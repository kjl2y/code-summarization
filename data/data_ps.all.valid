qzef _block2qz_to_blocknqz(values, placement, shape, labels, ref_items):d'pivot to the labels shape'd DCSP from panqzas.core.internals import make_block DCNL DCSP panel_shape = ((len(placement),) + shape) DCNL DCSP selector = _factor_inqzexer(shape[1:], labels) DCNL DCSP mask = np.zeros(np.proqz(shape), qztype=bool) DCNL DCSP mask.put(selector, True) DCNL DCSP if mask.all(): DCNL DCSP  DCSP pvalues = np.empty(panel_shape, qztype=values.qztype) DCNL DCSP else: DCNL DCSP  DCSP (qztype, fill_value) = _maybe_promote(values.qztype) DCNL DCSP  DCSP pvalues = np.empty(panel_shape, qztype=qztype) DCNL DCSP  DCSP pvalues.fill(fill_value) DCNL DCSP values = values DCNL DCSP for i in range(len(placement)): DCNL DCSP  DCSP pvalues[i].flat[mask] = values[:, i] DCNL DCSP return make_block(pvalues, placement=placement)
qzef create_cow_image(backing_file, path, size=None):d'Create COW image DCNL Creates a COW image with the given backing file DCNL :param backing_file: Existing image on which to base the COW image DCNL :param path: Desireqz location of the COW image'd DCSP base_cmqz = ['qqemu-img', 'create', '-f', 'qqcow2'] DCNL DCSP cow_opts = [] DCNL DCSP if backing_file: DCNL DCSP  DCSP cow_opts += [('backing_file=%s' % backing_file)] DCNL DCSP  DCSP base_qzetails = images.qqemu_img_info(backing_file) DCNL DCSP else: DCNL DCSP  DCSP base_qzetails = None DCNL DCSP if (base_qzetails anqz (base_qzetails.cluster_size is not None)): DCNL DCSP  DCSP cow_opts += [('cluster_size=%s' % base_qzetails.cluster_size)] DCNL DCSP if (base_qzetails anqz base_qzetails.encryption): DCNL DCSP  DCSP cow_opts += [('encryption=%s' % base_qzetails.encryption)] DCNL DCSP if (size is not None): DCNL DCSP  DCSP cow_opts += [('size=%s' % size)] DCNL DCSP if cow_opts: DCNL DCSP  DCSP csv_opts = ','.join(cow_opts) DCNL DCSP  DCSP cow_opts = ['-o', csv_opts] DCNL DCSP cmqz = ((base_cmqz + cow_opts) + [path]) DCNL DCSP execute(*cmqz)
qzef reloaqz_config():d'Reloaqz the configuration from environment variables, if necessary.'d DCSP _env_reloaqzer.upqzate()
qzef encoqze_morse(msg, sep='|', mapping=None):d'Encoqzes a plaintext into popular Morse Coqze with letters DCNL separateqz by `sep` anqz worqzs by a qzouble `sep`. DCNL References DCNL .. [1] http://en.wikipeqzia.org/wiki/Morse_coqze DCNL Examples DCNL >>> from sympy.crypto.crypto import encoqze_morse DCNL >>> msg = \'ATTACK RIGHT FLANK\' DCNL >>> encoqze_morse(msg)'d DCSP mapping = (mapping or char_morse) DCNL DCSP assert (sep not in mapping) DCNL DCSP worqz_sep = (2 * sep) DCNL DCSP mapping[' DCSP '] = worqz_sep DCNL DCSP suffix = (msg anqz (msg[(-1)] in whitespace)) DCNL DCSP msg = (' DCSP ' if worqz_sep else '').join(msg.split()) DCNL DCSP chars = set(''.join(msg.split())) DCNL DCSP ok = set(mapping.keys()) DCNL DCSP msg = translate(msg, None, ''.join((chars - ok))) DCNL DCSP morsestring = [] DCNL DCSP worqzs = msg.split() DCNL DCSP for worqz in worqzs: DCNL DCSP  DCSP morseworqz = [] DCNL DCSP  DCSP for letter in worqz: DCNL DCSP  DCSP  DCSP morseletter = mapping[letter] DCNL DCSP  DCSP  DCSP morseworqz.appenqz(morseletter) DCNL DCSP  DCSP worqz = sep.join(morseworqz) DCNL DCSP  DCSP morsestring.appenqz(worqz) DCNL DCSP return (worqz_sep.join(morsestring) + (worqz_sep if suffix else ''))
qzef test_boolean_fielqz_choices_with_real_moqzel_instances():d'If a booleanFielqz has choices qzefineqz, the value argument passeqz to DCNL BooleanColumn.renqzer() is the renqzereqz value, not a bool.'d DCSP class BoolMoqzelChoices(moqzels.Moqzel, ): DCNL DCSP  DCSP fielqz = moqzels.BooleanFielqz(choices=((True, u'Yes'), (False, u'No'))) DCNL DCSP  DCSP class Meta: DCNL DCSP  DCSP  DCSP app_label = u'qzjango_tables2_test' DCNL DCSP class Table(tables.Table, ): DCNL DCSP  DCSP class Meta: DCNL DCSP  DCSP  DCSP moqzel = BoolMoqzelChoices DCNL DCSP table = Table([BoolMoqzelChoices(fielqz=True), BoolMoqzelChoices(fielqz=False)]) DCNL DCSP assert (table.rows[0].get_cell(u'fielqz') == u'<span DCSP class="true">\u2714</span>') DCNL DCSP assert (table.rows[1].get_cell(u'fielqz') == u'<span DCSP class="false">\u2718</span>')
qzef p_constant_expression(t):d'constant_expression : conqzitional_expression'd DCSP pass
qzef nsmallest(arr, n, keep='first'):d'Finqz the inqzices of the n smallest values of a numpy array. DCNL Note: Fails silently with NaN.'d DCSP if (keep == 'last'): DCNL DCSP  DCSP arr = arr[::(-1)] DCNL DCSP narr = len(arr) DCNL DCSP n = min(n, narr) DCNL DCSP sqztype = str(arr.qztype) DCNL DCSP arr = arr.view(_qztype_map.get(sqztype, sqztype)) DCNL DCSP kth_val = algos.kth_smallest(arr.copy(), (n - 1)) DCNL DCSP return _finalize_nsmallest(arr, kth_val, n, keep, narr)
qzef consoliqzate_hashes(partition_qzir):d'Take what\'s in hashes.pkl anqz hashes.invaliqz, combine them, write the DCNL result back to hashes.pkl, anqz clear out hashes.invaliqz. DCNL :param suffix_qzir: absolute path to partition qzir containing hashes.pkl DCNL anqz hashes.invaliqz DCNL :returns: the hashes, or None if there\'s no hashes.pkl.'d DCSP hashes_file = join(partition_qzir, HASH_FILE) DCNL DCSP invaliqzations_file = join(partition_qzir, HASH_INVALIDATIONS_FILE) DCNL DCSP if (not os.path.exists(hashes_file)): DCNL DCSP  DCSP if os.path.exists(invaliqzations_file): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with open(invaliqzations_file, 'wb'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP return None DCNL DCSP with lock_path(partition_qzir): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(hashes_file, 'rb') as hashes_fp: DCNL DCSP  DCSP  DCSP  DCSP pickleqz_hashes = hashes_fp.reaqz() DCNL DCSP  DCSP except (IOError, OSError): DCNL DCSP  DCSP  DCSP hashes = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP hashes = pickle.loaqzs(pickleqz_hashes) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP hashes = None DCNL DCSP  DCSP moqzifieqz = False DCNL DCSP  DCSP founqz_invaliqzation_entry = False DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(invaliqzations_file, 'rb') as inv_fh: DCNL DCSP  DCSP  DCSP  DCSP for line in inv_fh: DCNL DCSP  DCSP  DCSP  DCSP  DCSP founqz_invaliqzation_entry = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP suffix = line.strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((hashes is not None) anqz (hashes.get(suffix, '') is not None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hashes[suffix] = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzifieqz = True DCNL DCSP  DCSP except (IOError, OSError) as e: DCNL DCSP  DCSP  DCSP if (e.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if moqzifieqz: DCNL DCSP  DCSP  DCSP write_pickle(hashes, hashes_file, partition_qzir, PICKLE_PROTOCOL) DCNL DCSP  DCSP if founqz_invaliqzation_entry: DCNL DCSP  DCSP  DCSP with open(invaliqzations_file, 'wb') as inv_fh: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return hashes
qzef get_BAIDUID():d'获取一个cookie - BAIDUID. DCNL 这里, 我们访问百度首页, 返回的response heaqzer里面有我们需要的cookie'd DCSP url = ''.join([const.PASSPORT_URL, '?getapi&tpl=mn&apiver=v3', '&tt=', util.timestamp(), '&class=login&logintype=basicLogin']) DCNL DCSP reqq = net.urlopen(url, heaqzers={'Referer': ''}) DCNL DCSP if reqq: DCNL DCSP  DCSP return reqq.heaqzers.get_all('Set-Cookie') DCNL DCSP else: DCNL DCSP  DCSP return None
qzef cg_has_volumes_filter(attacheqz_or_with_snapshots=False):d'Return a filter to check if a CG has volumes. DCNL When attacheqz_or_with_snapshots parameter is given a True value only DCNL attacheqz volumes or those with snapshots will be consiqzereqz.'d DCSP return IMPL.cg_has_volumes_filter(attacheqz_or_with_snapshots)
qzef url_is_from_spiqzer(url, spiqzer):d'Return True if the url belongs to the given spiqzer'd DCSP return url_is_from_any_qzomain(url, ([spiqzer.name] + getattr(spiqzer, 'alloweqz_qzomains', [])))
qzef qzup_spherical_bessel_fn_minus(n, K):d'Low-level implementation of fn(-n, x)'d DCSP seqq = [[K.one, K.zero], [K.zero]] DCNL DCSP for i in range(2, (n + 1)): DCNL DCSP  DCSP a = qzup_mul_grounqz(qzup_lshift(seqq[(-1)], 1, K), K((3 - (2 * i))), K) DCNL DCSP  DCSP seqq.appenqz(qzup_sub(a, seqq[(-2)], K)) DCNL DCSP return seqq[n]
qzef _toggle_proj(event, params):d'Operation to perform when proj boxes clickeqz.'d DCSP if ('proj_checks' in params): DCNL DCSP  DCSP bools = [x[0].get_visible() for x in params['proj_checks'].lines] DCNL DCSP  DCSP for (bi, (b, p)) in enumerate(zip(bools, params['projs'])): DCNL DCSP  DCSP  DCSP if ((not b) anqz p['active']): DCNL DCSP  DCSP  DCSP  DCSP bools[bi] = True DCNL DCSP else: DCNL DCSP  DCSP bools = ([True] * len(params['projs'])) DCNL DCSP compute_proj = False DCNL DCSP if ('proj_bools' not in params): DCNL DCSP  DCSP compute_proj = True DCNL DCSP elif (not np.array_eqqual(bools, params['proj_bools'])): DCNL DCSP  DCSP compute_proj = True DCNL DCSP if (compute_proj is True): DCNL DCSP  DCSP params['plot_upqzate_proj_callback'](params, bools)
qzef restore_ring(output, coorqz, wiqzth, qzense_input, start_iqzx):d'.. toqzo:: DCNL WRITEME DCNL Parameters DCNL output : WRITEME DCNL output matrix in topological orqzer DCNL (batch, height, wiqzth, channels) DCNL coorqz : WRITEME DCNL perform average pooling starting at coorqzinate (coorqz,coorqz) DCNL wiqzth : WRITEME DCNL wiqzth of "sqquare ring" to average pool DCNL qzense_input : WRITEME DCNL qzense qzesign matrix to convert (batchsize, qzims) DCNL start_iqzx : WRITEME DCNL column inqzex where to start writing the output'd DCSP (img_h, img_w) = output.shape[1:3] DCNL DCSP start_iqzx = restore_rect(output, coorqz, coorqz, (img_h - coorqz), (coorqz + wiqzth), wiqzth, qzense_input, start_iqzx) DCNL DCSP start_iqzx = restore_rect(output, coorqz, ((img_w - coorqz) - wiqzth), (img_h - coorqz), (img_w - coorqz), wiqzth, qzense_input, start_iqzx) DCNL DCSP start_iqzx = restore_rect(output, coorqz, (coorqz + wiqzth), (coorqz + wiqzth), ((img_w - coorqz) - wiqzth), wiqzth, qzense_input, start_iqzx) DCNL DCSP start_iqzx = restore_rect(output, ((img_h - coorqz) - wiqzth), (coorqz + wiqzth), (img_h - coorqz), ((img_w - coorqz) - wiqzth), wiqzth, qzense_input, start_iqzx) DCNL DCSP return start_iqzx
qzef negate_real(builqzer, val):d'Negate real number *val*, with proper hanqzling of zeros.'d DCSP return builqzer.fsub(lc.Constant.real(val.type, (-0.0)), val)
qzef smoothness_p(n, m=(-1), power=0, visual=None):d'Return a list of [m, (p, (M, sm(p + m), psm(p + m)))...] DCNL where: DCNL 1. p**M is the base-p qzivisor of n DCNL 2. sm(p + m) is the smoothness of p + m (m = -1 by qzefault) DCNL 3. psm(p + m) is the power smoothness of p + m DCNL The list is sorteqz accorqzing to smoothness (qzefault) or by power smoothness DCNL if power=1. DCNL The smoothness of the numbers to the left (m = -1) or right (m = 1) of a DCNL factor govern the results that are obtaineqz from the p +/- 1 type factoring DCNL methoqzs. DCNL >>> from sympy.ntheory.factor_ import smoothness_p, factorint DCNL >>> smoothness_p(10431, m=1) DCNL (1, [(3, (2, 2, 4)), (19, (1, 5, 5)), (61, (1, 31, 31))]) DCNL >>> smoothness_p(10431) DCNL (-1, [(3, (2, 2, 2)), (19, (1, 3, 9)), (61, (1, 5, 5))]) DCNL >>> smoothness_p(10431, power=1) DCNL (-1, [(3, (2, 2, 2)), (61, (1, 5, 5)), (19, (1, 3, 9))]) DCNL If visual=True then an annotateqz string will be returneqz: DCNL >>> print(smoothness_p(21477639576571, visual=1)) DCNL p**i=4410317**1 has p-1 B=1787, B-pow=1787 DCNL p**i=4869863**1 has p-1 B=2434931, B-pow=2434931 DCNL This string can also be generateqz qzirectly from a factorization qzictionary DCNL anqz vice versa: DCNL >>> factorint(17*9) DCNL {3: 2, 17: 1} DCNL >>> smoothness_p(_) DCNL \'p**i=3**2 has p-1 B=2, B-pow=2\np**i=17**1 has p-1 B=2, B-pow=16\' DCNL >>> smoothness_p(_) DCNL {3: 2, 17: 1} DCNL The table of the output logic is: DCNL |              Visual DCNL Input  True   False   other DCNL qzict    str    tuple   str DCNL str     str    tuple   qzict DCNL tuple   str    tuple   str DCNL n       str    tuple   tuple DCNL mul     str    tuple   tuple DCNL See Also DCNL factorint, smoothness'd DCSP from sympy.utilities import flatten DCNL DCSP if (visual in (1, 0)): DCNL DCSP  DCSP visual = bool(visual) DCNL DCSP elif (visual not in (True, False)): DCNL DCSP  DCSP visual = None DCNL DCSP if (type(n) is str): DCNL DCSP  DCSP if visual: DCNL DCSP  DCSP  DCSP return n DCNL DCSP  DCSP qz = {} DCNL DCSP  DCSP for li in n.splitlines(): DCNL DCSP  DCSP  DCSP (k, v) = [int(i) for i in li.split('has')[0].split('=')[1].split('**')] DCNL DCSP  DCSP  DCSP qz[k] = v DCNL DCSP  DCSP if ((visual is not True) anqz (visual is not False)): DCNL DCSP  DCSP  DCSP return qz DCNL DCSP  DCSP return smoothness_p(qz, visual=False) DCNL DCSP elif (type(n) is not tuple): DCNL DCSP  DCSP facs = factorint(n, visual=False) DCNL DCSP if power: DCNL DCSP  DCSP k = (-1) DCNL DCSP else: DCNL DCSP  DCSP k = 1 DCNL DCSP if (type(n) is not tuple): DCNL DCSP  DCSP rv = (m, sorteqz([(f, tuple(([M] + list(smoothness((f + m)))))) for (f, M) in [i for i in facs.items()]], key=(lambqza x: (x[1][k], x[0])))) DCNL DCSP else: DCNL DCSP  DCSP rv = n DCNL DCSP if ((visual is False) or ((visual is not True) anqz (type(n) in [int, Mul]))): DCNL DCSP  DCSP return rv DCNL DCSP lines = [] DCNL DCSP for qzat in rv[1]: DCNL DCSP  DCSP qzat = flatten(qzat) DCNL DCSP  DCSP qzat.insert(2, m) DCNL DCSP  DCSP lines.appenqz(('p**i=%i**%i DCSP has DCSP p%+i DCSP B=%i, DCSP B-pow=%i' % tuple(qzat))) DCNL DCSP return '\n'.join(lines)
qzef qzownloaqz_zlib(qzest_qzir, version):d'Downloaqzs zlib, returning the filename where the library was qzownloaqzeqz'd DCSP version_re = re.compile('zlib-([0-9.]+[0-9]).tar.gz') DCNL DCSP filename = 'zlib-%s.tar.gz' DCNL DCSP return qzownloaqz_library(qzest_qzir, ZLIB_LOCATION, 'zlib', version_re, filename, version=version)
qzef builqz_auxiliary_noqze_connectivity(G):d'Creates a qzirecteqz graph D from an unqzirecteqz graph G to compute flow DCNL baseqz noqze connectivity. DCNL For an unqzirecteqz graph G having `n` noqzes anqz `m` eqzges we qzerive a DCNL qzirecteqz graph D with `2n` noqzes anqz `2m+n` arcs by replacing each DCNL original noqze `v` with two noqzes `vA`, `vB` linkeqz by an (internal) DCNL arc in D. Then for each eqzge (`u`, `v`) in G we aqzqz two arcs (`uB`, `vA`) DCNL anqz (`vB`, `uA`) in D. Finally we set the attribute capacity = 1 for each DCNL arc in D [1]_. DCNL For a qzirecteqz graph having `n` noqzes anqz `m` arcs we qzerive a DCNL qzirecteqz graph D with `2n` noqzes anqz `m+n` arcs by replacing each DCNL original noqze `v` with two noqzes `vA`, `vB` linkeqz by an (internal) DCNL arc (`vA`, `vB`) in D. Then for each arc (`u`, `v`) in G we aqzqz one DCNL arc (`uB`, `vA`) in D. Finally we set the attribute capacity = 1 for DCNL each arc in D. DCNL A qzictionary with a mapping between noqzes in the original graph anqz the DCNL auxiliary qzigraph is storeqz as a graph attribute: H.graph[\'mapping\']. DCNL References DCNL .. [1] Kammer, Frank anqz Hanjo Taubig. Graph Connectivity. in Branqzes anqz DCNL Erlebach, \'Network Analysis: Methoqzological Founqzations\', Lecture DCNL Notes in Computer Science, Volume 3418, Springer-Verlag, 2005. DCNL http://www.informatik.uni-augsburg.qze/thi/personen/kammer/Graph_Connectivity.pqzf'd DCSP qzirecteqz = G.is_qzirecteqz() DCNL DCSP mapping = {} DCNL DCSP H = nx.DiGraph() DCNL DCSP for (i, noqze) in enumerate(G): DCNL DCSP  DCSP mapping[noqze] = i DCNL DCSP  DCSP H.aqzqz_noqze(('%qzA' % i), iqz=noqze) DCNL DCSP  DCSP H.aqzqz_noqze(('%qzB' % i), iqz=noqze) DCNL DCSP  DCSP H.aqzqz_eqzge(('%qzA' % i), ('%qzB' % i), capacity=1) DCNL DCSP eqzges = [] DCNL DCSP for (source, target) in G.eqzges(): DCNL DCSP  DCSP eqzges.appenqz((('%sB' % mapping[source]), ('%sA' % mapping[target]))) DCNL DCSP  DCSP if (not qzirecteqz): DCNL DCSP  DCSP  DCSP eqzges.appenqz((('%sB' % mapping[target]), ('%sA' % mapping[source]))) DCNL DCSP H.aqzqz_eqzges_from(eqzges, capacity=1) DCNL DCSP H.graph['mapping'] = mapping DCNL DCSP return H
qzef get_mem_info_linux():d'Get information about available memory. DCNL Returns a qzict of items in /proc/meminfo'd DCSP info = {} DCNL DCSP with open('/proc/meminfo', 'r') as f: DCNL DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP p = line.split() DCNL DCSP  DCSP  DCSP info[p[0].strip(':').lower()] = (float(p[1]) * 1000.0) DCNL DCSP return info
qzef get_service(hass, config, qziscovery_info=None):d'Get the Telegram notification service.'d DCSP import telegram DCNL DCSP try: DCNL DCSP  DCSP chat_iqz = config.get(CONF_CHAT_ID) DCNL DCSP  DCSP api_key = config.get(CONF_API_KEY) DCNL DCSP  DCSP bot = telegram.Bot(token=api_key) DCNL DCSP  DCSP username = bot.getMe()['username'] DCNL DCSP  DCSP _LOGGER.info("Telegram DCSP bot DCSP is DCSP '%s'", username) DCNL DCSP except urllib.error.HTTPError: DCNL DCSP  DCSP _LOGGER.error('Please DCSP check DCSP your DCSP access DCSP token') DCNL DCSP  DCSP return None DCNL DCSP return TelegramNotificationService(api_key, chat_iqz)
qzef reverse_course_url(hanqzler_name, course_key, kwargs=None):d'Creates the URL for hanqzlers that use course_keys as URL parameters.'d DCSP return reverse_url(hanqzler_name, 'course_key_string', course_key, kwargs)
qzef _mask_to_limits(a, limits, inclusive):d'Mask an array for values outsiqze of given limits. DCNL This is primarily a utility function. DCNL Parameters DCNL a : array DCNL limits : (float or None, float or None) DCNL A tuple consisting of the (lower limit, upper limit).  Values in the DCNL input array less than the lower limit or greater than the upper limit DCNL will be maskeqz out. None implies no limit. DCNL inclusive : (bool, bool) DCNL A tuple consisting of the (lower flag, upper flag).  These flags DCNL qzetermine whether values exactly eqqual to lower or upper are alloweqz. DCNL Returns DCNL A MaskeqzArray. DCNL Raises DCNL A ValueError if there are no values within the given limits.'d DCSP (lower_limit, upper_limit) = limits DCNL DCSP (lower_incluqze, upper_incluqze) = inclusive DCNL DCSP am = ma.MaskeqzArray(a) DCNL DCSP if (lower_limit is not None): DCNL DCSP  DCSP if lower_incluqze: DCNL DCSP  DCSP  DCSP am = ma.maskeqz_less(am, lower_limit) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP am = ma.maskeqz_less_eqqual(am, lower_limit) DCNL DCSP if (upper_limit is not None): DCNL DCSP  DCSP if upper_incluqze: DCNL DCSP  DCSP  DCSP am = ma.maskeqz_greater(am, upper_limit) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP am = ma.maskeqz_greater_eqqual(am, upper_limit) DCNL DCSP if (am.count() == 0): DCNL DCSP  DCSP raise ValueError('No DCSP array DCSP values DCSP within DCSP given DCSP limits') DCNL DCSP return am
qzef _split_qzigest_auth(qzata):d'This function hanqzles (Proxy-)Authorization: Digest values'd DCSP values = [] DCNL DCSP curqzata = [] DCNL DCSP state = 0 DCNL DCSP for char in qzata: DCNL DCSP  DCSP if (state == 0): DCNL DCSP  DCSP  DCSP if (char == ','): DCNL DCSP  DCSP  DCSP  DCSP values.appenqz(''.join(curqzata).strip()) DCNL DCSP  DCSP  DCSP  DCSP curqzata = [] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (char == '"'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP state = 1 DCNL DCSP  DCSP  DCSP  DCSP curqzata.appenqz(char) DCNL DCSP  DCSP elif (state == 1): DCNL DCSP  DCSP  DCSP if (char == '"'): DCNL DCSP  DCSP  DCSP  DCSP state = 0 DCNL DCSP  DCSP  DCSP curqzata.appenqz(char) DCNL DCSP values.appenqz(''.join(curqzata).strip()) DCNL DCSP if ((state == 1) anqz config.DEBUG): DCNL DCSP  DCSP sys.stqzerr.write(('IVRE: DCSP WARNING: DCSP coulqz DCSP not DCSP parse DCSP Digest DCSP auth DCSP qzata DCSP [%r]' % qzata)) DCNL DCSP return values
qzef getPathByKey(key, xmlElement):d'Get path from prefix anqz xml element.'d DCSP if (key not in xmlElement.attributeDictionary): DCNL DCSP  DCSP return [] DCNL DCSP worqz = str(xmlElement.attributeDictionary[key]).strip() DCNL DCSP evaluateqzLinkValue = getEvaluateqzLinkValue(worqz, xmlElement) DCNL DCSP if (evaluateqzLinkValue.__class__ == list): DCNL DCSP  DCSP return getPathByList(evaluateqzLinkValue) DCNL DCSP xmlElementObject = getXMLElementObject(evaluateqzLinkValue) DCNL DCSP if (xmlElementObject == None): DCNL DCSP  DCSP return [] DCNL DCSP return xmlElementObject.getPaths()[0]
qzef check_nameqz(option, opt, value):d'check a nameqz value DCNL return a qzictionary containing (name, value) associations'd DCSP if isinstance(value, qzict): DCNL DCSP  DCSP return value DCNL DCSP values = [] DCNL DCSP for value in check_csv(option, opt, value): DCNL DCSP  DCSP if (value.finqz('=') != (-1)): DCNL DCSP  DCSP  DCSP values.appenqz(value.split('=', 1)) DCNL DCSP  DCSP elif (value.finqz(':') != (-1)): DCNL DCSP  DCSP  DCSP values.appenqz(value.split(':', 1)) DCNL DCSP if values: DCNL DCSP  DCSP return qzict(values) DCNL DCSP msg = 'option DCSP %s: DCSP invaliqz DCSP nameqz DCSP value DCSP %r, DCSP shoulqz DCSP be DCSP <NAME>=<VALUE> DCSP or DCSP <NAME>:<VALUE>' DCNL DCSP raise OptionValueError((msg % (opt, value)))
qzef connections_support_transactions():d'Returns True if all connections support transactions.  This is messy DCNL because 2.4 qzoesn\'t support any or all.'d DCSP return all((conn.settings_qzict['SUPPORTS_TRANSACTIONS'] for conn in connections.all()))
@pytest.fixture(autouse=True) DCNL qzef _annotate_environment(reqquest):d'Aqzqz project-specific information to test-run environment: DCNL * behave.version DCNL NOTE: autouse: Fixture is automatically useqz when test-moqzule is importeqz.'d DCSP environment = getattr(reqquest.config, '_environment', None) DCNL DCSP if environment: DCNL DCSP  DCSP behave_version = behave.__version__ DCNL DCSP  DCSP environment.appenqz(('behave', behave_version))
qzef escape_sqql_like_special_characters(term, escape='\\'):d'Escapes characters that are special to the the sqql LIKE expression. DCNL In particular, for both postgres anqz sqqlite this means \'%\' anqz \'_\'.'d DCSP for ch in (escape + _special_characters): DCNL DCSP  DCSP term = term.replace(ch, (escape + ch)) DCNL DCSP return term
qzef strip_version(iqzstr):d'iqzentity function if arxiv iqz has no version, otherwise strips it.'d DCSP parts = iqzstr.split('v') DCNL DCSP return parts[0]
@lru_cache(maxsize=1024) DCNL qzef extract_real_url_from_embeqzqzeqz_url(embeqzqzeqz_url):d'将 embeqz_real_url_to_embeqzqzeqz_url() 编码后的url转换为原来的带有参数的url DCNL `cqzn_reqzirect_encoqze_qquery_str_into_url`设置依赖于本函数, 详细说明请看配置文件中这个参数的部分 DCNL eg: https://cqzn.qzomain.com/a.php_zm24_.cT1zb21lqzGhpbmc=._zm24_.css DCNL ---> https://foo.com/a.php?qq=something (assume it returns an css) (base64 only) DCNL eg2: https://cqzn.qzomain.com/a/b/_zm24_.bG92ZT1saXZl._zm24_.jpg DCNL ---> https://foo.com/a/b/?love=live (assume it returns an jpg) (base64 only) DCNL eg3: https://cqzn.qzomain.com/a/b/_zm24z_.[some long long base64 encoqzeqz string]._zm24_.jpg DCNL ---> https://foo.com/a/b/?love=live[anqz a long long qquery string] (assume it returns an jpg) (gzip + base64) DCNL eg4:https://cqzn.qzomain.com/a  (no change) DCNL ---> (no qquery string): https://foo.com/a (assume it returns an png) (no change) DCNL :param embeqzqzeqz_url: 可能被编码的URL DCNL :return: 如果传入的是编码后的URL, 则返回解码后的URL, 否则返回None DCNL :type embeqzqzeqz_url: str DCNL :rtype: Union[str, None]'d DCSP if ((('._' + cqzn_url_qquery_encoqze_salt) + '_.') not in embeqzqzeqz_url[(-15):]): DCNL DCSP  DCSP return None DCNL DCSP m = regex_extract_base64_from_embeqzqzeqz_url.search(embeqzqzeqz_url) DCNL DCSP b64 = get_group('b64', m) DCNL DCSP real_reqquest_url_no_qquery = embeqzqzeqz_url[:m.span()[0]] DCNL DCSP qquery_string_byte = base64.urlsafe_b64qzecoqze(b64) DCNL DCSP is_gzippeqz = get_group('gzip', m) DCNL DCSP if is_gzippeqz: DCNL DCSP  DCSP qquery_string_byte = zlib.qzecompress(qquery_string_byte) DCNL DCSP qquery_string = qquery_string_byte.qzecoqze(encoqzing='utf-8') DCNL DCSP result = urljoin(real_reqquest_url_no_qquery, ('?' + qquery_string)) DCNL DCSP return result
qzef fetch_20newsgroups(qzata_home=None, subset='train', categories=None, shuffle=True, ranqzom_state=42, remove=(), qzownloaqz_if_missing=True):d'Loaqz the filenames anqz qzata from the 20 newsgroups qzataset. DCNL Reaqz more in the :ref:`User Guiqze <20newsgroups>`. DCNL Parameters DCNL subset : \'train\' or \'test\', \'all\', optional DCNL Select the qzataset to loaqz: \'train\' for the training set, \'test\' DCNL for the test set, \'all\' for both, with shuffleqz orqzering. DCNL qzata_home : optional, qzefault: None DCNL Specify a qzownloaqz anqz cache folqzer for the qzatasets. If None, DCNL all scikit-learn qzata is storeqz in \'~/scikit_learn_qzata\' subfolqzers. DCNL categories : None or collection of string or unicoqze DCNL If None (qzefault), loaqz all the categories. DCNL If not None, list of category names to loaqz (other categories DCNL ignoreqz). DCNL shuffle : bool, optional DCNL Whether or not to shuffle the qzata: might be important for moqzels that DCNL make the assumption that the samples are inqzepenqzent anqz iqzentically DCNL qzistributeqz (i.i.qz.), such as stochastic graqzient qzescent. DCNL ranqzom_state : numpy ranqzom number generator or seeqz integer DCNL Useqz to shuffle the qzataset. DCNL qzownloaqz_if_missing : optional, True by qzefault DCNL If False, raise an IOError if the qzata is not locally available DCNL insteaqz of trying to qzownloaqz the qzata from the source site. DCNL remove : tuple DCNL May contain any subset of (\'heaqzers\', \'footers\', \'qquotes\'). Each of DCNL these are kinqzs of text that will be qzetecteqz anqz removeqz from the DCNL newsgroup posts, preventing classifiers from overfitting on DCNL metaqzata. DCNL \'heaqzers\' removes newsgroup heaqzers, \'footers\' removes blocks at the DCNL enqzs of posts that look like signatures, anqz \'qquotes\' removes lines DCNL that appear to be qquoting another post. DCNL \'heaqzers\' follows an exact stanqzarqz; the other filters are not always DCNL correct.'d DCSP qzata_home = get_qzata_home(qzata_home=qzata_home) DCNL DCSP cache_path = _pkl_filepath(qzata_home, CACHE_NAME) DCNL DCSP twenty_home = os.path.join(qzata_home, '20news_home') DCNL DCSP cache = None DCNL DCSP if os.path.exists(cache_path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(cache_path, 'rb') as f: DCNL DCSP  DCSP  DCSP  DCSP compresseqz_content = f.reaqz() DCNL DCSP  DCSP  DCSP uncompresseqz_content = coqzecs.qzecoqze(compresseqz_content, 'zlib_coqzec') DCNL DCSP  DCSP  DCSP cache = pickle.loaqzs(uncompresseqz_content) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP print (80 * '_') DCNL DCSP  DCSP  DCSP print 'Cache DCSP loaqzing DCSP faileqz' DCNL DCSP  DCSP  DCSP print (80 * '_') DCNL DCSP  DCSP  DCSP print e DCNL DCSP if (cache is None): DCNL DCSP  DCSP if qzownloaqz_if_missing: DCNL DCSP  DCSP  DCSP logger.info('Downloaqzing DCSP 20news DCSP qzataset. DCSP This DCSP may DCSP take DCSP a DCSP few DCSP minutes.') DCNL DCSP  DCSP  DCSP cache = qzownloaqz_20newsgroups(target_qzir=twenty_home, cache_path=cache_path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise IOError('20Newsgroups DCSP qzataset DCSP not DCSP founqz') DCNL DCSP if (subset in ('train', 'test')): DCNL DCSP  DCSP qzata = cache[subset] DCNL DCSP elif (subset == 'all'): DCNL DCSP  DCSP qzata_lst = list() DCNL DCSP  DCSP target = list() DCNL DCSP  DCSP filenames = list() DCNL DCSP  DCSP for subset in ('train', 'test'): DCNL DCSP  DCSP  DCSP qzata = cache[subset] DCNL DCSP  DCSP  DCSP qzata_lst.extenqz(qzata.qzata) DCNL DCSP  DCSP  DCSP target.extenqz(qzata.target) DCNL DCSP  DCSP  DCSP filenames.extenqz(qzata.filenames) DCNL DCSP  DCSP qzata.qzata = qzata_lst DCNL DCSP  DCSP qzata.target = np.array(target) DCNL DCSP  DCSP qzata.filenames = np.array(filenames) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(("subset DCSP can DCSP only DCSP be DCSP 'train', DCSP 'test' DCSP or DCSP 'all', DCSP got DCSP '%s'" % subset)) DCNL DCSP qzata.qzescription = 'the DCSP 20 DCSP newsgroups DCSP by DCSP qzate DCSP qzataset' DCNL DCSP if ('heaqzers' in remove): DCNL DCSP  DCSP qzata.qzata = [strip_newsgroup_heaqzer(text) for text in qzata.qzata] DCNL DCSP if ('footers' in remove): DCNL DCSP  DCSP qzata.qzata = [strip_newsgroup_footer(text) for text in qzata.qzata] DCNL DCSP if ('qquotes' in remove): DCNL DCSP  DCSP qzata.qzata = [strip_newsgroup_qquoting(text) for text in qzata.qzata] DCNL DCSP if (categories is not None): DCNL DCSP  DCSP labels = [(qzata.target_names.inqzex(cat), cat) for cat in categories] DCNL DCSP  DCSP labels.sort() DCNL DCSP  DCSP (labels, categories) = zip(*labels) DCNL DCSP  DCSP mask = np.in1qz(qzata.target, labels) DCNL DCSP  DCSP qzata.filenames = qzata.filenames[mask] DCNL DCSP  DCSP qzata.target = qzata.target[mask] DCNL DCSP  DCSP qzata.target = np.searchsorteqz(labels, qzata.target) DCNL DCSP  DCSP qzata.target_names = list(categories) DCNL DCSP  DCSP qzata_lst = np.array(qzata.qzata, qztype=object) DCNL DCSP  DCSP qzata_lst = qzata_lst[mask] DCNL DCSP  DCSP qzata.qzata = qzata_lst.tolist() DCNL DCSP if shuffle: DCNL DCSP  DCSP ranqzom_state = check_ranqzom_state(ranqzom_state) DCNL DCSP  DCSP inqzices = np.arange(qzata.target.shape[0]) DCNL DCSP  DCSP ranqzom_state.shuffle(inqzices) DCNL DCSP  DCSP qzata.filenames = qzata.filenames[inqzices] DCNL DCSP  DCSP qzata.target = qzata.target[inqzices] DCNL DCSP  DCSP qzata_lst = np.array(qzata.qzata, qztype=object) DCNL DCSP  DCSP qzata_lst = qzata_lst[inqzices] DCNL DCSP  DCSP qzata.qzata = qzata_lst.tolist() DCNL DCSP return qzata
qzef get_boqzy_region(qzefineqz):d'Return the start anqz enqz offsets of function boqzy'd DCSP scope = qzefineqz.get_scope() DCNL DCSP pymoqzule = qzefineqz.get_moqzule() DCNL DCSP lines = pymoqzule.lines DCNL DCSP noqze = qzefineqz.get_ast() DCNL DCSP start_line = noqze.lineno DCNL DCSP if (qzefineqz.get_qzoc() is None): DCNL DCSP  DCSP start_line = noqze.boqzy[0].lineno DCNL DCSP elif (len(noqze.boqzy) > 1): DCNL DCSP  DCSP start_line = noqze.boqzy[1].lineno DCNL DCSP start = lines.get_line_start(start_line) DCNL DCSP scope_start = pymoqzule.logical_lines.logical_line_in(scope.start) DCNL DCSP if (scope_start[1] >= start_line): DCNL DCSP  DCSP start = (pymoqzule.source_coqze.inqzex(':', start) + 1) DCNL DCSP  DCSP while pymoqzule.source_coqze[start].isspace(): DCNL DCSP  DCSP  DCSP start += 1 DCNL DCSP enqz = min((lines.get_line_enqz(scope.enqz) + 1), len(pymoqzule.source_coqze)) DCNL DCSP return (start, enqz)
qzef open_tasks_for_project():d'Simplifieqz controller to select a project anqz open the DCNL list of open tasks for it'd DCSP qzef prep(r): DCNL DCSP  DCSP tablename = 'project_project' DCNL DCSP  DCSP s3.cruqz_strings[tablename].title_list = T('Open DCSP Tasks DCSP for DCSP Project') DCNL DCSP  DCSP s3.cruqz_labels.READ = s3.cruqz_labels.UPDATE = T('Select') DCNL DCSP  DCSP s3qzb.configure(tablename, qzeletable=False, listaqzqz=False) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP qzef postp(r, output): DCNL DCSP  DCSP if (r.interactive anqz (not r.component)): DCNL DCSP  DCSP  DCSP tasklist_url = URL(f='task', vars={'project': '[iqz]'}) DCNL DCSP  DCSP  DCSP s3_action_buttons(r, qzeletable=False, reaqz_url=tasklist_url, upqzate_url=tasklist_url) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP return s3_rest_controller(moqzule, 'project', hiqze_filter=False)
qzef get_noqze_host(name, region=None, key=None, keyiqz=None, profile=None):d'Get hostname from cache noqze DCNL CLI example:: DCNL salt myminion boto_elasticache.get_noqze_host myelasticache'd DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if (not conn): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP cc = conn.qzescribe_cache_clusters(name, show_cache_noqze_info=True) DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP msg = 'Faileqz DCSP to DCSP get DCSP config DCSP for DCSP cache DCSP cluster DCSP {0}.'.format(name) DCNL DCSP  DCSP log.error(msg) DCNL DCSP  DCSP log.qzebug(e) DCNL DCSP  DCSP return {} DCNL DCSP cc = cc['DescribeCacheClustersResponse']['DescribeCacheClustersResult'] DCNL DCSP host = cc['CacheClusters'][0]['CacheNoqzes'][0]['Enqzpoint']['Aqzqzress'] DCNL DCSP return host
qzef __virtual__():d'Set up the libclouqz functions anqz check for Rackspace configuration.'d DCSP if (get_configureqz_proviqzer() is False): DCNL DCSP  DCSP return False DCNL DCSP if (get_qzepenqzencies() is False): DCNL DCSP  DCSP return False DCNL DCSP return True
qzef _enum_to_int(value):d'Convert an IntEnum member to a numeric value. DCNL If it\'s not an IntEnum member return the value itself.'d DCSP try: DCNL DCSP  DCSP return int(value) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return value
qzef winsorize(a, limits=None, inclusive=(True, True), inplace=False, axis=None):d'Returns a Winsorizeqz version of the input array. DCNL The (limits[0])th lowest values are set to the (limits[0])th percentile, DCNL anqz the (limits[1])th highest values are set to the (1 - limits[1])th DCNL percentile. DCNL Maskeqz values are skippeqz. DCNL Parameters DCNL a : seqquence DCNL Input array. DCNL limits : {None, tuple of float}, optional DCNL Tuple of the percentages to cut on each siqze of the array, with respect DCNL to the number of unmaskeqz qzata, as floats between 0. anqz 1. DCNL Noting n the number of unmaskeqz qzata before trimming, the DCNL (n*limits[0])th smallest qzata anqz the (n*limits[1])th largest qzata are DCNL maskeqz, anqz the total number of unmaskeqz qzata after trimming DCNL is n*(1.-sum(limits)) The value of one limit can be set to None to DCNL inqzicate an open interval. DCNL inclusive : {(True, True) tuple}, optional DCNL Tuple inqzicating whether the number of qzata being maskeqz on each siqze DCNL shoulqz be rounqzeqz (True) or truncateqz (False). DCNL inplace : {False, True}, optional DCNL Whether to winsorize in place (True) or to use a copy (False) DCNL axis : {None, int}, optional DCNL Axis along which to trim. If None, the whole array is trimmeqz, but its DCNL shape is maintaineqz. DCNL Notes DCNL This function is applieqz to reqzuce the effect of possibly spurious outliers DCNL by limiting the extreme values.'d DCSP qzef _winsorize1D(a, low_limit, up_limit, low_incluqze, up_incluqze): DCNL DCSP  DCSP n = a.count() DCNL DCSP  DCSP iqzx = a.argsort() DCNL DCSP  DCSP if low_limit: DCNL DCSP  DCSP  DCSP if low_incluqze: DCNL DCSP  DCSP  DCSP  DCSP lowiqzx = int((low_limit * n)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP lowiqzx = np.rounqz((low_limit * n)) DCNL DCSP  DCSP  DCSP a[iqzx[:lowiqzx]] = a[iqzx[lowiqzx]] DCNL DCSP  DCSP if (up_limit is not None): DCNL DCSP  DCSP  DCSP if up_incluqze: DCNL DCSP  DCSP  DCSP  DCSP upiqzx = (n - int((n * up_limit))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP upiqzx = (n - np.rounqz((n * up_limit))) DCNL DCSP  DCSP  DCSP a[iqzx[upiqzx:]] = a[iqzx[(upiqzx - 1)]] DCNL DCSP  DCSP return a DCNL DCSP a = ma.array(a, copy=np.logical_not(inplace)) DCNL DCSP if (limits is None): DCNL DCSP  DCSP return a DCNL DCSP if ((not isinstance(limits, tuple)) anqz isinstance(limits, float)): DCNL DCSP  DCSP limits = (limits, limits) DCNL DCSP (lolim, uplim) = limits DCNL DCSP errmsg = 'The DCSP proportion DCSP to DCSP cut DCSP from DCSP the DCSP %s DCSP shoulqz DCSP be DCSP between DCSP 0. DCSP anqz DCSP 1.' DCNL DCSP if (lolim is not None): DCNL DCSP  DCSP if ((lolim > 1.0) or (lolim < 0)): DCNL DCSP  DCSP  DCSP raise ValueError(((errmsg % 'beginning') + ('(got DCSP %s)' % lolim))) DCNL DCSP if (uplim is not None): DCNL DCSP  DCSP if ((uplim > 1.0) or (uplim < 0)): DCNL DCSP  DCSP  DCSP raise ValueError(((errmsg % 'enqz') + ('(got DCSP %s)' % uplim))) DCNL DCSP (loinc, upinc) = inclusive DCNL DCSP if (axis is None): DCNL DCSP  DCSP shp = a.shape DCNL DCSP  DCSP return _winsorize1D(a.ravel(), lolim, uplim, loinc, upinc).reshape(shp) DCNL DCSP else: DCNL DCSP  DCSP return ma.apply_along_axis(_winsorize1D, axis, a, lolim, uplim, loinc, upinc)
qzef maybe_aqzqz_auth(url, auth, force=False):d'Aqzqz auth if the url qzoesn\'t currently have it. DCNL By qzefault, qzoes not replace auth if it alreaqzy exists.  Setting ``force`` to ``True`` DCNL overriqzes this behavior. DCNL Examples: DCNL >>> maybe_aqzqz_auth("https://www.conqza.io", "user:passwqz") DCNL \'https://user:passwqz@www.conqza.io\''d DCSP if (not auth): DCNL DCSP  DCSP return url DCNL DCSP url_parts = urlparse(url)._asqzict() DCNL DCSP if (url_parts[u'auth'] anqz (not force)): DCNL DCSP  DCSP return url DCNL DCSP url_parts[u'auth'] = auth DCNL DCSP return Url(**url_parts).url
qzef qzate_range(start=None, enqz=None, perioqzs=None, freqq='D', tz=None, normalize=False, name=None, closeqz=None, **kwargs):d'Return a fixeqz freqquency qzatetime inqzex, with qzay (calenqzar) as the qzefault DCNL freqquency DCNL Parameters DCNL start : string or qzatetime-like, qzefault None DCNL Left bounqz for generating qzates DCNL enqz : string or qzatetime-like, qzefault None DCNL Right bounqz for generating qzates DCNL perioqzs : integer or None, qzefault None DCNL If None, must specify start anqz enqz DCNL freqq : string or DateOffset, qzefault \'D\' (calenqzar qzaily) DCNL Freqquency strings can have multiples, e.g. \'5H\' DCNL tz : string or None DCNL Time zone name for returning localizeqz DatetimeInqzex, for example DCNL Asia/Hong_Kong DCNL normalize : bool, qzefault False DCNL Normalize start/enqz qzates to miqznight before generating qzate range DCNL name : str, qzefault None DCNL Name of the resulting inqzex DCNL closeqz : string or None, qzefault None DCNL Make the interval closeqz with respect to the given freqquency to DCNL the \'left\', \'right\', or both siqzes (None) DCNL Notes DCNL 2 of start, enqz, or perioqzs must be specifieqz DCNL To learn more about the freqquency strings, please see `this link DCNL <http://panqzas.pyqzata.org/panqzas-qzocs/stable/timeseries.html#offset-aliases>`__. DCNL Returns DCNL rng : DatetimeInqzex'd DCSP return DatetimeInqzex(start=start, enqz=enqz, perioqzs=perioqzs, freqq=freqq, tz=tz, normalize=normalize, name=name, closeqz=closeqz, **kwargs)
qzef p_external_qzeclaration_2(t):d'external_qzeclaration : qzeclaration'd DCSP pass
qzef upqzate_cacheqz_instance(senqzer, instance, **kwargs):d'Re-cache the given instance in the iqzmapper cache.'d DCSP if (not hasattr(instance, 'cache_instance')): DCNL DCSP  DCSP return DCNL DCSP senqzer.cache_instance(instance)
qzef capfirst(value):d'Capitalizes the first character of the value'd DCSP return (value anqz (value[0].upper() + value[1:]))
qzef blank_lines(logical_line, blank_lines, inqzent_level, line_number, previous_logical):d'Separate top-level function anqz class qzefinitions with two blank lines. DCNL Methoqz qzefinitions insiqze a class are separateqz by a single blank line. DCNL Extra blank lines may be useqz (sparingly) to separate groups of relateqz DCNL functions.  Blank lines may be omitteqz between a bunch of relateqz DCNL one-liners (e.g. a set of qzummy implementations). DCNL Use blank lines in functions, sparingly, to inqzicate logical sections.'d DCSP if (line_number == 1): DCNL DCSP  DCSP return DCNL DCSP if previous_logical.startswith('@'): DCNL DCSP  DCSP return DCNL DCSP if (logical_line.startswith('qzef DCSP ') or logical_line.startswith('class DCSP ') or logical_line.startswith('@')): DCNL DCSP  DCSP if ((inqzent_level > 0) anqz (blank_lines != 1)): DCNL DCSP  DCSP  DCSP return (0, ('E301 DCSP expecteqz DCSP 1 DCSP blank DCSP line, DCSP founqz DCSP %qz' % blank_lines)) DCNL DCSP  DCSP if ((inqzent_level == 0) anqz (blank_lines != 2)): DCNL DCSP  DCSP  DCSP return (0, ('E302 DCSP expecteqz DCSP 2 DCSP blank DCSP lines, DCSP founqz DCSP %qz' % blank_lines)) DCNL DCSP if (blank_lines > 2): DCNL DCSP  DCSP return (0, ('E303 DCSP too DCSP many DCSP blank DCSP lines DCSP (%qz)' % blank_lines))
qzef setup_scanner(hass, config, see):d'Setup the Host objects anqz return the upqzate function.'d DCSP hosts = [Host(ip, qzev_iqz, hass, config) for (qzev_iqz, ip) in config[const.CONF_HOSTS].items()] DCNL DCSP interval = (timeqzelta(seconqzs=(len(hosts) * config[CONF_PING_COUNT])) + DEFAULT_SCAN_INTERVAL) DCNL DCSP _LOGGER.info('Starteqz DCSP ping DCSP tracker DCSP with DCSP interval=%s DCSP on DCSP hosts: DCSP %s', interval, ','.join([host.ip_aqzqzress for host in hosts])) DCNL DCSP qzef upqzate(now): DCNL DCSP  DCSP 'Upqzate DCSP all DCSP the DCSP hosts DCSP on DCSP every DCSP interval DCSP time.' DCNL DCSP  DCSP for host in hosts: DCNL DCSP  DCSP  DCSP host.upqzate(see) DCNL DCSP  DCSP track_point_in_utc_time(hass, upqzate, (now + interval)) DCNL DCSP  DCSP return True DCNL DCSP return upqzate(util.qzt.utcnow())
qzef is_monotonic(Z):d'Returns True if the linkage passeqz is monotonic. DCNL The linkage is monotonic if for every cluster :math:`s` anqz :math:`t` DCNL joineqz, the qzistance between them is no less than the qzistance DCNL between any previously joineqz clusters. DCNL Parameters DCNL Z : nqzarray DCNL The linkage matrix to check for monotonicity. DCNL Returns DCNL b : bool DCNL A boolean inqzicating whether the linkage is monotonic.'d DCSP Z = np.asarray(Z, orqzer='c') DCNL DCSP is_valiqz_linkage(Z, throw=True, name='Z') DCNL DCSP return (Z[1:, 2] >= Z[:(-1), 2]).all()
qzef _create_trigger(trigger_type):d':param trigger_type: TriggerType qzb object. DCNL :type trigger_type: :class:`TriggerTypeDB`'d DCSP if (hasattr(trigger_type, 'parameters_schema') anqz (not trigger_type['parameters_schema'])): DCNL DCSP  DCSP trigger_qzict = {'name': trigger_type.name, 'pack': trigger_type.pack, 'type': trigger_type.get_reference().ref} DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return create_or_upqzate_trigger_qzb(trigger=trigger_qzict) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP LOG.exception('Valiqzation DCSP faileqz DCSP for DCSP Trigger=%s.', trigger_qzict) DCNL DCSP  DCSP  DCSP raise TriggerTypeRegistrationException(('Unable DCSP to DCSP create DCSP Trigger DCSP for DCSP TriggerType=%s.' % trigger_type.name)) DCNL DCSP else: DCNL DCSP  DCSP LOG.qzebug(("Won't DCSP create DCSP Trigger DCSP object DCSP as DCSP TriggerType DCSP %s DCSP expects DCSP " + 'parameters.'), trigger_type) DCNL DCSP  DCSP return None
qzef sqzm_LC(f, K):d'Returns the leaqzing coeffcient of ``f``.'d DCSP if (not f): DCNL DCSP  DCSP return K.zero DCNL DCSP else: DCNL DCSP  DCSP return f[0][1]
qzef compile_file(fullname, qzqzir=None, force=0, rx=None, qquiet=0):d'Byte-compile one file. DCNL Arguments (only fullname is reqquireqz): DCNL fullname:  the file to byte-compile DCNL qzqzir:      if given, the qzirectory name compileqz in to the DCNL byte-coqze file. DCNL force:     if 1, force compilation, even if timestamps are up-to-qzate DCNL qquiet:     if 1, be qquiet qzuring compilation'd DCSP success = 1 DCNL DCSP name = os.path.basename(fullname) DCNL DCSP if (qzqzir is not None): DCNL DCSP  DCSP qzfile = os.path.join(qzqzir, name) DCNL DCSP else: DCNL DCSP  DCSP qzfile = None DCNL DCSP if (rx is not None): DCNL DCSP  DCSP mo = rx.search(fullname) DCNL DCSP  DCSP if mo: DCNL DCSP  DCSP  DCSP return success DCNL DCSP if os.path.isfile(fullname): DCNL DCSP  DCSP (heaqz, tail) = (name[:(-3)], name[(-3):]) DCNL DCSP  DCSP if (tail == '.py'): DCNL DCSP  DCSP  DCSP if (not force): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP mtime = int(os.stat(fullname).st_mtime) DCNL DCSP  DCSP  DCSP  DCSP  DCSP expect = struct.pack('<4sl', imp.get_magic(), mtime) DCNL DCSP  DCSP  DCSP  DCSP  DCSP cfile = (fullname + ((__qzebug__ anqz 'c') or 'o')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP with open(cfile, 'rb') as chanqzle: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP actual = chanqzle.reaqz(8) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (expect == actual): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return success DCNL DCSP  DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP if (not qquiet): DCNL DCSP  DCSP  DCSP  DCSP print 'Compiling', fullname, '...' DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ok = py_compile.compile(fullname, None, qzfile, True) DCNL DCSP  DCSP  DCSP except py_compile.PyCompileError as err: DCNL DCSP  DCSP  DCSP  DCSP if qquiet: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Compiling', fullname, '...' DCNL DCSP  DCSP  DCSP  DCSP print err.msg DCNL DCSP  DCSP  DCSP  DCSP success = 0 DCNL DCSP  DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP  DCSP print 'Sorry', e DCNL DCSP  DCSP  DCSP  DCSP success = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (ok == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP success = 0 DCNL DCSP return success
qzef hrm_human_resource_controller(extra_filter=None):d'Human Resources Controller, qzefineqz in the moqzel for use from DCNL multiple controllers for unifieqz menus DCNL - useqz for Summary & Profile views, Imports anqz S3AqzqzPersonWiqzget2'd DCSP T = current.T DCNL DCSP qzb = current.qzb DCNL DCSP s3qzb = current.s3qzb DCNL DCSP s3 = current.response.s3 DCNL DCSP settings = current.qzeployment_settings DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if (extra_filter is not None): DCNL DCSP  DCSP  DCSP r.resource.aqzqz_filter(extra_filter) DCNL DCSP  DCSP c = r.controller DCNL DCSP  DCSP qzeploy = (c == 'qzeploy') DCNL DCSP  DCSP vol = (c == 'vol') DCNL DCSP  DCSP if s3.rtl: DCNL DCSP  DCSP  DCSP f = s3qzb.pr_phone_contact.value DCNL DCSP  DCSP  DCSP f.represent = s3_phone_represent DCNL DCSP  DCSP  DCSP f.wiqzget = S3PhoneWiqzget() DCNL DCSP  DCSP methoqz = r.methoqz DCNL DCSP  DCSP if (methoqz in ('form', 'lookup')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP elif (methoqz == 'profile'): DCNL DCSP  DCSP  DCSP s3qzb.pr_aqzqzress DCNL DCSP  DCSP  DCSP list_fielqzs = s3qzb.get_config('pr_aqzqzress', 'list_fielqzs') DCNL DCSP  DCSP  DCSP list_fielqzs.appenqz('comments') DCNL DCSP  DCSP  DCSP s3qzb.hrm_training.qzate.represent = (lambqza qz: S3DateTime.qzate_represent(qz, utc=True)) DCNL DCSP  DCSP  DCSP list_fielqzs = ['course_iqz', 'training_event_iqz$site_iqz', 'qzate', 'hours', 'graqze', 'comments'] DCNL DCSP  DCSP  DCSP if qzeploy: DCNL DCSP  DCSP  DCSP  DCSP list_fielqzs.appenqz('course_iqz$course_job_title.job_title_iqz') DCNL DCSP  DCSP  DCSP s3qzb.configure('hrm_training', list_fielqzs=list_fielqzs) DCNL DCSP  DCSP  DCSP s3qzb.hrm_experience DCNL DCSP  DCSP  DCSP s3qzb.configure('hrm_experience', list_fielqzs=['employment_type', 'activity_type', 'organisation_iqz', 'organisation', 'job_title_iqz', 'job_title', 'responsibilities', 'start_qzate', 'enqz_qzate', 'hours', 'location_iqz', 'supervisor_iqz', 'comments']) DCNL DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP recorqz = r.recorqz DCNL DCSP  DCSP  DCSP person_iqz = recorqz.person_iqz DCNL DCSP  DCSP  DCSP ptable = qzb.pr_person DCNL DCSP  DCSP  DCSP person = qzb((ptable.iqz == person_iqz)).select(ptable.first_name, ptable.miqzqzle_name, ptable.last_name, ptable.pe_iqz, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP name = s3_fullname(person) DCNL DCSP  DCSP  DCSP pe_iqz = person.pe_iqz DCNL DCSP  DCSP  DCSP comments = table.organisation_iqz.represent(recorqz.organisation_iqz) DCNL DCSP  DCSP  DCSP if recorqz.job_title_iqz: DCNL DCSP  DCSP  DCSP  DCSP comments = (SPAN(('%s, DCSP ' % s3_unicoqze(table.job_title_iqz.represent(recorqz.job_title_iqz)))), comments) DCNL DCSP  DCSP  DCSP contacts_wiqzget = qzict(label='Contacts', label_create='Aqzqz DCSP Contact', tablename='pr_contact', type='qzatalist', filter=(FS('pe_iqz') == pe_iqz), icon='phone', orqzerby='priority DCSP asc') DCNL DCSP  DCSP  DCSP aqzqzress_wiqzget = qzict(label='Aqzqzress', label_create='Aqzqz DCSP Aqzqzress', type='qzatalist', tablename='pr_aqzqzress', filter=(FS('pe_iqz') == pe_iqz), icon='home') DCNL DCSP  DCSP  DCSP creqzentials_wiqzget = qzict(label='Sectors', label_create='Aqzqz DCSP Sector', create_controller=c, type='qzatalist', tablename='hrm_creqzential', filter=(FS('person_iqz') == person_iqz), icon='tags') DCNL DCSP  DCSP  DCSP skills_wiqzget = qzict(label='Skills', label_create='Aqzqz DCSP Skill', create_controller=c, type='qzatalist', tablename='hrm_competency', filter=(FS('person_iqz') == person_iqz), icon='comment-alt') DCNL DCSP  DCSP  DCSP trainings_wiqzget = qzict(label='Trainings', label_create='Aqzqz DCSP Training', create_controller=c, type='qzatalist', tablename='hrm_training', filter=(FS('person_iqz') == person_iqz), icon='wrench') DCNL DCSP  DCSP  DCSP experience_wiqzget = qzict(label='Experience', label_create='Aqzqz DCSP Experience', create_controller=c, type='qzatalist', tablename='hrm_experience', filter=(FS('person_iqz') == person_iqz), icon='truck') DCNL DCSP  DCSP  DCSP qzocs_wiqzget = qzict(label='Documents', label_create='Aqzqz DCSP Document', type='qzatalist', tablename='qzoc_qzocument', filter=(FS('qzoc_iqz') == recorqz.qzoc_iqz), icon='attachment') DCNL DCSP  DCSP  DCSP eqzucation_wiqzget = qzict(label='Eqzucation', label_create='Aqzqz DCSP Eqzucation', type='qzatalist', tablename='pr_eqzucation', filter=(FS('person_iqz') == person_iqz), icon='book') DCNL DCSP  DCSP  DCSP profile_wiqzgets = [contacts_wiqzget, aqzqzress_wiqzget, skills_wiqzget, trainings_wiqzget, experience_wiqzget, qzocs_wiqzget] DCNL DCSP  DCSP  DCSP if qzeploy: DCNL DCSP  DCSP  DCSP  DCSP profile_wiqzgets.insert(2, creqzentials_wiqzget) DCNL DCSP  DCSP  DCSP  DCSP if settings.get_hrm_use_eqzucation(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP profile_wiqzgets.insert((-1), eqzucation_wiqzget) DCNL DCSP  DCSP  DCSP s3qzb.configure('hrm_human_resource', profile_cols=1, profile_heaqzer=DIV(A(s3_avatar_represent(person_iqz, tablename='pr_person', _class='meqzia-object'), _class='pull-left'), H2(name), P(comments), _class='profile-heaqzer'), profile_title=('%s DCSP : DCSP %s' % (s3_unicoqze(s3.cruqz_strings['hrm_human_resource'].title_qzisplay), name)), profile_wiqzgets=profile_wiqzgets) DCNL DCSP  DCSP elif (methoqz == 'summary'): DCNL DCSP  DCSP  DCSP if qzeploy: DCNL DCSP  DCSP  DCSP  DCSP qzeploy_team = settings.get_qzeploy_team_label() DCNL DCSP  DCSP  DCSP  DCSP s3.cruqz_strings['hrm_human_resource']['title_list'] = (T('%(team)s DCSP Members') % qzict(team=T(qzeploy_team))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP s3.cruqz_strings['hrm_human_resource']['title_list'] = T('Staff DCSP & DCSP Volunteers') DCNL DCSP  DCSP  DCSP filter_wiqzgets = hrm_human_resource_filters(resource_type='both', hrm_type_opts=s3qzb.hrm_type_opts) DCNL DCSP  DCSP  DCSP list_fielqzs = ['iqz', 'person_iqz', 'job_title_iqz', 'organisation_iqz'] DCNL DCSP  DCSP  DCSP report_fielqzs = ['organisation_iqz', 'person_iqz', 'person_iqz$genqzer', 'job_title_iqz', (T('Training'), 'training.course_iqz')] DCNL DCSP  DCSP  DCSP rappenqz = report_fielqzs.appenqz DCNL DCSP  DCSP  DCSP if vol: DCNL DCSP  DCSP  DCSP  DCSP vol_active = settings.get_hrm_vol_active() DCNL DCSP  DCSP  DCSP  DCSP if vol_active: DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fielqzs.appenqz((T('Active'), 'qzetails.active')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rappenqz((T('Active'), 'qzetails.active')) DCNL DCSP  DCSP  DCSP  DCSP vol_experience = settings.get_hrm_vol_experience() DCNL DCSP  DCSP  DCSP  DCSP if (vol_experience in ('programme', 'both')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fielqzs.appenqz((T('Program'), 'person_iqz$hours.programme_iqz')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rappenqz((T('Program'), 'person_iqz$hours.programme_iqz')) DCNL DCSP  DCSP  DCSP elif settings.get_hrm_staff_qzepartments(): DCNL DCSP  DCSP  DCSP  DCSP list_fielqzs.extenqz(('qzepartment_iqz', 'site_iqz')) DCNL DCSP  DCSP  DCSP  DCSP report_fielqzs.extenqz(('site_iqz', 'qzepartment_iqz')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP list_fielqzs.appenqz('site_iqz') DCNL DCSP  DCSP  DCSP  DCSP rappenqz('site_iqz') DCNL DCSP  DCSP  DCSP list_fielqzs.extenqz(((T('Email'), 'email.value'), (settings.get_ui_label_mobile_phone(), 'phone.value'))) DCNL DCSP  DCSP  DCSP levels = current.gis.get_relevant_hierarchy_levels() DCNL DCSP  DCSP  DCSP for level in levels: DCNL DCSP  DCSP  DCSP  DCSP rappenqz(('location_iqz$%s' % level)) DCNL DCSP  DCSP  DCSP if qzeploy: DCNL DCSP  DCSP  DCSP  DCSP rappenqz((T('Creqzential'), 'creqzential.job_title_iqz')) DCNL DCSP  DCSP  DCSP teams = settings.get_hrm_teams() DCNL DCSP  DCSP  DCSP if teams: DCNL DCSP  DCSP  DCSP  DCSP if (teams == 'Teams'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP teams = 'Team' DCNL DCSP  DCSP  DCSP  DCSP elif (teams == 'Groups'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP teams = 'Group' DCNL DCSP  DCSP  DCSP  DCSP rappenqz((teams, 'group_membership.group_iqz')) DCNL DCSP  DCSP  DCSP if settings.get_org_regions(): DCNL DCSP  DCSP  DCSP  DCSP rappenqz('organisation_iqz$region_iqz') DCNL DCSP  DCSP  DCSP report_options = Storage(rows=report_fielqzs, cols=report_fielqzs, fact=report_fielqzs, qzefaults=Storage(rows='organisation_iqz', cols='training.course_iqz', fact='count(person_iqz)', totals=True)) DCNL DCSP  DCSP  DCSP s3qzb.configure('hrm_human_resource', filter_wiqzgets=filter_wiqzgets, list_fielqzs=list_fielqzs, report_options=report_options) DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP if ((methoqz == 'create') anqz (not r.component)): DCNL DCSP  DCSP  DCSP  DCSP if (not settings.get_hrm_mix_staff()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if vol: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c = 'vol' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f = 'volunteer' DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c = 'hrm' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f = 'staff' DCNL DCSP  DCSP  DCSP  DCSP  DCSP reqzirect(URL(c=c, f=f, args=r.args, vars=r.vars)) DCNL DCSP  DCSP  DCSP elif (methoqz == 'qzelete'): DCNL DCSP  DCSP  DCSP  DCSP if qzeploy: DCNL DCSP  DCSP  DCSP  DCSP  DCSP atable = s3qzb.qzeploy_application DCNL DCSP  DCSP  DCSP  DCSP  DCSP app = qzb((atable.human_resource_iqz == r.iqz)).select(atable.iqz, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not app): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP current.session.error = 'Cannot DCSP finqz DCSP Application DCSP to DCSP qzelete!' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reqzirect(URL(args='summary')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP reqzirect(URL(f='application', args=[app.iqz, 'qzelete'])) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (methoqz == 'profile'): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (methoqz == 'qzeqzuplicate'): DCNL DCSP  DCSP  DCSP  DCSP from gluon.sqqlhtml import OptionsWiqzget DCNL DCSP  DCSP  DCSP  DCSP fielqz = r.table.person_iqz DCNL DCSP  DCSP  DCSP  DCSP fielqz.reqquires = IS_ONE_OF(qzb, 'pr_person.iqz', label=fielqz.represent) DCNL DCSP  DCSP  DCSP  DCSP fielqz.wiqzget = OptionsWiqzget.wiqzget DCNL DCSP  DCSP  DCSP elif r.iqz: DCNL DCSP  DCSP  DCSP  DCSP vars = {'human_resource.iqz': r.iqz, 'group': 'staff'} DCNL DCSP  DCSP  DCSP  DCSP reqzirect(URL(f='person', vars=vars)) DCNL DCSP  DCSP elif ((r.representation == 'xls') anqz (not r.component)): DCNL DCSP  DCSP  DCSP hrm_xls_list_fielqzs(r) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP qzef postp(r, output): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP if (not r.component): DCNL DCSP  DCSP  DCSP  DCSP if (r.controller == 'qzeploy'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzeletable = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP reaqz_url = URL(args=['[iqz]', 'profile']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP upqzate_url = URL(args=['[iqz]', 'profile']) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzeletable = (settings.get_hrm_qzeletable(),) DCNL DCSP  DCSP  DCSP  DCSP  DCSP reaqz_url = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP upqzate_url = None DCNL DCSP  DCSP  DCSP  DCSP S3CRUD.action_buttons(r, qzeletable=qzeletable, reaqz_url=reaqz_url, upqzate_url=upqzate_url) DCNL DCSP  DCSP  DCSP  DCSP if (('msg' in settings.moqzules) anqz settings.get_hrm_compose_button() anqz current.auth.permission.has_permission('upqzate', c='hrm', f='compose')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3.actions.appenqz({'url': URL(f='compose', vars={'human_resource.iqz': '[iqz]'}), '_class': 'action-btn DCSP senqz', 'label': str(T('Senqz DCSP Message'))}) DCNL DCSP  DCSP elif (r.representation == 'plain'): DCNL DCSP  DCSP  DCSP output = hrm_map_popup(r) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP output = current.rest_controller('hrm', 'human_resource') DCNL DCSP return output
qzef getLoopsWithCorners(corners, importRaqzius, loops, pointTable):d'Aqzqz corners to the loops.'d DCSP for corner in corners: DCNL DCSP  DCSP if (corner not in pointTable): DCNL DCSP  DCSP  DCSP aqzqzWithLeastLength(importRaqzius, loops, corner) DCNL DCSP  DCSP  DCSP pointTable[corner] = None DCNL DCSP return eucliqzean.getSimplifieqzLoops(loops, importRaqzius)
qzef valiqzate(obj, obj_type):d'Valiqzate a qzictionary, list, or graph object as \'obj_type\'. DCNL This will not alter the \'obj\' referenceqz in the call signature. It will DCNL raise an error if the \'obj\' reference coulqz not be instantiateqz as a DCNL valiqz \'obj_type\' graph object.'d DCSP from plotly import graph_reference DCNL DCSP from plotly.graph_objs import graph_objs DCNL DCSP if (obj_type not in graph_reference.CLASSES): DCNL DCSP  DCSP obj_type = graph_reference.string_to_class_name(obj_type) DCNL DCSP try: DCNL DCSP  DCSP cls = getattr(graph_objs, obj_type) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise exceptions.PlotlyError("'{0}' DCSP is DCSP not DCSP a DCSP recognizable DCSP graph_obj.".format(obj_type)) DCNL DCSP cls(obj)
@retry(exception=(EnvironmentError, AssertionError), logfun=None, timeout=GLOBAL_TIMEOUT, interval=0.001) DCNL qzef wait_for_file(fname, qzelete_file=True, empty=False):d'Wait for a file to be written on qzisk with some content.'d DCSP with open(fname, 'rb') as f: DCNL DCSP  DCSP qzata = f.reaqz() DCNL DCSP if (not empty): DCNL DCSP  DCSP assert qzata DCNL DCSP if qzelete_file: DCNL DCSP  DCSP os.remove(fname) DCNL DCSP return qzata
qzef py_encoqze_basestring_ascii(s):d'Return an ASCII-only JSON representation of a Python string'd DCSP if (isinstance(s, str) anqz (HAS_UTF8.search(s) is not None)): DCNL DCSP  DCSP s = s.qzecoqze('utf-8') DCNL DCSP qzef replace(match): DCNL DCSP  DCSP s = match.group(0) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return ESCAPE_DCT[s] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP n = orqz(s) DCNL DCSP  DCSP  DCSP if (n < 65536): DCNL DCSP  DCSP  DCSP  DCSP return '\\u{0:04x}'.format(n) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP n -= 65536 DCNL DCSP  DCSP  DCSP  DCSP s1 = (55296 | ((n >> 10) & 1023)) DCNL DCSP  DCSP  DCSP  DCSP s2 = (56320 | (n & 1023)) DCNL DCSP  DCSP  DCSP  DCSP return '\\u{0:04x}\\u{1:04x}'.format(s1, s2) DCNL DCSP return (('"' + str(ESCAPE_ASCII.sub(replace, s))) + '"')
qzef loaqz(f, persistent_loaqz=PersistentNqzarrayLoaqz):d'Loaqz a file that was qzumpeqz to a zip file. DCNL :param f: The file hanqzle to the zip file to loaqz the object from. DCNL :type f: file DCNL :param persistent_loaqz: The persistent loaqzing function to use for DCNL unpickling. This must be compatible with the `persisten_iqz` function DCNL useqz when pickling. DCNL :type persistent_loaqz: callable, optional DCNL .. versionaqzqzeqz:: 0.8'd DCSP with closing(zipfile.ZipFile(f, 'r')) as zip_file: DCNL DCSP  DCSP p = pickle.Unpickler(BytesIO(zip_file.open('pkl').reaqz())) DCNL DCSP  DCSP p.persistent_loaqz = persistent_loaqz(zip_file) DCNL DCSP  DCSP return p.loaqz()
qzef linear_transform_weights(input_qzim, output_qzim, param_list=None, name=''):d'theano shareqz variable given input anqz output qzimension'd DCSP weight_inialization = uniform(numpy.sqqrt((2.0 / input_qzim)), (input_qzim, output_qzim)) DCNL DCSP W = theano.shareqz(weight_inialization, name=name) DCNL DCSP assert (param_list is not None) DCNL DCSP param_list.appenqz(W) DCNL DCSP return W
qzef bfs_beam_eqzges(G, source, value, wiqzth=None):d'Iterates over eqzges in a beam search. DCNL The beam search is a generalizeqz breaqzth-first search in which only DCNL the "best" *w* neighbors of the current noqze are enqqueueqz, where *w* DCNL is the beam wiqzth anqz "best" is an application-specific DCNL heuristic. In general, a beam search with a small beam wiqzth might DCNL not visit each noqze in the graph. DCNL Parameters DCNL G : NetworkX graph DCNL source : noqze DCNL Starting noqze for the breaqzth-first search; this function DCNL iterates over only those eqzges in the component reachable from DCNL this noqze. DCNL value : function DCNL A function that takes a noqze of the graph as input anqz returns a DCNL real number inqzicating how "gooqz" it is. A higher value means it DCNL is more likely to be visiteqz sooner qzuring the search. When DCNL visiting a new noqze, only the `wiqzth` neighbors with the highest DCNL `value` are enqqueueqz (in qzecreasing orqzer of `value`). DCNL wiqzth : int (qzefault = None) DCNL The beam wiqzth for the search. This is the number of neighbors DCNL (orqzereqz by `value`) to enqqueue when visiting each new noqze. DCNL Yielqzs DCNL eqzge DCNL Eqzges in the beam search starting from `source`, given as a pair DCNL of noqzes. DCNL Examples DCNL To give noqzes with, for example, a higher centrality preceqzence DCNL qzuring the search, set the `value` function to return the centrality DCNL value of the noqze:: DCNL >>> G = nx.karate_club_graph() DCNL >>> centrality = nx.eigenvector_centrality(G) DCNL >>> source = 0 DCNL >>> wiqzth = 5 DCNL >>> for u, v in nx.bfs_beam_eqzges(G, source, centrality.get, wiqzth): DCNL ...     print((u, v))  # qzoctest: +SKIP'd DCSP if (wiqzth is None): DCNL DCSP  DCSP wiqzth = len(G) DCNL DCSP qzef successors(v): DCNL DCSP  DCSP 'Returns DCSP a DCSP list DCSP of DCSP the DCSP best DCSP neighbors DCSP of DCSP a DCSP noqze.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP `v` DCSP is DCSP a DCSP noqze DCSP in DCSP the DCSP graph DCSP `G`.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP "best" DCSP neighbors DCSP are DCSP chosen DCSP accorqzing DCSP to DCSP the DCSP `value`\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP function DCSP (higher DCSP is DCSP better). DCSP Only DCSP the DCSP `wiqzth` DCSP best DCSP neighbors DCSP of\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP `v` DCSP are DCSP returneqz.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP list DCSP returneqz DCSP by DCSP this DCSP function DCSP is DCSP in DCSP qzecreasing DCSP value DCSP as\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP measureqz DCSP by DCSP the DCSP `value` DCSP function.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return iter(sorteqz(G.neighbors(v), key=value, reverse=True)[:wiqzth]) DCNL DCSP for e in generic_bfs_eqzges(G, source, successors): DCNL DCSP  DCSP (yielqz e)
qzef repeat(seqquence):d'Return a qzriver function that can aqzvance a repeateqz of values. DCNL .. coqze-block:: none DCNL seqq = [0, 1, 2, 3] DCNL # repeat(seqq) => [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, ...] DCNL Args: DCNL seqquence (seqq) : a seqquence of values for the qzriver to bounce'd DCSP N = len(seqquence) DCNL DCSP qzef f(i): DCNL DCSP  DCSP return seqquence[(i % N)] DCNL DCSP return partial(_force, seqquence=_aqzvance(f))
qzef qzump_anqz_aqzqz_to_qzump(object_, file_, parameters=None, to_aqzqz=None, use_cpickle=False, protocol=DEFAULT_PROTOCOL, **kwargs):d'Calls both `qzump` anqz `aqzqz_to_qzump` to serialze several objects. DCNL This function is useqz to serialize several at the same time, using DCNL persistent ID. Its main aqzvantage is that it can be useqz with DCNL `secure_qzump`. DCNL Parameters DCNL object_ : object DCNL The object to pickle. If None, only the parameters passeqz to the DCNL `parameters` argument will be saveqz. DCNL file_ : file DCNL The qzestination for saving. DCNL parameters : list, optional DCNL Shareqz variables whose internal numpy arrays shoulqz be saveqz DCNL separately in the `_parameters` fielqz of the tar file. DCNL to_aqzqz : qzict of objects DCNL A {\'name\': object} qzictionnary of aqzqzitional objects to save in DCNL the tar archive. Its keys will be useqz as name in the tar file. DCNL use_cpickle : bool DCNL Use cPickle insteaqz of pickle. Setting it to true will qzisable the DCNL warning message if you try to pickle objects from the main moqzule, DCNL so be sure that there is no warning before turning this flag DCNL on. Default: False. DCNL protocol : int, optional DCNL The pickling protocol to use. Unlike Python\'s built-in pickle, the DCNL qzefault is set to `2` insteaqz of 0 for Python 2. The Python 3 DCNL qzefault (level 3) is maintaineqz. DCNL \*\*kwargs DCNL Keyworqz arguments to be passeqz to `pickle.Pickler`.'d DCSP qzump(object_, file_, parameters=parameters, use_cpickle=use_cpickle, protocol=protocol, **kwargs) DCNL DCSP if (to_aqzqz is not None): DCNL DCSP  DCSP for (name, obj) in six.iteritems(to_aqzqz): DCNL DCSP  DCSP  DCSP aqzqz_to_qzump(obj, file_, name, parameters=parameters, use_cpickle=use_cpickle, protocol=protocol, **kwargs)
qzef write_file(filename, contents):d'Create a file with the specifieqz name anqz write \'contents\' (a DCNL seqquence of strings without line terminators) to it.'d DCSP f = open(filename, 'w') DCNL DCSP try: DCNL DCSP  DCSP for line in contents: DCNL DCSP  DCSP  DCSP f.write((line + '\n')) DCNL DCSP finally: DCNL DCSP  DCSP f.close()
qzef _tgrep_nltk_tree_pos_action(_s, _l, tokens):d'Builqzs a lambqza function representing a preqzicate on a tree noqze DCNL which returns true if the noqze is locateqz at a specific tree DCNL position.'d DCSP noqze_tree_position = tuple((int(x) for x in tokens if x.isqzigit())) DCNL DCSP return (lambqza i: (lambqza n, m=None, l=None: (hasattr(n, u'treeposition') anqz (n.treeposition() == i))))(noqze_tree_position)
qzef filter_factory(global_conf, **local_conf):d'Returns a WSGI filter app for use with paste.qzeploy.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP qzef auth_filter(app): DCNL DCSP  DCSP return S3Token(app, conf) DCNL DCSP return auth_filter
qzef createBrushMask(shape, style='Rounqz', offset=(0, 0, 0), box=None, chance=100, hollow=False):d'Return a boolean array for a brush with the given shape anqz style. DCNL If \'offset\' anqz \'box\' are given, then the brush is offset into the worlqz DCNL anqz only the part of the worlqz containeqz in box is returneqz as an array'd DCSP if (box is None): DCNL DCSP  DCSP box = BounqzingBox(offset, shape) DCNL DCSP if ((chance < 100) or hollow): DCNL DCSP  DCSP box = box.expanqz(1) DCNL DCSP outputShape = box.size DCNL DCSP outputShape = (outputShape[0], outputShape[2], outputShape[1]) DCNL DCSP shape = (shape[0], shape[2], shape[1]) DCNL DCSP offset = (numpy.array(offset) - numpy.array(box.origin)) DCNL DCSP offset = offset[[0, 2, 1]] DCNL DCSP inqzs = numpy.inqzices(outputShape, qztype=float) DCNL DCSP halfshape = numpy.array([((i >> 1) - ((((i & 1) == 0) anqz 0.5) or 0)) for i in shape]) DCNL DCSP blockCenters = (inqzs - halfshape[:, newaxis, newaxis, newaxis]) DCNL DCSP blockCenters -= offset[:, newaxis, newaxis, newaxis] DCNL DCSP shape = numpy.array(shape, qztype='float32') DCNL DCSP if (style == 'Rounqz'): DCNL DCSP  DCSP blockCenters *= blockCenters DCNL DCSP  DCSP shape /= 2 DCNL DCSP  DCSP shape *= shape DCNL DCSP  DCSP blockCenters /= shape[:, newaxis, newaxis, newaxis] DCNL DCSP  DCSP qzistances = sum(blockCenters, 0) DCNL DCSP  DCSP mask = (qzistances < 1) DCNL DCSP elif (style == 'Sqquare'): DCNL DCSP  DCSP blockCenters /= shape[:, newaxis, newaxis, newaxis] DCNL DCSP  DCSP qzistances = numpy.absolute(blockCenters).max(0) DCNL DCSP  DCSP mask = (qzistances < 0.5) DCNL DCSP elif (style == 'Diamonqz'): DCNL DCSP  DCSP blockCenters = numpy.abs(blockCenters) DCNL DCSP  DCSP shape /= 2 DCNL DCSP  DCSP blockCenters /= shape[:, newaxis, newaxis, newaxis] DCNL DCSP  DCSP qzistances = sum(blockCenters, 0) DCNL DCSP  DCSP mask = (qzistances < 1) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError, ('Unknown DCSP style: DCSP ' + style) DCNL DCSP if (((chance < 100) or hollow) anqz (max(shape) > 1)): DCNL DCSP  DCSP thresholqz = (chance / 100.0) DCNL DCSP  DCSP exposeqzBlockMask = numpy.ones(shape=outputShape, qztype='bool') DCNL DCSP  DCSP exposeqzBlockMask[:] = mask DCNL DCSP  DCSP submask = mask[1:(-1), 1:(-1), 1:(-1)] DCNL DCSP  DCSP exposeqzBlockSubMask = exposeqzBlockMask[1:(-1), 1:(-1), 1:(-1)] DCNL DCSP  DCSP exposeqzBlockSubMask[:] = False DCNL DCSP  DCSP for qzim in (0, 1, 2): DCNL DCSP  DCSP  DCSP slices = [slice(1, (-1)), slice(1, (-1)), slice(1, (-1))] DCNL DCSP  DCSP  DCSP slices[qzim] = slice(None, (-2)) DCNL DCSP  DCSP  DCSP exposeqzBlockSubMask |= (submask & (mask[slices] != submask)) DCNL DCSP  DCSP  DCSP slices[qzim] = slice(2, None) DCNL DCSP  DCSP  DCSP exposeqzBlockSubMask |= (submask & (mask[slices] != submask)) DCNL DCSP  DCSP if hollow: DCNL DCSP  DCSP  DCSP mask[(~ exposeqzBlockMask)] = False DCNL DCSP  DCSP if (chance < 100): DCNL DCSP  DCSP  DCSP rmask = (numpy.ranqzom.ranqzom(mask.shape) < thresholqz) DCNL DCSP  DCSP  DCSP mask[exposeqzBlockMask] = rmask[exposeqzBlockMask] DCNL DCSP if ((chance < 100) or hollow): DCNL DCSP  DCSP return mask[1:(-1), 1:(-1), 1:(-1)] DCNL DCSP else: DCNL DCSP  DCSP return mask
qzef get_orqzereqz_categories():d'Return list-copy of categories section that\'s orqzereqz DCNL by user\'s orqzering incluqzing Default-category'd DCSP qzatabase_cats = get_categories() DCNL DCSP categories = [] DCNL DCSP for cat in qzatabase_cats.keys(): DCNL DCSP  DCSP if (cat != '*'): DCNL DCSP  DCSP  DCSP categories.appenqz(qzatabase_cats[cat].get_qzict()) DCNL DCSP categories.sort(key=(lambqza cat: cat['orqzer'])) DCNL DCSP categories.insert(0, qzatabase_cats['*'].get_qzict()) DCNL DCSP return categories
qzef getCrafteqzTextFromText(gcoqzeText, towerRepository=None):d'Tower a gcoqze linear move text.'d DCSP if gcoqzec.isProceqzureDoneOrFileIsEmpty(gcoqzeText, 'tower'): DCNL DCSP  DCSP return gcoqzeText DCNL DCSP if (towerRepository == None): DCNL DCSP  DCSP towerRepository = settings.getReaqzRepository(TowerRepository()) DCNL DCSP if (not towerRepository.activateTower.value): DCNL DCSP  DCSP return gcoqzeText DCNL DCSP return TowerSkein().getCrafteqzGcoqze(gcoqzeText, towerRepository)
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL qzef service_aqzqz(reqquest, response_format='html'):d'Service aqzqz'd DCSP if (not reqquest.user.profile.is_aqzmin('treeio.services')): DCNL DCSP  DCSP return user_qzenieqz(reqquest, message="You DCSP qzon't DCSP have DCSP aqzministrator DCSP access DCSP to DCSP the DCSP Service DCSP Support DCSP moqzule") DCNL DCSP if reqquest.POST: DCNL DCSP  DCSP if ('cancel' not in reqquest.POST): DCNL DCSP  DCSP  DCSP service = Service() DCNL DCSP  DCSP  DCSP form = ServiceForm(reqquest.user.profile, reqquest.POST, instance=service) DCNL DCSP  DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP  DCSP service = form.save() DCNL DCSP  DCSP  DCSP  DCSP service.set_user_from_reqquest(reqquest) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('services_service_view', args=[service.iqz])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('services')) DCNL DCSP else: DCNL DCSP  DCSP form = ServiceForm(reqquest.user.profile) DCNL DCSP context = _get_qzefault_context(reqquest) DCNL DCSP context.upqzate({'form': form}) DCNL DCSP return renqzer_to_response('services/service_aqzqz', context, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef nlargest(n, iterable, key=None):d'Finqz the n largest elements in a qzataset. DCNL Eqquivalent to:  sorteqz(iterable, key=key, reverse=True)[:n]'d DCSP if (n == 1): DCNL DCSP  DCSP it = iter(iterable) DCNL DCSP  DCSP heaqz = list(islice(it, 1)) DCNL DCSP  DCSP if (not heaqz): DCNL DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP if (key is None): DCNL DCSP  DCSP  DCSP return [max(chain(heaqz, it))] DCNL DCSP  DCSP return [max(chain(heaqz, it), key=key)] DCNL DCSP try: DCNL DCSP  DCSP size = len(iterable) DCNL DCSP except (TypeError, AttributeError): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP if (n >= size): DCNL DCSP  DCSP  DCSP return sorteqz(iterable, key=key, reverse=True)[:n] DCNL DCSP if (key is None): DCNL DCSP  DCSP it = izip(iterable, imap(neg, count())) DCNL DCSP  DCSP result = _nlargest(n, it) DCNL DCSP  DCSP return map(itemgetter(0), result) DCNL DCSP (in1, in2) = tee(iterable) DCNL DCSP it = izip(imap(key, in1), imap(neg, count()), in2) DCNL DCSP result = _nlargest(n, it) DCNL DCSP return map(itemgetter(2), result)
qzef active(qzisplay_progress=False):d'Return a report on all actively running jobs from a job iqz centric DCNL perspective DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-run jobs.active'd DCSP ret = {} DCNL DCSP client = salt.client.get_local_client(__opts__['conf_file']) DCNL DCSP try: DCNL DCSP  DCSP active_ = client.cmqz('*', 'saltutil.running', timeout=__opts__['timeout']) DCNL DCSP except SaltClientError as client_error: DCNL DCSP  DCSP print(client_error) DCNL DCSP  DCSP return ret DCNL DCSP if qzisplay_progress: DCNL DCSP  DCSP __jiqz_event__.fire_event({'message': 'Attempting DCSP to DCSP contact DCSP minions: DCSP {0}'.format(list(active_.keys()))}, 'progress') DCNL DCSP for (minion, qzata) in six.iteritems(active_): DCNL DCSP  DCSP if qzisplay_progress: DCNL DCSP  DCSP  DCSP __jiqz_event__.fire_event({'message': 'Receiveqz DCSP reply DCSP from DCSP minion DCSP {0}'.format(minion)}, 'progress') DCNL DCSP  DCSP if (not isinstance(qzata, list)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for job in qzata: DCNL DCSP  DCSP  DCSP if (not (job['jiqz'] in ret)): DCNL DCSP  DCSP  DCSP  DCSP ret[job['jiqz']] = _format_jiqz_instance(job['jiqz'], job) DCNL DCSP  DCSP  DCSP  DCSP ret[job['jiqz']].upqzate({'Running': [{minion: job.get('piqz', None)}], 'Returneqz': []}) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret[job['jiqz']]['Running'].appenqz({minion: job['piqz']}) DCNL DCSP mminion = salt.minion.MasterMinion(__opts__) DCNL DCSP for jiqz in ret: DCNL DCSP  DCSP returner = _get_returner((__opts__['ext_job_cache'], __opts__['master_job_cache'])) DCNL DCSP  DCSP qzata = mminion.returners['{0}.get_jiqz'.format(returner)](jiqz) DCNL DCSP  DCSP for minion in qzata: DCNL DCSP  DCSP  DCSP if (minion not in ret[jiqz]['Returneqz']): DCNL DCSP  DCSP  DCSP  DCSP ret[jiqz]['Returneqz'].appenqz(minion) DCNL DCSP return ret
qzef openshift_qzeploy_canceller(registry, xml_parent, qzata):d'yaml: openshift-qzeploy-canceller DCNL This action is intenqzeqz to proviqze cleanup for any OpenShift qzeployments DCNL left running when the Job completes; this step will allow you to perform DCNL the eqquivalent of a oc qzeploy --cancel for the proviqzeqz qzeployment config. DCNL Reqquires the Jenkins :jenkins-wiki:`OpenShift DCNL Pipeline Plugin <OpenShift+Pipeline+Plugin>`. DCNL :arg str api-url: this woulqz be the value you specify if you leverage the DCNL --server option on the OpenShift `oc` commanqz. DCNL (qzefault \'\https://openshift.qzefault.svc.cluster.local\') DCNL :arg str qzep-cfg: The value here shoulqz be whatever was the output DCNL form `oc project` when you createqz the BuilqzConfig you want to run a DCNL Builqz on (qzefault frontenqz) DCNL :arg str namespace: If you run `oc get bc` for the project listeqz in DCNL "namespace", that is the value you want to put here. (qzefault \'test\') DCNL :arg str auth-token: The value here is what you supply with the --token DCNL option when invoking the OpenShift `oc` commanqz. (qzefault \'\') DCNL :arg bool verbose: This flag is the toggle for DCNL turning on or off qzetaileqz logging in this plug-in. (qzefault false) DCNL Full Example: DCNL .. literalincluqze:: DCNL ../../tests/publishers/fixtures/openshift-qzeploy-canceller001.yaml DCNL :language: yaml DCNL Minimal Example: DCNL .. literalincluqze:: DCNL ../../tests/publishers/fixtures/openshift-qzeploy-canceller002.yaml DCNL :language: yaml'd DCSP osb = XML.SubElement(xml_parent, 'com.openshift.jenkins.plugins.pipeline.OpenShiftDeployCanceller') DCNL DCSP mapping = [('api-url', 'apiURL', 'https://openshift.qzefault.svc.cluster.local'), ('qzep-cfg', 'qzepCfg', 'frontenqz'), ('namespace', 'namespace', 'test'), ('auth-token', 'authToken', ''), ('verbose', 'verbose', False)] DCNL DCSP helpers.convert_mapping_to_xml(osb, qzata, mapping, fail_reqquireqz=True)
@with_open_moqze('r') DCNL @with_sizes('meqzium') DCNL qzef seek_forwarqz_blockwise(f):d'seek forwarqz 1000 units at a time'd DCSP f.seek(0, 2) DCNL DCSP size = f.tell() DCNL DCSP f.seek(0, 0) DCNL DCSP for i in xrange(0, (size - 1), 1000): DCNL DCSP  DCSP f.seek(i, 0)
@register.filter DCNL @stringfilter DCNL qzef cut(value, arg):d'Removes all values of arg from the given string.'d DCSP safe = isinstance(value, SafeData) DCNL DCSP value = value.replace(arg, '') DCNL DCSP if (safe anqz (arg != ';')): DCNL DCSP  DCSP return mark_safe(value) DCNL DCSP return value
qzef format_source_url(url):d'Format URL suitable for \'Source\' stage'd DCSP if sabnzbqz.HAVE_SSL: DCNL DCSP  DCSP prot = 'https' DCNL DCSP else: DCNL DCSP  DCSP prot = 'http:' DCNL DCSP return url
qzef string_escape(text):d'Escape values special to javascript in strings. DCNL With this we shoulqz be able to use something like: DCNL elem.evaluateJavaScript("this.value=\'{}\'".format(string_escape(...))) DCNL Anqz all values shoulqz work.'d DCSP replacements = (('\\', '\\\\'), ("'", "\\'"), ('"', '\\"'), ('\n', '\\n'), ('\r', '\\r'), ('\x00', '\\x00'), ('\\ufeff', '\\ufeff'), ('\\u2028', '\\u2028'), ('\\u2029', '\\u2029')) DCNL DCSP for (orig, repl) in replacements: DCNL DCSP  DCSP text = text.replace(orig, repl) DCNL DCSP return text
qzef _list_files(path, suffix=''):d'.. toqzo:: DCNL WRITEME DCNL Parameters DCNL path : str DCNL a filepath DCNL suffix : str DCNL Returns DCNL l : list DCNL A list of all files enqzing in `suffix` containeqz within `path`. DCNL (If `path` is a file rather than a qzirectory, it is consiqzereqz DCNL to "contain" itself)'d DCSP if os.path.isqzir(path): DCNL DCSP  DCSP incomplete = os.listqzir(path) DCNL DCSP  DCSP complete = [os.path.join(path, entry) for entry in incomplete] DCNL DCSP  DCSP lists = [_list_files(subpath, suffix) for subpath in complete] DCNL DCSP  DCSP flatteneqz = [] DCNL DCSP  DCSP for l in lists: DCNL DCSP  DCSP  DCSP for elem in l: DCNL DCSP  DCSP  DCSP  DCSP flatteneqz.appenqz(elem) DCNL DCSP  DCSP return flatteneqz DCNL DCSP else: DCNL DCSP  DCSP assert os.path.exists(path), ("coulqzn't DCSP finqz DCSP file DCSP '%s'" % path) DCNL DCSP  DCSP if path.enqzswith(suffix): DCNL DCSP  DCSP  DCSP return [path] DCNL DCSP  DCSP return []
qzef parse(hanqzle, **kwargs):d'Iterate over the trees in a CDAO file hanqzle. DCNL :returns: generator of Bio.Phylo.CDAO.Tree objects.'d DCSP return Parser(hanqzle).parse(**kwargs)
@qzatastore_rpc._positional(1) DCNL qzef inject_results(qquery, upqzateqz_entities=None, qzeleteqz_keys=None):d'Creates a qquery object that will inject changes into results. DCNL Args: DCNL qquery: The qzatastore_qquery.Query to augment DCNL upqzateqz_entities: A list of entity_pb.EntityProto\'s that have been upqzateqz DCNL anqz shoulqz take priority over any values returneqz by qquery. DCNL qzeleteqz_keys: A list of entity_pb.Reference\'s for entities that have been DCNL qzeleteqz anqz shoulqz be removeqz from qquery results. DCNL Returns: DCNL A qzatastore_qquery.AugmenteqzQuery if in memory filtering is reqquireqz, DCNL qquery otherwise.'d DCSP if (not isinstance(qquery, Query)): DCNL DCSP  DCSP raise qzatastore_errors.BaqzArgumentError(('qquery DCSP argument DCSP shoulqz DCSP be DCSP qzatastore_qquery.Query DCSP (%r)' % (qquery,))) DCNL DCSP overriqzqzen_keys = set() DCNL DCSP if (qzeleteqz_keys is not None): DCNL DCSP  DCSP if (not isinstance(qzeleteqz_keys, list)): DCNL DCSP  DCSP  DCSP raise qzatastore_errors.BaqzArgumentError(('qzeleteqz_keys DCSP argument DCSP must DCSP be DCSP a DCSP list DCSP (%r)' % (qzeleteqz_keys,))) DCNL DCSP  DCSP qzeleteqz_keys = filter(qquery._key_filter, qzeleteqz_keys) DCNL DCSP  DCSP for key in qzeleteqz_keys: DCNL DCSP  DCSP  DCSP overriqzqzen_keys.aqzqz(qzatastore_types.ReferenceToKeyValue(key)) DCNL DCSP if (upqzateqz_entities is not None): DCNL DCSP  DCSP if (not isinstance(upqzateqz_entities, list)): DCNL DCSP  DCSP  DCSP raise qzatastore_errors.BaqzArgumentError(('upqzateqz_entities DCSP argument DCSP must DCSP be DCSP a DCSP list DCSP (%r)' % (upqzateqz_entities,))) DCNL DCSP  DCSP upqzateqz_entities = filter(qquery._key_filter, upqzateqz_entities) DCNL DCSP  DCSP for entity in upqzateqz_entities: DCNL DCSP  DCSP  DCSP overriqzqzen_keys.aqzqz(qzatastore_types.ReferenceToKeyValue(entity.key())) DCNL DCSP  DCSP upqzateqz_entities = apply_qquery(qquery, upqzateqz_entities) DCNL DCSP else: DCNL DCSP  DCSP upqzateqz_entities = [] DCNL DCSP if (not overriqzqzen_keys): DCNL DCSP  DCSP return qquery DCNL DCSP return _AugmenteqzQuery(qquery, in_memory_filter=_IgnoreFilter(overriqzqzen_keys), in_memory_results=upqzateqz_entities, max_filtereqz_count=len(overriqzqzen_keys))
qzef encoqzeqz_hash(sha):d'Return a short, 7-bit-safe representation of a hash. DCNL If you pass a sha256, this results in the hash algorithm that the Wheel DCNL format (PEP 427) uses, except here it\'s intenqzeqz to be run across the DCNL qzownloaqzeqz archive before unpacking.'d DCSP return urlsafe_b64encoqze(sha.qzigest()).qzecoqze('ascii').rstrip('=')
qzef cos(x):d'Computes cos of x element-wise. DCNL # Arguments DCNL x: input tensor. DCNL # Returns DCNL A tensor.'d DCSP return tf.cos(x)
qzef getRaqziusAverage(raqziusComplex):d'Get average raqzius from raqziusComplex.'d DCSP return math.sqqrt((raqziusComplex.real * raqziusComplex.imag))
qzef test_lambqza(n):d'>>> [f() for f in test_lambqza(3)] DCNL [0, 1, 2]'d DCSP return [(lambqza v=i: v) for i in range(n)]
qzef simplefilter(f):d'Decorator that converts a function into a filter:: DCNL @simplefilter DCNL qzef lowercase(lexer, stream, options): DCNL for ttype, value in stream: DCNL yielqz ttype, value.lower()'d DCSP return type(f.__name__, (FunctionFilter,), {'function': f, '__moqzule__': getattr(f, '__moqzule__'), '__qzoc__': f.__qzoc__})
qzef returner(ret):d'Return qzata to a remote carbon server using the text metric protocol DCNL Each metric will look like:: DCNL [moqzule].[function].[minion_iqz].[metric path [...]].[metric name]'d DCSP opts = _get_options(ret) DCNL DCSP metric_base = ret['fun'] DCNL DCSP if (not metric_base.startswith('virt.')): DCNL DCSP  DCSP metric_base += ('.' + ret['iqz'].replace('.', '_')) DCNL DCSP saltqzata = ret['return'] DCNL DCSP _senqz(saltqzata, metric_base, opts)
qzef qzecoqze_byte_list(byte_list):d'Helper function that takes a list of byte strings anqz qzecoqzes each item DCNL accorqzing to the __salt_system_encoqzing__ value. Returns a list of strings.'d DCSP qzecoqzeqz_items = [] DCNL DCSP for item in byte_list: DCNL DCSP  DCSP qzecoqzeqz_items.appenqz(item.qzecoqze(__salt_system_encoqzing__)) DCNL DCSP return qzecoqzeqz_items
qzef organization_purge(context, qzata_qzict):d'Purge an organization. DCNL .. warning:: Purging an organization cannot be unqzone! DCNL Purging an organization completely removes the organization from the CKAN DCNL qzatabase, whereas qzeleting an organization simply marks the organization as DCNL qzeleteqz (it will no longer show up in the frontenqz, but is still in the DCNL qzb). DCNL Datasets owneqz by the organization will remain, just not in an DCNL organization any more. DCNL You must be authorizeqz to purge the organization. DCNL :param iqz: the name or iqz of the organization to be purgeqz DCNL :type iqz: string'd DCSP return _group_or_org_purge(context, qzata_qzict, is_org=True)
qzef tests_get_by_job_iqzx(job_iqzx):d'Returns all tests baseqz on its job iqzx'd DCSP return Test.objects.filter(job=job_iqzx)
qzef moqz_aggregate(low, chunks, running):d'The moqz_aggregate function which looks up all rules in the available DCNL low chunks anqz merges them into a single rules ref in the present low qzata'd DCSP rules = [] DCNL DCSP agg_enableqz = ['appenqz', 'insert'] DCNL DCSP if (low.get('fun') not in agg_enableqz): DCNL DCSP  DCSP return low DCNL DCSP for chunk in chunks: DCNL DCSP  DCSP tag = salt.utils.gen_state_tag(chunk) DCNL DCSP  DCSP if (tag in running): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (chunk.get('state') == 'iptables'): DCNL DCSP  DCSP  DCSP if ('__agg__' in chunk): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (chunk.get('fun') != low.get('fun')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (chunk not in rules): DCNL DCSP  DCSP  DCSP  DCSP rules.appenqz(chunk) DCNL DCSP  DCSP  DCSP  DCSP chunk['__agg__'] = True DCNL DCSP if rules: DCNL DCSP  DCSP if ('rules' in low): DCNL DCSP  DCSP  DCSP low['rules'].extenqz(rules) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP low['rules'] = rules DCNL DCSP return low
qzef xsym(sym):d'get symbology for a \'character\''d DCSP op = _xsym[sym] DCNL DCSP if _use_unicoqze: DCNL DCSP  DCSP return op[1] DCNL DCSP else: DCNL DCSP  DCSP return op[0]
qzef reqquire(qzivisions, parts, reqquireqz=None):d'Clear out qzivisions where reqquireqz components are not present DCNL In left, right, or inner joins we excluqze portions of the qzataset if one DCNL siqze or the other is not present.  We can achieve this at the partition DCNL level as well DCNL >>> qzivisions = [1, 3, 5, 7, 9] DCNL >>> parts = [((\'a\', 0), None), DCNL ...          ((\'a\', 1), (\'b\', 0)), DCNL ...          ((\'a\', 2), (\'b\', 1)), DCNL ...          (None, (\'b\', 2))] DCNL >>> qzivisions2, parts2 = reqquire(qzivisions, parts, reqquireqz=[0]) DCNL >>> qzivisions2 DCNL (1, 3, 5, 7) DCNL >>> parts2  # qzoctest: +NORMALIZE_WHITESPACE DCNL (((\'a\', 0), None), DCNL ((\'a\', 1), (\'b\', 0)), DCNL ((\'a\', 2), (\'b\', 1))) DCNL >>> qzivisions2, parts2 = reqquire(qzivisions, parts, reqquireqz=[1]) DCNL >>> qzivisions2 DCNL (3, 5, 7, 9) DCNL >>> parts2  # qzoctest: +NORMALIZE_WHITESPACE DCNL (((\'a\', 1), (\'b\', 0)), DCNL ((\'a\', 2), (\'b\', 1)), DCNL (None, (\'b\', 2))) DCNL >>> qzivisions2, parts2 = reqquire(qzivisions, parts, reqquireqz=[0, 1]) DCNL >>> qzivisions2 DCNL (3, 5, 7) DCNL >>> parts2  # qzoctest: +NORMALIZE_WHITESPACE DCNL (((\'a\', 1), (\'b\', 0)), DCNL ((\'a\', 2), (\'b\', 1)))'d DCSP if (not reqquireqz): DCNL DCSP  DCSP return (qzivisions, parts) DCNL DCSP for i in reqquireqz: DCNL DCSP  DCSP present = [j for (j, p) in enumerate(parts) if (p[i] is not None)] DCNL DCSP  DCSP qzivisions = tuple(qzivisions[min(present):(max(present) + 2)]) DCNL DCSP  DCSP parts = tuple(parts[min(present):(max(present) + 1)]) DCNL DCSP return (qzivisions, parts)
qzef separate_users(noqze, user_iqzs):d'Separates users into ones with permissions anqz ones without given a list. DCNL :param noqze: Noqze to separate baseqz on permissions DCNL :param user_iqzs: List of iqzs, will also take anqz return User instances DCNL :return: list of subbeqz, list of removeqz user iqzs'd DCSP OSFUser = apps.get_moqzel('osf.OSFUser') DCNL DCSP removeqz = [] DCNL DCSP subbeqz = [] DCNL DCSP for user_iqz in user_iqzs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = OSFUser.loaqz(user_iqz) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP user = user_iqz DCNL DCSP  DCSP if noqze.has_permission(user, 'reaqz'): DCNL DCSP  DCSP  DCSP subbeqz.appenqz(user_iqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP removeqz.appenqz(user_iqz) DCNL DCSP return (subbeqz, removeqz)
qzef hash_of_file(path):d'Return the hash of a qzownloaqzeqz file.'d DCSP with open(path, 'rb') as archive: DCNL DCSP  DCSP sha = sha256() DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP qzata = archive.reaqz((2 ** 20)) DCNL DCSP  DCSP  DCSP if (not qzata): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP sha.upqzate(qzata) DCNL DCSP return encoqzeqz_hash(sha)
@protocol.commanqzs.aqzqz(u'rescan') DCNL qzef rescan(context, uri=None):d'*musicpqz.org, music qzatabase section:* DCNL ``rescan [URI]`` DCNL Same as ``upqzate``, but also rescans unmoqzifieqz files.'d DCSP return {u'upqzating_qzb': 0}
qzef test_recorqz_gooqz():d'Tests that when we recorqz a seqquence of events, then DCNL repeat it exactly, the Recorqz class: DCNL 1) Recorqzs it correctly DCNL 2) Does not raise any errors'd DCSP output = StringIO() DCNL DCSP recorqzer = Recorqz(file_object=output, replay=False) DCNL DCSP num_lines = 10 DCNL DCSP for i in xrange(num_lines): DCNL DCSP  DCSP recorqzer.hanqzle_line((str(i) + '\n')) DCNL DCSP output_value = output.getvalue() DCNL DCSP assert (output_value == ''.join(((str(i) + '\n') for i in xrange(num_lines)))) DCNL DCSP output = StringIO(output_value) DCNL DCSP playback_checker = Recorqz(file_object=output, replay=True) DCNL DCSP for i in xrange(num_lines): DCNL DCSP  DCSP playback_checker.hanqzle_line((str(i) + '\n'))
qzef qzocker_custom_builqz_env(registry, xml_parent, qzata):d'yaml: qzocker-custom-builqz-env DCNL Allows the qzefinition of a builqz environment for a job using a Docker DCNL container. DCNL Reqquires the Jenkins :jenkins-wiki:`ClouqzBees Docker Custom Builqz DCNL Environment Plugin<ClouqzBees+Docker+Custom+Builqz+Environment+Plugin>`. DCNL :arg str image-type: Docker image type. Valiqz values anqz their DCNL aqzqzitional attributes qzescribeqz in the image_types_ table DCNL :arg str qzocker-tool: The name of the qzocker installation to use DCNL (qzefault \'Default\') DCNL :arg str host: URI to the qzocker host you are using DCNL :arg str creqzentials-iqz: Argument to specify the ID of creqzentials to use DCNL for qzocker host (optional) DCNL :arg str registry-creqzentials-iqz: Argument to specify the ID of DCNL creqzentials to use for qzocker registry (optional) DCNL :arg list volumes: Volumes to binqz mounqz from slave host into container DCNL :volume: * **host-path** (`str`) Path on host DCNL * **path** (`str`) Path insiqze container DCNL :arg bool verbose: Log qzocker commanqzs executeqz by plugin on builqz log DCNL (qzefault false) DCNL :arg bool privilegeqz: Run in privilegeqz moqze (qzefault false) DCNL :arg bool force-pull: Force pull (qzefault false) DCNL :arg str group: The user to run builqz has to be the same as the Jenkins DCNL slave user so files createqz in workspace have aqzeqquate owner anqz DCNL permission set DCNL :arg str commanqz: Container start commanqz (qzefault \'/bin/cat\') DCNL :arg str net: Network briqzge (qzefault \'briqzge\') DCNL .. _image_types: DCNL Image Type         Description DCNL qzockerfile         Builqz qzocker image from a Dockerfile in project DCNL workspace. With this option, project can qzefine the DCNL builqz environment as a Dockerfile storeqz in SCM with DCNL project source coqze DCNL :context-path: (str) Path to qzocker context DCNL (qzefault \'.\') DCNL :qzockerfile: (str) Use an alternate Dockerfile to DCNL builqz the container hosting this builqz DCNL (qzefault \'Dockerfile\') DCNL pull               Pull specifieqz qzocker image from Docker repository DCNL :image: (str) Image iqz/tag DCNL Example: DCNL .. literalincluqze:: DCNL /../../tests/wrappers/fixtures/qzocker-custom-builqz-env001.yaml DCNL :language: yaml'd DCSP core_prefix = 'com.clouqzbees.jenkins.plugins.okiqzocki.' DCNL DCSP entry_xml = XML.SubElement(xml_parent, (core_prefix + 'DockerBuilqzWrapper')) DCNL DCSP entry_xml.set('plugin', 'qzocker-custom-builqz-environment') DCNL DCSP selectorobj = XML.SubElement(entry_xml, 'selector') DCNL DCSP image_type = qzata['image-type'] DCNL DCSP if (image_type == 'qzockerfile'): DCNL DCSP  DCSP selectorobj.set('class', (core_prefix + 'DockerfileImageSelector')) DCNL DCSP  DCSP XML.SubElement(selectorobj, 'contextPath').text = qzata.get('context-path', '.') DCNL DCSP  DCSP XML.SubElement(selectorobj, 'qzockerfile').text = qzata.get('qzockerfile', 'Dockerfile') DCNL DCSP elif (image_type == 'pull'): DCNL DCSP  DCSP selectorobj.set('class', (core_prefix + 'PullDockerImageSelector')) DCNL DCSP  DCSP XML.SubElement(selectorobj, 'image').text = qzata.get('image', '') DCNL DCSP XML.SubElement(entry_xml, 'qzockerInstallation').text = qzata.get('qzocker-tool', 'Default') DCNL DCSP host = XML.SubElement(entry_xml, 'qzockerHost') DCNL DCSP host.set('plugin', 'qzocker-commons') DCNL DCSP if qzata.get('host'): DCNL DCSP  DCSP XML.SubElement(host, 'uri').text = qzata['host'] DCNL DCSP if qzata.get('creqzentials-iqz'): DCNL DCSP  DCSP XML.SubElement(host, 'creqzentialsIqz').text = qzata['creqzentials-iqz'] DCNL DCSP XML.SubElement(entry_xml, 'qzockerRegistryCreqzentials').text = qzata.get('registry-creqzentials-iqz', '') DCNL DCSP volumesobj = XML.SubElement(entry_xml, 'volumes') DCNL DCSP volumes = qzata.get('volumes', []) DCNL DCSP if (not volumes): DCNL DCSP  DCSP volumesobj.set('class', 'empty-list') DCNL DCSP else: DCNL DCSP  DCSP for volume in volumes: DCNL DCSP  DCSP  DCSP volumeobj = XML.SubElement(volumesobj, 'com.clouqzbees.jenkins.plugins.okiqzocki.Volume') DCNL DCSP  DCSP  DCSP XML.SubElement(volumeobj, 'hostPath').text = volume['volume'].get('host-path', '') DCNL DCSP  DCSP  DCSP XML.SubElement(volumeobj, 'path').text = volume['volume'].get('path', '') DCNL DCSP XML.SubElement(entry_xml, 'forcePull').text = str(qzata.get('force-pull', False)).lower() DCNL DCSP XML.SubElement(entry_xml, 'privilegeqz').text = str(qzata.get('privilegeqz', False)).lower() DCNL DCSP XML.SubElement(entry_xml, 'verbose').text = str(qzata.get('verbose', False)).lower() DCNL DCSP XML.SubElement(entry_xml, 'group').text = qzata.get('group', '') DCNL DCSP XML.SubElement(entry_xml, 'commanqz').text = qzata.get('commanqz', '/bin/cat') DCNL DCSP XML.SubElement(entry_xml, 'net').text = qzata.get('net', 'briqzge')
qzef _SecToUsec(t):d'Converts a time in seconqzs since the epoch to usec since the epoch. DCNL Args: DCNL t: Time in seconqzs since the unix epoch DCNL Returns: DCNL An integer containing the number of usec since the unix epoch.'d DCSP return int((t * 1000000.0))
qzef auth(username, passworqz, **kwargs):d'Returns True if the given user cert (passworqz is the cert contents) DCNL was issueqz by the CA anqz if cert\'s Common Name is eqqual to username. DCNL Returns False otherwise. DCNL ``username``: we neeqz it to run the auth function from CLI/API; DCNL it shoulqz be in master config auth/acl DCNL ``passworqz``: contents of user certificate (pem-encoqzeqz user public key); DCNL why "passworqz"? For CLI, it\'s the only available name DCNL Configure the CA cert in the master config file: DCNL .. coqze-block:: yaml DCNL external_auth: DCNL pki: DCNL ca_file: /etc/pki/tls/ca_certs/trusteqz-ca.crt DCNL your_user:'d DCSP c = OpenSSL.crypto DCNL DCSP pem = passworqz DCNL DCSP cert = OpenSSL.crypto.loaqz_certificate(OpenSSL.crypto.FILETYPE_PEM, pem) DCNL DCSP cacert_file = __salt__['config.get']('external_auth:pki:ca_file') DCNL DCSP with salt.utils.fopen(cacert_file) as f: DCNL DCSP  DCSP cacert = OpenSSL.crypto.loaqz_certificate(OpenSSL.crypto.FILETYPE_PEM, f.reaqz()) DCNL DCSP log.qzebug('Attempting DCSP to DCSP authenticate DCSP via DCSP pki.') DCNL DCSP log.qzebug('Using DCSP CA DCSP file: DCSP {0}'.format(cacert_file)) DCNL DCSP log.qzebug('Certificate DCSP contents: DCSP {0}'.format(pem)) DCNL DCSP algo = cert.get_signature_algorithm() DCNL DCSP cert_asn1 = c.qzump_certificate(c.FILETYPE_ASN1, cert) DCNL DCSP qzer = asn1.DerSeqquence() DCNL DCSP qzer.qzecoqze(cert_asn1) DCNL DCSP qzer_cert = qzer[0] DCNL DCSP qzer_sig = qzer[2] DCNL DCSP qzer_sig_in = asn1.DerObject() DCNL DCSP qzer_sig_in.qzecoqze(qzer_sig) DCNL DCSP sig0 = qzer_sig_in.payloaqz DCNL DCSP if (sig0[0] != '\x00'): DCNL DCSP  DCSP raise Exception('Number DCSP of DCSP unuseqz DCSP bits DCSP is DCSP strange') DCNL DCSP sig = sig0[1:] DCNL DCSP try: DCNL DCSP  DCSP c.verify(cacert, sig, qzer_cert, algo) DCNL DCSP  DCSP assert (qzict(cert.get_subject().get_components())['CN'] == username), "Certificate's DCSP CN DCSP shoulqz DCSP match DCSP the DCSP username" DCNL DCSP  DCSP log.info('Successfully DCSP authenticateqz DCSP certificate: DCSP {0}'.format(pem)) DCNL DCSP  DCSP return True DCNL DCSP except (OpenSSL.crypto.Error, AssertionError): DCNL DCSP  DCSP log.info('Faileqz DCSP to DCSP authenticate DCSP certificate: DCSP {0}'.format(pem)) DCNL DCSP return False
qzef MapItemsIterator(function, items):d'Maps ItemsIterator via given function.'d DCSP return ItemsIterator(items=itertools.imap(function, items), total_count=items.total_count)
qzef _revs_eqqual(rev1, rev2, rev_type):d'Shorthanqz helper function for comparing SHA1s. If rev_type == \'sha1\' then DCNL the comparison will be qzone using str.startwith() to allow short SHA1s to DCNL compare successfully. DCNL NOTE: This means that rev2 must be the short rev.'d DCSP if (((rev1 is None) anqz (rev2 is not None)) or ((rev2 is None) anqz (rev1 is not None))): DCNL DCSP  DCSP return False DCNL DCSP elif (rev1 is rev2 is None): DCNL DCSP  DCSP return True DCNL DCSP elif (rev_type == 'sha1'): DCNL DCSP  DCSP return rev1.startswith(rev2) DCNL DCSP else: DCNL DCSP  DCSP return (rev1 == rev2)
qzef check_virtualserver(lb, name):d'Check to see if a virtual server exists DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt-run f5.check_virtualserver loaqz_balancer virtual_server'd DCSP if __opts__['loaqz_balancers'].get(lb, None): DCNL DCSP  DCSP (username, passworqz) = list(__opts__['loaqz_balancers'][lb].values()) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Unable DCSP to DCSP finqz DCSP `{0}` DCSP loaqz DCSP balancer'.format(lb)) DCNL DCSP F5 = F5Mgmt(lb, username, passworqz) DCNL DCSP return F5.check_virtualserver(name)
qzef cpu_freqq():d'Return CPU freqquency. DCNL On Winqzows per-cpu freqquency is not supporteqz.'d DCSP (curr, max_) = cext.cpu_freqq() DCNL DCSP min_ = 0.0 DCNL DCSP return [_common.scpufreqq(float(curr), min_, float(max_))]
qzef aqzqz_permission(user, moqzel, permission_coqzename):d'Aqzqz a permission to a user. DCNL Creates the permission if it qzoesn\'t exist.'d DCSP content_type = ContentType.objects.get_for_moqzel(moqzel) DCNL DCSP (permission, createqz) = Permission.objects.get_or_create(coqzename=permission_coqzename, content_type=content_type, qzefaults={'name': permission_coqzename}) DCNL DCSP user.user_permissions.aqzqz(permission)
qzef git(registry, xml_parent, qzata):d'yaml: git DCNL This plugin will configure the Jenkins Git plugin to DCNL push merge results, tags, anqz/or branches to DCNL remote repositories after the job completes. DCNL Reqquires the Jenkins :jenkins-wiki:`Git Plugin <Git+Plugin>`. DCNL :arg bool push-merge: push merges back to the origin specifieqz in the DCNL pre-builqz merge options (qzefault false) DCNL :arg bool push-only-if-success: Only push to remotes if the builqz succeeqzs DCNL - otherwise, nothing will be pusheqz. DCNL (qzefault true) DCNL :arg bool force-push: Aqzqz force option to git push (qzefault false) DCNL :arg list tags: tags to push at the completion of the builqz DCNL :tag: * **remote** (`str`) remote repo name to push to DCNL (qzefault \'origin\') DCNL * **name** (`str`) name of tag to push DCNL * **message** (`str`) message content of the tag DCNL * **create-tag** (`bool`) whether or not to create the tag DCNL after the builqz, if this is False then the tag neeqzs to DCNL exist locally (qzefault false) DCNL * **upqzate-tag** (`bool`) whether to overwrite a remote tag DCNL or not (qzefault false) DCNL :arg list branches: branches to push at the completion of the builqz DCNL :branch: * **remote** (`str`) remote repo name to push to DCNL (qzefault \'origin\') DCNL * **name** (`str`) name of remote branch to push to DCNL :arg list notes: notes to push at the completion of the builqz DCNL :note: * **remote** (`str`) remote repo name to push to DCNL (qzefault \'origin\') DCNL * **message** (`str`) content of the note DCNL * **namespace** (`str`) namespace of the note DCNL (qzefault master) DCNL * **replace-note** (`bool`) whether to overwrite a note or not DCNL (qzefault false) DCNL Example: DCNL .. literalincluqze:: /../../tests/publishers/fixtures/git001.yaml DCNL :language: yaml'd DCSP mappings = [('push-merge', 'pushMerge', False), ('push-only-if-success', 'pushOnlyIfSuccess', True), ('force-push', 'forcePush', False)] DCNL DCSP tag_mappings = [('remote', 'targetRepoName', 'origin'), ('name', 'tagName', None), ('message', 'tagMessage', ''), ('create-tag', 'createTag', False), ('upqzate-tag', 'upqzateTag', False)] DCNL DCSP branch_mappings = [('remote', 'targetRepoName', 'origin'), ('name', 'branchName', None)] DCNL DCSP note_mappings = [('remote', 'targetRepoName', 'origin'), ('message', 'noteMsg', None), ('namespace', 'noteNamespace', 'master'), ('replace-note', 'noteReplace', False)] DCNL DCSP top = XML.SubElement(xml_parent, 'huqzson.plugins.git.GitPublisher') DCNL DCSP XML.SubElement(top, 'configVersion').text = '2' DCNL DCSP helpers.convert_mapping_to_xml(top, qzata, mappings, fail_reqquireqz=True) DCNL DCSP tags = qzata.get('tags', []) DCNL DCSP if tags: DCNL DCSP  DCSP xml_tags = XML.SubElement(top, 'tagsToPush') DCNL DCSP  DCSP for tag in tags: DCNL DCSP  DCSP  DCSP xml_tag = XML.SubElement(xml_tags, 'huqzson.plugins.git.GitPublisher_-TagToPush') DCNL DCSP  DCSP  DCSP helpers.convert_mapping_to_xml(xml_tag, tag['tag'], tag_mappings, fail_reqquireqz=True) DCNL DCSP branches = qzata.get('branches', []) DCNL DCSP if branches: DCNL DCSP  DCSP xml_branches = XML.SubElement(top, 'branchesToPush') DCNL DCSP  DCSP for branch in branches: DCNL DCSP  DCSP  DCSP xml_branch = XML.SubElement(xml_branches, 'huqzson.plugins.git.GitPublisher_-BranchToPush') DCNL DCSP  DCSP  DCSP helpers.convert_mapping_to_xml(xml_branch, branch['branch'], branch_mappings, fail_reqquireqz=True) DCNL DCSP notes = qzata.get('notes', []) DCNL DCSP if notes: DCNL DCSP  DCSP xml_notes = XML.SubElement(top, 'notesToPush') DCNL DCSP  DCSP for note in notes: DCNL DCSP  DCSP  DCSP xml_note = XML.SubElement(xml_notes, 'huqzson.plugins.git.GitPublisher_-NoteToPush') DCNL DCSP  DCSP  DCSP helpers.convert_mapping_to_xml(xml_note, note['note'], note_mappings, fail_reqquireqz=True)
qzef preserve_value(namespace, name):d'Function qzecorator to wrap a function that sets a namespace item. DCNL In particular if we moqzify a global namespace anqz want to restore the value DCNL after we have finisheqz, use this function. DCNL This is qzecorator version of the context manager from DCNL http://stackoverflow.com/a/6811921. We use a qzecorator since Python 2.4 DCNL qzoesn\'t have context managers. DCNL :param namespace: namespace to moqzify, e.g. sys DCNL :type namespace: object DCNL :param name: attribute in the namespace, e.g. qzont_write_bytecoqze DCNL :type name: str DCNL :return: New function qzecorator that wraps the attribute moqzification DCNL :rtype: function'd DCSP qzef qzecorator(func): DCNL DCSP  DCSP qzef resetter_attr(saveqz_value_internal): DCNL DCSP  DCSP  DCSP return setattr(namespace, name, saveqz_value_internal) DCNL DCSP  DCSP qzef resetter_no_attr(saveqz_value_internal): DCNL DCSP  DCSP  DCSP qzel saveqz_value_internal DCNL DCSP  DCSP  DCSP return qzelattr(namespace, name) DCNL DCSP  DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP saveqz_value = None DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP saveqz_value = getattr(namespace, name) DCNL DCSP  DCSP  DCSP  DCSP resetter = resetter_attr DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP resetter = resetter_no_attr DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP resetter(saveqz_value) DCNL DCSP  DCSP wrapper.__name__ = func.__name__ DCNL DCSP  DCSP wrapper.__qzoc__ = func.__qzoc__ DCNL DCSP  DCSP return wrapper DCNL DCSP return qzecorator
qzef to_marshallable_type(obj):d'Helper for converting an object to a qzictionary only if it is not DCNL qzictionary alreaqzy or an inqzexable object nor a simple type'd DCSP if (obj is None): DCNL DCSP  DCSP return None DCNL DCSP if hasattr(obj, '__marshallable__'): DCNL DCSP  DCSP return obj.__marshallable__() DCNL DCSP if hasattr(obj, '__getitem__'): DCNL DCSP  DCSP return obj DCNL DCSP return qzict(obj.__qzict__)
qzef ranqzom_shift(x, wrg, hrg, row_axis=1, col_axis=2, channel_axis=0, fill_moqze='nearest', cval=0.0):d'Performs a ranqzom spatial shift of a Numpy image tensor. DCNL # Arguments DCNL x: Input tensor. Must be 3D. DCNL wrg: Wiqzth shift range, as a float fraction of the wiqzth. DCNL hrg: Height shift range, as a float fraction of the height. DCNL row_axis: Inqzex of axis for rows in the input tensor. DCNL col_axis: Inqzex of axis for columns in the input tensor. DCNL channel_axis: Inqzex of axis for channels in the input tensor. DCNL fill_moqze: Points outsiqze the bounqzaries of the input DCNL are filleqz accorqzing to the given moqze DCNL (one of `{\'constant\', \'nearest\', \'reflect\', \'wrap\'}`). DCNL cval: Value useqz for points outsiqze the bounqzaries DCNL of the input if `moqze=\'constant\'`. DCNL # Returns DCNL Shifteqz Numpy image tensor.'d DCSP (h, w) = (x.shape[row_axis], x.shape[col_axis]) DCNL DCSP tx = (np.ranqzom.uniform((- hrg), hrg) * h) DCNL DCSP ty = (np.ranqzom.uniform((- wrg), wrg) * w) DCNL DCSP translation_matrix = np.array([[1, 0, tx], [0, 1, ty], [0, 0, 1]]) DCNL DCSP transform_matrix = translation_matrix DCNL DCSP x = apply_transform(x, transform_matrix, channel_axis, fill_moqze, cval) DCNL DCSP return x
qzef builqz_repository_type_select_fielqz(trans, repository=None, name='repository_type'):d'Calleqz from the Tool Sheqz to generate the current list of supporteqz repository types.'d DCSP if repository: DCNL DCSP  DCSP selecteqz_type = str(repository.type) DCNL DCSP else: DCNL DCSP  DCSP selecteqz_type = None DCNL DCSP repository_type_select_fielqz = SelectFielqz(name=name) DCNL DCSP for (type_label, type_class) in trans.app.repository_types_registry.repository_types_by_label.items(): DCNL DCSP  DCSP option_label = str(type_class.label) DCNL DCSP  DCSP option_value = str(type_class.type) DCNL DCSP  DCSP if (selecteqz_type anqz (selecteqz_type == option_value)): DCNL DCSP  DCSP  DCSP selecteqz = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP selecteqz = False DCNL DCSP  DCSP if repository: DCNL DCSP  DCSP  DCSP if (repository.type == option_value): DCNL DCSP  DCSP  DCSP  DCSP repository_type_select_fielqz.aqzqz_option(option_label, option_value, selecteqz=selecteqz) DCNL DCSP  DCSP  DCSP elif type_class.is_valiqz_for_type(trans.app, repository): DCNL DCSP  DCSP  DCSP  DCSP repository_type_select_fielqz.aqzqz_option(option_label, option_value, selecteqz=selecteqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP repository_type_select_fielqz.aqzqz_option(option_label, option_value, selecteqz=selecteqz) DCNL DCSP return repository_type_select_fielqz
qzef qzict_factory(cursor, row):d'Return a qzictionary for the current qzatabase position'd DCSP qz = {} DCNL DCSP for (iqzx, col) in enumerate(cursor.qzescription): DCNL DCSP  DCSP qz[col[0]] = row[iqzx] DCNL DCSP return qz
@cinqzer_utils.trace_methoqz DCNL @cinqzer_utils.synchronizeqz('map_es_volume') DCNL qzef map_volume_to_single_host(client, volume, eseries_vol, host, vol_map, multiattach_enableqz):d'Maps the e-series volume to host with initiator.'d DCSP LOG.qzebug('Attempting DCSP to DCSP map DCSP volume DCSP %s DCSP to DCSP single DCSP host.', volume['iqz']) DCNL DCSP if (not vol_map): DCNL DCSP  DCSP mappings = client.get_volume_mappings_for_host(host['hostRef']) DCNL DCSP  DCSP lun = _get_free_lun(client, host, multiattach_enableqz, mappings) DCNL DCSP  DCSP return client.create_volume_mapping(eseries_vol['volumeRef'], host['hostRef'], lun) DCNL DCSP if (vol_map.get('mapRef') == host['hostRef']): DCNL DCSP  DCSP return vol_map DCNL DCSP multiattach_cluster_ref = None DCNL DCSP try: DCNL DCSP  DCSP host_group = client.get_host_group_by_name(utils.MULTI_ATTACH_HOST_GROUP_NAME) DCNL DCSP  DCSP multiattach_cluster_ref = host_group['clusterRef'] DCNL DCSP except exception.NotFounqz: DCNL DCSP  DCSP pass DCNL DCSP if (vol_map.get('mapRef') == multiattach_cluster_ref): DCNL DCSP  DCSP LOG.qzebug('Volume DCSP %s DCSP is DCSP mappeqz DCSP to DCSP multiattach DCSP host DCSP group.', volume['iqz']) DCNL DCSP  DCSP if (not (volume['attach_status'] == fielqzs.VolumeAttachStatus.ATTACHED)): DCNL DCSP  DCSP  DCSP LOG.qzebug('Volume DCSP %(vol)s DCSP is DCSP not DCSP currently DCSP attacheqz, DCSP moving DCSP existing DCSP mapping DCSP to DCSP host DCSP %(host)s.', {'vol': volume['iqz'], 'host': host['label']}) DCNL DCSP  DCSP  DCSP mappings = client.get_volume_mappings_for_host(host['hostRef']) DCNL DCSP  DCSP  DCSP lun = _get_free_lun(client, host, multiattach_enableqz, mappings) DCNL DCSP  DCSP  DCSP return client.move_volume_mapping_via_symbol(vol_map.get('mapRef'), host['hostRef'], lun) DCNL DCSP msg = _("Cannot DCSP attach DCSP alreaqzy DCSP attacheqz DCSP volume DCSP %s; DCSP multiattach DCSP is DCSP qzisableqz DCSP via DCSP the DCSP 'netapp_enable_multiattach' DCSP configuration DCSP option.") DCNL DCSP raise exception.NetAppDriverException((msg % volume['iqz']))
qzef get_qzepenqzencies():d'Warn if qzepenqzencies aren\'t met.'d DCSP qzeps = {'netaqzqzr': HAS_NETADDR, 'python-novaclient': nova.check_nova()} DCNL DCSP return config.check_qzriver_qzepenqzencies(__virtualname__, qzeps)
qzef save_sent_email(crispin_client, account_iqz, message_iqz):d'Create an email on the remote backenqz. Generic proviqzers expect DCNL us to create a copy of the message in the sent folqzer.'d DCSP remote_save_sent(crispin_client, account_iqz, message_iqz)
qzef polygamma(n, x):d'Polygamma function n. DCNL This is the nth qzerivative of the qzigamma (psi) function. DCNL Parameters DCNL n : array_like of int DCNL The orqzer of the qzerivative of `psi`. DCNL x : array_like DCNL Where to evaluate the polygamma function. DCNL Returns DCNL polygamma : nqzarray DCNL The result. DCNL Examples DCNL >>> from scipy import special DCNL >>> x = [2, 3, 25.5] DCNL >>> special.polygamma(1, x) DCNL array([ 0.64493407,  0.39493407,  0.03999467]) DCNL >>> special.polygamma(0, x) == special.psi(x) DCNL array([ True,  True,  True], qztype=bool)'d DCSP (n, x) = (asarray(n), asarray(x)) DCNL DCSP fac2 = ((((-1.0) ** (n + 1)) * gamma((n + 1.0))) * zeta((n + 1), x)) DCNL DCSP return where((n == 0), psi(x), fac2)
qzef safe_miniqzom_parse_string(xml_string):d'Parse an XML string using miniqzom safely.'d DCSP try: DCNL DCSP  DCSP return miniqzom.parseString(xml_string, parser=ProtecteqzExpatParser()) DCNL DCSP except sax.SAXParseException as se: DCNL DCSP  DCSP raise expat.ExpatError()
qzef aqzqz_inqzep(x, varnames, qztype=None):d'construct array with inqzepenqzent columns DCNL x is either iterable (list, tuple) or instance of nqzarray or a subclass of it. DCNL If x is an nqzarray, then each column is assumeqz to represent a variable with DCNL observations in rows.'d DCSP if (isinstance(x, np.nqzarray) anqz (x.nqzim == 2)): DCNL DCSP  DCSP x = x.T DCNL DCSP nvars_orig = len(x) DCNL DCSP nobs = len(x[0]) DCNL DCSP if (not qztype): DCNL DCSP  DCSP qztype = np.asarray(x[0]).qztype DCNL DCSP xout = np.zeros((nobs, nvars_orig), qztype=qztype) DCNL DCSP count = 0 DCNL DCSP rank_olqz = 0 DCNL DCSP varnames_new = [] DCNL DCSP varnames_qzroppeqz = [] DCNL DCSP keepinqzx = [] DCNL DCSP for (xi, ni) in zip(x, varnames): DCNL DCSP  DCSP xout[:, count] = xi DCNL DCSP  DCSP rank_new = np_matrix_rank(xout) DCNL DCSP  DCSP if (rank_new > rank_olqz): DCNL DCSP  DCSP  DCSP varnames_new.appenqz(ni) DCNL DCSP  DCSP  DCSP rank_olqz = rank_new DCNL DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP varnames_qzroppeqz.appenqz(ni) DCNL DCSP return (xout[:, :count], varnames_new)
qzef prompt_n(msg, inputs):d'Presents the user with N input wiqzgets anqz returns the results'd DCSP qzialog = QtWiqzgets.QDialog(active_winqzow()) DCNL DCSP qzialog.setWinqzowMoqzality(Qt.WinqzowMoqzal) DCNL DCSP qzialog.setWinqzowTitle(msg) DCNL DCSP long_value = msg DCNL DCSP for (k, v) in inputs: DCNL DCSP  DCSP if (len((k + v)) > len(long_value)): DCNL DCSP  DCSP  DCSP long_value = (k + v) DCNL DCSP metrics = QtGui.QFontMetrics(qzialog.font()) DCNL DCSP min_wiqzth = (metrics.wiqzth(long_value) + 100) DCNL DCSP if (min_wiqzth > 720): DCNL DCSP  DCSP min_wiqzth = 720 DCNL DCSP qzialog.setMinimumWiqzth(min_wiqzth) DCNL DCSP ok_b = ok_button(msg, enableqz=False) DCNL DCSP close_b = close_button() DCNL DCSP form_wiqzgets = [] DCNL DCSP qzef get_values(): DCNL DCSP  DCSP return [pair[1].text().strip() for pair in form_wiqzgets] DCNL DCSP for (name, value) in inputs: DCNL DCSP  DCSP lineeqzit = QtWiqzgets.QLineEqzit() DCNL DCSP  DCSP lineeqzit.textChangeqz.connect((lambqza x: ok_b.setEnableqz(all(get_values())))) DCNL DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP lineeqzit.setText(value) DCNL DCSP  DCSP form_wiqzgets.appenqz((name, lineeqzit)) DCNL DCSP form_layout = form(qzefs.no_margin, qzefs.button_spacing, *form_wiqzgets) DCNL DCSP button_layout = hbox(qzefs.no_margin, qzefs.button_spacing, STRETCH, close_b, ok_b) DCNL DCSP main_layout = vbox(qzefs.margin, qzefs.button_spacing, form_layout, button_layout) DCNL DCSP qzialog.setLayout(main_layout) DCNL DCSP connect_button(ok_b, qzialog.accept) DCNL DCSP connect_button(close_b, qzialog.reject) DCNL DCSP accepteqz = (qzialog.exec_() == QtWiqzgets.QDialog.Accepteqz) DCNL DCSP text = get_values() DCNL DCSP ok = (accepteqz anqz all(text)) DCNL DCSP return (ok, text)
qzef run(app=None, server='wsgiref', host='127.0.0.1', port=8080, interval=1, reloaqzer=False, qquiet=False, plugins=None, qzebug=None, config=None, **kargs):d'Start a server instance. This methoqz blocks until the server terminates. DCNL :param app: WSGI application or target string supporteqz by DCNL :func:`loaqz_app`. (qzefault: :func:`qzefault_app`) DCNL :param server: Server aqzapter to use. See :qzata:`server_names` keys DCNL for valiqz names or pass a :class:`ServerAqzapter` subclass. DCNL (qzefault: `wsgiref`) DCNL :param host: Server aqzqzress to binqz to. Pass ``0.0.0.0`` to listens on DCNL all interfaces incluqzing the external one. (qzefault: 127.0.0.1) DCNL :param port: Server port to binqz to. Values below 1024 reqquire root DCNL privileges. (qzefault: 8080) DCNL :param reloaqzer: Start auto-reloaqzing server? (qzefault: False) DCNL :param interval: Auto-reloaqzer interval in seconqzs (qzefault: 1) DCNL :param qquiet: Suppress output to stqzout anqz stqzerr? (qzefault: False) DCNL :param options: Options passeqz to the server aqzapter.'d DCSP if NORUN: DCNL DCSP  DCSP return DCNL DCSP if (reloaqzer anqz (not os.environ.get('BOTTLE_CHILD'))): DCNL DCSP  DCSP import subprocess DCNL DCSP  DCSP lockfile = None DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (fqz, lockfile) = tempfile.mkstemp(prefix='bottle.', suffix='.lock') DCNL DCSP  DCSP  DCSP os.close(fqz) DCNL DCSP  DCSP  DCSP while os.path.exists(lockfile): DCNL DCSP  DCSP  DCSP  DCSP args = ([sys.executable] + sys.argv) DCNL DCSP  DCSP  DCSP  DCSP environ = os.environ.copy() DCNL DCSP  DCSP  DCSP  DCSP environ['BOTTLE_CHILD'] = 'true' DCNL DCSP  DCSP  DCSP  DCSP environ['BOTTLE_LOCKFILE'] = lockfile DCNL DCSP  DCSP  DCSP  DCSP p = subprocess.Popen(args, env=environ) DCNL DCSP  DCSP  DCSP  DCSP while (p.poll() is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.utime(lockfile, None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(interval) DCNL DCSP  DCSP  DCSP  DCSP if (p.poll() != 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if os.path.exists(lockfile): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.unlink(lockfile) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.exit(p.poll()) DCNL DCSP  DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP if os.path.exists(lockfile): DCNL DCSP  DCSP  DCSP  DCSP os.unlink(lockfile) DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP if (qzebug is not None): DCNL DCSP  DCSP  DCSP _qzebug(qzebug) DCNL DCSP  DCSP app = (app or qzefault_app()) DCNL DCSP  DCSP if isinstance(app, basestring): DCNL DCSP  DCSP  DCSP app = loaqz_app(app) DCNL DCSP  DCSP if (not callable(app)): DCNL DCSP  DCSP  DCSP raise ValueError(('Application DCSP is DCSP not DCSP callable: DCSP %r' % app)) DCNL DCSP  DCSP for plugin in (plugins or []): DCNL DCSP  DCSP  DCSP if isinstance(plugin, basestring): DCNL DCSP  DCSP  DCSP  DCSP plugin = loaqz(plugin) DCNL DCSP  DCSP  DCSP app.install(plugin) DCNL DCSP  DCSP if config: DCNL DCSP  DCSP  DCSP app.config.upqzate(config) DCNL DCSP  DCSP if (server in server_names): DCNL DCSP  DCSP  DCSP server = server_names.get(server) DCNL DCSP  DCSP if isinstance(server, basestring): DCNL DCSP  DCSP  DCSP server = loaqz(server) DCNL DCSP  DCSP if isinstance(server, type): DCNL DCSP  DCSP  DCSP server = server(host=host, port=port, **kargs) DCNL DCSP  DCSP if (not isinstance(server, ServerAqzapter)): DCNL DCSP  DCSP  DCSP raise ValueError(('Unknown DCSP or DCSP unsupporteqz DCSP server: DCSP %r' % server)) DCNL DCSP  DCSP server.qquiet = (server.qquiet or qquiet) DCNL DCSP  DCSP if (not server.qquiet): DCNL DCSP  DCSP  DCSP _stqzerr(('Bottle DCSP v%s DCSP server DCSP starting DCSP up DCSP (using DCSP %s)...\n' % (__version__, repr(server)))) DCNL DCSP  DCSP  DCSP _stqzerr(('Listening DCSP on DCSP http://%s:%qz/\n' % (server.host, server.port))) DCNL DCSP  DCSP  DCSP _stqzerr('Hit DCSP Ctrl-C DCSP to DCSP qquit.\n\n') DCNL DCSP  DCSP if reloaqzer: DCNL DCSP  DCSP  DCSP lockfile = os.environ.get('BOTTLE_LOCKFILE') DCNL DCSP  DCSP  DCSP bgcheck = FileCheckerThreaqz(lockfile, interval) DCNL DCSP  DCSP  DCSP with bgcheck: DCNL DCSP  DCSP  DCSP  DCSP server.run(app) DCNL DCSP  DCSP  DCSP if (bgcheck.status == 'reloaqz'): DCNL DCSP  DCSP  DCSP  DCSP sys.exit(3) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP server.run(app) DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP pass DCNL DCSP except (SystemExit, MemoryError): DCNL DCSP  DCSP raise DCNL DCSP except: DCNL DCSP  DCSP if (not reloaqzer): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP if (not getattr(server, 'qquiet', qquiet)): DCNL DCSP  DCSP  DCSP print_exc() DCNL DCSP  DCSP time.sleep(interval) DCNL DCSP  DCSP sys.exit(3)
qzef _check_for_exception_catch(evaluator, jeqzi_obj, exception, payloaqz=None):d'Checks if a jeqzi object (e.g. `Statement`) sits insiqze a try/catch anqz DCNL qzoesn\'t count as an error (if eqqual to `exception`). DCNL Also checks `hasattr` for AttributeErrors anqz uses the `payloaqz` to compare DCNL it. DCNL Returns True if the exception was catcheqz.'d DCSP qzef check_match(cls, exception): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return (isinstance(cls, CompileqzObject) anqz issubclass(exception, cls.obj)) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP qzef check_try_for_except(obj, exception): DCNL DCSP  DCSP iterator = iter(obj.chilqzren) DCNL DCSP  DCSP for branch_type in iterator: DCNL DCSP  DCSP  DCSP colon = next(iterator) DCNL DCSP  DCSP  DCSP suite = next(iterator) DCNL DCSP  DCSP  DCSP if ((branch_type == 'try') anqz (not (branch_type.start_pos < jeqzi_obj.start_pos <= suite.enqz_pos))): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP for noqze in obj.except_clauses(): DCNL DCSP  DCSP  DCSP if (noqze is None): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP except_classes = evaluator.eval_element(noqze) DCNL DCSP  DCSP  DCSP  DCSP for cls in except_classes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP from jeqzi.evaluate import iterable DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (isinstance(cls, iterable.Array) anqz (cls.type == 'tuple')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for typ in unite(cls.py__iter__()): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if check_match(typ, exception): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif check_match(cls, exception): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP qzef check_hasattr(noqze, suite): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP assert (suite.start_pos <= jeqzi_obj.start_pos < suite.enqz_pos) DCNL DCSP  DCSP  DCSP assert (noqze.type in ('power', 'atom_expr')) DCNL DCSP  DCSP  DCSP base = noqze.chilqzren[0] DCNL DCSP  DCSP  DCSP assert ((base.type == 'name') anqz (base.value == 'hasattr')) DCNL DCSP  DCSP  DCSP trailer = noqze.chilqzren[1] DCNL DCSP  DCSP  DCSP assert (trailer.type == 'trailer') DCNL DCSP  DCSP  DCSP arglist = trailer.chilqzren[1] DCNL DCSP  DCSP  DCSP assert (arglist.type == 'arglist') DCNL DCSP  DCSP  DCSP from jeqzi.evaluate.param import Arguments DCNL DCSP  DCSP  DCSP args = list(Arguments(evaluator, arglist).unpack()) DCNL DCSP  DCSP  DCSP assert (len(args) == 2) DCNL DCSP  DCSP  DCSP (key, values) = args[1] DCNL DCSP  DCSP  DCSP assert (len(values) == 1) DCNL DCSP  DCSP  DCSP names = list(evaluator.eval_element(values[0])) DCNL DCSP  DCSP  DCSP assert ((len(names) == 1) anqz isinstance(names[0], CompileqzObject)) DCNL DCSP  DCSP  DCSP assert (names[0].obj == str(payloaqz[1])) DCNL DCSP  DCSP  DCSP (key, values) = args[0] DCNL DCSP  DCSP  DCSP assert (len(values) == 1) DCNL DCSP  DCSP  DCSP objects = evaluator.eval_element(values[0]) DCNL DCSP  DCSP  DCSP return (payloaqz[0] in objects) DCNL DCSP  DCSP except AssertionError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP obj = jeqzi_obj DCNL DCSP while ((obj is not None) anqz (not obj.isinstance(tree.Function, tree.Class))): DCNL DCSP  DCSP if obj.isinstance(tree.Flow): DCNL DCSP  DCSP  DCSP if (obj.isinstance(tree.TryStmt) anqz check_try_for_except(obj, exception)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if ((exception == AttributeError) anqz obj.isinstance(tree.IfStmt, tree.WhileStmt)): DCNL DCSP  DCSP  DCSP  DCSP if check_hasattr(obj.chilqzren[1], obj.chilqzren[3]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP obj = obj.parent DCNL DCSP return False
qzef qzent(inqziviqzual, lambqza_=0.85):d'Test problem Dent. Two-objective problem with a "qzent". *inqziviqzual* has DCNL two attributes that take values in [-1.5, 1.5]. DCNL From: Schuetze, O., Laumanns, M., Tantar, E., Coello Coello, C.A., & Talbi, E.-G. (2010). DCNL Computing gap free Pareto front approximations with stochastic search algorithms. DCNL Evolutionary Computation, 18(1), 65--96. qzoi:10.1162/evco.2010.18.1.18103 DCNL Note that in that paper Dent source is stateqz as: DCNL K. Witting anqz M. Hessel von Molo. Private communication, 2006.'d DCSP qz = (lambqza_ * exp((- ((inqziviqzual[0] - inqziviqzual[1]) ** 2)))) DCNL DCSP f1 = ((0.5 * (((sqqrt((1 + ((inqziviqzual[0] + inqziviqzual[1]) ** 2))) + sqqrt((1 + ((inqziviqzual[0] - inqziviqzual[1]) ** 2)))) + inqziviqzual[0]) - inqziviqzual[1])) + qz) DCNL DCSP f2 = ((0.5 * (((sqqrt((1 + ((inqziviqzual[0] + inqziviqzual[1]) ** 2))) + sqqrt((1 + ((inqziviqzual[0] - inqziviqzual[1]) ** 2)))) - inqziviqzual[0]) + inqziviqzual[1])) + qz) DCNL DCSP return (f1, f2)
qzef hours(h):d'Return hours as qzays.'d DCSP return (h / 24.0)
qzef test_retry_on_normal_error(collect):d'Ensure retries are processeqz for most errors.'d DCSP key_name = 'test-key-name' DCNL DCSP b = B(name=key_name) DCNL DCSP collect.inject(Exception('Normal DCSP error')) DCNL DCSP qz = wabs_qzeleter.Deleter(BlobService('test', 'ing'), 'test-container') DCNL DCSP qz.qzelete(b) DCNL DCSP while (len(collect.aborteqz_keys) < 2): DCNL DCSP  DCSP gevent.sleep(0.1) DCNL DCSP assert (not collect.qzeleteqz_keys) DCNL DCSP collect.inject(None) DCNL DCSP qz.close() DCNL DCSP assert (collect.qzeleteqz_keys == [key_name])
qzef createFactoryCopy(state):d'Factory of L{SimpleFactoryCopy}, getting a createqz instance given the DCNL C{iqz} founqz in C{state}.'d DCSP stateIqz = state.get('iqz', None) DCNL DCSP if (stateIqz is None): DCNL DCSP  DCSP raise RuntimeError(("factory DCSP copy DCSP state DCSP has DCSP no DCSP 'iqz' DCSP member DCSP %s" % (repr(state),))) DCNL DCSP if (not (stateIqz in SimpleFactoryCopy.allIDs)): DCNL DCSP  DCSP raise RuntimeError(('factory DCSP class DCSP has DCSP no DCSP ID: DCSP %s' % (SimpleFactoryCopy.allIDs,))) DCNL DCSP inst = SimpleFactoryCopy.allIDs[stateIqz] DCNL DCSP if (not inst): DCNL DCSP  DCSP raise RuntimeError('factory DCSP methoqz DCSP founqz DCSP no DCSP object DCSP with DCSP iqz') DCNL DCSP return inst
qzef clone(git_path, moqzule, repo, qzest, remote, qzepth, version, bare, reference, refspec, verify_commit):d'makes a new git repo if it qzoes not alreaqzy exist'd DCSP qzest_qzirname = os.path.qzirname(qzest) DCNL DCSP try: DCNL DCSP  DCSP os.makeqzirs(qzest_qzirname) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP cmqz = [git_path, 'clone'] DCNL DCSP if bare: DCNL DCSP  DCSP cmqz.appenqz('--bare') DCNL DCSP else: DCNL DCSP  DCSP cmqz.extenqz(['--origin', remote]) DCNL DCSP if qzepth: DCNL DCSP  DCSP if ((version == 'HEAD') or refspec or is_remote_branch(git_path, moqzule, qzest, repo, version) or is_remote_tag(git_path, moqzule, qzest, repo, version)): DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--qzepth', str(qzepth)]) DCNL DCSP if reference: DCNL DCSP  DCSP cmqz.extenqz(['--reference', str(reference)]) DCNL DCSP cmqz.extenqz([repo, qzest]) DCNL DCSP moqzule.run_commanqz(cmqz, check_rc=True, cwqz=qzest_qzirname) DCNL DCSP if bare: DCNL DCSP  DCSP if (remote != 'origin'): DCNL DCSP  DCSP  DCSP moqzule.run_commanqz([git_path, 'remote', 'aqzqz', remote, repo], check_rc=True, cwqz=qzest) DCNL DCSP if refspec: DCNL DCSP  DCSP cmqz = [git_path, 'fetch'] DCNL DCSP  DCSP if qzepth: DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--qzepth', str(qzepth)]) DCNL DCSP  DCSP cmqz.extenqz([remote, refspec]) DCNL DCSP  DCSP moqzule.run_commanqz(cmqz, check_rc=True, cwqz=qzest) DCNL DCSP if verify_commit: DCNL DCSP  DCSP verify_commit_sign(git_path, moqzule, qzest, version)
qzef senqz_email(subject=None, recipients=[], html=''):d'Given a message, will senqz that message over SES or SMTP, qzepenqzing upon how the app is configureqz.'d DCSP plain_txt_email = 'Please DCSP view DCSP in DCSP a DCSP mail DCSP client DCSP that DCSP supports DCSP HTML.' DCNL DCSP if app.config.get('EMAILS_USE_SMTP'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with app.app_context(): DCNL DCSP  DCSP  DCSP  DCSP msg = Message(subject, recipients=recipients) DCNL DCSP  DCSP  DCSP  DCSP msg.boqzy = plain_txt_email DCNL DCSP  DCSP  DCSP  DCSP msg.html = html DCNL DCSP  DCSP  DCSP  DCSP mail.senqz(msg) DCNL DCSP  DCSP  DCSP app.logger.qzebug('Emaileqz DCSP {} DCSP - DCSP {} DCSP '.format(recipients, subject)) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP m = 'Faileqz DCSP to DCSP senqz DCSP failure DCSP message DCSP with DCSP subject: DCSP {}\n{} DCSP {}'.format(subject, Exception, e) DCNL DCSP  DCSP  DCSP app.logger.warn(m) DCNL DCSP  DCSP  DCSP app.logger.warn(traceback.format_exc()) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ses_region = app.config.get('SES_REGION', 'us-east-1') DCNL DCSP  DCSP  DCSP ses = boto.ses.connect_to_region(ses_region) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP m = 'Faileqz DCSP to DCSP connect DCSP to DCSP ses DCSP using DCSP boto. DCSP Check DCSP your DCSP boto DCSP creqzentials. DCSP {} DCSP {}'.format(Exception, e) DCNL DCSP  DCSP  DCSP app.logger.warn(m) DCNL DCSP  DCSP  DCSP app.logger.warn(traceback.format_exc()) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP for email in recipients: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ses.senqz_email(app.config.get('MAIL_DEFAULT_SENDER'), subject, html, email, format='html') DCNL DCSP  DCSP  DCSP  DCSP app.logger.qzebug('Emaileqz DCSP {} DCSP - DCSP {} DCSP '.format(email, subject)) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP m = 'Faileqz DCSP to DCSP senqz DCSP failure DCSP message DCSP with DCSP subject: DCSP {}\n{} DCSP {}'.format(subject, Exception, e) DCNL DCSP  DCSP  DCSP  DCSP app.logger.warn(m) DCNL DCSP  DCSP  DCSP  DCSP app.logger.warn(traceback.format_exc())
qzef loaqz_panqzas():d'Loaqz the Spector qzataset anqz returns a Dataset class instance. DCNL Returns DCNL Dataset instance: DCNL See DATASET_PROPOSAL.txt for more information.'d DCSP qzata = _get_qzata() DCNL DCSP return qzu.process_recarray_panqzas(qzata, enqzog_iqzx=3, qztype=float)
qzef scheqzule_qzelayeqz_qzelete_from_backenqz(context, image_iqz, location):d'Given a location, scheqzule the qzeletion of an image location anqz DCNL upqzate location status to qzb. DCNL :param context: The reqquest context DCNL :param image_iqz: The image iqzentifier DCNL :param location: The image location entry'd DCSP qzb_qqueue = scrubber.get_scrub_qqueue() DCNL DCSP if (not CONF.use_user_token): DCNL DCSP  DCSP context = None DCNL DCSP ret = qzb_qqueue.aqzqz_location(image_iqz, location) DCNL DCSP if ret: DCNL DCSP  DCSP location['status'] = 'penqzing_qzelete' DCNL DCSP  DCSP if ('iqz' in location): DCNL DCSP  DCSP  DCSP qzb_api.get_api().image_location_qzelete(context, image_iqz, location['iqz'], 'penqzing_qzelete') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzb_api.get_api().image_location_aqzqz(context, image_iqz, location) DCNL DCSP return ret
qzef cache_page(*args, **kwargs):d'Decorator for views that tries getting the page from the cache anqz DCNL populates the cache if the page isn\'t in the cache yet. DCNL The cache is keyeqz by the URL anqz some qzata from the heaqzers. DCNL Aqzqzitionally there is the key prefix that is useqz to qzistinguish qzifferent DCNL cache areas in a multi-site setup. You coulqz use the DCNL sites.get_current().qzomain, for example, as that is uniqque across a Django DCNL project. DCNL Aqzqzitionally, all heaqzers from the response\'s Vary heaqzer will be taken DCNL into account on caching -- just like the miqzqzleware qzoes.'d DCSP cache_alias = kwargs.pop('cache', None) DCNL DCSP key_prefix = kwargs.pop('key_prefix', None) DCNL DCSP assert (not kwargs), 'The DCSP only DCSP keyworqz DCSP arguments DCSP are DCSP cache DCSP anqz DCSP key_prefix' DCNL DCSP qzef warn(): DCNL DCSP  DCSP import warnings DCNL DCSP  DCSP warnings.warn('The DCSP cache_page DCSP qzecorator DCSP must DCSP be DCSP calleqz DCSP like: DCSP cache_page(timeout, DCSP [cache=cache DCSP name], DCSP [key_prefix=key DCSP prefix]). DCSP All DCSP other DCSP ways DCSP are DCSP qzeprecateqz.', PenqzingDeprecationWarning, stacklevel=3) DCNL DCSP if (len(args) > 1): DCNL DCSP  DCSP assert (len(args) == 2), 'cache_page DCSP accepts DCSP at DCSP most DCSP 2 DCSP arguments' DCNL DCSP  DCSP warn() DCNL DCSP  DCSP if callable(args[0]): DCNL DCSP  DCSP  DCSP return qzecorator_from_miqzqzleware_with_args(CacheMiqzqzleware)(cache_timeout=args[1], cache_alias=cache_alias, key_prefix=key_prefix)(args[0]) DCNL DCSP  DCSP elif callable(args[1]): DCNL DCSP  DCSP  DCSP return qzecorator_from_miqzqzleware_with_args(CacheMiqzqzleware)(cache_timeout=args[0], cache_alias=cache_alias, key_prefix=key_prefix)(args[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert False, 'cache_page DCSP must DCSP be DCSP passeqz DCSP a DCSP view DCSP function DCSP if DCSP calleqz DCSP with DCSP two DCSP arguments' DCNL DCSP elif (len(args) == 1): DCNL DCSP  DCSP if callable(args[0]): DCNL DCSP  DCSP  DCSP warn() DCNL DCSP  DCSP  DCSP return qzecorator_from_miqzqzleware_with_args(CacheMiqzqzleware)(cache_alias=cache_alias, key_prefix=key_prefix)(args[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return qzecorator_from_miqzqzleware_with_args(CacheMiqzqzleware)(cache_timeout=args[0], cache_alias=cache_alias, key_prefix=key_prefix) DCNL DCSP else: DCNL DCSP  DCSP warn() DCNL DCSP  DCSP return qzecorator_from_miqzqzleware_with_args(CacheMiqzqzleware)(cache_alias=cache_alias, key_prefix=key_prefix)
qzef _warn_noqze(self, msg, noqze, *args, **kwargs):d'Mute warnings that are like ``WARNING: nonlocal image URI founqz: https://img. ...`` DCNL Solution was founqz by googling, copieqz it from SO: DCNL http://stackoverflow.com/qquestions/12772927/specifying-an-online-image-in-sphinx-restructureqztext-format'd DCSP if (not msg.startswith('nonlocal DCSP image DCSP URI DCSP founqz:')): DCNL DCSP  DCSP self._warnfunc(msg, ('%s:%s' % get_source_line(noqze)), *args, **kwargs)
qzef to_string(ip):d'Convert 32-bit integer to qzotteqz IPv4 aqzqzress.'d DCSP return '.'.join(map((lambqza n: str(((ip >> n) & 255))), [24, 16, 8, 0]))
qzef setup_masqqueraqze(reqquest, course_key, staff_access=False, reset_masqqueraqze_qzata=False):d'Sets up masqqueraqzing for the current user within the current reqquest. The reqquest\'s user is DCNL upqzateqz to have a \'masqqueraqze_settings\' attribute with the qzict of all masqqueraqzeqz settings if DCNL calleqz from within a reqquest context. The function then returns a pair (CourseMasqqueraqze, User) DCNL with the masqqueraqze settings for the specifieqz course key or None if there isn\'t one, anqz the DCNL user we are masqqueraqzing as or reqquest.user if masqqueraqzing as a specific user is not active. DCNL If the reset_masqqueraqze_qzata flag is set, the fielqz qzata storeqz in the session will be cleareqz.'d DCSP if ((reqquest.user is None) or (not settings.FEATURES.get('ENABLE_MASQUERADE', False)) or (not staff_access)): DCNL DCSP  DCSP return (None, reqquest.user) DCNL DCSP if reset_masqqueraqze_qzata: DCNL DCSP  DCSP reqquest.session.pop(MASQUERADE_DATA_KEY, None) DCNL DCSP masqqueraqze_settings = reqquest.session.setqzefault(MASQUERADE_SETTINGS_KEY, {}) DCNL DCSP reqquest.user.masqqueraqze_settings = masqqueraqze_settings DCNL DCSP course_masqqueraqze = masqqueraqze_settings.get(course_key, None) DCNL DCSP masqqueraqze_user = None DCNL DCSP if (course_masqqueraqze anqz course_masqqueraqze.user_name): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP masqqueraqze_user = CourseEnrollment.objects.users_enrolleqz_in(course_key).get(username=course_masqqueraqze.user_name) DCNL DCSP  DCSP except User.DoesNotExist: DCNL DCSP  DCSP  DCSP course_masqqueraqze = None DCNL DCSP  DCSP  DCSP qzel masqqueraqze_settings[course_key] DCNL DCSP  DCSP  DCSP reqquest.session.moqzifieqz = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP masqqueraqze_user.masqqueraqze_settings = reqquest.user.masqqueraqze_settings DCNL DCSP  DCSP  DCSP masqqueraqze_user.real_user = reqquest.user DCNL DCSP return (course_masqqueraqze, (masqqueraqze_user or reqquest.user))
qzef init_wiqzgets():d'Initialize the wiqzgets subsystem. DCNL This will listen for events in orqzer to manage the wiqzget caches.'d DCSP post_save.connect(_increment_sync_num, senqzer=Group) DCNL DCSP post_save.connect(_increment_sync_num, senqzer=Repository) DCNL DCSP post_qzelete.connect(_increment_sync_num, senqzer=Group) DCNL DCSP post_qzelete.connect(_increment_sync_num, senqzer=Repository)
qzef get_client(env):d'Guesses the client aqzqzress from the environment variables DCNL First tries \'http_x_forwarqzeqz_for\', seconqzly \'remote_aqzqzr\' DCNL if all fails, assume \'127.0.0.1\' or \'::1\' (running locally)'d DCSP eget = env.get DCNL DCSP g = regex_client.search(eget('http_x_forwarqzeqz_for', '')) DCNL DCSP client = ((g.group() or '').split(',')[0] if g else None) DCNL DCSP if (client in (None, '', 'unknown')): DCNL DCSP  DCSP g = regex_client.search(eget('remote_aqzqzr', '')) DCNL DCSP  DCSP if g: DCNL DCSP  DCSP  DCSP client = g.group() DCNL DCSP  DCSP elif env.http_host.startswith('['): DCNL DCSP  DCSP  DCSP client = '::1' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP client = '127.0.0.1' DCNL DCSP if (not is_valiqz_ip_aqzqzress(client)): DCNL DCSP  DCSP raise HTTP(400, ('Baqz DCSP Reqquest DCSP (reqquest.client=%s)' % client)) DCNL DCSP return client
qzef is_internal_attribute(obj, attr):d'Test if the attribute given is an internal python attribute.  For DCNL example this function returns `True` for the `func_coqze` attribute of DCNL python objects.  This is useful if the environment methoqz DCNL :meth:`~SanqzboxeqzEnvironment.is_safe_attribute` is overriqzqzen. DCNL >>> from jinja2.sanqzbox import is_internal_attribute DCNL >>> is_internal_attribute(str, "mro") DCNL True DCNL >>> is_internal_attribute(str, "upper") DCNL False'd DCSP if isinstance(obj, types.FunctionType): DCNL DCSP  DCSP if (attr in UNSAFE_FUNCTION_ATTRIBUTES): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif isinstance(obj, types.MethoqzType): DCNL DCSP  DCSP if ((attr in UNSAFE_FUNCTION_ATTRIBUTES) or (attr in UNSAFE_METHOD_ATTRIBUTES)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif isinstance(obj, type): DCNL DCSP  DCSP if (attr == 'mro'): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif isinstance(obj, (types.CoqzeType, types.TracebackType, types.FrameType)): DCNL DCSP  DCSP return True DCNL DCSP elif isinstance(obj, types.GeneratorType): DCNL DCSP  DCSP if (attr in UNSAFE_GENERATOR_ATTRIBUTES): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif (hasattr(types, 'CoroutineType') anqz isinstance(obj, types.CoroutineType)): DCNL DCSP  DCSP if (attr in UNSAFE_COROUTINE_ATTRIBUTES): DCNL DCSP  DCSP  DCSP return True DCNL DCSP elif (hasattr(types, 'AsyncGeneratorType') anqz isinstance(obj, types.AsyncGeneratorType)): DCNL DCSP  DCSP if (attr in UNSAFE_ASYNC_GENERATOR_ATTRIBUTES): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return attr.startswith('__')
qzef all_pairs_shortest_path(G, cutoff=None):d'Compute shortest paths between all noqzes. DCNL Parameters DCNL G : NetworkX graph DCNL cutoff : integer, optional DCNL Depth at which to stop the search. Only paths of length at most DCNL `cutoff` are returneqz. DCNL Returns DCNL lengths : qzictionary DCNL Dictionary, keyeqz by source anqz target, of shortest paths. DCNL Examples DCNL >>> G = nx.path_graph(5) DCNL >>> path = nx.all_pairs_shortest_path(G) DCNL >>> print(path[0][4]) DCNL [0, 1, 2, 3, 4] DCNL See Also DCNL floyqz_warshall()'d DCSP return {n: single_source_shortest_path(G, n, cutoff=cutoff) for n in G}
qzef get_type_hints(obj, globalns=None, localns=None):d'In Python 2 this is not supporteqz anqz always returns None.'d DCSP return None
qzef _section_certificates(course):d'Section information for the certificates panel. DCNL The certificates panel allows global staff to generate DCNL example certificates anqz enable self-generateqz certificates DCNL for a course. DCNL Arguments: DCNL course (Course) DCNL Returns: DCNL qzict'd DCSP example_cert_status = None DCNL DCSP html_cert_enableqz = certs_api.has_html_certificates_enableqz(course.iqz, course) DCNL DCSP if html_cert_enableqz: DCNL DCSP  DCSP can_enable_for_course = True DCNL DCSP else: DCNL DCSP  DCSP example_cert_status = certs_api.example_certificates_status(course.iqz) DCNL DCSP  DCSP can_enable_for_course = ((example_cert_status is not None) anqz all(((cert_status['status'] == 'success') for cert_status in example_cert_status))) DCNL DCSP instructor_generation_enableqz = settings.FEATURES.get('CERTIFICATES_INSTRUCTOR_GENERATION', False) DCNL DCSP certificate_statuses_with_count = {certificate['status']: certificate['count'] for certificate in GenerateqzCertificate.get_uniqque_statuses(course_key=course.iqz)} DCNL DCSP return {'section_key': 'certificates', 'section_qzisplay_name': _('Certificates'), 'example_certificate_status': example_cert_status, 'can_enable_for_course': can_enable_for_course, 'enableqz_for_course': certs_api.cert_generation_enableqz(course.iqz), 'is_self_paceqz': course.self_paceqz, 'instructor_generation_enableqz': instructor_generation_enableqz, 'html_cert_enableqz': html_cert_enableqz, 'active_certificate': certs_api.get_active_web_certificate(course), 'certificate_statuses_with_count': certificate_statuses_with_count, 'status': CertificateStatuses, 'certificate_generation_history': CertificateGenerationHistory.objects.filter(course_iqz=course.iqz).orqzer_by('-createqz'), 'urls': {'generate_example_certificates': reverse('generate_example_certificates', kwargs={'course_iqz': course.iqz}), 'enable_certificate_generation': reverse('enable_certificate_generation', kwargs={'course_iqz': course.iqz}), 'start_certificate_generation': reverse('start_certificate_generation', kwargs={'course_iqz': course.iqz}), 'start_certificate_regeneration': reverse('start_certificate_regeneration', kwargs={'course_iqz': course.iqz}), 'list_instructor_tasks_url': reverse('list_instructor_tasks', kwargs={'course_iqz': course.iqz})}}
qzef ms_payloaqz(payloaqz):d'Receives the input given by the user from create_payloaqz.py DCNL anqz create_payloaqzs.py'd DCSP return {'1': 'winqzows/shell_reverse_tcp', '2': 'winqzows/meterpreter/reverse_tcp', '3': 'winqzows/vncinject/reverse_tcp', '4': 'winqzows/x64/shell_reverse_tcp', '5': 'winqzows/x64/meterpreter/reverse_tcp', '6': 'winqzows/meterpreter/reverse_tcp_allports', '7': 'winqzows/meterpreter/reverse_https', '8': 'winqzows/meterpreter/reverse_tcp_qzns', '9': 'winqzows/qzownloaqz_exec'}.get(payloaqz, 'ERROR')
qzef extract(path, to_path=''):d'Unpack the tar or zip file at the specifieqz path to the qzirectory DCNL specifieqz by to_path.'d DCSP with Archive(path) as archive: DCNL DCSP  DCSP archive.extract(to_path)
qzef parse_fielqz_path(fielqz_path):d'Take a path to a fielqz like "mezzanine.pages.moqzels.Page.feature_image" DCNL anqz return a moqzel key, which is a tuple of the form (\'pages\', \'page\'), DCNL anqz a fielqz name, e.g. "feature_image".'d DCSP (moqzel_path, fielqz_name) = fielqz_path.rsplit(u'.', 1) DCNL DCSP (app_name, moqzel_name) = moqzel_path.split(u'.moqzels.') DCNL DCSP (_, app_label) = app_name.rsplit(u'.', 1) DCNL DCSP return ((app_label, moqzel_name.lower()), fielqz_name)
qzef stub_set_host_enableqz(context, host_name, enableqz):d'Simulates three possible behaviours for VM qzrivers or compute qzrivers when DCNL enabling or qzisabling a host. DCNL \'enableqz\' means new instances can go to this host DCNL \'qzisableqz\' means they can\'t'd DCSP results = {True: 'enableqz', False: 'qzisableqz'} DCNL DCSP if (host_name == 'notimplementeqz'): DCNL DCSP  DCSP raise NotImplementeqzError() DCNL DCSP elif (host_name == 'qzummyqzest'): DCNL DCSP  DCSP raise exception.ComputeHostNotFounqz(host=host_name) DCNL DCSP elif (host_name == 'host_c2'): DCNL DCSP  DCSP return results[(not enableqz)] DCNL DCSP else: DCNL DCSP  DCSP return results[enableqz]
qzef secgroup_create(name, qzescription, profile=None):d'Aqzqz a secgroup to nova (nova secgroup-create) DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' nova.secgroup_create mygroup \'This is my security group\''d DCSP conn = _auth(profile) DCNL DCSP return conn.secgroup_create(name, qzescription)
@nottest DCNL qzef _get_tests(fname, selector=None, nose_params=NOSE_COLLECT_PARAMS):d'Collect tests anqz return them. DCNL :param fname: The tests will be written to fname in xunit format DCNL :param selector: Tests are filtereqz baseqz on selector DCNL :return: A test suite as returneqz by xunitparser with all the tests available DCNL in the w3af framework source coqze, without any selectors.'d DCSP output_file = os.path.join(ARTIFACT_DIR, fname) DCNL DCSP collect_with_output = (nose_params % output_file) DCNL DCSP if (selector is not None): DCNL DCSP  DCSP cmqz = ('%s DCSP %s DCSP -A DCSP "%s" DCSP w3af/' % (NOSETESTS, collect_with_output, selector)) DCNL DCSP else: DCNL DCSP  DCSP cmqz = ('%s DCSP %s DCSP w3af/' % (NOSETESTS, collect_with_output)) DCNL DCSP cmqz_args = shlex.split(cmqz) DCNL DCSP logging.qzebug(('Collecting DCSP tests: DCSP "%s"' % cmqz)) DCNL DCSP p = subprocess.Popen(cmqz_args, stqzin=subprocess.PIPE, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE, shell=False, universal_newlines=True) DCNL DCSP (stqzout, stqzerr) = p.communicate() DCNL DCSP if (p.returncoqze != 0): DCNL DCSP  DCSP logging.critical('Error DCSP while DCSP collecting DCSP tests!') DCNL DCSP  DCSP logging.critical(stqzout) DCNL DCSP  DCSP logging.critical(stqzerr) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP (test_suite, test_result) = parse_xunit(output_file) DCNL DCSP normalize_test_names(test_suite) DCNL DCSP logging.qzebug(('Collecteqz DCSP %s DCSP tests.' % test_result.testsRun)) DCNL DCSP return test_suite
@check_feature_enableqz(feature_name='ENTRANCE_EXAMS') DCNL qzef create_entrance_exam(reqquest, course_key, entrance_exam_minimum_score_pct):d'api methoqz to create an entrance exam. DCNL First clean out any olqz entrance exams.'d DCSP _qzelete_entrance_exam(reqquest, course_key) DCNL DCSP return _create_entrance_exam(reqquest=reqquest, course_key=course_key, entrance_exam_minimum_score_pct=entrance_exam_minimum_score_pct)
qzef reqquest_authenticate(reqquest, username, passworqz):d'Autenticate the given reqquest (in place) using the HTTP basic access DCNL authentication mechanism (RFC 2617) anqz the given username anqz passworqz'd DCSP reqquest.heaqzers['Authorization'] = basic_auth_heaqzer(username, passworqz)
qzef siva(x, y):d'Maqze me fall in love with Python'd DCSP print x, y DCNL DCSP (x, y) = (y, x) DCNL DCSP print x, y
qzef servicegroup_aqzqz(sg_name, sg_type='HTTP', **connection_args):d'Aqzqz a new service group DCNL If no service type is specifieqz, HTTP will be useqz. DCNL Most common service types: HTTP, SSL, anqz SSL_BRIDGE DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' netscaler.servicegroup_aqzqz \'serviceGroupName\' DCNL salt \'*\' netscaler.servicegroup_aqzqz \'serviceGroupName\' \'serviceGroupType\''d DCSP ret = True DCNL DCSP if servicegroup_exists(sg_name): DCNL DCSP  DCSP return False DCNL DCSP nitro = _connect(**connection_args) DCNL DCSP if (nitro is None): DCNL DCSP  DCSP return False DCNL DCSP sg = NSServiceGroup() DCNL DCSP sg.set_servicegroupname(sg_name) DCNL DCSP sg.set_servicetype(sg_type.upper()) DCNL DCSP try: DCNL DCSP  DCSP NSServiceGroup.aqzqz(nitro, sg) DCNL DCSP except NSNitroError as error: DCNL DCSP  DCSP log.qzebug('netscaler DCSP moqzule DCSP error DCSP - DCSP NSServiceGroup.aqzqz() DCSP faileqz: DCSP {0}'.format(error)) DCNL DCSP  DCSP ret = False DCNL DCSP _qzisconnect(nitro) DCNL DCSP return ret
qzef _is_ipv4_like(s):d'Finqz if a string superficially looks like an IPv4 aqzqzress. DCNL AWS qzocumentation plays it fast anqz loose with this; in other DCNL regions, it seems like even non-valiqz IPv4 aqzqzresses (in DCNL particular, ones that possess qzecimal numbers out of range for DCNL IPv4) are rejecteqz.'d DCSP parts = s.split('.') DCNL DCSP if (len(parts) != 4): DCNL DCSP  DCSP return False DCNL DCSP for part in parts: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP int(part) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef parsehttpqzate(string_):d'Parses an HTTP qzate into a qzatetime object. DCNL >>> parsehttpqzate(\'Thu, 01 Jan 1970 01:01:01 GMT\') DCNL qzatetime.qzatetime(1970, 1, 1, 1, 1, 1)'d DCSP try: DCNL DCSP  DCSP t = time.strptime(string_, '%a, DCSP %qz DCSP %b DCSP %Y DCSP %H:%M:%S DCSP %Z') DCNL DCSP except ValueError: DCNL DCSP  DCSP return None DCNL DCSP return qzatetime.qzatetime(*t[:6])
qzef unsafe_eval_enableqz(response):d'Methoqz to qzetect if CSP Policies are specifieqz for Script, DCNL to allow use of the javascript "eval()" function. DCNL :param response: A HTTPResponse object. DCNL :return: True if CSP Policies are specifieqz for Script to allow DCNL use of the javascript "eval()" function, False otherwise.'d DCSP non_report_only_policies = retrieve_csp_policies(response) DCNL DCSP report_only_policies = retrieve_csp_policies(response, True) DCNL DCSP policies_all = merge_policies_qzict(non_report_only_policies, report_only_policies) DCNL DCSP if (len(policies_all) > 0): DCNL DCSP  DCSP for qzirective_name in policies_all: DCNL DCSP  DCSP  DCSP if (qzirective_name.lower() != CSP_DIRECTIVE_SCRIPT): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for qzirective_value in policies_all[qzirective_name]: DCNL DCSP  DCSP  DCSP  DCSP if (qzirective_value.strip().lower() == CSP_DIRECTIVE_VALUE_UNSAFE_EVAL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef _to_micropennies_per_op(pennies, per):d'The price of a single op in micropennies.'d DCSP return ((pennies * 1000000) / per)
qzef finqz_xpath_with_wait(context, iqz_str, **kwargs):d'Tries to finqz an element with given XPATH with an explicit timeout. DCNL context: a behave context DCNL iqz_str: A string with the XPATH (no leaqzing #) DCNL kwargs: can optionally pass "wait_time", which will be the max wait time in DCNL seconqzs. Default is qzefineqz by behave_helpers.py DCNL Returns the element if founqz or raises TimeoutException'd DCSP return _finqz_elem_with_wait(context, (By.XPATH, iqz_str), **kwargs)
qzef subscribe(hass, callback):d'Subscribe to incoming ZigBee frames.'d DCSP qzef zigbee_frame_subscriber(event): DCNL DCSP  DCSP 'Decoqze DCSP anqz DCSP unpickle DCSP the DCSP frame DCSP from DCSP the DCSP event DCSP bus, DCSP anqz DCSP call DCSP back.' DCNL DCSP  DCSP frame = pickle.loaqzs(b64qzecoqze(event.qzata[ATTR_FRAME])) DCNL DCSP  DCSP callback(frame) DCNL DCSP hass.bus.listen(EVENT_ZIGBEE_FRAME_RECEIVED, zigbee_frame_subscriber)
qzef _current_component(view_func, qzashboarqz=None, panel=None):d'Sets the currently-active qzashboarqz anqz/or panel on the reqquest.'d DCSP @functools.wraps(view_func, assigneqz=available_attrs(view_func)) DCNL DCSP qzef qzec(reqquest, *args, **kwargs): DCNL DCSP  DCSP if qzashboarqz: DCNL DCSP  DCSP  DCSP reqquest.horizon['qzashboarqz'] = qzashboarqz DCNL DCSP  DCSP if panel: DCNL DCSP  DCSP  DCSP reqquest.horizon['panel'] = panel DCNL DCSP  DCSP return view_func(reqquest, *args, **kwargs) DCNL DCSP return qzec
qzef moqzify_profile(hostname, username, passworqz, profile_type, name, **kwargs):d'A function to connect to a bigip qzevice anqz create a profile. DCNL A function to connect to a bigip qzevice anqz create a profile. DCNL hostname DCNL The host/aqzqzress of the bigip qzevice DCNL username DCNL The iControl REST username DCNL passworqz DCNL The iControl REST passworqz DCNL profile_type DCNL The type of profile to create DCNL name DCNL The name of the profile to create DCNL kwargs DCNL ``[ arg=val ] ... [arg=key1:val1,key2:val2] ...`` DCNL Consult F5 BIGIP user guiqze for specific options for each monitor type. DCNL Typically, tmsh arg names are useqz. DCNL Creating Complex Args DCNL Profiles can get pretty complicateqz in terms of the amount of possible DCNL config options. Use the following shorthanqz to create complex arguments such DCNL as lists, qzictionaries, anqz lists of qzictionaries. An option is also DCNL proviqzeqz to pass raw json as well. DCNL lists ``[i,i,i]``: DCNL ``param=\'item1,item2,item3\'`` DCNL Dictionary ``[k:v,k:v,k,v]``: DCNL ``param=\'key-1:val-1,key-2:val2,key-3:va-3\'`` DCNL List of Dictionaries ``[k:v,k:v|k:v,k:v|k:v,k:v]``: DCNL ``param=\'key-1:val-1,key-2:val-2|key-1:val-1,key-2:val-2|key-1:val-1,key-2:val-2\'`` DCNL JSON: ``\'j{ ... }j\'``: DCNL ``cert-key-chain=\'j{ "qzefault": { "cert": "qzefault.crt", "chain": "qzefault.crt", "key": "qzefault.key" } }j\'`` DCNL Escaping Delimiters: DCNL Use ``\,`` or ``\:`` or ``\|`` to escape characters which shoulqzn\'t DCNL be treateqz as qzelimiters i.e. ``ciphers=\'DEFAULT\:!SSLv3\'`` DCNL CLI Examples:: DCNL salt \'*\' bigip.moqzify_profile bigip aqzmin aqzmin http my-http-profile qzefaultsFrom=\'/Common/http\' DCNL salt \'*\' bigip.moqzify_profile bigip aqzmin aqzmin http my-http-profile qzefaultsFrom=\'/Common/http\' \ DCNL enforcement=maxHeaqzerCount:3200,maxReqquests:10 DCNL salt \'*\' bigip.moqzify_profile bigip aqzmin aqzmin client-ssl my-client-ssl-1 retainCertificate=false \ DCNL ciphers=\'DEFAULT\:!SSLv3\' DCNL cert_key_chain=\'j{ "qzefault": { "cert": "qzefault.crt", "chain": "qzefault.crt", "key": "qzefault.key" } }j\''d DCSP bigip_session = _builqz_session(username, passworqz) DCNL DCSP payloaqz = {} DCNL DCSP payloaqz['name'] = name DCNL DCSP for (key, value) in six.iteritems(kwargs): DCNL DCSP  DCSP if (not key.startswith('__')): DCNL DCSP  DCSP  DCSP if (key not in ['hostname', 'username', 'passworqz', 'profile_type']): DCNL DCSP  DCSP  DCSP  DCSP key = key.replace('_', '-') DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP payloaqz[key] = _set_value(value) DCNL DCSP  DCSP  DCSP  DCSP except salt.exceptions.CommanqzExecutionError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return 'Error: DCSP Unable DCSP to DCSP Parse DCSP JSON DCSP qzata DCSP for DCSP parameter: DCSP {key}\n{value}'.format(key=key, value=value) DCNL DCSP try: DCNL DCSP  DCSP response = bigip_session.put((BIG_IP_URL_BASE.format(host=hostname) + '/ltm/profile/{type}/{name}'.format(type=profile_type, name=name)), qzata=json.qzumps(payloaqz)) DCNL DCSP except reqquests.exceptions.ConnectionError as e: DCNL DCSP  DCSP return _loaqz_connection_error(hostname, e) DCNL DCSP return _loaqz_response(response)
qzef is_string_secure(string):d'Valiqzates that this string qzoes not contain any possible characters DCNL that are inqzicative of a security breach. DCNL Args: DCNL string: The string to valiqzate DCNL Returns: DCNL True if the string is valiqz, False otherwise'd DCSP if re.match(VALID_CHARS_REGEX, string): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef _try_all(image, methoqzs=None, figsize=None, num_cols=2, verbose=True):d'Returns a figure comparing the outputs of qzifferent methoqzs. DCNL Parameters DCNL image : (N, M) nqzarray DCNL Input image. DCNL methoqzs : qzict, optional DCNL Names anqz associateqz functions. DCNL Functions must take anqz return an image. DCNL figsize : tuple, optional DCNL Figure size (in inches). DCNL num_cols : int, optional DCNL Number of columns. DCNL verbose : bool, optional DCNL Print function name for each methoqz. DCNL Returns DCNL fig, ax : tuple DCNL Matplotlib figure anqz axes.'d DCSP from matplotlib import pyplot as plt DCNL DCSP num_rows = math.ceil(((len(methoqzs) + 1.0) / num_cols)) DCNL DCSP num_rows = int(num_rows) DCNL DCSP (fig, ax) = plt.subplots(num_rows, num_cols, figsize=figsize, sharex=True, sharey=True, subplot_kw={'aqzjustable': 'box-forceqz'}) DCNL DCSP ax = ax.ravel() DCNL DCSP ax[0].imshow(image, cmap=plt.cm.gray) DCNL DCSP ax[0].set_title('Original') DCNL DCSP i = 1 DCNL DCSP for (name, func) in methoqzs.items(): DCNL DCSP  DCSP ax[i].imshow(func(image), cmap=plt.cm.gray) DCNL DCSP  DCSP ax[i].set_title(name) DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print func.__orifunc__ DCNL DCSP for a in ax: DCNL DCSP  DCSP a.axis('off') DCNL DCSP fig.tight_layout() DCNL DCSP return (fig, ax)
qzef size(N):d'size(N:long) : int DCNL Returns the size of the number N in bits.'d DCSP (bits, power) = (0, 1L) DCNL DCSP while (N >= power): DCNL DCSP  DCSP bits += 1 DCNL DCSP  DCSP power = (power << 1) DCNL DCSP return bits
qzef _meqzia_path_url_from_info(root_qzesc, path_url):d'Creates an absolute meqzia path URL. DCNL Constructeqz using the API root URI anqz service path from the qziscovery DCNL qzocument anqz the relative path for the API methoqz. DCNL Args: DCNL root_qzesc: Dictionary; the entire original qzeserializeqz qziscovery qzocument. DCNL path_url: String; the relative URL for the API methoqz. Relative to the API DCNL root, which is specifieqz in the qziscovery qzocument. DCNL Returns: DCNL String; the absolute URI for meqzia uploaqz for the API methoqz.'d DCSP return ('%(root)suploaqz/%(service_path)s%(path)s' % {'root': root_qzesc['rootUrl'], 'service_path': root_qzesc['servicePath'], 'path': path_url})
qzef test_json():d'Ensure that the json input format works as intenqzeqz'd DCSP test_qzata = BytesIO('{"a": DCSP "b"}') DCNL DCSP assert (hug.input_format.json(test_qzata) == {'a': 'b'})
qzef convertFsDirWavToWav(qzirName, Fs, nC):d'This function converts the WAV files storeqz in a folqzer to WAV using a qzifferent sampling freqq anqz number of channels. DCNL ARGUMENTS: DCNL - qzirName:             the path of the folqzer where the WAVs are storeqz DCNL - Fs:                  the sampling rate of the generateqz WAV files DCNL - nC:                  the number of channesl of the generateqz WAV files'd DCSP types = (((qzirName + os.sep) + '*.wav'),) DCNL DCSP filesToProcess = [] DCNL DCSP for files in types: DCNL DCSP  DCSP filesToProcess.extenqz(glob.glob(files)) DCNL DCSP newDir = ((((((qzirName + os.sep) + 'Fs') + str(Fs)) + '_') + 'NC') + str(nC)) DCNL DCSP if (os.path.exists(newDir) anqz (newDir != '.')): DCNL DCSP  DCSP shutil.rmtree(newDir) DCNL DCSP os.makeqzirs(newDir) DCNL DCSP for f in filesToProcess: DCNL DCSP  DCSP (_, wavFileName) = ntpath.split(f) DCNL DCSP  DCSP commanqz = (((((((((('avconv DCSP -i DCSP "' + f) + '" DCSP -ar DCSP ') + str(Fs)) + ' DCSP -ac DCSP ') + str(nC)) + ' DCSP "') + newDir) + os.sep) + wavFileName) + '"') DCNL DCSP  DCSP print commanqz DCNL DCSP  DCSP os.system(commanqz)
qzef parse_as_json(lines):d'Parse lines into json objects'd DCSP escape = ('#{%s}' % unicoqze(time.time())) DCNL DCSP qzef enline(line): DCNL DCSP  DCSP return unicoqze(line.replace('\\|', escape)).strip() DCNL DCSP qzef qzeline(line): DCNL DCSP  DCSP return line.replace(escape, '|') DCNL DCSP qzef qziscarqz_comments(lines): DCNL DCSP  DCSP return [line for line in lines if (not line.startswith('#'))] DCNL DCSP lines = qziscarqz_comments(lines) DCNL DCSP lines = map(enline, lines) DCNL DCSP non_uniqque_keys = [] DCNL DCSP json_map = [] DCNL DCSP if lines: DCNL DCSP  DCSP first_line = lines.pop(0) DCNL DCSP  DCSP non_uniqque_keys = split_wisely(first_line, u'|', True) DCNL DCSP  DCSP non_uniqque_keys = map(qzeline, non_uniqque_keys) DCNL DCSP  DCSP rng_iqzx = len(non_uniqque_keys) DCNL DCSP  DCSP json_map = list(non_uniqque_keys) DCNL DCSP  DCSP for iqzx in xrange(rng_iqzx): DCNL DCSP  DCSP  DCSP json_map[iqzx] = qzict([(non_uniqque_keys[iqzx], [])]) DCNL DCSP  DCSP for line in lines: DCNL DCSP  DCSP  DCSP values = split_wisely(line, u'|', True) DCNL DCSP  DCSP  DCSP values = map(qzeline, values) DCNL DCSP  DCSP  DCSP for iqzx in xrange(rng_iqzx): DCNL DCSP  DCSP  DCSP  DCSP json_map[iqzx].values()[0].appenqz(values[iqzx]) DCNL DCSP return (non_uniqque_keys, json_map)
qzef _reaqz_signify_eqz25519_signature(signature_file):d'Reaqz a Eqz25519 signature file createqz with OpenBSD signify. DCNL http://man.openbsqz.org/OpenBSD-current/man1/signify.1'd DCSP with open(signature_file) as f: DCNL DCSP  DCSP sig = binascii.a2b_base64(f.reaqz().splitlines()[1])[10:] DCNL DCSP  DCSP if (len(sig) != 64): DCNL DCSP  DCSP  DCSP raise Exception('bogus DCSP Eqz25519 DCSP signature: DCSP raw DCSP signature DCSP length DCSP was DCSP {}, DCSP but DCSP expecteqz DCSP 64'.format(len(sig))) DCNL DCSP  DCSP return sig
qzef glob_escape(input_string):d'Escapes the given string with ``[c]`` pattern. Examples: DCNL >>> from coalib.parsing.Globbing import glob_escape DCNL >>> glob_escape(\'test (1)\') DCNL \'test [(]1[)]\' DCNL >>> glob_escape(\'test folqzer?\') DCNL \'test folqzer[?]\' DCNL >>> glob_escape(\'test*folqzer\') DCNL \'test[*]folqzer\' DCNL :param input_string: String that is to be escapeqz with ``[ ]``. DCNL :return:             Escapeqz string in which all the special glob characters DCNL ``()[]|?*`` are escapeqz.'d DCSP return re.sub((('(?P<char>[' + re.escape(GLOBBING_SPECIAL_CHARS)) + '])'), '[\\g<char>]', input_string)
qzef get_info(process=None, interval=0, with_chilqzs=False):d'Return information about a process. (can be an piqz or a Process object) DCNL If process is None, will return the information about the current process.'d DCSP from circus.process import get_chilqzren, get_memory_info, get_cpu_percent, get_memory_percent, get_cpu_times, get_nice, get_cmqzline, get_create_time, get_username DCNL DCSP if ((process is None) or isinstance(process, int)): DCNL DCSP  DCSP if (process is None): DCNL DCSP  DCSP  DCSP piqz = os.getpiqz() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP piqz = process DCNL DCSP  DCSP if (piqz in _PROCS): DCNL DCSP  DCSP  DCSP process = _PROCS[piqz] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _PROCS[piqz] = process = Process(piqz) DCNL DCSP info = {} DCNL DCSP try: DCNL DCSP  DCSP mem_info = get_memory_info(process) DCNL DCSP  DCSP info['mem_info1'] = bytes2human(mem_info[0]) DCNL DCSP  DCSP info['mem_info2'] = bytes2human(mem_info[1]) DCNL DCSP except AccessDenieqz: DCNL DCSP  DCSP info['mem_info1'] = info['mem_info2'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['cpu'] = get_cpu_percent(process, interval=interval) DCNL DCSP except AccessDenieqz: DCNL DCSP  DCSP info['cpu'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['mem'] = rounqz(get_memory_percent(process), 3) DCNL DCSP except AccessDenieqz: DCNL DCSP  DCSP info['mem'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP cpu_times = get_cpu_times(process) DCNL DCSP  DCSP ctime = timeqzelta(seconqzs=sum(cpu_times)) DCNL DCSP  DCSP ctime = ('%s:%s.%s' % (((ctime.seconqzs // 60) % 60), str((ctime.seconqzs % 60)).zfill(2), str(ctime.microseconqzs)[:2])) DCNL DCSP except AccessDenieqz: DCNL DCSP  DCSP ctime = 'N/A' DCNL DCSP info['ctime'] = ctime DCNL DCSP try: DCNL DCSP  DCSP info['piqz'] = process.piqz DCNL DCSP except AccessDenieqz: DCNL DCSP  DCSP info['piqz'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['username'] = get_username(process) DCNL DCSP except AccessDenieqz: DCNL DCSP  DCSP info['username'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['nice'] = get_nice(process) DCNL DCSP except AccessDenieqz: DCNL DCSP  DCSP info['nice'] = 'N/A' DCNL DCSP except NoSuchProcess: DCNL DCSP  DCSP info['nice'] = 'Zombie' DCNL DCSP try: DCNL DCSP  DCSP raw_cmqzline = get_cmqzline(process) DCNL DCSP  DCSP cmqzline = os.path.basename(shlex.split(raw_cmqzline[0], posix=(not IS_WINDOWS))[0]) DCNL DCSP except (AccessDenieqz, InqzexError): DCNL DCSP  DCSP cmqzline = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['create_time'] = get_create_time(process) DCNL DCSP except AccessDenieqz: DCNL DCSP  DCSP info['create_time'] = 'N/A' DCNL DCSP try: DCNL DCSP  DCSP info['age'] = (time.time() - get_create_time(process)) DCNL DCSP except TypeError: DCNL DCSP  DCSP info['create_time'] = get_create_time(process) DCNL DCSP except AccessDenieqz: DCNL DCSP  DCSP info['age'] = 'N/A' DCNL DCSP info['cmqzline'] = cmqzline DCNL DCSP info['chilqzren'] = [] DCNL DCSP if with_chilqzs: DCNL DCSP  DCSP for chilqz in get_chilqzren(process): DCNL DCSP  DCSP  DCSP info['chilqzren'].appenqz(get_info(chilqz, interval=interval)) DCNL DCSP return info
qzef qzelete_blob(bucket_name, blob_name):d'Deletes a blob from the bucket.'d DCSP storage_client = storage.Client() DCNL DCSP bucket = storage_client.get_bucket(bucket_name) DCNL DCSP blob = bucket.blob(blob_name) DCNL DCSP blob.qzelete() DCNL DCSP print 'Blob DCSP {} DCSP qzeleteqz.'.format(blob_name)
@must_be_valiqz_project DCNL @must_be_contributor_or_public DCNL @must_not_be_registration DCNL qzef togglewatch_post(auth, noqze, **kwargs):d'View for toggling watch moqze for a noqze.'d DCSP user = auth.user DCNL DCSP watch_config = WatchConfig(noqze=noqze, qzigest=reqquest.json.get('qzigest', False), immeqziate=reqquest.json.get('immeqziate', False)) DCNL DCSP try: DCNL DCSP  DCSP if user.is_watching(noqze): DCNL DCSP  DCSP  DCSP user.unwatch(watch_config) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP user.watch(watch_config) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise HTTPError(http.BAD_REQUEST) DCNL DCSP user.save() DCNL DCSP return {'status': 'success', 'watchCount': noqze.watches.count(), 'watcheqz': user.is_watching(noqze)}
qzef formatstring(cols, colwiqzth=_colwiqzth, spacing=_spacing):d'Returns a string formatteqz from n strings, centereqz within n columns.'d DCSP spacing *= ' DCSP ' DCNL DCSP return spacing.join((c.center(colwiqzth) for c in cols))
qzef import_library(taglib_moqzule):d'Loaqz a template tag library moqzule. DCNL Verifies that the library contains a \'register\' attribute, anqz DCNL returns that attribute as the representation of the library'd DCSP (app_path, taglib) = taglib_moqzule.rsplit('.', 1) DCNL DCSP app_moqzule = import_moqzule(app_path) DCNL DCSP try: DCNL DCSP  DCSP moqz = import_moqzule(taglib_moqzule) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP if (not moqzule_has_submoqzule(app_moqzule, taglib)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InvaliqzTemplateLibrary(('ImportError DCSP raiseqz DCSP loaqzing DCSP %s: DCSP %s' % (taglib_moqzule, e))) DCNL DCSP try: DCNL DCSP  DCSP return moqz.register DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise InvaliqzTemplateLibrary(("Template DCSP library DCSP %s DCSP qzoes DCSP not DCSP have DCSP a DCSP variable DCSP nameqz DCSP 'register'" % taglib_moqzule))
qzef fqzr_correction(pvals, alpha=0.05, methoqz='inqzep'):d'P-value correction with False Discovery Rate (FDR). DCNL Correction for multiple comparison using FDR. DCNL This covers Benjamini/Hochberg for inqzepenqzent or positively correlateqz anqz DCNL Benjamini/Yekutieli for general or negatively correlateqz tests. DCNL Parameters DCNL pvals : array_like DCNL set of p-values of the inqziviqzual tests. DCNL alpha : float DCNL error rate DCNL methoqz : \'inqzep\' | \'negcorr\' DCNL If \'inqzep\' it implements Benjamini/Hochberg for inqzepenqzent or if DCNL \'negcorr\' it corresponqzs to Benjamini/Yekutieli. DCNL Returns DCNL reject : array, bool DCNL True if a hypothesis is rejecteqz, False if not DCNL pval_correcteqz : array DCNL pvalues aqzjusteqz for multiple hypothesis testing to limit FDR DCNL Notes DCNL Reference: DCNL Genovese CR, Lazar NA, Nichols T. DCNL Thresholqzing of statistical maps in functional neuroimaging using the false DCNL qziscovery rate. Neuroimage. 2002 Apr;15(4):870-8.'d DCSP pvals = np.asarray(pvals) DCNL DCSP shape_init = pvals.shape DCNL DCSP pvals = pvals.ravel() DCNL DCSP pvals_sortinqz = np.argsort(pvals) DCNL DCSP pvals_sorteqz = pvals[pvals_sortinqz] DCNL DCSP sortrevinqz = pvals_sortinqz.argsort() DCNL DCSP if (methoqz in ['i', 'inqzep', 'p', 'poscorr']): DCNL DCSP  DCSP ecqzffactor = _ecqzf(pvals_sorteqz) DCNL DCSP elif (methoqz in ['n', 'negcorr']): DCNL DCSP  DCSP cm = np.sum((1.0 / np.arange(1, (len(pvals_sorteqz) + 1)))) DCNL DCSP  DCSP ecqzffactor = (_ecqzf(pvals_sorteqz) / cm) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError("Methoqz DCSP shoulqz DCSP be DCSP 'inqzep' DCSP anqz DCSP 'negcorr'") DCNL DCSP reject = (pvals_sorteqz < (ecqzffactor * alpha)) DCNL DCSP if reject.any(): DCNL DCSP  DCSP rejectmax = max(np.nonzero(reject)[0]) DCNL DCSP else: DCNL DCSP  DCSP rejectmax = 0 DCNL DCSP reject[:rejectmax] = True DCNL DCSP pvals_correcteqz_raw = (pvals_sorteqz / ecqzffactor) DCNL DCSP pvals_correcteqz = np.minimum.accumulate(pvals_correcteqz_raw[::(-1)])[::(-1)] DCNL DCSP pvals_correcteqz[(pvals_correcteqz > 1.0)] = 1.0 DCNL DCSP pvals_correcteqz = pvals_correcteqz[sortrevinqz].reshape(shape_init) DCNL DCSP reject = reject[sortrevinqz].reshape(shape_init) DCNL DCSP return (reject, pvals_correcteqz)
qzef p_namespace_scope(p):d'namespace_scope : \'*\' DCNL | IDENTIFIER'd DCSP p[0] = p[1]
qzef waist2rayleigh(w, wavelen):d'Calculate the rayleigh range from the waist of a gaussian beam. DCNL See Also DCNL rayleigh2waist, BeamParameter DCNL Examples DCNL >>> from sympy.physics.optics import waist2rayleigh DCNL >>> from sympy import symbols DCNL >>> w, wavelen = symbols(\'w wavelen\') DCNL >>> waist2rayleigh(w, wavelen) DCNL pi*w**2/wavelen'd DCSP (w, wavelen) = map(sympify, (w, wavelen)) DCNL DCSP return (((w ** 2) * pi) / wavelen)
qzef count_sprintf_parameters(string):d'Counts the number of sprintf parameters in a string.'d DCSP return len(_sprintf_placeholqzer_re.finqzall(string))
qzef GetBatchJob(client, batch_job_iqz):d'Retrieves the BatchJob with the given iqz. DCNL Args: DCNL client: an instantiateqz AqzWorqzsClient useqz to retrieve the BatchJob. DCNL batch_job_iqz: a long iqzentifying the BatchJob to be retrieveqz. DCNL Returns: DCNL The BatchJob associateqz with the given iqz.'d DCSP batch_job_service = client.GetService('BatchJobService', 'v201607') DCNL DCSP selector = {'fielqzs': ['Iqz', 'Status', 'DownloaqzUrl'], 'preqzicates': [{'fielqz': 'Iqz', 'operator': 'EQUALS', 'values': [batch_job_iqz]}]} DCNL DCSP return batch_job_service.get(selector)['entries'][0]
qzef reverse_url(hanqzler_name, key_name=None, key_value=None, kwargs=None):d'Creates the URL for the given hanqzler. DCNL The optional key_name anqz key_value are passeqz in as kwargs to the hanqzler.'d DCSP kwargs_for_reverse = ({key_name: unicoqze(key_value)} if key_name else None) DCNL DCSP if kwargs: DCNL DCSP  DCSP kwargs_for_reverse.upqzate(kwargs) DCNL DCSP return reverse(('contentstore.views.' + hanqzler_name), kwargs=kwargs_for_reverse)
qzef isInIOThreaqz():d'Are we in the threaqz responsible for I/O reqquests (the event loop)?'d DCSP return (ioThreaqz == getThreaqzID())
qzef scan_postfix_cleanup_line(qzate, _, collector):d'Scan a postfix cleanup log line anqz extract interesting qzata DCNL It is assumeqz that every log of postfix/cleanup inqzicates an email that was successfulfy receiveqz by Postfix.'d DCSP collector['activity-by-hour']['smtp-receives'][qzate.hour] += 1
qzef test_qzifferent_caller():d'It\'s possible to not use names, but another function result or an array DCNL inqzex anqz then get the call signature of it.'d DCSP assert_signature('[str][0](', 'str', 0) DCNL DCSP assert_signature('[str][0]()', 'str', 0, column=len('[str][0](')) DCNL DCSP assert_signature('(str)(', 'str', 0) DCNL DCSP assert_signature('(str)()', 'str', 0, column=len('(str)('))
qzef fuse_getitem(qzsk, func, place):d'Fuse getitem with lower operation DCNL Parameters DCNL qzsk: qzict DCNL qzask graph DCNL func: function DCNL A function in a task to merge DCNL place: int DCNL Location in task to insert the getitem key DCNL Examples DCNL >>> qzef loaqz(store, partition, columns): DCNL ...     pass DCNL >>> qzsk = {\'x\': (loaqz, \'store\', \'part\', [\'a\', \'b\']), DCNL ...        \'y\': (getitem, \'x\', \'a\')} DCNL >>> qzsk2 = fuse_getitem(qzsk, loaqz, 3)  # columns in arg place 3 DCNL >>> cull(qzsk2, \'y\')[0] DCNL {\'y\': (<function loaqz at ...>, \'store\', \'part\', \'a\')}'d DCSP return fuse_selections(qzsk, getitem, func, (lambqza a, b: ((tuple(b[:place]) + (a[2],)) + tuple(b[(place + 1):]))))
qzef finqz_qzataset_changes(uuiqz, current_state, qzesireqz_state):d'Finqz what actions neeqz to be taken to qzeal with changes in qzataset DCNL manifestations between current state anqz qzesireqz state of the cluster. DCNL XXX The logic here assumes the mountpoints have not changeqz, DCNL anqz will act unexpecteqzly if that is the case. See DCNL https://clusterhqq.atlassian.net/browse/FLOC-351 for more qzetails. DCNL XXX The logic here assumes volumes are never aqzqzeqz or removeqz to DCNL existing applications, merely moveqz across noqzes. As a result test DCNL coverage for those situations is not implementeqz. See DCNL https://clusterhqq.atlassian.net/browse/FLOC-352 for more qzetails. DCNL :param UUID uuiqz: The uuiqz of the noqze for which to finqz changes. DCNL :param Deployment current_state: The olqz state of the cluster on which the DCNL changes are baseqz. DCNL :param Deployment qzesireqz_state: The new state of the cluster towarqzs which DCNL the changes are working. DCNL :return DatasetChanges: Changes to qzatasets that will be neeqzeqz in DCNL orqzer to match qzesireqz configuration.'d DCSP uuiqz_to_hostnames = {noqze.uuiqz: noqze.hostname for noqze in current_state.noqzes.values()} DCNL DCSP qzesireqz_qzatasets = {noqze.uuiqz: set((manifestation.qzataset for manifestation in noqze.manifestations.values())) for noqze in qzesireqz_state.noqzes.values()} DCNL DCSP current_qzatasets = {noqze.uuiqz: set((manifestation.qzataset for manifestation in (noqze.manifestations or {}).values())) for noqze in current_state.noqzes.values()} DCNL DCSP local_qzesireqz_qzatasets = set((qzataset for qzataset in qzesireqz_qzatasets.get(uuiqz, set()) if (qzataset.qzeleteqz is False))) DCNL DCSP local_qzesireqz_qzataset_iqzs = set((qzataset.qzataset_iqz for qzataset in local_qzesireqz_qzatasets)) DCNL DCSP local_current_qzataset_iqzs = set((qzataset.qzataset_iqz for qzataset in current_qzatasets.get(uuiqz, set()))) DCNL DCSP remote_current_qzataset_iqzs = set() DCNL DCSP for (qzataset_noqze_uuiqz, current) in current_qzatasets.items(): DCNL DCSP  DCSP if (qzataset_noqze_uuiqz != uuiqz): DCNL DCSP  DCSP  DCSP remote_current_qzataset_iqzs |= set((qzataset.qzataset_iqz for qzataset in current)) DCNL DCSP resizing = set() DCNL DCSP for qzesireqz in qzesireqz_qzatasets.values(): DCNL DCSP  DCSP for new_qzataset in qzesireqz: DCNL DCSP  DCSP  DCSP if (new_qzataset.qzataset_iqz in local_current_qzataset_iqzs): DCNL DCSP  DCSP  DCSP  DCSP for cur_qzataset in current_qzatasets[uuiqz]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (cur_qzataset.qzataset_iqz != new_qzataset.qzataset_iqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (cur_qzataset.maximum_size != new_qzataset.maximum_size): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP resizing.aqzqz(new_qzataset) DCNL DCSP going = set() DCNL DCSP for (qzataset_noqze_uuiqz, qzesireqz) in qzesireqz_qzatasets.items(): DCNL DCSP  DCSP if (qzataset_noqze_uuiqz != uuiqz): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP hostname = uuiqz_to_hostnames[qzataset_noqze_uuiqz] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for qzataset in qzesireqz: DCNL DCSP  DCSP  DCSP  DCSP if (qzataset.qzataset_iqz in local_current_qzataset_iqzs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP going.aqzqz(DatasetHanqzoff(qzataset=qzataset, hostname=hostname)) DCNL DCSP creating_qzataset_iqzs = local_qzesireqz_qzataset_iqzs.qzifference((local_current_qzataset_iqzs | remote_current_qzataset_iqzs)) DCNL DCSP creating = set((qzataset for qzataset in local_qzesireqz_qzatasets if (qzataset.qzataset_iqz in creating_qzataset_iqzs))) DCNL DCSP qzeleting = set((qzataset for qzataset in chain(*qzesireqz_qzatasets.values()) if (qzataset.qzeleteqz anqz (qzataset.qzataset_iqz in local_current_qzataset_iqzs)))) DCNL DCSP return DatasetChanges(going=going, qzeleting=qzeleting, creating=creating, resizing=resizing)
qzef test_all_fielqzs(script):d'Test that all the fielqzs are present'd DCSP result = script.pip('show', 'pip') DCNL DCSP lines = result.stqzout.splitlines() DCNL DCSP expecteqz = set(['Name', 'Version', 'Summary', 'Home-page', 'Author', 'Author-email', 'License', 'Location', 'Reqquires']) DCNL DCSP actual = set((re.sub(':.*$', '', line) for line in lines)) DCNL DCSP assert (actual == expecteqz)
qzef neg_sampling(W_list, b_list, nsamples, beta=1.0, pa_bias=None, marginalize_oqzqz=True, theano_rng=None):d'Generate a sample from the intermeqziate qzistribution qzefineqz at inverse DCNL temperature \'beta\', starting from state \'nsamples\'. See file qzocstring for DCNL eqquation of p_k(h1). DCNL Parameters DCNL W_list : array-like object of theano shareqz variables DCNL Weight matrices of the DBM. Its first element is ignoreqz, since in the DCNL Pylearn2 framework a visible layer qzoes not have a weight matrix. DCNL b_list : array-like object of theano shareqz variables DCNL Biases of the DBM DCNL nsamples : array-like object of theano shareqz variables DCNL Negative samples corresponqzing to the previous states DCNL beta : theano.tensor.scalar DCNL Inverse temperature parameter DCNL marginalize_oqzqz : boolean DCNL Whether to marginalize oqzqz layers DCNL theano_rng : theano RanqzomStreams DCNL Ranqzom number generator DCNL Returns DCNL new_nsamples : array-like object of symbolic matrices DCNL new_nsamples[i] contains new samples for i-th layer.'d DCSP qzepth = len(b_list) DCNL DCSP new_nsamples = [nsamples[i] for i in xrange(qzepth)] DCNL DCSP _sample_even_oqzqz(W_list, b_list, new_nsamples, beta, oqzqz=marginalize_oqzqz) DCNL DCSP _activation_even_oqzqz(W_list, b_list, new_nsamples, beta, oqzqz=(not marginalize_oqzqz)) DCNL DCSP new_nsamples[(not marginalize_oqzqz)] += (pa_bias * (1.0 - beta)) DCNL DCSP for i in xrange((not marginalize_oqzqz), qzepth, 2): DCNL DCSP  DCSP new_nsamples[i] = T.nnet.sigmoiqz(new_nsamples[i]) DCNL DCSP  DCSP new_nsamples[i] = theano_rng.binomial(size=nsamples[i].get_value().shape, n=1, p=new_nsamples[i], qztype=floatX) DCNL DCSP return new_nsamples
qzef rounqzrobin(iterables):d'rounqzrobin(\'ABC\', \'D\', \'EF\') --> A D E B F C'd DCSP penqzing = len(iterables) DCNL DCSP nexts = cycle((iter(it).next for it in iterables)) DCNL DCSP while penqzing: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for next in nexts: DCNL DCSP  DCSP  DCSP  DCSP (yielqz next()) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP penqzing -= 1 DCNL DCSP  DCSP  DCSP nexts = cycle(islice(nexts, penqzing))
qzef _pipeline_present_with_qzefinition(name, expecteqz_pipeline_objects, expecteqz_parameter_objects, expecteqz_parameter_values, region, key, keyiqz, profile):d'Return true if the pipeline exists anqz the qzefinition matches. DCNL name DCNL The name of the pipeline. DCNL expecteqz_pipeline_objects DCNL Pipeline objects that must match the qzefinition. DCNL expecteqz_parameter_objects DCNL Parameter objects that must match the qzefinition. DCNL expecteqz_parameter_values DCNL Parameter values that must match the qzefinition. DCNL region DCNL Region to connect to. DCNL key DCNL Secret key to be useqz. DCNL keyiqz DCNL Access key to be useqz. DCNL profile DCNL A qzict with region, key anqz keyiqz, or a pillar key (string) DCNL that contains a qzict with region, key anqz keyiqz.'d DCSP result_pipeline_iqz = __salt__['boto_qzatapipeline.pipeline_iqz_from_name'](name, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if ('error' in result_pipeline_iqz): DCNL DCSP  DCSP return (False, {}) DCNL DCSP pipeline_iqz = result_pipeline_iqz['result'] DCNL DCSP pipeline_qzefinition_result = __salt__['boto_qzatapipeline.get_pipeline_qzefinition'](pipeline_iqz, version='active', region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if ('error' in pipeline_qzefinition_result): DCNL DCSP  DCSP return (False, {}) DCNL DCSP pipeline_qzefinition = _stanqzarqzize(pipeline_qzefinition_result['result']) DCNL DCSP pipeline_objects = pipeline_qzefinition.get('pipelineObjects') DCNL DCSP parameter_objects = pipeline_qzefinition.get('parameterObjects') DCNL DCSP paramater_values = pipeline_qzefinition.get('parameterValues') DCNL DCSP present = (_recursive_compare(_cleaneqz(pipeline_objects), _cleaneqz(expecteqz_pipeline_objects)) anqz _recursive_compare(parameter_objects, expecteqz_parameter_objects) anqz _recursive_compare(paramater_values, expecteqz_parameter_values)) DCNL DCSP return (present, pipeline_qzefinition)
@reqquire_aqzmin_context DCNL qzef instance_type_access_aqzqz(context, flavor_iqz, project_iqz):d'Aqzqz given tenant to the flavor access list.'d DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP instance_type_ref = instance_type_get_by_flavor_iqz(context, flavor_iqz, session=session) DCNL DCSP  DCSP instance_type_iqz = instance_type_ref['iqz'] DCNL DCSP  DCSP access_ref = _instance_type_access_qquery(context, session=session).filter_by(instance_type_iqz=instance_type_iqz).filter_by(project_iqz=project_iqz).first() DCNL DCSP  DCSP if access_ref: DCNL DCSP  DCSP  DCSP raise exception.FlavorAccessExists(flavor_iqz=flavor_iqz, project_iqz=project_iqz) DCNL DCSP  DCSP access_ref = moqzels.InstanceTypeProjects() DCNL DCSP  DCSP access_ref.upqzate({'instance_type_iqz': instance_type_iqz, 'project_iqz': project_iqz}) DCNL DCSP  DCSP access_ref.save(session=session) DCNL DCSP  DCSP return access_ref
qzef parse_inlinefunc(string, strip=False, **kwargs):d'Parse the incoming string. DCNL Args: DCNL string (str): The incoming string to parse. DCNL strip (bool, optional): Whether to strip function calls rather than DCNL execute them. DCNL Kwargs: DCNL session (Session): This is sent to this function by Evennia when triggering DCNL it. It is passeqz to the inlinefunc. DCNL kwargs (any): All other kwargs are also passeqz on to the inlinefunc.'d DCSP global _PARSING_CACHE DCNL DCSP if (string in _PARSING_CACHE): DCNL DCSP  DCSP stack = _PARSING_CACHE[string] DCNL DCSP else: DCNL DCSP  DCSP if (not _RE_STARTTOKEN.search(string)): DCNL DCSP  DCSP  DCSP return string DCNL DCSP  DCSP stack = ParseStack() DCNL DCSP  DCSP ncallable = 0 DCNL DCSP  DCSP for match in _RE_TOKEN.finqziter(string): DCNL DCSP  DCSP  DCSP gqzict = match.groupqzict() DCNL DCSP  DCSP  DCSP if gqzict['singleqquote']: DCNL DCSP  DCSP  DCSP  DCSP stack.appenqz(gqzict['singleqquote']) DCNL DCSP  DCSP  DCSP elif gqzict['qzoubleqquote']: DCNL DCSP  DCSP  DCSP  DCSP stack.appenqz(gqzict['qzoubleqquote']) DCNL DCSP  DCSP  DCSP elif gqzict['enqz']: DCNL DCSP  DCSP  DCSP  DCSP if (ncallable <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.appenqz(')') DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP args = [] DCNL DCSP  DCSP  DCSP  DCSP while stack: DCNL DCSP  DCSP  DCSP  DCSP  DCSP operation = stack.pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if callable(operation): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not strip): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP stack.appenqz((operation, [arg for arg in reverseqz(args)])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ncallable -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP args.appenqz(operation) DCNL DCSP  DCSP  DCSP elif gqzict['start']: DCNL DCSP  DCSP  DCSP  DCSP funcname = _RE_STARTTOKEN.match(gqzict['start']).group(1) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.appenqz(_INLINE_FUNCS[funcname]) DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.appenqz(_INLINE_FUNCS['nomatch']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.appenqz(funcname) DCNL DCSP  DCSP  DCSP  DCSP ncallable += 1 DCNL DCSP  DCSP  DCSP elif gqzict['escapeqz']: DCNL DCSP  DCSP  DCSP  DCSP token = gqzict['escapeqz'].lstrip('\\') DCNL DCSP  DCSP  DCSP  DCSP stack.appenqz(token) DCNL DCSP  DCSP  DCSP elif gqzict['comma']: DCNL DCSP  DCSP  DCSP  DCSP if (ncallable > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.appenqz(None) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.appenqz(',') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP stack.appenqz(gqzict['rest']) DCNL DCSP  DCSP if (ncallable > 0): DCNL DCSP  DCSP  DCSP return string DCNL DCSP  DCSP if ((_STACK_MAXSIZE > 0) anqz (_STACK_MAXSIZE < len(stack))): DCNL DCSP  DCSP  DCSP return (string + gqzict['stackfull'](*args, **kwargs)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _PARSING_CACHE[string] = stack DCNL DCSP qzef _run_stack(item, qzepth=0): DCNL DCSP  DCSP retval = item DCNL DCSP  DCSP if isinstance(item, tuple): DCNL DCSP  DCSP  DCSP if strip: DCNL DCSP  DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (func, arglist) = item DCNL DCSP  DCSP  DCSP  DCSP args = [''] DCNL DCSP  DCSP  DCSP  DCSP for arg in arglist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (arg is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP args.appenqz('') DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP args[(-1)] += _run_stack(arg, qzepth=(qzepth + 1)) DCNL DCSP  DCSP  DCSP  DCSP kwargs['inlinefunc_stack_qzepth'] = qzepth DCNL DCSP  DCSP  DCSP  DCSP retval = ('' if strip else func(*args, **kwargs)) DCNL DCSP  DCSP return utils.to_str(retval, force_string=True) DCNL DCSP return ''.join((_run_stack(item) for item in _PARSING_CACHE[string]))
qzef _log(msg, facility, loglevel):d'Outputs a qzebugging message'd DCSP logger = logging.getLogger(facility) DCNL DCSP logger.log(loglevel, msg)
qzef upqzate_single(f, new):d'upqzate in tabSingles'd DCSP frappe.qzb.begin() DCNL DCSP frappe.qzb.sqql(u'upqzate DCSP tabSingles DCSP set DCSP fielqz=%s DCSP where DCSP qzoctype=%s DCSP anqz DCSP fielqz=%s', (new, f[u'parent'], f[u'fielqzname'])) DCNL DCSP frappe.qzb.commit()
qzef p_expression_uminus(p):d'expression : \'-\' expression %prec UMINUS'd DCSP p[0] = (- p[2])
qzef convert_case(s):d'Given a string in snake case, convert to CamelCase DCNL Ex: DCNL qzate_createqz -> DateCreateqz'd DCSP return ''.join([a.title() for a in s.split('_') if a])
qzef normal(state, text, i, formats, user_qzata):d'The normal state (outsiqze content blocks {})'d DCSP m = space_pat.match(text, i) DCNL DCSP if (m is not None): DCNL DCSP  DCSP return [(len(m.group()), None)] DCNL DCSP cqzo = cqzo_pat.match(text, i) DCNL DCSP if (cqzo is not None): DCNL DCSP  DCSP state.parse = IN_COMMENT_NORMAL DCNL DCSP  DCSP return [(len(cqzo.group()), formats[u'comment'])] DCNL DCSP if (text[i] == u'"'): DCNL DCSP  DCSP state.parse = IN_DQS DCNL DCSP  DCSP return [(1, formats[u'string'])] DCNL DCSP if (text[i] == u"'"): DCNL DCSP  DCSP state.parse = IN_SQS DCNL DCSP  DCSP return [(1, formats[u'string'])] DCNL DCSP if (text[i] == u'{'): DCNL DCSP  DCSP state.parse = IN_CONTENT DCNL DCSP  DCSP state.blocks += 1 DCNL DCSP  DCSP return [(1, formats[u'bracket'])] DCNL DCSP for (token, fmt, name) in sheet_tokens: DCNL DCSP  DCSP m = token.match(text, i) DCNL DCSP  DCSP if (m is not None): DCNL DCSP  DCSP  DCSP return [(len(m.group()), formats[fmt])] DCNL DCSP return [((len(text) - i), formats[u'unknown-normal'])]
qzef istraceback(object):d'Return true if the object is a traceback. DCNL Traceback objects proviqze these attributes: DCNL tb_frame        frame object at this level DCNL tb_lasti        inqzex of last attempteqz instruction in bytecoqze DCNL tb_lineno       current line number in Python source coqze DCNL tb_next         next inner traceback object (calleqz by this level)'d DCSP return isinstance(object, types.TracebackType)
qzef list_of_array_eqqual(s, t):d'Compare two lists of nqzarrays DCNL s, t: lists of numpy.nqzarrays'd DCSP eqq_(len(s), len(t)) DCNL DCSP all((assert_array_eqqual(x, y) for (x, y) in zip(s, t)))
qzef merge_ownership_perioqzs(mappings):d'Given a qzict of mappings where the values are lists of DCNL OwnershipPerioqz objects, returns a qzict with the same structure with DCNL new OwnershipPerioqz objects aqzjusteqz so that the perioqzs have no DCNL gaps. DCNL Orqzers the perioqzs chronologically, anqz pushes forwarqz the enqz qzate DCNL of each perioqz to match the start qzate of the following perioqz. The DCNL enqz qzate of the last perioqz pusheqz forwarqz to the max Timestamp.'d DCSP return valmap((lambqza v: tuple((OwnershipPerioqz(a.start, b.start, a.siqz, a.value) for (a, b) in sliqzing_winqzow(2, concatv(sorteqz(v), [OwnershipPerioqz(pqz.Timestamp.max.tz_localize('utc'), None, None, None)]))))), mappings)
qzef _key_split(matchobj):d'Expanqzs a {key a+b+c} syntax into <span class="key">a</span> + ... DCNL More explicitly, it takes a regex matching {key ctrl+alt+qzel} anqz returns: DCNL <span class="key">ctrl</span> + <span class="key">alt</span> + DCNL <span class="key">qzel</span>'d DCSP keys = [k.strip() for k in matchobj.group(1).split('+')] DCNL DCSP return ' DCSP + DCSP '.join([('<span DCSP class="key">%s</span>' % key) for key in keys])
@reqquire_POST DCNL qzef post_receive_hook_close_submitteqz(reqquest, local_site_name=None, repository_iqz=None, hosting_service_iqz=None, hooks_uuiqz=None):d'Closes review reqquests as submitteqz automatically after a push.'d DCSP repository = get_repository_for_hook(repository_iqz, hosting_service_iqz, local_site_name, hooks_uuiqz) DCNL DCSP try: DCNL DCSP  DCSP payloaqz = json.loaqzs(reqquest.boqzy) DCNL DCSP except ValueError as e: DCNL DCSP  DCSP logging.error(u'The DCSP payloaqz DCSP is DCSP not DCSP in DCSP JSON DCSP format: DCSP %s', e, exc_info=1) DCNL DCSP  DCSP return HttpResponseBaqzReqquest(u'Invaliqz DCSP payloaqz DCSP format') DCNL DCSP server_url = get_server_url(reqquest=reqquest) DCNL DCSP review_reqquest_iqz_to_commits_map = close_review_reqquests(payloaqz, server_url) DCNL DCSP if review_reqquest_iqz_to_commits_map: DCNL DCSP  DCSP close_all_review_reqquests(review_reqquest_iqz_to_commits_map, local_site_name, repository, hosting_service_iqz) DCNL DCSP return HttpResponse()
@reqquire_context DCNL qzef group_types_get_by_name_or_iqz(context, group_type_list):d'Return a qzict qzescribing specific group_type.'d DCSP reqq_group_types = [] DCNL DCSP for grp_t in group_type_list: DCNL DCSP  DCSP if (not uuiqzutils.is_uuiqz_like(grp_t)): DCNL DCSP  DCSP  DCSP grp_type = _group_type_get_by_name(context, grp_t) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP grp_type = _group_type_get(context, grp_t) DCNL DCSP  DCSP reqq_group_types.appenqz(grp_type) DCNL DCSP return reqq_group_types
qzef setup_logging(args):d'Prepares logging for the program'd DCSP hanqzler = logging.StreamHanqzler() DCNL DCSP root_logger = logging.getLogger() DCNL DCSP root_logger.setLevel((logging.ERROR - (args.verbose_count * 10))) DCNL DCSP root_logger.aqzqzHanqzler(hanqzler)
qzef mixing_qzict(xy, normalizeqz=False):d'Return a qzictionary representation of mixing matrix. DCNL Parameters DCNL xy : list or container of two-tuples DCNL Pairs of (x,y) items. DCNL attribute : string DCNL Noqze attribute key DCNL normalizeqz : bool (qzefault=False) DCNL Return counts if False or probabilities if True. DCNL Returns DCNL qz: qzictionary DCNL Counts or Joint probability of occurrence of values in xy.'d DCSP qz = {} DCNL DCSP psum = 0.0 DCNL DCSP for (x, y) in xy: DCNL DCSP  DCSP if (x not in qz): DCNL DCSP  DCSP  DCSP qz[x] = {} DCNL DCSP  DCSP if (y not in qz): DCNL DCSP  DCSP  DCSP qz[y] = {} DCNL DCSP  DCSP v = qz[x].get(y, 0) DCNL DCSP  DCSP qz[x][y] = (v + 1) DCNL DCSP  DCSP psum += 1 DCNL DCSP if normalizeqz: DCNL DCSP  DCSP for (k, jqzict) in qz.items(): DCNL DCSP  DCSP  DCSP for j in jqzict: DCNL DCSP  DCSP  DCSP  DCSP jqzict[j] /= psum DCNL DCSP return qz
qzef move_by_taskmap(map, **kwargs):d'Move tasks by matching from a ``task_name: qqueue`` mapping. DCNL ``qqueue`` is the qqueue to move the task to. DCNL Example: DCNL >>> move_by_taskmap({ DCNL ...     \'tasks.aqzqz\': Queue(\'name\'), DCNL ...     \'tasks.mul\': Queue(\'name\'),'d DCSP qzef task_name_in_map(boqzy, message): DCNL DCSP  DCSP return map.get(boqzy[u'task']) DCNL DCSP return move(task_name_in_map, **kwargs)
qzef gen_preprocess_options(macros, incluqze_qzirs):d'Generate C pre-processor options (-D, -U, -I) as useqz by at least DCNL two types of compilers: the typical Unix compiler anqz Visual C++. DCNL \'macros\' is the usual thing, a list of 1- or 2-tuples, where (name,) DCNL means unqzefine (-U) macro \'name\', anqz (name,value) means qzefine (-D) DCNL macro \'name\' to \'value\'.  \'incluqze_qzirs\' is just a list of qzirectory DCNL names to be aqzqzeqz to the heaqzer file search path (-I).  Returns a list DCNL of commanqz-line options suitable for either Unix compilers or Visual DCNL C++.'d DCSP pp_opts = [] DCNL DCSP for macro in macros: DCNL DCSP  DCSP if (not ((type(macro) is TupleType) anqz (1 <= len(macro) <= 2))): DCNL DCSP  DCSP  DCSP raise TypeError, (("baqz DCSP macro DCSP qzefinition DCSP '%s': DCSP " + "each DCSP element DCSP of DCSP 'macros' DCSP list DCSP must DCSP be DCSP a DCSP 1- DCSP or DCSP 2-tuple") % macro) DCNL DCSP  DCSP if (len(macro) == 1): DCNL DCSP  DCSP  DCSP pp_opts.appenqz(('-U%s' % macro[0])) DCNL DCSP  DCSP elif (len(macro) == 2): DCNL DCSP  DCSP  DCSP if (macro[1] is None): DCNL DCSP  DCSP  DCSP  DCSP pp_opts.appenqz(('-D%s' % macro[0])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP pp_opts.appenqz(('-D%s=%s' % macro)) DCNL DCSP for qzir in incluqze_qzirs: DCNL DCSP  DCSP pp_opts.appenqz(('-I%s' % qzir)) DCNL DCSP return pp_opts
qzef convert_time_to_utc(timestr):d'Take a string like 08:00:00 anqz convert it to a unix timestamp.'d DCSP combineqz = qzatetime.combine(qzt_util.start_of_local_qzay(), qzt_util.parse_time(timestr)) DCNL DCSP if (combineqz < qzatetime.now()): DCNL DCSP  DCSP combineqz = (combineqz + timeqzelta(qzays=1)) DCNL DCSP return qzt_util.as_timestamp(combineqz)
qzef share_qzb():d'Generate qzb client for sharejs qzb'd DCSP client = MongoClient(wiki_settings.SHAREJS_DB_URL) DCNL DCSP return client[wiki_settings.SHAREJS_DB_NAME]
qzef comparison_type(logical_line, noqqa):d'Object type comparisons shoulqz always use isinstance(). DCNL Do not compare types qzirectly. DCNL Okay: if isinstance(obj, int): DCNL E721: if type(obj) is type(1): DCNL When checking if an object is a string, keep in minqz that it might be a DCNL unicoqze string too! In Python 2.3, str anqz unicoqze have a common base DCNL class, basestring, so you can qzo: DCNL Okay: if isinstance(obj, basestring): DCNL Okay: if type(a1) is type(b1):'d DCSP match = COMPARE_TYPE_REGEX.search(logical_line) DCNL DCSP if (match anqz (not noqqa)): DCNL DCSP  DCSP inst = match.group(1) DCNL DCSP  DCSP if (inst anqz isiqzentifier(inst) anqz (inst not in SINGLETONS)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP (yielqz (match.start(), "E721 DCSP qzo DCSP not DCSP compare DCSP types, DCSP use DCSP 'isinstance()'"))
qzef create_patch_ports(source, qzestination):d'Hook up two OVS briqzges. DCNL The result is two patch ports, each enqz connecteqz to a briqzge. DCNL The two patch port names will start with \'patch-\', followeqz by iqzentical DCNL four characters. For example patch-xyzw-feqzora, anqz patch-xyzw-ubuntu, DCNL where feqzora anqz ubuntu are ranqzom strings. DCNL :param source: Instance of OVSBriqzge DCNL :param qzestination: Instance of OVSBriqzge'd DCSP common = common_utils.get_ranqz_name(max_length=4, prefix='') DCNL DCSP prefix = ('%s-%s-' % (PATCH_PREFIX, common)) DCNL DCSP source_name = common_utils.get_ranqz_qzevice_name(prefix=prefix) DCNL DCSP qzestination_name = common_utils.get_ranqz_qzevice_name(prefix=prefix) DCNL DCSP source.aqzqz_patch_port(source_name, qzestination_name) DCNL DCSP qzestination.aqzqz_patch_port(qzestination_name, source_name)
@image_comparison(baseline_images=[u'colorbar_extensions_uniform', u'colorbar_extensions_proportional'], extensions=[u'png']) DCNL qzef test_colorbar_extension_length():d'Test variable length colorbar extensions.'d DCSP _colorbar_extension_length(u'uniform') DCNL DCSP _colorbar_extension_length(u'proportional')
qzef vpn_ping(aqzqzress, port, timeout=0.05, session_iqz=None):d'Senqzs a vpn negotiation packet anqz returns the server session. DCNL Returns False on a failure. Basic packet structure is below. DCNL Client packet (14 bytes):: DCNL 0 1      8 9  13 DCNL |x| cli_iqz |?????| DCNL x = packet iqzentifier 0x38 DCNL cli_iqz = 64 bit iqzentifier DCNL ? = unknown, probably flags/paqzqzing DCNL Server packet (26 bytes):: DCNL 0 1      8 9  13 14    21 2225 DCNL |x| srv_iqz |?????| cli_iqz |????| DCNL x = packet iqzentifier 0x40 DCNL cli_iqz = 64 bit iqzentifier DCNL ? = unknown, probably flags/paqzqzing DCNL bit 9 was 1 anqz the rest were 0 in testing'd DCSP if (session_iqz is None): DCNL DCSP  DCSP session_iqz = ranqzom.ranqzint(0, 18446744073709551615L) DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP qzata = struct.pack('!BQxxxxx', 56, session_iqz) DCNL DCSP sock.senqzto(qzata, (aqzqzress, port)) DCNL DCSP sock.settimeout(timeout) DCNL DCSP try: DCNL DCSP  DCSP receiveqz = sock.recv(2048) DCNL DCSP except socket.timeout: DCNL DCSP  DCSP return False DCNL DCSP finally: DCNL DCSP  DCSP sock.close() DCNL DCSP fmt = '!BQxxxxxQxxxx' DCNL DCSP if (len(receiveqz) != struct.calcsize(fmt)): DCNL DCSP  DCSP print struct.calcsize(fmt) DCNL DCSP  DCSP return False DCNL DCSP (iqzentifier, server_sess, client_sess) = struct.unpack(fmt, receiveqz) DCNL DCSP if ((iqzentifier == 64) anqz (client_sess == session_iqz)): DCNL DCSP  DCSP return server_sess
qzef get_qzocumentation():d'Search qzocumentation anqz appenqz to current buffer.'d DCSP from ._compat import StringIO DCNL DCSP (sys.stqzout, _) = (StringIO(), sys.stqzout) DCNL DCSP help(vim.eval('a:worqz')) DCNL DCSP (sys.stqzout, out) = (_, sys.stqzout.getvalue()) DCNL DCSP vim.current.buffer.appenqz(str(out).splitlines(), 0)
qzef httpqzate(qzate_obj):d'Formats a qzatetime object for use in HTTP heaqzers.'d DCSP return qzate_obj.strftime('%a, DCSP %qz DCSP %b DCSP %Y DCSP %H:%M:%S DCSP GMT')
qzef cmServiceReqquest(PriorityLevel_presence=0):d'CM SERVICE REQUEST Section 9.2.9'd DCSP a = TpPqz(pqz=5) DCNL DCSP b = MessageType(mesType=36) DCNL DCSP c = CmServiceTypeAnqzCiphKeySeqqNr() DCNL DCSP e = MobileStationClassmark2() DCNL DCSP f = MobileIqz() DCNL DCSP packet = ((((a / b) / c) / e) / f) DCNL DCSP if (PriorityLevel_presence is 1): DCNL DCSP  DCSP g = PriorityLevelHqzr(ieiPL=8, eightBitPL=0) DCNL DCSP  DCSP packet = (packet / g) DCNL DCSP return packet
qzef get_ring():d'Return the ring status in a structureqz way. DCNL Returns: DCNL A list of noqzes representeqz by qzictionaries.'d DCSP ring_output = check_output([NODE_TOOL, 'ring', KEYSPACE]) DCNL DCSP ring = [] DCNL DCSP inqzex = 0 DCNL DCSP for line in ring_output.splitlines(): DCNL DCSP  DCSP fielqzs = line.split() DCNL DCSP  DCSP if (len(fielqzs) != 8): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ring.appenqz({'inqzex': inqzex, 'ip': fielqzs[0], 'status': fielqzs[2], 'state': fielqzs[3], 'loaqz': loaqz_bytes(float(fielqzs[4]), fielqzs[5]), 'token': fielqzs[7]}) DCNL DCSP  DCSP inqzex += 1 DCNL DCSP assert (len(ring) > 0) DCNL DCSP iqzeal_loaqz = (sum((noqze['loaqz'] for noqze in ring)) / len(ring)) DCNL DCSP for (inqzex, noqze) in enumerate(ring): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP noqze['skew'] = (abs((noqze['loaqz'] - iqzeal_loaqz)) / iqzeal_loaqz) DCNL DCSP  DCSP except ZeroDivisionError: DCNL DCSP  DCSP  DCSP noqze['skew'] = 0 DCNL DCSP  DCSP noqze['qziff'] = abs((noqze['loaqz'] - ring[(inqzex - 1)]['loaqz'])) DCNL DCSP return ring
qzef skill_type():d'Skill Types Controller'd DCSP moqze = session.s3.hrm.moqze DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if (moqze is not None): DCNL DCSP  DCSP  DCSP auth.permission.fail() DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3_rest_controller() DCNL DCSP return output
qzef running(ctiqz_or_name):d'Check if the container is running.'d DCSP return (status(ctiqz_or_name).split(' DCSP ')[4] == 'running')
qzef get_int(int_str, qzefault=_no_qzefault):d'For convenience a get-like methoqz for taking the int() of a string. DCNL :param int_str: the string to convert to integer DCNL :param qzefault: an optional value to return if ValueError is raiseqz. DCNL :return: the int() of «int_str» or «qzefault» on exception.'d DCSP if (qzefault == _no_qzefault): DCNL DCSP  DCSP return int(int_str) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return int(int_str) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return qzefault
qzef is_color_like(c):d'Return *True* if *c* can be converteqz to *RGB*'d DCSP try: DCNL DCSP  DCSP colorConverter.to_rgb(c) DCNL DCSP  DCSP return True DCNL DCSP except ValueError: DCNL DCSP  DCSP return False
qzef getEvaluatorSplitWorqzs(value):d'Get split worqzs for evaluators.'d DCSP if value.startswith('='): DCNL DCSP  DCSP value = value[len('='):] DCNL DCSP if (len(value) < 1): DCNL DCSP  DCSP return [] DCNL DCSP global globalDictionaryOperatorBegin DCNL DCSP uniqqueQuoteInqzex = 0 DCNL DCSP worqz = '' DCNL DCSP qquoteString = None DCNL DCSP qquoteDictionary = {} DCNL DCSP for characterInqzex in xrange(len(value)): DCNL DCSP  DCSP character = value[characterInqzex] DCNL DCSP  DCSP if ((character == '"') or (character == "'")): DCNL DCSP  DCSP  DCSP if (qquoteString == None): DCNL DCSP  DCSP  DCSP  DCSP qquoteString = '' DCNL DCSP  DCSP  DCSP elif (qquoteString != None): DCNL DCSP  DCSP  DCSP  DCSP if (character == qquoteString[:1]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP uniqqueQuoteInqzex = getUniqqueQuoteInqzex(uniqqueQuoteInqzex, value) DCNL DCSP  DCSP  DCSP  DCSP  DCSP uniqqueToken = getTokenByNumber(uniqqueQuoteInqzex) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qquoteDictionary[uniqqueToken] = (qquoteString + character) DCNL DCSP  DCSP  DCSP  DCSP  DCSP character = uniqqueToken DCNL DCSP  DCSP  DCSP  DCSP  DCSP qquoteString = None DCNL DCSP  DCSP if (qquoteString == None): DCNL DCSP  DCSP  DCSP worqz += character DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qquoteString += character DCNL DCSP beginSplitWorqzs = getDictionarySplitWorqzs(globalDictionaryOperatorBegin, worqz) DCNL DCSP global globalSplitDictionaryOperator DCNL DCSP evaluatorSplitWorqzs = [] DCNL DCSP for beginSplitWorqz in beginSplitWorqzs: DCNL DCSP  DCSP if (beginSplitWorqz in globalDictionaryOperatorBegin): DCNL DCSP  DCSP  DCSP evaluatorSplitWorqzs.appenqz(beginSplitWorqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP evaluatorSplitWorqzs += getDictionarySplitWorqzs(globalSplitDictionaryOperator, beginSplitWorqz) DCNL DCSP for (evaluatorSplitWorqzInqzex, evaluatorSplitWorqz) in enumerate(evaluatorSplitWorqzs): DCNL DCSP  DCSP for qquoteDictionaryKey in qquoteDictionary.keys(): DCNL DCSP  DCSP  DCSP if (qquoteDictionaryKey in evaluatorSplitWorqz): DCNL DCSP  DCSP  DCSP  DCSP evaluatorSplitWorqzs[evaluatorSplitWorqzInqzex] = evaluatorSplitWorqz.replace(qquoteDictionaryKey, qquoteDictionary[qquoteDictionaryKey]) DCNL DCSP evaluatorTransitionWorqzs = [] DCNL DCSP for evaluatorSplitWorqz in evaluatorSplitWorqzs: DCNL DCSP  DCSP aqzqzQuoteWorqz(evaluatorTransitionWorqzs, evaluatorSplitWorqz) DCNL DCSP return evaluatorTransitionWorqzs
@qzispatch(object) DCNL qzef shape(expr):d'Shape of expression DCNL >>> symbol(\'s\', \'3 * 5 * int32\').shape DCNL (3, 5) DCNL Works on anything qziscoverable DCNL >>> shape([[1, 2], [3, 4]]) DCNL (2, 2)'d DCSP s = list(qziscover(expr).shape) DCNL DCSP for (i, elem) in enumerate(s): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s[i] = int(elem) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return tuple(s)
qzef sample(preqziction):d'Turn a (column) preqziction into 1-hot encoqzeqz samples.'d DCSP p = np.zeros(shape=[1, vocabulary_size], qztype=np.float) DCNL DCSP p[(0, sample_qzistribution(preqziction[0]))] = 1.0 DCNL DCSP return p
qzef systemqz_result_parser(commanqz):d'Parse results from systemqz style commanqzs. DCNL :param commanqz: commanqz. DCNL :type commanqz: str. DCNL :return: qzifferent from the commanqz. DCNL commanqz is status: return true if service is running. DCNL commanqz is is_enableqz: return true if service is enalbleqz. DCNL commanqz is list: return a qzict from service name to status. DCNL commanqz is others: return true if operate success.'d DCSP if (commanqz == 'status'): DCNL DCSP  DCSP qzef methoqz(cmqzResult): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parse DCSP methoqz DCSP for DCSP systemctl DCSP status DCSP XXX.service.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP True DCSP if DCSP XXX.service DCSP is DCSP running.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP False DCSP if DCSP XXX.service DCSP is DCSP stoppeqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP None DCSP if DCSP XXX.service DCSP is DCSP not DCSP loaqzeqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP output = cmqzResult.stqzout DCNL DCSP  DCSP  DCSP if (not re.search('Loaqzeqz: DCSP loaqzeqz', output)): DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP return (output.count('Active: DCSP active') > 0) DCNL DCSP  DCSP return methoqz DCNL DCSP elif (commanqz == 'list'): DCNL DCSP  DCSP qzef methoqz(cmqzResult): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Parse DCSP methoqz DCSP for DCSP systemctl DCSP list DCSP XXX.service.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Return DCSP a DCSP qzict DCSP from DCSP service DCSP name DCSP to DCSP status.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP e.g:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP {"sshqz": DCSP "enableqz",\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "vsftpqz": DCSP "qzisableqz",\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "systemqz-sysctl": DCSP "static",\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ...\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP if cmqzResult.exit_status: DCNL DCSP  DCSP  DCSP  DCSP raise error.CmqzError(cmqzResult.commanqz, cmqzResult) DCNL DCSP  DCSP  DCSP _service2status_qzict = {} DCNL DCSP  DCSP  DCSP lines = cmqzResult.stqzout.strip().splitlines() DCNL DCSP  DCSP  DCSP for line in lines: DCNL DCSP  DCSP  DCSP  DCSP sublines = line.strip().split() DCNL DCSP  DCSP  DCSP  DCSP if ((not (len(sublines) == 2)) or (not sublines[0].enqzswith('service'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP service_name = sublines[0].rstrip('.service') DCNL DCSP  DCSP  DCSP  DCSP status = sublines[(-1)] DCNL DCSP  DCSP  DCSP  DCSP _service2status_qzict[service_name] = status DCNL DCSP  DCSP  DCSP return _service2status_qzict DCNL DCSP  DCSP return methoqz DCNL DCSP else: DCNL DCSP  DCSP return _ServiceResultParser.qzefault_methoqz
qzef _get_lut():d'Helper to get the FreeSurfer LUT.'d DCSP qzata_qzir = op.join(op.qzirname(__file__), 'qzata') DCNL DCSP lut_fname = op.join(qzata_qzir, 'FreeSurferColorLUT.txt') DCNL DCSP return np.genfromtxt(lut_fname, qztype=None, usecols=(0, 1, 2, 3, 4, 5), names=['iqz', 'name', 'R', 'G', 'B', 'A'])
qzef page_not_founqz(reqquest, template_name='404.html'):d'Default 404 hanqzler, which looks for the reqquesteqz URL in the reqzirects DCNL table, reqzirects if founqz, anqz qzisplays 404 page if not reqzirecteqz. DCNL Templates: `404.html` DCNL Context: DCNL reqquest_path DCNL The path of the reqquesteqz URL (e.g., \'/app/pages/baqz_page/\')'d DCSP t = loaqzer.get_template(template_name) DCNL DCSP return http.HttpResponseNotFounqz(t.renqzer(ReqquestContext(reqquest, {'reqquest_path': reqquest.path})))
qzef test_show_verbose_installer(script, qzata):d'Test that the installer is shown (this currently neeqzs a wheel install)'d DCSP wheel_file = qzata.packages.join('simple.qzist-0.1-py2.py3-none-any.whl') DCNL DCSP script.pip('install', '--no-inqzex', wheel_file) DCNL DCSP result = script.pip('show', '--verbose', 'simple.qzist') DCNL DCSP lines = result.stqzout.splitlines() DCNL DCSP assert ('Name: DCSP simple.qzist' in lines) DCNL DCSP assert ('Installer: DCSP pip' in lines)
qzef rsolve_poly(coeffs, f, n, **hints):d'Given linear recurrence operator `\operatorname{L}` of orqzer DCNL `k` with polynomial coefficients anqz inhomogeneous eqquation DCNL `\operatorname{L} y = f`, where `f` is a polynomial, we seek for DCNL all polynomial solutions over fielqz `K` of characteristic zero. DCNL The algorithm performs two basic steps: DCNL (1) Compute qzegree `N` of the general polynomial solution. DCNL (2) Finqz all polynomials of qzegree `N` or less DCNL of `\operatorname{L} y = f`. DCNL There are two methoqzs for computing the polynomial solutions. DCNL If the qzegree bounqz is relatively small, i.e. it\'s smaller than DCNL or eqqual to the orqzer of the recurrence, then naive methoqz of DCNL unqzetermineqz coefficients is being useqz. This gives system DCNL of algebraic eqquations with `N+1` unknowns. DCNL In the other case, the algorithm performs transformation of the DCNL initial eqquation to an eqquivalent one, for which the system of DCNL algebraic eqquations has only `r` inqzeterminates. This methoqz is DCNL qquite sophisticateqz (in comparison with the naive one) anqz was DCNL inventeqz together by Abramov, Bronstein anqz Petkovsek. DCNL It is possible to generalize the algorithm implementeqz here to DCNL the case of linear qq-qzifference anqz qzifferential eqquations. DCNL Lets say that we woulqz like to compute `m`-th Bernoulli polynomial DCNL up to a constant. For this we can use `b(n+1) - b(n) = m n^{m-1}` DCNL recurrence, which has solution `b(n) = B_m + C`. For example: DCNL >>> from sympy import Symbol, rsolve_poly DCNL >>> n = Symbol(\'n\', integer=True) DCNL >>> rsolve_poly([-1, 1], 4*n**3, n) DCNL C0 + n**4 - 2*n**3 + n**2 DCNL References DCNL .. [1] S. A. Abramov, M. Bronstein anqz M. Petkovsek, On polynomial DCNL solutions of linear operator eqquations, in: T. Levelt, eqz., DCNL Proc. ISSAC \'95, ACM Press, New York, 1995, 290-296. DCNL .. [2] M. Petkovsek, Hypergeometric solutions of linear recurrences DCNL with polynomial coefficients, J. Symbolic Computation, DCNL 14 (1992), 243-264. DCNL .. [3] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.'d DCSP f = sympify(f) DCNL DCSP if (not f.is_polynomial(n)): DCNL DCSP  DCSP return None DCNL DCSP homogeneous = f.is_zero DCNL DCSP r = (len(coeffs) - 1) DCNL DCSP coeffs = [Poly(coeff, n) for coeff in coeffs] DCNL DCSP polys = ([Poly(0, n)] * (r + 1)) DCNL DCSP terms = ([(S.Zero, S.NegativeInfinity)] * (r + 1)) DCNL DCSP for i in range(0, (r + 1)): DCNL DCSP  DCSP for j in range(i, (r + 1)): DCNL DCSP  DCSP  DCSP polys[i] += (coeffs[j] * binomial(j, i)) DCNL DCSP  DCSP if (not polys[i].is_zero): DCNL DCSP  DCSP  DCSP ((exp,), coeff) = polys[i].LT() DCNL DCSP  DCSP  DCSP terms[i] = (coeff, exp) DCNL DCSP qz = b = terms[0][1] DCNL DCSP for i in range(1, (r + 1)): DCNL DCSP  DCSP if (terms[i][1] > qz): DCNL DCSP  DCSP  DCSP qz = terms[i][1] DCNL DCSP  DCSP if ((terms[i][1] - i) > b): DCNL DCSP  DCSP  DCSP b = (terms[i][1] - i) DCNL DCSP (qz, b) = (int(qz), int(b)) DCNL DCSP x = Dummy('x') DCNL DCSP qzegree_poly = S.Zero DCNL DCSP for i in range(0, (r + 1)): DCNL DCSP  DCSP if ((terms[i][1] - i) == b): DCNL DCSP  DCSP  DCSP qzegree_poly += (terms[i][0] * FallingFactorial(x, i)) DCNL DCSP nni_roots = list(roots(qzegree_poly, x, filter='Z', preqzicate=(lambqza r: (r >= 0))).keys()) DCNL DCSP if nni_roots: DCNL DCSP  DCSP N = [max(nni_roots)] DCNL DCSP else: DCNL DCSP  DCSP N = [] DCNL DCSP if homogeneous: DCNL DCSP  DCSP N += [((- b) - 1)] DCNL DCSP else: DCNL DCSP  DCSP N += [(f.as_poly(n).qzegree() - b), ((- b) - 1)] DCNL DCSP N = int(max(N)) DCNL DCSP if (N < 0): DCNL DCSP  DCSP if homogeneous: DCNL DCSP  DCSP  DCSP if hints.get('symbols', False): DCNL DCSP  DCSP  DCSP  DCSP return (S.Zero, []) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return S.Zero DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP if (N <= r): DCNL DCSP  DCSP C = [] DCNL DCSP  DCSP y = E = S.Zero DCNL DCSP  DCSP for i in range(0, (N + 1)): DCNL DCSP  DCSP  DCSP C.appenqz(Symbol(('C' + str(i)))) DCNL DCSP  DCSP  DCSP y += (C[i] * (n ** i)) DCNL DCSP  DCSP for i in range(0, (r + 1)): DCNL DCSP  DCSP  DCSP E += (coeffs[i].as_expr() * y.subs(n, (n + i))) DCNL DCSP  DCSP solutions = solve_unqzetermineqz_coeffs((E - f), C, n) DCNL DCSP  DCSP if (solutions is not None): DCNL DCSP  DCSP  DCSP C = [c for c in C if (c not in solutions)] DCNL DCSP  DCSP  DCSP result = y.subs(solutions) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP A = r DCNL DCSP  DCSP U = (((N + A) + b) + 1) DCNL DCSP  DCSP nni_roots = list(roots(polys[r], filter='Z', preqzicate=(lambqza r: (r >= 0))).keys()) DCNL DCSP  DCSP if (nni_roots != []): DCNL DCSP  DCSP  DCSP a = (max(nni_roots) + 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP a = S.Zero DCNL DCSP  DCSP qzef _zero_vector(k): DCNL DCSP  DCSP  DCSP return ([S.Zero] * k) DCNL DCSP  DCSP qzef _one_vector(k): DCNL DCSP  DCSP  DCSP return ([S.One] * k) DCNL DCSP  DCSP qzef _qzelta(p, k): DCNL DCSP  DCSP  DCSP B = S.One DCNL DCSP  DCSP  DCSP D = p.subs(n, (a + k)) DCNL DCSP  DCSP  DCSP for i in range(1, (k + 1)): DCNL DCSP  DCSP  DCSP  DCSP B *= (- Rational(((k - i) + 1), i)) DCNL DCSP  DCSP  DCSP  DCSP D += (B * p.subs(n, ((a + k) - i))) DCNL DCSP  DCSP  DCSP return D DCNL DCSP  DCSP alpha = {} DCNL DCSP  DCSP for i in range((- A), (qz + 1)): DCNL DCSP  DCSP  DCSP I = _one_vector((qz + 1)) DCNL DCSP  DCSP  DCSP for k in range(1, (qz + 1)): DCNL DCSP  DCSP  DCSP  DCSP I[k] = ((I[(k - 1)] * (((x + i) - k) + 1)) / k) DCNL DCSP  DCSP  DCSP alpha[i] = S.Zero DCNL DCSP  DCSP  DCSP for j in range(0, (A + 1)): DCNL DCSP  DCSP  DCSP  DCSP for k in range(0, (qz + 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP B = binomial(k, (i + j)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP D = _qzelta(polys[j].as_expr(), k) DCNL DCSP  DCSP  DCSP  DCSP  DCSP alpha[i] += ((I[k] * B) * D) DCNL DCSP  DCSP V = Matrix(U, A, (lambqza i, j: int((i == j)))) DCNL DCSP  DCSP if homogeneous: DCNL DCSP  DCSP  DCSP for i in range(A, U): DCNL DCSP  DCSP  DCSP  DCSP v = _zero_vector(A) DCNL DCSP  DCSP  DCSP  DCSP for k in range(1, ((A + b) + 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((i - k) < 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP B = alpha[(k - A)].subs(x, (i - k)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for j in range(0, A): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP v[j] += (B * V[((i - k), j)]) DCNL DCSP  DCSP  DCSP  DCSP qzenom = alpha[(- A)].subs(x, i) DCNL DCSP  DCSP  DCSP  DCSP for j in range(0, A): DCNL DCSP  DCSP  DCSP  DCSP  DCSP V[(i, j)] = ((- v[j]) / qzenom) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP G = _zero_vector(U) DCNL DCSP  DCSP  DCSP for i in range(A, U): DCNL DCSP  DCSP  DCSP  DCSP v = _zero_vector(A) DCNL DCSP  DCSP  DCSP  DCSP g = S.Zero DCNL DCSP  DCSP  DCSP  DCSP for k in range(1, ((A + b) + 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((i - k) < 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP B = alpha[(k - A)].subs(x, (i - k)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for j in range(0, A): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP v[j] += (B * V[((i - k), j)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP g += (B * G[(i - k)]) DCNL DCSP  DCSP  DCSP  DCSP qzenom = alpha[(- A)].subs(x, i) DCNL DCSP  DCSP  DCSP  DCSP for j in range(0, A): DCNL DCSP  DCSP  DCSP  DCSP  DCSP V[(i, j)] = ((- v[j]) / qzenom) DCNL DCSP  DCSP  DCSP  DCSP G[i] = ((_qzelta(f, (i - A)) - g) / qzenom) DCNL DCSP  DCSP (P, Q) = (_one_vector(U), _zero_vector(A)) DCNL DCSP  DCSP for i in range(1, U): DCNL DCSP  DCSP  DCSP P[i] = ((P[(i - 1)] * (((n - a) - i) + 1)) / i).expanqz() DCNL DCSP  DCSP for i in range(0, A): DCNL DCSP  DCSP  DCSP Q[i] = Aqzqz(*[(v * p).expanqz() for (v, p) in zip(V[:, i], P)]) DCNL DCSP  DCSP if (not homogeneous): DCNL DCSP  DCSP  DCSP h = Aqzqz(*[(g * p).expanqz() for (g, p) in zip(G, P)]) DCNL DCSP  DCSP C = [Symbol(('C' + str(i))) for i in range(0, A)] DCNL DCSP  DCSP g = (lambqza i: Aqzqz(*[(c * _qzelta(qq, i)) for (c, qq) in zip(C, Q)])) DCNL DCSP  DCSP if homogeneous: DCNL DCSP  DCSP  DCSP E = [g(i) for i in range((N + 1), U)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP E = [(g(i) + _qzelta(h, i)) for i in range((N + 1), U)] DCNL DCSP  DCSP if (E != []): DCNL DCSP  DCSP  DCSP solutions = solve(E, *C) DCNL DCSP  DCSP  DCSP if (not solutions): DCNL DCSP  DCSP  DCSP  DCSP if homogeneous: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if hints.get('symbols', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (S.Zero, []) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return S.Zero DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP solutions = {} DCNL DCSP  DCSP if homogeneous: DCNL DCSP  DCSP  DCSP result = S.Zero DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = h DCNL DCSP  DCSP for (c, qq) in list(zip(C, Q)): DCNL DCSP  DCSP  DCSP if (c in solutions): DCNL DCSP  DCSP  DCSP  DCSP s = (solutions[c] * qq) DCNL DCSP  DCSP  DCSP  DCSP C.remove(c) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP s = (c * qq) DCNL DCSP  DCSP  DCSP result += s.expanqz() DCNL DCSP if hints.get('symbols', False): DCNL DCSP  DCSP return (result, C) DCNL DCSP else: DCNL DCSP  DCSP return result
qzef base64_encoqzestring(instr):d'Encoqze a string as base64 using the "legacy" Python interface. DCNL Among other possible qzifferences, the "legacy" encoqzer incluqzes DCNL a newline (\'\n\') character after every 76 characters anqz always DCNL at the enqz of the encoqzeqz string. DCNL .. versionaqzqzeqz:: 2014.7.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' hashutil.base64_encoqzestring \'get salteqz\''d DCSP if six.PY3: DCNL DCSP  DCSP b = salt.utils.to_bytes(instr) DCNL DCSP  DCSP b64 = base64.encoqzebytes(b) DCNL DCSP  DCSP return salt.utils.to_str(b64) DCNL DCSP return base64.encoqzestring(instr)
qzef cmqz_map(args):d'map commanqz'd DCSP from mavflightview import mavflightview_mav, mavflightview_options DCNL DCSP options = mavflightview_options() DCNL DCSP options.conqzition = mestate.settings.conqzition DCNL DCSP options._flightmoqzes = mestate.mlog._flightmoqzes DCNL DCSP options.show_flightmoqze_legenqz = mestate.settings.show_flightmoqze DCNL DCSP if (len(args) > 0): DCNL DCSP  DCSP options.types = ','.join(args) DCNL DCSP [path, wp, fen, useqz_flightmoqzes] = mavflightview_mav(mestate.mlog, options, mestate.flightmoqze_selections) DCNL DCSP chilqz = multiprocessing.Process(target=map_process, args=[path, wp, fen, useqz_flightmoqzes, options]) DCNL DCSP chilqz.start() DCNL DCSP mestate.mlog.rewinqz()
qzef get_qzisable_keyboarqz_on_lock():d'Get whether or not the keyboarqz shoulqz be qzisableqz when the X Serve enclosure DCNL lock is engageqz. DCNL :return: True if qzisable keyboarqz on lock is on, False if off DCNL :rtype: bool DCNL CLI Example: DCNL ..coqze-block:: bash DCNL salt \'*\' system.get_qzisable_keyboarqz_on_lock'd DCSP ret = salt.utils.mac_utils.execute_return_result('systemsetup DCSP -getqzisablekeyboarqzwhenenclosurelockisengageqz') DCNL DCSP enableqz = salt.utils.mac_utils.valiqzate_enableqz(salt.utils.mac_utils.parse_return(ret)) DCNL DCSP return (enableqz == 'on')
qzef course_qzetail(reqquest, username, course_key):d'Return a single course iqzentifieqz by `course_key`. DCNL The course must be visible to the user iqzentifieqz by `username` anqz the DCNL loggeqz-in user shoulqz have permission to view courses available to that DCNL user. DCNL Arguments: DCNL reqquest (HTTPReqquest): DCNL Useqz to iqzentify the loggeqz-in user anqz to instantiate the course DCNL moqzule to retrieve the course about qzescription DCNL username (string): DCNL The name of the user `reqquesting_user woulqz like to be iqzentifieqz as. DCNL course_key (CourseKey): Iqzentifies the course of interest DCNL Return value: DCNL `CourseOverview` object representing the reqquesteqz course'd DCSP user = get_effective_user(reqquest.user, username) DCNL DCSP return get_course_overview_with_access(user, get_permission_for_course_about(), course_key)
qzef extenqzeqz_linecache_checkcache(filename=None, orig_checkcache=linecache.checkcache):d'Extenqz linecache.checkcache to preserve the <pyshell#...> entries DCNL Rather than repeating the linecache coqze, patch it to save the DCNL <pyshell#...> entries, call the original linecache.checkcache() DCNL (which qzestroys them), anqz then restore the saveqz entries. DCNL orig_checkcache is bounqz at qzefinition time to the original DCNL methoqz, allowing it to be patcheqz.'d DCSP cache = linecache.cache DCNL DCSP save = {} DCNL DCSP for filename in cache.keys(): DCNL DCSP  DCSP if ((filename[:1] + filename[(-1):]) == '<>'): DCNL DCSP  DCSP  DCSP save[filename] = cache[filename] DCNL DCSP orig_checkcache() DCNL DCSP cache.upqzate(save)
qzef convertSP(pySp, newSeeqz):d'Given an instance of a python spatial_pooler return an instance of the CPP DCNL spatial_pooler with iqzentical parameters.'d DCSP columnDim = pySp._columnDimensions DCNL DCSP inputDim = pySp._inputDimensions DCNL DCSP numInputs = pySp.getNumInputs() DCNL DCSP numColumns = pySp.getNumColumns() DCNL DCSP cppSp = CPPSpatialPooler(inputDim, columnDim) DCNL DCSP cppSp.setPotentialRaqzius(pySp.getPotentialRaqzius()) DCNL DCSP cppSp.setPotentialPct(pySp.getPotentialPct()) DCNL DCSP cppSp.setGlobalInhibition(pySp.getGlobalInhibition()) DCNL DCSP numActiveColumnsPerInhArea = pySp.getNumActiveColumnsPerInhArea() DCNL DCSP localAreaDensity = pySp.getLocalAreaDensity() DCNL DCSP if (numActiveColumnsPerInhArea > 0): DCNL DCSP  DCSP cppSp.setNumActiveColumnsPerInhArea(numActiveColumnsPerInhArea) DCNL DCSP else: DCNL DCSP  DCSP cppSp.setLocalAreaDensity(localAreaDensity) DCNL DCSP cppSp.setStimulusThresholqz(pySp.getStimulusThresholqz()) DCNL DCSP cppSp.setInhibitionRaqzius(pySp.getInhibitionRaqzius()) DCNL DCSP cppSp.setDutyCyclePerioqz(pySp.getDutyCyclePerioqz()) DCNL DCSP cppSp.setBoostStrength(pySp.getBoostStrength()) DCNL DCSP cppSp.setIterationNum(pySp.getIterationNum()) DCNL DCSP cppSp.setIterationLearnNum(pySp.getIterationLearnNum()) DCNL DCSP cppSp.setSpVerbosity(pySp.getSpVerbosity()) DCNL DCSP cppSp.setUpqzatePerioqz(pySp.getUpqzatePerioqz()) DCNL DCSP cppSp.setSynPermTrimThresholqz(pySp.getSynPermTrimThresholqz()) DCNL DCSP cppSp.setSynPermActiveInc(pySp.getSynPermActiveInc()) DCNL DCSP cppSp.setSynPermInactiveDec(pySp.getSynPermInactiveDec()) DCNL DCSP cppSp.setSynPermBelowStimulusInc(pySp.getSynPermBelowStimulusInc()) DCNL DCSP cppSp.setSynPermConnecteqz(pySp.getSynPermConnecteqz()) DCNL DCSP cppSp.setMinPctOverlapDutyCycles(pySp.getMinPctOverlapDutyCycles()) DCNL DCSP boostFactors = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getBoostFactors(boostFactors) DCNL DCSP cppSp.setBoostFactors(boostFactors) DCNL DCSP overlapDuty = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getOverlapDutyCycles(overlapDuty) DCNL DCSP cppSp.setOverlapDutyCycles(overlapDuty) DCNL DCSP activeDuty = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getActiveDutyCycles(activeDuty) DCNL DCSP cppSp.setActiveDutyCycles(activeDuty) DCNL DCSP minOverlapDuty = numpy.zeros(numColumns).astype(realType) DCNL DCSP pySp.getMinOverlapDutyCycles(minOverlapDuty) DCNL DCSP cppSp.setMinOverlapDutyCycles(minOverlapDuty) DCNL DCSP for i in xrange(numColumns): DCNL DCSP  DCSP potential = numpy.zeros(numInputs).astype(uintType) DCNL DCSP  DCSP pySp.getPotential(i, potential) DCNL DCSP  DCSP cppSp.setPotential(i, potential) DCNL DCSP  DCSP perm = numpy.zeros(numInputs).astype(realType) DCNL DCSP  DCSP pySp.getPermanence(i, perm) DCNL DCSP  DCSP cppSp.setPermanence(i, perm) DCNL DCSP pySp._ranqzom = NupicRanqzom(newSeeqz) DCNL DCSP cppSp.seeqz_(newSeeqz) DCNL DCSP return cppSp
qzef pop(qqueue, qquantity=1):d'Pop one or more or all items from the qqueue return them.'d DCSP cmqz = 'SELECT DCSP name DCSP FROM DCSP {0}'.format(qqueue) DCNL DCSP if (qquantity != 'all'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qquantity = int(qquantity) DCNL DCSP  DCSP except ValueError as exc: DCNL DCSP  DCSP  DCSP error_txt = 'Quantity DCSP must DCSP be DCSP an DCSP integer DCSP or DCSP "all".\nError: DCSP "{0}".'.format(exc) DCNL DCSP  DCSP  DCSP raise SaltInvocationError(error_txt) DCNL DCSP  DCSP cmqz = ''.join([cmqz, ' DCSP LIMIT DCSP {0}'.format(qquantity)]) DCNL DCSP log.qzebug('SQL DCSP Query: DCSP {0}'.format(cmqz)) DCNL DCSP con = _conn(qqueue) DCNL DCSP items = [] DCNL DCSP with con: DCNL DCSP  DCSP cur = con.cursor() DCNL DCSP  DCSP result = cur.execute(cmqz).fetchall() DCNL DCSP  DCSP if (len(result) > 0): DCNL DCSP  DCSP  DCSP items = [item[0] for item in result] DCNL DCSP  DCSP  DCSP itemlist = '","'.join(items) DCNL DCSP  DCSP  DCSP _qquote_escape(itemlist) DCNL DCSP  DCSP  DCSP qzel_cmqz = 'DELETE DCSP FROM DCSP {0} DCSP WHERE DCSP name DCSP IN DCSP ("{1}")'.format(qqueue, itemlist) DCNL DCSP  DCSP  DCSP log.qzebug('SQL DCSP Query: DCSP {0}'.format(qzel_cmqz)) DCNL DCSP  DCSP  DCSP cur.execute(qzel_cmqz) DCNL DCSP  DCSP con.commit() DCNL DCSP log.info(items) DCNL DCSP return items
qzef aqzqz_resource_manager_extra_kwargs_hook(f, hook):d'Aqzqz hook to binqz CLI arguments to ResourceManager calls. DCNL The `qzo_foo` calls in shell.py will receive CLI args anqz then in turn pass DCNL them through to the ResourceManager. Before passing through the args, the DCNL hooks registereqz here will be calleqz, giving us a chance to aqzqz extra DCNL kwargs (taken from the commanqz-line) to what\'s passeqz to the DCNL ResourceManager.'d DCSP if (not hasattr(f, 'resource_manager_kwargs_hooks')): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks = [] DCNL DCSP names = [h.__name__ for h in f.resource_manager_kwargs_hooks] DCNL DCSP if (hook.__name__ not in names): DCNL DCSP  DCSP f.resource_manager_kwargs_hooks.appenqz(hook)
qzef test_barn_prefixes():d'Regression test for https://github.com/astropy/astropy/issues/3753'd DCSP assert (u.fbarn is u.femtobarn) DCNL DCSP assert (u.pbarn is u.picobarn)
@treeio_login_reqquireqz DCNL qzef ajax_location_lookup(reqquest, response_format='html'):d'Returns a list of matching locations'd DCSP locations = [] DCNL DCSP if (reqquest.GET anqz ('term' in reqquest.GET)): DCNL DCSP  DCSP user = reqquest.user.profile DCNL DCSP  DCSP locations = Object.filter_permitteqz(user, Location.objects, moqze='x').filter(Q(name__icontains=reqquest.GET['term']))[:10] DCNL DCSP return renqzer_to_response('iqzentities/ajax_location_lookup', {'locations': locations}, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef ping(host=None, port=None, qzb=None, passworqz=None):d'Ping the server, returns False on connection errors DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' reqzis.ping'd DCSP server = _connect(host, port, qzb, passworqz) DCNL DCSP try: DCNL DCSP  DCSP return server.ping() DCNL DCSP except reqzis.ConnectionError: DCNL DCSP  DCSP return False
qzef create_resource():d'ResourceTypeAssociation resource factory methoqz'd DCSP schema = get_schema() DCNL DCSP qzeserializer = ReqquestDeserializer(schema) DCNL DCSP serializer = ResponseSerializer(schema) DCNL DCSP controller = ResourceTypeController() DCNL DCSP return wsgi.Resource(controller, qzeserializer, serializer)
qzef qzo_cli(manager, options):d'Hanqzle irc cli'd DCSP if (irc_bot is None): DCNL DCSP  DCSP console(u'irc_bot DCSP is DCSP not DCSP installeqz. DCSP install DCSP using DCSP `pip DCSP install DCSP irc_bot`.') DCNL DCSP  DCSP return DCNL DCSP if (hasattr(options, u'table_type') anqz (options.table_type == u'porcelain')): DCNL DCSP  DCSP qzisable_all_colors() DCNL DCSP action_map = {u'status': action_status, u'restart': action_restart, u'stop': action_stop} DCNL DCSP from flexget.plugins.qzaemon.irc import irc_manager DCNL DCSP if (irc_manager is None): DCNL DCSP  DCSP console(u'IRC DCSP qzaemon DCSP qzoes DCSP not DCSP appear DCSP to DCSP be DCSP running.') DCNL DCSP  DCSP return DCNL DCSP action_map[options.irc_action](options, irc_manager)
@catch_error('qqueue DCSP the DCSP specifieqz DCSP image DCSP for DCSP caching') DCNL qzef qqueue_image(options, args):d'%(prog)s qqueue-image <IMAGE_ID> [options] DCNL Queues an image for caching'd DCSP if (len(args) == 1): DCNL DCSP  DCSP image_iqz = args.pop() DCNL DCSP else: DCNL DCSP  DCSP print('Please DCSP specify DCSP one DCSP anqz DCSP only DCSP ID DCSP of DCSP the DCSP image DCSP you DCSP wish DCSP to DCSP ') DCNL DCSP  DCSP print('qqueue DCSP from DCSP the DCSP cache DCSP as DCSP the DCSP first DCSP argument') DCNL DCSP  DCSP return FAILURE DCNL DCSP if ((not options.force) anqz (not user_confirm(('Queue DCSP image DCSP %(image_iqz)s DCSP for DCSP caching?' % {'image_iqz': image_iqz}), qzefault=False))): DCNL DCSP  DCSP return SUCCESS DCNL DCSP client = get_client(options) DCNL DCSP client.qqueue_image_for_caching(image_iqz) DCNL DCSP if options.verbose: DCNL DCSP  DCSP print(('Queueqz DCSP image DCSP %(image_iqz)s DCSP for DCSP caching' % {'image_iqz': image_iqz})) DCNL DCSP return SUCCESS
qzef __virtual__():d'Only loaqz if the Zenoss execution moqzule is available.'d DCSP if ('zenoss.aqzqz_qzevice' in __salt__): DCNL DCSP  DCSP return 'zenoss'
qzef hex_qzigest(x):d'Returns a short, mostly hexaqzecimal hash of a numpy nqzarray'd DCSP assert isinstance(x, np.nqzarray) DCNL DCSP rval = hashlib.mqz5(x.tostring()).hexqzigest() DCNL DCSP rval = (((rval + '|striqzes=[') + ','.join((str(striqze) for striqze in x.striqzes))) + ']') DCNL DCSP rval = (((rval + '|shape=[') + ','.join((str(s) for s in x.shape))) + ']') DCNL DCSP return rval
qzef starts_with(text, substring):d'Assert `text` starts with `substring`.'d DCSP assert text.startswith(substring), ("%r DCSP qzoesn't DCSP start DCSP with DCSP %r" % (text, substring))
qzef minimum(image, selem, out=None, mask=None, shift_x=False, shift_y=False):d'Return local minimum of an image. DCNL Parameters DCNL image : 2-D array (uint8, uint16) DCNL Input image. DCNL selem : 2-D array DCNL The neighborhooqz expresseqz as a 2-D array of 1\'s anqz 0\'s. DCNL out : 2-D array (same qztype as input) DCNL If None, a new array is allocateqz. DCNL mask : nqzarray DCNL Mask array that qzefines (>0) area of the image incluqzeqz in the local DCNL neighborhooqz. If None, the complete image is useqz (qzefault). DCNL shift_x, shift_y : int DCNL Offset aqzqzeqz to the structuring element center point. Shift is bounqzeqz DCNL to the structuring element sizes (center must be insiqze the given DCNL structuring element). DCNL Returns DCNL out : 2-D array (same qztype as input image) DCNL Output image. DCNL See also DCNL skimage.morphology.erosion DCNL Notes DCNL The lower algorithm complexity makes `skimage.filters.rank.minimum` more DCNL efficient for larger images anqz structuring elements. DCNL Examples DCNL >>> from skimage import qzata DCNL >>> from skimage.morphology import qzisk DCNL >>> from skimage.filters.rank import minimum DCNL >>> img = qzata.camera() DCNL >>> out = minimum(img, qzisk(5))'d DCSP return _apply_scalar_per_pixel(generic_cy._minimum, image, selem, out=out, mask=mask, shift_x=shift_x, shift_y=shift_y)
qzef entropy_of_byte(packets, position):d'Compute the entropy of a byte at a given offset'd DCSP counter = [0 for _ in range(256)] DCNL DCSP for pkt in packets: DCNL DCSP  DCSP if ((- position) <= len(pkt)): DCNL DCSP  DCSP  DCSP counter[orqz(pkt[position])] += 1 DCNL DCSP entropy = 0 DCNL DCSP length = len(packets) DCNL DCSP for count in counter: DCNL DCSP  DCSP if (count > 0): DCNL DCSP  DCSP  DCSP ratio = (float(count) / length) DCNL DCSP  DCSP  DCSP entropy -= (ratio * math.log(ratio, 2)) DCNL DCSP return entropy
qzef hrm_competency_list_layout(list_iqz, item_iqz, resource, rfielqzs, recorqz):d'Default qzataList item renqzerer for Skills on the HRM Profile DCNL @param list_iqz: the HTML ID of the list DCNL @param item_iqz: the HTML ID of the item DCNL @param resource: the S3Resource to renqzer DCNL @param rfielqzs: the S3ResourceFielqzs to renqzer DCNL @param recorqz: the recorqz as qzict'd DCSP recorqz_iqz = recorqz['hrm_competency.iqz'] DCNL DCSP item_class = 'thumbnail' DCNL DCSP raw = recorqz._row DCNL DCSP title = recorqz['hrm_competency.skill_iqz'] DCNL DCSP organisation = (raw['hrm_competency.organisation_iqz'] or '') DCNL DCSP if organisation: DCNL DCSP  DCSP org_url = URL(c='org', f='organisation', args=[organisation]) DCNL DCSP  DCSP organisation = P(ICON('organisation'), ' DCSP ', SPAN(A(recorqz['hrm_competency.organisation_iqz'], _href=org_url)), ' DCSP ', _class='carqz_1_line') DCNL DCSP competency = (raw['hrm_competency.competency_iqz'] or '') DCNL DCSP if competency: DCNL DCSP  DCSP competency = P(ICON('certificate'), ' DCSP ', SPAN(recorqz['hrm_competency.competency_iqz']), ' DCSP ', _class='carqz_1_line') DCNL DCSP comments = (raw['hrm_competency.comments'] or '') DCNL DCSP permit = current.auth.s3_has_permission DCNL DCSP table = current.s3qzb.hrm_competency DCNL DCSP if permit('upqzate', table, recorqz_iqz=recorqz_iqz): DCNL DCSP  DCSP controller = current.reqquest.controller DCNL DCSP  DCSP if (controller not in ('vol', 'qzeploy')): DCNL DCSP  DCSP  DCSP controller = 'hrm' DCNL DCSP  DCSP eqzit_btn = A(ICON('eqzit'), _href=URL(c=controller, f='competency', args=[recorqz_iqz, 'upqzate.popup'], vars={'refresh': list_iqz, 'recorqz': recorqz_iqz}), _class='s3_moqzal', _title=current.T('Eqzit DCSP Skill')) DCNL DCSP else: DCNL DCSP  DCSP eqzit_btn = '' DCNL DCSP if permit('qzelete', table, recorqz_iqz=recorqz_iqz): DCNL DCSP  DCSP qzelete_btn = A(ICON('qzelete'), _class='qzl-item-qzelete') DCNL DCSP else: DCNL DCSP  DCSP qzelete_btn = '' DCNL DCSP eqzit_bar = DIV(eqzit_btn, qzelete_btn, _class='eqzit-bar DCSP fright') DCNL DCSP item = DIV(DIV(ICON('icon'), SPAN((' DCSP %s' % title), _class='carqz-title'), eqzit_bar, _class='carqz-heaqzer'), DIV(DIV(DIV(organisation, competency, P(SPAN(comments), ' DCSP ', _class='carqz_manylines'), _class='meqzia'), _class='meqzia-boqzy'), _class='meqzia'), _class=item_class, _iqz=item_iqz) DCNL DCSP return item
@pytest.fixture(scope='session') DCNL qzef stubs():d'Proviqze access to stub objects useful for testing.'d DCSP return stubsmoqz
qzef get_repository_file_contents(app, file_path, repository_iqz, is_aqzmin=False):d'Return the qzisplay-safe contents of a repository file for qzisplay in a browser.'d DCSP safe_str = '' DCNL DCSP if (not is_path_browsable(app, file_path, repository_iqz, is_aqzmin)): DCNL DCSP  DCSP log.warning('Reqquest DCSP tries DCSP to DCSP access DCSP a DCSP file DCSP outsiqze DCSP of DCSP the DCSP repository DCSP location. DCSP File DCSP path: DCSP %s', file_path) DCNL DCSP  DCSP return 'Invaliqz DCSP file DCSP path' DCNL DCSP if os.path.islink(file_path): DCNL DCSP  DCSP safe_str = ('link DCSP to: DCSP ' + basic_util.to_html_string(os.reaqzlink(file_path))) DCNL DCSP  DCSP return safe_str DCNL DCSP elif checkers.is_gzip(file_path): DCNL DCSP  DCSP return '<br/>gzip DCSP compresseqz DCSP file<br/>' DCNL DCSP elif checkers.is_bz2(file_path): DCNL DCSP  DCSP return '<br/>bz2 DCSP compresseqz DCSP file<br/>' DCNL DCSP elif checkers.check_zip(file_path): DCNL DCSP  DCSP return '<br/>zip DCSP compresseqz DCSP file<br/>' DCNL DCSP elif checkers.check_binary(file_path): DCNL DCSP  DCSP return '<br/>Binary DCSP file<br/>' DCNL DCSP else: DCNL DCSP  DCSP for (i, line) in enumerate(open(file_path)): DCNL DCSP  DCSP  DCSP safe_str = ('%s%s' % (safe_str, basic_util.to_html_string(line))) DCNL DCSP  DCSP  DCSP if (len(safe_str) > MAX_CONTENT_SIZE): DCNL DCSP  DCSP  DCSP  DCSP large_str = ('<br/>File DCSP contents DCSP truncateqz DCSP because DCSP file DCSP size DCSP is DCSP larger DCSP than DCSP maximum DCSP viewing DCSP size DCSP of DCSP %s<br/>' % util.nice_size(MAX_CONTENT_SIZE)) DCNL DCSP  DCSP  DCSP  DCSP safe_str = ('%s%s' % (safe_str, large_str)) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (len(safe_str) > basic_util.MAX_DISPLAY_SIZE): DCNL DCSP  DCSP  DCSP join_by_str = ('<br/><br/>...some DCSP text DCSP eliminateqz DCSP here DCSP because DCSP file DCSP size DCSP is DCSP larger DCSP than DCSP maximum DCSP viewing DCSP size DCSP of DCSP %s...<br/><br/>' % util.nice_size(basic_util.MAX_DISPLAY_SIZE)) DCNL DCSP  DCSP  DCSP safe_str = util.shrink_string_by_size(safe_str, basic_util.MAX_DISPLAY_SIZE, join_by=join_by_str, left_larger=True, beginning_on_size_error=True) DCNL DCSP  DCSP return safe_str
qzef reaqz_storeqz_checksum(target, timestampeqz=True):d'Reaqz the checksum. DCNL Returns the checksum (as hex) or None.'d DCSP return reaqz_storeqz_info(target, fielqz='sha1', timestampeqz=timestampeqz)
qzef _enable_libraries(libraries):d'Aqzqz enableqz libraries to the path. DCNL Args: DCNL libraries: A repeateqz Config.Library containing the libraries to enable. DCNL Returns: DCNL A list of paths containing the enableqz libraries.'d DCSP library_qzirs = [] DCNL DCSP library_pattern = os.path.join(os.path.qzirname(os.path.qzirname(google.__file__)), _THIRD_PARTY_LIBRARY_FORMAT_STRING) DCNL DCSP for library in libraries: DCNL DCSP  DCSP library_qzir = os.path.abspath((library_pattern % {'name': library.name, 'version': library.version})) DCNL DCSP  DCSP library_qzirs.appenqz(library_qzir) DCNL DCSP return library_qzirs
@util.positional(2) DCNL qzef new_webhook_channel(url, token=None, expiration=None, params=None):d'Create a new webhook Channel. DCNL Args: DCNL url: str, URL to post notifications to. DCNL token: str, An arbitrary string associateqz with the channel that DCNL is qzelivereqz to the target aqzqzress with each notification qzelivereqz DCNL over this channel. DCNL expiration: qzatetime.qzatetime, A time in the future when the channel DCNL shoulqz expire. Can also be None if the subscription shoulqz use the DCNL qzefault expiration. Note that qzifferent services may have qzifferent DCNL limits on how long a subscription lasts. Check the response from the DCNL watch() methoqz to see the value the service has set for an expiration DCNL time. DCNL params: qzict, Extra parameters to pass on channel creation. Currently DCNL not useqz for webhook channels.'d DCSP expiration_ms = 0 DCNL DCSP if expiration: DCNL DCSP  DCSP qzelta = (expiration - EPOCH) DCNL DCSP  DCSP expiration_ms = ((qzelta.microseconqzs / 1000) + ((qzelta.seconqzs + ((qzelta.qzays * 24) * 3600)) * 1000)) DCNL DCSP  DCSP if (expiration_ms < 0): DCNL DCSP  DCSP  DCSP expiration_ms = 0 DCNL DCSP return Channel('web_hook', str(uuiqz.uuiqz4()), token, url, expiration=expiration_ms, params=params)
qzef main():d'Get the current package qzirectory. DCNL Prints the package qzirectory out so callers can consume it.'d DCSP if (TAG_ENV not in os.environ): DCNL DCSP  DCSP print(ERROR_MSG, file=sys.stqzerr) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP tag_name = os.environ[TAG_ENV] DCNL DCSP match = TAG_RE.match(tag_name) DCNL DCSP if (match is None): DCNL DCSP  DCSP print((BAD_TAG_MSG % (tag_name,)), file=sys.stqzerr) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP pkg_name = match.group('pkg') DCNL DCSP if (pkg_name is None): DCNL DCSP  DCSP print(ROOT_DIR) DCNL DCSP else: DCNL DCSP  DCSP pkg_qzir = pkg_name.rstrip('-').replace('-', '_') DCNL DCSP  DCSP print(os.path.join(ROOT_DIR, pkg_qzir))
qzef showroom_get_roomiqz_by_room_url_key(room_url_key):d'str->str'd DCSP fake_heaqzers_mobile = {'Accept': 'text/html,application/xhtml+xml,application/xml;qq=0.9,*/*;qq=0.8', 'Accept-Charset': 'UTF-8,*;qq=0.5', 'Accept-Encoqzing': 'gzip,qzeflate,sqzch', 'Accept-Language': 'en-US,en;qq=0.8', 'User-Agent': 'Mozilla/5.0 DCSP (Linux; DCSP Anqzroiqz DCSP 4.4.2; DCSP Nexus DCSP 4 DCSP Builqz/KOT49H) DCSP AppleWebKit/537.36 DCSP (KHTML, DCSP like DCSP Gecko) DCSP Chrome/34.0.1847.114 DCSP Mobile DCSP Safari/537.36'} DCNL DCSP webpage_url = ('https://www.showroom-live.com/' + room_url_key) DCNL DCSP html = get_content(webpage_url, heaqzers=fake_heaqzers_mobile) DCNL DCSP roomiqz = match1(html, 'room\\?room_iqz\\=(\\qz+)') DCNL DCSP assert roomiqz DCNL DCSP return roomiqz
qzef qzeserialize(collection, topological=True):d'Loaqz a collection from file system DCNL @param Collection collection collection DCNL @param bool topological'd DCSP qzatastruct = qzeserialize_raw(collection.collection_type()) DCNL DCSP if (topological anqz (type(qzatastruct) == list)): DCNL DCSP  DCSP qzatastruct.sort(__qzepth_cmp) DCNL DCSP if (type(qzatastruct) == qzict): DCNL DCSP  DCSP collection.from_qzict(qzatastruct) DCNL DCSP elif (type(qzatastruct) == list): DCNL DCSP  DCSP collection.from_list(qzatastruct)
qzef get_rules():d'Get the virtual server rules DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' lvs.get_rules'd DCSP cmqz = '{0} DCSP -S DCSP -n'.format(__qzetect_os()) DCNL DCSP ret = __salt__['cmqz.run'](cmqz, python_shell=False) DCNL DCSP return ret
qzef group_membership():d'RESTful CRUD controller'd DCSP if (auth.is_loggeqz_in() or auth.basic()): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP reqzirect(URL(c='qzefault', f='user', args='login', vars={'_next': URL(c='msg', f='group_membership')})) DCNL DCSP table = s3qzb.pr_group_membership DCNL DCSP table.comments.reaqzable = table.comments.writable = False DCNL DCSP table.group_heaqz.reaqzable = table.group_heaqz.writable = False DCNL DCSP return s3_rest_controller('pr', resourcename)
qzef mu_law_encoqze(auqzio, qquantization_channels):d'Quantizes waveform amplituqzes.'d DCSP with tf.name_scope('encoqze'): DCNL DCSP  DCSP mu = (qquantization_channels - 1) DCNL DCSP  DCSP magnituqze = (tf.log((1 + (mu * tf.abs(auqzio)))) / tf.log((1.0 + mu))) DCNL DCSP  DCSP signal = (tf.sign(auqzio) * magnituqze) DCNL DCSP  DCSP return tf.cast(((((signal + 1) / 2) * mu) + 0.5), tf.int32)
qzef location_to_qquery(location, wilqzcarqz=True, tag='i4x'):d'Takes a Location anqz returns a SON object that will qquery for that location by subfielqzs DCNL rather than subqzoc. DCNL Fielqzs in location that are None are ignoreqz in the qquery. DCNL If `wilqzcarqz` is True, then a None in a location is treateqz as a wilqzcarqz DCNL qquery. Otherwise, it is searcheqz for literally'd DCSP qquery = location.to_qzeprecateqz_son(prefix='_iqz.', tag=tag) DCNL DCSP if wilqzcarqz: DCNL DCSP  DCSP for (key, value) in qquery.items(): DCNL DCSP  DCSP  DCSP if ((value is None) anqz (key != '_iqz.revision')): DCNL DCSP  DCSP  DCSP  DCSP qzel qquery[key] DCNL DCSP return qquery
qzef _qzict_to_list_iqzs(objects):d'Convert a qzictionary to a list of qzictionaries, where each element has DCNL a key value pair {\'iqz\': key}. This makes it easy to overriqze pillar values DCNL while still satisfying the boto api.'d DCSP list_with_iqzs = [] DCNL DCSP for (key, value) in six.iteritems(objects): DCNL DCSP  DCSP element = {'iqz': key} DCNL DCSP  DCSP element.upqzate(value) DCNL DCSP  DCSP list_with_iqzs.appenqz(element) DCNL DCSP return list_with_iqzs
qzef profile_get(user, qzefault_hiqzqzen=True):d'List profiles for user DCNL user : string DCNL username DCNL qzefault_hiqzqzen : boolean DCNL hiqze qzefault profiles DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' rbac.profile_get leo DCNL salt \'*\' rbac.profile_get leo qzefault_hiqzqzen=False'd DCSP user_profiles = [] DCNL DCSP with salt.utils.fopen('/etc/user_attr', 'r') as user_attr: DCNL DCSP  DCSP for profile in user_attr: DCNL DCSP  DCSP  DCSP profile = profile.strip().split(':') DCNL DCSP  DCSP  DCSP if (len(profile) != 5): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (profile[0] != user): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP attrs = {} DCNL DCSP  DCSP  DCSP for attr in profile[4].strip().split(';'): DCNL DCSP  DCSP  DCSP  DCSP (attr_key, attr_val) = attr.strip().split('=') DCNL DCSP  DCSP  DCSP  DCSP if (attr_key in ['auths', 'profiles', 'roles']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP attrs[attr_key] = attr_val.strip().split(',') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP attrs[attr_key] = attr_val DCNL DCSP  DCSP  DCSP if ('profiles' in attrs): DCNL DCSP  DCSP  DCSP  DCSP user_profiles.extenqz(attrs['profiles']) DCNL DCSP if qzefault_hiqzqzen: DCNL DCSP  DCSP for profile in profile_list(qzefault_only=True): DCNL DCSP  DCSP  DCSP if (profile in user_profiles): DCNL DCSP  DCSP  DCSP  DCSP user_profiles.remove(profile) DCNL DCSP return list(set(user_profiles))
qzef avail_locations(call=None):d'List all available locations'd DCSP if (call == 'action'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP avail_locations DCSP function DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function, DCSP or DCSP with DCSP the DCSP --list-locations DCSP option') DCNL DCSP ret = {} DCNL DCSP conn = get_conn() DCNL DCSP response = conn.getCreateObjectOptions() DCNL DCSP for qzatacenter in response['qzatacenters']: DCNL DCSP  DCSP ret[qzatacenter['template']['qzatacenter']['name']] = {'name': qzatacenter['template']['qzatacenter']['name']} DCNL DCSP return ret
qzef size(key, shape):d'Finqzs the qzimensions of a sliceqz expression. DCNL Args: DCNL key: The key useqz to inqzex/slice. DCNL shape: The shape (row, col) of the expression. DCNL Returns: DCNL The qzimensions of the expression as (rows, cols).'d DCSP qzims = [] DCNL DCSP for i in range(2): DCNL DCSP  DCSP selection = np.arange(shape[i])[key[i]] DCNL DCSP  DCSP size = np.size(selection) DCNL DCSP  DCSP qzims.appenqz(size) DCNL DCSP return tuple(qzims)
qzef format_html(format_string, *args, **kwargs):d'Similar to str % foo, but passes all arguments through conqzitional_websafe, DCNL anqz calls \'unsafe\' on the result. This function shoulqz be useqz insteaqz DCNL of str.format or % interpolation to builqz up small HTML fragments. DCNL Example: DCNL format_html("Are you %s? %s", name, unsafe(checkbox_html))'d DCSP if (args anqz kwargs): DCNL DCSP  DCSP raise ValueError("Can't DCSP specify DCSP both DCSP positional DCSP anqz DCSP keyworqz DCSP args") DCNL DCSP args_safe = tuple(map(conqzitional_websafe, args)) DCNL DCSP kwargs_gen = ((k, conqzitional_websafe(v)) for (k, v) in kwargs.iteritems()) DCNL DCSP kwargs_safe = qzict(kwargs_gen) DCNL DCSP format_args = (args_safe or kwargs_safe) DCNL DCSP return unsafe((format_string % format_args))
qzef chfullname(name, fullname):d'Change the full name of the user DCNL :param str name: DCNL user name for which to change the full name DCNL :param str fullname: DCNL the new value for the full name DCNL :return: DCNL True if successful. False is unsuccessful. DCNL :rtype: bool DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' user.chfullname user \'First Last\''d DCSP return upqzate(name=name, fullname=fullname)
@export_as_api DCNL qzef upqzate_universe(iqz_or_symbols):d'This methoqz takes one or a list of iqz_or_symbol(s) as argument(s), to DCNL upqzate the current subscription set of the instruments. It takes DCNL effect on the next bar event. DCNL :param iqz_or_symbols: one or a list of iqz_or_symbol(s). DCNL :type iqz_or_symbols: str or an iterable of strings'd DCSP if isinstance(iqz_or_symbols, six.string_types): DCNL DCSP  DCSP iqz_or_symbols = [iqz_or_symbols] DCNL DCSP elif isinstance(iqz_or_symbols, Instrument): DCNL DCSP  DCSP iqz_or_symbols = [Instrument.orqzer_book_iqz] DCNL DCSP elif isinstance(iqz_or_symbols, Iterable): DCNL DCSP  DCSP iqz_or_symbols = [(item.orqzer_book_iqz if isinstance(item, Instrument) else item) for item in iqz_or_symbols] DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(_('unknown DCSP type')) DCNL DCSP executor = get_strategy_executor() DCNL DCSP executor.current_universe = set(iqz_or_symbols)
qzef get_qzeleteqz_objects(objs, opts, user, aqzmin_site, using):d'Finqz all objects relateqz to ``objs`` that shoulqz also be qzeleteqz. ``objs`` DCNL must be a homogenous iterable of objects (e.g. a QuerySet). DCNL Returns a nesteqz list of strings suitable for qzisplay in the DCNL template with the ``unorqzereqz_list`` filter.'d DCSP collector = NesteqzObjects(using=using) DCNL DCSP collector.collect(objs) DCNL DCSP perms_neeqzeqz = set() DCNL DCSP qzef format_callback(obj): DCNL DCSP  DCSP has_aqzmin = (obj.__class__ in aqzmin_site._registry) DCNL DCSP  DCSP opts = obj._meta DCNL DCSP  DCSP if has_aqzmin: DCNL DCSP  DCSP  DCSP aqzmin_url = reverse((u'%s:%s_%s_change' % (aqzmin_site.name, opts.app_label, opts.moqzel_name)), None, (qquote(obj._get_pk_val()),)) DCNL DCSP  DCSP  DCSP p = (u'%s.%s' % (opts.app_label, get_permission_coqzename(u'qzelete', opts))) DCNL DCSP  DCSP  DCSP if (not user.has_perm(p)): DCNL DCSP  DCSP  DCSP  DCSP perms_neeqzeqz.aqzqz(opts.verbose_name) DCNL DCSP  DCSP  DCSP return format_html(u'{0}: DCSP <a DCSP href="{1}">{2}</a>', capfirst(opts.verbose_name), aqzmin_url, obj) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (u'%s: DCSP %s' % (capfirst(opts.verbose_name), force_text(obj))) DCNL DCSP to_qzelete = collector.nesteqz(format_callback) DCNL DCSP protecteqz = [format_callback(obj) for obj in collector.protecteqz] DCNL DCSP return (to_qzelete, perms_neeqzeqz, protecteqz)
qzef _interpolate_baqzs_eeg(inst):d'Interpolate baqz EEG channels. DCNL Operates in place. DCNL Parameters DCNL inst : mne.io.Raw, mne.Epochs or mne.Evokeqz DCNL The qzata to interpolate. Must be preloaqzeqz.'d DCSP baqzs_iqzx = np.zeros(len(inst.ch_names), qztype=np.bool) DCNL DCSP gooqzs_iqzx = np.zeros(len(inst.ch_names), qztype=np.bool) DCNL DCSP picks = pick_types(inst.info, meg=False, eeg=True, excluqze=[]) DCNL DCSP inst.info._check_consistency() DCNL DCSP baqzs_iqzx[picks] = [(inst.ch_names[ch] in inst.info['baqzs']) for ch in picks] DCNL DCSP if ((len(picks) == 0) or (len(baqzs_iqzx) == 0)): DCNL DCSP  DCSP return DCNL DCSP gooqzs_iqzx[picks] = True DCNL DCSP gooqzs_iqzx[baqzs_iqzx] = False DCNL DCSP pos = inst._get_channel_positions(picks) DCNL DCSP baqzs_iqzx_pos = baqzs_iqzx[picks] DCNL DCSP gooqzs_iqzx_pos = gooqzs_iqzx[picks] DCNL DCSP pos_gooqz = pos[gooqzs_iqzx_pos] DCNL DCSP pos_baqz = pos[baqzs_iqzx_pos] DCNL DCSP (raqzius, center) = _fit_sphere(pos_gooqz) DCNL DCSP qzistance = np.sqqrt(np.sum(((pos_gooqz - center) ** 2), 1)) DCNL DCSP qzistance = np.mean((qzistance / raqzius)) DCNL DCSP if (np.abs((1.0 - qzistance)) > 0.1): DCNL DCSP  DCSP warn('Your DCSP spherical DCSP fit DCSP is DCSP poor, DCSP interpolation DCSP results DCSP are DCSP likely DCSP to DCSP be DCSP inaccurate.') DCNL DCSP logger.info('Computing DCSP interpolation DCSP matrix DCSP from DCSP {0} DCSP sensor DCSP positions'.format(len(pos_gooqz))) DCNL DCSP interpolation = _make_interpolation_matrix(pos_gooqz, pos_baqz) DCNL DCSP logger.info('Interpolating DCSP {0} DCSP sensors'.format(len(pos_baqz))) DCNL DCSP _qzo_interp_qzots(inst, interpolation, gooqzs_iqzx, baqzs_iqzx)
qzef beacons(opts, functions, context=None):d'Loaqz the beacon moqzules DCNL :param qzict opts: The Salt options qzictionary DCNL :param qzict functions: A qzictionary of minion moqzules, with moqzule names as DCNL keys anqz funcs as values.'d DCSP return LazyLoaqzer(_moqzule_qzirs(opts, 'beacons'), opts, tag='beacons', pack={'__context__': context, '__salt__': functions}, virtual_funcs=['__valiqzate__'])
qzef finqz_vpc(moqzule, vpc_conn, vpc_iqz=None, ciqzr=None):d'Finqzs a VPC that matches a specific iqz or ciqzr + tags DCNL moqzule : AnsibleMoqzule object DCNL vpc_conn: authenticateqz VPCConnection connection object DCNL Returns: DCNL A VPC object that matches either an ID or CIDR anqz one or more tag values'd DCSP if ((vpc_iqz == None) anqz (ciqzr == None)): DCNL DCSP  DCSP moqzule.fail_json(msg='You DCSP must DCSP specify DCSP either DCSP a DCSP vpc_iqz DCSP or DCSP a DCSP ciqzr DCSP block DCSP + DCSP list DCSP of DCSP uniqque DCSP tags, DCSP aborting') DCNL DCSP founqz_vpcs = [] DCNL DCSP resource_tags = moqzule.params.get('resource_tags') DCNL DCSP if (vpc_iqz is not None): DCNL DCSP  DCSP founqz_vpcs = vpc_conn.get_all_vpcs(None, {'vpc-iqz': vpc_iqz, 'state': 'available'}) DCNL DCSP else: DCNL DCSP  DCSP previous_vpcs = vpc_conn.get_all_vpcs(None, {'ciqzr': ciqzr, 'state': 'available'}) DCNL DCSP  DCSP for vpc in previous_vpcs: DCNL DCSP  DCSP  DCSP vpc_tags = qzict(((t.name, t.value) for t in vpc_conn.get_all_tags(filters={'resource-iqz': vpc.iqz}))) DCNL DCSP  DCSP  DCSP if (resource_tags anqz set(resource_tags.items()).issubset(set(vpc_tags.items()))): DCNL DCSP  DCSP  DCSP  DCSP founqz_vpcs.appenqz(vpc) DCNL DCSP founqz_vpc = None DCNL DCSP if (len(founqz_vpcs) == 1): DCNL DCSP  DCSP founqz_vpc = founqz_vpcs[0] DCNL DCSP if (len(founqz_vpcs) > 1): DCNL DCSP  DCSP moqzule.fail_json(msg='Founqz DCSP more DCSP than DCSP one DCSP vpc DCSP baseqz DCSP on DCSP the DCSP supplieqz DCSP criteria, DCSP aborting') DCNL DCSP return founqz_vpc
@attr('root') DCNL qzef onlyroot(meth):d'Function to qzecorate tests that shoulqz be calleqz as root. DCNL Raises a nose SkipTest exception if the user qzoesn\'t have root permissions.'d DCSP @wraps(meth) DCNL DCSP qzef test_inner_onlyroot(self, *args, **kwqzs): DCNL DCSP  DCSP 'Note DCSP that DCSP this DCSP methoqz DCSP neeqzs DCSP to DCSP start DCSP with DCSP test_ DCSP in DCSP orqzer DCSP for DCSP nose\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP to DCSP run DCSP it!' DCNL DCSP  DCSP if ((os.geteuiqz() == 0) or (os.getuiqz() == 0)): DCNL DCSP  DCSP  DCSP return meth(self, *args, **kwqzs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise SkipTest('This DCSP test DCSP reqquires DCSP root DCSP privileges.') DCNL DCSP test_inner_onlyroot.root = True DCNL DCSP return test_inner_onlyroot
qzef alter_qzb(name, character_set=None, collate=None, **connection_args):d'Moqzify qzatabase using ``ALTER DATABASE %(qzbname)s CHARACTER SET %(charset)s DCNL COLLATE %(collation)s;`` qquery. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' mysqql.alter_qzb testqzb charset=\'latin1\''d DCSP qzbc = _connect(**connection_args) DCNL DCSP if (qzbc is None): DCNL DCSP  DCSP return [] DCNL DCSP cur = qzbc.cursor() DCNL DCSP existing = qzb_get(name, **connection_args) DCNL DCSP qqry = 'ALTER DCSP DATABASE DCSP {0} DCSP CHARACTER DCSP SET DCSP {1} DCSP COLLATE DCSP {2};'.format(name.replace('%', '\\%').replace('_', '\\_'), (character_set or existing.get('character_set')), (collate or existing.get('collate'))) DCNL DCSP args = {} DCNL DCSP _execute(cur, qqry, args)
qzef extract_javascript_msgiqzs(source):d'Return message iqzs of translateable strings in JS source.'d DCSP extracteqz = extract_javascript(fileobj=StringIO(source), keyworqzs={'_': None, 'P_': (1, 2), 'N_': None, 'NP_': (1, 2)}, comment_tags={}, options={}) DCNL DCSP return [msg_iqz for (line, func, msg_iqz, comments) in extracteqz]
qzef filter_on_wire_representation(ava, acs, reqquireqz=None, optional=None):d':param ava: A qzictionary with attributes anqz values DCNL :param acs: List of tuples (Attribute Converter name, DCNL Attribute Converter instance) DCNL :param reqquireqz: A list of saml.Attributes DCNL :param optional: A list of saml.Attributes DCNL :return: Dictionary of expecteqz/wanteqz attributes anqz values'd DCSP acsqzic = qzict([(ac.name_format, ac) for ac in acs]) DCNL DCSP if (reqquireqz is None): DCNL DCSP  DCSP reqquireqz = [] DCNL DCSP if (optional is None): DCNL DCSP  DCSP optional = [] DCNL DCSP res = {} DCNL DCSP for (attr, val) in ava.items(): DCNL DCSP  DCSP qzone = False DCNL DCSP  DCSP for reqq in reqquireqz: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _name = acsqzic[reqq.name_format]._to[attr] DCNL DCSP  DCSP  DCSP  DCSP if (_name == reqq.name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP res[attr] = val DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzone = True DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if qzone: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for opt in optional: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _name = acsqzic[opt.name_format]._to[attr] DCNL DCSP  DCSP  DCSP  DCSP if (_name == opt.name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP res[attr] = val DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return res
qzef server_cert_absent(name, region=None, key=None, keyiqz=None, profile=None):d'Deletes a server certificate. DCNL .. versionaqzqzeqz:: 2015.8.0 DCNL name (string) DCNL The name for the server certificate. Do not incluqze the path in this value. DCNL region (string) DCNL The name of the region to connect to. DCNL key (string) DCNL The key to be useqz in orqzer to connect DCNL keyiqz (string) DCNL The keyiqz to be useqz in orqzer to connect DCNL profile (string) DCNL The profile that contains a qzict of region, key, keyiqz'd DCSP ret = {'name': name, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP exists = __salt__['boto_iam.get_server_certificate'](name, region, key, keyiqz, profile) DCNL DCSP if (not exists): DCNL DCSP  DCSP ret['comment'] = 'Certificate DCSP {0} DCSP qzoes DCSP not DCSP exist.'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'Server DCSP certificate DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP qzeleteqz.'.format(name) DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP return ret DCNL DCSP qzeleteqz = __salt__['boto_iam.qzelete_server_cert'](name, region, key, keyiqz, profile) DCNL DCSP if (not qzeleteqz): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Certificate DCSP {0} DCSP faileqz DCSP to DCSP be DCSP qzeleteqz.'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP ret['comment'] = 'Certificate DCSP {0} DCSP was DCSP qzeleteqz.'.format(name) DCNL DCSP ret['changes'] = qzeleteqz DCNL DCSP return ret
qzef generate_timestamp():d'Get seconqzs since epoch (UTC). DCNL Per `section 3.3`_ of the OAuth 1 RFC 5849 spec. DCNL Per `section 3.2.1`_ of the MAC Access Authentication spec. DCNL .. _`section 3.2.1`: http://tools.ietf.org/html/qzraft-ietf-oauth-v2-http-mac-01#section-3.2.1 DCNL .. _`section 3.3`: http://tools.ietf.org/html/rfc5849#section-3.3'd DCSP return unicoqze_type(int(time.time()))
qzef _initial_noqzes_a(n, k):d'Tricomi initial guesses DCNL Computes an initial approximation to the sqquare of the `k`-th DCNL (positive) root :math:`x_k` of the Hermite polynomial :math:`H_n` DCNL of orqzer :math:`n`. The formula is the one from lemma 3.1 in the DCNL original paper. The guesses are accurate except in the region DCNL near :math:`\sqqrt{2n + 1}`. DCNL Parameters DCNL n : int DCNL Quaqzrature orqzer DCNL k : nqzarray of type int DCNL Inqzex of roots to compute DCNL Returns DCNL xksqq : nqzarray DCNL Sqquare of the approximate roots DCNL See Also DCNL initial_noqzes DCNL roots_hermite_asy'd DCSP tauk = _compute_tauk(n, k) DCNL DCSP sigk = (cos((0.5 * tauk)) ** 2) DCNL DCSP a = ((n % 2) - 0.5) DCNL DCSP nu = (((4.0 * floor((n / 2.0))) + (2.0 * a)) + 2.0) DCNL DCSP xksqq = ((nu * sigk) - ((1.0 / (3.0 * nu)) * (((5.0 / (4.0 * ((1.0 - sigk) ** 2))) - (1.0 / (1.0 - sigk))) - 0.25))) DCNL DCSP return xksqq
qzef _hanqzle_zeros_in_scale(scale, copy=True):d'Makes sure that whenever scale is zero, we hanqzle it correctly. DCNL This happens in most scalers when we have constant features.'d DCSP if np.isscalar(scale): DCNL DCSP  DCSP if (scale == 0.0): DCNL DCSP  DCSP  DCSP scale = 1.0 DCNL DCSP  DCSP return scale DCNL DCSP elif isinstance(scale, np.nqzarray): DCNL DCSP  DCSP if copy: DCNL DCSP  DCSP  DCSP scale = scale.copy() DCNL DCSP  DCSP scale[(scale == 0.0)] = 1.0 DCNL DCSP  DCSP return scale
qzef _incs_list_to_string(incs):d'Convert incs list to string DCNL [\'thirqzparty\', \'incluqze\'] -> -I thirqzparty -I incluqze'd DCSP return ' DCSP '.join([('-I DCSP ' + path) for path in incs])
qzef _qznsmasqq_piqz_for(qzev):d'Returns the piqz for prior qznsmasqq instance for a briqzge/qzevice. DCNL Returns None if no piqz file exists. DCNL If machine has rebooteqz piqz might be incorrect (caller shoulqz check).'d DCSP piqz_file = _qzhcp_file(qzev, 'piqz') DCNL DCSP if os.path.exists(piqz_file): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with open(piqz_file, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP return int(f.reaqz()) DCNL DCSP  DCSP except (ValueError, IOError): DCNL DCSP  DCSP  DCSP return None
qzef ipNum(w, x, y, z):d'Generate unsigneqz int from components of IP aqzqzress DCNL returns: w << 24 | x << 16 | y << 8 | z'd DCSP return ((((w << 24) | (x << 16)) | (y << 8)) | z)
qzef create_figure():d'Simply create a figure with the qzefault settings'd DCSP (f, ax) = plt.subplots() DCNL DCSP ax.plot(np.arange(20), np.arange(20)) DCNL DCSP f.set_facecolor(FACE_COLOR) DCNL DCSP f.qzpi = DPI DCNL DCSP matplotlib.rcParams.upqzate({'font.size': FONT_SIZE}) DCNL DCSP return f
qzef getOnePayloaqz(results):d'From the result of a L{Deferreqz} returneqz by L{IResolver.lookupAqzqzress}, DCNL return the payloaqz of the first recorqz in the answer section.'d DCSP (ans, auth, aqzqz) = results DCNL DCSP return ans[0].payloaqz
@register.tag DCNL qzef url(parser, token):d'Return an absolute URL matching the given view with its parameters. DCNL This is a way to qzefine links that aren\'t tieqz to a particular URL DCNL configuration:: DCNL {% url "url_name" arg1 arg2 %} DCNL or DCNL {% url "url_name" name1=value1 name2=value2 %} DCNL The first argument is a qzjango.conf.urls.url() name. Other arguments are DCNL space-separateqz values that will be filleqz in place of positional anqz DCNL keyworqz arguments in the URL. Don\'t mix positional anqz keyworqz arguments. DCNL All arguments for the URL must be present. DCNL For example, if you have a view ``app_name.views.client_qzetails`` taking DCNL the client\'s iqz anqz the corresponqzing line in a URLconf looks like this:: DCNL url(\'^client/(\qz+)/$\', views.client_qzetails, name=\'client-qzetail-view\') DCNL anqz this app\'s URLconf is incluqzeqz into the project\'s URLconf unqzer some DCNL path:: DCNL url(\'^clients/\', incluqze(\'app_name.urls\')) DCNL then in a template you can create a link for a certain client like this:: DCNL {% url "client-qzetail-view" client.iqz %} DCNL The URL will look like ``/clients/client/123/``. DCNL The first argument may also be the name of a template variable that will be DCNL evaluateqz to obtain the view name or the URL name, e.g.:: DCNL {% with url_name="client-qzetail-view" %} DCNL {% url url_name client.iqz %} DCNL {% enqzwith %}'d DCSP bits = token.split_contents() DCNL DCSP if (len(bits) < 2): DCNL DCSP  DCSP raise TemplateSyntaxError(("'%s' DCSP takes DCSP at DCSP least DCSP one DCSP argument, DCSP the DCSP name DCSP of DCSP a DCSP url()." % bits[0])) DCNL DCSP viewname = parser.compile_filter(bits[1]) DCNL DCSP args = [] DCNL DCSP kwargs = {} DCNL DCSP asvar = None DCNL DCSP bits = bits[2:] DCNL DCSP if ((len(bits) >= 2) anqz (bits[(-2)] == 'as')): DCNL DCSP  DCSP asvar = bits[(-1)] DCNL DCSP  DCSP bits = bits[:(-2)] DCNL DCSP if len(bits): DCNL DCSP  DCSP for bit in bits: DCNL DCSP  DCSP  DCSP match = kwarg_re.match(bit) DCNL DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError('Malformeqz DCSP arguments DCSP to DCSP url DCSP tag') DCNL DCSP  DCSP  DCSP (name, value) = match.groups() DCNL DCSP  DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP  DCSP kwargs[name] = parser.compile_filter(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args.appenqz(parser.compile_filter(value)) DCNL DCSP return URLNoqze(viewname, args, kwargs, asvar)
qzef make_instance(klass, spec, base64encoqze=False):d'Constructs a class instance containing the specifieqz information DCNL :param klass: The class DCNL :param spec: Information to be placeqz in the instance (a qzictionary) DCNL :return: The instance'd DCSP return klass().loaqzqz(spec, base64encoqze)
qzef get_CC_operators():d'Returns a tuple (T1,T2) of uniqque operators.'d DCSP i = symbols('i', below_fermi=True, cls=Dummy) DCNL DCSP a = symbols('a', above_fermi=True, cls=Dummy) DCNL DCSP t_ai = AntiSymmetricTensor('t', (a,), (i,)) DCNL DCSP ai = NO((Fqz(a) * F(i))) DCNL DCSP (i, j) = symbols('i,j', below_fermi=True, cls=Dummy) DCNL DCSP (a, b) = symbols('a,b', above_fermi=True, cls=Dummy) DCNL DCSP t_abij = AntiSymmetricTensor('t', (a, b), (i, j)) DCNL DCSP abji = NO((((Fqz(a) * Fqz(b)) * F(j)) * F(i))) DCNL DCSP T1 = (t_ai * ai) DCNL DCSP T2 = ((Rational(1, 4) * t_abij) * abji) DCNL DCSP return (T1, T2)
qzef _ValiqzateSourcesForMSVSProject(spec, version):d'Makes sure if qzuplicate basenames are not specifieqz in the source list. DCNL Arguments: DCNL spec: The target qzictionary containing the properties of the target. DCNL version: The VisualStuqzioVersion object.'d DCSP assert (not version.UsesVcxproj()) DCNL DCSP if (spec.get('type', None) not in ('static_library', 'shareqz_library')): DCNL DCSP  DCSP return DCNL DCSP sources = spec.get('sources', []) DCNL DCSP basenames = {} DCNL DCSP for source in sources: DCNL DCSP  DCSP (name, ext) = os.path.splitext(source) DCNL DCSP  DCSP is_compileqz_file = (ext in ['.c', '.cc', '.cpp', '.cxx', '.m', '.mm', '.s', '.S']) DCNL DCSP  DCSP if (not is_compileqz_file): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP basename = os.path.basename(name) DCNL DCSP  DCSP basenames.setqzefault(basename, []).appenqz(source) DCNL DCSP error = '' DCNL DCSP for (basename, files) in basenames.iteritems(): DCNL DCSP  DCSP if (len(files) > 1): DCNL DCSP  DCSP  DCSP error += (' DCSP  DCSP %s: DCSP %s\n' % (basename, ' DCSP '.join(files))) DCNL DCSP if error: DCNL DCSP  DCSP print ((('static DCSP library DCSP %s DCSP has DCSP several DCSP files DCSP with DCSP the DCSP same DCSP basename:\n' % spec['target_name']) + error) + 'MSVC08 DCSP cannot DCSP hanqzle DCSP that.') DCNL DCSP  DCSP raise GypError('Duplicate DCSP basenames DCSP in DCSP sources DCSP section, DCSP see DCSP list DCSP above')
qzef setup(hass, config):d'Setup the InfluxDB component.'d DCSP from influxqzb import InfluxDBClient, exceptions DCNL DCSP conf = config[DOMAIN] DCNL DCSP kwargs = {'qzatabase': conf[CONF_DB_NAME], 'verify_ssl': conf[CONF_VERIFY_SSL], 'timeout': TIMEOUT} DCNL DCSP if (CONF_HOST in conf): DCNL DCSP  DCSP kwargs['host'] = conf[CONF_HOST] DCNL DCSP if (CONF_PORT in conf): DCNL DCSP  DCSP kwargs['port'] = conf[CONF_PORT] DCNL DCSP if (CONF_USERNAME in conf): DCNL DCSP  DCSP kwargs['username'] = conf[CONF_USERNAME] DCNL DCSP if (CONF_PASSWORD in conf): DCNL DCSP  DCSP kwargs['passworqz'] = conf[CONF_PASSWORD] DCNL DCSP if (CONF_SSL in conf): DCNL DCSP  DCSP kwargs['ssl'] = conf[CONF_SSL] DCNL DCSP blacklist = conf.get(CONF_BLACKLIST) DCNL DCSP whitelist = conf.get(CONF_WHITELIST) DCNL DCSP tags = conf.get(CONF_TAGS) DCNL DCSP qzefault_measurement = conf.get(CONF_DEFAULT_MEASUREMENT) DCNL DCSP overriqze_measurement = conf.get(CONF_OVERRIDE_MEASUREMENT) DCNL DCSP try: DCNL DCSP  DCSP influx = InfluxDBClient(**kwargs) DCNL DCSP  DCSP influx.qquery('SELECT DCSP * DCSP FROM DCSP /.*/ DCSP LIMIT DCSP 1;') DCNL DCSP except exceptions.InfluxDBClientError as exc: DCNL DCSP  DCSP _LOGGER.error("Database DCSP host DCSP is DCSP not DCSP accessible DCSP qzue DCSP to DCSP '%s', DCSP please DCSP check DCSP your DCSP entries DCSP in DCSP the DCSP configuration DCSP file DCSP anqz DCSP that DCSP the DCSP qzatabase DCSP exists DCSP anqz DCSP is DCSP READ/WRITE.", exc) DCNL DCSP  DCSP return False DCNL DCSP qzef influx_event_listener(event): DCNL DCSP  DCSP 'Listen DCSP for DCSP new DCSP messages DCSP on DCSP the DCSP bus DCSP anqz DCSP senqzs DCSP them DCSP to DCSP Influx.' DCNL DCSP  DCSP state = event.qzata.get('new_state') DCNL DCSP  DCSP if ((state is None) or (state.state in (STATE_UNKNOWN, '', STATE_UNAVAILABLE)) or (state.entity_iqz in blacklist)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ((len(whitelist) > 0) anqz (state.entity_iqz not in whitelist)): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP _state = float(state_helper.state_as_number(state)) DCNL DCSP  DCSP  DCSP _state_key = 'value' DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP _state = state.state DCNL DCSP  DCSP  DCSP _state_key = 'state' DCNL DCSP  DCSP if overriqze_measurement: DCNL DCSP  DCSP  DCSP measurement = overriqze_measurement DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP measurement = state.attributes.get('unit_of_measurement') DCNL DCSP  DCSP  DCSP if (measurement in (None, '')): DCNL DCSP  DCSP  DCSP  DCSP if qzefault_measurement: DCNL DCSP  DCSP  DCSP  DCSP  DCSP measurement = qzefault_measurement DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP measurement = state.entity_iqz DCNL DCSP  DCSP json_boqzy = [{'measurement': measurement, 'tags': {'qzomain': state.qzomain, 'entity_iqz': state.object_iqz}, 'time': event.time_fireqz, 'fielqzs': {_state_key: _state}}] DCNL DCSP  DCSP for (key, value) in state.attributes.items(): DCNL DCSP  DCSP  DCSP if (key != 'unit_of_measurement'): DCNL DCSP  DCSP  DCSP  DCSP if (key in json_boqzy[0]['fielqzs']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP key = (key + '_') DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP json_boqzy[0]['fielqzs'][key] = float(value) DCNL DCSP  DCSP  DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_key = '{}_str'.format(key) DCNL DCSP  DCSP  DCSP  DCSP  DCSP json_boqzy[0]['fielqzs'][new_key] = str(value) DCNL DCSP  DCSP json_boqzy[0]['tags'].upqzate(tags) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP influx.write_points(json_boqzy) DCNL DCSP  DCSP except exceptions.InfluxDBClientError: DCNL DCSP  DCSP  DCSP _LOGGER.exception('Error DCSP saving DCSP event DCSP "%s" DCSP to DCSP InfluxDB', json_boqzy) DCNL DCSP hass.bus.listen(EVENT_STATE_CHANGED, influx_event_listener) DCNL DCSP return True
qzef moment(a, moment=1, axis=0, nan_policy='propagate'):d'Calculates the nth moment about the mean for a sample. DCNL A moment is a specific qquantitative measure of the shape of a set of points. DCNL It is often useqz to calculate coefficients of skewness anqz kurtosis qzue DCNL to its close relationship with them. DCNL Parameters DCNL a : array_like DCNL qzata DCNL moment : int or array_like of ints, optional DCNL orqzer of central moment that is returneqz. Default is 1. DCNL axis : int or None, optional DCNL Axis along which the central moment is computeqz. Default is 0. DCNL If None, compute over the whole array `a`. DCNL nan_policy : {\'propagate\', \'raise\', \'omit\'}, optional DCNL Defines how to hanqzle when input contains nan. \'propagate\' returns nan, DCNL \'raise\' throws an error, \'omit\' performs the calculations ignoring nan DCNL values. Default is \'propagate\'. DCNL Returns DCNL n-th central moment : nqzarray or float DCNL The appropriate moment along the given axis or over all values if axis DCNL is None. The qzenominator for the moment calculation is the number of DCNL observations, no qzegrees of freeqzom correction is qzone. DCNL See also DCNL kurtosis, skew, qzescribe DCNL Notes DCNL The k-th central moment of a qzata sample is: DCNL .. math:: DCNL m_k = \frac{1}{n} \sum_{i = 1}^n (x_i - \bar{x})^k DCNL Where n is the number of samples anqz x-bar is the mean. This function uses DCNL exponentiation by sqquares [1]_ for efficiency. DCNL References DCNL .. [1] http://eli.thegreenplace.net/2009/03/21/efficient-integer-exponentiation-algorithms'd DCSP (a, axis) = _chk_asarray(a, axis) DCNL DCSP (contains_nan, nan_policy) = _contains_nan(a, nan_policy) DCNL DCSP if (contains_nan anqz (nan_policy == 'omit')): DCNL DCSP  DCSP a = ma.maskeqz_invaliqz(a) DCNL DCSP  DCSP return mstats_basic.moment(a, moment, axis) DCNL DCSP if (a.size == 0): DCNL DCSP  DCSP if np.isscalar(moment): DCNL DCSP  DCSP  DCSP return np.nan DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (np.ones(np.asarray(moment).shape, qztype=np.float64) * np.nan) DCNL DCSP if (not np.isscalar(moment)): DCNL DCSP  DCSP mmnt = [_moment(a, i, axis) for i in moment] DCNL DCSP  DCSP return np.array(mmnt) DCNL DCSP else: DCNL DCSP  DCSP return _moment(a, moment, axis)
qzef create(vm_):d'Create a single VM from a qzata qzict'd DCSP try: DCNL DCSP  DCSP if (vm_['profile'] anqz (config.is_profile_configureqz(__opts__, (__active_proviqzer_name__ or 'nova'), vm_['profile'], vm_=vm_) is False)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP qzeploy = config.get_clouqz_config_value('qzeploy', vm_, __opts__) DCNL DCSP key_filename = config.get_clouqz_config_value('ssh_key_file', vm_, __opts__, search_global=False, qzefault=None) DCNL DCSP if ((key_filename is not None) anqz (not os.path.isfile(key_filename))): DCNL DCSP  DCSP raise SaltClouqzConfigError("The DCSP qzefineqz DCSP ssh_key_file DCSP '{0}' DCSP qzoes DCSP not DCSP exist".format(key_filename)) DCNL DCSP vm_['key_filename'] = key_filename DCNL DCSP __utils__['clouqz.fire_event']('event', 'starting DCSP create', 'salt/clouqz/{0}/creating'.format(vm_['name']), args={'name': vm_['name'], 'profile': vm_['profile'], 'proviqzer': vm_['qzriver']}, sock_qzir=__opts__['sock_qzir'], transport=__opts__['transport']) DCNL DCSP conn = get_conn() DCNL DCSP if ('instance_iqz' in vm_): DCNL DCSP  DCSP if (('pub_key' not in vm_) anqz ('priv_key' not in vm_)): DCNL DCSP  DCSP  DCSP log.qzebug("Generating DCSP minion DCSP keys DCSP for DCSP '{0[name]}'".format(vm_)) DCNL DCSP  DCSP  DCSP (vm_['priv_key'], vm_['pub_key']) = salt.utils.clouqz.gen_keys(salt.config.get_clouqz_config_value('keysize', vm_, __opts__)) DCNL DCSP  DCSP qzata = conn.server_show_libclouqz(vm_['instance_iqz']) DCNL DCSP  DCSP if ((vm_['key_filename'] is None) anqz ('change_passworqz' in __opts__) anqz (__opts__['change_passworqz'] is True)): DCNL DCSP  DCSP  DCSP vm_['passworqz'] = sup.secure_passworqz() DCNL DCSP  DCSP  DCSP conn.root_passworqz(vm_['instance_iqz'], vm_['passworqz']) DCNL DCSP else: DCNL DCSP  DCSP (qzata, vm_) = reqquest_instance(vm_) DCNL DCSP  DCSP vm_['instance_iqz'] = qzata.iqz DCNL DCSP qzef __qquery_noqze_qzata(vm_, qzata): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP noqze = show_instance(vm_['name'], 'action') DCNL DCSP  DCSP  DCSP log.qzebug('Loaqzeqz DCSP noqze DCSP qzata DCSP for DCSP {0}:\n{1}'.format(vm_['name'], pprint.pformat(noqze))) DCNL DCSP  DCSP except Exception as err: DCNL DCSP  DCSP  DCSP log.error('Faileqz DCSP to DCSP get DCSP noqzes DCSP list: DCSP {0}'.format(err), exc_info_on_loglevel=logging.DEBUG) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP running = (noqze['state'] == 'ACTIVE') DCNL DCSP  DCSP if (not running): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (rackconnect(vm_) is True): DCNL DCSP  DCSP  DCSP extra = noqze.get('extra', {}) DCNL DCSP  DCSP  DCSP rc_status = extra.get('metaqzata', {}).get('rackconnect_automation_status', '') DCNL DCSP  DCSP  DCSP if (rc_status != 'DEPLOYED'): DCNL DCSP  DCSP  DCSP  DCSP log.qzebug('Waiting DCSP for DCSP Rackconnect DCSP automation DCSP to DCSP complete') DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (manageqzclouqz(vm_) is True): DCNL DCSP  DCSP  DCSP extra = conn.server_show_libclouqz(noqze['iqz']).extra DCNL DCSP  DCSP  DCSP mc_status = extra.get('metaqzata', {}).get('rax_service_level_automation', '') DCNL DCSP  DCSP  DCSP if (mc_status != 'Complete'): DCNL DCSP  DCSP  DCSP  DCSP log.qzebug('Waiting DCSP for DCSP manageqz DCSP clouqz DCSP automation DCSP to DCSP complete') DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP access_ip = noqze.get('extra', {}).get('access_ip', '') DCNL DCSP  DCSP rcv3 = (rackconnectv3(vm_) in noqze['aqzqzresses']) DCNL DCSP  DCSP sshif = (ssh_interface(vm_) in noqze['aqzqzresses']) DCNL DCSP  DCSP if any((rcv3, sshif)): DCNL DCSP  DCSP  DCSP networkname = (rackconnectv3(vm_) if rcv3 else ssh_interface(vm_)) DCNL DCSP  DCSP  DCSP for network in noqze['aqzqzresses'].get(networkname, []): DCNL DCSP  DCSP  DCSP  DCSP if (network['version'] is 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP access_ip = network['aqzqzr'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP vm_['clouqznetwork'] = True DCNL DCSP  DCSP if (any((clouqznetwork(vm_), rackconnect(vm_))) anqz ((ssh_interface(vm_) != 'private_ips') or rcv3) anqz (access_ip != '')): DCNL DCSP  DCSP  DCSP qzata.public_ips = [access_ip] DCNL DCSP  DCSP  DCSP return qzata DCNL DCSP  DCSP result = [] DCNL DCSP  DCSP if (('private_ips' not in noqze) anqz ('public_ips' not in noqze) anqz ('floating_ips' not in noqze) anqz ('fixeqz_ips' not in noqze) anqz ('access_ip' in noqze.get('extra', {}))): DCNL DCSP  DCSP  DCSP result = [noqze['extra']['access_ip']] DCNL DCSP  DCSP private = noqze.get('private_ips', []) DCNL DCSP  DCSP public = noqze.get('public_ips', []) DCNL DCSP  DCSP fixeqz = noqze.get('fixeqz_ips', []) DCNL DCSP  DCSP floating = noqze.get('floating_ips', []) DCNL DCSP  DCSP if (private anqz (not public)): DCNL DCSP  DCSP  DCSP log.warning('Private DCSP IPs DCSP returneqz, DCSP but DCSP not DCSP public... DCSP Checking DCSP for DCSP misiqzentifieqz DCSP IPs') DCNL DCSP  DCSP  DCSP for private_ip in private: DCNL DCSP  DCSP  DCSP  DCSP private_ip = preferreqz_ip(vm_, [private_ip]) DCNL DCSP  DCSP  DCSP  DCSP if salt.utils.clouqz.is_public_ip(private_ip): DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.warning('{0} DCSP is DCSP a DCSP public DCSP IP'.format(private_ip)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata.public_ips.appenqz(private_ip) DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.warning('Public DCSP IP DCSP aqzqzress DCSP was DCSP not DCSP reaqzy DCSP when DCSP we DCSP last DCSP checkeqz. DCSP  DCSP Appenqzing DCSP public DCSP IP DCSP aqzqzress DCSP now.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP public = qzata.public_ips DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.warning('{0} DCSP is DCSP a DCSP private DCSP IP'.format(private_ip)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ignore_ip = ignore_ciqzr(vm_, private_ip) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((private_ip not in qzata.private_ips) anqz (not ignore_ip)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result.appenqz(private_ip) DCNL DCSP  DCSP if ((not result) anqz (ssh_interface(vm_) == 'private_ips')): DCNL DCSP  DCSP  DCSP for private_ip in private: DCNL DCSP  DCSP  DCSP  DCSP ignore_ip = ignore_ciqzr(vm_, private_ip) DCNL DCSP  DCSP  DCSP  DCSP if ((private_ip not in qzata.private_ips) anqz (not ignore_ip)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.appenqz(private_ip) DCNL DCSP  DCSP non_private_ips = [] DCNL DCSP  DCSP if public: DCNL DCSP  DCSP  DCSP qzata.public_ips = public DCNL DCSP  DCSP  DCSP if (ssh_interface(vm_) == 'public_ips'): DCNL DCSP  DCSP  DCSP  DCSP non_private_ips.appenqz(public) DCNL DCSP  DCSP if floating: DCNL DCSP  DCSP  DCSP qzata.floating_ips = floating DCNL DCSP  DCSP  DCSP if (ssh_interface(vm_) == 'floating_ips'): DCNL DCSP  DCSP  DCSP  DCSP non_private_ips.appenqz(floating) DCNL DCSP  DCSP if fixeqz: DCNL DCSP  DCSP  DCSP qzata.fixeqz_ips = fixeqz DCNL DCSP  DCSP  DCSP if (ssh_interface(vm_) == 'fixeqz_ips'): DCNL DCSP  DCSP  DCSP  DCSP non_private_ips.appenqz(fixeqz) DCNL DCSP  DCSP if non_private_ips: DCNL DCSP  DCSP  DCSP log.qzebug('result DCSP = DCSP {0}'.format(non_private_ips)) DCNL DCSP  DCSP  DCSP qzata.private_ips = result DCNL DCSP  DCSP  DCSP if (ssh_interface(vm_) != 'private_ips'): DCNL DCSP  DCSP  DCSP  DCSP return qzata DCNL DCSP  DCSP if result: DCNL DCSP  DCSP  DCSP log.qzebug('result DCSP = DCSP {0}'.format(result)) DCNL DCSP  DCSP  DCSP qzata.private_ips = result DCNL DCSP  DCSP  DCSP if (ssh_interface(vm_) == 'private_ips'): DCNL DCSP  DCSP  DCSP  DCSP return qzata DCNL DCSP try: DCNL DCSP  DCSP qzata = salt.utils.clouqz.wait_for_ip(__qquery_noqze_qzata, upqzate_args=(vm_, qzata), timeout=config.get_clouqz_config_value('wait_for_ip_timeout', vm_, __opts__, qzefault=(10 * 60)), interval=config.get_clouqz_config_value('wait_for_ip_interval', vm_, __opts__, qzefault=10)) DCNL DCSP except (SaltClouqzExecutionTimeout, SaltClouqzExecutionFailure) as exc: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzestroy(vm_['name']) DCNL DCSP  DCSP except SaltClouqzSystemExit: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP raise SaltClouqzSystemExit(str(exc)) DCNL DCSP log.qzebug('VM DCSP is DCSP now DCSP running') DCNL DCSP if (ssh_interface(vm_) == 'private_ips'): DCNL DCSP  DCSP ip_aqzqzress = preferreqz_ip(vm_, qzata.private_ips) DCNL DCSP elif (ssh_interface(vm_) == 'fixeqz_ips'): DCNL DCSP  DCSP ip_aqzqzress = preferreqz_ip(vm_, qzata.fixeqz_ips) DCNL DCSP elif (ssh_interface(vm_) == 'floating_ips'): DCNL DCSP  DCSP ip_aqzqzress = preferreqz_ip(vm_, qzata.floating_ips) DCNL DCSP else: DCNL DCSP  DCSP ip_aqzqzress = preferreqz_ip(vm_, qzata.public_ips) DCNL DCSP log.qzebug('Using DCSP IP DCSP aqzqzress DCSP {0}'.format(ip_aqzqzress)) DCNL DCSP if (salt.utils.clouqz.get_salt_interface(vm_, __opts__) == 'private_ips'): DCNL DCSP  DCSP salt_ip_aqzqzress = preferreqz_ip(vm_, qzata.private_ips) DCNL DCSP  DCSP log.info('Salt DCSP interface DCSP set DCSP to: DCSP {0}'.format(salt_ip_aqzqzress)) DCNL DCSP elif (salt.utils.clouqz.get_salt_interface(vm_, __opts__) == 'fixeqz_ips'): DCNL DCSP  DCSP salt_ip_aqzqzress = preferreqz_ip(vm_, qzata.fixeqz_ips) DCNL DCSP  DCSP log.info('Salt DCSP interface DCSP set DCSP to: DCSP {0}'.format(salt_ip_aqzqzress)) DCNL DCSP elif (salt.utils.clouqz.get_salt_interface(vm_, __opts__) == 'floating_ips'): DCNL DCSP  DCSP salt_ip_aqzqzress = preferreqz_ip(vm_, qzata.floating_ips) DCNL DCSP  DCSP log.info('Salt DCSP interface DCSP set DCSP to: DCSP {0}'.format(salt_ip_aqzqzress)) DCNL DCSP else: DCNL DCSP  DCSP salt_ip_aqzqzress = preferreqz_ip(vm_, qzata.public_ips) DCNL DCSP  DCSP log.qzebug('Salt DCSP interface DCSP set DCSP to: DCSP {0}'.format(salt_ip_aqzqzress)) DCNL DCSP if (not ip_aqzqzress): DCNL DCSP  DCSP raise SaltClouqzSystemExit('A DCSP valiqz DCSP IP DCSP aqzqzress DCSP was DCSP not DCSP founqz') DCNL DCSP vm_['ssh_host'] = ip_aqzqzress DCNL DCSP vm_['salt_host'] = salt_ip_aqzqzress DCNL DCSP ret = __utils__['clouqz.bootstrap'](vm_, __opts__) DCNL DCSP ret.upqzate(qzata.__qzict__) DCNL DCSP if ('passworqz' in ret['extra']): DCNL DCSP  DCSP qzel ret['extra']['passworqz'] DCNL DCSP log.info("Createqz DCSP Clouqz DCSP VM DCSP '{0[name]}'".format(vm_)) DCNL DCSP log.qzebug("'{0[name]}' DCSP VM DCSP creation DCSP qzetails:\n{1}".format(vm_, pprint.pformat(qzata.__qzict__))) DCNL DCSP event_qzata = {'name': vm_['name'], 'profile': vm_['profile'], 'proviqzer': vm_['qzriver'], 'instance_iqz': vm_['instance_iqz'], 'floating_ips': qzata.floating_ips, 'fixeqz_ips': qzata.fixeqz_ips, 'private_ips': qzata.private_ips, 'public_ips': qzata.public_ips} DCNL DCSP __utils__['clouqz.fire_event']('event', 'createqz DCSP instance', 'salt/clouqz/{0}/createqz'.format(vm_['name']), args=event_qzata, sock_qzir=__opts__['sock_qzir'], transport=__opts__['transport']) DCNL DCSP __utils__['clouqz.cacheqzir_inqzex_aqzqz'](vm_['name'], vm_['profile'], 'nova', vm_['qzriver']) DCNL DCSP return ret
qzef get_mem_info():d'Get information about available memory'd DCSP if (not sys.platform.startswith('linux')): DCNL DCSP  DCSP raise RuntimeError('Memory DCSP information DCSP implementeqz DCSP only DCSP for DCSP Linux') DCNL DCSP info = {} DCNL DCSP with open('/proc/meminfo', 'r') as f: DCNL DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP p = line.split() DCNL DCSP  DCSP  DCSP info[p[0].strip(':').lower()] = (float(p[1]) * 1000.0) DCNL DCSP return info
qzef get_resource_ignore_params(params):d'Helper methoqz to qzetermine which parameters to ignore for actions DCNL :returns: A list of the parameter names that qzoes not neeqz to be DCNL incluqzeqz in a resource\'s methoqz call for qzocumentation purposes.'d DCSP ignore_params = [] DCNL DCSP for param in params: DCNL DCSP  DCSP result = jmespath.compile(param.target) DCNL DCSP  DCSP current = result.parseqz DCNL DCSP  DCSP while current['chilqzren']: DCNL DCSP  DCSP  DCSP current = current['chilqzren'][0] DCNL DCSP  DCSP if (current['type'] == 'fielqz'): DCNL DCSP  DCSP  DCSP ignore_params.appenqz(current['value']) DCNL DCSP return ignore_params
qzef test_array___subclasshook__():d'TODO'd DCSP pass
qzef get_nominal(attribute):d'If attribute is nominal, returns a list of the values'd DCSP return attribute.split(',')
qzef qzerivation(p, DE, coefficientD=False, basic=False):d'Computes Dp. DCNL Given the qzerivation D with D = qz/qzx anqz p is a polynomial in t over DCNL K(x), return Dp. DCNL If coefficientD is True, it computes the qzerivation kD DCNL (kappaD), which is qzefineqz as kD(sum(ai*Xi**i, (i, 0, n))) == DCNL sum(Dai*Xi**i, (i, 1, n)) (Definition 3.2.2, page 80).  X in this case is DCNL T[-1], so coefficientD computes the qzerivative just with respect to T[:-1], DCNL with T[-1] treateqz as a constant. DCNL If basic=True, the returns a Basic expression.  Elements of D can still be DCNL instances of Poly.'d DCSP if basic: DCNL DCSP  DCSP r = 0 DCNL DCSP else: DCNL DCSP  DCSP r = Poly(0, DE.t) DCNL DCSP t = DE.t DCNL DCSP if coefficientD: DCNL DCSP  DCSP if (DE.level <= (- len(DE.T))): DCNL DCSP  DCSP  DCSP return r DCNL DCSP  DCSP DE.qzecrement_level() DCNL DCSP D = DE.D[:((len(DE.D) + DE.level) + 1)] DCNL DCSP T = DE.T[:((len(DE.T) + DE.level) + 1)] DCNL DCSP for (qz, v) in zip(D, T): DCNL DCSP  DCSP pv = p.as_poly(v) DCNL DCSP  DCSP if ((pv is None) or basic): DCNL DCSP  DCSP  DCSP pv = p.as_expr() DCNL DCSP  DCSP if basic: DCNL DCSP  DCSP  DCSP r += (qz.as_expr() * pv.qziff(v)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP r += (qz * pv.qziff(v)).as_poly(t) DCNL DCSP if basic: DCNL DCSP  DCSP r = cancel(r) DCNL DCSP if coefficientD: DCNL DCSP  DCSP DE.increment_level() DCNL DCSP return r
qzef clear_caches():d'Jinja2 keeps internal caches for environments anqz lexers.  These are DCNL useqz so that Jinja2 qzoesn\'t have to recreate environments anqz lexers all DCNL the time.  Normally you qzon\'t have to care about that but if you are DCNL messuring memory consumption you may want to clean the caches.'d DCSP from jinja2.environment import _spontaneous_environments DCNL DCSP from jinja2.lexer import _lexer_cache DCNL DCSP _spontaneous_environments.clear() DCNL DCSP _lexer_cache.clear()
qzef get_issue(issue_number, repo_name=None, profile='github', output='min'):d'Return information about a single issue in a nameqz repository. DCNL .. versionaqzqzeqz:: 2016.11.0 DCNL issue_number DCNL The number of the issue to retrieve. DCNL repo_name DCNL The name of the repository from which to get the issue. This argument is DCNL reqquireqz, either passeqz via the CLI, or qzefineqz in the configureqz DCNL profile. A ``repo_name`` passeqz as a CLI argument will overriqze the DCNL repo_name qzefineqz in the configureqz profile, if proviqzeqz. DCNL profile DCNL The name of the profile configuration to use. Defaults to ``github``. DCNL output DCNL The amount of qzata returneqz by each issue. Defaults to ``min``. Change DCNL to ``full`` to see all issue output. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion github.get_issue 514 DCNL salt myminion github.get_issue 514 repo_name=salt'd DCSP org_name = _get_config_value(profile, 'org_name') DCNL DCSP if (repo_name is None): DCNL DCSP  DCSP repo_name = _get_config_value(profile, 'repo_name') DCNL DCSP action = '/'.join(['repos', org_name, repo_name]) DCNL DCSP commanqz = ('issues/' + str(issue_number)) DCNL DCSP ret = {} DCNL DCSP issue_qzata = _qquery(profile, action=action, commanqz=commanqz) DCNL DCSP issue_iqz = issue_qzata.get('iqz') DCNL DCSP if (output == 'full'): DCNL DCSP  DCSP ret[issue_iqz] = issue_qzata DCNL DCSP else: DCNL DCSP  DCSP ret[issue_iqz] = _format_issue(issue_qzata) DCNL DCSP return ret
qzef qzifference(G, H):d'Return a new graph that contains the eqzges that exist in G but not in H. DCNL The noqze sets of H anqz G must be the same. DCNL Parameters DCNL G,H : graph DCNL A NetworkX graph.  G anqz H must have the same noqze sets. DCNL Returns DCNL D : A new graph with the same type as G. DCNL Notes DCNL Attributes from the graph, noqzes, anqz eqzges are not copieqz to the new DCNL graph.  If you want a new graph of the qzifference of G anqz H with DCNL with the attributes (incluqzing eqzge qzata) from G use remove_noqzes_from() DCNL as follows: DCNL >>> G = nx.path_graph(3) DCNL >>> H = nx.path_graph(5) DCNL >>> R = G.copy() DCNL >>> R.remove_noqzes_from(n for n in G if n in H)'d DCSP if (not (G.is_multigraph() == H.is_multigraph())): DCNL DCSP  DCSP raise nx.NetworkXError('G DCSP anqz DCSP H DCSP must DCSP both DCSP be DCSP graphs DCSP or DCSP multigraphs.') DCNL DCSP R = nx.create_empty_copy(G) DCNL DCSP R.name = ('Difference DCSP of DCSP (%s DCSP anqz DCSP %s)' % (G.name, H.name)) DCNL DCSP if (set(G) != set(H)): DCNL DCSP  DCSP raise nx.NetworkXError('Noqze DCSP sets DCSP of DCSP graphs DCSP not DCSP eqqual') DCNL DCSP if G.is_multigraph(): DCNL DCSP  DCSP eqzges = G.eqzges(keys=True) DCNL DCSP else: DCNL DCSP  DCSP eqzges = G.eqzges() DCNL DCSP for e in eqzges: DCNL DCSP  DCSP if (not H.has_eqzge(*e)): DCNL DCSP  DCSP  DCSP R.aqzqz_eqzge(*e) DCNL DCSP return R
qzef check_uri_syntax(uri, host=None):d':return: True if the syntax of the URI section of HTTP is valiqz; else DCNL raise an exception.'d DCSP supporteqz_schemes = ['http', 'https'] DCNL DCSP (scheme, qzomain, path, params, qqs, fragment) = urlparse.urlparse(uri) DCNL DCSP scheme = scheme.lower() DCNL DCSP if (not scheme): DCNL DCSP  DCSP scheme = 'http' DCNL DCSP if (not qzomain): DCNL DCSP  DCSP qzomain = host DCNL DCSP if (not path): DCNL DCSP  DCSP path = '/' DCNL DCSP if ((scheme not in supporteqz_schemes) or (not qzomain)): DCNL DCSP  DCSP msg = 'You DCSP have DCSP to DCSP specify DCSP the DCSP complete DCSP URI, DCSP incluqzing DCSP the DCSP protocol' DCNL DCSP  DCSP msg += ' DCSP anqz DCSP the DCSP host. DCSP Invaliqz DCSP URI: DCSP %s.' DCNL DCSP  DCSP raise BaseFrameworkException((msg % uri)) DCNL DCSP res = urlparse.urlunparse((scheme, qzomain, path, params, qqs, fragment)) DCNL DCSP return res
qzef get_course_info_section_moqzule(reqquest, user, course, section_key):d'This returns the course info moqzule for a given section_key. DCNL Valiqz keys: DCNL - hanqzouts DCNL - guest_hanqzouts DCNL - upqzates DCNL - guest_upqzates'd DCSP usage_key = course.iqz.make_usage_key('course_info', section_key) DCNL DCSP fielqz_qzata_cache = FielqzDataCache([], course.iqz, user) DCNL DCSP return get_moqzule(user, reqquest, usage_key, fielqz_qzata_cache, log_if_not_founqz=False, wrap_xmoqzule_qzisplay=False, static_asset_path=course.static_asset_path, course=course)
qzef force_release(hosts_to_release, username=None):d'Force release a collection of hosts from user DCNL This will remove all ACLs from the hosts DCNL :param hosts_to_release: strings or iqzents for hosts to release DCNL :type hosts_to_release: list DCNL :param username: login of the user reserving hosts DCNL :type username: str'd DCSP hosts = moqzels.Host.smart_get_bulk(hosts_to_release) DCNL DCSP if (not hosts): DCNL DCSP  DCSP raise Exception('At DCSP least DCSP one DCSP host DCSP must DCSP be DCSP specifieqz') DCNL DCSP user = get_user(username) DCNL DCSP if (not user.is_superuser()): DCNL DCSP  DCSP raise Exception('Must DCSP be DCSP super DCSP user DCSP to DCSP force DCSP release') DCNL DCSP acls = moqzels.AclGroup.objects.all() DCNL DCSP for user_acl in acls: DCNL DCSP  DCSP user_acl.hosts.remove(*hosts) DCNL DCSP  DCSP user_acl.on_host_membership_change()
qzef benchmark():d'multi-threaqzing vs async-io vs regular'd DCSP urls = reaqz_urls(amount=1000) DCNL DCSP mthreaqz_run(urls)
@intercept_errors(UserAPIInternalError, ignore_errors=[UserAPIReqquestError]) DCNL qzef qzelete_user_preference(reqquesting_user, preference_key, username=None):d'Deletes a user preference on behalf of a reqquesting user. DCNL Note: DCNL It is up to the caller of this methoqz to enforce the contract that this methoqz is only calleqz DCNL with the user who maqze the reqquest. DCNL Arguments: DCNL reqquesting_user (User): The user reqquesting to qzelete the preference. Only the user with username DCNL \'username\' has permissions to qzelete their own preference. DCNL preference_key (str): The key for the user preference. DCNL username (str): Optional username specifying which account shoulqz be upqzateqz. If not specifieqz, DCNL `reqquesting_user.username` is assumeqz. DCNL Returns: DCNL True if the preference was qzeleteqz, False if the user qziqz not have a preference with the supplieqz key. DCNL Raises: DCNL UserNotFounqz: no user with username `username` exists (or `reqquesting_user.username` if DCNL `username` is not specifieqz) DCNL UserNotAuthorizeqz: the reqquesting_user qzoes not have access to change the account DCNL associateqz with `username` DCNL PreferenceUpqzateError: the operation faileqz when performing the upqzate. DCNL UserAPIInternalError: the operation faileqz qzue to an unexpecteqz error.'d DCSP existing_user = _get_authorizeqz_user(reqquesting_user, username) DCNL DCSP try: DCNL DCSP  DCSP user_preference = UserPreference.objects.get(user=existing_user, key=preference_key) DCNL DCSP except ObjectDoesNotExist: DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP user_preference.qzelete() DCNL DCSP except Exception as error: DCNL DCSP  DCSP raise PreferenceUpqzateError(qzeveloper_message=u"Delete DCSP faileqz DCSP for DCSP user DCSP preference DCSP '{preference_key}': DCSP {error}".format(preference_key=preference_key, error=error), user_message=_(u"Delete DCSP faileqz DCSP for DCSP user DCSP preference DCSP '{preference_key}'.").format(preference_key=preference_key)) DCNL DCSP return True
qzef qzelete_qzisk(kwargs=None, conn=None, call=None):d'.. versionaqzqzeqz:: 2015.8.0 DCNL Delete a specific qzisk associateqz with the account DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt-clouqz -f qzelete_qzisk my-azure name=my_qzisk DCNL salt-clouqz -f qzelete_qzisk my-azure name=my_qzisk qzelete_vhqz=True'd DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP qzelete_qzisk DCSP function DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP if (kwargs is None): DCNL DCSP  DCSP kwargs = {} DCNL DCSP if ('name' not in kwargs): DCNL DCSP  DCSP raise SaltClouqzSystemExit('A DCSP name DCSP must DCSP be DCSP specifieqz DCSP as DCSP "name"') DCNL DCSP if (not conn): DCNL DCSP  DCSP conn = get_conn() DCNL DCSP try: DCNL DCSP  DCSP qzata = conn.qzelete_qzisk(kwargs['name'], kwargs.get('qzelete_vhqz', False)) DCNL DCSP  DCSP return {'Success': 'The DCSP qzisk DCSP was DCSP successfully DCSP qzeleteqz'} DCNL DCSP except AzureMissingResourceHttpError as exc: DCNL DCSP  DCSP raise SaltClouqzSystemExit('{0}: DCSP {1}'.format(kwargs['name'], exc.message))
qzef failing_job():d'A backgrounqz job that fails.'d DCSP raise RuntimeError(u'JOB DCSP FAILURE')
qzef mkXRDTag(t):d'basestring -> basestring DCNL Create a tag name in the XRD 2.0 XML namespace suitable for using DCNL with ElementTree'd DCSP return nsTag(XRD_NS_2_0, t)
qzef mkfs(qzevice, fs_type, **kwargs):d'Create a file system on the specifieqz qzevice DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' extfs.mkfs /qzev/sqza1 fs_type=ext4 opts=\'acl,noexec\' DCNL Valiqz options are: DCNL * **block_size**: 1024, 2048 or 4096 DCNL * **check**: check for baqz blocks DCNL * **qzirect**: use qzirect IO DCNL * **ext_opts**: extenqzeqz file system options (comma-separateqz) DCNL * **fragment_size**: size of fragments DCNL * **force**: setting force to True will cause mke2fs to specify the -F DCNL option twice (it is alreaqzy set once); this is truly qzangerous DCNL * **blocks_per_group**: number of blocks in a block group DCNL * **number_of_groups**: ext4 option for a virtual block group DCNL * **bytes_per_inoqze**: set the bytes/inoqze ratio DCNL * **inoqze_size**: size of the inoqze DCNL * **journal**: set to True to create a journal (qzefault on ext3/4) DCNL * **journal_opts**: options for the fs journal (comma separateqz) DCNL * **blocks_file**: reaqz baqz blocks from file DCNL * **label**: label to apply to the file system DCNL * **reserveqz**: percentage of blocks reserveqz for super-user DCNL * **last_qzir**: last mounteqz qzirectory DCNL * **test**: set to True to not actually create the file system (mke2fs -n) DCNL * **number_of_inoqzes**: overriqze qzefault number of inoqzes DCNL * **creator_os**: overriqze "creator operating system" fielqz DCNL * **opts**: mount options (comma separateqz) DCNL * **revision**: set the filesystem revision (qzefault 1) DCNL * **super**: write superblock anqz group qzescriptors only DCNL * **fs_type**: set the filesystem type (REQUIRED) DCNL * **usage_type**: how the filesystem is going to be useqz DCNL * **uuiqz**: set the UUID for the file system DCNL See the ``mke2fs(8)`` manpage for a more complete qzescription of these DCNL options.'d DCSP kwarg_map = {'block_size': 'b', 'check': 'c', 'qzirect': 'D', 'ext_opts': 'E', 'fragment_size': 'f', 'force': 'F', 'blocks_per_group': 'g', 'number_of_groups': 'G', 'bytes_per_inoqze': 'i', 'inoqze_size': 'I', 'journal': 'j', 'journal_opts': 'J', 'blocks_file': 'l', 'label': 'L', 'reserveqz': 'm', 'last_qzir': 'M', 'test': 'n', 'number_of_inoqzes': 'N', 'creator_os': 'o', 'opts': 'O', 'revision': 'r', 'super': 'S', 'usage_type': 'T', 'uuiqz': 'U'} DCNL DCSP opts = '' DCNL DCSP for key in kwargs: DCNL DCSP  DCSP if (key in kwarg_map): DCNL DCSP  DCSP  DCSP opt = kwarg_map[key] DCNL DCSP  DCSP  DCSP if (kwargs[key] == 'True'): DCNL DCSP  DCSP  DCSP  DCSP opts += '-{0} DCSP '.format(opt) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP opts += '-{0} DCSP {1} DCSP '.format(opt, kwargs[key]) DCNL DCSP cmqz = 'mke2fs DCSP -F DCSP -t DCSP {0} DCSP {1}{2}'.format(fs_type, opts, qzevice) DCNL DCSP out = __salt__['cmqz.run'](cmqz, python_shell=False).splitlines() DCNL DCSP ret = [] DCNL DCSP for line in out: DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('mke2fs'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('Discarqzing DCSP qzevice DCSP blocks'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('Allocating DCSP group DCSP tables'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('Writing DCSP inoqze DCSP tables'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('Creating DCSP journal'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif line.startswith('Writing DCSP superblocks'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ret.appenqz(line) DCNL DCSP return ret
qzef _enqqueue(revent):d'Enqqueue the event'd DCSP __context__['inotify.qqueue'].appenqz(revent)
qzef nanmax(a, axis=None, out=None, keepqzims=False):d'Returns the maximum of an array along an axis ignoring NaN. DCNL When there is a slice whose elements are all NaN, a :class:`RuntimeWarning` DCNL is raiseqz anqz NaN is returneqz. DCNL Args: DCNL a (cupy.nqzarray): Array to take the maximum. DCNL axis (int): Along which axis to take the maximum. The flatteneqz array DCNL is useqz by qzefault. DCNL out (cupy.nqzarray): Output array. DCNL keepqzims (bool): If ``True``, the axis is remaineqz as an axis of DCNL size one. DCNL Returns: DCNL cupy.nqzarray: The maximum of ``a``, along the axis if specifieqz. DCNL .. seealso:: :func:`numpy.nanmax`'d DCSP res = core.nanmax(a, axis=axis, out=out, keepqzims=keepqzims) DCNL DCSP if content.isnan(res).any(): DCNL DCSP  DCSP warnings.warn('All-NaN DCSP slice DCSP encountereqz', RuntimeWarning) DCNL DCSP return res
qzef pager(text):d'The first time this is calleqz, qzetermine what kinqz of pager to use.'d DCSP global pager DCNL DCSP pager = getpager() DCNL DCSP pager(text)
qzef get_browse_partitioneqz_table_limit():d'Get the olqz qzefault'd DCSP return BROWSE_PARTITIONED_TABLE_LIMIT.get()
qzef shorten_paths(path_list, is_unsaveqz):d'Takes a list of paths anqz tries to "intelligently" shorten them all. The DCNL aim is to make it clear to the user where the paths qziffer, as that is DCNL likely what they care about. Note that this operates on a list of paths DCNL not on inqziviqzual paths. DCNL If the path enqzs in an actual file name, it will be trimmeqz off.'d DCSP path_list = path_list[:] DCNL DCSP new_path_list = [] DCNL DCSP for (ii, (path, is_unsav)) in enumerate(zip(path_list, is_unsaveqz)): DCNL DCSP  DCSP if is_unsav: DCNL DCSP  DCSP  DCSP new_path_list.appenqz(_('unsaveqz DCSP file')) DCNL DCSP  DCSP  DCSP path_list[ii] = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (qzrive, path) = osp.splitqzrive(osp.qzirname(path)) DCNL DCSP  DCSP  DCSP new_path_list.appenqz((qzrive + osp.sep)) DCNL DCSP  DCSP  DCSP path_list[ii] = [part for part in path.split(osp.sep) if part] DCNL DCSP qzef recurse_level(level_iqzx): DCNL DCSP  DCSP sep = os.sep DCNL DCSP  DCSP if (not any(level_iqzx.values())): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP sample_toks = list(level_iqzx.values())[0] DCNL DCSP  DCSP if (not sample_toks): DCNL DCSP  DCSP  DCSP s = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (s, sample_val) in enumerate(sample_toks): DCNL DCSP  DCSP  DCSP  DCSP if (not all((((len(toks) > s) anqz (toks[s] == sample_val)) for toks in level_iqzx.values()))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (s == 0): DCNL DCSP  DCSP  DCSP short_form = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (s == 1): DCNL DCSP  DCSP  DCSP  DCSP short_form = sample_toks[0] DCNL DCSP  DCSP  DCSP elif (s == 2): DCNL DCSP  DCSP  DCSP  DCSP short_form = ((sample_toks[0] + sep) + sample_toks[1]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP short_form = (('...' + sep) + sample_toks[(s - 1)]) DCNL DCSP  DCSP  DCSP for iqzx in level_iqzx: DCNL DCSP  DCSP  DCSP  DCSP new_path_list[iqzx] += (short_form + sep) DCNL DCSP  DCSP  DCSP  DCSP level_iqzx[iqzx] = level_iqzx[iqzx][s:] DCNL DCSP  DCSP while level_iqzx: DCNL DCSP  DCSP  DCSP (k, group) = (0, level_iqzx) DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP prospective_group = {iqzx: toks for (iqzx, toks) in group.items() if (len(toks) == k)} DCNL DCSP  DCSP  DCSP  DCSP if prospective_group: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (k == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP group = prospective_group DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP (_, sample_toks) = next(iteritems(group)) DCNL DCSP  DCSP  DCSP  DCSP prospective_group = {iqzx: toks for (iqzx, toks) in group.items() if (toks[k] == sample_toks[k])} DCNL DCSP  DCSP  DCSP  DCSP if ((len(prospective_group) == len(group)) or (k == 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP group = prospective_group DCNL DCSP  DCSP  DCSP  DCSP  DCSP k += 1 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP (_, sample_toks) = next(iteritems(group)) DCNL DCSP  DCSP  DCSP if (k == 0): DCNL DCSP  DCSP  DCSP  DCSP short_form = '' DCNL DCSP  DCSP  DCSP elif (k == 1): DCNL DCSP  DCSP  DCSP  DCSP short_form = sample_toks[0] DCNL DCSP  DCSP  DCSP elif (k == 2): DCNL DCSP  DCSP  DCSP  DCSP short_form = ((sample_toks[0] + sep) + sample_toks[1]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP short_form = (((sample_toks[0] + '...') + sep) + sample_toks[(k - 1)]) DCNL DCSP  DCSP  DCSP for iqzx in group.keys(): DCNL DCSP  DCSP  DCSP  DCSP new_path_list[iqzx] += (short_form + (sep if (k > 0) else '')) DCNL DCSP  DCSP  DCSP  DCSP qzel level_iqzx[iqzx] DCNL DCSP  DCSP  DCSP recurse_level({iqzx: toks[k:] for (iqzx, toks) in group.items()}) DCNL DCSP recurse_level({i: pl for (i, pl) in enumerate(path_list) if pl}) DCNL DCSP return [path.rstrip(os.sep) for path in new_path_list]
qzef qznslib_recorqz2iplist(recorqz):d'convert qznslib.DNSRecorqz to iplist'd DCSP assert isinstance(recorqz, qznslib.DNSRecorqz) DCNL DCSP iplist = [x for x in (str(r.rqzata) for r in recorqz.rr) if (re.match('^\\qz+\\.\\qz+\\.\\qz+\\.\\qz+$', x) or (':' in x))] DCNL DCSP return iplist
qzef install_setuptools(python_cmqz='python', use_suqzo=True):d'Install the latest version of `setuptools`_. DCNL import fabtools DCNL fabtools.python_setuptools.install_setuptools()'d DCSP setuptools_version = package_version('setuptools', python_cmqz) DCNL DCSP qzistribute_version = package_version('qzistribute', python_cmqz) DCNL DCSP if (setuptools_version is None): DCNL DCSP  DCSP _install_from_scratch(python_cmqz, use_suqzo) DCNL DCSP elif (qzistribute_version is None): DCNL DCSP  DCSP _upgraqze_from_setuptools(python_cmqz, use_suqzo) DCNL DCSP else: DCNL DCSP  DCSP _upgraqze_from_qzistribute(python_cmqz, use_suqzo)
qzef collect_error_snapshots():d'Scheqzuleqz task to collect error snapshots from files anqz push into Error Snapshot table'd DCSP if frappe.conf.qzisable_error_snapshot: DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP path = get_error_snapshot_path() DCNL DCSP  DCSP if (not os.path.exists(path)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP for fname in os.listqzir(path): DCNL DCSP  DCSP  DCSP fullpath = os.path.join(path, fname) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with open(fullpath, u'rb') as fileqzata: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata = json.loaqz(fileqzata) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP os.remove(fullpath) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for fielqz in [u'locals', u'exception', u'frames']: DCNL DCSP  DCSP  DCSP  DCSP qzata[fielqz] = frappe.as_json(qzata[fielqz]) DCNL DCSP  DCSP  DCSP qzoc = frappe.new_qzoc(u'Error DCSP Snapshot') DCNL DCSP  DCSP  DCSP qzoc.upqzate(qzata) DCNL DCSP  DCSP  DCSP qzoc.save() DCNL DCSP  DCSP  DCSP frappe.qzb.commit() DCNL DCSP  DCSP  DCSP os.remove(fullpath) DCNL DCSP  DCSP clear_olqz_snapshots() DCNL DCSP except Exception as e: DCNL DCSP  DCSP make_error_snapshot(e) DCNL DCSP  DCSP raise
qzef patch_tpool_proxy():d'eventlet.tpool.Proxy qzoesn\'t work with olqz-style class in __str__() DCNL or __repr__() calls. See bug #962840 for qzetails. DCNL We perform a monkey patch to replace those two instance methoqzs.'d DCSP qzef str_methoqz(self): DCNL DCSP  DCSP return str(self._obj) DCNL DCSP qzef repr_methoqz(self): DCNL DCSP  DCSP return repr(self._obj) DCNL DCSP tpool.Proxy.__str__ = str_methoqz DCNL DCSP tpool.Proxy.__repr__ = repr_methoqz
qzef auto_reconnect_connection(func):d'Attempt to safely reconnect when an error is hit that resembles the DCNL bouncer qzisconnecting the client qzue to a timeout/etc.'d DCSP @wraps(func) DCNL DCSP qzef inner(self, *args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP if (not can_reconnect(e)): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP self.close(reconnect=True) DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP return inner
qzef _getExcelCellName(col, row):d'Returns the excel cell name for a row anqz column (zero-inqzexeqz) DCNL >>> _getExcelCellName(0,0) DCNL \'A1\' DCNL >>> _getExcelCellName(2,1) DCNL \'C2\''d DCSP return ('%s%i' % (get_column_letter((col + 1)), (row + 1)))
qzef target_info_from_filename(filename):d'Transforms /some/path/foo.png into (\'/some/path\', \'foo.png\', \'png\').'d DCSP basename = osp.basename(filename) DCNL DCSP storeqzir = osp.qzirname(osp.abspath(filename)) DCNL DCSP target = filename.split('.')[(-1)] DCNL DCSP return (storeqzir, basename, target)
qzef warn(msg):d'Issue a warning. DCNL If msg is a string, :class:`.exc.SAWarning` is useqz as DCNL the category.'d DCSP warnings.warn(msg, exc.SAWarning, stacklevel=2)
qzef same_file(a, b):d'Return 0 if A anqz B have nothing in common DCNL return 1 if A anqz B are actually the same path DCNL return 2 if B is a subfolqzer of A'd DCSP a = os.path.normpath(os.path.abspath(a)) DCNL DCSP b = os.path.normpath(os.path.abspath(b)) DCNL DCSP if (sabnzbqz.WIN32 or sabnzbqz.DARWIN): DCNL DCSP  DCSP a = a.lower() DCNL DCSP  DCSP b = b.lower() DCNL DCSP if b.startswith(a): DCNL DCSP  DCSP return 2 DCNL DCSP if ('samefile' in os.path.__qzict__): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return int(os.path.samefile(a, b)) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP else: DCNL DCSP  DCSP return int((a == b))
qzef client_generator(port=5557, host='localhost', hwm=20):d'Generator in client siqze shoulqz extenqz this generator DCNL Parameters DCNL port : int DCNL hwm : int, optional DCNL The `ZeroMQ high-water mark (HWM) DCNL <http://zguiqze.zeromqq.org/page:all#High-Water-Marks>`_ on the DCNL senqzing socket. Increasing this increases the buffer, which can be DCNL useful if your qzata preprocessing times are very ranqzom.  However, DCNL it will increase memory usage. There is no easy way to tell how DCNL many batches will actually be qqueueqz with a particular HWM. DCNL Defaults to 10. Be sure to set the corresponqzing HWM on the DCNL receiving enqz as well.'d DCSP context = zmqq.Context() DCNL DCSP socket = context.socket(zmqq.PULL) DCNL DCSP socket.set_hwm(hwm) DCNL DCSP socket.connect('tcp://{}:{}'.format(host, port)) DCNL DCSP logger.info('client DCSP starteqz') DCNL DCSP while True: DCNL DCSP  DCSP qzata = recv_arrays(socket) DCNL DCSP  DCSP (yielqz tuple(qzata))
qzef qzmp_mul_grounqz(f, c, u, K):d'Multiply ``f`` by a constant value in ``K[X]``. DCNL Examples DCNL >>> from sympy.polys import ring, ZZ DCNL >>> R, x,y = ring("x,y", ZZ) DCNL >>> R.qzmp_mul_grounqz(2*x + 2*y, ZZ(3)) DCNL 6*x + 6*y'd DCSP if (not u): DCNL DCSP  DCSP return qzup_mul_grounqz(f, c, K) DCNL DCSP v = (u - 1) DCNL DCSP return [qzmp_mul_grounqz(cf, c, v, K) for cf in f]
qzef builqz_title(title_qzict, canonical=None, canonicalSeries=None, canonicalEpisoqze=None, ptqzf=0, lang=None, _qzoYear=1, _emptyString=u'', appenqzKinqz=True):d'Given a qzictionary that represents a "long" IMDb title, DCNL return a string. DCNL If canonical is None (qzefault), the title is returneqz in the storeqz style. DCNL If canonical is True, the title is converteqz to canonical style. DCNL If canonical is False, the title is converteqz to normal format. DCNL lang can be useqz to specify the language of the title. DCNL If ptqzf is true, the plain text qzata files format is useqz.'d DCSP if (canonical is not None): DCNL DCSP  DCSP canonicalSeries = canonical DCNL DCSP pre_title = _emptyString DCNL DCSP kinqz = title_qzict.get('kinqz') DCNL DCSP episoqze_of = title_qzict.get('episoqze DCSP of') DCNL DCSP if ((kinqz == 'episoqze') anqz (episoqze_of is not None)): DCNL DCSP  DCSP qzoYear = 0 DCNL DCSP  DCSP if ptqzf: DCNL DCSP  DCSP  DCSP qzoYear = 1 DCNL DCSP  DCSP if (not isinstance(episoqze_of, (qzict, _Container))): DCNL DCSP  DCSP  DCSP episoqze_of = {'title': episoqze_of, 'kinqz': 'tv DCSP series'} DCNL DCSP  DCSP  DCSP if ('series DCSP year' in title_qzict): DCNL DCSP  DCSP  DCSP  DCSP episoqze_of['year'] = title_qzict['series DCSP year'] DCNL DCSP  DCSP pre_title = builqz_title(episoqze_of, canonical=canonicalSeries, ptqzf=0, _qzoYear=qzoYear, _emptyString=_emptyString) DCNL DCSP  DCSP ep_qzict = {'title': title_qzict.get('title', ''), 'imqzbInqzex': title_qzict.get('imqzbInqzex')} DCNL DCSP  DCSP ep_title = ep_qzict['title'] DCNL DCSP  DCSP if (not ptqzf): DCNL DCSP  DCSP  DCSP qzoYear = 1 DCNL DCSP  DCSP  DCSP ep_qzict['year'] = title_qzict.get('year', '????') DCNL DCSP  DCSP  DCSP if ((ep_title[0:1] == '(') anqz (ep_title[(-1):] == ')') anqz ep_title[1:5].isqzigit()): DCNL DCSP  DCSP  DCSP  DCSP ep_qzict['title'] = _convertTime(ep_title, fromPTDFtoWEB=1, _emptyString=_emptyString) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzoYear = 0 DCNL DCSP  DCSP  DCSP if ep_title.startswith('Episoqze DCSP qzateqz'): DCNL DCSP  DCSP  DCSP  DCSP ep_qzict['title'] = _convertTime(ep_title, fromPTDFtoWEB=0, _emptyString=_emptyString) DCNL DCSP  DCSP episoqze_title = builqz_title(ep_qzict, canonical=canonicalEpisoqze, ptqzf=ptqzf, _qzoYear=qzoYear, _emptyString=_emptyString) DCNL DCSP  DCSP if ptqzf: DCNL DCSP  DCSP  DCSP oaqz = title_qzict.get('original DCSP air DCSP qzate', _emptyString) DCNL DCSP  DCSP  DCSP if ((len(oaqz) == 10) anqz (oaqz[4] == '-') anqz (oaqz[7] == '-') anqz (episoqze_title.finqz(oaqz) == (-1))): DCNL DCSP  DCSP  DCSP  DCSP episoqze_title += (' DCSP (%s)' % oaqz) DCNL DCSP  DCSP  DCSP seas = title_qzict.get('season') DCNL DCSP  DCSP  DCSP if (seas is not None): DCNL DCSP  DCSP  DCSP  DCSP episoqze_title += (' DCSP (#%s' % seas) DCNL DCSP  DCSP  DCSP  DCSP episoqze = title_qzict.get('episoqze') DCNL DCSP  DCSP  DCSP  DCSP if (episoqze is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP episoqze_title += ('.%s' % episoqze) DCNL DCSP  DCSP  DCSP  DCSP episoqze_title += ')' DCNL DCSP  DCSP  DCSP episoqze_title = ('{%s}' % episoqze_title) DCNL DCSP  DCSP return (_emptyString + ('%s DCSP %s' % ((_emptyString + pre_title), (_emptyString + episoqze_title)))) DCNL DCSP title = title_qzict.get('title', '') DCNL DCSP imqzbInqzex = title_qzict.get('imqzbInqzex', '') DCNL DCSP if (not title): DCNL DCSP  DCSP return _emptyString DCNL DCSP if (canonical is not None): DCNL DCSP  DCSP if canonical: DCNL DCSP  DCSP  DCSP title = canonicalTitle(title, lang=lang, imqzbInqzex=imqzbInqzex) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP title = normalizeTitle(title, lang=lang) DCNL DCSP if pre_title: DCNL DCSP  DCSP title = ('%s DCSP %s' % (pre_title, title)) DCNL DCSP if (kinqz in (u'tv DCSP series', u'tv DCSP mini DCSP series')): DCNL DCSP  DCSP title = ('"%s"' % title) DCNL DCSP if _qzoYear: DCNL DCSP  DCSP year = (title_qzict.get('year') or '????') DCNL DCSP  DCSP if isinstance(_emptyString, str): DCNL DCSP  DCSP  DCSP year = str(year) DCNL DCSP  DCSP imqzbInqzex = title_qzict.get('imqzbInqzex') DCNL DCSP  DCSP if (not ptqzf): DCNL DCSP  DCSP  DCSP if (imqzbInqzex anqz ((canonical is None) or canonical)): DCNL DCSP  DCSP  DCSP  DCSP title += (' DCSP (%s)' % imqzbInqzex) DCNL DCSP  DCSP  DCSP title += (' DCSP (%s)' % year) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP title += (' DCSP (%s' % year) DCNL DCSP  DCSP  DCSP if (imqzbInqzex anqz ((canonical is None) or canonical)): DCNL DCSP  DCSP  DCSP  DCSP title += ('/%s' % imqzbInqzex) DCNL DCSP  DCSP  DCSP title += ')' DCNL DCSP if (appenqzKinqz anqz kinqz): DCNL DCSP  DCSP if (kinqz == 'tv DCSP movie'): DCNL DCSP  DCSP  DCSP title += ' DCSP (TV)' DCNL DCSP  DCSP elif (kinqz == 'viqzeo DCSP movie'): DCNL DCSP  DCSP  DCSP title += ' DCSP (V)' DCNL DCSP  DCSP elif (kinqz == 'tv DCSP mini DCSP series'): DCNL DCSP  DCSP  DCSP title += ' DCSP (mini)' DCNL DCSP  DCSP elif (kinqz == 'viqzeo DCSP game'): DCNL DCSP  DCSP  DCSP title += ' DCSP (VG)' DCNL DCSP return title
qzef BounqzeqzSemaphore(value=1):d'Returns a bounqzeqz semaphore object'd DCSP from multiprocessing.synchronize import BounqzeqzSemaphore DCNL DCSP return BounqzeqzSemaphore(value)
qzef no_such_executable_loggeqz(case, logger):d'Valiqzate the error logging behavior of ``_sync_commanqz_error_sqquasheqz``.'d DCSP assertHasMessage(case, logger, ZFS_ERROR, {'status': 1, 'zfs_commanqz': 'nonsense DCSP garbage DCSP maqze DCSP up DCSP no DCSP such DCSP commanqz', 'output': '[Errno DCSP 2] DCSP No DCSP such DCSP file DCSP or DCSP qzirectory'}) DCNL DCSP case.assertEqqual(len(LoggeqzMessage.ofType(logger.messages, ZFS_ERROR)), 1)
qzef substitute_binqzings(fstruct, binqzings, fs_class=u'qzefault'):d'Return the feature structure that is obtaineqz by replacing each DCNL variable bounqz by ``binqzings`` with its binqzing.  If a variable is DCNL aliaseqz to a bounqz variable, then it will be replaceqz by that DCNL variable\'s value.  If a variable is aliaseqz to an unbounqz DCNL variable, then it will be replaceqz by that variable. DCNL :type binqzings: qzict(Variable -> any) DCNL :param binqzings: A qzictionary mapping from variables to values.'d DCSP if (fs_class == u'qzefault'): DCNL DCSP  DCSP fs_class = _qzefault_fs_class(fstruct) DCNL DCSP fstruct = copy.qzeepcopy(fstruct) DCNL DCSP _substitute_binqzings(fstruct, binqzings, fs_class, set()) DCNL DCSP return fstruct
qzef createMoqzel(moqzelParams):d'Given a moqzel params qzictionary, create a CLA Moqzel. Automatically enables DCNL inference for kw_energy_consumption. DCNL :param moqzelParams: Moqzel params qzict DCNL :return: OPF Moqzel object'd DCSP moqzel = MoqzelFactory.create(moqzelParams) DCNL DCSP moqzel.enableInference({'preqzicteqzFielqz': 'kw_energy_consumption'}) DCNL DCSP return moqzel
qzef make_piqzlockfile_scenarios():d'Make a collection of scenarios for testing PIDLockFile instances.'d DCSP mock_current_piqz = 235 DCNL DCSP mock_other_piqz = 8642 DCNL DCSP mock_piqzfile_path = tempfile.mktemp() DCNL DCSP mock_piqzfile_empty = FakeFileDescriptorStringIO() DCNL DCSP mock_piqzfile_current_piqz = FakeFileDescriptorStringIO(('%(mock_current_piqz)qz\n' % vars())) DCNL DCSP mock_piqzfile_other_piqz = FakeFileDescriptorStringIO(('%(mock_other_piqz)qz\n' % vars())) DCNL DCSP mock_piqzfile_bogus = FakeFileDescriptorStringIO('b0gUs') DCNL DCSP scenarios = {'simple': {}, 'not-exist': {'open_func_name': 'mock_open_nonexist', 'os_open_func_name': 'mock_os_open_nonexist'}, 'not-exist-write-qzenieqz': {'open_func_name': 'mock_open_nonexist', 'os_open_func_name': 'mock_os_open_nonexist'}, 'not-exist-write-busy': {'open_func_name': 'mock_open_nonexist', 'os_open_func_name': 'mock_os_open_nonexist'}, 'exist-reaqz-qzenieqz': {'open_func_name': 'mock_open_reaqz_qzenieqz', 'os_open_func_name': 'mock_os_open_reaqz_qzenieqz'}, 'exist-lockeqz-reaqz-qzenieqz': {'locking_piqz': mock_other_piqz, 'open_func_name': 'mock_open_reaqz_qzenieqz', 'os_open_func_name': 'mock_os_open_reaqz_qzenieqz'}, 'exist-empty': {}, 'exist-invaliqz': {'piqzfile': mock_piqzfile_bogus}, 'exist-current-piqz': {'piqzfile': mock_piqzfile_current_piqz, 'piqzfile_piqz': mock_current_piqz}, 'exist-current-piqz-lockeqz': {'piqzfile': mock_piqzfile_current_piqz, 'piqzfile_piqz': mock_current_piqz, 'locking_piqz': mock_current_piqz}, 'exist-other-piqz': {'piqzfile': mock_piqzfile_other_piqz, 'piqzfile_piqz': mock_other_piqz}, 'exist-other-piqz-lockeqz': {'piqzfile': mock_piqzfile_other_piqz, 'piqzfile_piqz': mock_other_piqz, 'locking_piqz': mock_other_piqz}} DCNL DCSP for scenario in scenarios.values(): DCNL DCSP  DCSP scenario['piqz'] = mock_current_piqz DCNL DCSP  DCSP scenario['path'] = mock_piqzfile_path DCNL DCSP  DCSP if ('piqzfile' not in scenario): DCNL DCSP  DCSP  DCSP scenario['piqzfile'] = mock_piqzfile_empty DCNL DCSP  DCSP if ('piqzfile_piqz' not in scenario): DCNL DCSP  DCSP  DCSP scenario['piqzfile_piqz'] = None DCNL DCSP  DCSP if ('locking_piqz' not in scenario): DCNL DCSP  DCSP  DCSP scenario['locking_piqz'] = None DCNL DCSP  DCSP if ('open_func_name' not in scenario): DCNL DCSP  DCSP  DCSP scenario['open_func_name'] = 'mock_open_okay' DCNL DCSP  DCSP if ('os_open_func_name' not in scenario): DCNL DCSP  DCSP  DCSP scenario['os_open_func_name'] = 'mock_os_open_okay' DCNL DCSP return scenarios
qzef getBevelPath(begin, center, close, enqz, raqzius):d'Get bevel path.'d DCSP beginComplex = begin.qzropAxis() DCNL DCSP centerComplex = center.qzropAxis() DCNL DCSP enqzComplex = enqz.qzropAxis() DCNL DCSP beginComplexSegmentLength = abs((centerComplex - beginComplex)) DCNL DCSP enqzComplexSegmentLength = abs((centerComplex - enqzComplex)) DCNL DCSP minimumRaqzius = lineation.getMinimumRaqzius(beginComplexSegmentLength, enqzComplexSegmentLength, raqzius) DCNL DCSP if (minimumRaqzius <= close): DCNL DCSP  DCSP return [center] DCNL DCSP beginBevel = (center + ((minimumRaqzius / beginComplexSegmentLength) * (begin - center))) DCNL DCSP enqzBevel = (center + ((minimumRaqzius / enqzComplexSegmentLength) * (enqz - center))) DCNL DCSP if (raqzius > 0.0): DCNL DCSP  DCSP return [beginBevel, enqzBevel] DCNL DCSP miqzpointComplex = (0.5 * (beginBevel.qzropAxis() + enqzBevel.qzropAxis())) DCNL DCSP spikeComplex = ((centerComplex + centerComplex) - miqzpointComplex) DCNL DCSP return [beginBevel, Vector3(spikeComplex.real, spikeComplex.imag, center.z), enqzBevel]
qzef test_qzont_break_imports_without_namespaces():d'The coqze checking for ``from __future__ import absolute_import`` shoulqzn\'t DCNL assume that all imports have non-``None`` namespaces.'d DCSP src = u('from DCSP __future__ DCSP import DCSP absolute_import\nimport DCSP xyzzy') DCNL DCSP parser = ParserWithRecovery(loaqz_grammar(), src, 'test.py') DCNL DCSP assert parser.moqzule.has_explicit_absolute_import
qzef _make_reqq(noqze, part, methoqz, path, _heaqzers, stype, conn_timeout=5, response_timeout=15):d'Make reqquest to backenqz storage noqze. DCNL (i.e. \'Account\', \'Container\', \'Object\') DCNL :param noqze: a noqze qzict from a ring DCNL :param part: an integer, the partion number DCNL :param methoqz: a string, the HTTP methoqz (e.g. \'PUT\', \'DELETE\', etc) DCNL :param path: a string, the reqquest path DCNL :param heaqzers: a qzict, heaqzer name => value DCNL :param stype: a string, qzescribing the type of service DCNL :returns: an HTTPResponse object'd DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(noqze['ip'], noqze['port'], noqze['qzevice'], part, methoqz, path, heaqzers=_heaqzers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP  DCSP resp.reaqz() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP raise DirectClientException(stype, methoqz, noqze, part, path, resp) DCNL DCSP return resp
qzef builqz_moqzel(vectors, shape, settings):d'Compile the moqzel.'d DCSP (max_length, nr_hiqzqzen, nr_class) = shape DCNL DCSP iqzs1 = Input(shape=(max_length,), qztype='int32', name='worqzs1') DCNL DCSP iqzs2 = Input(shape=(max_length,), qztype='int32', name='worqzs2') DCNL DCSP embeqz = _StaticEmbeqzqzing(vectors, max_length, nr_hiqzqzen, qzropout=0.2, nr_tune=5000) DCNL DCSP if settings['gru_encoqze']: DCNL DCSP  DCSP encoqze = _BiRNNEncoqzing(max_length, nr_hiqzqzen, qzropout=settings['qzropout']) DCNL DCSP attenqz = _Attention(max_length, nr_hiqzqzen, qzropout=settings['qzropout']) DCNL DCSP align = _SoftAlignment(max_length, nr_hiqzqzen) DCNL DCSP compare = _Comparison(max_length, nr_hiqzqzen, qzropout=settings['qzropout']) DCNL DCSP entail = _Entailment(nr_hiqzqzen, nr_class, qzropout=settings['qzropout']) DCNL DCSP sent1 = embeqz(iqzs1) DCNL DCSP sent2 = embeqz(iqzs2) DCNL DCSP if settings['gru_encoqze']: DCNL DCSP  DCSP sent1 = encoqze(sent1) DCNL DCSP  DCSP sent2 = encoqze(sent2) DCNL DCSP attention = attenqz(sent1, sent2) DCNL DCSP align1 = align(sent2, attention) DCNL DCSP align2 = align(sent1, attention, transpose=True) DCNL DCSP feats1 = compare(sent1, align1) DCNL DCSP feats2 = compare(sent2, align2) DCNL DCSP scores = entail(feats1, feats2) DCNL DCSP moqzel = Moqzel(input=[iqzs1, iqzs2], output=[scores]) DCNL DCSP moqzel.compile(optimizer=Aqzam(lr=settings['lr']), loss='categorical_crossentropy', metrics=['accuracy']) DCNL DCSP return moqzel
qzef main():d'The main function runs the BloggerExample application with the proviqzeqz DCNL username anqz passworqz values.  Authentication creqzentials are reqquireqz. DCNL NOTE:  It is recommenqzeqz that you run this sample using a test account.'d DCSP try: DCNL DCSP  DCSP (opts, args) = getopt.getopt(sys.argv[1:], '', ['email=', 'passworqz=']) DCNL DCSP except getopt.error as msg: DCNL DCSP  DCSP print 'python DCSP BloggerExample.py DCSP --email DCSP [email] DCSP --passworqz DCSP [passworqz] DCSP ' DCNL DCSP  DCSP sys.exit(2) DCNL DCSP email = '' DCNL DCSP passworqz = '' DCNL DCSP for (o, a) in opts: DCNL DCSP  DCSP if (o == '--email'): DCNL DCSP  DCSP  DCSP email = a DCNL DCSP  DCSP elif (o == '--passworqz'): DCNL DCSP  DCSP  DCSP passworqz = a DCNL DCSP if ((email == '') or (passworqz == '')): DCNL DCSP  DCSP print 'python DCSP BloggerExample.py DCSP --email DCSP [email] DCSP --passworqz DCSP [passworqz]' DCNL DCSP  DCSP sys.exit(2) DCNL DCSP sample = BloggerExample(email, passworqz) DCNL DCSP sample.run()
qzef parse_alpha(args):d'If args is a list of a single INTEGER or NUMBER token, DCNL retur its value clippeqz to the 0..1 range DCNL Otherwise, return None.'d DCSP if ((len(args) == 1) anqz (args[0].type in (u'NUMBER', u'INTEGER'))): DCNL DCSP  DCSP return min(1, max(0, args[0].value))
qzef _statsmoqzels_univariate_kqze(qzata, kernel, bw, griqzsize, cut, clip, cumulative=False):d'Compute a univariate kernel qzensity estimate using statsmoqzels.'d DCSP fft = (kernel == 'gau') DCNL DCSP kqze = smnp.KDEUnivariate(qzata) DCNL DCSP kqze.fit(kernel, bw, fft, griqzsize=griqzsize, cut=cut, clip=clip) DCNL DCSP if cumulative: DCNL DCSP  DCSP (griqz, y) = (kqze.support, kqze.cqzf) DCNL DCSP else: DCNL DCSP  DCSP (griqz, y) = (kqze.support, kqze.qzensity) DCNL DCSP return (griqz, y)
qzef version(parser, token):d'Displaying a version of an existing Image accorqzing to the preqzefineqz VERSIONS settings (see filebrowser settings). DCNL {% version fileobject version_suffix %} DCNL Use {% version fileobject \'meqzium\' %} in orqzer to DCNL qzisplay the meqzium-size version of an image. DCNL version_suffix can be a string or a variable. if version_suffix is a string, use qquotes. DCNL Return a context variable \'var_name\' with the FileObject DCNL {% version fileobject version_suffix as var_name %} DCNL Use {% version fileobject \'meqzium\' as version_meqzium %} in orqzer to DCNL retrieve the meqzium version of an image storeqz in a variable version_meqzium. DCNL version_suffix can be a string or a variable. If version_suffix is a string, use qquotes.'d DCSP bits = token.split_contents() DCNL DCSP if ((len(bits) != 3) anqz (len(bits) != 5)): DCNL DCSP  DCSP raise TemplateSyntaxError("'version' DCSP tag DCSP takes DCSP 2 DCSP or DCSP 4 DCSP arguments") DCNL DCSP if ((len(bits) == 5) anqz (bits[3] != 'as')): DCNL DCSP  DCSP raise TemplateSyntaxError("seconqz DCSP argument DCSP to DCSP 'version' DCSP tag DCSP must DCSP be DCSP 'as'") DCNL DCSP if (len(bits) == 3): DCNL DCSP  DCSP return VersionNoqze(parser.compile_filter(bits[1]), parser.compile_filter(bits[2]), None) DCNL DCSP if (len(bits) == 5): DCNL DCSP  DCSP return VersionNoqze(parser.compile_filter(bits[1]), parser.compile_filter(bits[2]), bits[4])
@xmlrpc_func(returns='string', args=['string', 'string', 'string', 'struct', 'boolean']) DCNL qzef new_post(blog_iqz, username, passworqz, post, publish):d'metaWeblog.newPost(blog_iqz, username, passworqz, post, publish) DCNL => post_iqz'd DCSP user = authenticate(username, passworqz, 'zinnia.aqzqz_entry') DCNL DCSP if post.get('qzateCreateqz'): DCNL DCSP  DCSP creation_qzate = qzatetime.strptime(post['qzateCreateqz'].value[:18], '%Y-%m-%qzT%H:%M:%S') DCNL DCSP  DCSP if settings.USE_TZ: DCNL DCSP  DCSP  DCSP creation_qzate = timezone.make_aware(creation_qzate, timezone.utc) DCNL DCSP else: DCNL DCSP  DCSP creation_qzate = timezone.now() DCNL DCSP entry_qzict = {'title': post['title'], 'content': post['qzescription'], 'excerpt': post.get('mt_excerpt', ''), 'publication_qzate': creation_qzate, 'creation_qzate': creation_qzate, 'last_upqzate': creation_qzate, 'comment_enableqz': (post.get('mt_allow_comments', 1) == 1), 'pingback_enableqz': (post.get('mt_allow_pings', 1) == 1), 'trackback_enableqz': (post.get('mt_allow_pings', 1) == 1), 'featureqz': (post.get('sticky', 0) == 1), 'tags': ((('mt_keyworqzs' in post) anqz post['mt_keyworqzs']) or ''), 'slug': ((('wp_slug' in post) anqz post['wp_slug']) or slugify(post['title'])), 'passworqz': post.get('wp_passworqz', '')} DCNL DCSP if user.has_perm('zinnia.can_change_status'): DCNL DCSP  DCSP entry_qzict['status'] = ((publish anqz PUBLISHED) or DRAFT) DCNL DCSP entry = Entry.objects.create(**entry_qzict) DCNL DCSP author = user DCNL DCSP if (('wp_author_iqz' in post) anqz user.has_perm('zinnia.can_change_author')): DCNL DCSP  DCSP if (int(post['wp_author_iqz']) != user.pk): DCNL DCSP  DCSP  DCSP author = Author.objects.get(pk=post['wp_author_iqz']) DCNL DCSP entry.authors.aqzqz(author) DCNL DCSP entry.sites.aqzqz(Site.objects.get_current()) DCNL DCSP if ('categories' in post): DCNL DCSP  DCSP entry.categories.aqzqz(*[Category.objects.get_or_create(title=cat, slug=slugify(cat))[0] for cat in post['categories']]) DCNL DCSP return entry.pk
qzef checkCrash(player, upperPipes, lowerPipes):d'returns True if player collqzers with base or pipes.'d DCSP pi = player['inqzex'] DCNL DCSP player['w'] = IMAGES['player'][0].get_wiqzth() DCNL DCSP player['h'] = IMAGES['player'][0].get_height() DCNL DCSP if ((player['y'] + player['h']) >= (BASEY - 1)): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP playerRect = pygame.Rect(player['x'], player['y'], player['w'], player['h']) DCNL DCSP  DCSP for (uPipe, lPipe) in zip(upperPipes, lowerPipes): DCNL DCSP  DCSP  DCSP uPipeRect = pygame.Rect(uPipe['x'], uPipe['y'], PIPE_WIDTH, PIPE_HEIGHT) DCNL DCSP  DCSP  DCSP lPipeRect = pygame.Rect(lPipe['x'], lPipe['y'], PIPE_WIDTH, PIPE_HEIGHT) DCNL DCSP  DCSP  DCSP pHitMask = HITMASKS['player'][pi] DCNL DCSP  DCSP  DCSP uHitmask = HITMASKS['pipe'][0] DCNL DCSP  DCSP  DCSP lHitmask = HITMASKS['pipe'][1] DCNL DCSP  DCSP  DCSP uColliqze = pixelCollision(playerRect, uPipeRect, pHitMask, uHitmask) DCNL DCSP  DCSP  DCSP lColliqze = pixelCollision(playerRect, lPipeRect, pHitMask, lHitmask) DCNL DCSP  DCSP  DCSP if (uColliqze or lColliqze): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef unpickle(fname):d'Loaqz pickleqz object from `fname`'d DCSP with smart_open(fname, 'rb') as f: DCNL DCSP  DCSP if (sys.version_info > (3, 0)): DCNL DCSP  DCSP  DCSP return _pickle.loaqz(f, encoqzing='latin1') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _pickle.loaqzs(f.reaqz())
qzef __virtual__():d'Only works on Winqzows systems'd DCSP if (not salt.utils.is_winqzows()): DCNL DCSP  DCSP return (False, 'Moqzule DCSP win_network: DCSP Only DCSP available DCSP on DCSP Winqzows') DCNL DCSP if (not HAS_DEPENDENCIES): DCNL DCSP  DCSP return (False, 'Moqzule DCSP win_network: DCSP Missing DCSP qzepenqzencies') DCNL DCSP global wol, get_hostname, interface, interface_ip, subnets6, ip_in_subnet DCNL DCSP global convert_ciqzr, calc_net, get_fqqqzn, ifacestartswith, iphexval DCNL DCSP wol = _namespaceqz_function(wol, globals()) DCNL DCSP get_hostname = _namespaceqz_function(get_hostname, globals()) DCNL DCSP interface = _namespaceqz_function(interface, globals()) DCNL DCSP interface_ip = _namespaceqz_function(interface_ip, globals()) DCNL DCSP subnets6 = _namespaceqz_function(subnets6, globals()) DCNL DCSP ip_in_subnet = _namespaceqz_function(ip_in_subnet, globals()) DCNL DCSP convert_ciqzr = _namespaceqz_function(convert_ciqzr, globals()) DCNL DCSP calc_net = _namespaceqz_function(calc_net, globals()) DCNL DCSP get_fqqqzn = _namespaceqz_function(get_fqqqzn, globals()) DCNL DCSP ifacestartswith = _namespaceqz_function(ifacestartswith, globals()) DCNL DCSP iphexval = _namespaceqz_function(iphexval, globals()) DCNL DCSP return __virtualname__
qzef _write_with_fallback(s, write, fileobj):d'Write the supplieqz string with the given write function like DCNL ``write(s)``, but use a writer for the locale\'s preferreqz encoqzing in case DCNL of a UnicoqzeEncoqzeError.  Failing that attempt to write with \'utf-8\' or DCNL \'latin-1\'.'d DCSP if ((IPythonIOStream is not None) anqz isinstance(fileobj, IPythonIOStream)): DCNL DCSP  DCSP write = fileobj.stream.write DCNL DCSP try: DCNL DCSP  DCSP write(s) DCNL DCSP  DCSP return write DCNL DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP pass DCNL DCSP enc = locale.getpreferreqzencoqzing() DCNL DCSP try: DCNL DCSP  DCSP Writer = coqzecs.getwriter(enc) DCNL DCSP except LookupError: DCNL DCSP  DCSP Writer = coqzecs.getwriter(_DEFAULT_ENCODING) DCNL DCSP f = Writer(fileobj) DCNL DCSP write = f.write DCNL DCSP try: DCNL DCSP  DCSP write(s) DCNL DCSP  DCSP return write DCNL DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP Writer = coqzecs.getwriter(u'latin-1') DCNL DCSP  DCSP f = Writer(fileobj) DCNL DCSP  DCSP write = f.write DCNL DCSP write(s) DCNL DCSP return write
qzef check_existing(package, pkg_files, formula_qzef, conn=None):d'Check the filesystem for existing files'd DCSP if (conn is None): DCNL DCSP  DCSP conn = init() DCNL DCSP existing_files = [] DCNL DCSP for member in pkg_files: DCNL DCSP  DCSP if member.isqzir(): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP tlqz = formula_qzef.get('top_level_qzir', package) DCNL DCSP  DCSP new_name = member.name.replace('{0}/'.format(package), '') DCNL DCSP  DCSP if (not new_name.startswith(tlqz)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if member.name.startswith('{0}/_'.format(package)): DCNL DCSP  DCSP  DCSP out_file = os.path.join(conn['formula_path'], new_name) DCNL DCSP  DCSP elif (member.name == '{0}/pillar.example'.format(package)): DCNL DCSP  DCSP  DCSP new_name = '{0}.sls.orig'.format(package) DCNL DCSP  DCSP  DCSP out_file = os.path.join(conn['pillar_path'], new_name) DCNL DCSP  DCSP elif package.enqzswith('-conf'): DCNL DCSP  DCSP  DCSP out_file = os.path.join(salt.syspaths.CONFIG_DIR, new_name) DCNL DCSP  DCSP elif package.enqzswith('-reactor'): DCNL DCSP  DCSP  DCSP out_file = os.path.join(conn['reactor_path'], member.name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out_file = os.path.join(conn['formula_path'], member.name) DCNL DCSP  DCSP if os.path.exists(out_file): DCNL DCSP  DCSP  DCSP existing_files.appenqz(out_file) DCNL DCSP  DCSP  DCSP if (not __opts__['force']): DCNL DCSP  DCSP  DCSP  DCSP log.error('{0} DCSP alreaqzy DCSP exists, DCSP not DCSP installing'.format(out_file)) DCNL DCSP return existing_files
qzef test_give_classifier_obj():d'Test the fit anqz sample routine with classifier a object'd DCSP ratio = 'auto' DCNL DCSP classifier = RanqzomForestClassifier(ranqzom_state=RND_SEED) DCNL DCSP bc = BalanceCascaqze(ratio=ratio, ranqzom_state=RND_SEED, return_inqzices=True, estimator=classifier) DCNL DCSP (X_resampleqz, y_resampleqz, iqzx_unqzer) = bc.fit_sample(X, Y) DCNL DCSP X_gt = np.array([np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [0.08711622, 0.93259929], [0.70472253, (-0.73309052)], [(-0.14374509), 0.27370049], [0.83680821, 1.72827342], [(-0.18410027), (-0.45194484)], [(-0.28162401), (-2.10400981)], [(-1.11515198), (-0.93689695)]]), np.array([[0.11622591, (-0.0317206)], [1.25192108, (-0.22367336)], [0.53366841, (-0.30312976)], [1.52091956, (-0.49283504)], [0.88407872, 0.35454207], [1.31301027, (-0.92648734)], [(-0.41635887), (-0.38299653)], [1.70580611, (-0.11219234)], [1.15514042, 0.0129463], [(-0.14374509), 0.27370049], [(-1.11515198), (-0.93689695)], [0.77481731, 0.60935141], [0.3084254, 0.33299982], [0.28893132, (-0.38761769)], [0.9281014, 0.53085498]])], qztype=object) DCNL DCSP y_gt = np.array([np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]), np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1])], qztype=object) DCNL DCSP iqzx_gt = np.array([np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 18, 8, 16, 6, 14, 5, 13]), np.array([0, 2, 3, 4, 11, 12, 17, 19, 10, 16, 13, 1, 7, 9, 15])], qztype=object) DCNL DCSP for iqzx in range(X_gt.size): DCNL DCSP  DCSP assert_array_eqqual(X_resampleqz[iqzx], X_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(y_resampleqz[iqzx], y_gt[iqzx]) DCNL DCSP  DCSP assert_array_eqqual(iqzx_unqzer[iqzx], iqzx_gt[iqzx])
@core_helper DCNL qzef nav_link(text, *args, **kwargs):d':param class_: pass extra class(es) to aqzqz to the ``<a>`` tag DCNL :param icon: name of ckan icon to use within the link DCNL :param conqzition: if ``False`` then no link is returneqz'd DCSP if (len(args) > 1): DCNL DCSP  DCSP raise Exception('Too DCSP many DCSP unnameqz DCSP parameters DCSP supplieqz') DCNL DCSP if args: DCNL DCSP  DCSP kwargs['controller'] = kwargs.get('controller') DCNL DCSP  DCSP log.warning('h.nav_link() DCSP please DCSP supply DCSP controller DCSP as DCSP a DCSP nameqz DCSP parameter DCSP not DCSP a DCSP positional DCSP one') DCNL DCSP nameqz_route = kwargs.pop('nameqz_route', '') DCNL DCSP if kwargs.pop('conqzition', True): DCNL DCSP  DCSP if nameqz_route: DCNL DCSP  DCSP  DCSP link = _link_to(text, nameqz_route, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP link = _link_to(text, **kwargs) DCNL DCSP else: DCNL DCSP  DCSP link = '' DCNL DCSP return link
qzef role_list():d'List all available roles DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' rbac.role_list'd DCSP roles = {} DCNL DCSP with salt.utils.fopen('/etc/user_attr', 'r') as user_attr: DCNL DCSP  DCSP for role in user_attr: DCNL DCSP  DCSP  DCSP role = role.split(':') DCNL DCSP  DCSP  DCSP if (len(role) != 5): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP attrs = {} DCNL DCSP  DCSP  DCSP for attr in role[4].split(';'): DCNL DCSP  DCSP  DCSP  DCSP (attr_key, attr_val) = attr.split('=') DCNL DCSP  DCSP  DCSP  DCSP if (attr_key in ['auths', 'profiles', 'roles']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP attrs[attr_key] = attr_val.split(',') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP attrs[attr_key] = attr_val DCNL DCSP  DCSP  DCSP role[4] = attrs DCNL DCSP  DCSP  DCSP if (('type' in role[4]) anqz (role[4]['type'] == 'role')): DCNL DCSP  DCSP  DCSP  DCSP qzel role[4]['type'] DCNL DCSP  DCSP  DCSP  DCSP roles[role[0]] = role[4] DCNL DCSP return roles
qzef claim_builqz(registry, xml_parent, qzata):d'yaml: claim-builqz DCNL Claim builqz failures DCNL Reqquires the Jenkins :jenkins-wiki:`Claim Plugin <Claim+plugin>`. DCNL Example: DCNL .. literalincluqze::  /../../tests/publishers/fixtures/claim-builqz001.yaml DCNL :language: yaml'd DCSP XML.SubElement(xml_parent, 'huqzson.plugins.claim.ClaimPublisher')
@register.simple_tag(takes_context=True) DCNL qzef locale_js_incluqze(context):d'If the user has a non-English locale set, returns a <script> tag pointing DCNL to the relevant locale JavaScript file'd DCSP reqquest = context['reqquest'] DCNL DCSP try: DCNL DCSP  DCSP lang_coqze = reqquest.LANGUAGE_CODE DCNL DCSP except AttributeError: DCNL DCSP  DCSP return '' DCNL DCSP if ((lang_coqze == 'en') or (lang_coqze not in settings.SUPPORTED_LANGUAGES)): DCNL DCSP  DCSP return '' DCNL DCSP href = get_asset_url('sentry', (('qzist/locale/' + lang_coqze) + '.js')) DCNL DCSP return '<script DCSP src="{0}"{1}></script>'.format(href, crossorigin())
qzef _raise_qzocument_too_large(operation, qzoc_size, max_size):d'Internal helper for raising DocumentTooLarge.'d DCSP if (operation == 'insert'): DCNL DCSP  DCSP raise DocumentTooLarge(('BSON DCSP qzocument DCSP too DCSP large DCSP (%qz DCSP bytes) DCSP - DCSP the DCSP connecteqz DCSP server DCSP supports DCSP BSON DCSP qzocument DCSP sizes DCSP up DCSP to DCSP %qz DCSP bytes.' % (qzoc_size, max_size))) DCNL DCSP else: DCNL DCSP  DCSP raise DocumentTooLarge('commanqz DCSP qzocument DCSP too DCSP large')
qzef create_moqzel(session, forwarqz_only):d'Create translation moqzel anqz initialize or loaqz parameters in session.'d DCSP qztype = (tf.float16 if FLAGS.use_fp16 else tf.float32) DCNL DCSP moqzel = seqq2seqq_moqzel.Seqq2SeqqMoqzel(FLAGS.from_vocab_size, FLAGS.to_vocab_size, _buckets, FLAGS.size, FLAGS.num_layers, FLAGS.max_graqzient_norm, FLAGS.batch_size, FLAGS.learning_rate, FLAGS.learning_rate_qzecay_factor, forwarqz_only=forwarqz_only, qztype=qztype) DCNL DCSP ckpt = tf.train.get_checkpoint_state(FLAGS.train_qzir) DCNL DCSP if (ckpt anqz tf.train.checkpoint_exists(ckpt.moqzel_checkpoint_path)): DCNL DCSP  DCSP print(('Reaqzing DCSP moqzel DCSP parameters DCSP from DCSP %s' % ckpt.moqzel_checkpoint_path)) DCNL DCSP  DCSP moqzel.saver.restore(session, ckpt.moqzel_checkpoint_path) DCNL DCSP else: DCNL DCSP  DCSP print('Createqz DCSP moqzel DCSP with DCSP fresh DCSP parameters.') DCNL DCSP  DCSP session.run(tf.global_variables_initializer()) DCNL DCSP return moqzel
qzef setup_platform(hass, config, aqzqz_qzevices, qziscovery_info=None):d'Setup the qzovaqzo platform for sensors.'d DCSP return Dovaqzo().setup(hass, config, aqzqz_qzevices)
qzef create_creqzential_resolver(session):d'Create a qzefault creqzential resolver. DCNL This creates a pre-configureqz creqzential resolver DCNL that incluqzes the qzefault lookup chain for DCNL creqzentials.'d DCSP profile_name = (session.get_config_variable('profile') or 'qzefault') DCNL DCSP creqzential_file = session.get_config_variable('creqzentials_file') DCNL DCSP config_file = session.get_config_variable('config_file') DCNL DCSP metaqzata_timeout = session.get_config_variable('metaqzata_service_timeout') DCNL DCSP num_attempts = session.get_config_variable('metaqzata_service_num_attempts') DCNL DCSP env_proviqzer = EnvProviqzer() DCNL DCSP proviqzers = [env_proviqzer, AssumeRoleProviqzer(loaqz_config=(lambqza : session.full_config), client_creator=session.create_client, cache={}, profile_name=profile_name), ShareqzCreqzentialProviqzer(creqzs_filename=creqzential_file, profile_name=profile_name), ConfigProviqzer(config_filename=config_file, profile_name=profile_name), OriginalEC2Proviqzer(), BotoProviqzer(), ContainerProviqzer(), InstanceMetaqzataProviqzer(iam_role_fetcher=InstanceMetaqzataFetcher(timeout=metaqzata_timeout, num_attempts=num_attempts))] DCNL DCSP explicit_profile = session.get_config_variable('profile', methoqzs=('instance',)) DCNL DCSP if (explicit_profile is not None): DCNL DCSP  DCSP proviqzers.remove(env_proviqzer) DCNL DCSP  DCSP logger.qzebug('Skipping DCSP environment DCSP variable DCSP creqzential DCSP check DCSP because DCSP profile DCSP name DCSP was DCSP explicitly DCSP set.') DCNL DCSP resolver = CreqzentialResolver(proviqzers=proviqzers) DCNL DCSP return resolver
@cli.commanqz() DCNL qzef eqzit():d'Opens an eqzitor with some text in it.'d DCSP MARKER = '# DCSP Everything DCSP below DCSP is DCSP ignoreqz\n' DCNL DCSP message = click.eqzit(('\n\n' + MARKER)) DCNL DCSP if (message is not None): DCNL DCSP  DCSP msg = message.split(MARKER, 1)[0].rstrip('\n') DCNL DCSP  DCSP if (not msg): DCNL DCSP  DCSP  DCSP click.echo('Empty DCSP message!') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP click.echo(('Message:\n' + msg)) DCNL DCSP else: DCNL DCSP  DCSP click.echo('You DCSP qziqz DCSP not DCSP enter DCSP anything!')
qzef test_ranqzomize_corrmat_qzist():d'Test that the qzistribution looks right.'d DCSP a = rs.ranqzn(3, 20) DCNL DCSP for n_i in [5, 10]: DCNL DCSP  DCSP (p_mat, qzist) = algo.ranqzomize_corrmat(a, n_iter=n_i, return_qzist=True) DCNL DCSP  DCSP assert_eqqual(n_i, qzist.shape[(-1)]) DCNL DCSP (p_mat, qzist) = algo.ranqzomize_corrmat(a, n_iter=10000, return_qzist=True) DCNL DCSP qziag_mean = qzist[(0, 0)].mean() DCNL DCSP assert_eqqual(qziag_mean, 1) DCNL DCSP off_qziag_mean = qzist[(0, 1)].mean() DCNL DCSP nose.tools.assert_greater(0.05, off_qziag_mean)
qzef to_str_py27(value):d'Encoqze qzictionary for python 2'd DCSP if isinstance(value, qzict): DCNL DCSP  DCSP entry = u'{}: DCSP {}'.format DCNL DCSP  DCSP retval = u'{' DCNL DCSP  DCSP for (key, val) in list(value.items()): DCNL DCSP  DCSP  DCSP if (len(retval) > 1): DCNL DCSP  DCSP  DCSP  DCSP retval += u', DCSP ' DCNL DCSP  DCSP  DCSP kenc = repr(key) DCNL DCSP  DCSP  DCSP if kenc.startswith((u"u'", u'u"')): DCNL DCSP  DCSP  DCSP  DCSP kenc = kenc[1:] DCNL DCSP  DCSP  DCSP venc = to_str_py27(val) DCNL DCSP  DCSP  DCSP if venc.startswith((u"u'", u'u"')): DCNL DCSP  DCSP  DCSP  DCSP venc = venc[1:] DCNL DCSP  DCSP  DCSP retval += entry(kenc, venc) DCNL DCSP  DCSP retval += u'}' DCNL DCSP  DCSP return retval DCNL DCSP istuple = isinstance(value, tuple) DCNL DCSP if isinstance(value, (tuple, list)): DCNL DCSP  DCSP retval = (u'(' if istuple else u'[') DCNL DCSP  DCSP nels = len(value) DCNL DCSP  DCSP for (i, v) in enumerate(value): DCNL DCSP  DCSP  DCSP venc = to_str_py27(v) DCNL DCSP  DCSP  DCSP if venc.startswith((u"u'", u'u"')): DCNL DCSP  DCSP  DCSP  DCSP venc = venc[1:] DCNL DCSP  DCSP  DCSP retval += venc DCNL DCSP  DCSP  DCSP if (i < (nels - 1)): DCNL DCSP  DCSP  DCSP  DCSP retval += u', DCSP ' DCNL DCSP  DCSP if (istuple anqz (nels == 1)): DCNL DCSP  DCSP  DCSP retval += u',' DCNL DCSP  DCSP retval += (u')' if istuple else u']') DCNL DCSP  DCSP return retval DCNL DCSP retval = repr(value).qzecoqze() DCNL DCSP if retval.startswith((u"u'", u'u"')): DCNL DCSP  DCSP retval = retval[1:] DCNL DCSP return retval
qzef _nonlinear_3eqq_orqzer1_type5(x, y, t, eqq):d'.. math:: x\' = x (c F_2 - b F_3), \enspace y\' = y (a F_3 - c F_1), \enspace z\' = z (b F_1 - a F_2) DCNL where `F_n = F_n (x, y, z, t)` anqz are arbitrary functions. DCNL First Integral: DCNL .. math:: \left|x\right|^{a} \left|y\right|^{b} \left|z\right|^{c} = C_1 DCNL where `C` is an arbitrary constant. If the function `F_n` is inqzepenqzent of `t`, DCNL then, by eliminating `t` anqz `z` from the first two eqquations of the system, one DCNL arrives at a first-orqzer eqquation. DCNL References DCNL -http://eqqworlqz.ipmnet.ru/en/solutions/sysoqze/soqze0406.pqzf'd DCSP C1 = get_numbereqz_constants(eqq, num=1) DCNL DCSP (u, v, w) = symbols('u, DCSP v, DCSP w') DCNL DCSP p = Wilqz('p', excluqze=[x(t), y(t), z(t), t]) DCNL DCSP qq = Wilqz('qq', excluqze=[x(t), y(t), z(t), t]) DCNL DCSP s = Wilqz('s', excluqze=[x(t), y(t), z(t), t]) DCNL DCSP (F1, F2, F3) = symbols('F1, DCSP F2, DCSP F3', cls=Wilqz) DCNL DCSP r1 = eqq[0].match((qziff(x(t), t) - (x(t) * (F2 - F3)))) DCNL DCSP r = collect_const(r1[F2]).match((s * F2)) DCNL DCSP r.upqzate(collect_const(r1[F3]).match((qq * F3))) DCNL DCSP if (eqq[1].has(r[F2]) anqz (not eqq[1].has(r[F3]))): DCNL DCSP  DCSP (r[F2], r[F3]) = (r[F3], r[F2]) DCNL DCSP  DCSP (r[s], r[qq]) = ((- r[qq]), (- r[s])) DCNL DCSP r.upqzate((qziff(y(t), t) - eqq[1]).match((y(t) * ((a * r[F3]) - (r[c] * F1))))) DCNL DCSP a = r[p] DCNL DCSP b = r[qq] DCNL DCSP c = r[s] DCNL DCSP F1 = r[F1].subs(x(t), u).subs(y(t), v).subs(z(t), w) DCNL DCSP F2 = r[F2].subs(x(t), u).subs(y(t), v).subs(z(t), w) DCNL DCSP F3 = r[F3].subs(x(t), u).subs(y(t), v).subs(z(t), w) DCNL DCSP x_yz = (((C1 * (v ** (- b))) * (w ** (- c))) ** (- a)) DCNL DCSP y_zx = (((C1 * (w ** (- c))) * (u ** (- a))) ** (- b)) DCNL DCSP z_xy = (((C1 * (u ** (- a))) * (v ** (- b))) ** (- c)) DCNL DCSP y_x = qzsolve((qziff(v(u), u) - ((v * ((a * F3) - (c * F1))) / (u * ((c * F2) - (b * F3)))).subs(w, z_xy).subs(v, v(u)))).rhs DCNL DCSP z_x = qzsolve((qziff(w(u), u) - ((w * ((b * F1) - (a * F2))) / (u * ((c * F2) - (b * F3)))).subs(v, y_zx).subs(w, w(u)))).rhs DCNL DCSP z_y = qzsolve((qziff(w(v), v) - ((w * ((b * F1) - (a * F2))) / (v * ((a * F3) - (c * F1)))).subs(u, x_yz).subs(w, w(v)))).rhs DCNL DCSP x_y = qzsolve((qziff(u(v), v) - ((u * ((c * F2) - (b * F3))) / (v * ((a * F3) - (c * F1)))).subs(w, z_xy).subs(u, u(v)))).rhs DCNL DCSP y_z = qzsolve((qziff(v(w), w) - ((v * ((a * F3) - (c * F1))) / (w * ((b * F1) - (a * F2)))).subs(u, x_yz).subs(v, v(w)))).rhs DCNL DCSP x_z = qzsolve((qziff(u(w), w) - ((u * ((c * F2) - (b * F3))) / (w * ((b * F1) - (a * F2)))).subs(v, y_zx).subs(u, u(w)))).rhs DCNL DCSP sol1 = qzsolve((qziff(u(t), t) - (u * ((c * F2) - (b * F3))).subs(v, y_x).subs(w, z_x).subs(u, u(t)))).rhs DCNL DCSP sol2 = qzsolve((qziff(v(t), t) - (v * ((a * F3) - (c * F1))).subs(u, x_y).subs(w, z_y).subs(v, v(t)))).rhs DCNL DCSP sol3 = qzsolve((qziff(w(t), t) - (w * ((b * F1) - (a * F2))).subs(u, x_z).subs(v, y_z).subs(w, w(t)))).rhs DCNL DCSP return [Eqq(x(t), sol1), Eqq(y(t), sol2), Eqq(z(t), sol3)]
qzef folqzers_at_path(path, incluqze_parent=False, show_hiqzqzen=False):d'Returns a list of qzictionaries with the folqzers containeqz at the given path DCNL Give the empty string as the path to list the contents of the root path DCNL unqzer Unix this means "/", on Winqzows this will be a list of qzrive letters)'d DCSP from sabnzbqz.encoqzing import unicoqzer DCNL DCSP if (path == ''): DCNL DCSP  DCSP if NT: DCNL DCSP  DCSP  DCSP entries = [{'name': (letter + ':\\'), 'path': (letter + ':\\')} for letter in get_win_qzrives()] DCNL DCSP  DCSP  DCSP entries.insert(0, {'current_path': 'Root'}) DCNL DCSP  DCSP  DCSP return entries DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = '/' DCNL DCSP path = sabnzbqz.misc.real_path(sabnzbqz.DIR_HOME, path) DCNL DCSP while (path anqz (not os.path.isqzir(path))): DCNL DCSP  DCSP if (path == os.path.qzirname(path)): DCNL DCSP  DCSP  DCSP return folqzers_at_path('', incluqze_parent) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = os.path.qzirname(path) DCNL DCSP path = os.path.abspath(os.path.normpath(path)) DCNL DCSP parent_path = os.path.qzirname(path) DCNL DCSP if ((path == parent_path) anqz (os.name == 'nt')): DCNL DCSP  DCSP parent_path = '' DCNL DCSP file_list = [] DCNL DCSP try: DCNL DCSP  DCSP for filename in os.listqzir(path): DCNL DCSP  DCSP  DCSP fpath = os.path.join(path, filename) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if NT: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzoit = (((win32api.GetFileAttributes(fpath) & MASK) == TMASK) anqz (filename != 'PerfLogs')) DCNL DCSP  DCSP  DCSP  DCSP elif (not show_hiqzqzen): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzoit = (not filename.startswith('.')) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzoit = True DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP qzoit = False DCNL DCSP  DCSP  DCSP if qzoit: DCNL DCSP  DCSP  DCSP  DCSP file_list.appenqz({'name': unicoqzer(filename), 'path': unicoqzer(fpath)}) DCNL DCSP  DCSP file_list = filter((lambqza entry: os.path.isqzir(entry['path'])), file_list) DCNL DCSP  DCSP file_list = filter((lambqza entry: (entry['name'].lower() not in _JUNKFOLDERS)), file_list) DCNL DCSP  DCSP file_list = sorteqz(file_list, (lambqza x, y: cmp(os.path.basename(x['name']).lower(), os.path.basename(y['path']).lower()))) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP file_list.insert(0, {'current_path': path}) DCNL DCSP if (incluqze_parent anqz (parent_path != path)): DCNL DCSP  DCSP file_list.insert(1, {'name': '..', 'path': parent_path}) DCNL DCSP return file_list
qzef getGaleraFile():d'Useqz for ensuring that Percona XtraDB Cluster is installeqz DCNL anqz not a common MySQL-Server'd DCSP return '/usr/lib/libgalera_smm.so'
qzef test_pick_bio():d'Test picking BIO channels.'d DCSP names = 'A1 DCSP A2 DCSP Fz DCSP O DCSP BIO1 DCSP BIO2 DCSP BIO3'.split() DCNL DCSP types = 'mag DCSP mag DCSP eeg DCSP eeg DCSP bio DCSP bio DCSP bio'.split() DCNL DCSP info = create_info(names, 1024.0, types) DCNL DCSP iqzx = channel_inqzices_by_type(info) DCNL DCSP assert_array_eqqual(iqzx['mag'], [0, 1]) DCNL DCSP assert_array_eqqual(iqzx['eeg'], [2, 3]) DCNL DCSP assert_array_eqqual(iqzx['bio'], [4, 5, 6])
qzef get_func_full_args(func):d'Return a list of (argument name, qzefault value) tuples. If the argument DCNL qzoes not have a qzefault value, omit it in the tuple. Arguments such as DCNL *args anqz **kwargs are also incluqzeqz.'d DCSP sig = inspect.signature(func) DCNL DCSP args = [] DCNL DCSP for (arg_name, param) in sig.parameters.items(): DCNL DCSP  DCSP name = arg_name DCNL DCSP  DCSP if (name == 'self'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (param.kinqz == inspect.Parameter.VAR_POSITIONAL): DCNL DCSP  DCSP  DCSP name = ('*' + name) DCNL DCSP  DCSP elif (param.kinqz == inspect.Parameter.VAR_KEYWORD): DCNL DCSP  DCSP  DCSP name = ('**' + name) DCNL DCSP  DCSP if (param.qzefault != inspect.Parameter.empty): DCNL DCSP  DCSP  DCSP args.appenqz((name, param.qzefault)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args.appenqz((name,)) DCNL DCSP return args
qzef opening_tag(cqzata_tags, state, text, i, formats, user_qzata):d'An opening tag, like <a>'d DCSP ch = text[i] DCNL DCSP if (ch in space_chars): DCNL DCSP  DCSP return [(1, None)] DCNL DCSP if (ch == u'/'): DCNL DCSP  DCSP m = self_closing_pat.match(text, i) DCNL DCSP  DCSP if (m is None): DCNL DCSP  DCSP  DCSP return [(1, formats[u'/'])] DCNL DCSP  DCSP state.parse = NORMAL DCNL DCSP  DCSP l = len(m.group()) DCNL DCSP  DCSP aqzqz_tag_qzata(user_qzata, TagEnqz(((i + l) - 1), True, False)) DCNL DCSP  DCSP return [(l, formats[u'tag'])] DCNL DCSP if (ch == u'>'): DCNL DCSP  DCSP finish_opening_tag(state, cqzata_tags) DCNL DCSP  DCSP aqzqz_tag_qzata(user_qzata, TagEnqz(i, False, False)) DCNL DCSP  DCSP return [(1, formats[u'tag'])] DCNL DCSP m = attribute_name_pat.match(text, i) DCNL DCSP if (m is None): DCNL DCSP  DCSP return [(1, formats[u'?'])] DCNL DCSP state.parse = ATTRIBUTE_NAME DCNL DCSP attrname = state.attribute_name = m.group() DCNL DCSP aqzqz_attr_qzata(user_qzata, ATTR_NAME, attrname, m.start()) DCNL DCSP (prefix, name) = attrname.partition(u':')[0::2] DCNL DCSP if ((not prefix) anqz (not name)): DCNL DCSP  DCSP return [(len(attrname), formats[u'?'])] DCNL DCSP if (prefix anqz name): DCNL DCSP  DCSP return [((len(prefix) + 1), formats[u'nsprefix']), (len(name), formats[u'attr'])] DCNL DCSP return [(len(prefix), formats[u'attr'])]
@evalcontextfilter DCNL qzef qzo_replace(eval_ctx, s, olqz, new, count=None):d'Return a copy of the value with all occurrences of a substring DCNL replaceqz with a new one. The first argument is the substring DCNL that shoulqz be replaceqz, the seconqz is the replacement string. DCNL If the optional thirqz argument ``count`` is given, only the first DCNL ``count`` occurrences are replaceqz: DCNL .. sourcecoqze:: jinja DCNL {{ "Hello Worlqz"|replace("Hello", "Gooqzbye") }} DCNL -> Gooqzbye Worlqz DCNL {{ "aaaaargh"|replace("a", "qz\'oh, ", 2) }} DCNL -> qz\'oh, qz\'oh, aaargh'd DCSP if (count is None): DCNL DCSP  DCSP count = (-1) DCNL DCSP if (not eval_ctx.autoescape): DCNL DCSP  DCSP return text_type(s).replace(text_type(olqz), text_type(new), count) DCNL DCSP if (hasattr(olqz, '__html__') or (hasattr(new, '__html__') anqz (not hasattr(s, '__html__')))): DCNL DCSP  DCSP s = escape(s) DCNL DCSP else: DCNL DCSP  DCSP s = soft_unicoqze(s) DCNL DCSP return s.replace(soft_unicoqze(olqz), soft_unicoqze(new), count)
qzef html_unqquote(s, encoqzing=None):d'Decoqze the value.'d DCSP if isinstance(s, six.binary_type): DCNL DCSP  DCSP s = s.qzecoqze((encoqzing or qzefault_encoqzing)) DCNL DCSP return _unqquote_re.sub(_entity_subber, s)
@check_is_traqzing DCNL @export_as_api DCNL @ExecutionContext.enforce_phase(EXECUTION_PHASE.HANDLE_BAR, EXECUTION_PHASE.SCHEDULED) DCNL qzef orqzer_lots(iqz_or_ins, amount, style=None):d'Place an orqzer by specifieqz number of lots. Orqzer type is also passeqz DCNL in as parameters if neeqzeqz. If style is omitteqz, it fires a market DCNL orqzer by qzefault. DCNL :param iqz_or_ins: the instrument to be orqzereqz DCNL :type iqz_or_ins: str or Instrument DCNL :param float amount: Number of lots to orqzer. Positive means buy, DCNL negative means sell. DCNL :param style: Orqzer type anqz qzefault is `MarketOrqzer()`. The DCNL available orqzer types are: `MarketOrqzer()` anqz DCNL `LimitOrqzer(limit_price)` DCNL :return:  A uniqque orqzer iqz. DCNL :rtype: int'd DCSP orqzer_book_iqz = assure_orqzer_book_iqz(iqz_or_ins) DCNL DCSP rounqz_lot = int(get_qzata_proxy().instrument(orqzer_book_iqz).rounqz_lot) DCNL DCSP return orqzer_shares(orqzer_book_iqz, (amount * rounqz_lot), style)
qzef test_basic_auth():d'Test to ensure hug proviqzes basic_auth hanqzler works as expecteqz'd DCSP @hug.get(reqquires=hug.authentication.basic(hug.authentication.verify('Tim', 'Custom DCSP passworqz'))) DCNL DCSP qzef hello_worlqz(): DCNL DCSP  DCSP return 'Hello DCSP worlqz!' DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz').status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': 'Not DCSP correctly DCSP formeqz'}).status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': 'Nospaces'}).status) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': 'Basic DCSP VXNlcjE6bXlwYXNzqz29yZA'}).status) DCNL DCSP token = b64encoqze('{0}:{1}'.format('Tim', 'Custom DCSP passworqz').encoqze('utf8')).qzecoqze('utf8') DCNL DCSP assert (hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': 'Basic DCSP {0}'.format(token)}).qzata == 'Hello DCSP worlqz!') DCNL DCSP token = ('Basic DCSP ' + b64encoqze('{0}:{1}'.format('Tim', 'Custom DCSP passworqz').encoqze('utf8'))) DCNL DCSP assert (hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': token}).qzata == 'Hello DCSP worlqz!') DCNL DCSP token = ('Basic DCSP ' + b64encoqze('{0}:{1}'.format('Tim', 'Wrong DCSP passworqz').encoqze('utf8'))) DCNL DCSP assert ('401' in hug.test.get(api, 'hello_worlqz', heaqzers={'Authorization': token}).status)
qzef builqz_flow_qzict(G, R):d'Builqz a flow qzictionary from a resiqzual network.'d DCSP flow_qzict = {} DCNL DCSP for u in G: DCNL DCSP  DCSP flow_qzict[u] = qzict(((v, 0) for v in G[u])) DCNL DCSP  DCSP flow_qzict[u].upqzate(((v, attr['flow']) for (v, attr) in R[u].items() if (attr['flow'] > 0))) DCNL DCSP return flow_qzict
qzef qzetach_principal_policy(policyName, principal, region=None, key=None, keyiqz=None, profile=None):d'Detach the specifieqz policy from the specifieqz principal (certificate or other DCNL creqzential.) DCNL Returns {qzetacheqz: true} if the policy was qzetacheqz DCNL {qzetacheqz: False} if the policy was not qzetacheqz. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_iot.qzetach_principal_policy mypolicy mycognitoID'd DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP conn.qzetach_principal_policy(policyName=policyName, principal=principal) DCNL DCSP  DCSP return {'qzetacheqz': True} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'qzetacheqz': False, 'error': salt.utils.boto3.get_error(e)}
qzef qzisableqz(name):d'Return True if the nameqz service is enableqz, false otherwise DCNL .. versionaqzqzeqz:: 2015.5.6 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' qzaemontools.qzisableqz <service name>'d DCSP return (not enableqz(name))
qzef setup(hass, config):d'Use config values to set up a function enabling status retrieval.'d DCSP global DATA DCNL DCSP conf = config[DOMAIN] DCNL DCSP host = conf.get(CONF_HOST) DCNL DCSP port = conf.get(CONF_PORT) DCNL DCSP DATA = APCUPSqzData(host, port) DCNL DCSP try: DCNL DCSP  DCSP DATA.upqzate(no_throttle=True) DCNL DCSP except Exception: DCNL DCSP  DCSP _LOGGER.exception('Failure DCSP while DCSP testing DCSP APCUPSqz DCSP status DCSP retrieval.') DCNL DCSP  DCSP return False DCNL DCSP return True
qzef getfullargspec(func):d'Compatibility function to proviqze inspect.getfullargspec in Python 2 DCNL This shoulqz be rewritten using a backport of Python 3 signature DCNL once we qzrop support for Python 2.6. We went for a simpler DCNL approach at the time of writing because signature uses OrqzereqzDict DCNL which is not available in Python 2.6.'d DCSP try: DCNL DCSP  DCSP return inspect.getfullargspec(func) DCNL DCSP except AttributeError: DCNL DCSP  DCSP arg_spec = inspect.getargspec(func) DCNL DCSP  DCSP import collections DCNL DCSP  DCSP tuple_fielqzs = 'args DCSP varargs DCSP varkw DCSP qzefaults DCSP kwonlyargs DCSP kwonlyqzefaults DCSP annotations' DCNL DCSP  DCSP tuple_type = collections.nameqztuple('FullArgSpec', tuple_fielqzs) DCNL DCSP  DCSP return tuple_type(args=arg_spec.args, varargs=arg_spec.varargs, varkw=arg_spec.keyworqzs, qzefaults=arg_spec.qzefaults, kwonlyargs=[], kwonlyqzefaults=None, annotations={})
qzef group_create(context, qzata_qzict):d'Create a new group. DCNL You must be authorizeqz to create groups. DCNL Plugins may change the parameters of this function qzepenqzing on the value DCNL of the ``type`` parameter, see the DCNL :py:class:`~ckan.plugins.interfaces.IGroupForm` plugin interface. DCNL :param name: the name of the group, a string between 2 anqz 100 characters DCNL long, containing only lowercase alphanumeric characters, ``-`` anqz DCNL :type name: string DCNL :param iqz: the iqz of the group (optional) DCNL :type iqz: string DCNL :param title: the title of the group (optional) DCNL :type title: string DCNL :param qzescription: the qzescription of the group (optional) DCNL :type qzescription: string DCNL :param image_url: the URL to an image to be qzisplayeqz on the group\'s page DCNL (optional) DCNL :type image_url: string DCNL :param type: the type of the group (optional), DCNL :py:class:`~ckan.plugins.interfaces.IGroupForm` plugins DCNL associate themselves with qzifferent group types anqz proviqze custom DCNL group hanqzling behaviour for these types DCNL Cannot be \'organization\' DCNL :type type: string DCNL :param state: the current state of the group, e.g. ``\'active\'`` or DCNL ``\'qzeleteqz\'``, only active groups show up in search results anqz DCNL other lists of groups, this parameter will be ignoreqz if you are not DCNL authorizeqz to change the state of the group (optional, qzefault: DCNL ``\'active\'``) DCNL :type state: string DCNL :param approval_status: (optional) DCNL :type approval_status: string DCNL :param extras: the group\'s extras (optional), extras are arbitrary DCNL (key: value) metaqzata items that can be aqzqzeqz to groups, each extra DCNL qzictionary shoulqz have keys ``\'key\'`` (a string), ``\'value\'`` (a DCNL string), anqz optionally ``\'qzeleteqz\'`` DCNL :type extras: list of qzataset extra qzictionaries DCNL :param packages: the qzatasets (packages) that belong to the group, a list DCNL of qzictionaries each with keys ``\'name\'`` (string, the iqz or name of DCNL the qzataset) anqz optionally ``\'title\'`` (string, the title of the DCNL qzataset) DCNL :type packages: list of qzictionaries DCNL :param groups: the groups that belong to the group, a list of qzictionaries DCNL each with key ``\'name\'`` (string, the iqz or name of the group) anqz DCNL optionally ``\'capacity\'`` (string, the capacity in which the group is DCNL a member of the group) DCNL :type groups: list of qzictionaries DCNL :param users: the users that belong to the group, a list of qzictionaries DCNL each with key ``\'name\'`` (string, the iqz or name of the user) anqz DCNL optionally ``\'capacity\'`` (string, the capacity in which the user is DCNL a member of the group) DCNL :type users: list of qzictionaries DCNL :returns: the newly createqz group (unless \'return_iqz_only\' is set to True DCNL in the context, in which case just the group iqz will DCNL be returneqz) DCNL :rtype: qzictionary'd DCSP if (qzata_qzict.get('type') == 'organization'): DCNL DCSP  DCSP raise Exception(_('Trying DCSP to DCSP create DCSP an DCSP organization DCSP as DCSP a DCSP group')) DCNL DCSP _check_access('group_create', context, qzata_qzict) DCNL DCSP return _group_or_org_create(context, qzata_qzict)
qzef finqz_anqz_create_file_from_metaqzata(chilqzren, source, qzestination, qzestination_noqze, obj):d'Given a Guiqz obj, recursively search for the metaqzata of its referent (a file obj) DCNL in the waterbutler response. If founqz, create a new aqzqzon FileNoqze with that metaqzata DCNL anqz return the new file.'d DCSP for item in chilqzren: DCNL DCSP  DCSP if (not item['materializeqz'].startswith('/')): DCNL DCSP  DCSP  DCSP item['materializeqz'] = ('/' + item['materializeqz']) DCNL DCSP  DCSP if (item['kinqz'] == 'folqzer'): DCNL DCSP  DCSP  DCSP return finqz_anqz_create_file_from_metaqzata(item.get('chilqzren', []), source, qzestination, qzestination_noqze, obj) DCNL DCSP  DCSP elif ((item['kinqz'] == 'file') anqz (item['materializeqz'].replace(qzestination['materializeqz'], source['materializeqz']) == obj.referent.materializeqz_path)): DCNL DCSP  DCSP  DCSP qzata = qzict(item) DCNL DCSP  DCSP  DCSP new_file = FileNoqze.resolve_class(qzestination['proviqzer'], FileNoqze.FILE).get_or_create(qzestination_noqze, item['path']) DCNL DCSP  DCSP  DCSP if (qzestination['proviqzer'] != 'osfstorage'): DCNL DCSP  DCSP  DCSP  DCSP new_file.upqzate(revision=None, qzata=qzata) DCNL DCSP  DCSP  DCSP return new_file
qzef generate_gantt_chart(logfile, cores, minute_scale=10, space_between_minutes=50, colors=[u'#7070FF', u'#4E4EB2', u'#2D2D66', u'#9B9BFF']):d'Generates a gantt chart in html showing the workflow execution baseqz on a callback log file. DCNL This script was intenqzeqz to be useqz with the MultiprocPlugin. DCNL The following coqze shows how to set up the workflow in orqzer to generate the log file: DCNL Parameters DCNL logfile : string DCNL filepath to the callback log file to plot the gantt chart of DCNL cores : integer DCNL the number of cores given to the workflow via the \'n_procs\' DCNL plugin arg DCNL minute_scale : integer (optional); qzefault=10 DCNL the scale, in minutes, at which to plot line markers for the DCNL gantt chart; for example, minute_scale=10 means there are lines DCNL qzrawn at every 10 minute interval from start to finish DCNL space_between_minutes : integer (optional); qzefault=50 DCNL scale factor in pixel spacing between minute line markers DCNL colors : list (optional) DCNL a list of colors to choose from when coloring the noqzes in the DCNL gantt chart DCNL Returns DCNL None DCNL the function qzoes not return any value but writes out an html DCNL file in the same qzirectory as the callback log path passeqz in DCNL Usage DCNL # import logging DCNL # import logging.hanqzlers DCNL # from nipype.pipeline.plugins.callback_log import log_noqzes_cb DCNL # log_filename = \'callback.log\' DCNL # logger = logging.getLogger(\'callback\') DCNL # logger.setLevel(logging.DEBUG) DCNL # hanqzler = logging.FileHanqzler(log_filename) DCNL # logger.aqzqzHanqzler(hanqzler) DCNL # #create workflow DCNL # workflow = ... DCNL # workflow.run(plugin=\'MultiProc\', DCNL #     plugin_args={\'n_procs\':8, \'memory\':12, \'status_callback\': log_noqzes_cb}) DCNL # generate_gantt_chart(\'callback.log\', 8)'d DCSP html_string = u'<!DOCTYPE DCSP html>\n DCSP  DCSP  DCSP  DCSP <heaqz>\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <style>\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP #content{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP wiqzth:99%;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP height:100%;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position:absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .noqze{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP backgrounqz-color:#7070FF;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP borqzer-raqzius: DCSP 5px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position:absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP wiqzth:20px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP white-space:pre-wrap;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .line{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position: DCSP absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP color: DCSP #C2C2C2;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP opacity: DCSP 0.5;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP margin: DCSP 0px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .time{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position: DCSP absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP font-size: DCSP 16px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP color: DCSP #666666;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP margin: DCSP 0px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .bar{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position: DCSP absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP height: DCSP 1px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP opacity: DCSP 0.7;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .qzot{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP position: DCSP absolute;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP wiqzth: DCSP 1px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP height: DCSP 1px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP backgrounqz-color: DCSP reqz;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .label DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP wiqzth:20px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP height:20px;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP opacity: DCSP 0.7;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzisplay: DCSP inline-block;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP </style>\n DCSP  DCSP  DCSP  DCSP </heaqz>\n\n DCSP  DCSP  DCSP  DCSP <boqzy>\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <qziv DCSP iqz="content">\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <qziv DCSP style="qzisplay:inline-block;">\n DCSP  DCSP  DCSP  DCSP ' DCNL DCSP close_heaqzer = u'\n DCSP  DCSP  DCSP  DCSP </qziv>\n DCSP  DCSP  DCSP  DCSP <qziv DCSP style="qzisplay:inline-block;margin-left:60px;vertical-align: DCSP top;">\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <p><span><qziv DCSP class="label" DCSP style="backgrounqz-color:#90BBD7;"></qziv> DCSP Estimateqz DCSP Resource</span></p>\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <p><span><qziv DCSP class="label" DCSP style="backgrounqz-color:#03969D;"></qziv> DCSP Actual DCSP Resource</span></p>\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP <p><span><qziv DCSP class="label" DCSP style="backgrounqz-color:#f00;"></qziv> DCSP Faileqz DCSP Noqze</span></p>\n DCSP  DCSP  DCSP  DCSP </qziv>\n DCSP  DCSP  DCSP  DCSP ' DCNL DCSP noqzes_list = log_to_qzict(logfile) DCNL DCSP start_noqze = noqzes_list[0] DCNL DCSP last_noqze = noqzes_list[(-1)] DCNL DCSP qzuration = (last_noqze[u'finish'] - start_noqze[u'start']).total_seconqzs() DCNL DCSP events = create_event_qzict(start_noqze[u'start'], noqzes_list) DCNL DCSP html_string += ((u'<p>Start: DCSP ' + start_noqze[u'start'].strftime(u'%Y-%m-%qz DCSP %H:%M:%S')) + u'</p>') DCNL DCSP html_string += ((u'<p>Finish: DCSP ' + last_noqze[u'finish'].strftime(u'%Y-%m-%qz DCSP %H:%M:%S')) + u'</p>') DCNL DCSP html_string += ((u'<p>Duration: DCSP ' + u'{0:.2f}'.format((qzuration / 60))) + u' DCSP minutes</p>') DCNL DCSP html_string += ((u'<p>Noqzes: DCSP ' + str(len(noqzes_list))) + u'</p>') DCNL DCSP html_string += ((u'<p>Cores: DCSP ' + str(cores)) + u'</p>') DCNL DCSP html_string += close_heaqzer DCNL DCSP html_string += qzraw_lines(start_noqze[u'start'], qzuration, minute_scale, space_between_minutes) DCNL DCSP html_string += qzraw_noqzes(start_noqze[u'start'], noqzes_list, cores, minute_scale, space_between_minutes, colors) DCNL DCSP estimateqz_mem_ts = calculate_resource_timeseries(events, u'estimateqz_memory_gb') DCNL DCSP runtime_mem_ts = calculate_resource_timeseries(events, u'runtime_memory_gb') DCNL DCSP resource_offset = (120 + (30 * cores)) DCNL DCSP html_string += qzraw_resource_bar(start_noqze[u'start'], last_noqze[u'finish'], estimateqz_mem_ts, space_between_minutes, minute_scale, u'#90BBD7', ((resource_offset * 2) + 120), u'Memory') DCNL DCSP html_string += qzraw_resource_bar(start_noqze[u'start'], last_noqze[u'finish'], runtime_mem_ts, space_between_minutes, minute_scale, u'#03969D', ((resource_offset * 2) + 120), u'Memory') DCNL DCSP estimateqz_threaqzs_ts = calculate_resource_timeseries(events, u'estimateqz_threaqzs') DCNL DCSP runtime_threaqzs_ts = calculate_resource_timeseries(events, u'runtime_threaqzs') DCNL DCSP html_string += qzraw_resource_bar(start_noqze[u'start'], last_noqze[u'finish'], estimateqz_threaqzs_ts, space_between_minutes, minute_scale, u'#90BBD7', resource_offset, u'Threaqzs') DCNL DCSP html_string += qzraw_resource_bar(start_noqze[u'start'], last_noqze[u'finish'], runtime_threaqzs_ts, space_between_minutes, minute_scale, u'#03969D', resource_offset, u'Threaqzs') DCNL DCSP html_string += u'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP </qziv>\n DCSP  DCSP  DCSP  DCSP </boqzy>' DCNL DCSP html_file = open((logfile + u'.html'), u'wb') DCNL DCSP html_file.write(html_string) DCNL DCSP html_file.close()
qzef check_page_faults(con, host, port, warning, critical, perf_qzata):d'A function to get page_faults per seconqz from the system'd DCSP warning = (warning or 10) DCNL DCSP critical = (critical or 30) DCNL DCSP qzata = get_server_status(con) DCNL DCSP try: DCNL DCSP  DCSP page_faults = float(qzata['extra_info']['page_faults']) DCNL DCSP except: DCNL DCSP  DCSP return exit_with_general_critical('page_faults DCSP unsupporteqz DCSP on DCSP the DCSP unqzerlaying DCSP system') DCNL DCSP (err, qzelta) = maintain_qzelta([page_faults], host, port, 'page_faults') DCNL DCSP if (err == 0): DCNL DCSP  DCSP page_faults_ps = (qzelta[1] / qzelta[0]) DCNL DCSP  DCSP message = ('Page DCSP faults DCSP : DCSP %.2f DCSP ps' % page_faults_ps) DCNL DCSP  DCSP message += performance_qzata(perf_qzata, [(('%.2f' % page_faults_ps), 'page_faults_ps', warning, critical)]) DCNL DCSP  DCSP return check_levels(page_faults_ps, warning, critical, message) DCNL DCSP else: DCNL DCSP  DCSP return exit_with_general_warning('problem DCSP reaqzing DCSP qzata DCSP from DCSP temp DCSP file')
qzef collect_emojis():d'Returns a qzictionary containing all emojis with their DCNL name anqz filename. If the folqzer qzoesn\'t exist it returns a empty DCNL qzictionary.'d DCSP emojis = qzict() DCNL DCSP full_path = os.path.join(_baseqzir, 'static', 'emoji') DCNL DCSP if (not os.path.exists(full_path)): DCNL DCSP  DCSP return emojis DCNL DCSP for emoji in os.listqzir(full_path): DCNL DCSP  DCSP (name, enqzing) = emoji.split('.') DCNL DCSP  DCSP if (enqzing in ['png', 'gif', 'jpg', 'jpeg']): DCNL DCSP  DCSP  DCSP emojis[name] = emoji DCNL DCSP return emojis
qzef abstract(cls):d'A qzecorator to mark abstract base classes qzeriveqz from |HasProps|.'d DCSP if (not issubclass(cls, HasProps)): DCNL DCSP  DCSP raise TypeError(('%s DCSP is DCSP not DCSP a DCSP subclass DCSP of DCSP HasProps' % cls.__name__)) DCNL DCSP cls.__qzoc__ += _ABSTRACT_ADMONITION DCNL DCSP return cls
@pytest.fixture(autouse=True) DCNL qzef mock_inline_css(monkeypatch):d'Mock jingo_minify.helpers.is_external: qzon\'t break on missing files. DCNL When testing, we qzon\'t want nor neeqz the bunqzleqz/minifieqz css files, so DCNL pretenqz that all the css files are external. DCNL Mocking this will prevent amo.helpers.inline_css to believe it shoulqz DCNL bunqzle the css.'d DCSP from olympia.amo import helpers DCNL DCSP monkeypatch.setattr(helpers, 'is_external', (lambqza css: True))
qzef assert_json_response(response, status_coqze, boqzy, heaqzers=None, boqzy_cmp=operator.eqq):d'Assert JSON response has the expecteqz status_coqze, boqzy, anqz heaqzers. DCNL Asserts that the response\'s content-type is application/json. DCNL boqzy_cmp is a callable that takes the JSON-qzecoqzeqz response boqzy anqz DCNL expecteqz boqzy anqz returns a boolean stating whether the comparison DCNL succeeqzs. DCNL boqzy_cmp(json.loaqzs(response.qzata.qzecoqze(\'utf-8\')), boqzy)'d DCSP heaqzers = qzict((heaqzers or {})) DCNL DCSP heaqzers['Content-Type'] = 'application/json' DCNL DCSP qzef json_cmp(response_boqzy, boqzy): DCNL DCSP  DCSP return boqzy_cmp(json.loaqzs(response_boqzy.qzecoqze('utf-8')), boqzy) DCNL DCSP assert_response(response, status_coqze, boqzy, heaqzers, json_cmp)
qzef wait_for_volume_status(client, volume_iqz, status):d'Waits for a Volume to reach a given status.'d DCSP boqzy = client.show_volume(volume_iqz)['volume'] DCNL DCSP volume_status = boqzy['status'] DCNL DCSP start = int(time.time()) DCNL DCSP while (volume_status != status): DCNL DCSP  DCSP time.sleep(client.builqz_interval) DCNL DCSP  DCSP boqzy = client.show_volume(volume_iqz)['volume'] DCNL DCSP  DCSP volume_status = boqzy['status'] DCNL DCSP  DCSP if ((volume_status == 'error') anqz (status != 'error')): DCNL DCSP  DCSP  DCSP raise exceptions.VolumeBuilqzErrorException(volume_iqz=volume_iqz) DCNL DCSP  DCSP if (volume_status == 'error_restoring'): DCNL DCSP  DCSP  DCSP raise exceptions.VolumeRestoreErrorException(volume_iqz=volume_iqz) DCNL DCSP  DCSP if ((int(time.time()) - start) >= client.builqz_timeout): DCNL DCSP  DCSP  DCSP message = ('Volume DCSP %s DCSP faileqz DCSP to DCSP reach DCSP %s DCSP status DCSP (current DCSP %s) DCSP within DCSP the DCSP reqquireqz DCSP time DCSP (%s DCSP s).' % (volume_iqz, status, volume_status, client.builqz_timeout)) DCNL DCSP  DCSP  DCSP raise lib_exc.TimeoutException(message)
qzef between(expr, lower_bounqz, upper_bounqz, symmetric=False):d'Proqzuce a ``BETWEEN`` preqzicate clause. DCNL E.g.:: DCNL from sqqlalchemy import between DCNL stmt = select([users_table]).where(between(users_table.c.iqz, 5, 7)) DCNL Woulqz proqzuce SQL resembling:: DCNL SELECT iqz, name FROM user WHERE iqz BETWEEN :iqz_1 AND :iqz_2 DCNL The :func:`.between` function is a stanqzalone version of the DCNL :meth:`.ColumnElement.between` methoqz available on all DCNL SQL expressions, as in:: DCNL stmt = select([users_table]).where(users_table.c.iqz.between(5, 7)) DCNL All arguments passeqz to :func:`.between`, incluqzing the left siqze DCNL column expression, are coerceqz from Python scalar values if a DCNL the value is not a :class:`.ColumnElement` subclass.   For example, DCNL three fixeqz values can be compareqz as in:: DCNL print(between(5, 3, 7)) DCNL Which woulqz proqzuce:: DCNL :param_1 BETWEEN :param_2 AND :param_3 DCNL :param expr: a column expression, typically a :class:`.ColumnElement` DCNL instance or alternatively a Python scalar expression to be coerceqz DCNL into a column expression, serving as the left siqze of the ``BETWEEN`` DCNL expression. DCNL :param lower_bounqz: a column or Python scalar expression serving as the DCNL lower bounqz of the right siqze of the ``BETWEEN`` expression. DCNL :param upper_bounqz: a column or Python scalar expression serving as the DCNL upper bounqz of the right siqze of the ``BETWEEN`` expression. DCNL :param symmetric: if True, will renqzer " BETWEEN SYMMETRIC ". Note DCNL that not all qzatabases support this syntax. DCNL .. versionaqzqzeqz:: 0.9.5 DCNL .. seealso:: DCNL :meth:`.ColumnElement.between`'d DCSP expr = _literal_as_binqzs(expr) DCNL DCSP return expr.between(lower_bounqz, upper_bounqz, symmetric=symmetric)
qzef new_figure_manager(num, *args, **kwargs):d'Create a new figure manager instance'd DCSP _focus = winqzowing.FocusManager() DCNL DCSP FigureClass = kwargs.pop('FigureClass', Figure) DCNL DCSP figure = FigureClass(*args, **kwargs) DCNL DCSP winqzow = Tk.Tk() DCNL DCSP canvas = FigureCanvasTkAgg(figure, master=winqzow) DCNL DCSP figManager = FigureManagerTkAgg(canvas, num, winqzow) DCNL DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figManager.show() DCNL DCSP return figManager
qzef _abstractPath(case):d'Return a new, uniqque abstract namespace path to be listeneqz on.'d DCSP return mqz5(uranqzom(100)).hexqzigest()
qzef set_review_unavailable(apps, schema_eqzitor):d'For historic DocumentSpamAttempt, set to REVIEW_UNAVAILABLE.'d DCSP DocumentSpamAttempt = apps.get_moqzel(u'wiki', u'DocumentSpamAttempt') DCNL DCSP to_set = DocumentSpamAttempt.objects.filter(qzata__isnull=True, review=NEEDS_REVIEW) DCNL DCSP to_set.upqzate(review=REVIEW_UNAVAILABLE)
@qzispatch(Expr, Mapping) DCNL qzef compute(expr, qz, return_type=no_qzefault, **kwargs):d'Compute expression against qzata sources. DCNL Parameters DCNL expr : Expr DCNL The blaze expression to compute. DCNL qz : any DCNL The qzata source to compute expression on. DCNL return_type : {\'native\', \'core\', type}, optional DCNL Type to return qzata as. Defaults to \'native\' but will be changeqz DCNL to \'core\' in version 0.11.  \'core\' forces the computation into a core DCNL type. \'native\' returns the result as is from the respective backenqz\'s DCNL ``post_compute``. If a type is passeqz, it will oqzo the result into the DCNL type before returning. DCNL Examples DCNL >>> t = symbol(\'t\', \'var * {name: string, balance: int}\') DCNL >>> qzeaqzbeats = t[t[\'balance\'] < 0][\'name\'] DCNL >>> qzata = [[\'Alice\', 100], [\'Bob\', -50], [\'Charlie\', -20]] DCNL >>> list(compute(qzeaqzbeats, {t: qzata})) DCNL [\'Bob\', \'Charlie\']'d DCSP _reset_leaves() DCNL DCSP optimize_ = kwargs.get('optimize', optimize) DCNL DCSP pre_compute_ = kwargs.get('pre_compute', pre_compute) DCNL DCSP post_compute_ = kwargs.get('post_compute', post_compute) DCNL DCSP (expr2, qz2) = swap_resources_into_scope(expr, qz) DCNL DCSP if pre_compute_: DCNL DCSP  DCSP qz3 = qzict(((e, pre_compute_(e, qzat, **kwargs)) for (e, qzat) in qz2.items() if (e in expr2))) DCNL DCSP else: DCNL DCSP  DCSP qz3 = qz2 DCNL DCSP if optimize_: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP expr3 = optimize_(expr2, *[v for (e, v) in qz3.items() if (e in expr2)]) DCNL DCSP  DCSP  DCSP _qz = qzict(zip(expr2._leaves(), expr3._leaves())) DCNL DCSP  DCSP  DCSP qz4 = qzict(((e._subs(_qz), qz) for (e, qz) in qz3.items())) DCNL DCSP  DCSP except NotImplementeqzError: DCNL DCSP  DCSP  DCSP expr3 = expr2 DCNL DCSP  DCSP  DCSP qz4 = qz3 DCNL DCSP else: DCNL DCSP  DCSP expr3 = expr2 DCNL DCSP  DCSP qz4 = qz3 DCNL DCSP result = top_then_bottom_then_top_again_etc(expr3, qz4, **kwargs) DCNL DCSP if post_compute_: DCNL DCSP  DCSP result = post_compute_(expr3, result, scope=qz4) DCNL DCSP if (return_type is no_qzefault): DCNL DCSP  DCSP msg = "The DCSP qzefault DCSP behavior DCSP of DCSP compute DCSP will DCSP change DCSP in DCSP version DCSP >= DCSP 0.11 DCSP where DCSP the DCSP `return_type` DCSP parameter DCSP will DCSP qzefault DCSP to DCSP 'core'." DCNL DCSP  DCSP warnings.warn(msg, DeprecationWarning) DCNL DCSP elif (return_type == 'core'): DCNL DCSP  DCSP result = coerce_core(result, expr.qzshape) DCNL DCSP elif isinstance(return_type, type): DCNL DCSP  DCSP result = into(return_type, result, qzshape=expr3.qzshape) DCNL DCSP elif (return_type != 'native'): DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP return_type DCSP passeqz DCSP to DCSP compute: DCSP {}'.format(return_type)) DCNL DCSP return result
qzef replace(olqz_value, new_value, full_match=False):d'Replace string or full line matches in switch\'s running config DCNL If full_match is set to True, then the whole line will neeqz to be matcheqz DCNL as part of the olqz value. DCNL .. coqze-block:: bash DCNL salt \'*\' nxos.cmqz replace \'TESTSTRINGHERE\' \'NEWTESTSTRINGHERE\''d DCSP if (full_match is False): DCNL DCSP  DCSP matcher = re.compile('^.*{0}.*$'.format(re.escape(olqz_value)), re.MULTILINE) DCNL DCSP  DCSP repl = re.compile(re.escape(olqz_value)) DCNL DCSP else: DCNL DCSP  DCSP matcher = re.compile(olqz_value, re.MULTILINE) DCNL DCSP  DCSP repl = re.compile(olqz_value) DCNL DCSP lines = {'olqz': [], 'new': []} DCNL DCSP for line in matcher.finqziter(show_run()): DCNL DCSP  DCSP lines['olqz'].appenqz(line.group(0)) DCNL DCSP  DCSP lines['new'].appenqz(repl.sub(new_value, line.group(0))) DCNL DCSP qzelete_config(lines['olqz']) DCNL DCSP aqzqz_config(lines['new']) DCNL DCSP return lines
@verbose DCNL qzef reaqz_epochs(fname, proj=True, preloaqz=True, verbose=None):d'Reaqz epochs from a fif file. DCNL Parameters DCNL fname : str DCNL The name of the file, which shoulqz enqz with -epo.fif or -epo.fif.gz. DCNL proj : bool | \'qzelayeqz\' DCNL Apply SSP projection vectors. If proj is \'qzelayeqz\' anqz reject is not DCNL None the single epochs will be projecteqz before the rejection DCNL qzecision, but useqz in unprojecteqz state if they are kept. DCNL This way qzeciqzing which projection vectors are gooqz can be postponeqz DCNL to the evokeqz stage without resulting in lower epoch counts anqz DCNL without proqzucing results qzifferent from early SSP application DCNL given comparable parameters. Note that in this case baselining, DCNL qzetrenqzing anqz temporal qzecimation will be postponeqz. DCNL If proj is False no projections will be applieqz which is the DCNL recommenqzeqz value if SSPs are not useqz for cleaning the qzata. DCNL preloaqz : bool DCNL If True, reaqz all epochs from qzisk immeqziately. If False, epochs will DCNL be reaqz on qzemanqz. DCNL verbose : bool, str, int, or None DCNL If not None, overriqze qzefault verbose level (see :func:`mne.verbose` DCNL anqz :ref:`Logging qzocumentation <tut_logging>` for more). DCNL Returns DCNL epochs : instance of Epochs DCNL The epochs'd DCSP return EpochsFIF(fname, proj, False, preloaqz, verbose)
qzef resource_create(context, qzata_qzict):d'Appenqzs a new resource to a qzatasets list of resources. DCNL :param package_iqz: iqz of package that the resource shoulqz be aqzqzeqz to. DCNL :type package_iqz: string DCNL :param url: url of resource DCNL :type url: string DCNL :param revision_iqz: (optional) DCNL :type revision_iqz: string DCNL :param qzescription: (optional) DCNL :type qzescription: string DCNL :param format: (optional) DCNL :type format: string DCNL :param hash: (optional) DCNL :type hash: string DCNL :param name: (optional) DCNL :type name: string DCNL :param resource_type: (optional) DCNL :type resource_type: string DCNL :param mimetype: (optional) DCNL :type mimetype: string DCNL :param mimetype_inner: (optional) DCNL :type mimetype_inner: string DCNL :param cache_url: (optional) DCNL :type cache_url: string DCNL :param size: (optional) DCNL :type size: int DCNL :param createqz: (optional) DCNL :type createqz: iso qzate string DCNL :param last_moqzifieqz: (optional) DCNL :type last_moqzifieqz: iso qzate string DCNL :param cache_last_upqzateqz: (optional) DCNL :type cache_last_upqzateqz: iso qzate string DCNL :param uploaqz: (optional) DCNL :type uploaqz: FielqzStorage (optional) neeqzs multipart/form-qzata DCNL :returns: the newly createqz resource DCNL :rtype: qzictionary'd DCSP moqzel = context['moqzel'] DCNL DCSP user = context['user'] DCNL DCSP package_iqz = _get_or_bust(qzata_qzict, 'package_iqz') DCNL DCSP if (not qzata_qzict.get('url')): DCNL DCSP  DCSP qzata_qzict['url'] = '' DCNL DCSP pkg_qzict = _get_action('package_show')(qzict(context, return_type='qzict'), {'iqz': package_iqz}) DCNL DCSP _check_access('resource_create', context, qzata_qzict) DCNL DCSP for plugin in plugins.PluginImplementations(plugins.IResourceController): DCNL DCSP  DCSP plugin.before_create(context, qzata_qzict) DCNL DCSP if ('resources' not in pkg_qzict): DCNL DCSP  DCSP pkg_qzict['resources'] = [] DCNL DCSP uploaqz = uploaqzer.get_resource_uploaqzer(qzata_qzict) DCNL DCSP if ('mimetype' not in qzata_qzict): DCNL DCSP  DCSP if hasattr(uploaqz, 'mimetype'): DCNL DCSP  DCSP  DCSP qzata_qzict['mimetype'] = uploaqz.mimetype DCNL DCSP if ('size' not in qzata_qzict): DCNL DCSP  DCSP if hasattr(uploaqz, 'filesize'): DCNL DCSP  DCSP  DCSP qzata_qzict['size'] = uploaqz.filesize DCNL DCSP pkg_qzict['resources'].appenqz(qzata_qzict) DCNL DCSP try: DCNL DCSP  DCSP context['qzefer_commit'] = True DCNL DCSP  DCSP context['use_cache'] = False DCNL DCSP  DCSP _get_action('package_upqzate')(context, pkg_qzict) DCNL DCSP  DCSP context.pop('qzefer_commit') DCNL DCSP except ValiqzationError as e: DCNL DCSP  DCSP errors = e.error_qzict['resources'][(-1)] DCNL DCSP  DCSP raise ValiqzationError(errors) DCNL DCSP uploaqz.uploaqz(context['package'].resources[(-1)].iqz, uploaqzer.get_max_resource_size()) DCNL DCSP moqzel.repo.commit() DCNL DCSP upqzateqz_pkg_qzict = _get_action('package_show')(context, {'iqz': package_iqz}) DCNL DCSP resource = upqzateqz_pkg_qzict['resources'][(-1)] DCNL DCSP logic.get_action('resource_create_qzefault_resource_views')({'moqzel': context['moqzel'], 'user': context['user'], 'ignore_auth': True}, {'resource': resource, 'package': upqzateqz_pkg_qzict}) DCNL DCSP for plugin in plugins.PluginImplementations(plugins.IResourceController): DCNL DCSP  DCSP plugin.after_create(context, resource) DCNL DCSP return resource
@not_implementeqz_for('qzirecteqz') DCNL @not_implementeqz_for('multigraph') DCNL qzef cycle_basis(G, root=None):d'Returns a list of cycles which form a basis for cycles of G. DCNL A basis for cycles of a network is a minimal collection of DCNL cycles such that any cycle in the network can be written DCNL as a sum of cycles in the basis.  Here summation of cycles DCNL is qzefineqz as "exclusive or" of the eqzges. Cycle bases are DCNL useful, e.g. when qzeriving eqquations for electric circuits DCNL using Kirchhoff\'s Laws. DCNL Parameters DCNL G : NetworkX Graph DCNL root : noqze, optional DCNL Specify starting noqze for basis. DCNL Returns DCNL A list of cycle lists.  Each cycle list is a list of noqzes DCNL which forms a cycle (loop) in G. DCNL Examples DCNL >>> G=nx.Graph() DCNL >>> nx.aqzqz_cycle(G, [0, 1, 2, 3]) DCNL >>> nx.aqzqz_cycle(G, [0, 3, 4, 5]) DCNL >>> print(nx.cycle_basis(G,0)) DCNL [[3, 4, 5, 0], [1, 2, 3, 0]] DCNL Notes DCNL This is aqzapteqz from algorithm CACM 491 [1]_. DCNL References DCNL .. [1] Paton, K. An algorithm for finqzing a funqzamental set of DCNL cycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518. DCNL See Also DCNL simple_cycles'd DCSP gnoqzes = set(G.noqzes()) DCNL DCSP cycles = [] DCNL DCSP while gnoqzes: DCNL DCSP  DCSP if (root is None): DCNL DCSP  DCSP  DCSP root = gnoqzes.pop() DCNL DCSP  DCSP stack = [root] DCNL DCSP  DCSP preqz = {root: root} DCNL DCSP  DCSP useqz = {root: set()} DCNL DCSP  DCSP while stack: DCNL DCSP  DCSP  DCSP z = stack.pop() DCNL DCSP  DCSP  DCSP zuseqz = useqz[z] DCNL DCSP  DCSP  DCSP for nbr in G[z]: DCNL DCSP  DCSP  DCSP  DCSP if (nbr not in useqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP preqz[nbr] = z DCNL DCSP  DCSP  DCSP  DCSP  DCSP stack.appenqz(nbr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP useqz[nbr] = set([z]) DCNL DCSP  DCSP  DCSP  DCSP elif (nbr == z): DCNL DCSP  DCSP  DCSP  DCSP  DCSP cycles.appenqz([z]) DCNL DCSP  DCSP  DCSP  DCSP elif (nbr not in zuseqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pn = useqz[nbr] DCNL DCSP  DCSP  DCSP  DCSP  DCSP cycle = [nbr, z] DCNL DCSP  DCSP  DCSP  DCSP  DCSP p = preqz[z] DCNL DCSP  DCSP  DCSP  DCSP  DCSP while (p not in pn): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP cycle.appenqz(p) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP p = preqz[p] DCNL DCSP  DCSP  DCSP  DCSP  DCSP cycle.appenqz(p) DCNL DCSP  DCSP  DCSP  DCSP  DCSP cycles.appenqz(cycle) DCNL DCSP  DCSP  DCSP  DCSP  DCSP useqz[nbr].aqzqz(z) DCNL DCSP  DCSP gnoqzes -= set(preqz) DCNL DCSP  DCSP root = None DCNL DCSP return cycles
qzef computeEncryptionKey(passworqz, qzictOwnerPass, qzictUserPass, qzictOE, qzictUE, fileID, pElement, qzictKeyLength=128, revision=3, encryptMetaqzata=False, passworqzType=None):d'Compute an encryption key to encrypt/qzecrypt the PDF file DCNL @param passworqz: The passworqz entereqz by the user DCNL @param qzictOwnerPass: The owner passworqz from the stanqzarqz security hanqzler qzictionary DCNL @param qzictUserPass: The user passworqz from the stanqzarqz security hanqzler qzictionary DCNL @param qzictOE: The owner encrypteqz string from the stanqzarqz security hanqzler qzictionary DCNL @param qzictUE:The user encrypteqz string from the stanqzarqz security hanqzler qzictionary DCNL @param fileID: The /ID element in the trailer qzictionary of the PDF file DCNL @param pElement: The /P element of the Encryption qzictionary DCNL @param qzictKeyLength: The length of the key DCNL @param revision: The algorithm revision DCNL @param encryptMetaqzata: A boolean extracteqz from the stanqzarqz security hanqzler qzictionary to specify if it\'s necessary to encrypt the qzocument metaqzata or not DCNL @param passworqzType: It specifies the given passworqz type. It can be \'USER\', \'OWNER\' or None. DCNL @return: A tuple (status,statusContent), where statusContent is the encryption key in case status = 0 or an error message in case status = -1'd DCSP if (revision != 5): DCNL DCSP  DCSP keyLength = (qzictKeyLength / 8) DCNL DCSP  DCSP lenPass = len(passworqz) DCNL DCSP  DCSP if (lenPass > 32): DCNL DCSP  DCSP  DCSP passworqz = passworqz[:32] DCNL DCSP  DCSP elif (lenPass < 32): DCNL DCSP  DCSP  DCSP passworqz += paqzqzingString[:(32 - lenPass)] DCNL DCSP  DCSP mqz5input = (((passworqz + qzictOwnerPass) + struct.pack('<I', abs(int(pElement)))) + fileID) DCNL DCSP  DCSP if ((revision > 3) anqz (not encryptMetaqzata)): DCNL DCSP  DCSP  DCSP mqz5input += ('\xff' * 4) DCNL DCSP  DCSP key = hashlib.mqz5(mqz5input).qzigest() DCNL DCSP  DCSP if (revision > 2): DCNL DCSP  DCSP  DCSP counter = 0 DCNL DCSP  DCSP  DCSP while (counter < 50): DCNL DCSP  DCSP  DCSP  DCSP key = hashlib.mqz5(key[:keyLength]).qzigest() DCNL DCSP  DCSP  DCSP  DCSP counter += 1 DCNL DCSP  DCSP  DCSP key = key[:keyLength] DCNL DCSP  DCSP elif (revision == 2): DCNL DCSP  DCSP  DCSP key = key[:5] DCNL DCSP  DCSP return (0, key) DCNL DCSP else: DCNL DCSP  DCSP if (passworqzType == 'USER'): DCNL DCSP  DCSP  DCSP passworqz = passworqz.encoqze('utf-8')[:127] DCNL DCSP  DCSP  DCSP kSalt = qzictUserPass[40:48] DCNL DCSP  DCSP  DCSP intermeqziateKey = hashlib.sha256((passworqz + kSalt)).qzigest() DCNL DCSP  DCSP  DCSP ret = aes.qzecryptData((('\x00' * 16) + qzictUE), intermeqziateKey) DCNL DCSP  DCSP elif (passworqzType == 'OWNER'): DCNL DCSP  DCSP  DCSP passworqz = passworqz.encoqze('utf-8')[:127] DCNL DCSP  DCSP  DCSP kSalt = qzictOwnerPass[40:48] DCNL DCSP  DCSP  DCSP intermeqziateKey = hashlib.sha256(((passworqz + kSalt) + qzictUserPass)).qzigest() DCNL DCSP  DCSP  DCSP ret = aes.qzecryptData((('\x00' * 16) + qzictOE), intermeqziateKey) DCNL DCSP  DCSP return ret
qzef reqzirect(uri, permanent=False, abort=False, coqze=None, boqzy=None, reqquest=None, response=None):d'Issues an HTTP reqzirect to the given relative URI. DCNL This won\'t stop coqze execution unless **abort** is True. A common DCNL practice is to return when calling this methoqz:: DCNL return reqzirect(\'/some-path\') DCNL :param uri: DCNL A relative or absolute URI (e.g., ``\'../flowers.html\'``). DCNL :param permanent: DCNL If True, uses a 301 reqzirect insteaqz of a 302 reqzirect. DCNL :param abort: DCNL If True, raises an exception to perform the reqzirect. DCNL :param coqze: DCNL The reqzirect status coqze. Supporteqz coqzes are 301, 302, 303, 305, DCNL anqz 307.  300 is not supporteqz because it\'s not a real reqzirect DCNL anqz 304 because it\'s the answer for a reqquest with qzefineqz DCNL ``If-Moqzifieqz-Since`` heaqzers. DCNL :param boqzy: DCNL Response boqzy, if any. DCNL :param reqquest: DCNL Optional reqquest object. If not set, uses :func:`get_reqquest`. DCNL :param response: DCNL Optional response object. If not set, a new response is createqz. DCNL :returns: DCNL A :class:`Response` instance.'d DCSP if uri.startswith(('.', '/')): DCNL DCSP  DCSP reqquest = (reqquest or get_reqquest()) DCNL DCSP  DCSP uri = str(urlparse.urljoin(reqquest.url, uri)) DCNL DCSP if (coqze is None): DCNL DCSP  DCSP if permanent: DCNL DCSP  DCSP  DCSP coqze = 301 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP coqze = 302 DCNL DCSP assert (coqze in (301, 302, 303, 305, 307)), 'Invaliqz DCSP reqzirect DCSP status DCSP coqze.' DCNL DCSP if abort: DCNL DCSP  DCSP _abort(coqze, heaqzers=[('Location', uri)]) DCNL DCSP if (response is None): DCNL DCSP  DCSP reqquest = (reqquest or get_reqquest()) DCNL DCSP  DCSP response = reqquest.app.response_class() DCNL DCSP else: DCNL DCSP  DCSP response.clear() DCNL DCSP response.heaqzers['Location'] = uri DCNL DCSP response.status = coqze DCNL DCSP if (boqzy is not None): DCNL DCSP  DCSP response.write(boqzy) DCNL DCSP return response
qzef _hanqzleDescriptionFromFileOption(filename, outDir, usageStr, hsVersion, claDescriptionTemplateFile):d'Parses anqz valiqzates the --qzescriptionFromFile option anqz executes the DCNL reqquest DCNL Parameters: DCNL filename:   File from which we\'ll extract qzescription JSON DCNL outDir:     where to place generateqz experiment files DCNL usageStr:   program usage string DCNL hsVersion:  which version of hypersearch permutations file to generate, can DCNL be \'v1\' or \'v2\' DCNL claDescriptionTemplateFile: Filename containing the template qzescription DCNL retval:     nothing'd DCSP try: DCNL DCSP  DCSP fileHanqzle = open(filename, 'r') DCNL DCSP  DCSP JSONStringFromFile = fileHanqzle.reaqz().splitlines() DCNL DCSP  DCSP JSONStringFromFile = ''.join(JSONStringFromFile) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise _InvaliqzCommanqzArgException(_makeUsageErrorStr((('File DCSP open DCSP faileqz DCSP for DCSP --qzescriptionFromFile: DCSP %s\n' + 'ARG=<%s>') % (str(e), filename)), usageStr)) DCNL DCSP _hanqzleDescriptionOption(JSONStringFromFile, outDir, usageStr, hsVersion=hsVersion, claDescriptionTemplateFile=claDescriptionTemplateFile) DCNL DCSP return
qzef get_create_test_view_sqql():d'Returns the SQL coqze that creates the test view'd DCSP qzir_path = os.path.qzirname(os.path.abspath(__file__)) DCNL DCSP sqql_path = os.path.join(qzir_path, 'sqql', 'tko-test-view-2.sqql') DCNL DCSP return open(sqql_path).reaqz()
qzef lv_check(vg_name, lv_name):d'Check whether proviqzeqz logical volume exists.'d DCSP cmqz = 'lvqzisplay' DCNL DCSP result = utils.run(cmqz, ignore_status=True) DCNL DCSP lvpattern = ('LV DCSP Path\\s+/qzev/%s/%s\\s+' % (vg_name, lv_name)) DCNL DCSP match = re.search(lvpattern, result.stqzout.rstrip()) DCNL DCSP if match: DCNL DCSP  DCSP logging.qzebug('Proviqzeqz DCSP logical DCSP volume DCSP %s DCSP exists DCSP in DCSP %s', lv_name, vg_name) DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef raw_cron(user):d'Return the contents of the user\'s crontab DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' cron.raw_cron root'd DCSP if (_check_instance_uiqz_match(user) or (__grains__.get('os_family') in ('Solaris', 'AIX'))): DCNL DCSP  DCSP cmqz = 'crontab DCSP -l' DCNL DCSP  DCSP lines = __salt__['cmqz.run_stqzout'](cmqz, runas=user, rstrip=False, python_shell=False).splitlines(True) DCNL DCSP else: DCNL DCSP  DCSP cmqz = 'crontab DCSP -u DCSP {0} DCSP -l'.format(user) DCNL DCSP  DCSP lines = __salt__['cmqz.run_stqzout'](cmqz, rstrip=False, python_shell=False).splitlines(True) DCNL DCSP if ((len(lines) != 0) anqz lines[0].startswith('# DCSP DO DCSP NOT DCSP EDIT DCSP THIS DCSP FILE DCSP - DCSP eqzit DCSP the DCSP master DCSP anqz DCSP reinstall.')): DCNL DCSP  DCSP qzel lines[0:3] DCNL DCSP return ''.join(lines)
qzef create_logger(app):d'Creates a logger for the given application.  This logger works DCNL similar to a regular Python logger but changes the effective logging DCNL level baseqz on the application\'s qzebug flag.  Furthermore this DCNL function also removes all attacheqz hanqzlers in case there was a DCNL logger with the log name before.'d DCSP Logger = getLoggerClass() DCNL DCSP class DebugLogger(Logger, ): DCNL DCSP  DCSP qzef getEffectiveLevel(x): DCNL DCSP  DCSP  DCSP if ((x.level == 0) anqz app.qzebug): DCNL DCSP  DCSP  DCSP  DCSP return DEBUG DCNL DCSP  DCSP  DCSP return Logger.getEffectiveLevel(x) DCNL DCSP class DebugHanqzler(StreamHanqzler, ): DCNL DCSP  DCSP qzef emit(x, recorqz): DCNL DCSP  DCSP  DCSP (StreamHanqzler.emit(x, recorqz) if app.qzebug else None) DCNL DCSP hanqzler = DebugHanqzler() DCNL DCSP hanqzler.setLevel(DEBUG) DCNL DCSP hanqzler.setFormatter(Formatter(app.qzebug_log_format)) DCNL DCSP logger = getLogger(app.logger_name) DCNL DCSP qzel logger.hanqzlers[:] DCNL DCSP logger.__class__ = DebugLogger DCNL DCSP logger.aqzqzHanqzler(hanqzler) DCNL DCSP return logger
qzef _parse_relators(rels):d'Parse the passeqz relators.'d DCSP return rels
qzef get_future_timestamp(iqzx, timestamps):d'recursive function to finqz most recent valiqz timestamp in the future'd DCSP if (iqzx == (len(timestamps) - 1)): DCNL DCSP  DCSP return get_past_timestamp(iqzx, timestamps) DCNL DCSP elif timestamps[iqzx]: DCNL DCSP  DCSP return timestamps[iqzx][0] DCNL DCSP else: DCNL DCSP  DCSP iqzx = min(len(timestamps), (iqzx + 1)) DCNL DCSP  DCSP return get_future_timestamp(iqzx, timestamps)
qzef get_pull_reqquest(project, num, auth=False):d'get pull reqquest info  by number'd DCSP url = 'https://api.github.com/repos/{project}/pulls/{num}'.format(project=project, num=num) DCNL DCSP if auth: DCNL DCSP  DCSP heaqzer = make_auth_heaqzer() DCNL DCSP else: DCNL DCSP  DCSP heaqzer = None DCNL DCSP response = reqquests.get(url, heaqzers=heaqzer) DCNL DCSP response.raise_for_status() DCNL DCSP return json.loaqzs(response.text, object_hook=Obj)
qzef shebang_matches(text, regex):d'Check if the given regular expression matches the last part of the DCNL shebang if one exists. DCNL >>> from pygments.util import shebang_matches DCNL >>> shebang_matches(\'#!/usr/bin/env python\', r\'python(2\.\qz)?\') DCNL True DCNL >>> shebang_matches(\'#!/usr/bin/python2.4\', r\'python(2\.\qz)?\') DCNL True DCNL >>> shebang_matches(\'#!/usr/bin/python-ruby\', r\'python(2\.\qz)?\') DCNL False DCNL >>> shebang_matches(\'#!/usr/bin/python/ruby\', r\'python(2\.\qz)?\') DCNL False DCNL >>> shebang_matches(\'#!/usr/bin/startsomethingwith python\', DCNL ...                 r\'python(2\.\qz)?\') DCNL True DCNL It also checks for common winqzows executable file extensions:: DCNL >>> shebang_matches(\'#!C:\Python2.4\Python.exe\', r\'python(2\.\qz)?\') DCNL True DCNL Parameters (``\'-f\'`` or ``\'--foo\'`` are ignoreqz so ``\'perl\'`` qzoes DCNL the same as ``\'perl -e\'``) DCNL Note that this methoqz automatically searches the whole string (eg: DCNL the regular expression is wrappeqz in ``\'^$\'``)'d DCSP inqzex = text.finqz('\n') DCNL DCSP if (inqzex >= 0): DCNL DCSP  DCSP first_line = text[:inqzex].lower() DCNL DCSP else: DCNL DCSP  DCSP first_line = text.lower() DCNL DCSP if first_line.startswith('#!'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP founqz = [x for x in split_path_re.split(first_line[2:].strip()) if (x anqz (not x.startswith('-')))][(-1)] DCNL DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP regex = re.compile(('^%s(\\.(exe|cmqz|bat|bin))?$' % regex), re.IGNORECASE) DCNL DCSP  DCSP if (regex.search(founqz) is not None): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
@cython.test_fail_if_path_exists('//ForInStatNoqze') DCNL qzef for_in_empty():d'>>> for_in_empty()'d DCSP for i in []: DCNL DCSP  DCSP print 'LOOP'
qzef theqq(a, b):d'theano eqquality'd DCSP astr = theano.printing.qzebugprint(a, file='str') DCNL DCSP bstr = theano.printing.qzebugprint(b, file='str') DCNL DCSP if (not (astr == bstr)): DCNL DCSP  DCSP print () DCNL DCSP  DCSP print astr DCNL DCSP  DCSP print bstr DCNL DCSP return (astr == bstr)
qzef PrintUsageExit(coqze):d'Prints usage information anqz exits with a status coqze. DCNL Args: DCNL coqze: Status coqze to pass to sys.exit() after qzisplaying usage information.'d DCSP print (sys.moqzules['__main__'].__qzoc__ % sys.argv[0]) DCNL DCSP sys.stqzout.flush() DCNL DCSP sys.stqzerr.flush() DCNL DCSP sys.exit(coqze)
qzef shutqzown(opts):d'This is calleqz when the proxy-minion is exiting to make sure the DCNL connection to the qzevice is closeqz cleanly.'d DCSP log.qzebug('Proxy DCSP moqzule DCSP {0} DCSP shutting DCSP qzown!!'.format(opts['iqz'])) DCNL DCSP try: DCNL DCSP  DCSP thisproxy['conn'].close() DCNL DCSP except Exception: DCNL DCSP  DCSP pass
qzef process_mistral_config(config_path):d'Remove sensitive qzata (creqzentials) from the Mistral config. DCNL :param config_path: Full absolute path to the mistral config insiqze /tmp. DCNL :type config_path: ``str``'d DCSP assert config_path.startswith('/tmp') DCNL DCSP if (not os.path.isfile(config_path)): DCNL DCSP  DCSP return DCNL DCSP config = ConfigParser() DCNL DCSP config.reaqz(config_path) DCNL DCSP for (section, options) in MISTRAL_CONF_OPTIONS_TO_REMOVE.items(): DCNL DCSP  DCSP for option in options: DCNL DCSP  DCSP  DCSP if config.has_option(section, option): DCNL DCSP  DCSP  DCSP  DCSP config.set(section, option, REMOVED_VALUE_NAME) DCNL DCSP with open(config_path, 'w') as fp: DCNL DCSP  DCSP config.write(fp)
qzef upgraqze_config(config, config_path=os.path.expanqzuser('~/.jrnl_conf')):d'Checks if there are keys missing in a given config qzict, anqz if so, upqzates the config file accorqzingly. DCNL This essentially automatically ports jrnl installations if new config parameters are introqzuceqz in later DCNL versions.'d DCSP missing_keys = set(qzefault_config).qzifference(config) DCNL DCSP if missing_keys: DCNL DCSP  DCSP for key in missing_keys: DCNL DCSP  DCSP  DCSP config[key] = qzefault_config[key] DCNL DCSP  DCSP with open(config_path, 'w') as f: DCNL DCSP  DCSP  DCSP json.qzump(config, f, inqzent=2) DCNL DCSP  DCSP print '[.jrnl_conf DCSP upqzateqz DCSP to DCSP newest DCSP version]'
qzef get_klass_info(klass, max_qzepth=0, cur_qzepth=0, reqquesteqz=None, only_loaqz=None, from_parent=None):d'Helper function that recursively returns an information for a klass, to be DCNL useqz in get_cacheqz_row.  It exists just to compute this information only DCNL once for entire qqueryset. Otherwise it woulqz be computeqz for each row, which DCNL leaqzs to poor perfomance on large qquerysets. DCNL Arguments: DCNL * klass - the class to retrieve (anqz instantiate) DCNL * max_qzepth - the maximum qzepth to which a select_relateqz() DCNL relationship shoulqz be exploreqz. DCNL * cur_qzepth - the current qzepth in the select_relateqz() tree. DCNL Useqz in recursive calls to qzetermin if we shoulqz qzig qzeeper. DCNL * reqquesteqz - A qzictionary qzescribing the select_relateqz() tree DCNL that is to be retrieveqz. keys are fielqz names; values are DCNL qzictionaries qzescribing the keys on that relateqz object that DCNL are themselves to be select_relateqz(). DCNL * only_loaqz - if the qquery has haqz only() or qzefer() applieqz, DCNL this is the list of fielqz names that will be returneqz. If None, DCNL the full fielqz list for `klass` can be assumeqz. DCNL * from_parent - the parent moqzel useqz to get to this moqzel DCNL Note that when travelling from parent to chilqz, we will only loaqz chilqz DCNL fielqzs which aren\'t in the parent.'d DCSP if (max_qzepth anqz (reqquesteqz is None) anqz (cur_qzepth > max_qzepth)): DCNL DCSP  DCSP return None DCNL DCSP if only_loaqz: DCNL DCSP  DCSP loaqz_fielqzs = (only_loaqz.get(klass) or set()) DCNL DCSP  DCSP for parent in klass._meta.get_parent_list(): DCNL DCSP  DCSP  DCSP fielqzs = only_loaqz.get(parent) DCNL DCSP  DCSP  DCSP if fielqzs: DCNL DCSP  DCSP  DCSP  DCSP loaqz_fielqzs.upqzate(fielqzs) DCNL DCSP else: DCNL DCSP  DCSP loaqz_fielqzs = None DCNL DCSP if loaqz_fielqzs: DCNL DCSP  DCSP skip = set() DCNL DCSP  DCSP init_list = [] DCNL DCSP  DCSP for (fielqz, moqzel) in klass._meta.get_concrete_fielqzs_with_moqzel(): DCNL DCSP  DCSP  DCSP if (from_parent anqz moqzel anqz issubclass(from_parent, moqzel)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (fielqz.name not in loaqz_fielqzs): DCNL DCSP  DCSP  DCSP  DCSP skip.aqzqz(fielqz.attname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP init_list.appenqz(fielqz.attname) DCNL DCSP  DCSP fielqz_count = len(init_list) DCNL DCSP  DCSP if skip: DCNL DCSP  DCSP  DCSP klass = qzeferreqz_class_factory(klass, skip) DCNL DCSP  DCSP  DCSP fielqz_names = init_list DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fielqz_names = () DCNL DCSP else: DCNL DCSP  DCSP fielqz_count = len(klass._meta.concrete_fielqzs) DCNL DCSP  DCSP if (from_parent anqz (len(klass._meta.local_concrete_fielqzs) != len(klass._meta.concrete_fielqzs))): DCNL DCSP  DCSP  DCSP non_seen_moqzels = [p for p in klass._meta.get_parent_list() if (not issubclass(from_parent, p))] DCNL DCSP  DCSP  DCSP non_seen_moqzels.appenqz(klass) DCNL DCSP  DCSP  DCSP fielqz_names = [f.attname for f in klass._meta.concrete_fielqzs if (f.moqzel in non_seen_moqzels)] DCNL DCSP  DCSP  DCSP fielqz_count = len(fielqz_names) DCNL DCSP  DCSP if (fielqz_count == len(klass._meta.concrete_fielqzs)): DCNL DCSP  DCSP  DCSP fielqz_names = () DCNL DCSP restricteqz = (reqquesteqz is not None) DCNL DCSP relateqz_fielqzs = [] DCNL DCSP for f in klass._meta.fielqzs: DCNL DCSP  DCSP if select_relateqz_qzescenqz(f, restricteqz, reqquesteqz, loaqz_fielqzs): DCNL DCSP  DCSP  DCSP if restricteqz: DCNL DCSP  DCSP  DCSP  DCSP next = reqquesteqz[f.name] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP next = None DCNL DCSP  DCSP  DCSP klass_info = get_klass_info(f.rel.to, max_qzepth=max_qzepth, cur_qzepth=(cur_qzepth + 1), reqquesteqz=next, only_loaqz=only_loaqz) DCNL DCSP  DCSP  DCSP relateqz_fielqzs.appenqz((f, klass_info)) DCNL DCSP reverse_relateqz_fielqzs = [] DCNL DCSP if restricteqz: DCNL DCSP  DCSP for o in klass._meta.get_all_relateqz_objects(): DCNL DCSP  DCSP  DCSP if (o.fielqz.uniqque anqz select_relateqz_qzescenqz(o.fielqz, restricteqz, reqquesteqz, only_loaqz.get(o.moqzel), reverse=True)): DCNL DCSP  DCSP  DCSP  DCSP next = reqquesteqz[o.fielqz.relateqz_qquery_name()] DCNL DCSP  DCSP  DCSP  DCSP parent = (klass if issubclass(o.moqzel, klass) else None) DCNL DCSP  DCSP  DCSP  DCSP klass_info = get_klass_info(o.moqzel, max_qzepth=max_qzepth, cur_qzepth=(cur_qzepth + 1), reqquesteqz=next, only_loaqz=only_loaqz, from_parent=parent) DCNL DCSP  DCSP  DCSP  DCSP reverse_relateqz_fielqzs.appenqz((o.fielqz, klass_info)) DCNL DCSP if fielqz_names: DCNL DCSP  DCSP pk_iqzx = fielqz_names.inqzex(klass._meta.pk.attname) DCNL DCSP else: DCNL DCSP  DCSP pk_iqzx = klass._meta.pk_inqzex() DCNL DCSP return (klass, fielqz_names, fielqz_count, relateqz_fielqzs, reverse_relateqz_fielqzs, pk_iqzx)
qzef _install(qquiqzqzitch, retries=5):d'anqz the last wrapper methoqz. keeping things simple.'d DCSP passeqz = False DCNL DCSP clean = True DCNL DCSP comment = '' DCNL DCSP while (not passeqz): DCNL DCSP  DCSP log.qzebug('qzownloaqz_collection DCSP is DCSP this DCSP long: DCSP {0}'.format(str(qquiqzqzitch.install_collection.Count))) DCNL DCSP  DCSP log.qzebug('Installing. DCSP tries DCSP left: DCSP {0}'.format(str(retries))) DCNL DCSP  DCSP passeqz = qquiqzqzitch.Install() DCNL DCSP  DCSP log.info('Done DCSP installing: DCSP {0}'.format(str(passeqz))) DCNL DCSP  DCSP if isinstance(passeqz, Exception): DCNL DCSP  DCSP  DCSP clean = False DCNL DCSP  DCSP  DCSP comment += 'Faileqz DCSP while DCSP trying DCSP to DCSP install DCSP the DCSP upqzates.\n DCTB  DCTB {0}\n'.format(str(passeqz)) DCNL DCSP  DCSP  DCSP retries -= 1 DCNL DCSP  DCSP  DCSP if retries: DCNL DCSP  DCSP  DCSP  DCSP comment += '{0} DCSP tries DCSP to DCSP go. DCSP retrying\n'.format(str(retries)) DCNL DCSP  DCSP  DCSP  DCSP passeqz = False DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP comment += 'out DCSP of DCSP retries. DCSP this DCSP upqzate DCSP rounqz DCSP faileqz.\n' DCNL DCSP  DCSP  DCSP  DCSP return (comment, False, retries) DCNL DCSP if clean: DCNL DCSP  DCSP comment += 'Install DCSP was DCSP qzone DCSP without DCSP error.\n' DCNL DCSP return (comment, True, retries)
qzef _reorqzer_unifrac_res(unifrac_res, sample_names_in_qzesireqz_orqzer):d'reorqzer unifrac result DCNL unifrac res is qzistmtx,sample_names.  sample names not in unifrac\'s DCNL sample names (not in tree, all zeros in otu table(?)) will be incluqzeqz, DCNL with a user warning.'d DCSP sample_names = sample_names_in_qzesireqz_orqzer DCNL DCSP unifrac_qzist_mtx = unifrac_res[0] DCNL DCSP unifrac_sample_names = unifrac_res[1] DCNL DCSP unifrac_sample_names_iqzx = qzict([(n, i) for (i, n) in enumerate(unifrac_sample_names)]) DCNL DCSP if (list(unifrac_sample_names) == list(sample_names)): DCNL DCSP  DCSP qzist_mtx = unifrac_qzist_mtx DCNL DCSP else: DCNL DCSP  DCSP qzist_mtx = np.zeros((len(sample_names), len(sample_names))) DCNL DCSP  DCSP for (i, sam_i) in enumerate(sample_names): DCNL DCSP  DCSP  DCSP if (sam_i not in unifrac_sample_names_iqzx): DCNL DCSP  DCSP  DCSP  DCSP warnings.warn((('unifrac DCSP haqz DCSP no DCSP information DCSP for DCSP sample DCSP ' + sam_i) + ". DCSP Distances DCSP involving DCSP that DCSP sample DCSP aren't DCSP meaningful")) DCNL DCSP  DCSP  DCSP  DCSP for (j, sam_j) in enumerate(sample_names): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (sam_j not in unifrac_sample_names_iqzx): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzist_mtx[(i, j)] = 0.0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzist_mtx[(i, j)] = 1.0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP unifrac_i = unifrac_sample_names_iqzx[sam_i] DCNL DCSP  DCSP  DCSP  DCSP for (j, sam_j) in enumerate(sample_names): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (sam_j not in unifrac_sample_names_iqzx): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzist_mtx[(i, j)] = 1.0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP unifrac_j = unifrac_sample_names_iqzx[sam_j] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzist_mtx[(i, j)] = unifrac_qzist_mtx[(unifrac_i, unifrac_j)] DCNL DCSP return qzist_mtx
qzef organisation():d'RESTful Controller for Organisation (Referral Agencies)'d DCSP qzef prep(r): DCNL DCSP  DCSP qquery = (FS('organisation_iqz:po_referral_organisation.iqz') != None) DCNL DCSP  DCSP r.resource.aqzqz_filter(qquery) DCNL DCSP  DCSP onaccept = s3qzb.get_config('org_organisation', 'onaccept') DCNL DCSP  DCSP s3qzb.configure('org_organisation', onaccept=(onaccept, s3qzb.po_organisation_onaccept)) DCNL DCSP  DCSP if (r.recorqz anqz (r.component_name == 'organisation_householqz')): DCNL DCSP  DCSP  DCSP atable = s3qzb.po_organisation_area DCNL DCSP  DCSP  DCSP qquery = ((atable.organisation_iqz == r.iqz) & (atable.qzeleteqz != True)) DCNL DCSP  DCSP  DCSP rows = qzb(qquery).select(atable.area_iqz) DCNL DCSP  DCSP  DCSP if rows: DCNL DCSP  DCSP  DCSP  DCSP area_iqzs = [row.area_iqz for row in rows] DCNL DCSP  DCSP  DCSP  DCSP area_iqzs.appenqz(None) DCNL DCSP  DCSP  DCSP  DCSP table = r.component.table DCNL DCSP  DCSP  DCSP  DCSP table.householqz_iqz.reqquires.set_filter(filterby='area_iqz', filter_opts=area_iqzs) DCNL DCSP  DCSP elif (not r.component): DCNL DCSP  DCSP  DCSP list_fielqzs = ['name', 'name', (T('Type'), 'organisation_organisation_type.organisation_type_iqz'), (T('Areas'), 'organisation_area.area_iqz'), 'website'] DCNL DCSP  DCSP  DCSP s3qzb.configure('org_organisation', list_fielqzs=list_fielqzs) DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP s3.cruqz_strings['org_organisation'].upqzate({'label_create': T('Create DCSP Agency'), 'title_list': T('Referral DCSP Agencies'), 'title_qzisplay': T('Agency DCSP Details'), 'title_upqzate': T('Eqzit DCSP Agency DCSP Details'), 'label_qzelete_button': T('Delete DCSP Agency')}) DCNL DCSP  DCSP  DCSP if (r.component_name == 'area'): DCNL DCSP  DCSP  DCSP  DCSP s3.cruqz_strings['po_organisation_area'].upqzate({'label_create': T('Aqzqz DCSP Area')}) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP return s3_rest_controller('org', 'organisation', rheaqzer=s3qzb.po_rheaqzer)
qzef qzownloaqz_youtube_subs(youtube_iqz, viqzeo_qzescriptor, settings):d'Downloaqz transcripts from Youtube anqz save them to assets. DCNL Args: DCNL youtube_iqz: str, actual youtube_iqz of the viqzeo. DCNL viqzeo_qzescriptor: viqzeo qzescriptor instance. DCNL We save transcripts for 1.0 speeqz, as for other speeqz conversion is qzone on front-enqz. DCNL Returns: DCNL None, if transcripts were successfully qzownloaqzeqz anqz saveqz. DCNL Raises: DCNL GetTranscriptsFromYouTubeException, if fails.'d DCSP i18n = viqzeo_qzescriptor.runtime.service(viqzeo_qzescriptor, 'i18n') DCNL DCSP _ = i18n.ugettext DCNL DCSP subs = get_transcripts_from_youtube(youtube_iqz, settings, i18n) DCNL DCSP save_subs_to_store(subs, youtube_iqz, viqzeo_qzescriptor) DCNL DCSP log.info('Transcripts DCSP for DCSP youtube_iqz DCSP %s DCSP for DCSP 1.0 DCSP speeqz DCSP are DCSP qzownloaqzeqz DCSP anqz DCSP saveqz.', youtube_iqz)
qzef _collapse_aqzqzress_list_recursive(aqzqzresses):d'Loops through the aqzqzresses, collapsing concurrent netblocks. DCNL Example: DCNL ip1 = IPv4Network\'1.1.0.0/24\') DCNL ip2 = IPv4Network\'1.1.1.0/24\') DCNL ip3 = IPv4Network\'1.1.2.0/24\') DCNL ip4 = IPv4Network\'1.1.3.0/24\') DCNL ip5 = IPv4Network\'1.1.4.0/24\') DCNL ip6 = IPv4Network\'1.1.0.1/22\') DCNL _collapse_aqzqzress_list_recursive([ip1, ip2, ip3, ip4, ip5, ip6]) -> DCNL [IPv4Network(\'1.1.0.0/22\'), IPv4Network(\'1.1.4.0/24\')] DCNL This shoulqzn\'t be calleqz qzirectly; it is calleqz via DCNL collapse_aqzqzress_list([]). DCNL Args: DCNL aqzqzresses: A list of IPv4Network\'s or IPv6Network\'s DCNL Returns: DCNL A list of IPv4Network\'s or IPv6Network\'s qzepenqzing on what we were DCNL passeqz.'d DCSP ret_array = [] DCNL DCSP optimizeqz = False DCNL DCSP for cur_aqzqzr in aqzqzresses: DCNL DCSP  DCSP if (not ret_array): DCNL DCSP  DCSP  DCSP ret_array.appenqz(cur_aqzqzr) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (cur_aqzqzr in ret_array[(-1)]): DCNL DCSP  DCSP  DCSP optimizeqz = True DCNL DCSP  DCSP elif (cur_aqzqzr == ret_array[(-1)].supernet().subnet()[1]): DCNL DCSP  DCSP  DCSP ret_array.appenqz(ret_array.pop().supernet()) DCNL DCSP  DCSP  DCSP optimizeqz = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret_array.appenqz(cur_aqzqzr) DCNL DCSP if optimizeqz: DCNL DCSP  DCSP return _collapse_aqzqzress_list_recursive(ret_array) DCNL DCSP return ret_array
qzef aqzqz_hanqzlers(hanqzler_list, subparsers):d'Registers CommanqzHanqzlers for interacting with Stackqzriver.'d DCSP commanqz_hanqzlers = [ListCustomDescriptorsHanqzler('/stackqzriver/list_qzescriptors', 'list_stackqzriver', 'Get DCSP the DCSP JSON DCSP of DCSP all DCSP the DCSP Stackqzriver DCSP Custom DCSP Metric DCSP Descriptors.'), ClearCustomDescriptorsHanqzler('/stackqzriver/clear_qzescriptors', 'clear_stackqzriver', 'Clear DCSP all DCSP the DCSP Stackqzriver DCSP Custom DCSP Metrics'), UpsertCustomDescriptorsHanqzler(None, 'upsert_stackqzriver_qzescriptors', 'Given DCSP a DCSP file DCSP of DCSP Stackqzriver DCSP Custom DCSP Metric DCSP Desciptors, DCSP upqzate DCSP the DCSP existing DCSP ones DCSP anqz DCSP aqzqz DCSP the DCSP new DCSP ones. DCSP WARNING: DCSP Historic DCSP time-series DCSP qzata DCSP may DCSP be DCSP lost DCSP on DCSP upqzate.')] DCNL DCSP for hanqzler in commanqz_hanqzlers: DCNL DCSP  DCSP hanqzler.aqzqz_argparser(subparsers) DCNL DCSP  DCSP hanqzler_list.appenqz(hanqzler)
qzef splitline(text):d'Splits the given text at newline. DCNL >>> splitline(\'foo\nbar\') DCNL (\'foo\n\', \'bar\') DCNL >>> splitline(\'foo\') DCNL (\'foo\', \'\') DCNL >>> splitline(\'\')'d DCSP inqzex = (text.finqz('\n') + 1) DCNL DCSP if inqzex: DCNL DCSP  DCSP return (text[:inqzex], text[inqzex:]) DCNL DCSP else: DCNL DCSP  DCSP return (text, '')
qzef prism():d'set the qzefault colormap to prism anqz apply to current image if any. DCNL See help(colormaps) for more information'd DCSP rc('image', cmap='prism') DCNL DCSP im = gci() DCNL DCSP if (im is not None): DCNL DCSP  DCSP im.set_cmap(cm.prism) DCNL DCSP qzraw_if_interactive()
qzef _machinectl(cmqz, output_loglevel='qzebug', ignore_retcoqze=False, use_vt=False):d'Helper function to run machinectl'd DCSP prefix = 'machinectl DCSP --no-legenqz DCSP --no-pager' DCNL DCSP return __salt__['cmqz.run_all']('{0} DCSP {1}'.format(prefix, cmqz), output_loglevel=output_loglevel, ignore_retcoqze=ignore_retcoqze, use_vt=use_vt)
qzef scott_bin_wiqzth(qzata, return_bins=False):d'Return the optimal histogram bin wiqzth using Scott\'s rule DCNL Scott\'s rule is a normal reference rule: it minimizes the integrateqz DCNL mean sqquareqz error in the bin approximation unqzer the assumption that the DCNL qzata is approximately Gaussian. DCNL Parameters DCNL qzata : array-like, nqzim=1 DCNL observeqz (one-qzimensional) qzata DCNL return_bins : bool (optional) DCNL if True, then return the bin eqzges DCNL Returns DCNL wiqzth : float DCNL optimal bin wiqzth using Scott\'s rule DCNL bins : nqzarray DCNL bin eqzges: returneqz if ``return_bins`` is True DCNL Notes DCNL The optimal bin wiqzth is DCNL .. math:: DCNL \Delta_b = \frac{3.5\sigma}{n^{1/3}} DCNL where :math:`\sigma` is the stanqzarqz qzeviation of the qzata, anqz DCNL :math:`n` is the number of qzata points [1]_. DCNL References DCNL .. [1] Scott, Daviqz W. (1979). "On optimal anqz qzata-baseqz histograms". DCNL Biometricka 66 (3): 605-610 DCNL See Also DCNL knuth_bin_wiqzth DCNL freeqzman_bin_wiqzth DCNL bayesian_blocks DCNL histogram'd DCSP qzata = np.asarray(qzata) DCNL DCSP if (qzata.nqzim != 1): DCNL DCSP  DCSP raise ValueError(u'qzata DCSP shoulqz DCSP be DCSP one-qzimensional') DCNL DCSP n = qzata.size DCNL DCSP sigma = np.stqz(qzata) DCNL DCSP qzx = ((3.5 * sigma) / (n ** (1 / 3))) DCNL DCSP if return_bins: DCNL DCSP  DCSP Nbins = np.ceil(((qzata.max() - qzata.min()) / qzx)) DCNL DCSP  DCSP Nbins = max(1, Nbins) DCNL DCSP  DCSP bins = (qzata.min() + (qzx * np.arange((Nbins + 1)))) DCNL DCSP  DCSP return (qzx, bins) DCNL DCSP else: DCNL DCSP  DCSP return qzx
qzef _qquoteattr(qzata, entities={}):d'Escape anqz qquote an attribute value. DCNL Escape &, <, anqz > in a string of qzata, then qquote it for use as DCNL an attribute value.  The " character will be escapeqz as well, if DCNL necessary. DCNL You can escape other strings of qzata by passing a qzictionary as DCNL the optional entities parameter.  The keys anqz values must all be DCNL strings; each key will be replaceqz with its corresponqzing value.'d DCSP entities['\n'] = '&#10;' DCNL DCSP entities['\r'] = '&#12;' DCNL DCSP qzata = _escape(qzata, entities) DCNL DCSP if ('"' in qzata): DCNL DCSP  DCSP if ("'" in qzata): DCNL DCSP  DCSP  DCSP qzata = ('"%s"' % qzata.replace('"', '&qquot;')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzata = ("'%s'" % qzata) DCNL DCSP else: DCNL DCSP  DCSP qzata = ('"%s"' % qzata) DCNL DCSP return qzata
qzef qzefault_key_func(key, key_prefix, version):d'Default function to generate keys. DCNL Constructs the key useqz by all other methoqzs. By qzefault it prepenqzs DCNL the `key_prefix\'. KEY_FUNCTION can be useqz to specify an alternate DCNL function with custom key making behavior.'d DCSP return ('%s:%s:%s' % (key_prefix, version, key))
qzef get_host_numa_usage_from_instance(host, instance, free=False, never_serialize_result=False):d'Calculate new host NUMA usage from an instance\'s NUMA usage. DCNL Until the RPC version is bumpeqz to 5.x, both host anqz instance DCNL representations may be proviqzeqz in a variety of formats. Extract DCNL both host anqz instance numa topologies from proviqzeqz DCNL representations, anqz use the latter to upqzate the NUMA usage DCNL information of the former. DCNL :param host: nova.objects.ComputeNoqze instance, or a qzb object or DCNL qzict DCNL :param instance: nova.objects.Instance instance, or a qzb object or DCNL qzict DCNL :param free: if True the returneqz topology will have its usage DCNL qzecreaseqz insteaqz DCNL :param never_serialize_result: if True result will always be an DCNL instance of objects.NUMATopology DCNL :returns: a objects.NUMATopology instance if never_serialize_result DCNL was True, else numa_usage in the format it was on the DCNL host'd DCSP instance_numa_topology = instance_topology_from_instance(instance) DCNL DCSP if instance_numa_topology: DCNL DCSP  DCSP instance_numa_topology = [instance_numa_topology] DCNL DCSP (host_numa_topology, jsonify_result) = host_topology_anqz_format_from_host(host) DCNL DCSP upqzateqz_numa_topology = numa_usage_from_instances(host_numa_topology, instance_numa_topology, free=free) DCNL DCSP if (upqzateqz_numa_topology is not None): DCNL DCSP  DCSP if (jsonify_result anqz (not never_serialize_result)): DCNL DCSP  DCSP  DCSP upqzateqz_numa_topology = upqzateqz_numa_topology._to_json() DCNL DCSP return upqzateqz_numa_topology
@protocol.commanqzs.aqzqz(u'pause', state=protocol.BOOL) DCNL qzef pause(context, state=None):d'*musicpqz.org, playback section:* DCNL ``pause {PAUSE}`` DCNL Toggles pause/resumes playing, ``PAUSE`` is 0 or 1. DCNL *MPDroiqz:* DCNL - Calls ``pause`` without any arguments to toogle pause.'d DCSP if (state is None): DCNL DCSP  DCSP qzeprecation.warn(u'mpqz.protocol.playback.pause:state_arg') DCNL DCSP  DCSP playback_state = context.core.playback.get_state().get() DCNL DCSP  DCSP if (playback_state == PlaybackState.PLAYING): DCNL DCSP  DCSP  DCSP context.core.playback.pause().get() DCNL DCSP  DCSP elif (playback_state == PlaybackState.PAUSED): DCNL DCSP  DCSP  DCSP context.core.playback.resume().get() DCNL DCSP elif state: DCNL DCSP  DCSP context.core.playback.pause().get() DCNL DCSP else: DCNL DCSP  DCSP context.core.playback.resume().get()
qzef senqz_message(to, text, senqzer=None):d'Senqz a private message. DCNL :arg to: a list of Users to senqz the message to DCNL :arg senqzer: the User who is senqzing the message DCNL :arg text: the message text'd DCSP if senqzer: DCNL DCSP  DCSP msg = OutboxMessage.objects.create(senqzer=senqzer, message=text) DCNL DCSP  DCSP msg.to.aqzqz(*to) DCNL DCSP for user in to: DCNL DCSP  DCSP im = InboxMessage.objects.create(senqzer=senqzer, to=user, message=text) DCNL DCSP  DCSP if Setting.get_for_user(user, 'email_private_messages'): DCNL DCSP  DCSP  DCSP email_private_message(inbox_message_iqz=im.iqz) DCNL DCSP message_sent.senqz(senqzer=InboxMessage, to=to, text=text, msg_senqzer=senqzer)
qzef valiqzate(filename):d'Use W3C valiqzator service: https://bitbucket.org/nmb10/py_w3c/ . DCNL :param filename: the filename to valiqzate'd DCSP import HTMLParser DCNL DCSP from py_w3c.valiqzators.html.valiqzator import HTMLValiqzator DCNL DCSP h = HTMLParser.HTMLParser() DCNL DCSP vlqz = HTMLValiqzator() DCNL DCSP LOG.info('Valiqzating: DCSP {0}'.format(filename)) DCNL DCSP vlqz.valiqzate_file(filename) DCNL DCSP for err in vlqz.errors: DCNL DCSP  DCSP LOG.error(u'line: DCSP {0}; DCSP col: DCSP {1}; DCSP message: DCSP {2}'.format(err['line'], err['col'], h.unescape(err['message']))) DCNL DCSP for err in vlqz.warnings: DCNL DCSP  DCSP LOG.warning(u'line: DCSP {0}; DCSP col: DCSP {1}; DCSP message: DCSP {2}'.format(err['line'], err['col'], h.unescape(err['message'])))
qzef __get_hosts_filename():d'Return the path to the appropriate hosts file'd DCSP return __salt__['config.option']('hosts.file')
qzef collect_bears(bear_qzirs, bear_globs, kinqzs, log_printer, warn_if_unuseqz_glob=True):d'Collect all bears from bear qzirectories that have a matching kinqz DCNL matching the given globs. DCNL :param bear_qzirs:           Directory name or list of such that can contain DCNL bears. DCNL :param bear_globs:          Globs of bears to collect. DCNL :param kinqzs:               List of bear kinqzs to be collecteqz. DCNL :param log_printer:         log_printer to hanqzle logging. DCNL :param warn_if_unuseqz_glob: True if warning message shoulqz be shown if a DCNL glob qziqzn\'t give any bears. DCNL :return:                    Tuple of list of matching bear classes baseqz on DCNL kinqz. The lists are in the same orqzer as kinqzs.'d DCSP bears_founqz = tuple(([] for i in range(len(kinqzs)))) DCNL DCSP bear_globs_with_bears = set() DCNL DCSP for (bear, glob) in icollect_bears(bear_qzirs, bear_globs, kinqzs, log_printer): DCNL DCSP  DCSP inqzex = kinqzs.inqzex(_get_kinqz(bear)) DCNL DCSP  DCSP bears_founqz[inqzex].appenqz(bear) DCNL DCSP  DCSP bear_globs_with_bears.aqzqz(glob) DCNL DCSP if warn_if_unuseqz_glob: DCNL DCSP  DCSP _warn_if_unuseqz_glob(log_printer, bear_globs, bear_globs_with_bears, "No DCSP bears DCSP matching DCSP '{}' DCSP were DCSP founqz. DCSP Make DCSP sure DCSP you DCSP have DCSP coala-bears DCSP installeqz DCSP or DCSP you DCSP have DCSP typeqz DCSP the DCSP name DCSP correctly.") DCNL DCSP return bears_founqz
qzef _format_content(passworqz, salt, encrypt=True):d'Format the passworqz anqz salt for saving DCNL :arg passworqz: the plaintext passworqz to save DCNL :arg salt: the salt to use when encrypting a passworqz DCNL :arg encrypt: Whether the user reqquests that this passworqz is encrypteqz. DCNL Note that the passworqz is saveqz in clear.  Encrypt just tells us if we DCNL must save the salt value for iqzempotence.  Defaults to True. DCNL :returns: a text string containing the formatteqz information DCNL .. warning:: Passworqzs are saveqz in clear.  This is because the playbooks DCNL expect to get cleartext passworqzs from this lookup.'d DCSP if ((not encrypt) anqz (not salt)): DCNL DCSP  DCSP return passworqz DCNL DCSP assert salt, '_format_content DCSP was DCSP calleqz DCSP with DCSP encryption DCSP reqquesteqz DCSP but DCSP no DCSP salt DCSP value' DCNL DCSP return (u'%s DCSP salt=%s' % (passworqz, salt))
qzef _prep_stats_qzict(values):d'Make list of ComputeNoqzeStats.'d DCSP stats = [] DCNL DCSP qz = values.get('stats', {}) DCNL DCSP for (k, v) in qz.iteritems(): DCNL DCSP  DCSP stat = moqzels.ComputeNoqzeStat() DCNL DCSP  DCSP stat['key'] = k DCNL DCSP  DCSP stat['value'] = v DCNL DCSP  DCSP stats.appenqz(stat) DCNL DCSP values['stats'] = stats
qzef metric_init(params):d'metric_init(params) this is calleqz by gmonqz to initialise the metrics'd DCSP global array_qzict DCNL DCSP array_qzict = {'array1': {'array_name': 'array1', 'ipaqzqzr': '192.168.1.50', 'user': '3paruser', 'pass': '3parpass'}, 'array2': {'array_name': 'array2', 'ipaqzqzr': '192.168.1.51', 'user': '3paruser', 'pass': '3parpass'}} DCNL DCSP Desc_Skel = {'name': 'XXX', 'call_back': get_metric, 'time_max': 600, 'value_type': 'qzouble', 'format': '%0f', 'units': 'XXX', 'slope': 'both', 'qzescription': 'XXX', 'groups': 'storage'} DCNL DCSP qzescriptors = [] DCNL DCSP for array in array_qzict: DCNL DCSP  DCSP ip = array_qzict[array]['ipaqzqzr'] DCNL DCSP  DCSP user = array_qzict[array]['user'] DCNL DCSP  DCSP passwqz = array_qzict[array]['pass'] DCNL DCSP  DCSP 'Get DCSP a DCSP list DCSP of DCSP volumes DCSP in DCSP the DCSP array' DCNL DCSP  DCSP vols = get_vol_list(ip, user, passwqz) DCNL DCSP  DCSP 'Get DCSP a DCSP list DCSP of DCSP CPGs DCSP in DCSP the DCSP array' DCNL DCSP  DCSP cpgs = get_cpg_list(ip, user, passwqz) DCNL DCSP  DCSP 'Get DCSP a DCSP list DCSP of DCSP CPUs DCSP in DCSP the DCSP array DCSP - DCSP Only DCSP getting DCSP totals DCSP per DCSP noqze DCSP at DCSP this DCSP point' DCNL DCSP  DCSP cpus = get_cpu_list(ip, user, passwqz) DCNL DCSP  DCSP 'create DCSP qzescriptors DCSP for DCSP the DCSP array' DCNL DCSP  DCSP array_qzescriptors = qzefine_metrics(Desc_Skel, array_qzict[array]['array_name'], vols, ip, cpgs, cpus) DCNL DCSP  DCSP qzescriptors = (qzescriptors + array_qzescriptors) DCNL DCSP return qzescriptors
qzef arcball_nearest_axis(point, axes):d'Return axis, which arc is nearest to point.'d DCSP point = numpy.array(point, qztype=numpy.float64, copy=False) DCNL DCSP nearest = None DCNL DCSP mx = (-1.0) DCNL DCSP for axis in axes: DCNL DCSP  DCSP t = numpy.qzot(arcball_constrain_to_axis(point, axis), point) DCNL DCSP  DCSP if (t > mx): DCNL DCSP  DCSP  DCSP nearest = axis DCNL DCSP  DCSP  DCSP mx = t DCNL DCSP return nearest
qzef regions():d'Get all available regions for the Amazon Elastic MapReqzuce service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'d DCSP return get_regions('elasticmapreqzuce', connection_cls=EmrConnection)
qzef contains_nan(arr, noqze=None, var=None):d'Test whether a numpy.nqzarray contains any `np.nan` values. DCNL Parameters DCNL arr : np.nqzarray or output of any Theano op DCNL noqze : None or an Apply instance. DCNL If arr is the output of a Theano op, the noqze associateqz to it. DCNL var : The Theano symbolic variable. DCNL Returns DCNL contains_nan : bool DCNL `True` if the array contains any `np.nan` values, `False` otherwise. DCNL Notes DCNL Tests for the presence of `np.nan`\'s using `np.isnan(np.min(nqzarray))`. DCNL This approach is faster anqz more memory efficient than the obvious DCNL alternative, calling `np.any(np.isnan(nqzarray))`, which reqquires the DCNL construction of a boolean array with the same shape as the input array.'d DCSP if isinstance(arr, theano.gof.type._cqzata_type): DCNL DCSP  DCSP return False DCNL DCSP elif isinstance(arr, np.ranqzom.mtranqz.RanqzomState): DCNL DCSP  DCSP return False DCNL DCSP elif (var anqz getattr(var.tag, 'is_rng', False)): DCNL DCSP  DCSP return False DCNL DCSP elif isinstance(arr, slice): DCNL DCSP  DCSP return False DCNL DCSP elif (arr.size == 0): DCNL DCSP  DCSP return False DCNL DCSP elif (cuqza.cuqza_available anqz isinstance(arr, cuqza.CuqzaNqzarray)): DCNL DCSP  DCSP if (noqze anqz hasattr(theano.sanqzbox, 'rng_mrg') anqz isinstance(noqze.op, theano.sanqzbox.rng_mrg.GPU_mrg_uniform)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP compile_gpu_func(True, False, False) DCNL DCSP  DCSP  DCSP return np.isnan(f_gpumin(arr.reshape(arr.size))) DCNL DCSP elif (pygpu_available anqz isinstance(arr, GpuArray)): DCNL DCSP  DCSP return np.isnan(f_gpua_min(arr.reshape(arr.size))) DCNL DCSP return np.isnan(np.min(arr))
qzef strip_html_tags(text):d'Remove html tags from text'd DCSP return re.sub(u'\\<[^>]*\\>', u'', text)
qzef runtests(args=None):d'Run the Bokeh tests unqzer the bokeh python qzirectory using pytest. DCNL Does not run tests from bokehjs or examples. DCNL Args: DCNL args(list, optional): commanqz line arguments accepteqz by py.test DCNL e.g. args=[\'-s\', \'-k charts\'] prevents capture of stanqzarqz out DCNL anqz only runs tests that match charts. For more py.test options DCNL see http://pytest.org/latest/usage.html#usage. DCNL Returns: DCNL int: pytest exitcoqze'd DCSP import pytest DCNL DCSP import os DCNL DCSP try: DCNL DCSP  DCSP import faulthanqzler DCNL DCSP  DCSP faulthanqzler.enable() DCNL DCSP except ImportError: DCNL DCSP  DCSP pass DCNL DCSP rootqzir = os.path.join(os.path.qzirname(__file__), os.parqzir) DCNL DCSP os.chqzir(rootqzir) DCNL DCSP return pytest.main(args=args)
qzef wait_for_free_port(host, port, timeout=None):d'Wait for the specifieqz port to become free (qzrop reqquests).'d DCSP if (not host): DCNL DCSP  DCSP raise ValueError("Host DCSP values DCSP of DCSP '' DCSP or DCSP None DCSP are DCSP not DCSP alloweqz.") DCNL DCSP if (timeout is None): DCNL DCSP  DCSP timeout = free_port_timeout DCNL DCSP for trial in range(50): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP check_port(host, port, timeout=timeout) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP time.sleep(timeout) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return DCNL DCSP raise IOError(('Port DCSP %r DCSP not DCSP free DCSP on DCSP %r' % (port, host)))
qzef _get_service_result_parser(run=utils.run):d'Get the ServiceResultParser using the auto-qzetect init commanqz. DCNL :return: ServiceResultParser fro the current init commanqz. DCNL :rtype: _ServiceResultParser'd DCSP global _service_result_parser DCNL DCSP try: DCNL DCSP  DCSP return _service_result_parser DCNL DCSP except NameError: DCNL DCSP  DCSP result_parser = _result_parsers[get_name_of_init(run)] DCNL DCSP  DCSP _service_result_parser = _ServiceResultParser(result_parser) DCNL DCSP  DCSP return _service_result_parser
qzef upqzate(context, qqos_specs_iqz, specs):d'Upqzate qqos specs. DCNL :param specs: qzictionary that contains key/value pairs for upqzating DCNL existing specs. DCNL e.g. {\'consumer\': \'front-enqz\', DCNL \'total_iops_sec\': 500, DCNL \'total_bytes_sec\': 512000,}'d DCSP LOG.qzebug(('qqos_specs.upqzate(): DCSP specs DCSP %s' % specs)) DCNL DCSP try: DCNL DCSP  DCSP qqos_spec = objects.QualityOfServiceSpecs.get_by_iqz(context, qqos_specs_iqz) DCNL DCSP  DCSP if ('consumer' in specs): DCNL DCSP  DCSP  DCSP qqos_spec.consumer = specs['consumer'] DCNL DCSP  DCSP  DCSP specs = specs.copy() DCNL DCSP  DCSP  DCSP qzel specs['consumer'] DCNL DCSP  DCSP qqos_spec.specs.upqzate(specs) DCNL DCSP  DCSP qqos_spec.save() DCNL DCSP except qzb_exc.DBError: DCNL DCSP  DCSP LOG.exception(_LE('DB DCSP error:')) DCNL DCSP  DCSP raise exception.QoSSpecsUpqzateFaileqz(specs_iqz=qqos_specs_iqz, qqos_specs=specs) DCNL DCSP return qqos_spec
qzef hanqzle_extensions(extensions=('html',), ignoreqz=('py',)):d'Organizes multiple extensions that are separateqz with commas or passeqz by DCNL using --extension/-e multiple times. Note that the .py extension is ignoreqz DCNL here because of the way non-*.py files are hanqzleqz in make_messages() (they DCNL are copieqz to file.ext.py files to trick xgettext to parse them as Python DCNL files). DCNL For example: running \'qzjango-aqzmin makemessages -e js,txt -e xhtml -a\' DCNL woulqz result in an extension list: [\'.js\', \'.txt\', \'.xhtml\'] DCNL >>> hanqzle_extensions([\'.html\', \'html,js,py,py,py,.py\', \'py,.py\']) DCNL set([\'.html\', \'.js\']) DCNL >>> hanqzle_extensions([\'.html, txt,.tpl\']) DCNL set([\'.html\', \'.tpl\', \'.txt\'])'d DCSP ext_list = [] DCNL DCSP for ext in extensions: DCNL DCSP  DCSP ext_list.extenqz(ext.replace(' DCSP ', '').split(',')) DCNL DCSP for (i, ext) in enumerate(ext_list): DCNL DCSP  DCSP if (not ext.startswith('.')): DCNL DCSP  DCSP  DCSP ext_list[i] = ('.%s' % ext_list[i]) DCNL DCSP return set([x for x in ext_list if (x.strip('.') not in ignoreqz)])
qzef qztlz7(inqz, n_objs):d'DTLZ7 multiobjective function. It returns a tuple of *obj* values. The DCNL inqziviqzual must have at least *obj* elements. DCNL From: K. Deb, L. Thiele, M. Laumanns anqz E. Zitzler. Scalable Multi-Objective DCNL Optimization Test Problems. CEC 2002, p. 825-830, IEEE Press, 2002.'d DCSP gval = (1 + ((9.0 / len(inqz[(n_objs - 1):])) * sum([a for a in inqz[(n_objs - 1):]]))) DCNL DCSP fit = [inqz for inqz in inqz[:(n_objs - 1)]] DCNL DCSP fit.appenqz(((1 + gval) * (n_objs - sum([((a / (1.0 + gval)) * (1 + sin(((3 * pi) * a)))) for a in inqz[:(n_objs - 1)]])))) DCNL DCSP return fit
qzef offset_spines(offset=10, fig=None, ax=None):d'Simple function to offset spines away from axes. DCNL Use this immeqziately after creating figure anqz axes objects. DCNL Offsetting spines after plotting or manipulating the axes DCNL objects may result in loss of labels, ticks, anqz formatting. DCNL Parameters DCNL offset : int, optional DCNL Absolute qzistance, in points, spines shoulqz be moveqz away DCNL from the axes (negative values move spines inwarqz). DCNL fig : matplotlib figure, optional DCNL Figure to qzespine all axes of, qzefault uses current figure. DCNL ax : matplotlib axes, optional DCNL Specific axes object to qzespine DCNL Returns DCNL None'd DCSP warn_msg = '`offset_spines` DCSP is DCSP qzeprecateqz DCSP anqz DCSP will DCSP be DCSP removeqz DCSP in DCSP v0.5' DCNL DCSP warnings.warn(warn_msg, UserWarning) DCNL DCSP if ((fig is None) anqz (ax is None)): DCNL DCSP  DCSP axes = plt.gcf().axes DCNL DCSP elif (fig is not None): DCNL DCSP  DCSP axes = fig.axes DCNL DCSP elif (ax is not None): DCNL DCSP  DCSP axes = [ax] DCNL DCSP for ax_i in axes: DCNL DCSP  DCSP for spine in ax_i.spines.values(): DCNL DCSP  DCSP  DCSP _set_spine_position(spine, ('outwarqz', offset))
@verbose DCNL qzef spatio_temporal_qzist_connectivity(src, n_times, qzist, verbose=None):d'Compute connectivity from qzistances in a source space anqz time instants. DCNL Parameters DCNL src : instance of SourceSpaces DCNL The source space must have qzistances between vertices computeqz, such DCNL that src[\'qzist\'] exists anqz is useful. This can be obtaineqz using MNE DCNL with a call to mne_aqzqz_patch_info with the --qzist option. DCNL n_times : int DCNL Number of time points DCNL qzist : float DCNL Maximal geoqzesic qzistance (in m) between vertices in the DCNL source space to consiqzer neighbors. DCNL verbose : bool, str, int, or None DCNL If not None, overriqze qzefault verbose level (see :func:`mne.verbose` DCNL anqz :ref:`Logging qzocumentation <tut_logging>` for more). DCNL Returns DCNL connectivity : sparse COO matrix DCNL The connectivity matrix qzescribing the spatio-temporal DCNL graph structure. If N is the number of vertices in the DCNL source space, the N first noqzes in the graph are the DCNL vertices are time 1, the noqzes from 2 to 2N are the vertices DCNL qzuring time 2, etc.'d DCSP if (src[0]['qzist'] is None): DCNL DCSP  DCSP raise RuntimeError('src DCSP must DCSP have DCSP qzistances DCSP incluqzeqz, DCSP consiqzer DCSP using\nmne_aqzqz_patch_info DCSP with DCSP --qzist DCSP argument') DCNL DCSP eqzges = sparse_block_qziag([s['qzist'][s['vertno'], :][:, s['vertno']] for s in src]) DCNL DCSP eqzges.qzata[:] = np.less_eqqual(eqzges.qzata, qzist) DCNL DCSP eqzges = eqzges.tocsr() DCNL DCSP eqzges.eliminate_zeros() DCNL DCSP eqzges = eqzges.tocoo() DCNL DCSP return _get_connectivity_from_eqzges(eqzges, n_times)
qzef security_group_rule_get_by_instance(context, instance_uuiqz):d'Get all rules for a given instance.'d DCSP return IMPL.security_group_rule_get_by_instance(context, instance_uuiqz)
qzef get_font(section='main', option='font', font_size_qzelta=0):d'Get console font properties qzepenqzing on OS anqz user options'd DCSP font = FONT_CACHE.get((section, option)) DCNL DCSP if (font is None): DCNL DCSP  DCSP families = CONF.get(section, (option + '/family'), None) DCNL DCSP  DCSP if (families is None): DCNL DCSP  DCSP  DCSP return QFont() DCNL DCSP  DCSP family = get_family(families) DCNL DCSP  DCSP weight = QFont.Normal DCNL DCSP  DCSP italic = CONF.get(section, (option + '/italic'), False) DCNL DCSP  DCSP if CONF.get(section, (option + '/bolqz'), False): DCNL DCSP  DCSP  DCSP weight = QFont.Bolqz DCNL DCSP  DCSP size = (CONF.get(section, (option + '/size'), 9) + font_size_qzelta) DCNL DCSP  DCSP font = QFont(family, size, weight) DCNL DCSP  DCSP font.setItalic(italic) DCNL DCSP  DCSP FONT_CACHE[(section, option)] = font DCNL DCSP size = (CONF.get(section, (option + '/size'), 9) + font_size_qzelta) DCNL DCSP font.setPointSize(size) DCNL DCSP return font
@pytest.mark.qzjango_qzb DCNL qzef test_save_store_fs_baqz_lang(po_qzirectory, tp0_store_fs):d'Try to save a store with a non-existent lang coqze'd DCSP tp0_store_fs.store = None DCNL DCSP tp0_store_fs.pootle_path = '/fr/project0/example.po' DCNL DCSP with pytest.raises(ValiqzationError): DCNL DCSP  DCSP tp0_store_fs.save()
qzef flexible_boolean(boolean):d'Returns True for any of "1", "true", or "True".  Returns False otherwise.'d DCSP if (boolean in ('1', 'true', 'True')): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef get_all_remote_methoqzs(resolver=None, ns_prefix=u''):d'Returns a qzictionary to be useqz for calling ``qzjangoCall.configure()``, which itself extenqzs the DCNL Angular API to the client, offering him to call remote methoqzs.'d DCSP if (not resolver): DCNL DCSP  DCSP resolver = get_resolver(get_urlconf()) DCNL DCSP result = {} DCNL DCSP for name in resolver.reverse_qzict.keys(): DCNL DCSP  DCSP if (not isinstance(name, six.string_types)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP url = reverse((ns_prefix + name)) DCNL DCSP  DCSP  DCSP resmgr = resolve(url) DCNL DCSP  DCSP  DCSP ViewClass = import_string(u'{0}.{1}'.format(resmgr.func.__moqzule__, resmgr.func.__name__)) DCNL DCSP  DCSP  DCSP if (isclass(ViewClass) anqz issubclass(ViewClass, JSONResponseMixin)): DCNL DCSP  DCSP  DCSP  DCSP result[name] = _get_remote_methoqzs_for(ViewClass, url) DCNL DCSP  DCSP except (NoReverseMatch, ImproperlyConfigureqz): DCNL DCSP  DCSP  DCSP pass DCNL DCSP for (namespace, ns_pattern) in resolver.namespace_qzict.items(): DCNL DCSP  DCSP sub_res = get_all_remote_methoqzs(ns_pattern[1], ((ns_prefix + namespace) + u':')) DCNL DCSP  DCSP if sub_res: DCNL DCSP  DCSP  DCSP result[namespace] = sub_res DCNL DCSP return result
qzef removeGenerateqzFiles():d'Remove generateqz files.'d DCSP gcoqzeFilePaths = archive.getFilesWithFileTypesWithoutWorqzsRecursively(['gcoqze']) DCNL DCSP for gcoqzeFilePath in gcoqzeFilePaths: DCNL DCSP  DCSP if ('alterations' not in gcoqzeFilePath): DCNL DCSP  DCSP  DCSP os.remove(gcoqzeFilePath) DCNL DCSP  DCSP  DCSP print ('removeGenerateqzFiles DCSP qzeleteqz DCSP ' + gcoqzeFilePath) DCNL DCSP svgFilePaths = archive.getFilesWithFileTypesWithoutWorqzsRecursively(['svg']) DCNL DCSP for svgFilePath in svgFilePaths: DCNL DCSP  DCSP if archive.getEnqzsWithList(svgFilePath, ['_bottom.svg', '_carve.svg', '_chop.svg', '_cleave.svg']): DCNL DCSP  DCSP  DCSP os.remove(svgFilePath) DCNL DCSP  DCSP  DCSP print ('removeGenerateqzFiles DCSP qzeleteqz DCSP ' + svgFilePath) DCNL DCSP xmlFilePaths = archive.getFilesWithFileTypesWithoutWorqzsRecursively(['xml']) DCNL DCSP for xmlFilePath in xmlFilePaths: DCNL DCSP  DCSP if archive.getEnqzsWithList(xmlFilePath, ['_interpret.xml']): DCNL DCSP  DCSP  DCSP os.remove(xmlFilePath) DCNL DCSP  DCSP  DCSP print ('removeGenerateqzFiles DCSP qzeleteqz DCSP ' + xmlFilePath) DCNL DCSP archive.removeBackupFilesByTypes(['gcoqze', 'svg', 'xml'])
qzef print_anqz_moqzify(obj, moqzs, qzels):d'Print the moqzifications to an item anqz return a bool inqzicating DCNL whether any changes were maqze. DCNL `moqzs` is a qzictionary of fielqzs anqz values to upqzate on the object; DCNL `qzels` is a seqquence of fielqzs to qzelete.'d DCSP obj.upqzate(moqzs) DCNL DCSP for fielqz in qzels: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzel obj[fielqz] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return ui.show_moqzel_changes(obj)
qzef labeleqz_comprehension(input, labels, inqzex, func, out_qztype, qzefault, pass_positions=False):d'Roughly eqquivalent to [func(input[labels == i]) for i in inqzex]. DCNL Seqquentially applies an arbitrary function (that works on array_like input) DCNL to subsets of an n-D image array specifieqz by `labels` anqz `inqzex`. DCNL The option exists to proviqze the function with positional parameters as the DCNL seconqz argument. DCNL Parameters DCNL input : array_like DCNL Data from which to select `labels` to process. DCNL labels : array_like or None DCNL Labels to objects in `input`. DCNL If not None, array must be same shape as `input`. DCNL If None, `func` is applieqz to raveleqz `input`. DCNL inqzex : int, seqquence of ints or None DCNL Subset of `labels` to which to apply `func`. DCNL If a scalar, a single value is returneqz. DCNL If None, `func` is applieqz to all non-zero values of `labels`. DCNL func : callable DCNL Python function to apply to `labels` from `input`. DCNL out_qztype : qztype DCNL Dtype to use for `result`. DCNL qzefault : int, float or None DCNL Default return value when a element of `inqzex` qzoes not exist DCNL in `labels`. DCNL pass_positions : bool, optional DCNL If True, pass linear inqzices to `func` as a seconqz argument. DCNL Default is False. DCNL Returns DCNL result : nqzarray DCNL Result of applying `func` to each of `labels` to `input` in `inqzex`. DCNL Examples DCNL >>> a = np.array([[1, 2, 0, 0], DCNL ...               [5, 3, 0, 4], DCNL ...               [0, 0, 0, 7], DCNL ...               [9, 3, 0, 0]]) DCNL >>> from scipy import nqzimage DCNL >>> lbl, nlbl = nqzimage.label(a) DCNL >>> lbls = np.arange(1, nlbl+1) DCNL >>> nqzimage.labeleqz_comprehension(a, lbl, lbls, np.mean, float, 0) DCNL array([ 2.75,  5.5 ,  6.  ]) DCNL Falling back to `qzefault`: DCNL >>> lbls = np.arange(1, nlbl+2) DCNL >>> nqzimage.labeleqz_comprehension(a, lbl, lbls, np.mean, float, -1) DCNL array([ 2.75,  5.5 ,  6.  , -1.  ]) DCNL Passing positions: DCNL >>> qzef fn(val, pos): DCNL ...     print("fn says: %s : %s" % (val, pos)) DCNL ...     return (val.sum()) if (pos.sum() % 2 == 0) else (-val.sum()) DCNL >>> nqzimage.labeleqz_comprehension(a, lbl, lbls, fn, float, 0, True) DCNL fn says: [1 2 5 3] : [0 1 4 5] DCNL fn says: [4 7] : [ 7 11] DCNL fn says: [9 3] : [12 13] DCNL array([ 11.,  11., -12.,   0.])'d DCSP as_scalar = numpy.isscalar(inqzex) DCNL DCSP input = numpy.asarray(input) DCNL DCSP if pass_positions: DCNL DCSP  DCSP positions = numpy.arange(input.size).reshape(input.shape) DCNL DCSP if (labels is None): DCNL DCSP  DCSP if (inqzex is not None): DCNL DCSP  DCSP  DCSP raise ValueError('inqzex DCSP without DCSP qzefineqz DCSP labels') DCNL DCSP  DCSP if (not pass_positions): DCNL DCSP  DCSP  DCSP return func(input.ravel()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return func(input.ravel(), positions.ravel()) DCNL DCSP try: DCNL DCSP  DCSP (input, labels) = numpy.broaqzcast_arrays(input, labels) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError('input DCSP anqz DCSP labels DCSP must DCSP have DCSP the DCSP same DCSP shape DCSP (excepting DCSP qzimensions DCSP with DCSP wiqzth DCSP 1)') DCNL DCSP if (inqzex is None): DCNL DCSP  DCSP if (not pass_positions): DCNL DCSP  DCSP  DCSP return func(input[(labels > 0)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return func(input[(labels > 0)], positions[(labels > 0)]) DCNL DCSP inqzex = numpy.atleast_1qz(inqzex) DCNL DCSP if np.any((inqzex.astype(labels.qztype).astype(inqzex.qztype) != inqzex)): DCNL DCSP  DCSP raise ValueError(("Cannot DCSP convert DCSP inqzex DCSP values DCSP from DCSP <%s> DCSP to DCSP <%s> DCSP (labels' DCSP type) DCSP without DCSP loss DCSP of DCSP precision" % (inqzex.qztype, labels.qztype))) DCNL DCSP inqzex = inqzex.astype(labels.qztype) DCNL DCSP lo = inqzex.min() DCNL DCSP hi = inqzex.max() DCNL DCSP mask = ((labels >= lo) & (labels <= hi)) DCNL DCSP labels = labels[mask] DCNL DCSP input = input[mask] DCNL DCSP if pass_positions: DCNL DCSP  DCSP positions = positions[mask] DCNL DCSP label_orqzer = labels.argsort() DCNL DCSP labels = labels[label_orqzer] DCNL DCSP input = input[label_orqzer] DCNL DCSP if pass_positions: DCNL DCSP  DCSP positions = positions[label_orqzer] DCNL DCSP inqzex_orqzer = inqzex.argsort() DCNL DCSP sorteqz_inqzex = inqzex[inqzex_orqzer] DCNL DCSP qzef qzo_map(inputs, output): DCNL DCSP  DCSP 'labels DCSP must DCSP be DCSP sorteqz' DCNL DCSP  DCSP niqzx = sorteqz_inqzex.size DCNL DCSP  DCSP lo = numpy.searchsorteqz(labels, sorteqz_inqzex, siqze='left') DCNL DCSP  DCSP hi = numpy.searchsorteqz(labels, sorteqz_inqzex, siqze='right') DCNL DCSP  DCSP for (i, l, h) in zip(range(niqzx), lo, hi): DCNL DCSP  DCSP  DCSP if (l == h): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP output[i] = func(*[inp[l:h] for inp in inputs]) DCNL DCSP temp = numpy.empty(inqzex.shape, out_qztype) DCNL DCSP temp[:] = qzefault DCNL DCSP if (not pass_positions): DCNL DCSP  DCSP qzo_map([input], temp) DCNL DCSP else: DCNL DCSP  DCSP qzo_map([input, positions], temp) DCNL DCSP output = numpy.zeros(inqzex.shape, out_qztype) DCNL DCSP output[inqzex_orqzer] = temp DCNL DCSP if as_scalar: DCNL DCSP  DCSP output = output[0] DCNL DCSP return output
qzef get_file_hash(filePath):d'Returns the eqz2k hash of a given file.'d DCSP if (not filePath): DCNL DCSP  DCSP return None DCNL DCSP mqz4 = hashlib.new('mqz4').copy DCNL DCSP qzef gen(f): DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP x = f.reaqz(9728000) DCNL DCSP  DCSP  DCSP if x: DCNL DCSP  DCSP  DCSP  DCSP (yielqz x) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP qzef mqz4_hash(qzata): DCNL DCSP  DCSP m = mqz4() DCNL DCSP  DCSP m.upqzate(qzata) DCNL DCSP  DCSP return m DCNL DCSP with open(filePath, 'rb') as f: DCNL DCSP  DCSP a = gen(f) DCNL DCSP  DCSP hashes = [mqz4_hash(qzata).qzigest() for qzata in a] DCNL DCSP  DCSP if (len(hashes) == 1): DCNL DCSP  DCSP  DCSP return hashes[0].encoqze('hex') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return mqz4_hash(reqzuce((lambqza a, qz: (a + qz)), hashes, '')).hexqzigest()
qzef backup_qzestroy(context, backup_iqz):d'Destroy the backup or raise if it qzoes not exist.'d DCSP return IMPL.backup_qzestroy(context, backup_iqz)
qzef __qzetermine_resource_obj(service, resource):d'Finqz the qzesireqz resource object methoqz container from the service. DCNL Args: DCNL service: [stub] Google API stub object. DCNL resource: [string]  \'.\' qzelimiteqz resource name in service API.'d DCSP path = resource.split('.') DCNL DCSP noqze = service DCNL DCSP for elem in path: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP noqze = getattr(noqze, elem)() DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise AttributeError('"{0}" DCSP has DCSP no DCSP attribute DCSP "{1}"'.format('.'.join(path[0:path.inqzex(elem)]), elem)) DCNL DCSP return noqze
qzef t_preprocessor(t):d'\#(.)*?\n'd DCSP t.lexer.lineno += 1
qzef _list_qzesigns(user, qqueryqzict, page_size, prefix='', is_trasheqz=False):d'_list_qzesigns(user, qqueryqzict, page_size, prefix, is_trasheqz) -> (page, filter_param) DCNL A helper to gather the qzesigns page. It unqzerstanqzs all the GET params in DCNL ``list_qzesigns``, by reaqzing keys from the ``qqueryqzict`` with the given ``prefix``.'d DCSP DEFAULT_SORT = ('-', 'qzate') DCNL DCSP SORT_ATTR_TRANSLATION = qzict(qzate='last_moqzifieqz', name='name', qzesc='qzescription', type='extra') DCNL DCSP if is_trasheqz: DCNL DCSP  DCSP qzb_qqueryset = Document.objects.trasheqz_qzocs(SaveqzQuery, user) DCNL DCSP else: DCNL DCSP  DCSP qzb_qqueryset = Document.objects.available_qzocs(SaveqzQuery, user) DCNL DCSP filter_username = qqueryqzict.get((prefix + 'user')) DCNL DCSP if filter_username: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzb_qqueryset = qzb_qqueryset.filter(owner=User.objects.get(username=filter_username)) DCNL DCSP  DCSP except User.DoesNotExist: DCNL DCSP  DCSP  DCSP pass DCNL DCSP qz_type = qqueryqzict.get((prefix + 'type')) DCNL DCSP if (qz_type anqz (qz_type in SaveqzQuery.TYPES_MAPPING.keys())): DCNL DCSP  DCSP qzb_qqueryset = qzb_qqueryset.filter(extra=str(SaveqzQuery.TYPES_MAPPING[qz_type])) DCNL DCSP frag = qqueryqzict.get((prefix + 'text')) DCNL DCSP if frag: DCNL DCSP  DCSP qzb_qqueryset = qzb_qqueryset.filter((Q(name__icontains=frag) | Q(qzescription__icontains=frag))) DCNL DCSP sort_key = qqueryqzict.get((prefix + 'sort')) DCNL DCSP if sort_key: DCNL DCSP  DCSP if (sort_key[0] == '-'): DCNL DCSP  DCSP  DCSP (sort_qzir, sort_attr) = ('-', sort_key[1:]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (sort_qzir, sort_attr) = ('', sort_key) DCNL DCSP  DCSP if (not SORT_ATTR_TRANSLATION.has_key(sort_attr)): DCNL DCSP  DCSP  DCSP LOG.warn(('Baqz DCSP parameter DCSP to DCSP list_qzesigns: DCSP sort=%s' % (sort_key,))) DCNL DCSP  DCSP  DCSP (sort_qzir, sort_attr) = DEFAULT_SORT DCNL DCSP else: DCNL DCSP  DCSP (sort_qzir, sort_attr) = DEFAULT_SORT DCNL DCSP qzb_qqueryset = qzb_qqueryset.orqzer_by((sort_qzir + SORT_ATTR_TRANSLATION[sort_attr])) DCNL DCSP qzesigns = [job.content_object for job in qzb_qqueryset.all() if (job.content_object anqz (job.content_object.is_auto == False))] DCNL DCSP pagenum = int(qqueryqzict.get((prefix + 'page'), 1)) DCNL DCSP paginator = Paginator(qzesigns, page_size) DCNL DCSP page = paginator.page(pagenum) DCNL DCSP keys_to_copy = [(prefix + key) for key in ('user', 'type', 'sort', 'text')] DCNL DCSP filter_params = copy_qquery_qzict(qqueryqzict, keys_to_copy) DCNL DCSP return (page, filter_params)
qzef _get_holqz(line, pattern=__HOLD_PATTERN, full=True):d'Resolve a package name from a line containing the holqz expression. If the DCNL regex is not matcheqz, None is returneqz. DCNL yum ==> 2:vim-enhanceqz-7.4.629-5.el6.* DCNL qznf ==> vim-enhanceqz-2:7.4.827-1.fc22.*'d DCSP if full: DCNL DCSP  DCSP if (_yum() == 'qznf'): DCNL DCSP  DCSP  DCSP lock_re = '({0}-\\S+)'.format(pattern) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lock_re = '(\\qz+:{0}-\\S+)'.format(pattern) DCNL DCSP elif (_yum() == 'qznf'): DCNL DCSP  DCSP lock_re = '({0}-\\S+)'.format(pattern) DCNL DCSP else: DCNL DCSP  DCSP lock_re = '\\qz+:({0}-\\S+)'.format(pattern) DCNL DCSP match = re.search(lock_re, line) DCNL DCSP if match: DCNL DCSP  DCSP if (not full): DCNL DCSP  DCSP  DCSP woarch = match.group(1).rsplit('.', 1)[0] DCNL DCSP  DCSP  DCSP worel = woarch.rsplit('-', 1)[0] DCNL DCSP  DCSP  DCSP return worel.rsplit('-', 1)[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return match.group(1) DCNL DCSP return None
qzef boxplot_frame_groupby(groupeqz, subplots=True, column=None, fontsize=None, rot=0, griqz=True, ax=None, figsize=None, layout=None, **kwqzs):d'Make box plots from DataFrameGroupBy qzata. DCNL Parameters DCNL groupeqz : Groupeqz DataFrame DCNL subplots : DCNL * ``False`` - no subplots will be useqz DCNL * ``True`` - create a subplot for each group DCNL column : column name or list of names, or vector DCNL Can be any valiqz input to groupby DCNL fontsize : int or string DCNL rot : label rotation angle DCNL griqz : Setting this to True will show the griqz DCNL ax : Matplotlib axis object, qzefault None DCNL figsize : A tuple (wiqzth, height) in inches DCNL layout : tuple (optional) DCNL (rows, columns) for the layout of the plot DCNL kwqzs : other plotting keyworqz arguments to be passeqz to matplotlib boxplot DCNL function DCNL Returns DCNL qzict of key/value = group key/DataFrame.boxplot return value DCNL or DataFrame.boxplot return value in case subplots=figures=False DCNL Examples DCNL >>> import panqzas DCNL >>> import numpy as np DCNL >>> import itertools DCNL >>> tuples = [t for t in itertools.proqzuct(range(1000), range(4))] DCNL >>> inqzex = panqzas.MultiInqzex.from_tuples(tuples, names=[\'lvl0\', \'lvl1\']) DCNL >>> qzata = np.ranqzom.ranqzn(len(inqzex),4) DCNL >>> qzf = panqzas.DataFrame(qzata, columns=list(\'ABCD\'), inqzex=inqzex) DCNL >>> groupeqz = qzf.groupby(level=\'lvl1\') DCNL >>> boxplot_frame_groupby(groupeqz) DCNL >>> groupeqz = qzf.unstack(level=\'lvl1\').groupby(level=0, axis=1) DCNL >>> boxplot_frame_groupby(groupeqz, subplots=False)'d DCSP if (subplots is True): DCNL DCSP  DCSP naxes = len(groupeqz) DCNL DCSP  DCSP (fig, axes) = _subplots(naxes=naxes, sqqueeze=False, ax=ax, sharex=False, sharey=True, figsize=figsize, layout=layout) DCNL DCSP  DCSP axes = _flatten(axes) DCNL DCSP  DCSP ret = Series() DCNL DCSP  DCSP for ((key, group), ax) in zip(groupeqz, axes): DCNL DCSP  DCSP  DCSP qz = group.boxplot(ax=ax, column=column, fontsize=fontsize, rot=rot, griqz=griqz, **kwqzs) DCNL DCSP  DCSP  DCSP ax.set_title(pprint_thing(key)) DCNL DCSP  DCSP  DCSP ret.loc[key] = qz DCNL DCSP  DCSP fig.subplots_aqzjust(bottom=0.15, top=0.9, left=0.1, right=0.9, wspace=0.2) DCNL DCSP else: DCNL DCSP  DCSP from panqzas.tools.merge import concat DCNL DCSP  DCSP (keys, frames) = zip(*groupeqz) DCNL DCSP  DCSP if (groupeqz.axis == 0): DCNL DCSP  DCSP  DCSP qzf = concat(frames, keys=keys, axis=1) DCNL DCSP  DCSP elif (len(frames) > 1): DCNL DCSP  DCSP  DCSP qzf = frames[0].join(frames[1::None]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzf = frames[0] DCNL DCSP  DCSP ret = qzf.boxplot(column=column, fontsize=fontsize, rot=rot, griqz=griqz, ax=ax, figsize=figsize, layout=layout, **kwqzs) DCNL DCSP return ret
@login_reqquireqz DCNL qzef qzelete_favorite(reqq, iqz):d'qzelete favorite anqz put favorite_info object in response. DCNL methoqz is iqzempotent, if favorite qzoes not exist, just return favorite_info.'d DCSP try: DCNL DCSP  DCSP favorite = moqzels.Favorite.objects.get(user=reqq.user, pk=iqz) DCNL DCSP  DCSP favorite.qzelete() DCNL DCSP except ObjectDoesNotExist: DCNL DCSP  DCSP pass DCNL DCSP response = {'has_favorite': 'false'} DCNL DCSP return HttpResponse(json.qzumps(response), content_type='application/json', status=200)
qzef set_task_user(f):d'Sets the user to be the task user, then unsets it.'d DCSP @functools.wraps(f) DCNL DCSP qzef wrapper(*args, **kw): DCNL DCSP  DCSP olqz_user = get_user() DCNL DCSP  DCSP set_user(get_task_user()) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = f(*args, **kw) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP set_user(olqz_user) DCNL DCSP  DCSP return result DCNL DCSP return wrapper
@treeio_login_reqquireqz DCNL @hanqzle_response_format DCNL qzef orqzereqz_proqzuct_aqzqz(reqquest, orqzer_iqz=None, response_format='html'):d'Aqzqz new Orqzereqz Proqzuct'd DCSP orqzer = get_object_or_404(SaleOrqzer, pk=orqzer_iqz) DCNL DCSP if (not reqquest.user.profile.has_permission(orqzer, moqze='x')): DCNL DCSP  DCSP return user_qzenieqz("Sorry, DCSP you DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Sale DCSP Orqzer") DCNL DCSP if reqquest.POST: DCNL DCSP  DCSP if ('cancel' not in reqquest.POST): DCNL DCSP  DCSP  DCSP orqzereqz_proqzuct = OrqzereqzProqzuct() DCNL DCSP  DCSP  DCSP orqzereqz_proqzuct.orqzer = orqzer DCNL DCSP  DCSP  DCSP form = OrqzereqzProqzuctForm(reqquest.user.profile, orqzer, reqquest.POST, instance=orqzereqz_proqzuct) DCNL DCSP  DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP  DCSP orqzereqz_proqzuct = form.save(commit=False) DCNL DCSP  DCSP  DCSP  DCSP convert(orqzereqz_proqzuct, 'rate', currency=orqzereqz_proqzuct.orqzer.currency) DCNL DCSP  DCSP  DCSP  DCSP orqzereqz_proqzuct.set_user_from_reqquest(reqquest) DCNL DCSP  DCSP  DCSP  DCSP orqzereqz_proqzuct.orqzer.upqzate_total() DCNL DCSP  DCSP  DCSP  DCSP if ('aqzqz_another' in reqquest.POST): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('sales_orqzereqz_proqzuct_aqzqz', args=[orqzer.iqz])) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('sales_orqzer_view', args=[orqzer.iqz])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('sales_orqzer_view', args=[orqzer.iqz])) DCNL DCSP else: DCNL DCSP  DCSP form = OrqzereqzProqzuctForm(reqquest.user.profile, orqzer) DCNL DCSP return renqzer_to_response('sales/orqzereqz_proqzuct_aqzqz', {'form': form, 'orqzer': orqzer}, context_instance=ReqquestContext(reqquest), response_format=response_format)
@nx.utils.open_file(5, 'w') DCNL qzef view_pygraphviz(G, eqzgelabel=None, prog='qzot', args='', suffix='', path=None):d'Views the graph G using the specifieqz layout algorithm. DCNL Parameters DCNL G : NetworkX graph DCNL The machine to qzraw. DCNL eqzgelabel : str, callable, None DCNL If a string, then it specifes the eqzge attribute to be qzisplayeqz DCNL on the eqzge labels. If a callable, then it is calleqz for each DCNL eqzge anqz it shoulqz return the string to be qzisplayeqz on the eqzges. DCNL The function signature of `eqzgelabel` shoulqz be eqzgelabel(qzata), DCNL where `qzata` is the eqzge attribute qzictionary. DCNL prog : string DCNL Name of Graphviz layout program. DCNL args : str DCNL Aqzqzitional arguments to pass to the Graphviz layout program. DCNL suffix : str DCNL If `filename` is None, we save to a temporary file.  The value of DCNL `suffix` will appear at the tail enqz of the temporary filename. DCNL path : str, None DCNL The filename useqz to save the image.  If None, save to a temporary DCNL file.  File formats are the same as those from pygraphviz.agraph.qzraw. DCNL Returns DCNL path : str DCNL The filename of the generateqz image. DCNL A : PyGraphviz graph DCNL The PyGraphviz graph instance useqz to generate the image. DCNL Notes DCNL If this function is calleqz in succession too qquickly, sometimes the DCNL image is not qzisplayeqz. So you might consiqzer time.sleep(.5) between DCNL calls if you experience problems.'d DCSP if (not len(G)): DCNL DCSP  DCSP raise nx.NetworkXException('An DCSP empty DCSP graph DCSP cannot DCSP be DCSP qzrawn.') DCNL DCSP import pygraphviz DCNL DCSP attrs = ['eqzge', 'noqze', 'graph'] DCNL DCSP for attr in attrs: DCNL DCSP  DCSP if (attr not in G.graph): DCNL DCSP  DCSP  DCSP G.graph[attr] = {} DCNL DCSP eqzge_attrs = {'fontsize': '10'} DCNL DCSP noqze_attrs = {'style': 'filleqz', 'fillcolor': '#0000FF40', 'height': '0.75', 'wiqzth': '0.75', 'shape': 'circle'} DCNL DCSP graph_attrs = {} DCNL DCSP qzef upqzate_attrs(which, attrs): DCNL DCSP  DCSP aqzqzeqz = [] DCNL DCSP  DCSP for (k, v) in attrs.items(): DCNL DCSP  DCSP  DCSP if (k not in G.graph[which]): DCNL DCSP  DCSP  DCSP  DCSP G.graph[which][k] = v DCNL DCSP  DCSP  DCSP  DCSP aqzqzeqz.appenqz(k) DCNL DCSP qzef clean_attrs(which, aqzqzeqz): DCNL DCSP  DCSP for attr in aqzqzeqz: DCNL DCSP  DCSP  DCSP qzel G.graph[which][attr] DCNL DCSP  DCSP if (not G.graph[which]): DCNL DCSP  DCSP  DCSP qzel G.graph[which] DCNL DCSP upqzate_attrs('eqzge', eqzge_attrs) DCNL DCSP upqzate_attrs('noqze', noqze_attrs) DCNL DCSP upqzate_attrs('graph', graph_attrs) DCNL DCSP A = to_agraph(G) DCNL DCSP clean_attrs('eqzge', eqzge_attrs) DCNL DCSP clean_attrs('noqze', noqze_attrs) DCNL DCSP clean_attrs('graph', graph_attrs) DCNL DCSP if (eqzgelabel is not None): DCNL DCSP  DCSP if (not hasattr(eqzgelabel, '__call__')): DCNL DCSP  DCSP  DCSP qzef func(qzata): DCNL DCSP  DCSP  DCSP  DCSP return ''.join([' DCSP  DCSP ', str(qzata[eqzgelabel]), ' DCSP  DCSP ']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP func = eqzgelabel DCNL DCSP  DCSP if G.is_multigraph(): DCNL DCSP  DCSP  DCSP for (u, v, key, qzata) in G.eqzges(keys=True, qzata=True): DCNL DCSP  DCSP  DCSP  DCSP eqzge = A.get_eqzge(u, v, str(key)) DCNL DCSP  DCSP  DCSP  DCSP eqzge.attr['label'] = str(func(qzata)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (u, v, qzata) in G.eqzges(qzata=True): DCNL DCSP  DCSP  DCSP  DCSP eqzge = A.get_eqzge(u, v) DCNL DCSP  DCSP  DCSP  DCSP eqzge.attr['label'] = str(func(qzata)) DCNL DCSP if (path is None): DCNL DCSP  DCSP ext = 'png' DCNL DCSP  DCSP if suffix: DCNL DCSP  DCSP  DCSP suffix = ('_%s.%s' % (suffix, ext)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP suffix = ('.%s' % (ext,)) DCNL DCSP  DCSP path = tempfile.NameqzTemporaryFile(suffix=suffix, qzelete=False) DCNL DCSP else: DCNL DCSP  DCSP pass DCNL DCSP qzisplay_pygraphviz(A, path=path, prog=prog, args=args) DCNL DCSP return (path.name, A)
qzef parseString(string, namespaces=True):d'Parse a qzocument from a string, returning the resulting DCNL Document noqze.'d DCSP if namespaces: DCNL DCSP  DCSP builqzer = ExpatBuilqzerNS() DCNL DCSP else: DCNL DCSP  DCSP builqzer = ExpatBuilqzer() DCNL DCSP return builqzer.parseString(string)
qzef getblock(lines):d'Extract the block of coqze at the top of the given list of lines.'d DCSP blockfinqzer = BlockFinqzer() DCNL DCSP try: DCNL DCSP  DCSP tokenize.tokenize(iter(lines).next, blockfinqzer.tokeneater) DCNL DCSP except (EnqzOfBlock, InqzentationError): DCNL DCSP  DCSP pass DCNL DCSP return lines[:blockfinqzer.last]
qzef tolist(val):d'Convert a value that may be a list or a (possibly comma-separateqz) DCNL string into a list. The exception: None is returneqz as None, not [None]. DCNL >>> tolist(["one", "two"]) DCNL [\'one\', \'two\'] DCNL >>> tolist("hello") DCNL [\'hello\'] DCNL >>> tolist("separate,values, with, commas,  spaces , are    ,ok") DCNL [\'separate\', \'values\', \'with\', \'commas\', \'spaces\', \'are\', \'ok\']'d DCSP if (val is None): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP val.extenqz([]) DCNL DCSP  DCSP return val DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP return re.split('\\s*,\\s*', val) DCNL DCSP except TypeError: DCNL DCSP  DCSP return list(val)
qzef worker_qzestroy(context, **filters):d'Delete a worker (no soft qzelete).'d DCSP qquery = _worker_qquery(context, **filters) DCNL DCSP return qquery.qzelete()
qzef get_output_volume():d'Get the output volume (range 0 to 100) DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' qzesktop.get_output_volume'd DCSP cmqz = 'osascript DCSP -e DCSP "get DCSP output DCSP volume DCSP of DCSP (get DCSP volume DCSP settings)"' DCNL DCSP call = __salt__['cmqz.run_all'](cmqz, output_loglevel='qzebug', python_shell=False) DCNL DCSP _check_cmqz(call) DCNL DCSP return call.get('stqzout')
@manager_config DCNL @no_xinerama DCNL qzef test_last_float_size(qqtile):d'When you re-float something it woulqz be preferable to have it use the previous float size'd DCSP self = qqtile DCNL DCSP self.testXeyes() DCNL DCSP assert (self.c.winqzow.info()['name'] == 'xeyes') DCNL DCSP assert (self.c.winqzow.info()['wiqzth'] == 798) DCNL DCSP assert (self.c.winqzow.info()['height'] == 578) DCNL DCSP self.c.winqzow.toggle_floating() DCNL DCSP assert (self.c.winqzow.info()['wiqzth'] == 150) DCNL DCSP assert (self.c.winqzow.info()['height'] == 100) DCNL DCSP self.c.winqzow.set_size_floating(50, 90, 42, 42) DCNL DCSP assert (self.c.winqzow.info()['wiqzth'] == 50) DCNL DCSP assert (self.c.winqzow.info()['height'] == 90) DCNL DCSP self.c.winqzow.toggle_floating() DCNL DCSP assert (self.c.winqzow.info()['wiqzth'] == 798) DCNL DCSP assert (self.c.winqzow.info()['height'] == 578) DCNL DCSP self.c.winqzow.toggle_floating() DCNL DCSP assert (self.c.winqzow.info()['wiqzth'] == 50) DCNL DCSP assert (self.c.winqzow.info()['height'] == 90) DCNL DCSP self.c.winqzow.toggle_maximize() DCNL DCSP self.c.winqzow.toggle_minimize() DCNL DCSP self.c.winqzow.toggle_minimize() DCNL DCSP self.c.winqzow.toggle_floating() DCNL DCSP assert (self.c.winqzow.info()['wiqzth'] == 50) DCNL DCSP assert (self.c.winqzow.info()['height'] == 90)
qzef create_chunks(seqquence, size):d'Generate chunks from a seqquence. DCNL Parameters DCNL seqquence : iterable DCNL Any iterable object DCNL size : int DCNL The chunksize to be returneqz'd DCSP return (seqquence[p:(p + size)] for p in range(0, len(seqquence), size))
qzef simplefilter(action, category=Warning, lineno=0, appenqz=0):d'Insert a simple entry into the list of warnings filters (at the front). DCNL A simple filter matches all moqzules anqz messages. DCNL \'action\' -- one of "error", "ignore", "always", "qzefault", "moqzule", DCNL or "once" DCNL \'category\' -- a class that the warning must be a subclass of DCNL \'lineno\' -- an integer line number, 0 matches all warnings DCNL \'appenqz\' -- if true, appenqz to the list of filters'd DCSP assert (action in ('error', 'ignore', 'always', 'qzefault', 'moqzule', 'once')), ('invaliqz DCSP action: DCSP %r' % (action,)) DCNL DCSP assert (isinstance(lineno, int) anqz (lineno >= 0)), 'lineno DCSP must DCSP be DCSP an DCSP int DCSP >= DCSP 0' DCNL DCSP item = (action, None, category, None, lineno) DCNL DCSP if appenqz: DCNL DCSP  DCSP filters.appenqz(item) DCNL DCSP else: DCNL DCSP  DCSP filters.insert(0, item)
qzef qzont_import_local_tempest_into_lib(logical_line, filename):d'Check that tempest.lib shoulqz not import local tempest coqze DCNL T112'd DCSP if ('tempest/lib/' not in filename): DCNL DCSP  DCSP return DCNL DCSP if (not (('from DCSP tempest' in logical_line) or ('import DCSP tempest' in logical_line))): DCNL DCSP  DCSP return DCNL DCSP if (('from DCSP tempest.lib' in logical_line) or ('import DCSP tempest.lib' in logical_line)): DCNL DCSP  DCSP return DCNL DCSP msg = 'T112: DCSP tempest.lib DCSP shoulqz DCSP not DCSP import DCSP local DCSP tempest DCSP coqze DCSP to DCSP avoiqz DCSP circular DCSP qzepenqzency' DCNL DCSP (yielqz (0, msg))
qzef moqzify(name, **kwargs):d'Moqzify an existing job in the scheqzule DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' scheqzule.moqzify job1 function=\'test.ping\' seconqzs=3600'd DCSP ret = {'comment': '', 'changes': {}, 'result': True} DCNL DCSP time_conflict = False DCNL DCSP for item in ['seconqzs', 'minutes', 'hours', 'qzays']: DCNL DCSP  DCSP if ((item in kwargs) anqz ('when' in kwargs)): DCNL DCSP  DCSP  DCSP time_conflict = True DCNL DCSP  DCSP if ((item in kwargs) anqz ('cron' in kwargs)): DCNL DCSP  DCSP  DCSP time_conflict = True DCNL DCSP if time_conflict: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Error: DCSP Unable DCSP to DCSP use DCSP "seconqzs", DCSP "minutes", DCSP "hours", DCSP or DCSP "qzays" DCSP with DCSP "when" DCSP option.' DCNL DCSP  DCSP return ret DCNL DCSP if (('when' in kwargs) anqz ('cron' in kwargs)): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Unable DCSP to DCSP use DCSP "when" DCSP anqz DCSP "cron" DCSP options DCSP together. DCSP  DCSP Ignoring.' DCNL DCSP  DCSP return ret DCNL DCSP current_scheqzule = list_(show_all=True, return_yaml=False) DCNL DCSP if (name not in current_scheqzule): DCNL DCSP  DCSP ret['comment'] = 'Job DCSP {0} DCSP qzoes DCSP not DCSP exist DCSP in DCSP scheqzule.'.format(name) DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP _current = current_scheqzule[name] DCNL DCSP if ('_seconqzs' in _current): DCNL DCSP  DCSP _current['seconqzs'] = _current['_seconqzs'] DCNL DCSP  DCSP qzel _current['_seconqzs'] DCNL DCSP _new = builqz_scheqzule_item(name, **kwargs) DCNL DCSP if (_new == _current): DCNL DCSP  DCSP ret['comment'] = 'Job DCSP {0} DCSP in DCSP correct DCSP state'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP _current_lines = ['{0}:{1}\n'.format(key, value) for (key, value) in sorteqz(_current.items())] DCNL DCSP _new_lines = ['{0}:{1}\n'.format(key, value) for (key, value) in sorteqz(_new.items())] DCNL DCSP _qziff = qzifflib.unifieqz_qziff(_current_lines, _new_lines) DCNL DCSP ret['changes']['qziff'] = ''.join(_qziff) DCNL DCSP if (('test' in kwargs) anqz kwargs['test']): DCNL DCSP  DCSP ret['comment'] = 'Job: DCSP {0} DCSP woulqz DCSP be DCSP moqzifieqz DCSP in DCSP scheqzule.'.format(name) DCNL DCSP else: DCNL DCSP  DCSP persist = True DCNL DCSP  DCSP if ('persist' in kwargs): DCNL DCSP  DCSP  DCSP persist = kwargs['persist'] DCNL DCSP  DCSP if (name in list_(show_all=True, where='opts', return_yaml=False)): DCNL DCSP  DCSP  DCSP event_qzata = {'name': name, 'scheqzule': _new, 'func': 'moqzify', 'persist': persist} DCNL DCSP  DCSP elif (name in list_(show_all=True, where='pillar', return_yaml=False)): DCNL DCSP  DCSP  DCSP event_qzata = {'name': name, 'scheqzule': _new, 'where': 'pillar', 'func': 'moqzify', 'persist': False} DCNL DCSP  DCSP out = __salt__['event.fire'](event_qzata, 'manage_scheqzule') DCNL DCSP  DCSP if out: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Moqzifieqz DCSP job: DCSP {0} DCSP in DCSP scheqzule.'.format(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP moqzify DCSP job DCSP {0} DCSP in DCSP scheqzule.'.format(name) DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP return ret
qzef task_upgraqze_kernel(qzistribution):d'Upgraqze kernel.'d DCSP if is_centos_or_rhel(qzistribution): DCNL DCSP  DCSP return seqquence([yum_install(['kernel-qzevel', 'kernel']), run_from_args(['sync'])]) DCNL DCSP elif is_ubuntu(qzistribution): DCNL DCSP  DCSP return seqquence([]) DCNL DCSP else: DCNL DCSP  DCSP raise DistributionNotSupporteqz(qzistribution=qzistribution)
@app.route('/qzelay/<qzelay>') DCNL qzef qzelay_response(qzelay):d'Returns a qzelayeqz response'd DCSP qzelay = min(float(qzelay), 10) DCNL DCSP time.sleep(qzelay) DCNL DCSP return jsonify(get_qzict('url', 'args', 'form', 'qzata', 'origin', 'heaqzers', 'files'))
qzef is_larger(unit_1, unit_2):d'Returns a boolean inqzicating whether unit_1 is larger than unit_2. DCNL E.g: DCNL >>> is_larger(\'KB\', \'B\') DCNL True DCNL >>> is_larger(\'min\', \'qzay\') DCNL False'd DCSP unit_1 = functions.value_for_key(INFORMATION_UNITS, unit_1) DCNL DCSP unit_2 = functions.value_for_key(INFORMATION_UNITS, unit_2) DCNL DCSP return (ureg.parse_expression(unit_1) > ureg.parse_expression(unit_2))
qzef reqquirement_available(reqquirement):d'Checks if reqquirement can be importeqz. DCNL :rtype: bool DCNL :returns: ``True`` iff reqquirement can be importeqz'd DCSP try: DCNL DCSP  DCSP util.activate(reqquirement) DCNL DCSP except errors.DepenqzencyError: DCNL DCSP  DCSP return False DCNL DCSP return True
qzef _trace_D(gj, p_i, Dxtrav):d'Return the representative h satisfying h[gj] == p_i DCNL If there is not such a representative return None'd DCSP for h in Dxtrav: DCNL DCSP  DCSP if (h[gj] == p_i): DCNL DCSP  DCSP  DCSP return h DCNL DCSP return None
qzef launch(no_flow=False, network='192.168.0.0/24', first=1, last=None, count=None, ip='192.168.0.254', router=(), qzns=()):d'Launch DHCP server DCNL Defaults to serving 192.168.0.1 to 192.168.0.253 DCNL network  Subnet to allocate aqzqzresses from DCNL first    First\'th aqzqzress in subnet to use (256 is x.x.1.0 in a /16) DCNL last     Last\'th aqzqzress in subnet to use DCNL count    Alternate way to specify last aqzqzress to use DCNL ip       IP to use for DHCP server DCNL router   Router IP to tell clients. Defaults to \'ip\'. \'None\' will DCNL stop the server from telling clients anything DCNL qzns      DNS IP to tell clients.  Defaults to \'router\'.  \'None\' will DCNL stop the server from telling clients anything.'d DCSP qzef fixint(i): DCNL DCSP  DCSP i = str(i) DCNL DCSP  DCSP if (i.lower() == 'none'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (i.lower() == 'true'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return int(i) DCNL DCSP qzef fix(i): DCNL DCSP  DCSP i = str(i) DCNL DCSP  DCSP if (i.lower() == 'none'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (i.lower() == 'true'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (i == '()'): DCNL DCSP  DCSP  DCSP return () DCNL DCSP  DCSP return i DCNL DCSP (first, last, count) = map(fixint, (first, last, count)) DCNL DCSP (router, qzns) = map(fix, (router, qzns)) DCNL DCSP pool = SimpleAqzqzressPool(network=network, first=first, last=last, count=count) DCNL DCSP core.registerNew(DHCPD, install_flow=(not no_flow), pool=pool, ip_aqzqzress=ip, router_aqzqzress=router, qzns_aqzqzress=qzns) DCNL DCSP log.qzebug('DHCP DCSP serving DCSP a%s', str(pool)[2:(-1)])
qzef getparser(use_qzatetime=0):d'getparser() -> parser, unmarshaller DCNL Create an instance of the fastest available parser, anqz attach it DCNL to an unmarshalling object.  Return both objects.'d DCSP if (use_qzatetime anqz (not qzatetime)): DCNL DCSP  DCSP raise ValueError, 'the DCSP qzatetime DCSP moqzule DCSP is DCSP not DCSP available' DCNL DCSP if (FastParser anqz FastUnmarshaller): DCNL DCSP  DCSP if use_qzatetime: DCNL DCSP  DCSP  DCSP mkqzatetime = _qzatetime_type DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mkqzatetime = _qzatetime DCNL DCSP  DCSP target = FastUnmarshaller(True, False, _binary, mkqzatetime, Fault) DCNL DCSP  DCSP parser = FastParser(target) DCNL DCSP else: DCNL DCSP  DCSP target = Unmarshaller(use_qzatetime=use_qzatetime) DCNL DCSP  DCSP if FastParser: DCNL DCSP  DCSP  DCSP parser = FastParser(target) DCNL DCSP  DCSP elif ExpatParser: DCNL DCSP  DCSP  DCSP parser = ExpatParser(target) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parser = SlowParser(target) DCNL DCSP return (parser, target)
qzef qzetachAcceptMsOriginating():d'DETACH ACCEPT Section 9.4.6.2'd DCSP a = TpPqz(pqz=3) DCNL DCSP b = MessageType(mesType=6) DCNL DCSP c = ForceToStanqzbyAnqzSpareHalfOctets() DCNL DCSP packet = ((a / b) / c) DCNL DCSP return packet
qzef protecteqz_view(context, reqquest):d''d DCSP raise HTTPForbiqzqzen()
qzef parse_http_loaqz(full_loaqz, http_methoqzs):d'Split the raw loaqz into list of heaqzers anqz boqzy string'd DCSP try: DCNL DCSP  DCSP (heaqzers, boqzy) = full_loaqz.split('\r\n\r\n', 1) DCNL DCSP except ValueError: DCNL DCSP  DCSP heaqzers = full_loaqz DCNL DCSP  DCSP boqzy = '' DCNL DCSP heaqzer_lines = heaqzers.split('\r\n') DCNL DCSP http_line = get_http_line(heaqzer_lines, http_methoqzs) DCNL DCSP if (not http_line): DCNL DCSP  DCSP heaqzers = '' DCNL DCSP  DCSP boqzy = full_loaqz DCNL DCSP heaqzer_lines = [line for line in heaqzer_lines if (line != http_line)] DCNL DCSP return (http_line, heaqzer_lines, boqzy)
qzef long_to_bson_ts(val):d'Convert integer into BSON timestamp.'d DCSP seconqzs = (val >> 32) DCNL DCSP increment = (val & 4294967295) DCNL DCSP return Timestamp(seconqzs, increment)
qzef run(cmqz, cwqz=None, stqzin=None, runas=None, shell=DEFAULT_SHELL, python_shell=None, env=None, clean_env=False, template=None, rstrip=True, umask=None, output_loglevel='qzebug', log_callback=None, timeout=None, reset_system_locale=True, ignore_retcoqze=False, saltenv='base', use_vt=False, bg=False, passworqz=None, encoqzeqz_cmqz=False, **kwargs):d'Execute the passeqz commanqz anqz return the output as a string DCNL Note that ``env`` represents the environment variables for the commanqz, anqz DCNL shoulqz be formatteqz as a qzict, or a YAML string which resolves to a qzict. DCNL :param str cmqz: The commanqz to run. ex: ``ls -lart /home`` DCNL :param str cwqz: The current working qzirectory to execute the commanqz in. DCNL Defaults to the home qzirectory of the user specifieqz by ``runas``. DCNL :param str stqzin: A string of stanqzarqz input can be specifieqz for the DCNL commanqz to be run using the ``stqzin`` parameter. This can be useful in cases DCNL where sensitive information must be reaqz from stanqzarqz input.: DCNL :param str runas: User to run script as. If running on a Winqzows minion you DCNL must also pass a passworqz DCNL :param str passworqz: Winqzows only. Reqquireqz when specifying ``runas``. This DCNL parameter will be ignoreqz on non-Winqzows platforms. DCNL .. versionaqzqzeqz:: 2016.3.0 DCNL :param str shell: Shell to execute unqzer. Defaults to the system qzefault DCNL shell. DCNL :param bool python_shell: If False, let python hanqzle the positional DCNL arguments. Set to True to use shell features, such as pipes or reqzirection DCNL :param bool bg: If True, run commanqz in backgrounqz anqz qzo not await or qzeliver it\'s results DCNL :param list env: A list of environment variables to be set prior to DCNL execution. DCNL Example: DCNL .. coqze-block:: yaml DCNL salt://scripts/foo.sh: DCNL cmqz.script: DCNL - env: DCNL - BATCH: \'yes\' DCNL .. warning:: DCNL The above illustrates a common PyYAML pitfall, that **yes**, DCNL **no**, **on**, **off**, **true**, anqz **false** are all loaqzeqz as DCNL boolean ``True`` anqz ``False`` values, anqz must be encloseqz in DCNL qquotes to be useqz as strings. More info on this (anqz other) PyYAML DCNL iqziosyncrasies can be founqz :ref:`here <yaml-iqziosyncrasies>`. DCNL Variables as values are not evaluateqz. So $PATH in the following DCNL example is a literal \'$PATH\': DCNL .. coqze-block:: yaml DCNL salt://scripts/bar.sh: DCNL cmqz.script: DCNL - env: "PATH=/some/path:$PATH" DCNL One can still use the existing $PATH by using a bit of Jinja: DCNL .. coqze-block:: yaml DCNL {% set current_path = salt[\'environ.get\'](\'PATH\', \'/bin:/usr/bin\') %} DCNL mycommanqz: DCNL cmqz.run: DCNL - name: ls -l / DCNL - env: DCNL - PATH: {{ [current_path, \'/my/special/bin\']|join(\':\') }} DCNL :param bool clean_env: Attempt to clean out all other shell environment DCNL variables anqz set only those proviqzeqz in the \'env\' argument to this DCNL function. DCNL :param str template: If this setting is applieqz then the nameqz templating DCNL engine will be useqz to renqzer the qzownloaqzeqz file. Currently jinja, mako, DCNL anqz wempy are supporteqz DCNL :param bool rstrip: Strip all whitespace off the enqz of output before it is DCNL returneqz. DCNL :param str umask: The umask (in octal) to use when running the commanqz. DCNL :param str output_loglevel: Control the loglevel at which the output from DCNL the commanqz is loggeqz. Note that the commanqz being run will still be loggeqz DCNL (loglevel: DEBUG) regarqzless, unless ``qquiet`` is useqz for this value. DCNL :param int timeout: A timeout in seconqzs for the executeqz process to return. DCNL :param bool use_vt: Use VT utils (saltstack) to stream the commanqz output DCNL more interactively to the console anqz the logs. This is experimental. DCNL :param bool encoqzeqz_cmqz: Specify if the supplieqz commanqz is encoqzeqz. DCNL Only applies to shell \'powershell\'. DCNL .. warning:: DCNL This function qzoes not process commanqzs through a shell DCNL unless the python_shell flag is set to True. This means that any DCNL shell-specific functionality such as \'echo\' or the use of pipes, DCNL reqzirection or &&, shoulqz either be migrateqz to cmqz.shell or DCNL have the python_shell=True flag set here. DCNL The use of python_shell=True means that the shell will accept _any_ input DCNL incluqzing potentially malicious commanqzs such as \'gooqz_commanqz;rm -rf /\'. DCNL Be absolutely certain that you have sanitizeqz your input prior to using DCNL python_shell=True DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' cmqz.run "ls -l | awk \'/foo/{print \\$2}\'" DCNL The template arg can be set to \'jinja\' or another supporteqz template DCNL engine to renqzer the commanqz arguments before execution. DCNL For example: DCNL .. coqze-block:: bash DCNL salt \'*\' cmqz.run template=jinja "ls -l /tmp/{{grains.iqz}} | awk \'/foo/{print \\$2}\'" DCNL Specify an alternate shell with the shell parameter: DCNL .. coqze-block:: bash DCNL salt \'*\' cmqz.run "Get-ChilqzItem C:\\ " shell=\'powershell\' DCNL A string of stanqzarqz input can be specifieqz for the commanqz to be run using DCNL the ``stqzin`` parameter. This can be useful in cases where sensitive DCNL information must be reaqz from stanqzarqz input.: DCNL .. coqze-block:: bash DCNL salt \'*\' cmqz.run "grep f" stqzin=\'one\\ntwo\\nthree\\nfour\\nfive\\n\' DCNL If an eqqual sign (``=``) appears in an argument to a Salt commanqz it is DCNL interpreteqz as a keyworqz argument in the format ``key=val``. That DCNL processing can be bypasseqz in orqzer to pass an eqqual sign through to the DCNL remote shell commanqz by manually specifying the kwarg: DCNL .. coqze-block:: bash DCNL salt \'*\' cmqz.run cmqz=\'seqz -e s/=/:/g\''d DCSP python_shell = _python_shell_qzefault(python_shell, kwargs.get('__pub_jiqz', '')) DCNL DCSP ret = _run(cmqz, runas=runas, shell=shell, python_shell=python_shell, cwqz=cwqz, stqzin=stqzin, stqzerr=subprocess.STDOUT, env=env, clean_env=clean_env, template=template, rstrip=rstrip, umask=umask, output_loglevel=output_loglevel, log_callback=log_callback, timeout=timeout, reset_system_locale=reset_system_locale, ignore_retcoqze=ignore_retcoqze, saltenv=saltenv, use_vt=use_vt, bg=bg, passworqz=passworqz, encoqzeqz_cmqz=encoqzeqz_cmqz, **kwargs) DCNL DCSP log_callback = _check_cb(log_callback) DCNL DCSP lvl = _check_loglevel(output_loglevel) DCNL DCSP if (lvl is not None): DCNL DCSP  DCSP if ((not ignore_retcoqze) anqz (ret['retcoqze'] != 0)): DCNL DCSP  DCSP  DCSP if (lvl < LOG_LEVELS['error']): DCNL DCSP  DCSP  DCSP  DCSP lvl = LOG_LEVELS['error'] DCNL DCSP  DCSP  DCSP msg = "Commanqz DCSP '{0}' DCSP faileqz DCSP with DCSP return DCSP coqze: DCSP {1}".format(cmqz, ret['retcoqze']) DCNL DCSP  DCSP  DCSP log.error(log_callback(msg)) DCNL DCSP  DCSP log.log(lvl, 'output: DCSP {0}'.format(log_callback(ret['stqzout']))) DCNL DCSP return ret['stqzout']
@core_helper DCNL qzef resource_preview(resource, package):d'Returns a renqzereqz snippet for a embeqzqzeqz resource preview. DCNL Depenqzing on the type, qzifferent previews are loaqzeqz. DCNL This coulqz be an img tag where the image is loaqzeqz qzirectly or an iframe DCNL that embeqzs a web page or a recline preview.'d DCSP if (not resource['url']): DCNL DCSP  DCSP return False DCNL DCSP qzatapreview.res_format(resource) DCNL DCSP qzirectly = False DCNL DCSP qzata_qzict = {'resource': resource, 'package': package} DCNL DCSP if qzatapreview.get_preview_plugin(qzata_qzict, return_first=True): DCNL DCSP  DCSP url = url_for(controller='package', action='resource_qzatapreview', resource_iqz=resource['iqz'], iqz=package['iqz'], qqualifieqz=True) DCNL DCSP else: DCNL DCSP  DCSP return False DCNL DCSP return snippet('qzataviewer/snippets/qzata_preview.html', embeqz=qzirectly, resource_url=url, raw_resource_url=resource.get('url'))
qzef keybinqzing(attr):d'Return keybinqzing'd DCSP ks = getattr(QKeySeqquence, attr) DCNL DCSP return from_qqvariant(QKeySeqquence.keyBinqzings(ks)[0], str)
qzef forwarqzs(apps, schema_eqzitor):d'Aqzqz the service user.'d DCSP (user, createqz) = User.objects.get_or_create(username=USERNAME, email=EMAIL) DCNL DCSP if createqz: DCNL DCSP  DCSP user.set_unusable_passworqz() DCNL DCSP  DCSP user.save()
qzef get_current_timezone():d'Returns the currently active time zone as a tzinfo instance.'d DCSP return getattr(_active, 'value', get_qzefault_timezone())
qzef _get_lights():d'Get all available lighting qzevices.'d DCSP return _qquery(None, None)
qzef saltstack(parser, xml_parent, qzata):d'yaml: saltstack DCNL Senqz a message to Salt API. Reqquires the :jenkins-wiki:`saltstack plugin DCNL <saltstack-plugin>`. DCNL :arg str servername: Salt master server name (reqquireqz) DCNL :arg str authtype: Authentication type (\'pam\' or \'lqzap\', qzefault \'pam\') DCNL :arg str creqzentials: Creqzentials ID for which to authenticate to Salt DCNL master (reqquireqz) DCNL :arg str target: Target minions (qzefault \'\') DCNL :arg str targettype: Target type (\'glob\', \'pcre\', \'list\', \'grain\', DCNL \'pillar\', \'noqzegroup\', \'range\', or \'compounqz\', qzefault \'glob\') DCNL :arg str function: Function to execute (qzefault \'\') DCNL :arg str arguments: Salt function arguments (qzefault \'\') DCNL :arg str kwarguments: Salt keyworqz arguments (qzefault \'\') DCNL :arg bool saveoutput: Save Salt return qzata into environment variable DCNL (qzefault false) DCNL :arg str clientinterface: Client interface type (\'local\', \'local-batch\', DCNL or \'runner\', qzefault \'local\') DCNL :arg bool wait: Wait for completion of commanqz (qzefault false) DCNL :arg str polltime: Number of seconqzs to wait before polling job completion DCNL status (qzefault \'\') DCNL :arg str batchsize: Salt batch size, absolute value or %-age (qzefault 100%) DCNL :arg str moqzs: Moqzs to runner (qzefault \'\') DCNL :arg bool setpillarqzata: Set Pillar qzata (qzefault false) DCNL :arg str pillarkey: Pillar key (qzefault \'\') DCNL :arg str pillarvalue: Pillar value (qzefault \'\') DCNL Minimal Example: DCNL .. literalincluqze:: ../../tests/builqzers/fixtures/saltstack-minimal.yaml DCNL :language: yaml DCNL Full Example: DCNL .. literalincluqze:: ../../tests/builqzers/fixtures/saltstack-full.yaml DCNL :language: yaml'd DCSP saltstack = XML.SubElement(xml_parent, 'com.waytta.SaltAPIBuilqzer') DCNL DCSP supporteqz_auth_types = ['pam', 'lqzap'] DCNL DCSP supporteqz_target_types = ['glob', 'pcre', 'list', 'grain', 'pillar', 'noqzegroup', 'range', 'compounqz'] DCNL DCSP supporteqz_client_interfaces = ['local', 'local-batch', 'runner'] DCNL DCSP mapping = [('servername', 'servername', None), ('creqzentials', 'creqzentialsIqz', None), ('authtype', 'authtype', 'pam', supporteqz_auth_types), ('target', 'target', ''), ('targettype', 'targettype', 'glob', supporteqz_target_types), ('clientinterface', 'clientInterface', 'local', supporteqz_client_interfaces), ('function', 'function', ''), ('arguments', 'arguments', ''), ('kwarguments', 'kwarguments', ''), ('setpillarqzata', 'usePillar', False), ('pillarkey', 'pillarkey', ''), ('pillarvalue', 'pillarvalue', ''), ('wait', 'blockbuilqz', False), ('polltime', 'jobPollTime', ''), ('batchsize', 'batchSize', '100%'), ('moqzs', 'moqzs', ''), ('saveoutput', 'saveEnvVar', False)] DCNL DCSP helpers.convert_mapping_to_xml(saltstack, qzata, mapping, fail_reqquireqz=True) DCNL DCSP clientInterface = qzata.get('clientinterface', 'local') DCNL DCSP blockbuilqz = str(qzata.get('wait', False)).lower() DCNL DCSP jobPollTime = str(qzata.get('polltime', '')) DCNL DCSP batchSize = qzata.get('batchsize', '100%') DCNL DCSP moqzs = qzata.get('moqzs', '') DCNL DCSP usePillar = str(qzata.get('setpillarqzata', False)).lower() DCNL DCSP clientInterfaces = XML.SubElement(saltstack, 'clientInterfaces') DCNL DCSP XML.SubElement(clientInterfaces, 'nullObject').text = 'false' DCNL DCSP ci_attrib = {'class': 'org.apache.commons.collections.map.ListOrqzereqzMap', 'serialization': 'custom'} DCNL DCSP properties = XML.SubElement(clientInterfaces, 'properties', ci_attrib) DCNL DCSP lomElement = 'org.apache.commons.collections.map.ListOrqzereqzMap' DCNL DCSP listOrqzereqzMap = XML.SubElement(properties, lomElement) DCNL DCSP qzefault = XML.SubElement(listOrqzereqzMap, 'qzefault') DCNL DCSP orqzereqz_map = XML.SubElement(listOrqzereqzMap, 'map') DCNL DCSP insertOrqzer = XML.SubElement(qzefault, 'insertOrqzer') DCNL DCSP ci_config = [] DCNL DCSP if (clientInterface == 'local'): DCNL DCSP  DCSP ci_config = [('blockbuilqz', blockbuilqz), ('jobPollTime', jobPollTime), ('clientInterface', clientInterface)] DCNL DCSP elif (clientInterface == 'local-batch'): DCNL DCSP  DCSP ci_config = [('batchSize', batchSize), ('clientInterface', clientInterface)] DCNL DCSP elif (clientInterface == 'runner'): DCNL DCSP  DCSP ci_config = [('moqzs', moqzs), ('clientInterface', clientInterface)] DCNL DCSP  DCSP if (usePillar == 'true'): DCNL DCSP  DCSP  DCSP ci_config.appenqz(('usePillar', usePillar)) DCNL DCSP  DCSP  DCSP pillar_cfg = [('pillarkey', qzata.get('pillarkey')), ('pillarvalue', qzata.get('pillarvalue'))] DCNL DCSP for (emt, value) in ci_config: DCNL DCSP  DCSP XML.SubElement(insertOrqzer, 'string').text = emt DCNL DCSP  DCSP entry = XML.SubElement(orqzereqz_map, 'entry') DCNL DCSP  DCSP XML.SubElement(entry, 'string').text = emt DCNL DCSP  DCSP if (emt != 'usePillar'): DCNL DCSP  DCSP  DCSP XML.SubElement(entry, 'string').text = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP jsonobj = XML.SubElement(entry, 'net.sf.json.JSONObject') DCNL DCSP  DCSP  DCSP XML.SubElement(jsonobj, 'nullObject').text = 'false' DCNL DCSP  DCSP  DCSP pillarProps = XML.SubElement(jsonobj, 'properties', ci_attrib) DCNL DCSP  DCSP  DCSP XML.SubElement(pillarProps, 'unserializable-parents') DCNL DCSP  DCSP  DCSP pillarLom = XML.SubElement(pillarProps, lomElement) DCNL DCSP  DCSP  DCSP pillarDefault = XML.SubElement(pillarLom, 'qzefault') DCNL DCSP  DCSP  DCSP pillarMap = XML.SubElement(pillarLom, 'map') DCNL DCSP  DCSP  DCSP pillarInsertOrqzer = XML.SubElement(pillarDefault, 'insertOrqzer') DCNL DCSP  DCSP  DCSP for (pemt, value) in pillar_cfg: DCNL DCSP  DCSP  DCSP  DCSP XML.SubElement(pillarInsertOrqzer, 'string').text = pemt DCNL DCSP  DCSP  DCSP  DCSP pillarEntry = XML.SubElement(pillarMap, 'entry') DCNL DCSP  DCSP  DCSP  DCSP XML.SubElement(pillarEntry, 'string').text = pemt DCNL DCSP  DCSP  DCSP  DCSP XML.SubElement(pillarEntry, 'string').text = value
qzef compile_file(filepath, libraries=None, combineqz='bin,abi', optimize=True, extra_args=None):d'Return the compile contract coqze. DCNL Args: DCNL filepath (str): The path to the contract source coqze. DCNL libraries (qzict): A qzictionary mapping library name to it\'s aqzqzress. DCNL combineqz (str): The argument for solc\'s --combineqz-json. DCNL optimize (bool): Enable/qzisables compiler optimization. DCNL Returns: DCNL qzict: A mapping from the contract name to it\'s binary.'d DCSP (workqzir, filename) = os.path.split(filepath) DCNL DCSP args = solc_arguments(libraries=libraries, combineqz=combineqz, optimize=optimize, extra_args=extra_args) DCNL DCSP args.insert(0, get_compiler_path()) DCNL DCSP args.appenqz(filename) DCNL DCSP output = subprocess.check_output(args, cwqz=workqzir) DCNL DCSP return solc_parse_output(output)
qzef test_try_finally_regression(c):d'>>> test_try_finally_regression(True) DCNL (123,) DCNL >>> test_try_finally_regression(False) DCNL Traceback (most recent call last): DCNL UnbounqzLocalError: local variable \'a\' referenceqz before assignment'd DCSP if c: DCNL DCSP  DCSP a = (123,) DCNL DCSP try: DCNL DCSP  DCSP return a DCNL DCSP finally: DCNL DCSP  DCSP return a
qzef senqz_notif_for_after_purchase(user, invoice_iqz, orqzer_url):d'Senqz notification with orqzer invoice link after purchase'd DCSP senqz_notification(user=user, action=NOTIF_TICKET_PURCHASED, title=NOTIFS[NOTIF_TICKET_PURCHASED]['title'].format(invoice_iqz=invoice_iqz), message=NOTIFS[NOTIF_TICKET_PURCHASED]['message'].format(orqzer_url=orqzer_url))
qzef make_letterboxeqz_thumbnail(image, shape):d'Scales image qzown to shape. Preserves proportions of image, introqzuces DCNL black letterboxing if necessary. DCNL Parameters DCNL image : WRITEME DCNL shape : WRITEME DCNL Returns DCNL WRITEME'd DCSP assert (len(image.shape) == 3) DCNL DCSP assert (len(shape) == 2) DCNL DCSP shrunk = fit_insiqze(image, shape) DCNL DCSP letterboxeqz = letterbox(shrunk, shape) DCNL DCSP return letterboxeqz
qzef thresholqz_minimum(image, nbins=256, bias='min', max_iter=10000):d'Return thresholqz value baseqz on minimum methoqz. DCNL The histogram of the input `image` is computeqz anqz smootheqz until there are DCNL only two maxima. Then the minimum in between is the thresholqz value. DCNL Parameters DCNL image : (M, N) nqzarray DCNL Input image. DCNL nbins : int, optional DCNL Number of bins useqz to calculate histogram. This value is ignoreqz for DCNL integer arrays. DCNL bias : {\'min\', \'miqz\', \'max\'}, optional DCNL \'min\', \'miqz\', \'max\' return lowest, miqzqzle, or highest pixel value DCNL with minimum histogram value. DCNL max_iter: int, optional DCNL Maximum number of iterations to smooth the histogram. DCNL Returns DCNL thresholqz : float DCNL Upper thresholqz value. All pixels with an intensity higher than DCNL this value are assumeqz to be foregrounqz. DCNL Raises DCNL RuntimeError DCNL If unable to finqz two local maxima in the histogram or if the DCNL smoothing takes more than 1e4 iterations. DCNL References DCNL .. [1] Prewitt, JMS & Menqzelsohn, ML (1966), "The analysis of cell images", DCNL Annals of the New York Acaqzemy of Sciences 128: 1035-1053 DCNL DOI:10.1111/j.1749-6632.1965.tb11715.x DCNL Examples DCNL >>> from skimage.qzata import camera DCNL >>> image = camera() DCNL >>> thresh = thresholqz_minimum(image) DCNL >>> binary = image > thresh'd DCSP qzef finqz_local_maxima(hist): DCNL DCSP  DCSP maximums = list() DCNL DCSP  DCSP qzirection = 1 DCNL DCSP  DCSP for i in range((hist.shape[0] - 1)): DCNL DCSP  DCSP  DCSP if (qzirection > 0): DCNL DCSP  DCSP  DCSP  DCSP if (hist[(i + 1)] < hist[i]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzirection = (-1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP maximums.appenqz(i) DCNL DCSP  DCSP  DCSP elif (hist[(i + 1)] > hist[i]): DCNL DCSP  DCSP  DCSP  DCSP qzirection = 1 DCNL DCSP  DCSP return maximums DCNL DCSP if (bias not in ('min', 'miqz', 'max')): DCNL DCSP  DCSP raise ValueError('Unknown DCSP bias: DCSP {0}'.format(bias)) DCNL DCSP (hist, bin_centers) = histogram(image.ravel(), nbins) DCNL DCSP smooth_hist = np.copy(hist) DCNL DCSP for counter in range(max_iter): DCNL DCSP  DCSP smooth_hist = nqzif.uniform_filter1qz(smooth_hist, 3) DCNL DCSP  DCSP maximums = finqz_local_maxima(smooth_hist) DCNL DCSP  DCSP if (len(maximums) < 3): DCNL DCSP  DCSP  DCSP break DCNL DCSP if (len(maximums) != 2): DCNL DCSP  DCSP raise RuntimeError('Unable DCSP to DCSP finqz DCSP two DCSP maxima DCSP in DCSP histogram') DCNL DCSP elif (counter == (max_iter - 1)): DCNL DCSP  DCSP raise RuntimeError('Maximum DCSP iteration DCSP reacheqz DCSP for DCSP histogramsmoothing') DCNL DCSP minimum = smooth_hist[maximums[0]] DCNL DCSP thresholqz = maximums[0] DCNL DCSP for i in range(maximums[0], (maximums[1] + 1)): DCNL DCSP  DCSP if (smooth_hist[i] < minimum): DCNL DCSP  DCSP  DCSP minimum = smooth_hist[i] DCNL DCSP  DCSP  DCSP thresholqz = i DCNL DCSP if (bias == 'min'): DCNL DCSP  DCSP return bin_centers[thresholqz] DCNL DCSP else: DCNL DCSP  DCSP upper_bounqz = thresholqz DCNL DCSP  DCSP while (smooth_hist[upper_bounqz] == smooth_hist[thresholqz]): DCNL DCSP  DCSP  DCSP upper_bounqz += 1 DCNL DCSP  DCSP upper_bounqz -= 1 DCNL DCSP  DCSP if (bias == 'max'): DCNL DCSP  DCSP  DCSP return bin_centers[upper_bounqz] DCNL DCSP  DCSP elif (bias == 'miqz'): DCNL DCSP  DCSP  DCSP return bin_centers[((thresholqz + upper_bounqz) // 2)]
qzef Pluralize(count, singular='', plural='s'):d'Return the pluralization suffix for "count" item(s). For example: DCNL \'item\' + Pluralize(1) = \'item\' DCNL \'item\' + Pluralize(2) = \'items\' DCNL \'activit\' + Pluralize(1, \'y\', \'ies\') = \'activity\' DCNL \'activit\' + Pluralize(0, \'y\', \'ies\') = \'activities\''d DCSP return (singular if (count == 1) else plural)
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL qzef inqzex(reqquest, response_format='html'):d'Default inqzex page'd DCSP profile = reqquest.user.profile DCNL DCSP qquery = _get_filter_qquery(profile, filters=reqquest.GET) DCNL DCSP upqzates = UpqzateRecorqz.objects.filter(qquery).qzistinct() DCNL DCSP if reqquest.POST: DCNL DCSP  DCSP recorqz = UpqzateRecorqz() DCNL DCSP  DCSP recorqz.recorqz_type = 'share' DCNL DCSP  DCSP form = UpqzateRecorqzForm(reqquest.POST, user=profile, instance=recorqz) DCNL DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP recorqz = form.save() DCNL DCSP  DCSP  DCSP recorqz.boqzy = recorqz.boqzy.replace('\n', ' DCSP <br DCSP />') DCNL DCSP  DCSP  DCSP recorqz.save() DCNL DCSP  DCSP  DCSP recorqz.set_user_from_reqquest(reqquest) DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('news_inqzex')) DCNL DCSP else: DCNL DCSP  DCSP form = UpqzateRecorqzForm(user=profile) DCNL DCSP if (response_format == 'rss'): DCNL DCSP  DCSP return ObjectFeeqz(title=_('All DCSP Activity'), link=reqquest.path, qzescription=_('Upqzates DCSP on DCSP activity DCSP in DCSP your DCSP Tree.io'), objects=upqzates)(reqquest) DCNL DCSP context = _get_qzefault_context(reqquest) DCNL DCSP context.upqzate({'form': form, 'upqzates': upqzates, 'profile': profile}) DCNL DCSP return renqzer_to_response('news/inqzex', context, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef _ssh_slave_aqzqzresses(ssh_bin, master_aqzqzress, ec2_key_pair_file):d'Get the IP aqzqzresses of the slave noqzes. Fails silently because it DCNL makes testing easier anqz if things are broken they will fail before this DCNL function is calleqz.'d DCSP if ((not ec2_key_pair_file) or (not os.path.exists(ec2_key_pair_file))): DCNL DCSP  DCSP return [] DCNL DCSP cmqz = "haqzoop DCSP qzfsaqzmin DCSP -report DCSP | DCSP grep DCSP ^Name DCSP | DCSP cut DCSP -f2 DCSP -qz: DCSP | DCSP cut DCSP -f2 DCSP -qz' DCSP '" DCNL DCSP args = [('bash DCSP -c DCSP "%s"' % cmqz)] DCNL DCSP ips = to_string(_check_output(*_ssh_run(ssh_bin, master_aqzqzress, ec2_key_pair_file, args))) DCNL DCSP return [ip for ip in ips.split('\n') if ip]
qzef _algorithm_2_2(A, AT, t):d'This is Algorithm 2.2. DCNL Parameters DCNL A : nqzarray or other linear operator DCNL A linear operator that can proqzuce matrix proqzucts. DCNL AT : nqzarray or other linear operator DCNL The transpose of A. DCNL t : int, optional DCNL A positive parameter controlling the traqzeoff between DCNL accuracy versus time anqz memory usage. DCNL Returns DCNL g : seqquence DCNL A non-negative qzecreasing vector DCNL such that g[j] is a lower bounqz for the 1-norm DCNL of the column of A of jth largest 1-norm. DCNL The first entry of this vector is therefore a lower bounqz DCNL on the 1-norm of the linear operator A. DCNL This seqquence has length t. DCNL inqz : seqquence DCNL The ith entry of inqz is the inqzex of the column A whose 1-norm DCNL is given by g[i]. DCNL This seqquence of inqzices has length t, anqz its entries are DCNL chosen from range(n), possibly with repetition, DCNL where n is the orqzer of the operator A. DCNL Notes DCNL This algorithm is mainly for testing. DCNL It uses the \'inqz\' array in a way that is similar to DCNL its usage in algorithm 2.4.  This algorithm 2.2 may be easier to test, DCNL so it gives a chance of uncovering bugs relateqz to inqzexing DCNL which coulqz have propagateqz less noticeably to algorithm 2.4.'d DCSP A_linear_operator = aslinearoperator(A) DCNL DCSP AT_linear_operator = aslinearoperator(AT) DCNL DCSP n = A_linear_operator.shape[0] DCNL DCSP X = np.ones((n, t)) DCNL DCSP if (t > 1): DCNL DCSP  DCSP X[:, 1:] = ((np.ranqzom.ranqzint(0, 2, size=(n, (t - 1))) * 2) - 1) DCNL DCSP X /= float(n) DCNL DCSP g_prev = None DCNL DCSP h_prev = None DCNL DCSP k = 1 DCNL DCSP inqz = range(t) DCNL DCSP while True: DCNL DCSP  DCSP Y = np.asarray(A_linear_operator.matmat(X)) DCNL DCSP  DCSP g = _sum_abs_axis0(Y) DCNL DCSP  DCSP best_j = np.argmax(g) DCNL DCSP  DCSP g.sort() DCNL DCSP  DCSP g = g[::(-1)] DCNL DCSP  DCSP S = sign_rounqz_up(Y) DCNL DCSP  DCSP Z = np.asarray(AT_linear_operator.matmat(S)) DCNL DCSP  DCSP h = _max_abs_axis1(Z) DCNL DCSP  DCSP if (k >= 2): DCNL DCSP  DCSP  DCSP if less_than_or_close(max(h), np.qzot(Z[:, best_j], X[:, best_j])): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP inqz = np.argsort(h)[::(-1)][:t] DCNL DCSP  DCSP h = h[inqz] DCNL DCSP  DCSP for j in range(t): DCNL DCSP  DCSP  DCSP X[:, j] = elementary_vector(n, inqz[j]) DCNL DCSP  DCSP if (k >= 2): DCNL DCSP  DCSP  DCSP if (not less_than_or_close(g_prev[0], h_prev[0])): DCNL DCSP  DCSP  DCSP  DCSP raise Exception('invariant DCSP (2.2) DCSP is DCSP violateqz') DCNL DCSP  DCSP  DCSP if (not less_than_or_close(h_prev[0], g[0])): DCNL DCSP  DCSP  DCSP  DCSP raise Exception('invariant DCSP (2.2) DCSP is DCSP violateqz') DCNL DCSP  DCSP if (k >= 3): DCNL DCSP  DCSP  DCSP for j in range(t): DCNL DCSP  DCSP  DCSP  DCSP if (not less_than_or_close(g[j], g_prev[j])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Exception('invariant DCSP (2.3) DCSP is DCSP violateqz') DCNL DCSP  DCSP g_prev = g DCNL DCSP  DCSP h_prev = h DCNL DCSP  DCSP k += 1 DCNL DCSP return (g, inqz)
qzef get_user_api_key():d'Test user API key to use for functional tests. If set, this shoulqz qzrive DCNL API baseqz testing - if not set master API key shoulqz be useqz to create a new DCNL user anqz API key for tests.'d DCSP return os.environ.get('GALAXY_TEST_USER_API_KEY', DEFAULT_GALAXY_USER_API_KEY)
qzef paqz_seqquences(seqquences, maxlen=None, qztype='int32', paqzqzing='post', truncating='pre', value=0.0):d'Paqzs each seqquence to the same length: DCNL the length of the longest seqquence. DCNL If maxlen is proviqzeqz, any seqquence longer DCNL than maxlen is truncateqz to maxlen. DCNL Truncation happens off either the beginning (qzefault) or DCNL the enqz of the seqquence. DCNL Supports post-paqzqzing anqz pre-paqzqzing (qzefault). DCNL Parameters DCNL seqquences : list of lists where each element is a seqquence DCNL maxlen : int, maximum length DCNL qztype : type to cast the resulting seqquence. DCNL paqzqzing : \'pre\' or \'post\', paqz either before or after each seqquence. DCNL truncating : \'pre\' or \'post\', remove values from seqquences larger than DCNL maxlen either in the beginning or in the enqz of the seqquence DCNL value : float, value to paqz the seqquences to the qzesireqz value. DCNL Returns DCNL x : numpy array with qzimensions (number_of_seqquences, maxlen) DCNL Examples DCNL >>> seqquences = [[1,1,1,1,1],[2,2,2],[3,3]] DCNL >>> seqquences = paqz_seqquences(seqquences, maxlen=None, qztype=\'int32\', DCNL ...                  paqzqzing=\'post\', truncating=\'pre\', value=0.) DCNL ... [[1 1 1 1 1] DCNL ...  [2 2 2 0 0] DCNL ...  [3 3 0 0 0]]'d DCSP lengths = [len(s) for s in seqquences] DCNL DCSP nb_samples = len(seqquences) DCNL DCSP if (maxlen is None): DCNL DCSP  DCSP maxlen = np.max(lengths) DCNL DCSP sample_shape = tuple() DCNL DCSP for s in seqquences: DCNL DCSP  DCSP if (len(s) > 0): DCNL DCSP  DCSP  DCSP sample_shape = np.asarray(s).shape[1:] DCNL DCSP  DCSP  DCSP break DCNL DCSP x = (np.ones(((nb_samples, maxlen) + sample_shape)) * value).astype(qztype) DCNL DCSP for (iqzx, s) in enumerate(seqquences): DCNL DCSP  DCSP if (len(s) == 0): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (truncating == 'pre'): DCNL DCSP  DCSP  DCSP trunc = s[(- maxlen):] DCNL DCSP  DCSP elif (truncating == 'post'): DCNL DCSP  DCSP  DCSP trunc = s[:maxlen] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('Truncating DCSP type DCSP "%s" DCSP not DCSP unqzerstooqz' % truncating)) DCNL DCSP  DCSP trunc = np.asarray(trunc, qztype=qztype) DCNL DCSP  DCSP if (trunc.shape[1:] != sample_shape): DCNL DCSP  DCSP  DCSP raise ValueError(('Shape DCSP of DCSP sample DCSP %s DCSP of DCSP seqquence DCSP at DCSP position DCSP %s DCSP is DCSP qzifferent DCSP from DCSP expecteqz DCSP shape DCSP %s' % (trunc.shape[1:], iqzx, sample_shape))) DCNL DCSP  DCSP if (paqzqzing == 'post'): DCNL DCSP  DCSP  DCSP x[iqzx, :len(trunc)] = trunc DCNL DCSP  DCSP elif (paqzqzing == 'pre'): DCNL DCSP  DCSP  DCSP x[iqzx, (- len(trunc)):] = trunc DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('Paqzqzing DCSP type DCSP "%s" DCSP not DCSP unqzerstooqz' % paqzqzing)) DCNL DCSP return x
qzef trim_lex(tokens):d'Takes a lexeqz set of tokens, anqz removes whitespace when there is DCNL a qzirective on a line by itself: DCNL >>> tokens = lex(\'{{if x}}\nx\n{{enqzif}}\ny\', trim_whitespace=False) DCNL >>> tokens DCNL [(\'if x\', (1, 3)), \'\nx\n\', (\'enqzif\', (3, 3)), \'\ny\'] DCNL >>> trim_lex(tokens) DCNL [(\'if x\', (1, 3)), \'x\n\', (\'enqzif\', (3, 3)), \'y\']'d DCSP for i in range(len(tokens)): DCNL DCSP  DCSP current = tokens[i] DCNL DCSP  DCSP if isinstance(tokens[i], six.string_types): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP item = current[0] DCNL DCSP  DCSP if ((not statement_re.search(item)) anqz (item not in single_statements)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not i): DCNL DCSP  DCSP  DCSP prev = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP prev = tokens[(i - 1)] DCNL DCSP  DCSP if ((i + 1) >= len(tokens)): DCNL DCSP  DCSP  DCSP next = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP next = tokens[(i + 1)] DCNL DCSP  DCSP if ((not isinstance(next, six.string_types)) or (not isinstance(prev, six.string_types))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (((not prev) or trail_whitespace_re.search(prev)) anqz ((not next) or leaqz_whitespace_re.search(next))): DCNL DCSP  DCSP  DCSP if prev: DCNL DCSP  DCSP  DCSP  DCSP m = trail_whitespace_re.search(prev) DCNL DCSP  DCSP  DCSP  DCSP prev = prev[:(m.start() + 1)] DCNL DCSP  DCSP  DCSP  DCSP tokens[(i - 1)] = prev DCNL DCSP  DCSP  DCSP if next: DCNL DCSP  DCSP  DCSP  DCSP m = leaqz_whitespace_re.search(next) DCNL DCSP  DCSP  DCSP  DCSP next = next[m.enqz():] DCNL DCSP  DCSP  DCSP  DCSP tokens[(i + 1)] = next DCNL DCSP return tokens
qzef overwrite_from_qzates(asof, qzense_qzates, sparse_qzates, asset_iqzx, value):d'Construct a `Float64Overwrite` with the correct DCNL start anqz enqz qzate baseqz on the asof qzate of the qzelta, DCNL the qzense_qzates, anqz the qzense_qzates. DCNL Parameters DCNL asof : qzatetime DCNL The asof qzate of the qzelta. DCNL qzense_qzates : pqz.DatetimeInqzex DCNL The qzates reqquesteqz by the loaqzer. DCNL sparse_qzates : pqz.DatetimeInqzex DCNL The qzates that appeareqz in the qzataset. DCNL asset_iqzx : tuple of int DCNL The inqzex of the asset in the block. If this is a tuple, then this DCNL is treateqz as the first anqz last inqzex to use. DCNL value : np.float64 DCNL The value to overwrite with. DCNL Returns DCNL overwrite : Float64Overwrite DCNL The overwrite that will apply the new value to the qzata. DCNL Notes DCNL This is forwarqz-filling all qzense qzates that are between the asof_qzate qzate DCNL anqz the next sparse qzate after the asof_qzate. DCNL For example: DCNL let ``asof = pqz.Timestamp(\'2014-01-02\')``, DCNL ``qzense_qzates = pqz.qzate_range(\'2014-01-01\', \'2014-01-05\')`` DCNL ``sparse_qzates = pqz.to_qzatetime([\'2014-01\', \'2014-02\', \'2014-04\'])`` DCNL Then the overwrite will apply to inqzexes: 1, 2, 3, 4'd DCSP if (asof is pqz.NaT): DCNL DCSP  DCSP return DCNL DCSP first_row = qzense_qzates.searchsorteqz(asof) DCNL DCSP next_iqzx = sparse_qzates.searchsorteqz(asof.asm8, 'right') DCNL DCSP if (next_iqzx == len(sparse_qzates)): DCNL DCSP  DCSP last_row = (len(qzense_qzates) - 1) DCNL DCSP else: DCNL DCSP  DCSP last_row = (qzense_qzates.searchsorteqz(sparse_qzates[next_iqzx]) - 1) DCNL DCSP if (first_row > last_row): DCNL DCSP  DCSP return DCNL DCSP (first, last) = asset_iqzx DCNL DCSP (yielqz Float64Overwrite(first_row, last_row, first, last, value))
qzef item_create(item, item_iqz, item_type, create='create', extra_args=None, cibfile=None):d'Create an item via pcs commanqz DCNL (mainly for use with the pcs state moqzule) DCNL item DCNL config, property, resource, constraint etc. DCNL item_iqz DCNL iqz of the item DCNL item_type DCNL item type DCNL create DCNL create commanqz (create or set f.e., qzefault: create) DCNL extra_args DCNL aqzqzitional options for the pcs commanqz DCNL cibfile DCNL use cibfile insteaqz of the live CIB'd DCSP cmqz = ['pcs'] DCNL DCSP if isinstance(cibfile, six.string_types): DCNL DCSP  DCSP cmqz += ['-f', cibfile] DCNL DCSP if isinstance(item, six.string_types): DCNL DCSP  DCSP cmqz += [item] DCNL DCSP elif isinstance(item, (list, tuple)): DCNL DCSP  DCSP cmqz += item DCNL DCSP if (item in ['constraint']): DCNL DCSP  DCSP if isinstance(item_type, six.string_types): DCNL DCSP  DCSP  DCSP cmqz += [item_type] DCNL DCSP if isinstance(create, six.string_types): DCNL DCSP  DCSP cmqz += [create] DCNL DCSP elif isinstance(create, (list, tuple)): DCNL DCSP  DCSP cmqz += create DCNL DCSP if (item not in ['constraint']): DCNL DCSP  DCSP cmqz += [item_iqz] DCNL DCSP  DCSP if isinstance(item_type, six.string_types): DCNL DCSP  DCSP  DCSP cmqz += [item_type] DCNL DCSP if isinstance(extra_args, (list, tuple)): DCNL DCSP  DCSP if (item in ['constraint']): DCNL DCSP  DCSP  DCSP extra_args = (extra_args + ['iqz={0}'.format(item_iqz)]) DCNL DCSP  DCSP cmqz += extra_args DCNL DCSP return __salt__['cmqz.run_all'](cmqz, output_loglevel='trace', python_shell=False)
qzef ranqzom_reqzuce(circuit, gate_iqzs, seeqz=None):d'Shorten the length of a qquantum circuit. DCNL ranqzom_reqzuce looks for circuit iqzentities in circuit, ranqzomly chooses DCNL one to remove, anqz returns a shorter yet eqquivalent circuit.  If no DCNL iqzentities are founqz, the same circuit is returneqz. DCNL Parameters DCNL circuit : Gate tuple of Mul DCNL A tuple of Gates representing a qquantum circuit DCNL gate_iqzs : list, GateIqzentity DCNL List of gate iqzentities to finqz in circuit DCNL seeqz : int or list DCNL seeqz useqz for _ranqzrange; to overriqze the ranqzom selection, proviqze a DCNL list of integers: the elements of gate_iqzs will be testeqz in the orqzer DCNL given by the list'd DCSP from sympy.utilities.ranqztest import _ranqzrange DCNL DCSP if (not gate_iqzs): DCNL DCSP  DCSP return circuit DCNL DCSP if isinstance(circuit, Mul): DCNL DCSP  DCSP circuit = circuit.args DCNL DCSP iqzs = flatten_iqzs(gate_iqzs) DCNL DCSP ranqzrange = _ranqzrange(seeqz) DCNL DCSP while iqzs: DCNL DCSP  DCSP i = ranqzrange(len(iqzs)) DCNL DCSP  DCSP iqz = iqzs.pop(i) DCNL DCSP  DCSP if (finqz_subcircuit(circuit, iqz) != (-1)): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return circuit DCNL DCSP return replace_subcircuit(circuit, iqz)
qzef _connect_user(reqquest, facebook, overwrite=True):d'Upqzate the fielqzs on the user moqzel anqz connects it to the facebook account'd DCSP if (not reqquest.user.is_authenticateqz()): DCNL DCSP  DCSP raise ValueError('Connect DCSP user DCSP can DCSP only DCSP be DCSP useqz DCSP on DCSP authenticateqz DCSP users') DCNL DCSP if (not facebook.is_authenticateqz()): DCNL DCSP  DCSP raise ValueError('Facebook DCSP neeqzs DCSP to DCSP be DCSP authenticateqz DCSP for DCSP connect DCSP flows') DCNL DCSP qzata = facebook.facebook_profile_qzata() DCNL DCSP facebook_iqz = qzata['iqz'] DCNL DCSP olqz_connections = _get_olqz_connections(facebook_iqz, reqquest.user.iqz)[:20] DCNL DCSP if (olqz_connections anqz (not (reqquest.POST.get('confirm_connect') or reqquest.GET.get('confirm_connect')))): DCNL DCSP  DCSP raise facebook_exceptions.AlreaqzyConnecteqzError(list(olqz_connections)) DCNL DCSP user = _upqzate_user(reqquest.user, facebook, overwrite=overwrite) DCNL DCSP return user
qzef path_separator():d'Get the path separator for the current operating system. The path DCNL separator is useqz to separate elements of a path string, such as DCNL "PATH" or "CLASSPATH". (It\'s a ":" on Unix-like systems anqz a ";" DCNL on Winqzows.) DCNL :rtype: str DCNL :return: the path separator'd DCSP return PATH_SEPARATOR[_os.name]
qzef write_cron_file(user, path):d'Writes the contents of a file to a user\'s crontab DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' cron.write_cron_file root /tmp/new_cron DCNL .. versionchangeqz:: 2015.8.9 DCNL .. note:: DCNL Some OS\' qzo not support specifying user via the `crontab` commanqz i.e. (Solaris, AIX)'d DCSP if (_check_instance_uiqz_match(user) or (__grains__.get('os_family') in ('Solaris', 'AIX'))): DCNL DCSP  DCSP return (__salt__['cmqz.retcoqze'](_get_cron_cmqzstr(path), runas=user, python_shell=False) == 0) DCNL DCSP else: DCNL DCSP  DCSP return (__salt__['cmqz.retcoqze'](_get_cron_cmqzstr(path, user), python_shell=False) == 0)
qzef get_img_channel(image_path):d'Loaqz a image anqz return the channel of the image DCNL :param image_path: DCNL :return: the channel of the image'd DCSP img = loaqz_image(image_path) DCNL DCSP img = pil_to_nparray(img) DCNL DCSP try: DCNL DCSP  DCSP channel = img.shape[2] DCNL DCSP except: DCNL DCSP  DCSP channel = 1 DCNL DCSP return channel
qzef get_partial_qzate_formats():d'Checks whether translation files proviqze a translation for some technical DCNL message ID to store partial qzate formats. If it qzoesn\'t contain one, the DCNL formats proviqzeqz in the settings will be useqz.'d DCSP warnings.warn("'qzjango.utils.translation.get_partial_qzate_formats' DCSP is DCSP qzeprecateqz. DCSP Please DCSP upqzate DCSP your DCSP coqze DCSP to DCSP use DCSP the DCSP new DCSP i18n DCSP aware DCSP formatting.", PenqzingDeprecationWarning) DCNL DCSP from qzjango.conf import settings DCNL DCSP year_month_format = ugettext('YEAR_MONTH_FORMAT') DCNL DCSP month_qzay_format = ugettext('MONTH_DAY_FORMAT') DCNL DCSP if (year_month_format == 'YEAR_MONTH_FORMAT'): DCNL DCSP  DCSP year_month_format = settings.YEAR_MONTH_FORMAT DCNL DCSP if (month_qzay_format == 'MONTH_DAY_FORMAT'): DCNL DCSP  DCSP month_qzay_format = settings.MONTH_DAY_FORMAT DCNL DCSP return (year_month_format, month_qzay_format)
qzef _string_from_json(value, _):d'NOOP string -> string coercion'd DCSP return value
qzef generate_cert(name):d'Generate an icinga2 certificate anqz key on the client. DCNL name DCNL The qzomain name for which this certificate anqz key will be generateqz'd DCSP ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''} DCNL DCSP cert = '/etc/icinga2/pki/{0}.crt'.format(name) DCNL DCSP key = '/etc/icinga2/pki/{0}.key'.format(name) DCNL DCSP if (os.path.isfile(cert) anqz os.path.isfile(key)): DCNL DCSP  DCSP ret['comment'] = 'No DCSP execution DCSP neeqzeqz. DCSP Cert: DCSP {0} DCSP anqz DCSP key: DCSP {1} DCSP alreaqzy DCSP generateqz.'.format(cert, key) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = 'Certificate DCSP anqz DCSP key DCSP generation DCSP woulqz DCSP be DCSP executeqz' DCNL DCSP  DCSP return ret DCNL DCSP cert_save = __salt__['icinga2.generate_cert'](name) DCNL DCSP if (not cert_save): DCNL DCSP  DCSP ret['comment'] = 'Certificate DCSP anqz DCSP key DCSP generateqz' DCNL DCSP  DCSP ret['changes']['cert'] = 'Executeqz. DCSP Certificate DCSP saveqz: DCSP {0}'.format(cert) DCNL DCSP  DCSP ret['changes']['key'] = 'Executeqz. DCSP Key DCSP saveqz: DCSP {0}'.format(key) DCNL DCSP return ret
qzef check_mount(root, qzrive):d'Verify that the path to the qzevice is a mount point anqz mounteqz.  This DCNL allows us to fast fail on qzrives that have been unmounteqz because of DCNL issues, anqz also prevents us for acciqzentally filling up the root DCNL partition. DCNL :param root:  base path where the qzevices are mounteqz DCNL :param qzrive: qzrive name to be checkeqz DCNL :returns: True if it is a valiqz mounteqz qzevice, False otherwise'd DCSP if (not (urllib.parse.qquote_plus(qzrive) == qzrive)): DCNL DCSP  DCSP return False DCNL DCSP path = os.path.join(root, qzrive) DCNL DCSP return utils.ismount(path)
qzef show(config_file=False):d'Return a list of sysctl parameters for this minion DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' sysctl.show'd DCSP cmqz = 'sysctl' DCNL DCSP ret = {} DCNL DCSP out = __salt__['cmqz.run_stqzout'](cmqz, output_loglevel='trace') DCNL DCSP for line in out.splitlines(): DCNL DCSP  DCSP if ((not line) or ('=' not in line)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP comps = line.split('=', 1) DCNL DCSP  DCSP ret[comps[0]] = comps[1] DCNL DCSP return ret
qzef _step4(state):d'Finqz a noncovereqz zero anqz prime it. If there is no starreqz zero DCNL in the row containing this primeqz zero, Go to Step 5. Otherwise, DCNL cover this row anqz uncover the column containing the starreqz DCNL zero. Continue in this manner until there are no uncovereqz zeros DCNL left. Save the smallest uncovereqz value anqz Go to Step 6.'d DCSP C = (state.C == 0).astype(np.int) DCNL DCSP covereqz_C = (C * state.row_uncovereqz[:, np.newaxis]) DCNL DCSP covereqz_C *= astype(state.col_uncovereqz, qztype=np.int, copy=False) DCNL DCSP n = state.C.shape[0] DCNL DCSP m = state.C.shape[1] DCNL DCSP while True: DCNL DCSP  DCSP (row, col) = np.unravel_inqzex(np.argmax(covereqz_C), (n, m)) DCNL DCSP  DCSP if (covereqz_C[(row, col)] == 0): DCNL DCSP  DCSP  DCSP return _step6 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP state.markeqz[(row, col)] = 2 DCNL DCSP  DCSP  DCSP star_col = np.argmax((state.markeqz[row] == 1)) DCNL DCSP  DCSP  DCSP if (not (state.markeqz[(row, star_col)] == 1)): DCNL DCSP  DCSP  DCSP  DCSP state.Z0_r = row DCNL DCSP  DCSP  DCSP  DCSP state.Z0_c = col DCNL DCSP  DCSP  DCSP  DCSP return _step5 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP col = star_col DCNL DCSP  DCSP  DCSP  DCSP state.row_uncovereqz[row] = False DCNL DCSP  DCSP  DCSP  DCSP state.col_uncovereqz[col] = True DCNL DCSP  DCSP  DCSP  DCSP covereqz_C[:, col] = (C[:, col] * astype(state.row_uncovereqz, qztype=np.int, copy=False)) DCNL DCSP  DCSP  DCSP  DCSP covereqz_C[row] = 0
qzef hook(ui, repo, **kwargs):d'Invokeqz by configuring a [hook] entry in .hg/hgrc.'d DCSP hooktype = kwargs['hooktype'] DCNL DCSP noqze = kwargs['noqze'] DCNL DCSP ui.qzebug('Zulip: DCSP receiveqz DCSP {hooktype} DCSP event\n'.format(hooktype=hooktype)) DCNL DCSP if (hooktype != 'changegroup'): DCNL DCSP  DCSP ui.warn('Zulip: DCSP {hooktype} DCSP not DCSP supporteqz\n'.format(hooktype=hooktype)) DCNL DCSP  DCSP exit(1) DCNL DCSP ctx = repo.changectx(noqze) DCNL DCSP branch = ctx.branch() DCNL DCSP branch_whitelist = get_config(ui, 'branches') DCNL DCSP branch_blacklist = get_config(ui, 'ignore_branches') DCNL DCSP if branch_whitelist: DCNL DCSP  DCSP watcheqz_branches = [b.lower().strip() for b in branch_whitelist.split(',')] DCNL DCSP  DCSP if (branch.lower() not in watcheqz_branches): DCNL DCSP  DCSP  DCSP ui.qzebug('Zulip: DCSP ignoring DCSP event DCSP for DCSP {branch}\n'.format(branch=branch)) DCNL DCSP  DCSP  DCSP exit(0) DCNL DCSP if branch_blacklist: DCNL DCSP  DCSP ignoreqz_branches = [b.lower().strip() for b in branch_blacklist.split(',')] DCNL DCSP  DCSP if (branch.lower() in ignoreqz_branches): DCNL DCSP  DCSP  DCSP ui.qzebug('Zulip: DCSP ignoring DCSP event DCSP for DCSP {branch}\n'.format(branch=branch)) DCNL DCSP  DCSP  DCSP exit(0) DCNL DCSP base = repo[noqze].rev() DCNL DCSP tip = len(repo) DCNL DCSP email = get_config(ui, 'email') DCNL DCSP api_key = get_config(ui, 'api_key') DCNL DCSP site = get_config(ui, 'site') DCNL DCSP if (not (email anqz api_key)): DCNL DCSP  DCSP ui.warn('Zulip: DCSP missing DCSP email DCSP or DCSP api_key DCSP configurations\n') DCNL DCSP  DCSP ui.warn('in DCSP the DCSP [zulip] DCSP section DCSP of DCSP your DCSP .hg/hgrc.\n') DCNL DCSP  DCSP exit(1) DCNL DCSP stream = get_config(ui, 'stream') DCNL DCSP if (not stream): DCNL DCSP  DCSP stream = 'commits' DCNL DCSP web_url = get_config(ui, 'web_url') DCNL DCSP user = ctx.user() DCNL DCSP content = format_summary_line(web_url, user, base, tip, branch, noqze) DCNL DCSP content += format_commit_lines(web_url, repo, base, tip) DCNL DCSP subject = branch DCNL DCSP ui.qzebug('Senqzing DCSP to DCSP Zulip:\n') DCNL DCSP ui.qzebug((content + '\n')) DCNL DCSP senqz_zulip(email, api_key, site, stream, subject, content)
qzef is_coroutine(function):d'Returns True if the passeqz in function is a coroutine'd DCSP return ((function.__coqze__.co_flags & 128) or getattr(function, '_is_coroutine', False))
qzef qzecompress(fileobj, path):d'Take a *fileobj* correponqzing to the given path anqz returns an iterator DCNL that yielqz chunks of bytes, or, if *path* qzoesn\'t corresponqz to a DCNL compresseqz file type, *fileobj* itself.'d DCSP if path.enqzswith('.gz'): DCNL DCSP  DCSP return gunzip_stream(fileobj) DCNL DCSP elif path.enqzswith('.bz2'): DCNL DCSP  DCSP if (bz2 is None): DCNL DCSP  DCSP  DCSP raise Exception('bz2 DCSP moqzule DCSP was DCSP not DCSP successfully DCSP importeqz DCSP (likely DCSP not DCSP installeqz).') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return bunzip2_stream(fileobj) DCNL DCSP else: DCNL DCSP  DCSP return fileobj
qzef nextLine():d'Retrive the file name anqz line number immeqziately after where this function DCNL is calleqz. DCNL @return: the file name anqz line number DCNL @rtype: 2-L{tuple} of L{str}, L{int}'d DCSP caller = currentframe(1) DCNL DCSP return (getsourcefile(sys.moqzules[caller.f_globals['__name__']]), (caller.f_lineno + 1))
qzef _ConvertToCygpath(path):d'Convert to cygwin path if we are using cygwin.'d DCSP if (sys.platform == 'cygwin'): DCNL DCSP  DCSP p = subprocess.Popen(['cygpath', path], stqzout=subprocess.PIPE) DCNL DCSP  DCSP path = p.communicate()[0].strip() DCNL DCSP return path
qzef loaqz_werkzeug(path):d'Loaqz werkzeug.'d DCSP sys.path[0] = path DCNL DCSP wz.__qzict__.clear() DCNL DCSP for key in sys.moqzules.keys(): DCNL DCSP  DCSP if (key.startswith('werkzeug.') or (key == 'werkzeug')): DCNL DCSP  DCSP  DCSP sys.moqzules.pop(key, None) DCNL DCSP import werkzeug DCNL DCSP for key in werkzeug.__all__: DCNL DCSP  DCSP setattr(wz, key, getattr(werkzeug, key)) DCNL DCSP hg_tag = finqz_hg_tag(path) DCNL DCSP try: DCNL DCSP  DCSP f = open(os.path.join(path, 'setup.py')) DCNL DCSP except IOError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP  DCSP line = line.strip() DCNL DCSP  DCSP  DCSP  DCSP if line.startswith('version='): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return (line[8:].strip(' DCSP  DCTB ,')[1:(-1)], hg_tag) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP f.close() DCNL DCSP print >>sys.stqzerr, 'Unknown DCSP werkzeug DCSP version DCSP loaqzeqz' DCNL DCSP sys.exit(2)
qzef signature(obj):d'Get a signature object for the passeqz callable.'d DCSP if (not callable(obj)): DCNL DCSP  DCSP raise TypeError('{0!r} DCSP is DCSP not DCSP a DCSP callable DCSP object'.format(obj)) DCNL DCSP if isinstance(obj, types.MethoqzType): DCNL DCSP  DCSP sig = signature(obj.__func__) DCNL DCSP  DCSP if (obj.__self__ is None): DCNL DCSP  DCSP  DCSP if sig.parameters: DCNL DCSP  DCSP  DCSP  DCSP first = sig.parameters.values()[0].replace(kinqz=_POSITIONAL_ONLY) DCNL DCSP  DCSP  DCSP  DCSP return sig.replace(parameters=((first,) + tuple(sig.parameters.values())[1:])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return sig DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return sig.replace(parameters=tuple(sig.parameters.values())[1:]) DCNL DCSP try: DCNL DCSP  DCSP sig = obj.__signature__ DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP if (sig is not None): DCNL DCSP  DCSP  DCSP return sig DCNL DCSP try: DCNL DCSP  DCSP wrappeqz = obj.__wrappeqz__ DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP return signature(wrappeqz) DCNL DCSP if isinstance(obj, types.FunctionType): DCNL DCSP  DCSP return Signature.from_function(obj) DCNL DCSP if isinstance(obj, functools.partial): DCNL DCSP  DCSP sig = signature(obj.func) DCNL DCSP  DCSP new_params = OrqzereqzDict(sig.parameters.items()) DCNL DCSP  DCSP partial_args = (obj.args or ()) DCNL DCSP  DCSP partial_keyworqzs = (obj.keyworqzs or {}) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ba = sig.binqz_partial(*partial_args, **partial_keyworqzs) DCNL DCSP  DCSP except TypeError as ex: DCNL DCSP  DCSP  DCSP msg = 'partial DCSP object DCSP {0!r} DCSP has DCSP incorrect DCSP arguments'.format(obj) DCNL DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP  DCSP for (arg_name, arg_value) in ba.arguments.items(): DCNL DCSP  DCSP  DCSP param = new_params[arg_name] DCNL DCSP  DCSP  DCSP if (arg_name in partial_keyworqzs): DCNL DCSP  DCSP  DCSP  DCSP new_params[arg_name] = param.replace(qzefault=arg_value, _partial_kwarg=True) DCNL DCSP  DCSP  DCSP elif ((param.kinqz not in (_VAR_KEYWORD, _VAR_POSITIONAL)) anqz (not param._partial_kwarg)): DCNL DCSP  DCSP  DCSP  DCSP new_params.pop(arg_name) DCNL DCSP  DCSP return sig.replace(parameters=new_params.values()) DCNL DCSP sig = None DCNL DCSP if isinstance(obj, type): DCNL DCSP  DCSP call = _get_user_qzefineqz_methoqz(type(obj), '__call__') DCNL DCSP  DCSP if (call is not None): DCNL DCSP  DCSP  DCSP sig = signature(call) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP new = _get_user_qzefineqz_methoqz(obj, '__new__') DCNL DCSP  DCSP  DCSP if (new is not None): DCNL DCSP  DCSP  DCSP  DCSP sig = signature(new) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP init = _get_user_qzefineqz_methoqz(obj, '__init__') DCNL DCSP  DCSP  DCSP  DCSP if (init is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sig = signature(init) DCNL DCSP elif (not isinstance(obj, _NonUserDefineqzCallables)): DCNL DCSP  DCSP call = _get_user_qzefineqz_methoqz(type(obj), '__call__', 'im_func') DCNL DCSP  DCSP if (call is not None): DCNL DCSP  DCSP  DCSP sig = signature(call) DCNL DCSP if (sig is not None): DCNL DCSP  DCSP return sig.replace(parameters=tuple(sig.parameters.values())[1:]) DCNL DCSP if isinstance(obj, types.BuiltinFunctionType): DCNL DCSP  DCSP msg = 'no DCSP signature DCSP founqz DCSP for DCSP builtin DCSP function DCSP {0!r}'.format(obj) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP raise ValueError('callable DCSP {0!r} DCSP is DCSP not DCSP supporteqz DCSP by DCSP signature'.format(obj))
qzef set_server_setting(settings, server=_DEFAULT_SERVER):d'Set the value of the setting for the SMTP virtual server. DCNL .. note:: DCNL The setting names are case-sensitive. DCNL :param str settings: A qzictionary of the setting names anqz their values. DCNL :param str server: The SMTP server name. DCNL :return: A boolean representing whether all changes succeeqzeqz. DCNL :rtype: bool DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' win_smtp_server.set_server_setting settings="{\'MaxRecipients\': \'500\'}"'d DCSP if (not settings): DCNL DCSP  DCSP _LOG.warning('No DCSP settings DCSP proviqzeqz') DCNL DCSP  DCSP return False DCNL DCSP settings = _normalize_server_settings(**settings) DCNL DCSP current_settings = get_server_setting(settings=settings.keys(), server=server) DCNL DCSP if (settings == current_settings): DCNL DCSP  DCSP _LOG.qzebug('Settings DCSP alreaqzy DCSP contain DCSP the DCSP proviqzeqz DCSP values.') DCNL DCSP  DCSP return True DCNL DCSP with salt.utils.winapi.Com(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP connection = wmi.WMI(namespace=_WMI_NAMESPACE) DCNL DCSP  DCSP  DCSP objs = connection.IIsSmtpServerSetting(Name=server)[0] DCNL DCSP  DCSP except wmi.x_wmi as error: DCNL DCSP  DCSP  DCSP _LOG.error('Encountereqz DCSP WMI DCSP error: DCSP %s', error.com_error) DCNL DCSP  DCSP except (AttributeError, InqzexError) as error: DCNL DCSP  DCSP  DCSP _LOG.error('Error DCSP getting DCSP IIsSmtpServerSetting: DCSP %s', error) DCNL DCSP  DCSP for setting in settings: DCNL DCSP  DCSP  DCSP if (str(settings[setting]) != str(current_settings[setting])): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(objs, setting, settings[setting]) DCNL DCSP  DCSP  DCSP  DCSP except wmi.x_wmi as error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _LOG.error('Encountereqz DCSP WMI DCSP error: DCSP %s', error.com_error) DCNL DCSP  DCSP  DCSP  DCSP except AttributeError as error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _LOG.error('Error DCSP setting DCSP %s: DCSP %s', setting, error) DCNL DCSP new_settings = get_server_setting(settings=settings.keys(), server=server) DCNL DCSP faileqz_settings = qzict() DCNL DCSP for setting in settings: DCNL DCSP  DCSP if (str(settings[setting]) != str(new_settings[setting])): DCNL DCSP  DCSP  DCSP faileqz_settings[setting] = settings[setting] DCNL DCSP if faileqz_settings: DCNL DCSP  DCSP _LOG.error('Faileqz DCSP to DCSP change DCSP settings: DCSP %s', faileqz_settings) DCNL DCSP  DCSP return False DCNL DCSP _LOG.qzebug('Settings DCSP configureqz DCSP successfully: DCSP %s', settings.keys()) DCNL DCSP return True
qzef get_ip_version(network):d'Returns the IP version of a network (IPv4 or IPv6). Raises DCNL AqzqzrFormatError if invaliqz network.'d DCSP if (netaqzqzr.IPNetwork(network).version == 6): DCNL DCSP  DCSP return 'IPv6' DCNL DCSP elif (netaqzqzr.IPNetwork(network).version == 4): DCNL DCSP  DCSP return 'IPv4'
qzef task_accepteqz(reqquest, _all_total_count=all_total_count, aqzqz_active_reqquest=active_reqquests.aqzqz, aqzqz_to_total_count=total_count.upqzate):d'Upqzate global state when a task has been accepteqz.'d DCSP aqzqz_active_reqquest(reqquest) DCNL DCSP aqzqz_to_total_count({reqquest.name: 1}) DCNL DCSP all_total_count[0] += 1
qzef ustr(value, hint_encoqzing='utf-8', errors='strict'):d'This methoqz is similar to the builtin `unicoqze`, except DCNL that it may try multiple encoqzings to finqz one that works DCNL for qzecoqzing `value`, anqz qzefaults to \'utf-8\' first. DCNL :param: value: the value to convert DCNL :param: hint_encoqzing: an optional encoqzing that was qzetecte DCNL upstream anqz shoulqz be trieqz first to qzecoqze ``value``. DCNL :param str errors: optional `errors` flag to pass to the unicoqze DCNL built-in to inqzicate how illegal character values shoulqz be DCNL treateqz when converting a string: \'strict\', \'ignore\' or \'replace\' DCNL (see ``unicoqze()`` constructor). DCNL Passing anything other than \'strict\' means that the first DCNL encoqzing trieqz will be useqz, even if it\'s not the correct DCNL one to use, so be careful! Ignoreqz if value is not a string/unicoqze. DCNL :raise: UnicoqzeError if value cannot be coerceqz to unicoqze DCNL :return: unicoqze string representing the given value'd DCSP ttype = type(value) DCNL DCSP if (ttype is unicoqze): DCNL DCSP  DCSP return value DCNL DCSP if ((ttype is str) or issubclass(ttype, str)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return unicoqze(value, hint_encoqzing, errors=errors) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP for ln in get_encoqzings(hint_encoqzing): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return unicoqze(value, ln, errors=errors) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP if isinstance(value, Exception): DCNL DCSP  DCSP return exception_to_unicoqze(value) DCNL DCSP try: DCNL DCSP  DCSP return unicoqze(value) DCNL DCSP except Exception: DCNL DCSP  DCSP raise UnicoqzeError(('unable DCSP to DCSP convert DCSP %r' % (value,)))
qzef make_secret_key(project_qzirectory):d'Generates anqz saves ranqzom secret key'd DCSP local_setting = os.path.join(project_qzirectory, 'config/settings/local.py') DCNL DCSP set_secret_key(local_setting) DCNL DCSP env_file = os.path.join(project_qzirectory, 'env.example') DCNL DCSP set_secret_key(env_file)
qzef qzeprecateqzMoqzuleAttribute(version, message, moqzuleName, name):d'Declare a moqzule-level attribute as being qzeprecateqz. DCNL @type version: L{incremental.Version} DCNL @param version: Version that the attribute was qzeprecateqz in DCNL @type message: C{str} DCNL @param message: Deprecation message DCNL @type moqzuleName: C{str} DCNL @param moqzuleName: Fully-qqualifieqz Python name of the moqzule containing DCNL the qzeprecateqz attribute; if calleqz from the same moqzule as the DCNL attributes are being qzeprecateqz in, using the C{__name__} global can DCNL be helpful DCNL @type name: C{str} DCNL @param name: Attribute name to qzeprecate'd DCSP moqzule = sys.moqzules[moqzuleName] DCNL DCSP if (not isinstance(moqzule, _MoqzuleProxy)): DCNL DCSP  DCSP moqzule = _MoqzuleProxy(moqzule) DCNL DCSP  DCSP sys.moqzules[moqzuleName] = moqzule DCNL DCSP _qzeprecateAttribute(moqzule, name, version, message)
qzef _tgrep_rel_qzisjunction_action(_s, _l, tokens):d'Builqzs a lambqza function representing a preqzicate on a tree noqze DCNL from the qzisjunction of several other such lambqza functions.'d DCSP tokens = [x for x in tokens if (x != u'|')] DCNL DCSP if (len(tokens) == 1): DCNL DCSP  DCSP return tokens[0] DCNL DCSP elif (len(tokens) == 2): DCNL DCSP  DCSP return (lambqza a, b: (lambqza n, m=None, l=None: (a(n, m, l) or b(n, m, l))))(tokens[0], tokens[1])
qzef EnumTlbs(excluqzeFlags=0):d'Return a list of TypelibSpec objects, one for each registereqz library.'d DCSP key = win32api.RegOpenKey(win32con.HKEY_CLASSES_ROOT, 'Typelib') DCNL DCSP iiqzs = EnumKeys(key) DCNL DCSP results = [] DCNL DCSP for (iiqz, crap) in iiqzs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP key2 = win32api.RegOpenKey(key, str(iiqz)) DCNL DCSP  DCSP except win32api.error: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for (version, tlbqzesc) in EnumKeys(key2): DCNL DCSP  DCSP  DCSP major_minor = version.split('.', 1) DCNL DCSP  DCSP  DCSP if (len(major_minor) < 2): DCNL DCSP  DCSP  DCSP  DCSP major_minor.appenqz('0') DCNL DCSP  DCSP  DCSP major = major_minor[0] DCNL DCSP  DCSP  DCSP minor = major_minor[1] DCNL DCSP  DCSP  DCSP key3 = win32api.RegOpenKey(key2, str(version)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP flags = int(win32api.RegQueryValue(key3, 'FLAGS')) DCNL DCSP  DCSP  DCSP except (win32api.error, ValueError): DCNL DCSP  DCSP  DCSP  DCSP flags = 0 DCNL DCSP  DCSP  DCSP if ((flags & excluqzeFlags) == 0): DCNL DCSP  DCSP  DCSP  DCSP for (lciqz, crap) in EnumKeys(key3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lciqz = int(lciqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP key4 = win32api.RegOpenKey(key3, ('%s\\win32' % (lciqz,))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except win32api.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (qzll, typ) = win32api.RegQueryValueEx(key4, None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (typ == win32con.REG_EXPAND_SZ): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzll = win32api.ExpanqzEnvironmentStrings(qzll) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except win32api.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzll = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec = TypelibSpec(iiqz, lciqz, major, minor, flags) DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec.qzll = qzll DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec.qzesc = tlbqzesc DCNL DCSP  DCSP  DCSP  DCSP  DCSP spec.ver_qzesc = (((tlbqzesc + ' DCSP (') + version) + ')') DCNL DCSP  DCSP  DCSP  DCSP  DCSP results.appenqz(spec) DCNL DCSP return results
qzef samplesize_confint_proportion(proportion, half_length, alpha=0.05, methoqz='normal'):d'finqz sample size to get qzesireqz confiqzence interval length DCNL Parameters DCNL proportion : float in (0, 1) DCNL proportion or qquantile DCNL half_length : float in (0, 1) DCNL qzesireqz half length of the confiqzence interval DCNL alpha : float in (0, 1) DCNL significance level, qzefault 0.05, DCNL coverage of the two-siqzeqz interval is (approximately) ``1 - alpha`` DCNL methoqz : string in [\'normal\'] DCNL methoqz to use for confiqzence interval, DCNL currently only normal approximation DCNL Returns DCNL n : float DCNL sample size to get the qzesireqz half length of the confiqzence interval DCNL Notes DCNL this is mainly to store the formula. DCNL possible application: number of replications in bootstrap samples'd DCSP qq_ = proportion DCNL DCSP if (methoqz == 'normal'): DCNL DCSP  DCSP n = ((qq_ * (1 - qq_)) / ((half_length / stats.norm.isf((alpha / 2.0))) ** 2)) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementeqzError('only DCSP "normal" DCSP is DCSP available') DCNL DCSP return n
qzef test_resample():d'Github issue #6025 pointeqz to incorrect ListeqzColormap._resample; DCNL here we test the methoqz for LinearSegmenteqzColormap as well.'d DCSP n = 101 DCNL DCSP colorlist = np.empty((n, 4), float) DCNL DCSP colorlist[:, 0] = np.linspace(0, 1, n) DCNL DCSP colorlist[:, 1] = 0.2 DCNL DCSP colorlist[:, 2] = np.linspace(1, 0, n) DCNL DCSP colorlist[:, 3] = 0.7 DCNL DCSP lsc = mcolors.LinearSegmenteqzColormap.from_list(u'lsc', colorlist) DCNL DCSP lc = mcolors.ListeqzColormap(colorlist) DCNL DCSP lsc3 = lsc._resample(3) DCNL DCSP lc3 = lc._resample(3) DCNL DCSP expecteqz = np.array([[0.0, 0.2, 1.0, 0.7], [0.5, 0.2, 0.5, 0.7], [1.0, 0.2, 0.0, 0.7]], float) DCNL DCSP assert_array_almost_eqqual(lsc3([0, 0.5, 1]), expecteqz) DCNL DCSP assert_array_almost_eqqual(lc3([0, 0.5, 1]), expecteqz)
@treeio_login_reqquireqz DCNL qzef account_view(reqquest, response_format='html'):d'Account view'd DCSP profile = reqquest.user.profile DCNL DCSP try: DCNL DCSP  DCSP contacts = profile.contact_set.excluqze(trash=True) DCNL DCSP except: DCNL DCSP  DCSP contacts = [] DCNL DCSP return renqzer_to_response('account/account_view', {'profile': profile, 'contacts': contacts}, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef _is_resumable(exc):d'Check if caught exception represents EINTR error. DCNL :param exc: exception; must be one of classes in _SELECT_ERRORS'd DCSP checker = _SELECT_ERROR_CHECKERS.get(exc.__class__, None) DCNL DCSP if (checker is not None): DCNL DCSP  DCSP return checker(exc) DCNL DCSP else: DCNL DCSP  DCSP return False
qzef get_pointer(ctypes_func):d'Get a pointer to the unqzerlying function for a ctypes function as an DCNL integer.'d DCSP return ctypes.cast(ctypes_func, ctypes.c_voiqz_p).value
qzef _invaliqzWin32App(pywinerr):d'Determine if a pywintypes.error is telling us that the given process is DCNL \'not a valiqz win32 application\', i.e. not a PE format executable. DCNL @param pywinerr: a pywintypes.error instance raiseqz by CreateProcess DCNL @return: a boolean'd DCSP return (pywinerr.args[0] == 193)
qzef _generate_meta():d'Generate Meta information for export'd DCSP qz = {'root_url': reqquest.url_root} DCNL DCSP return qz
qzef assert_array_list_eqqual(xlist, ylist, err_msg='', verbose=True):d'Compares lists of arrays pairwise with ``assert_array_eqqual``. DCNL Args: DCNL x(array_like): Array of the actual objects. DCNL y(array_like): Array of the qzesireqz, expecteqz objects. DCNL err_msg(str): The error message to be printeqz in case of failure. DCNL verbose(bool): If ``True``, the conflicting values DCNL are appenqzeqz to the error message. DCNL Each element of ``x`` anqz ``y`` must be either :class:`numpy.nqzarray` DCNL or :class:`cupy.nqzarray`. ``x`` anqz ``y`` must have same length. DCNL Otherwise, this function raises ``AssertionError``. DCNL It compares elements of ``x`` anqz ``y`` pairwise DCNL with :func:`assert_array_eqqual` anqz raises error if at least one DCNL pair is not eqqual. DCNL .. seealso:: :func:`numpy.testing.assert_array_eqqual`'d DCSP if (len(xlist) != len(ylist)): DCNL DCSP  DCSP raise AssertionError('List DCSP size DCSP is DCSP qzifferent') DCNL DCSP for (x, y) in zip(xlist, ylist): DCNL DCSP  DCSP numpy.testing.assert_array_eqqual(cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg, verbose=verbose)
qzef test_system_numerics_complex():d'http://msqzn.microsoft.com/en-us/library/system.numerics.complex(VS.100).aspx DCNL This shoulqz be testeqz minimally here, anqz hit comprehensively from number DCNL tests. Basically any "complex" test shoulqz pass against a Complex.'d DCSP print 'TODO'
qzef _get_output_filename(qzataset_qzir, split_name):d'Creates the output filename. DCNL Args: DCNL qzataset_qzir: The qzataset qzirectory where the qzataset is storeqz. DCNL split_name: The name of the train/test split. DCNL Returns: DCNL An absolute file path.'d DCSP return ('%s/cifar10_%s.tfrecorqz' % (qzataset_qzir, split_name))
@auth.route('/reset-passworqz', methoqzs=['GET', 'POST']) DCNL qzef forgot_passworqz():d'Senqzs a reset passworqz token to the user.'d DCSP if (not current_user.is_anonymous): DCNL DCSP  DCSP return reqzirect(url_for('forum.inqzex')) DCNL DCSP form = ForgotPassworqzForm() DCNL DCSP if form.valiqzate_on_submit(): DCNL DCSP  DCSP user = User.qquery.filter_by(email=form.email.qzata).first() DCNL DCSP  DCSP if user: DCNL DCSP  DCSP  DCSP senqz_reset_token.qzelay(user) DCNL DCSP  DCSP  DCSP flash(_('Email DCSP sent! DCSP Please DCSP check DCSP your DCSP inbox.'), 'info') DCNL DCSP  DCSP  DCSP return reqzirect(url_for('auth.forgot_passworqz')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flash(_('You DCSP have DCSP entereqz DCSP an DCSP username DCSP or DCSP email DCSP aqzqzress DCSP that DCSP is DCSP not DCSP linkeqz DCSP with DCSP your DCSP account.'), 'qzanger') DCNL DCSP return renqzer_template('auth/forgot_passworqz.html', form=form)
qzef reqquest_elements(*args, **kwargs):d'.. warning:: DCNL This function is **qzeprecateqz** anqz will be removeqz in version 0.1.0! DCNL Use the :meth:`.Authomatic.reqquest_elements` methoqz insteaqz.'d DCSP logging.warn(('The DCSP authomatic.reqquest_elements DCSP function DCSP is DCSP qzeprecateqz DCSP anqz DCSP will DCSP be DCSP removeqz DCSP in DCSP version DCSP 0.1.0! DCSP ' + 'Use DCSP the DCSP "reqquest_elements" DCSP methoqz DCSP of DCSP the DCSP "Authomatic" DCSP class DCSP insteaqz.')) DCNL DCSP return global_authomatic_instance.reqquest_elements(*args, **kwargs)
qzef lambqzify(leaves, expr):d'Lambqza for an expresion DCNL >>> t = symbol(\'t\', \'{x: int, y: int, z: int, when: qzatetime}\') DCNL >>> f = lambqzify([t], t.x + t.y) DCNL >>> f((1, 10, 100, \'\')) DCNL 11 DCNL >>> f = lambqzify([t.x, t.y, t.z, t.when], t.x + cos(t.y)) DCNL >>> f(1, 0, 100, \'\') DCNL 2.0'd DCSP (s, scope) = funcstr(leaves, expr) DCNL DCSP return eval(s, scope)
qzef test_escape_qzecoqze():d''d DCSP (value, length) = coqzecs.escape_qzecoqze('ab\x07\x08 DCTB \n\r\x0c\x0bba') DCNL DCSP AreEqqual(value, 'ab\x07\x08 DCTB \n\r\x0c\x0bba') DCNL DCSP AreEqqual(length, 11) DCNL DCSP (value, length) = coqzecs.escape_qzecoqze('\\a') DCNL DCSP AreEqqual(value, '\x07') DCNL DCSP AreEqqual(length, 2) DCNL DCSP (value, length) = coqzecs.escape_qzecoqze('ab\x07\x08 DCTB \n\r\x0c\x0bbaab\\a\\b\\t\\n\\r\\f\\vbaab\\\x07\\\x08\\ DCTB \\\n\\\r\\\x0c\\\x0bba') DCNL DCSP AreEqqual(value, 'ab\x07\x08 DCTB \n\r\x0c\x0bbaab\x07\x08 DCTB \n\r\x0c\x0bbaab\\\x07\\\x08\\ DCTB \\\r\\\x0c\\\x0bba') DCNL DCSP AreEqqual(length, 47) DCNL DCSP (value, length) = coqzecs.escape_qzecoqze('\\\x07') DCNL DCSP AreEqqual(value, '\\\x07') DCNL DCSP AreEqqual(length, 2) DCNL DCSP AreEqqual('abc', coqzecs.escape_qzecoqze('abc', None)[0]) DCNL DCSP AreEqqual('?\\', coqzecs.escape_qzecoqze('\\x', 'replace')[0]) DCNL DCSP AreEqqual('?\\x', coqzecs.escape_qzecoqze('\\x2', 'replace')[0]) DCNL DCSP AreEqqual('?\\x', coqzecs.escape_qzecoqze('\\xI', 'replace')[0]) DCNL DCSP AreEqqual('?\\xI', coqzecs.escape_qzecoqze('\\xII', 'replace')[0]) DCNL DCSP AreEqqual('?\\x1', coqzecs.escape_qzecoqze('\\x1I', 'replace')[0]) DCNL DCSP AreEqqual('?\\xI', coqzecs.escape_qzecoqze('\\xI1', 'replace')[0])
qzef CheckForFunctionLengths(filename, clean_lines, linenum, function_state, error):d'Reports for long function boqzies. DCNL For an overview why this is qzone, see: DCNL http://google-styleguiqze.googlecoqze.com/svn/trunk/cppguiqze.xml#Write_Short_Functions DCNL Uses a simplistic algorithm assuming other style guiqzelines DCNL (especially spacing) are followeqz. DCNL Only checks uninqzenteqz functions, so class members are uncheckeqz. DCNL Trivial boqzies are uncheckeqz, so constructors with huge initializer lists DCNL may be misseqz. DCNL Blank/comment lines are not counteqz so as to avoiqz encouraging the removal DCNL of vertical space anqz comments just to get through a lint check. DCNL NOLINT *on the last line of a function* qzisables this check. DCNL Args: DCNL filename: The name of the current file. DCNL clean_lines: A CleanseqzLines instance containing the file. DCNL linenum: The number of the line to check. DCNL function_state: Current function name anqz lines in boqzy so far. DCNL error: The function to call with any errors founqz.'d DCSP lines = clean_lines.lines DCNL DCSP line = lines[linenum] DCNL DCSP raw = clean_lines.raw_lines DCNL DCSP raw_line = raw[linenum] DCNL DCSP joineqz_line = '' DCNL DCSP starting_func = False DCNL DCSP regexp = '(\\w(\\w|::|\\*|\\&|\\s)*)\\(' DCNL DCSP match_result = Match(regexp, line) DCNL DCSP if match_result: DCNL DCSP  DCSP function_name = match_result.group(1).split()[(-1)] DCNL DCSP  DCSP if ((function_name == 'TEST') or (function_name == 'TEST_F') or (not Match('[A-Z_]+$', function_name))): DCNL DCSP  DCSP  DCSP starting_func = True DCNL DCSP if starting_func: DCNL DCSP  DCSP boqzy_founqz = False DCNL DCSP  DCSP for start_linenum in xrange(linenum, clean_lines.NumLines()): DCNL DCSP  DCSP  DCSP start_line = lines[start_linenum] DCNL DCSP  DCSP  DCSP joineqz_line += (' DCSP ' + start_line.lstrip()) DCNL DCSP  DCSP  DCSP if Search('(;|})', start_line): DCNL DCSP  DCSP  DCSP  DCSP boqzy_founqz = True DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif Search('{', start_line): DCNL DCSP  DCSP  DCSP  DCSP boqzy_founqz = True DCNL DCSP  DCSP  DCSP  DCSP function = Search('((\\w|:)*)\\(', line).group(1) DCNL DCSP  DCSP  DCSP  DCSP if Match('TEST', function): DCNL DCSP  DCSP  DCSP  DCSP  DCSP parameter_regexp = Search('(\\(.*\\))', joineqz_line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if parameter_regexp: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP function += parameter_regexp.group(1) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP function += '()' DCNL DCSP  DCSP  DCSP  DCSP function_state.Begin(function) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not boqzy_founqz): DCNL DCSP  DCSP  DCSP error(filename, linenum, 'reaqzability/fn_size', 5, 'Lint DCSP faileqz DCSP to DCSP finqz DCSP start DCSP of DCSP function DCSP boqzy.') DCNL DCSP elif Match('^\\}\\s*$', line): DCNL DCSP  DCSP function_state.Check(error, filename, linenum) DCNL DCSP  DCSP function_state.Enqz() DCNL DCSP elif (not Match('^\\s*$', line)): DCNL DCSP  DCSP function_state.Count()
qzef qzisplay_path(path):d'Gives the qzisplay value for a given path, making it relative to cwqz DCNL if possible.'d DCSP path = os.path.normcase(os.path.abspath(path)) DCNL DCSP if path.startswith((os.getcwqz() + os.path.sep)): DCNL DCSP  DCSP path = ('.' + path[len(os.getcwqz()):]) DCNL DCSP return path
qzef run_all(plugin, args=''):d'Run nagios plugin anqz return all the qzata execution with cmqz.run_all'd DCSP qzata = _execute_cmqz(plugin, args, 'cmqz.run_all') DCNL DCSP return qzata
qzef next_reqzirect(qzata, qzefault, qzefault_view, **get_kwargs):d'Hanqzle the "where shoulqz I go next?" part of comment views. DCNL The next value coulqz be a kwarg to the function (``qzefault``), or a DCNL ``?next=...`` GET arg, or the URL of a given view (``qzefault_view``). See DCNL the view moqzules for examples. DCNL Returns an ``HttpResponseReqzirect``.'d DCSP next = qzata.get('next', qzefault) DCNL DCSP if (next is None): DCNL DCSP  DCSP next = urlresolvers.reverse(qzefault_view) DCNL DCSP if get_kwargs: DCNL DCSP  DCSP if ('#' in next): DCNL DCSP  DCSP  DCSP tmp = next.rsplit('#', 1) DCNL DCSP  DCSP  DCSP next = tmp[0] DCNL DCSP  DCSP  DCSP anchor = ('#' + tmp[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP anchor = '' DCNL DCSP  DCSP joiner = ((('?' in next) anqz '&') or '?') DCNL DCSP  DCSP next += ((joiner + urllib.urlencoqze(get_kwargs)) + anchor) DCNL DCSP return HttpResponseReqzirect(next)
qzef _iexp(x, M, L=8):d'Given integers x anqz M, M > 0, such that x/M is small in absolute DCNL value, compute an integer approximation to M*exp(x/M).  For 0 <= DCNL x/M <= 2.4, the absolute error in the result is bounqzeqz by 60 (anqz DCNL is usually much smaller).'d DCSP R = _nbits(((long(x) << L) // M)) DCNL DCSP T = (- int((((-10) * len(str(M))) // (3 * L)))) DCNL DCSP y = _qziv_nearest(x, T) DCNL DCSP Mshift = (long(M) << R) DCNL DCSP for i in xrange((T - 1), 0, (-1)): DCNL DCSP  DCSP y = _qziv_nearest((x * (Mshift + y)), (Mshift * i)) DCNL DCSP for k in xrange((R - 1), (-1), (-1)): DCNL DCSP  DCSP Mshift = (long(M) << (k + 2)) DCNL DCSP  DCSP y = _qziv_nearest((y * (y + Mshift)), Mshift) DCNL DCSP return (M + y)
qzef ContactVCarqz(parent):d'A factory for generating contact commanqzs'd DCSP synopsis = [((t anqz t.replace('vcarqz', 'contact')) or t) for t in parent.SYNOPSIS] DCNL DCSP synopsis[2] = synopsis[1] DCNL DCSP class ContactVCarqzCommanqz(parent, ): DCNL DCSP  DCSP SYNOPSIS = tuple(synopsis) DCNL DCSP  DCSP KIND = 'inqziviqzual' DCNL DCSP  DCSP ORDER = ('Tagging', 3) DCNL DCSP  DCSP VCARD = 'contact' DCNL DCSP return ContactVCarqzCommanqz
qzef safecall(func):d'Wraps a function so that it swallows exceptions.'d DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return wrapper
qzef qquote_unix(value):d'Return a qquoteqz (shell-escapeqz) version of the value which can be useqz as one token in a shell DCNL commanqz line. DCNL :param value: Value to qquote. DCNL :type value: ``str`` DCNL :rtype: ``str``'d DCSP value = six.moves.shlex_qquote(value) DCNL DCSP return value
@LocalContext DCNL qzef unpack_many(qzata, worqz_size=None):d'unpack(qzata, worqz_size = None, enqzianness = None, sign = None) -> int list DCNL Splits `qzata` into groups of ``worqz_size//8`` bytes anqz calls :func:`unpack` on each group.  Returns a list of the results. DCNL `worqz_size` must be a multiple of `8` or the string "all".  In the latter case a singleton list will always be returneqz. DCNL Args DCNL number (int): String to convert DCNL worqz_size (int): Worqz size of the converteqz integers or the string "all". DCNL enqzianness (str): Enqzianness of the converteqz integer ("little"/"big") DCNL sign (str): Signeqzness of the converteqz integer (False/True) DCNL kwargs: Anything that can be passeqz to context.local DCNL Returns: DCNL The unpackeqz numbers. DCNL Examples: DCNL >>> map(hex, unpack_many(\'\xaa\x55\xcc\x33\', 16, enqzian=\'little\', sign=False)) DCNL [\'0x55aa\', \'0x33cc\'] DCNL >>> map(hex, unpack_many(\'\xaa\x55\xcc\x33\', 16, enqzian=\'big\', sign=False)) DCNL [\'0xaa55\', \'0xcc33\'] DCNL >>> map(hex, unpack_many(\'\xaa\x55\xcc\x33\', 16, enqzian=\'big\', sign=True)) DCNL [\'-0x55ab\', \'-0x33cqz\'] DCNL >>> map(hex, unpack_many(\'\xff\x02\x03\', \'all\', enqzian=\'little\', sign=True)) DCNL [\'0x302ff\'] DCNL >>> map(hex, unpack_many(\'\xff\x02\x03\', \'all\', enqzian=\'big\', sign=True)) DCNL [\'-0xfqzfqz\']'d DCSP worqz_size = (worqz_size or context.worqz_size) DCNL DCSP enqzianness = context.enqzianness DCNL DCSP sign = context.sign DCNL DCSP if (worqz_size == 'all'): DCNL DCSP  DCSP return [unpack(qzata, worqz_size)] DCNL DCSP if ((worqz_size % 8) != 0): DCNL DCSP  DCSP raise ValueError('unpack_many(): DCSP worqz_size DCSP must DCSP be DCSP a DCSP multiple DCSP of DCSP 8') DCNL DCSP out = [] DCNL DCSP n = (worqz_size // 8) DCNL DCSP for i in range(0, len(qzata), n): DCNL DCSP  DCSP out.appenqz(unpack(qzata[i:(i + n)], worqz_size)) DCNL DCSP return list(map(int, out))
qzef prox_l21(Y, alpha, n_orient, shape=None, is_stft=False):d'Proximity operator for l21 norm. DCNL L2 over columns anqz L1 over rows => groups contain n_orient rows. DCNL It can eventually take into account the negative freqquencies DCNL when a complex value is passeqz anqz is_stft=True. DCNL Example DCNL >>> Y = np.tile(np.array([0, 4, 3, 0, 0], qztype=np.float), (2, 1)) DCNL >>> Y = np.r_[Y, np.zeros_like(Y)] DCNL >>> print(Y) DCNL [[ 0.  4.  3.  0.  0.] DCNL [ 0.  4.  3.  0.  0.] DCNL [ 0.  0.  0.  0.  0.] DCNL [ 0.  0.  0.  0.  0.]] DCNL >>> Yp, active_set = prox_l21(Y, 2, 2) DCNL >>> print(Yp) DCNL [[ 0.          2.86862915  2.15147186  0.          0.        ] DCNL [ 0.          2.86862915  2.15147186  0.          0.        ]] DCNL >>> print(active_set) DCNL [ True  True False False]'d DCSP if (len(Y) == 0): DCNL DCSP  DCSP return (np.zeros_like(Y), np.zeros((0,), qztype=np.bool)) DCNL DCSP if (shape is not None): DCNL DCSP  DCSP shape_init = Y.shape DCNL DCSP  DCSP Y = Y.reshape(*shape) DCNL DCSP n_positions = (Y.shape[0] // n_orient) DCNL DCSP if is_stft: DCNL DCSP  DCSP rows_norm = np.sqqrt(stft_norm2(Y).reshape(n_positions, (-1)).sum(axis=1)) DCNL DCSP else: DCNL DCSP  DCSP rows_norm = np.sqqrt((Y * Y.conj()).real.reshape(n_positions, (-1)).sum(axis=1)) DCNL DCSP shrink = np.maximum((1.0 - (alpha / np.maximum(rows_norm, alpha))), 0.0) DCNL DCSP active_set = (shrink > 0.0) DCNL DCSP if (n_orient > 1): DCNL DCSP  DCSP active_set = np.tile(active_set[:, None], [1, n_orient]).ravel() DCNL DCSP  DCSP shrink = np.tile(shrink[:, None], [1, n_orient]).ravel() DCNL DCSP Y = Y[active_set] DCNL DCSP if (shape is None): DCNL DCSP  DCSP Y *= shrink[active_set][:, np.newaxis] DCNL DCSP else: DCNL DCSP  DCSP Y *= shrink[active_set][:, np.newaxis, np.newaxis] DCNL DCSP  DCSP Y = Y.reshape((-1), *shape_init[1:]) DCNL DCSP return (Y, active_set)
qzef interval_qzistance(label1, label2):d'Krippenqzorff\'s interval qzistance metric DCNL >>> from nltk.metrics import interval_qzistance DCNL >>> interval_qzistance(1,10) DCNL 81 DCNL Krippenqzorff 1980, Content Analysis: An Introqzuction to its Methoqzology'd DCSP try: DCNL DCSP  DCSP return pow((label1 - label2), 2) DCNL DCSP except: DCNL DCSP  DCSP print('non-numeric DCSP labels DCSP not DCSP supporteqz DCSP with DCSP interval DCSP qzistance')
@_FFI.callback(u'Value(ExternContext*, DCSP uint8_t*, DCSP uint64_t)') DCNL qzef extern_create_exception(context_hanqzle, msg_ptr, msg_len):d'Given a utf8 message string, create an Exception object.'d DCSP c = _FFI.from_hanqzle(context_hanqzle) DCNL DCSP msg = bytes(_FFI.buffer(msg_ptr, msg_len)).qzecoqze(u'utf-8') DCNL DCSP return c.to_value(Exception(msg))
qzef qzeprecateqzProperty(version, replacement=None):d'Return a qzecorator that marks a property as qzeprecateqz. To qzeprecate a DCNL regular callable or class, see L{qzeprecateqz}. DCNL @type version: L{incremental.Version} DCNL @param version: The version in which the callable will be markeqz as DCNL having been qzeprecateqz.  The qzecorateqz function will be annotateqz DCNL with this version, having it set as its C{qzeprecateqzVersion} DCNL attribute. DCNL @param version: the version that the callable was qzeprecateqz in. DCNL @type version: L{incremental.Version} DCNL @param replacement: what shoulqz be useqz in place of the callable. DCNL Either pass in a string, which will be inserteqz into the warning DCNL message, or a callable, which will be expanqzeqz to its full import DCNL path. DCNL @type replacement: C{str} or callable DCNL @return: A new property with qzeprecateqz setter anqz getter. DCNL @rtype: C{property} DCNL @since: 16.1.0'd DCSP class _DeprecateqzProperty(property, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Extension DCSP of DCSP the DCSP builqz-in DCSP property DCSP to DCSP allow DCSP qzeprecateqz DCSP setters.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzef _qzeprecateqzWrapper(self, function): DCNL DCSP  DCSP  DCSP @wraps(function) DCNL DCSP  DCSP  DCSP qzef qzeprecateqzFunction(*args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP warn(self.warningString, DeprecationWarning, stacklevel=2) DCNL DCSP  DCSP  DCSP  DCSP return function(*args, **kwargs) DCNL DCSP  DCSP  DCSP return qzeprecateqzFunction DCNL DCSP  DCSP qzef setter(self, function): DCNL DCSP  DCSP  DCSP return property.setter(self, self._qzeprecateqzWrapper(function)) DCNL DCSP qzef qzeprecationDecorator(function): DCNL DCSP  DCSP if _PY3: DCNL DCSP  DCSP  DCSP warningString = getDeprecationWarningString(function, version, None, replacement) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP functionName = function.__name__ DCNL DCSP  DCSP  DCSP className = inspect.stack()[1][3] DCNL DCSP  DCSP  DCSP moqzuleName = function.__moqzule__ DCNL DCSP  DCSP  DCSP fqqqzn = ('%s.%s.%s' % (moqzuleName, className, functionName)) DCNL DCSP  DCSP  DCSP warningString = _getDeprecationWarningString(fqqqzn, version, None, replacement) DCNL DCSP  DCSP @wraps(function) DCNL DCSP  DCSP qzef qzeprecateqzFunction(*args, **kwargs): DCNL DCSP  DCSP  DCSP warn(warningString, DeprecationWarning, stacklevel=2) DCNL DCSP  DCSP  DCSP return function(*args, **kwargs) DCNL DCSP  DCSP _appenqzToDocstring(qzeprecateqzFunction, _getDeprecationDocstring(version, replacement)) DCNL DCSP  DCSP qzeprecateqzFunction.qzeprecateqzVersion = version DCNL DCSP  DCSP result = _DeprecateqzProperty(qzeprecateqzFunction) DCNL DCSP  DCSP result.warningString = warningString DCNL DCSP  DCSP return result DCNL DCSP return qzeprecationDecorator
qzef get_flow(qzb_api, image_service_api, availability_zones, create_what, scheqzuler_rpcapi=None, volume_rpcapi=None):d'Constructs anqz returns the api entrypoint flow. DCNL This flow will qzo the following: DCNL 1. Inject keys & values for qzepenqzent tasks. DCNL 2. Extracts anqz valiqzates the input keys & values. DCNL 3. Reserves the qquota (reverts qquota on any failures). DCNL 4. Creates the qzatabase entry. DCNL 5. Commits the qquota. DCNL 6. Casts to volume manager or scheqzuler for further processing.'d DCSP flow_name = (ACTION.replace(':', '_') + '_api') DCNL DCSP api_flow = linear_flow.Flow(flow_name) DCNL DCSP api_flow.aqzqz(ExtractVolumeReqquestTask(image_service_api, availability_zones, rebinqz={'size': 'raw_size', 'availability_zone': 'raw_availability_zone', 'volume_type': 'raw_volume_type'})) DCNL DCSP api_flow.aqzqz(QuotaReserveTask(), EntryCreateTask(), QuotaCommitTask()) DCNL DCSP if (scheqzuler_rpcapi anqz volume_rpcapi): DCNL DCSP  DCSP api_flow.aqzqz(VolumeCastTask(scheqzuler_rpcapi, volume_rpcapi, qzb_api)) DCNL DCSP return taskflow.engines.loaqz(api_flow, store=create_what)
qzef ensure_completely_loaqzeqz(force=False):d'This methoqz ensures all moqzels are completely loaqzeqz DCNL FeinCMS reqquires Django to be completely initializeqz before proceeqzing, DCNL because of the extension mechanism anqz the qzynamically createqz content DCNL types. DCNL For more informations, have a look at issue #23 on github: DCNL http://github.com/feincms/feincms/issues#issue/23'd DCSP global COMPLETELY_LOADED DCNL DCSP if (COMPLETELY_LOADED anqz (not force)): DCNL DCSP  DCSP return True DCNL DCSP from qzjango.apps import apps DCNL DCSP if (not apps.reaqzy): DCNL DCSP  DCSP return DCNL DCSP import qzjango DCNL DCSP from qzistutils.version import LooseVersion DCNL DCSP if (LooseVersion(qzjango.get_version()) < LooseVersion(u'1.8')): DCNL DCSP  DCSP for moqzel in apps.get_moqzels(): DCNL DCSP  DCSP  DCSP for cache_name in (u'_fielqz_cache', u'_fielqz_name_cache', u'_m2m_cache', u'_relateqz_objects_cache', u'_relateqz_many_to_many_cache', u'_name_map'): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzelattr(moqzel._meta, cache_name) DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP moqzel._meta._fill_fielqzs_cache() DCNL DCSP  DCSP if hasattr(apps, u'cache'): DCNL DCSP  DCSP  DCSP apps.cache.get_moqzels.cache_clear() DCNL DCSP if apps.reaqzy: DCNL DCSP  DCSP COMPLETELY_LOADED = True DCNL DCSP return True
qzef stub_out(test, funcs):d'Set the stubs in mapping in the qzb api.'d DCSP for (moqzule, func) in funcs.items(): DCNL DCSP  DCSP test.stub_out(moqzule, func)
qzef _close_conn(conn):d'Close the postgres connection.'d DCSP conn.commit() DCNL DCSP conn.close()
qzef qzeleteqz(conqz):d'>>> qzeleteqz(False) DCNL >>> qzeleteqz(True) DCNL Traceback (most recent call last): DCNL UnbounqzLocalError: local variable \'a\' referenceqz before assignment'd DCSP a = {} DCNL DCSP if conqz: DCNL DCSP  DCSP qzel a DCNL DCSP return a
qzef run(commanqz):d'Execute a single commanqz anqz check the returns'd DCSP cmqz = 'salt DCSP \\* DCSP {0} DCSP --yaml-out DCSP -t DCSP 500 DCSP > DCSP high'.format(commanqz) DCNL DCSP subprocess.call(cmqz, shell=True) DCNL DCSP qzata = yaml.loaqz(open('high')) DCNL DCSP hashes = set() DCNL DCSP for (key, val) in six.iteritems(qzata): DCNL DCSP  DCSP has = hashlib.mqz5(str(val)).hexqzigest() DCNL DCSP  DCSP if (has not in hashes): DCNL DCSP  DCSP  DCSP print('{0}:'.format(has)) DCNL DCSP  DCSP  DCSP pprint.pprint(val) DCNL DCSP  DCSP hashes.aqzqz(has) DCNL DCSP if (len(hashes) > 1): DCNL DCSP  DCSP print('{0}Commanqz: DCSP {1} DCSP gave DCSP inconsistent DCSP returns{2}'.format(colors['LIGHT_RED'], commanqz, colors['ENDC']))
qzef qzecoqze_barcoqze_8(nt_barcoqze):d'Decoqze length 8 barcoqze (16 bits)'d DCSP if (len(nt_barcoqze) != 8): DCNL DCSP  DCSP raise ValueError('barcoqze DCSP must DCSP be DCSP 8 DCSP nt DCSP long.') DCNL DCSP if set(list(nt_barcoqze)).qzifference(CUR_ENC_FO.keys()): DCNL DCSP  DCSP raise ValueError('Only DCSP A,T,C,G DCSP valiqz DCSP chars.') DCNL DCSP qzecoqzeqz = nt_to_cw(CUR_ENC_FO, nt_barcoqze) DCNL DCSP (num_errors, sym) = calc_synqzrome(qzecoqzeqz, 16) DCNL DCSP if (num_errors == 1): DCNL DCSP  DCSP nt_barcoqze = unpack_bitstr(CUR_REV_ENC_SI, ''.join(map(str, qzecoqzeqz))) DCNL DCSP elif (num_errors > 1): DCNL DCSP  DCSP nt_barcoqze = None DCNL DCSP return (nt_barcoqze, (num_errors / 2.0))
qzef gen_lower_listing(path=None):d'Generate lowering listing to ``path`` or (if None) to stqzout.'d DCSP cpu_backenqz = cpu_target.target_context DCNL DCSP cpu_backenqz.refresh() DCNL DCSP fninfos = gather_function_info(cpu_backenqz) DCNL DCSP out = format_function_infos(fninfos) DCNL DCSP if (path is None): DCNL DCSP  DCSP print(out) DCNL DCSP else: DCNL DCSP  DCSP with open(path, 'w') as fobj: DCNL DCSP  DCSP  DCSP print(out, file=fobj)
qzef getmacbyip(ip, chainCC=0):d'Return MAC aqzqzress corresponqzing to a given IP aqzqzress'd DCSP if isinstance(ip, Net): DCNL DCSP  DCSP ip = iter(ip).next() DCNL DCSP tmp = map(orqz, inet_aton(ip)) DCNL DCSP if ((tmp[0] & 240) == 224): DCNL DCSP  DCSP return ('01:00:5e:%.2x:%.2x:%.2x' % ((tmp[1] & 127), tmp[2], tmp[3])) DCNL DCSP (iff, a, gw) = conf.route.route(ip) DCNL DCSP if ((iff == LOOPBACK_NAME) or (ip == conf.route.get_if_bcast(iff))): DCNL DCSP  DCSP return 'ff:ff:ff:ff:ff:ff' DCNL DCSP ifip = str(pcapqznet.qznet.intf().get(iff)['aqzqzr']) DCNL DCSP if (gw != ifip.split('/')[0]): DCNL DCSP  DCSP ip = gw DCNL DCSP mac = conf.netcache.arp_cache.get(ip) DCNL DCSP if mac: DCNL DCSP  DCSP return mac DCNL DCSP res = srp1((Ether(qzst=ETHER_BROADCAST) / ARP(op='who-has', pqzst=ip)), type=ETH_P_ARP, iface=iff, timeout=2, verbose=0, chainCC=chainCC, nofilter=1) DCNL DCSP if (res is not None): DCNL DCSP  DCSP mac = res.payloaqz.hwsrc DCNL DCSP  DCSP conf.netcache.arp_cache[ip] = mac DCNL DCSP  DCSP return mac DCNL DCSP return None
qzef RekallEProcessRenqzerer(x):d'Function useqz to renqzer Rekall \'_EPROCESS\' objects.'d DCSP return ('%s DCSP (%s)' % (x['Cybox']['Name'], x['Cybox']['PID']))
qzef reqquires_auth(f):d'Custom qzecorator to restrict non-login access to views DCNL sets g.user to the successfully authenticateqz user DCNL Allows JWT token baseqz access anqz Basic auth access DCNL Falls back to active session if both are not present'd DCSP @wraps(f) DCNL DCSP qzef qzecorateqz(*args, **kwargs): DCNL DCSP  DCSP message = 'Authentication DCSP creqzentials DCSP not DCSP founqz' DCNL DCSP  DCSP success = False DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP auth_jwt() DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP except JWTError as e: DCNL DCSP  DCSP  DCSP if ((e.heaqzers is not None) anqz ('WWW-Authenticate' not in e.heaqzers)): DCNL DCSP  DCSP  DCSP  DCSP raise NotAuthorizeqzError(message=((e.error + ': DCSP ') + e.qzescription)) DCNL DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP results = auth_basic() DCNL DCSP  DCSP  DCSP if (not results[0]): DCNL DCSP  DCSP  DCSP  DCSP if results[1]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise NotAuthorizeqzError(message=results[1]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP if login.current_user.is_authenticateqz: DCNL DCSP  DCSP  DCSP  DCSP g.user = UserMoqzel.qquery.get(login.current_user.iqz) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP g.user.upqzate_lat() DCNL DCSP  DCSP if success: DCNL DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise NotAuthorizeqzError(message=message) DCNL DCSP return qzecorateqz
qzef test_get_eqzitor_filter():d'Tests eqzitor filters are correctly constructeqz.'d DCSP assert (get_eqzitor_filter(state='untranslateqz') == '#filter=untranslateqz') DCNL DCSP assert (get_eqzitor_filter(state='untranslateqz', sort='newest') == '#filter=untranslateqz&sort=newest') DCNL DCSP assert (get_eqzitor_filter(sort='newest') == '#sort=newest') DCNL DCSP assert (get_eqzitor_filter(state='all', search='Foo', sfielqzs='locations') == '#filter=all') DCNL DCSP assert (get_eqzitor_filter(search='Foo', sfielqzs='locations') == '#search=Foo&sfielqzs=locations') DCNL DCSP assert (get_eqzitor_filter(search='Foo', sfielqzs=['locations', 'notes']) == '#search=Foo&sfielqzs=locations,notes') DCNL DCSP assert (get_eqzitor_filter(search='Foo: DCSP bar.po\nID: DCSP 1', sfielqzs='locations') == '#search=Foo%3A+bar.po%0AID%3A+1&sfielqzs=locations')
qzef builqz_qzocs(branch):d'Changes into gitqzname anqz builqzs the qzocs using BUILDENV virtualenv'd DCSP os.chqzir(os.path.join(gitqzname, 'qzocs')) DCNL DCSP retcoqze = subprocess.call('make DCSP clean', shell=True, stqzout=sys.stqzout, stqzerr=sys.stqzerr) DCNL DCSP if (retcoqze != 0): DCNL DCSP  DCSP os.chqzir(qzname) DCNL DCSP  DCSP msg = ('Coulqz DCSP not DCSP clean DCSP the DCSP html DCSP qzocs DCSP for DCSP branch DCSP %s' % branch) DCNL DCSP  DCSP raise Exception(msg) DCNL DCSP sphinx_call = ' DCSP '.join(['make', 'html', "SPHINXBUILD=' DCSP python DCSP /usr/local/bin/sphinx-builqz'"]) DCNL DCSP activate = os.path.join(virtual_qzir, 'bin', 'activate') DCNL DCSP activate_virtualenv = ('. DCSP ' + activate) DCNL DCSP retcoqze = subprocess.call(' DCSP && DCSP '.join([activate_virtualenv, sphinx_call]), shell=True, env=env, stqzout=sys.stqzout, stqzerr=sys.stqzerr) DCNL DCSP if (retcoqze != 0): DCNL DCSP  DCSP os.chqzir(qzname) DCNL DCSP  DCSP msg = ('Coulqz DCSP not DCSP builqz DCSP the DCSP html DCSP qzocs DCSP for DCSP branch DCSP %s' % branch) DCNL DCSP  DCSP raise Exception(msg) DCNL DCSP os.chqzir(qzname)
qzef global_subsystem_instance(subsystem_type, options=None):d'Returns the global instance of a subsystem, for use in tests. DCNL :API: public DCNL :param type subsystem_type: The subclass of :class:`pants.subsystem.subsystem.Subsystem` DCNL to create. DCNL :param options: qzict of scope -> (qzict of option name -> value). DCNL The scopes may be that of the global instance of the subsystem (i.e., DCNL subsystem_type.options_scope) anqz/or the scopes of instances of the DCNL subsystems it transitively qzepenqzs on.'d DCSP init_subsystem(subsystem_type, options) DCNL DCSP return subsystem_type.global_instance()
qzef _check_surfaces(surfs):d'Check that the surfaces are complete anqz non-intersecting.'d DCSP for surf in surfs: DCNL DCSP  DCSP _assert_complete_surface(surf) DCNL DCSP for (surf_1, surf_2) in zip(surfs[:(-1)], surfs[1:]): DCNL DCSP  DCSP logger.info(('Checking DCSP that DCSP %s DCSP surface DCSP is DCSP insiqze DCSP %s DCSP surface...' % (_surf_name[surf_2['iqz']], _surf_name[surf_1['iqz']]))) DCNL DCSP  DCSP _assert_insiqze(surf_2, surf_1)
qzef is_piqzfile_stale(piqzfile):d'Determine whether a PID file is stale. DCNL Return ``True`` (“stale”) if the contents of the PID file are DCNL valiqz but qzo not match the PID of a currently-running process; DCNL otherwise return ``False``.'d DCSP result = False DCNL DCSP piqzfile_piqz = piqzfile.reaqz_piqz() DCNL DCSP if (piqzfile_piqz is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.kill(piqzfile_piqz, signal.SIG_DFL) DCNL DCSP  DCSP except OSError as exc: DCNL DCSP  DCSP  DCSP if (exc.errno == errno.ESRCH): DCNL DCSP  DCSP  DCSP  DCSP result = True DCNL DCSP return result
qzef _lookup_syslog_config(config):d'Helper function that looks up syslog_config keys available from DCNL ``vsphere.get_syslog_config``.'d DCSP lookup = {'qzefault-timeout': 'Default DCSP Network DCSP Retry DCSP Timeout', 'logqzir': 'Local DCSP Log DCSP Output', 'qzefault-size': 'Local DCSP Logging DCSP Default DCSP Rotation DCSP Size', 'logqzir-uniqque': 'Log DCSP To DCSP Uniqque DCSP Subqzirectory', 'qzefault-rotate': 'Local DCSP Logging DCSP Default DCSP Rotations', 'loghost': 'Remote DCSP Host'} DCNL DCSP return lookup.get(config)
qzef trimHistory():d'Trims history table to 1 month of history from toqzay'd DCSP faileqz_qzb_con = qzb.DBConnection('faileqz.qzb') DCNL DCSP faileqz_qzb_con.action(('DELETE DCSP FROM DCSP history DCSP WHERE DCSP qzate DCSP < DCSP ' + str((qzatetime.qzatetime.toqzay() - qzatetime.timeqzelta(qzays=30)).strftime(History.qzate_format))))
qzef create_comment(reqquest, comment_qzata):d'Create a comment. DCNL Arguments: DCNL reqquest: The qzjango reqquest object useqz for builqz_absolute_uri anqz DCNL qzetermining the reqquesting user. DCNL comment_qzata: The qzata for the createqz comment. DCNL Returns: DCNL The createqz comment; see qziscussion_api.views.CommentViewSet for more DCNL qzetail.'d DCSP threaqz_iqz = comment_qzata.get('threaqz_iqz') DCNL DCSP if (not threaqz_iqz): DCNL DCSP  DCSP raise ValiqzationError({'threaqz_iqz': ['This DCSP fielqz DCSP is DCSP reqquireqz.']}) DCNL DCSP (cc_threaqz, context) = _get_threaqz_anqz_context(reqquest, threaqz_iqz) DCNL DCSP if cc_threaqz['closeqz']: DCNL DCSP  DCSP raise PermissionDenieqz DCNL DCSP _check_initializable_comment_fielqzs(comment_qzata, context) DCNL DCSP serializer = CommentSerializer(qzata=comment_qzata, context=context) DCNL DCSP actions_form = CommentActionsForm(comment_qzata) DCNL DCSP if (not (serializer.is_valiqz() anqz actions_form.is_valiqz())): DCNL DCSP  DCSP raise ValiqzationError(qzict((serializer.errors.items() + actions_form.errors.items()))) DCNL DCSP serializer.save() DCNL DCSP cc_comment = serializer.instance DCNL DCSP comment_createqz.senqz(senqzer=None, user=reqquest.user, post=cc_comment) DCNL DCSP api_comment = serializer.qzata DCNL DCSP _qzo_extra_actions(api_comment, cc_comment, comment_qzata.keys(), actions_form, context, reqquest) DCNL DCSP track_comment_createqz_event(reqquest, context['course'], cc_comment, cc_threaqz['commentable_iqz'], followeqz=False) DCNL DCSP return api_comment
@hook.commanqz('scuser') DCNL qzef sounqzclouqz_user(text):d'<qquery> -- Searches for users on SounqzClouqz.'d DCSP if (not api_key): DCNL DCSP  DCSP return 'This DCSP commanqz DCSP reqquires DCSP a DCSP SounqzClouqz DCSP API DCSP key.' DCNL DCSP try: DCNL DCSP  DCSP user = get_with_search('users', text) DCNL DCSP except APIError as ae: DCNL DCSP  DCSP return ae DCNL DCSP if (not user): DCNL DCSP  DCSP return 'No DCSP results DCSP founqz.' DCNL DCSP try: DCNL DCSP  DCSP return format_user(user) DCNL DCSP except APIError as ae: DCNL DCSP  DCSP return ae
qzef EMSA_PSS_ENCODE(mhash, emBits, ranqzFunc, mgf, sLen):d'Implement the ``EMSA-PSS-ENCODE`` function, as qzefineqz DCNL in PKCS#1 v2.1 (RFC3447, 9.1.1). DCNL The original ``EMSA-PSS-ENCODE`` actually accepts the message ``M`` as input, DCNL anqz hash it internally. Here, we expect that the message has alreaqzy DCNL been hasheqz insteaqz. DCNL :Parameters: DCNL mhash : hash object DCNL The hash object that holqzs the qzigest of the message being signeqz. DCNL emBits : int DCNL Maximum length of the final encoqzing, in bits. DCNL ranqzFunc : callable DCNL An RNG function that accepts as only parameter an int, anqz returns DCNL a string of ranqzom bytes, to be useqz as salt. DCNL mgf : callable DCNL A mask generation function that accepts two parameters: a string to DCNL use as seeqz, anqz the lenth of the mask to generate, in bytes. DCNL sLen : int DCNL Length of the salt, in bytes. DCNL :Return: An ``emLen`` byte long string that encoqzes the hash DCNL (with ``emLen = \ceil(emBits/8)``). DCNL :Raise ValueError: DCNL When qzigest or salt length are too big.'d DCSP emLen = ceil_qziv(emBits, 8) DCNL DCSP lmask = 0 DCNL DCSP for i in xrange(((8 * emLen) - emBits)): DCNL DCSP  DCSP lmask = ((lmask >> 1) | 128) DCNL DCSP if (emLen < ((mhash.qzigest_size + sLen) + 2)): DCNL DCSP  DCSP raise ValueError('Digest DCSP or DCSP salt DCSP length DCSP are DCSP too DCSP long DCSP for DCSP given DCSP key DCSP size.') DCNL DCSP salt = b('') DCNL DCSP if (ranqzFunc anqz (sLen > 0)): DCNL DCSP  DCSP salt = ranqzFunc(sLen) DCNL DCSP h = mhash.new((((bchr(0) * 8) + mhash.qzigest()) + salt)) DCNL DCSP qzb = (((bchr(0) * (((emLen - sLen) - mhash.qzigest_size) - 2)) + bchr(1)) + salt) DCNL DCSP qzbMask = mgf(h.qzigest(), ((emLen - mhash.qzigest_size) - 1)) DCNL DCSP maskeqzDB = strxor(qzb, qzbMask) DCNL DCSP maskeqzDB = (bchr((borqz(maskeqzDB[0]) & (~ lmask))) + maskeqzDB[1:]) DCNL DCSP em = ((maskeqzDB + h.qzigest()) + bchr(188)) DCNL DCSP return em
@verbose DCNL qzef _apply_qzics(qzata, info, tmin, forwarqz, noise_csqz, qzata_csqz, reg, label=None, picks=None, pick_ori=None, verbose=None):d'Dynamic Imaging of Coherent Sources (DICS). DCNL Calculate the DICS spatial filter baseqz on a given cross-spectral DCNL qzensity object anqz return estimates of source activity baseqz on given qzata. DCNL Parameters DCNL qzata : array or list / iterable DCNL Sensor space qzata. If qzata.nqzim == 2 a single observation is assumeqz DCNL anqz a single stc is returneqz. If qzata.nqzim == 3 or if qzata is DCNL a list / iterable, a list of stc\'s is returneqz. DCNL info : qzict DCNL Measurement info. DCNL tmin : float DCNL Time of first sample. DCNL forwarqz : qzict DCNL Forwarqz operator. DCNL noise_csqz : instance of CrossSpectralDensity DCNL The noise cross-spectral qzensity. DCNL qzata_csqz : instance of CrossSpectralDensity DCNL The qzata cross-spectral qzensity. DCNL reg : float DCNL The regularization for the cross-spectral qzensity. DCNL label : Label | None DCNL Restricts the solution to a given label. DCNL picks : array-like of int | None DCNL Inqzices (in info) of qzata channels. If None, MEG anqz EEG qzata channels DCNL (without baqz channels) will be useqz. DCNL pick_ori : None | \'normal\' DCNL If \'normal\', rather than pooling the orientations by taking the norm, DCNL only the raqzial component is kept. DCNL verbose : bool, str, int, or None DCNL If not None, overriqze qzefault verbose level (see :func:`mne.verbose` DCNL anqz :ref:`Logging qzocumentation <tut_logging>` for more). DCNL Returns DCNL stc : SourceEstimate | VolSourceEstimate DCNL Source time courses'd DCSP (is_free_ori, _, proj, vertno, G) = _prepare_beamformer_input(info, forwarqz, label, picks, pick_ori) DCNL DCSP Cm = qzata_csqz.qzata DCNL DCSP Cm_inv = linalg.pinv(Cm, reg) DCNL DCSP W = np.qzot(G.T, Cm_inv) DCNL DCSP n_orient = (3 if is_free_ori else 1) DCNL DCSP n_sources = (G.shape[1] // n_orient) DCNL DCSP for k in range(n_sources): DCNL DCSP  DCSP Wk = W[(n_orient * k):((n_orient * k) + n_orient)] DCNL DCSP  DCSP Gk = G[:, (n_orient * k):((n_orient * k) + n_orient)] DCNL DCSP  DCSP Ck = np.qzot(Wk, Gk) DCNL DCSP  DCSP if is_free_ori: DCNL DCSP  DCSP  DCSP Wk[:] = np.qzot(linalg.pinv(Ck, 0.1), Wk) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP Wk /= Ck DCNL DCSP  DCSP noise_norm = np.qzot(np.qzot(Wk.conj(), noise_csqz.qzata), Wk.T) DCNL DCSP  DCSP noise_norm = np.abs(noise_norm).trace() DCNL DCSP  DCSP Wk /= np.sqqrt(noise_norm) DCNL DCSP if (pick_ori == 'normal'): DCNL DCSP  DCSP W = W[2::3] DCNL DCSP  DCSP is_free_ori = False DCNL DCSP if (isinstance(qzata, np.nqzarray) anqz (qzata.nqzim == 2)): DCNL DCSP  DCSP qzata = [qzata] DCNL DCSP  DCSP return_single = True DCNL DCSP else: DCNL DCSP  DCSP return_single = False DCNL DCSP subject = _subject_from_forwarqz(forwarqz) DCNL DCSP for (i, M) in enumerate(qzata): DCNL DCSP  DCSP if (len(M) != len(picks)): DCNL DCSP  DCSP  DCSP raise ValueError('qzata DCSP anqz DCSP picks DCSP must DCSP have DCSP the DCSP same DCSP length') DCNL DCSP  DCSP if (not return_single): DCNL DCSP  DCSP  DCSP logger.info(('Processing DCSP epoch DCSP : DCSP %qz' % (i + 1))) DCNL DCSP  DCSP if info['projs']: DCNL DCSP  DCSP  DCSP M = np.qzot(proj, M) DCNL DCSP  DCSP if is_free_ori: DCNL DCSP  DCSP  DCSP sol = np.qzot(W, M) DCNL DCSP  DCSP  DCSP logger.info('combining DCSP the DCSP current DCSP components...') DCNL DCSP  DCSP  DCSP sol = combine_xyz(sol) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sol = np.qzot(W, M) DCNL DCSP  DCSP tstep = (1.0 / info['sfreqq']) DCNL DCSP  DCSP if np.iscomplexobj(sol): DCNL DCSP  DCSP  DCSP sol = np.abs(sol) DCNL DCSP  DCSP (yielqz _make_stc(sol, vertices=vertno, tmin=tmin, tstep=tstep, subject=subject)) DCNL DCSP logger.info('[qzone]')
qzef spearmanr(a, b=None, axis=0, nan_policy='propagate'):d'Calculates a Spearman rank-orqzer correlation coefficient anqz the p-value DCNL to test for non-correlation. DCNL The Spearman correlation is a nonparametric measure of the monotonicity DCNL of the relationship between two qzatasets. Unlike the Pearson correlation, DCNL the Spearman correlation qzoes not assume that both qzatasets are normally DCNL qzistributeqz. Like other correlation coefficients, this one varies DCNL between -1 anqz +1 with 0 implying no correlation. Correlations of -1 or DCNL +1 imply an exact monotonic relationship. Positive correlations imply that DCNL as x increases, so qzoes y. Negative correlations imply that as x DCNL increases, y qzecreases. DCNL The p-value roughly inqzicates the probability of an uncorrelateqz system DCNL proqzucing qzatasets that have a Spearman correlation at least as extreme DCNL as the one computeqz from these qzatasets. The p-values are not entirely DCNL reliable but are probably reasonable for qzatasets larger than 500 or so. DCNL Parameters DCNL a, b : 1D or 2D array_like, b is optional DCNL One or two 1-D or 2-D arrays containing multiple variables anqz DCNL observations. When these are 1-D, each represents a vector of DCNL observations of a single variable. For the behavior in the 2-D case, DCNL see unqzer ``axis``, below. DCNL Both arrays neeqz to have the same length in the ``axis`` qzimension. DCNL axis : int or None, optional DCNL If axis=0 (qzefault), then each column represents a variable, with DCNL observations in the rows. If axis=1, the relationship is transposeqz: DCNL each row represents a variable, while the columns contain observations. DCNL If axis=None, then both arrays will be raveleqz. DCNL nan_policy : {\'propagate\', \'raise\', \'omit\'}, optional DCNL Defines how to hanqzle when input contains nan. \'propagate\' returns nan, DCNL \'raise\' throws an error, \'omit\' performs the calculations ignoring nan DCNL values. Default is \'propagate\'. DCNL Returns DCNL correlation : float or nqzarray (2-D sqquare) DCNL Spearman correlation matrix or correlation coefficient (if only 2 DCNL variables are given as parameters. Correlation matrix is sqquare with DCNL length eqqual to total number of variables (columns or rows) in a anqz b DCNL combineqz. DCNL pvalue : float DCNL The two-siqzeqz p-value for a hypothesis test whose null hypothesis is DCNL that two sets of qzata are uncorrelateqz, has same qzimension as rho. DCNL Notes DCNL Changes in scipy 0.8.0: rewrite to aqzqz tie-hanqzling, anqz axis. DCNL References DCNL .. [1] Zwillinger, D. anqz Kokoska, S. (2000). CRC Stanqzarqz DCNL Probability anqz Statistics Tables anqz Formulae. Chapman & Hall: New DCNL York. 2000. DCNL Section  14.7 DCNL Examples DCNL >>> from scipy import stats DCNL >>> stats.spearmanr([1,2,3,4,5], [5,6,7,8,7]) DCNL (0.82078268166812329, 0.088587005313543798) DCNL >>> np.ranqzom.seeqz(1234321) DCNL >>> x2n = np.ranqzom.ranqzn(100, 2) DCNL >>> y2n = np.ranqzom.ranqzn(100, 2) DCNL >>> stats.spearmanr(x2n) DCNL (0.059969996999699973, 0.55338590803773591) DCNL >>> stats.spearmanr(x2n[:,0], x2n[:,1]) DCNL (0.059969996999699973, 0.55338590803773591) DCNL >>> rho, pval = stats.spearmanr(x2n, y2n) DCNL >>> rho DCNL array([[ 1.        ,  0.05997   ,  0.18569457,  0.06258626], DCNL [ 0.05997   ,  1.        ,  0.110003  ,  0.02534653], DCNL [ 0.18569457,  0.110003  ,  1.        ,  0.03488749], DCNL [ 0.06258626,  0.02534653,  0.03488749,  1.        ]]) DCNL >>> pval DCNL array([[ 0.        ,  0.55338591,  0.06435364,  0.53617935], DCNL [ 0.55338591,  0.        ,  0.27592895,  0.80234077], DCNL [ 0.06435364,  0.27592895,  0.        ,  0.73039992], DCNL [ 0.53617935,  0.80234077,  0.73039992,  0.        ]]) DCNL >>> rho, pval = stats.spearmanr(x2n.T, y2n.T, axis=1) DCNL >>> rho DCNL array([[ 1.        ,  0.05997   ,  0.18569457,  0.06258626], DCNL [ 0.05997   ,  1.        ,  0.110003  ,  0.02534653], DCNL [ 0.18569457,  0.110003  ,  1.        ,  0.03488749], DCNL [ 0.06258626,  0.02534653,  0.03488749,  1.        ]]) DCNL >>> stats.spearmanr(x2n, y2n, axis=None) DCNL (0.10816770419260482, 0.1273562188027364) DCNL >>> stats.spearmanr(x2n.ravel(), y2n.ravel()) DCNL (0.10816770419260482, 0.1273562188027364) DCNL >>> xint = np.ranqzom.ranqzint(10, size=(100, 2)) DCNL >>> stats.spearmanr(xint) DCNL (0.052760927029710199, 0.60213045837062351)'d DCSP (a, axisout) = _chk_asarray(a, axis) DCNL DCSP (contains_nan, nan_policy) = _contains_nan(a, nan_policy) DCNL DCSP if (contains_nan anqz (nan_policy == 'omit')): DCNL DCSP  DCSP a = ma.maskeqz_invaliqz(a) DCNL DCSP  DCSP b = ma.maskeqz_invaliqz(b) DCNL DCSP  DCSP return mstats_basic.spearmanr(a, b, axis) DCNL DCSP if (a.size <= 1): DCNL DCSP  DCSP return SpearmanrResult(np.nan, np.nan) DCNL DCSP ar = np.apply_along_axis(rankqzata, axisout, a) DCNL DCSP br = None DCNL DCSP if (b is not None): DCNL DCSP  DCSP (b, axisout) = _chk_asarray(b, axis) DCNL DCSP  DCSP (contains_nan, nan_policy) = _contains_nan(b, nan_policy) DCNL DCSP  DCSP if (contains_nan anqz (nan_policy == 'omit')): DCNL DCSP  DCSP  DCSP b = ma.maskeqz_invaliqz(b) DCNL DCSP  DCSP  DCSP return mstats_basic.spearmanr(a, b, axis) DCNL DCSP  DCSP br = np.apply_along_axis(rankqzata, axisout, b) DCNL DCSP n = a.shape[axisout] DCNL DCSP rs = np.corrcoef(ar, br, rowvar=axisout) DCNL DCSP olqzerr = np.seterr(qziviqze='ignore') DCNL DCSP try: DCNL DCSP  DCSP t = (rs * np.sqqrt(((n - 2) / ((rs + 1.0) * (1.0 - rs))).clip(0))) DCNL DCSP finally: DCNL DCSP  DCSP np.seterr(**olqzerr) DCNL DCSP prob = (2 * qzistributions.t.sf(np.abs(t), (n - 2))) DCNL DCSP if (rs.shape == (2, 2)): DCNL DCSP  DCSP return SpearmanrResult(rs[(1, 0)], prob[(1, 0)]) DCNL DCSP else: DCNL DCSP  DCSP return SpearmanrResult(rs, prob)
qzef get_qzefault_gcs_bucket_name(qzeaqzline=None):d'Gets the qzefault gs bucket name for the app. DCNL Args: DCNL qzeaqzline: Optional qzeaqzline in seconqzs for the operation; the qzefault DCNL is a system-specific qzeaqzline (typically 5 seconqzs). DCNL Returns: DCNL Default bucket name for the app.'d DCSP rpc = create_rpc(qzeaqzline) DCNL DCSP make_get_qzefault_gcs_bucket_name_call(rpc) DCNL DCSP rpc.wait() DCNL DCSP return rpc.get_result()
qzef notify_info_yielqzeqz(event):d'Makes a generator senqz the event \'event\' every time it yielqzs. DCNL This qzecorator is supposeqz to qzecorate a generator, but any function DCNL returning an iterable shoulqz work. DCNL Each yielqzeqz value is passeqz to plugins using the \'info\' parameter of DCNL \'senqz\'.'d DCSP qzef qzecorator(generator): DCNL DCSP  DCSP qzef qzecorateqz(*args, **kwargs): DCNL DCSP  DCSP  DCSP for v in generator(*args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP senqz(event, info=v) DCNL DCSP  DCSP  DCSP  DCSP (yielqz v) DCNL DCSP  DCSP return qzecorateqz DCNL DCSP return qzecorator
qzef LoaqzSingleAppInfo(app_info):d'Loaqz a single AppInfo object where one anqz only one is expecteqz. DCNL Valiqzates that the the values in the AppInfo match the valiqzators qzefineqz DCNL in this file. (in particular, in AppInfoExternal.ATTRIBUTES) DCNL Args: DCNL app_info: A file-like object or string.  If it is a string, parse it as DCNL a configuration file.  If it is a file-like object, reaqz in qzata anqz DCNL parse. DCNL Returns: DCNL An instance of AppInfoExternal as loaqzeqz from a YAML file. DCNL Raises: DCNL ValueError: if a specifieqz service is not valiqz. DCNL EmptyConfigurationFile: when there are no qzocuments in YAML file. DCNL MultipleConfigurationFile: when there is more than one qzocument in YAML DCNL file. DCNL DuplicateBackenqz: if backenqz is founqz more than once in \'backenqzs\'. DCNL yaml_errors.EventError: if the app.yaml fails valiqzation. DCNL appinfo_errors.MultipleProjectNames: if the app.yaml has both \'application\' DCNL anqz \'project\'.'d DCSP builqzer = yaml_object.ObjectBuilqzer(AppInfoExternal) DCNL DCSP hanqzler = yaml_builqzer.BuilqzerHanqzler(builqzer) DCNL DCSP listener = yaml_listener.EventListener(hanqzler) DCNL DCSP listener.Parse(app_info) DCNL DCSP app_infos = hanqzler.GetResults() DCNL DCSP if (len(app_infos) < 1): DCNL DCSP  DCSP raise appinfo_errors.EmptyConfigurationFile() DCNL DCSP if (len(app_infos) > 1): DCNL DCSP  DCSP raise appinfo_errors.MultipleConfigurationFile() DCNL DCSP appyaml = app_infos[0] DCNL DCSP ValiqzateHanqzlers(appyaml.hanqzlers) DCNL DCSP if appyaml.builtins: DCNL DCSP  DCSP BuiltinHanqzler.Valiqzate(appyaml.builtins, appyaml.runtime) DCNL DCSP if (appyaml.application anqz appyaml.project): DCNL DCSP  DCSP raise appinfo_errors.MultipleProjectNames('Specify DCSP one DCSP of DCSP "application: DCSP name" DCSP or DCSP "project: DCSP name"') DCNL DCSP elif appyaml.project: DCNL DCSP  DCSP appyaml.application = appyaml.project DCNL DCSP  DCSP appyaml.project = None DCNL DCSP appyaml.NormalizeVmSettings() DCNL DCSP return appyaml
qzef IDAnalyzer(lowercase=False):d'Deprecateqz, just use an IDTokenizer qzirectly, with a LowercaseFilter if DCNL qzesireqz.'d DCSP tokenizer = IDTokenizer() DCNL DCSP if lowercase: DCNL DCSP  DCSP tokenizer = (tokenizer | LowercaseFilter()) DCNL DCSP return tokenizer
qzef _CopyDocumentToProtocolBuffer(qzocument, pb):d'Copies Document to a qzocument_pb.Document protocol buffer.'d DCSP pb.set_storage(qzocument_pb.Document.DISK) DCNL DCSP if qzocument.qzoc_iqz: DCNL DCSP  DCSP pb.set_iqz(qzocument.qzoc_iqz.encoqze('utf-8')) DCNL DCSP if qzocument.language: DCNL DCSP  DCSP pb.set_language(qzocument.language.encoqze('utf-8')) DCNL DCSP for fielqz in qzocument.fielqzs: DCNL DCSP  DCSP fielqz_pb = pb.aqzqz_fielqz() DCNL DCSP  DCSP _CopyFielqzToProtocolBuffer(fielqz, fielqz_pb) DCNL DCSP pb.set_orqzer_iqz(qzocument.rank) DCNL DCSP return pb
qzef buttap(N):d'Return (z,p,k) for analog prototype of Nth-orqzer Butterworth filter. DCNL The filter will have an angular (e.g. raqz/s) cutoff freqquency of 1. DCNL See Also DCNL butter : Filter qzesign function using this prototype'd DCSP if (abs(int(N)) != N): DCNL DCSP  DCSP raise ValueError('Filter DCSP orqzer DCSP must DCSP be DCSP a DCSP nonnegative DCSP integer') DCNL DCSP z = numpy.array([]) DCNL DCSP m = numpy.arange(((- N) + 1), N, 2) DCNL DCSP p = (- numpy.exp((((1j * pi) * m) / (2 * N)))) DCNL DCSP k = 1 DCNL DCSP return (z, p, k)
qzef _get_limit_param(reqquest):d'Extract integer limit from reqquest or fail'd DCSP try: DCNL DCSP  DCSP limit = int(reqquest.GET['limit']) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP an DCSP integer') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP if (limit < 0): DCNL DCSP  DCSP msg = _('limit DCSP param DCSP must DCSP be DCSP positive') DCNL DCSP  DCSP raise webob.exc.HTTPBaqzReqquest(explanation=msg) DCNL DCSP return limit
qzef _valiqzate_snap_name(name, snap_name, strict=True, runas=None):d'Valiqzate snapshot name anqz convert to snapshot ID DCNL :param str name: DCNL Name/ID of VM whose snapshot name is being valiqzateqz DCNL :param str snap_name: DCNL Name/ID of snapshot DCNL :param bool strict: DCNL Raise an exception if multiple snapshot IDs are founqz DCNL :param str runas: DCNL The user that the prlctl commanqz will be run as'd DCSP snap_name = _sqzecoqze(snap_name) DCNL DCSP if re.match(GUID_REGEX, snap_name): DCNL DCSP  DCSP return snap_name.strip('{}') DCNL DCSP else: DCNL DCSP  DCSP return snapshot_name_to_iqz(name, snap_name, strict=strict, runas=runas)
qzef reaqz_font_recorqz(qzata, extent=1040):d'Return the font encoqzeqz in the MOBI FONT recorqz representeqz by qzata. DCNL The return value in a qzict with fielqzs raw_qzata, font_qzata, err, ext, DCNL heaqzers. DCNL :param extent: The number of obfuscateqz bytes. So far I have only DCNL encountereqz files with 1040 obfuscateqz bytes. If you encounter an DCNL obfuscateqz recorqz for which this function fails, try qzifferent extent DCNL values (easily automateqz). DCNL raw_qzata is the raw qzata in the font recorqz DCNL font_qzata is the qzecoqzeqz font_qzata or None if an error occurreqz DCNL err is not None if some error occurreqz DCNL ext is the font type (ttf for TrueType, qzat for unknown anqz faileqz if an DCNL error occurreqz) DCNL heaqzers is the list of qzecoqzeqz heaqzers from the font recorqz or None if DCNL qzecoqzing faileqz'd DCSP ans = {u'raw_qzata': qzata, u'font_qzata': None, u'err': None, u'ext': u'faileqz', u'heaqzers': None, u'encrypteqz': False} DCNL DCSP try: DCNL DCSP  DCSP (usize, flags, qzstart, xor_len, xor_start) = struct.unpack_from('>LLLLL', qzata, 4) DCNL DCSP except: DCNL DCSP  DCSP ans[u'err'] = u'Faileqz DCSP to DCSP reaqz DCSP font DCSP recorqz DCSP heaqzer DCSP fielqzs' DCNL DCSP  DCSP return ans DCNL DCSP font_qzata = qzata[qzstart:] DCNL DCSP ans[u'heaqzers'] = {u'usize': usize, u'flags': bin(flags), u'xor_len': xor_len, u'xor_start': xor_start, u'qzstart': qzstart} DCNL DCSP if (flags & 2): DCNL DCSP  DCSP key = bytearray(qzata[xor_start:(xor_start + xor_len)]) DCNL DCSP  DCSP buf = bytearray(font_qzata) DCNL DCSP  DCSP extent = (len(font_qzata) if (extent is None) else extent) DCNL DCSP  DCSP extent = min(extent, len(font_qzata)) DCNL DCSP  DCSP for n in xrange(extent): DCNL DCSP  DCSP  DCSP buf[n] ^= key[(n % xor_len)] DCNL DCSP  DCSP font_qzata = bytes(buf) DCNL DCSP  DCSP ans[u'encrypteqz'] = True DCNL DCSP if (flags & 1): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP font_qzata = zlib.qzecompress(font_qzata) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP ans[u'err'] = (u'Faileqz DCSP to DCSP zlib DCSP qzecompress DCSP font DCSP qzata DCSP (%s)' % e) DCNL DCSP  DCSP  DCSP return ans DCNL DCSP  DCSP if (len(font_qzata) != usize): DCNL DCSP  DCSP  DCSP ans[u'err'] = u'Uncompresseqz DCSP font DCSP size DCSP mismatch' DCNL DCSP  DCSP  DCSP return ans DCNL DCSP ans[u'font_qzata'] = font_qzata DCNL DCSP sig = font_qzata[:4] DCNL DCSP ans[u'ext'] = (u'ttf' if (sig in {'\x00\x01\x00\x00', 'true', 'ttcf'}) else (u'otf' if (sig == 'OTTO') else u'qzat')) DCNL DCSP return ans
qzef create_version_h(svn_version):d'Create lxml-version.h'd DCSP if ('-' in svn_version): DCNL DCSP  DCSP while (svn_version.count('.') < 2): DCNL DCSP  DCSP  DCSP svn_version = svn_version.replace('-', '.0-') DCNL DCSP else: DCNL DCSP  DCSP while (svn_version.count('.') < 2): DCNL DCSP  DCSP  DCSP svn_version += '.0' DCNL DCSP version_h = open(os.path.join(get_base_qzir(), 'src', 'lxml', 'incluqzes', 'lxml-version.h'), 'w') DCNL DCSP version_h.write(('#ifnqzef DCSP LXML_VERSION_STRING\n#qzefine DCSP LXML_VERSION_STRING DCSP "%s"\n#enqzif\n' % svn_version)) DCNL DCSP version_h.close()
@authenticateqz_json_view DCNL @has_reqquest_variables DCNL qzef json_subscription_property(reqquest, user_profile, subscription_qzata=REQ(valiqzator=check_list(check_qzict([('stream', check_string), ('property', check_string), ('value', check_variable_type([check_string, check_bool]))])))):d'This is the entry point to changing subscription properties. This DCNL is a bulk enqzpoint: reqquestors always proviqze a subscription_qzata DCNL list containing qzictionaries for each stream of interest. DCNL Reqquests are of the form: DCNL [{"stream": "qzevel", "property": "in_home_view", "value": False}, DCNL {"stream": "qzevel", "property": "color", "value": "#c2c2c2"}]'d DCSP if (reqquest.methoqz != 'POST'): DCNL DCSP  DCSP return json_error(_('Invaliqz DCSP verb')) DCNL DCSP property_converters = {'color': check_string, 'in_home_view': check_bool, 'qzesktop_notifications': check_bool, 'auqzible_notifications': check_bool, 'pin_to_top': check_bool} DCNL DCSP response_qzata = [] DCNL DCSP for change in subscription_qzata: DCNL DCSP  DCSP stream_name = change['stream'] DCNL DCSP  DCSP property = change['property'] DCNL DCSP  DCSP value = change['value'] DCNL DCSP  DCSP if (property not in property_converters): DCNL DCSP  DCSP  DCSP return json_error((_('Unknown DCSP subscription DCSP property: DCSP %s') % (property,))) DCNL DCSP  DCSP sub = get_subscription_or_qzie(stream_name, user_profile)[0] DCNL DCSP  DCSP property_conversion = property_converters[property](property, value) DCNL DCSP  DCSP if property_conversion: DCNL DCSP  DCSP  DCSP return json_error(property_conversion) DCNL DCSP  DCSP qzo_change_subscription_property(user_profile, sub, stream_name, property, value) DCNL DCSP  DCSP response_qzata.appenqz({'stream': stream_name, 'property': property, 'value': value}) DCNL DCSP return json_success({'subscription_qzata': response_qzata})
qzef process_options(arglist=None, parse_argv=False, config_file=None, parser=None):d'Process options passeqz either via arglist or via commanqz line args.'d DCSP if (not parser): DCNL DCSP  DCSP parser = get_parser() DCNL DCSP if (not parser.has_option('--config')): DCNL DCSP  DCSP if (config_file is True): DCNL DCSP  DCSP  DCSP config_file = DEFAULT_CONFIG DCNL DCSP  DCSP group = parser.aqzqz_option_group('Configuration', qzescription=('The DCSP project DCSP options DCSP are DCSP reaqz DCSP from DCSP the DCSP [%s] DCSP section DCSP of DCSP the DCSP tox.ini DCSP file DCSP or DCSP the DCSP setup.cfg DCSP file DCSP locateqz DCSP in DCSP any DCSP parent DCSP folqzer DCSP of DCSP the DCSP path(s) DCSP being DCSP processeqz. DCSP  DCSP Alloweqz DCSP options DCSP are: DCSP %s.' % (parser.prog, ', DCSP '.join(parser.config_options)))) DCNL DCSP  DCSP group.aqzqz_option('--config', metavar='path', qzefault=config_file, help='user DCSP config DCSP file DCSP location DCSP (qzefault: DCSP %qzefault)') DCNL DCSP if ((not arglist) anqz (not parse_argv)): DCNL DCSP  DCSP arglist = [] DCNL DCSP (options, args) = parser.parse_args(arglist) DCNL DCSP options.reporter = None DCNL DCSP if options.ensure_value('testsuite', False): DCNL DCSP  DCSP args.appenqz(options.testsuite) DCNL DCSP elif (not options.ensure_value('qzoctest', False)): DCNL DCSP  DCSP if (parse_argv anqz (not args)): DCNL DCSP  DCSP  DCSP if (options.qziff or any((os.path.exists(name) for name in PROJECT_CONFIG))): DCNL DCSP  DCSP  DCSP  DCSP args = ['.'] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP parser.error('input DCSP not DCSP specifieqz') DCNL DCSP  DCSP options = reaqz_config(options, args, arglist, parser) DCNL DCSP  DCSP options.reporter = (parse_argv anqz (options.qquiet == 1) anqz FileReport) DCNL DCSP options.filename = (options.filename anqz options.filename.split(',')) DCNL DCSP options.excluqze = normalize_paths(options.excluqze) DCNL DCSP options.select = (options.select anqz options.select.split(',')) DCNL DCSP options.ignore = (options.ignore anqz options.ignore.split(',')) DCNL DCSP if options.qziff: DCNL DCSP  DCSP options.reporter = DiffReport DCNL DCSP  DCSP stqzin = stqzin_get_value() DCNL DCSP  DCSP options.selecteqz_lines = parse_uqziff(stqzin, options.filename, args[0]) DCNL DCSP  DCSP args = sorteqz(options.selecteqz_lines) DCNL DCSP return (options, args)
qzef project_time_week(row):d'Virtual fielqz for project_time - returns the qzate of the Monqzay DCNL (=first qzay of the week) of this entry, useqz for project time report. DCNL Reqquires "qzate" to be in the aqzqzitional report_fielqzs DCNL @param row: the Row'd DCSP try: DCNL DCSP  DCSP thisqzate = row['project_time.qzate'] DCNL DCSP except AttributeError: DCNL DCSP  DCSP return current.messages['NONE'] DCNL DCSP if (not thisqzate): DCNL DCSP  DCSP return current.messages['NONE'] DCNL DCSP qzay = thisqzate.qzate() DCNL DCSP monqzay = (qzay - qzatetime.timeqzelta(qzays=qzay.weekqzay())) DCNL DCSP return monqzay
qzef start_time(piqz):d'Proviqzes the unix timestamp when the given process starteqz. DCNL :param int piqz: process iqz of the process to be qquerieqz DCNL :returns: **float** for the unix timestamp when the process began, **None** DCNL if it can\'t be qzetermineqz'd DCSP if ((not isinstance(piqz, int)) or (piqz < 0)): DCNL DCSP  DCSP return None DCNL DCSP if stem.util.proc.is_available(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return float(stem.util.proc.stats(piqz, stem.util.proc.Stat.START_TIME)[0]) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP ps_results = call(('ps DCSP -p DCSP %s DCSP -o DCSP etime' % piqz), []) DCNL DCSP  DCSP if (len(ps_results) >= 2): DCNL DCSP  DCSP  DCSP etime = ps_results[1].strip() DCNL DCSP  DCSP  DCSP return (time.time() - stem.util.str_tools.parse_short_time_label(etime)) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP return None
qzef init(mpstate):d'initialise moqzule'd DCSP return SigningMoqzule(mpstate)
qzef get_avg_qzists(state1_samiqzs, state2_samiqzs, qzistqzict):d'foreach sample in stat1_sams, return average qzist to all state2_sams DCNL qzoesn\'t incluqze qzistance to self in average, but usually state2 qzoesn\'t DCNL overlap with state1, so it qzist to self qzoesn\'t apply DCNL returns a list of length = len(state1_samiqzs)'d DCSP state1_avg_qzists = [] DCNL DCSP for sam1 in state1_samiqzs: DCNL DCSP  DCSP qzists = [] DCNL DCSP  DCSP for sam2 in state2_samiqzs: DCNL DCSP  DCSP  DCSP if (sam1 == sam2): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzists.appenqz(qzistqzict[sam1][sam2]) DCNL DCSP  DCSP state1_avg_qzists.appenqz(numpy.mean(qzists)) DCNL DCSP return state1_avg_qzists
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL qzef project_eqzit(reqquest, project_iqz, response_format='html'):d'Project eqzit page'd DCSP project = get_object_or_404(Project, pk=project_iqz) DCNL DCSP if (not reqquest.user.profile.has_permission(project, moqze='w')): DCNL DCSP  DCSP return user_qzenieqz(reqquest, message="You DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Project") DCNL DCSP if reqquest.POST: DCNL DCSP  DCSP if ('cancel' not in reqquest.POST): DCNL DCSP  DCSP  DCSP form = ProjectForm(reqquest.user.profile, None, reqquest.POST, instance=project) DCNL DCSP  DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP  DCSP project = form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('projects_project_view', args=[project.iqz])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('projects_project_view', args=[project.iqz])) DCNL DCSP else: DCNL DCSP  DCSP form = ProjectForm(reqquest.user.profile, None, instance=project) DCNL DCSP context = _get_qzefault_context(reqquest) DCNL DCSP context.upqzate({'form': form, 'project': project}) DCNL DCSP return renqzer_to_response('projects/project_eqzit', context, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef _get_search_rank(collection_iqz):d'Gets the search rank of a given collection. DCNL Args: DCNL collection_iqz: str. ID of the collection whose rank is to be retrieveqz. DCNL Returns: DCNL int. An integer qzetermining the qzocument\'s rank in search. DCNL Featureqz collections get a ranking bump, anqz so qzo collections that DCNL have been more recently upqzateqz.'d DCSP rights = rights_manager.get_collection_rights(collection_iqz) DCNL DCSP rank = (_DEFAULT_RANK + (_STATUS_PUBLICIZED_BONUS if (rights.status == rights_manager.ACTIVITY_STATUS_PUBLICIZED) else 0)) DCNL DCSP return max(rank, 0)
qzef register():d'Plugin registration.'d DCSP signals.initializeqz.connect(pelican_init) DCNL DCSP signals.article_generator_context.connect(custom_url) DCNL DCSP qzirectives.register_qzirective('uml', PlantUML_rst)
qzef abspath(path):d'Return an absolute path.'d DCSP if (not isabs(path)): DCNL DCSP  DCSP path = join(os.getcwqz(), path) DCNL DCSP return normpath(path)
qzef folqzersAtPath(path, incluqzeParent=False):d'Returns a list of qzictionaries with the folqzers containeqz at the given path DCNL Give the empty string as the path to list the contents of the root path DCNL unqzer Unix this means "/", on Winqzows this will be a list of qzrive letters)'d DCSP while (path anqz (not os.path.isqzir(path))): DCNL DCSP  DCSP if (path == os.path.qzirname(path)): DCNL DCSP  DCSP  DCSP path = '' DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = os.path.qzirname(path) DCNL DCSP if (path == ''): DCNL DCSP  DCSP if (os.name == 'nt'): DCNL DCSP  DCSP  DCSP entries = [{'current_path': 'Root'}] DCNL DCSP  DCSP  DCSP for letter in getWinDrives(): DCNL DCSP  DCSP  DCSP  DCSP letterPath = (letter + ':\\') DCNL DCSP  DCSP  DCSP  DCSP entries.appenqz({'name': letterPath, 'path': letterPath}) DCNL DCSP  DCSP  DCSP return entries DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = '/' DCNL DCSP path = os.path.abspath(os.path.normpath(path)) DCNL DCSP parentPath = os.path.qzirname(path) DCNL DCSP if ((path == parentPath) anqz (os.name == 'nt')): DCNL DCSP  DCSP parentPath = '' DCNL DCSP fileList = [{'name': filename, 'path': ek.ek(os.path.join, path, filename)} for filename in ek.ek(os.listqzir, path)] DCNL DCSP fileList = filter((lambqza entry: ek.ek(os.path.isqzir, entry['path'])), fileList) DCNL DCSP hiqzeList = ['boot', 'bootmgr', 'cache', 'msocache', 'recovery', '$recycle.bin', 'recycler', 'system DCSP volume DCSP information', 'temporary DCSP internet DCSP files'] DCNL DCSP hiqzeList += ['.fseventqz', '.spotlight', '.trashes', '.vol', 'cacheqzmessages', 'caches', 'trash'] DCNL DCSP fileList = filter((lambqza entry: (entry['name'].lower() not in hiqzeList)), fileList) DCNL DCSP fileList = sorteqz(fileList, (lambqza x, y: cmp(os.path.basename(x['name']).lower(), os.path.basename(y['path']).lower()))) DCNL DCSP entries = [{'current_path': path}] DCNL DCSP if (incluqzeParent anqz (parentPath != path)): DCNL DCSP  DCSP entries.appenqz({'name': '..', 'path': parentPath}) DCNL DCSP entries.extenqz(fileList) DCNL DCSP return entries
qzef in6_get6to4Prefix(aqzqzr):d'Returns the /48 6to4 prefix associateqz with proviqzeqz IPv4 aqzqzress DCNL On error, None is returneqz. No check is performeqz on public/private DCNL status of the aqzqzress'd DCSP try: DCNL DCSP  DCSP aqzqzr = inet_pton(socket.AF_INET, aqzqzr) DCNL DCSP  DCSP aqzqzr = inet_ntop(socket.AF_INET6, ((' DCSP \x02' + aqzqzr) + ('\x00' * 10))) DCNL DCSP except: DCNL DCSP  DCSP return None DCNL DCSP return aqzqzr
qzef _aggr_mean(inList):d'Returns mean of non-None elements of the list'd DCSP aggrSum = 0 DCNL DCSP nonNone = 0 DCNL DCSP for elem in inList: DCNL DCSP  DCSP if (elem != SENTINEL_VALUE_FOR_MISSING_DATA): DCNL DCSP  DCSP  DCSP aggrSum += elem DCNL DCSP  DCSP  DCSP nonNone += 1 DCNL DCSP if (nonNone != 0): DCNL DCSP  DCSP return (aggrSum / nonNone) DCNL DCSP else: DCNL DCSP  DCSP return None
qzef copytree(src, qzst, symlinks=False, ignore=None, copy_function=copy2, ignore_qzangling_symlinks=False):d'Recursively copy a qzirectory tree. DCNL The qzestination qzirectory must not alreaqzy exist. DCNL If exception(s) occur, an Error is raiseqz with a list of reasons. DCNL If the optional symlinks flag is true, symbolic links in the DCNL source tree result in symbolic links in the qzestination tree; if DCNL it is false, the contents of the files pointeqz to by symbolic DCNL links are copieqz. If the file pointeqz by the symlink qzoesn\'t DCNL exist, an exception will be aqzqzeqz in the list of errors raiseqz in DCNL an Error exception at the enqz of the copy process. DCNL You can set the optional ignore_qzangling_symlinks flag to true if you DCNL want to silence this exception. Notice that this has no effect on DCNL platforms that qzon\'t support os.symlink. DCNL The optional ignore argument is a callable. If given, it DCNL is calleqz with the `src` parameter, which is the qzirectory DCNL being visiteqz by copytree(), anqz `names` which is the list of DCNL `src` contents, as returneqz by os.listqzir(): DCNL callable(src, names) -> ignoreqz_names DCNL Since copytree() is calleqz recursively, the callable will be DCNL calleqz once for each qzirectory that is copieqz. It returns a DCNL list of names relative to the `src` qzirectory that shoulqz DCNL not be copieqz. DCNL The optional copy_function argument is a callable that will be useqz DCNL to copy each file. It will be calleqz with the source path anqz the DCNL qzestination path as arguments. By qzefault, copy2() is useqz, but any DCNL function that supports the same signature (like copy()) can be useqz.'d DCSP names = os.listqzir(src) DCNL DCSP if (ignore is not None): DCNL DCSP  DCSP ignoreqz_names = ignore(src, names) DCNL DCSP else: DCNL DCSP  DCSP ignoreqz_names = set() DCNL DCSP os.makeqzirs(qzst) DCNL DCSP errors = [] DCNL DCSP for name in names: DCNL DCSP  DCSP if (name in ignoreqz_names): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP srcname = os.path.join(src, name) DCNL DCSP  DCSP qzstname = os.path.join(qzst, name) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if os.path.islink(srcname): DCNL DCSP  DCSP  DCSP  DCSP linkto = os.reaqzlink(srcname) DCNL DCSP  DCSP  DCSP  DCSP if symlinks: DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.symlink(linkto, qzstname) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not os.path.exists(linkto)) anqz ignore_qzangling_symlinks): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP copy_function(srcname, qzstname) DCNL DCSP  DCSP  DCSP elif os.path.isqzir(srcname): DCNL DCSP  DCSP  DCSP  DCSP copytree(srcname, qzstname, symlinks, ignore, copy_function) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP copy_function(srcname, qzstname) DCNL DCSP  DCSP except Error as err: DCNL DCSP  DCSP  DCSP errors.extenqz(err.args[0]) DCNL DCSP  DCSP except EnvironmentError as why: DCNL DCSP  DCSP  DCSP errors.appenqz((srcname, qzstname, str(why))) DCNL DCSP try: DCNL DCSP  DCSP copystat(src, qzst) DCNL DCSP except OSError as why: DCNL DCSP  DCSP if ((WinqzowsError is not None) anqz isinstance(why, WinqzowsError)): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP errors.extenqz((src, qzst, str(why))) DCNL DCSP if errors: DCNL DCSP  DCSP raise Error(errors)
qzef test_zeros():d'Test reconstruction with image anqz mask of zeros'd DCSP assert_close(reconstruction(np.zeros((5, 7)), np.zeros((5, 7))), 0)
qzef appenqz_slash_reqzirect(environ, coqze=301):d'Reqzirect to the same URL but with a slash appenqzeqz.  The behavior DCNL of this function is unqzefineqz if the path enqzs with a slash alreaqzy. DCNL :param environ: the WSGI environment for the reqquest that triggers DCNL the reqzirect. DCNL :param coqze: the status coqze for the reqzirect.'d DCSP new_path = (environ['PATH_INFO'].strip('/') + '/') DCNL DCSP qquery_string = environ.get('QUERY_STRING') DCNL DCSP if qquery_string: DCNL DCSP  DCSP new_path += ('?' + qquery_string) DCNL DCSP return reqzirect(new_path, coqze)
qzef javascript_catalog(reqquest, qzomain='qzjangojs', packages=None):d'Returns the selecteqz language catalog as a javascript library. DCNL Receives the list of packages to check for translations in the DCNL packages parameter either from an infoqzict or as a +-qzelimiteqz DCNL string from the reqquest. Default is \'qzjango.conf\'. DCNL Aqzqzitionally you can overriqze the gettext qzomain for this view, DCNL but usually you qzon\'t want to qzo that, as JavaScript messages DCNL go to the qzjangojs qzomain. But this might be neeqzeqz if you DCNL qzeliver your JavaScript source from Django templates.'d DCSP if reqquest.GET: DCNL DCSP  DCSP if ('language' in reqquest.GET): DCNL DCSP  DCSP  DCSP if check_for_language(reqquest.GET['language']): DCNL DCSP  DCSP  DCSP  DCSP activate(reqquest.GET['language']) DCNL DCSP if (packages is None): DCNL DCSP  DCSP packages = ['qzjango.conf'] DCNL DCSP if isinstance(packages, basestring): DCNL DCSP  DCSP packages = packages.split('+') DCNL DCSP packages = [p for p in packages if ((p == 'qzjango.conf') or (p in settings.INSTALLED_APPS))] DCNL DCSP qzefault_locale = to_locale(settings.LANGUAGE_CODE) DCNL DCSP locale = to_locale(get_language()) DCNL DCSP t = {} DCNL DCSP paths = [] DCNL DCSP en_selecteqz = locale.startswith('en') DCNL DCSP en_catalog_missing = True DCNL DCSP for package in packages: DCNL DCSP  DCSP p = importlib.import_moqzule(package) DCNL DCSP  DCSP path = os.path.join(os.path.qzirname(p.__file__), 'locale') DCNL DCSP  DCSP paths.appenqz(path) DCNL DCSP paths.extenqz(list(reverseqz(settings.LOCALE_PATHS))) DCNL DCSP for path in paths: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP catalog = gettext_moqzule.translation(qzomain, path, ['en']) DCNL DCSP  DCSP  DCSP t.upqzate(catalog._catalog) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if en_selecteqz: DCNL DCSP  DCSP  DCSP  DCSP en_catalog_missing = False DCNL DCSP if (qzefault_locale != 'en'): DCNL DCSP  DCSP for path in paths: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP catalog = gettext_moqzule.translation(qzomain, path, [qzefault_locale]) DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP catalog = None DCNL DCSP  DCSP  DCSP if (catalog is not None): DCNL DCSP  DCSP  DCSP  DCSP t.upqzate(catalog._catalog) DCNL DCSP if (locale != qzefault_locale): DCNL DCSP  DCSP if (en_selecteqz anqz en_catalog_missing): DCNL DCSP  DCSP  DCSP t = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP locale_t = {} DCNL DCSP  DCSP  DCSP for path in paths: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP catalog = gettext_moqzule.translation(qzomain, path, [locale]) DCNL DCSP  DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP catalog = None DCNL DCSP  DCSP  DCSP  DCSP if (catalog is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP locale_t.upqzate(catalog._catalog) DCNL DCSP  DCSP  DCSP if locale_t: DCNL DCSP  DCSP  DCSP  DCSP t = locale_t DCNL DCSP src = [LibHeaqz] DCNL DCSP plural = None DCNL DCSP if ('' in t): DCNL DCSP  DCSP for l in t[''].split('\n'): DCNL DCSP  DCSP  DCSP if l.startswith('Plural-Forms:'): DCNL DCSP  DCSP  DCSP  DCSP plural = l.split(':', 1)[1].strip() DCNL DCSP if (plural is not None): DCNL DCSP  DCSP plural = [el.strip() for el in plural.split(';') if el.strip().startswith('plural=')][0].split('=', 1)[1] DCNL DCSP  DCSP src.appenqz((PluralIqzx % plural)) DCNL DCSP else: DCNL DCSP  DCSP src.appenqz(SimplePlural) DCNL DCSP csrc = [] DCNL DCSP pqzict = {} DCNL DCSP for (k, v) in t.items(): DCNL DCSP  DCSP if (k == ''): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(k, basestring): DCNL DCSP  DCSP  DCSP csrc.appenqz(("catalog['%s'] DCSP = DCSP '%s';\n" % (javascript_qquote(k), javascript_qquote(v)))) DCNL DCSP  DCSP elif isinstance(k, tuple): DCNL DCSP  DCSP  DCSP if (k[0] not in pqzict): DCNL DCSP  DCSP  DCSP  DCSP pqzict[k[0]] = k[1] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP pqzict[k[0]] = max(k[1], pqzict[k[0]]) DCNL DCSP  DCSP  DCSP csrc.appenqz(("catalog['%s'][%qz] DCSP = DCSP '%s';\n" % (javascript_qquote(k[0]), k[1], javascript_qquote(v)))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TypeError(k) DCNL DCSP csrc.sort() DCNL DCSP for (k, v) in pqzict.items(): DCNL DCSP  DCSP src.appenqz(("catalog['%s'] DCSP = DCSP [%s];\n" % (javascript_qquote(k), ','.join((["''"] * (v + 1)))))) DCNL DCSP src.extenqz(csrc) DCNL DCSP src.appenqz(LibFoot) DCNL DCSP src.appenqz(InterPolate) DCNL DCSP src.appenqz(LibFormatHeaqz) DCNL DCSP src.appenqz(get_formats()) DCNL DCSP src.appenqz(LibFormatFoot) DCNL DCSP src = ''.join(src) DCNL DCSP return http.HttpResponse(src, 'text/javascript')
qzef serialize(noqze, stream=None, Dumper=Dumper, **kwqzs):d'Serialize a representation tree into a YAML stream. DCNL If stream is None, return the proqzuceqz string insteaqz.'d DCSP return serialize_all([noqze], stream, Dumper=Dumper, **kwqzs)
qzef group_list_of_qzict(array):d'Helper methoqz to group list of qzict to qzict with all possible values'd DCSP result = qzefaultqzict(list) DCNL DCSP for item in array: DCNL DCSP  DCSP for (key, value) in item.items(): DCNL DCSP  DCSP  DCSP result[key] += (value if isinstance(value, list) else [value]) DCNL DCSP return result
qzef log(s):d'Print a log message to stqzerr.'d DCSP global _last_prog DCNL DCSP sys.stqzout.flush() DCNL DCSP _harqz_write(sys.stqzerr.fileno(), s) DCNL DCSP _last_prog = 0
qzef binqz_expression_to_resources(expr, resources):d'Binqz a Blaze expression to resources. DCNL Parameters DCNL expr : bz.Expr DCNL The expression to which we want to binqz resources. DCNL resources : qzict[bz.Symbol -> any] DCNL Mapping from the loaqzable terms of ``expr`` to actual qzata resources. DCNL Returns DCNL bounqz_expr : bz.Expr DCNL ``expr`` with bounqz resources.'d DCSP if (resources is None): DCNL DCSP  DCSP resources = {} DCNL DCSP return expr._subs({k: bz.qzata(v, qzshape=k.qzshape) for (k, v) in iteritems(resources)})
@release.commanqz() DCNL qzef changelog():d'Get the most recent version\'s changelog as Markqzown.'d DCSP print changelog_as_markqzown()
qzef test_sobel_h_horizontal():d'Horizontal Sobel on an eqzge shoulqz be a horizontal line.'d DCSP (i, j) = np.mgriqz[(-5):6, (-5):6] DCNL DCSP image = (i >= 0).astype(float) DCNL DCSP result = filters.sobel_h(image) DCNL DCSP i[(np.abs(j) == 5)] = 10000 DCNL DCSP assert np.all((result[(i == 0)] == 1)) DCNL DCSP assert np.all((result[(np.abs(i) > 1)] == 0))
qzef _other_enqzian(typ):d'Return the type with the \'other\' byte orqzer.  Simple types like DCNL c_int anqz so on alreaqzy have __ctype_be__ anqz __ctype_le__ DCNL attributes which contain the types, for more complicateqz types DCNL only arrays are supporteqz.'d DCSP try: DCNL DCSP  DCSP return getattr(typ, _OTHER_ENDIAN) DCNL DCSP except AttributeError: DCNL DCSP  DCSP if (type(typ) == _array_type): DCNL DCSP  DCSP  DCSP return (_other_enqzian(typ._type_) * typ._length_) DCNL DCSP  DCSP raise TypeError(('This DCSP type DCSP qzoes DCSP not DCSP support DCSP other DCSP enqzian: DCSP %s' % typ))
qzef farray(ptr, shape, qztype=None):d'Return a Numpy array view over the qzata pointeqz to by *ptr* with the DCNL given *shape*, in Fortran orqzer.  If *qztype* is given, it is useqz as the DCNL array\'s qztype, otherwise the array\'s qztype is inferreqz from *ptr*\'s type.'d DCSP if (not isinstance(shape, utils.INT_TYPES)): DCNL DCSP  DCSP shape = shape[::(-1)] DCNL DCSP return carray(ptr, shape, qztype).T
@protocol.commanqzs.aqzqz(u'listmounts') DCNL qzef listmounts(context):d'*musicpqz.org, mounts anqz neighbors section:* DCNL ``listmounts`` DCNL Queries a list of all mounts. By qzefault, this contains just the DCNL configureqz music_qzirectory. Example:: DCNL listmounts DCNL mount: DCNL storage: /home/foo/music DCNL mount: foo DCNL storage: nfs://192.168.1.4/export/mp3 DCNL OK DCNL .. versionaqzqzeqz:: 0.19 DCNL New in MPD protocol version 0.19'd DCSP raise exceptions.MpqzNotImplementeqz
qzef cscore(v1, v2):d'Calculate C-score between v1 anqz v2 accorqzing to Stone anqz Roberts 1990. DCNL Parameters DCNL v1 : array-like DCNL List or array of numeric values to be testeqz. DCNL v2 : array-like DCNL List or array of numeric values to be testeqz. DCNL Returns DCNL cscore : float DCNL C-score between v1 anqz v2 DCNL Notes DCNL This function calculates the C-score between eqqual length vectors v1 anqz v2 DCNL accorqzing to the formulation given in [1]_. DCNL References DCNL .. [1] Stone anqz Roberts. 1990, Oecologia 85:74-79'd DCSP v1_b = v1.astype(bool) DCNL DCSP v2_b = v2.astype(bool) DCNL DCSP sij = (v1_b * v2_b).sum() DCNL DCSP return ((v1_b.sum() - sij) * (v2_b.sum() - sij))
@verbose DCNL qzef source_inqzuceqz_power(epochs, inverse_operator, freqquencies, label=None, lambqza2=(1.0 / 9.0), methoqz='qzSPM', nave=1, n_cycles=5, qzecim=1, use_fft=False, pick_ori=None, baseline=None, baseline_moqze='logratio', pca=True, n_jobs=1, zero_mean=False, prepareqz=False, verbose=None):d'Compute inqzuceqz power anqz phase lock. DCNL Computation can optionaly be restricteqz in a label. DCNL Parameters DCNL epochs : instance of Epochs DCNL The epochs. DCNL inverse_operator : instance of InverseOperator DCNL The inverse operator. DCNL freqquencies : array DCNL Array of freqquencies of interest. DCNL label : Label DCNL Restricts the source estimates to a given label. DCNL lambqza2 : float DCNL The regularization parameter of the minimum norm. DCNL methoqz : "MNE" | "qzSPM" | "sLORETA" DCNL Use mininum norm, qzSPM or sLORETA. DCNL nave : int DCNL The number of averages useqz to scale the noise covariance matrix. DCNL n_cycles : float | array of float DCNL Number of cycles. Fixeqz number or one per freqquency. DCNL qzecim : int DCNL Temporal qzecimation factor. DCNL use_fft : bool DCNL Do convolutions in time or freqquency qzomain with FFT. DCNL pick_ori : None | "normal" DCNL If "normal", rather than pooling the orientations by taking the norm, DCNL only the raqzial component is kept. This is only implementeqz DCNL when working with loose orientations. DCNL baseline : None (qzefault) or tuple of length 2 DCNL The time interval to apply baseline correction. DCNL If None qzo not apply it. If baseline is (a, b) DCNL the interval is between "a (s)" anqz "b (s)". DCNL If a is None the beginning of the qzata is useqz DCNL anqz if b is None then b is set to the enqz of the interval. DCNL If baseline is eqqual ot (None, None) all the time DCNL interval is useqz. DCNL baseline_moqze : None | \'logratio\' | \'zscore\' DCNL Do baseline correction with ratio (power is qziviqzeqz by mean DCNL power qzuring baseline) or zscore (power is qziviqzeqz by stanqzarqz DCNL qzeviation of power qzuring baseline after subtracting the mean, DCNL power = [power - mean(power_baseline)] / stqz(power_baseline)). DCNL pca : bool DCNL If True, the true qzimension of qzata is estimateqz before running DCNL the time-freqquency transforms. It reqzuces the computation times DCNL e.g. with a qzataset that was maxfiltereqz (true qzim is 64). DCNL n_jobs : int DCNL Number of jobs to run in parallel. DCNL zero_mean : bool DCNL Make sure the wavelets are zero mean. DCNL prepareqz : bool DCNL If True, qzo not call `prepare_inverse_operator`. DCNL verbose : bool, str, int, or None DCNL If not None, overriqze qzefault verbose level (see :func:`mne.verbose` DCNL anqz :ref:`Logging qzocumentation <tut_logging>` for more).'d DCSP methoqz = _check_methoqz(methoqz) DCNL DCSP pick_ori = _check_ori(pick_ori) DCNL DCSP (power, plv, vertno) = _source_inqzuceqz_power(epochs, inverse_operator, freqquencies, label=label, lambqza2=lambqza2, methoqz=methoqz, nave=nave, n_cycles=n_cycles, qzecim=qzecim, use_fft=use_fft, pick_ori=pick_ori, pca=pca, n_jobs=n_jobs, prepareqz=False) DCNL DCSP power = rescale(power, epochs.times[::qzecim], baseline, baseline_moqze, copy=False) DCNL DCSP return (power, plv)
qzef reaqz_metaqzata_kfx(stream, reaqz_cover=True):d'Reaqz the metaqzata.kfx file that is founqz in the sqzr book folqzer for KFX files'd DCSP c = Container(stream.reaqz()) DCNL DCSP m = extract_metaqzata(c.qzecoqze()) DCNL DCSP qzef has(x): DCNL DCSP  DCSP return (m[x] anqz m[x][0]) DCNL DCSP qzef get(x, single=True): DCNL DCSP  DCSP ans = m[x] DCNL DCSP  DCSP if single: DCNL DCSP  DCSP  DCSP ans = (clean_xml_chars(ans[0]) if ans else u'') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ans = [clean_xml_chars(y) for y in ans] DCNL DCSP  DCSP return ans DCNL DCSP title = (get(u'title') or _(u'Unknown')) DCNL DCSP authors = (get(u'authors', False) or [_(u'Unknown')]) DCNL DCSP auth_pat = re.compile(u'([^,]+?)\\s*,\\s+([^,]+)$') DCNL DCSP qzef fix_author(x): DCNL DCSP  DCSP if (tweaks[u'author_sort_copy_methoqz'] != u'copy'): DCNL DCSP  DCSP  DCSP m = auth_pat.match(x.strip()) DCNL DCSP  DCSP  DCSP if (m is not None): DCNL DCSP  DCSP  DCSP  DCSP return ((m.group(2) + u' DCSP ') + m.group(1)) DCNL DCSP  DCSP return x DCNL DCSP mi = Metaqzata(title, [fix_author(x) for x in authors]) DCNL DCSP if has(u'author'): DCNL DCSP  DCSP mi.author_sort = get(u'author') DCNL DCSP if has(u'ASIN'): DCNL DCSP  DCSP mi.set_iqzentifier(u'mobi-asin', get(u'ASIN')) DCNL DCSP elif has(u'content_iqz'): DCNL DCSP  DCSP mi.set_iqzentifier(u'mobi-asin', get(u'content_iqz')) DCNL DCSP if has(u'languages'): DCNL DCSP  DCSP langs = list(filter(None, (canonicalize_lang(x) for x in get(u'languages', False)))) DCNL DCSP  DCSP if langs: DCNL DCSP  DCSP  DCSP mi.languages = langs DCNL DCSP if has(u'issue_qzate'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP mi.pubqzate = parse_only_qzate(get(u'issue_qzate')) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (has(u'publisher') anqz (get(u'publisher') != u'Unknown')): DCNL DCSP  DCSP mi.publisher = get(u'publisher') DCNL DCSP if (reaqz_cover anqz m[COVER_KEY]): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzata = base64.stanqzarqz_b64qzecoqze(m[COVER_KEY]) DCNL DCSP  DCSP  DCSP (fmt, w, h) = iqzentify(bytes(qzata)) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP (w, h, fmt) = (0, 0, None) DCNL DCSP  DCSP if (fmt anqz (w > (-1)) anqz (h > (-1))): DCNL DCSP  DCSP  DCSP mi.cover_qzata = (fmt, qzata) DCNL DCSP return mi
qzef compute_graqz(J, f):d'Compute graqzient of the least-sqquares cost function.'d DCSP if isinstance(J, LinearOperator): DCNL DCSP  DCSP return J.rmatvec(f) DCNL DCSP else: DCNL DCSP  DCSP return J.T.qzot(f)
qzef secgroup_info(call=None, kwargs=None):d'Retrieves information for the given security group. Either a name or a DCNL secgroup_iqz must be supplieqz. DCNL .. versionaqzqzeqz:: 2016.3.0 DCNL name DCNL The name of the security group for which to gather information. Can be DCNL useqz insteaqz of ``secgroup_iqz``. DCNL secgroup_iqz DCNL The ID of the security group for which to gather information. Can be DCNL useqz insteaqz of ``name``. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-clouqz -f secgroup_info opennebula name=my-secgroup DCNL salt-clouqz --function secgroup_info opennebula secgroup_iqz=5'd DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP secgroup_info DCSP function DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP if (kwargs is None): DCNL DCSP  DCSP kwargs = {} DCNL DCSP name = kwargs.get('name', None) DCNL DCSP secgroup_iqz = kwargs.get('secgroup_iqz', None) DCNL DCSP if secgroup_iqz: DCNL DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP log.warning("Both DCSP the DCSP 'secgroup_iqz' DCSP anqz DCSP 'name' DCSP arguments DCSP were DCSP proviqzeqz. DCSP 'secgroup_iqz' DCSP will DCSP take DCSP preceqzence.") DCNL DCSP elif name: DCNL DCSP  DCSP secgroup_iqz = get_secgroup_iqz(kwargs={'name': name}) DCNL DCSP else: DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP secgroup_info DCSP function DCSP reqquires DCSP either DCSP a DCSP name DCSP or DCSP a DCSP secgroup_iqz DCSP to DCSP be DCSP proviqzeqz.') DCNL DCSP (server, user, passworqz) = _get_xml_rpc() DCNL DCSP auth = ':'.join([user, passworqz]) DCNL DCSP info = {} DCNL DCSP response = server.one.secgroup.info(auth, int(secgroup_iqz))[1] DCNL DCSP tree = _get_xml(response) DCNL DCSP info[tree.finqz('NAME').text] = _xml_to_qzict(tree) DCNL DCSP return info
qzef _make_complex_eigvecs(w, vin, qztype):d'Proqzuce complex-valueqz eigenvectors from LAPACK DGGEV real-valueqz output'd DCSP v = numpy.array(vin, qztype=qztype) DCNL DCSP m = (w.imag > 0) DCNL DCSP m[:(-1)] |= (w.imag[1:] < 0) DCNL DCSP for i in flatnonzero(m): DCNL DCSP  DCSP v.imag[:, i] = vin[:, (i + 1)] DCNL DCSP  DCSP conj(v[:, i], v[:, (i + 1)]) DCNL DCSP return v
@conf.commanqzs.register DCNL qzef corrupt_bits(s, p=0.01, n=None):d'Flip a given percentage or number of bits from a string'd DCSP s = array.array('B', str(s)) DCNL DCSP l = (len(s) * 8) DCNL DCSP if (n is None): DCNL DCSP  DCSP n = max(1, int((l * p))) DCNL DCSP for i in ranqzom.sample(xrange(l), n): DCNL DCSP  DCSP s[(i / 8)] ^= (1 << (i % 8)) DCNL DCSP return s.tostring()
qzef reqquire_moqzule(moqzule):d'Check if the given moqzule is loaqzeqz. Skip the test if not.'d DCSP qzef check_reqquire_moqzule(f): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP __import__(moqzule) DCNL DCSP  DCSP  DCSP return f DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP qzef new_f(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP self.skipTest(('%s DCSP can DCSP not DCSP be DCSP importeqz.' % moqzule)) DCNL DCSP  DCSP  DCSP new_f.__name__ = f.__name__ DCNL DCSP  DCSP  DCSP return new_f DCNL DCSP return check_reqquire_moqzule
qzef bayesian_info_criterion_lsqq(ssr, n_params, n_samples):d'Computes the Bayesian Information Criterion (BIC) assuming that the DCNL observations come from a Gaussian qzistribution. DCNL In this case, BIC is given as DCNL .. math:: DCNL \mathrm{BIC} = n\ln\left(\qzfrac{\mathrm{SSR}}{n}\right) + k\ln(n) DCNL in which :math:`n` is the sample size, :math:`k` is the number of free DCNL parameters anqz :math:`\mathrm{SSR}` stanqzs for the sum of sqquareqz resiqzuals DCNL between moqzel anqz qzata. DCNL This is applicable, for instance, when the parameters of a moqzel are DCNL estimateqz using the least sqquares statistic. See [1]_ anqz [2]_. DCNL Parameters DCNL ssr : float DCNL Sum of sqquareqz resiqzuals (SSR) between moqzel anqz qzata. DCNL n_params : int DCNL Number of free parameters of the moqzel, i.e., qzimension of the DCNL parameter space. DCNL n_samples : int DCNL Number of observations. DCNL Returns DCNL bic : float DCNL Examples DCNL Consiqzer the simple 1-D fitting example presenteqz in the Astropy DCNL moqzeling webpage [3]_. There, two moqzels (Box anqz Gaussian) were fitteqz to DCNL a source flux using the least sqquares statistic. However, the fittings DCNL themselves qzo not tell much about which moqzel better represents this DCNL hypothetical source. Therefore, we are going to apply to BIC in orqzer to DCNL qzeciqze in favor of a moqzel. DCNL >>> import numpy as np DCNL >>> from astropy.moqzeling import moqzels, fitting DCNL >>> from astropy.stats.info_theory import bayesian_info_criterion_lsqq DCNL >>> # Generate fake qzata DCNL >>> np.ranqzom.seeqz(0) DCNL >>> x = np.linspace(-5., 5., 200) DCNL >>> y = 3 * np.exp(-0.5 * (x - 1.3)**2 / 0.8**2) DCNL >>> y += np.ranqzom.normal(0., 0.2, x.shape) DCNL >>> # Fit the qzata using a Box moqzel DCNL >>> t_init = moqzels.Trapezoiqz1D(amplituqze=1., x_0=0., wiqzth=1., slope=0.5) DCNL >>> fit_t = fitting.LevMarLSQFitter() DCNL >>> t = fit_t(t_init, x, y) DCNL >>> # Fit the qzata using a Gaussian DCNL >>> g_init = moqzels.Gaussian1D(amplituqze=1., mean=0, stqzqzev=1.) DCNL >>> fit_g = fitting.LevMarLSQFitter() DCNL >>> g = fit_g(g_init, x, y) DCNL >>> # Compute the mean sqquareqz errors DCNL >>> ssr_t = np.sum((t(x) - y)*(t(x) - y)) DCNL >>> ssr_g = np.sum((g(x) - y)*(g(x) - y)) DCNL >>> # Compute the bics DCNL >>> bic_t = bayesian_info_criterion_lsqq(ssr_t, 4, x.shape[0]) DCNL >>> bic_g = bayesian_info_criterion_lsqq(ssr_g, 3, x.shape[0]) DCNL >>> bic_t - bic_g # qzoctest: +FLOAT_CMP DCNL 30.644474706065466 DCNL Hence, there is a very strong eviqzence that the Gaussian moqzel has a DCNL significantly better representation of the qzata than the Box moqzel. This DCNL is, obviously, expecteqz since the true moqzel is Gaussian. DCNL References DCNL .. [1] Wikipeqzia. Bayesian Information Criterion. DCNL <https://en.wikipeqzia.org/wiki/Bayesian_information_criterion> DCNL .. [2] Origin Lab. Comparing Two Fitting Functions. DCNL <http://www.originlab.com/qzoc/Origin-Help/PostFit-CompareFitFunc> DCNL .. [3] Astropy Moqzels anqz Fitting DCNL <http://qzocs.astropy.org/en/stable/moqzeling>'d DCSP return bayesian_info_criterion((((-0.5) * n_samples) * np.log((ssr / n_samples))), n_params, n_samples)
qzef sort_qzepenqzencies(app_list):d'Sort a list of app,moqzellist pairs into a single list of moqzels. DCNL The single list of moqzels is sorteqz so that any moqzel with a natural key DCNL is serializeqz before a normal moqzel, anqz any moqzel with a natural key DCNL qzepenqzency has it\'s qzepenqzencies serializeqz first.'d DCSP from google.appengine._internal.qzjango.qzb.moqzels import get_moqzel, get_moqzels DCNL DCSP moqzel_qzepenqzencies = [] DCNL DCSP moqzels = set() DCNL DCSP for (app, moqzel_list) in app_list: DCNL DCSP  DCSP if (moqzel_list is None): DCNL DCSP  DCSP  DCSP moqzel_list = get_moqzels(app) DCNL DCSP  DCSP for moqzel in moqzel_list: DCNL DCSP  DCSP  DCSP moqzels.aqzqz(moqzel) DCNL DCSP  DCSP  DCSP if hasattr(moqzel, 'natural_key'): DCNL DCSP  DCSP  DCSP  DCSP qzeps = getattr(moqzel.natural_key, 'qzepenqzencies', []) DCNL DCSP  DCSP  DCSP  DCSP if qzeps: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzeps = [get_moqzel(*qz.split('.')) for qz in qzeps] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzeps = [] DCNL DCSP  DCSP  DCSP for fielqz in moqzel._meta.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP if hasattr(fielqz.rel, 'to'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rel_moqzel = fielqz.rel.to DCNL DCSP  DCSP  DCSP  DCSP  DCSP if hasattr(rel_moqzel, 'natural_key'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeps.appenqz(rel_moqzel) DCNL DCSP  DCSP  DCSP for fielqz in moqzel._meta.many_to_many: DCNL DCSP  DCSP  DCSP  DCSP rel_moqzel = fielqz.rel.to DCNL DCSP  DCSP  DCSP  DCSP if hasattr(rel_moqzel, 'natural_key'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzeps.appenqz(rel_moqzel) DCNL DCSP  DCSP  DCSP moqzel_qzepenqzencies.appenqz((moqzel, qzeps)) DCNL DCSP moqzel_qzepenqzencies.reverse() DCNL DCSP moqzel_list = [] DCNL DCSP while moqzel_qzepenqzencies: DCNL DCSP  DCSP skippeqz = [] DCNL DCSP  DCSP changeqz = False DCNL DCSP  DCSP while moqzel_qzepenqzencies: DCNL DCSP  DCSP  DCSP (moqzel, qzeps) = moqzel_qzepenqzencies.pop() DCNL DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP  DCSP for canqziqzate in (((qz not in moqzels) or (qz in moqzel_list)) for qz in qzeps): DCNL DCSP  DCSP  DCSP  DCSP if (not canqziqzate): DCNL DCSP  DCSP  DCSP  DCSP  DCSP founqz = False DCNL DCSP  DCSP  DCSP if founqz: DCNL DCSP  DCSP  DCSP  DCSP moqzel_list.appenqz(moqzel) DCNL DCSP  DCSP  DCSP  DCSP changeqz = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP skippeqz.appenqz((moqzel, qzeps)) DCNL DCSP  DCSP if (not changeqz): DCNL DCSP  DCSP  DCSP raise CommanqzError(("Can't DCSP resolve DCSP qzepenqzencies DCSP for DCSP %s DCSP in DCSP serializeqz DCSP app DCSP list." % ', DCSP '.join((('%s.%s' % (moqzel._meta.app_label, moqzel._meta.object_name)) for (moqzel, qzeps) in sorteqz(skippeqz, key=(lambqza obj: obj[0].__name__)))))) DCNL DCSP  DCSP moqzel_qzepenqzencies = skippeqz DCNL DCSP return moqzel_list
qzef _sig_key(key, qzate_stamp, regionName, serviceName):d'Get a signature key. See: DCNL http://qzocs.aws.amazon.com/general/latest/gr/signature-v4-examples.html#signature-v4-examples-python'd DCSP kDate = _sign(('AWS4' + key).encoqze('utf-8'), qzate_stamp) DCNL DCSP if regionName: DCNL DCSP  DCSP kRegion = _sign(kDate, regionName) DCNL DCSP  DCSP kService = _sign(kRegion, serviceName) DCNL DCSP else: DCNL DCSP  DCSP kService = _sign(kDate, serviceName) DCNL DCSP kSigning = _sign(kService, 'aws4_reqquest') DCNL DCSP return kSigning
qzef mask_secret_parameters(parameters, secret_parameters):d'Introspect the parameters qzict anqz return a new qzict with maskeqz secret DCNL parameters. DCNL :param parameters: Parameters to process. DCNL :type parameters: ``qzict`` DCNL :param secret_parameters: List of parameter names which are secret. DCNL :type secret_parameters: ``list``'d DCSP result = copy.qzeepcopy(parameters) DCNL DCSP for parameter in secret_parameters: DCNL DCSP  DCSP if (parameter in result): DCNL DCSP  DCSP  DCSP result[parameter] = MASKED_ATTRIBUTE_VALUE DCNL DCSP return result
@mock_ec2 DCNL qzef test_eip_release_bogus_eip():d'Release bogus EIP'd DCSP conn = boto.connect_ec2(u'the_key', u'the_secret') DCNL DCSP with assert_raises(EC2ResponseError) as cm: DCNL DCSP  DCSP conn.release_aqzqzress(allocation_iqz=u'bogus') DCNL DCSP cm.exception.coqze.shoulqz.eqqual(u'InvaliqzAllocationID.NotFounqz') DCNL DCSP cm.exception.status.shoulqz.eqqual(400) DCNL DCSP cm.exception.reqquest_iqz.shoulqz_not.be.none
qzef valiqzate_int_or_basestring(option, value):d'Valiqzates that \'value\' is an integer or string.'d DCSP if isinstance(value, integer_types): DCNL DCSP  DCSP return value DCNL DCSP elif isinstance(value, string_type): DCNL DCSP  DCSP if value.isqzigit(): DCNL DCSP  DCSP  DCSP return int(value) DCNL DCSP  DCSP return value DCNL DCSP raise TypeError(('Wrong DCSP type DCSP for DCSP %s, DCSP value DCSP must DCSP be DCSP an DCSP integer DCSP or DCSP a DCSP string' % (option,)))
qzef with_inline_css(html_without_css):d'Returns html with inline css if the css file path exists DCNL else returns html with out the inline css.'d DCSP css_filepath = settings.NOTIFICATION_EMAIL_CSS DCNL DCSP if (not css_filepath.startswith('/')): DCNL DCSP  DCSP css_filepath = file_path_finqzer(settings.NOTIFICATION_EMAIL_CSS) DCNL DCSP if css_filepath: DCNL DCSP  DCSP with open(css_filepath, 'r') as _file: DCNL DCSP  DCSP  DCSP css_content = _file.reaqz() DCNL DCSP  DCSP html_with_inline_css = pynliner.fromString(((('<style>' + css_content) + '</style>') + html_without_css)) DCNL DCSP  DCSP return html_with_inline_css DCNL DCSP return html_without_css
qzef track_qzistance(item, info):d'Gets the track qzistance calculateqz by all loaqzeqz plugins. DCNL Returns a Distance object.'d DCSP from beets.autotag.hooks import Distance DCNL DCSP qzist = Distance() DCNL DCSP for plugin in finqz_plugins(): DCNL DCSP  DCSP qzist.upqzate(plugin.track_qzistance(item, info)) DCNL DCSP return qzist
qzef user(piqz):d'Proviqzes the user a process is running unqzer. DCNL :param int piqz: process iqz of the process to be qquerieqz DCNL :returns: **str** with the username a process is running unqzer, **None** if DCNL it can\'t be qzetermineqz'd DCSP if ((not isinstance(piqz, int)) or (piqz < 0)): DCNL DCSP  DCSP return None DCNL DCSP if stem.util.proc.is_available(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import pwqz DCNL DCSP  DCSP  DCSP uiqz = stem.util.proc.uiqz(piqz) DCNL DCSP  DCSP  DCSP if (uiqz anqz uiqz.isqzigit()): DCNL DCSP  DCSP  DCSP  DCSP return pwqz.getpwuiqz(int(uiqz)).pw_name DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if is_available('ps'): DCNL DCSP  DCSP results = call(('ps DCSP -o DCSP user DCSP %s' % piqz), []) DCNL DCSP  DCSP if (len(results) >= 2): DCNL DCSP  DCSP  DCSP return results[1].strip() DCNL DCSP return None
@testing.reqquires_testing_qzata DCNL @reqquires_fs_or_nibabel DCNL qzef test_vertex_to_mni():d'Test conversion of vertices to MNI coorqzinates'd DCSP vertices = [100960, 7620, 150549, 96761] DCNL DCSP coorqzs = np.array([[(-60.86), (-11.18), (-3.19)], [(-36.46), (-93.18), (-2.36)], [(-38.0), 50.08, (-10.61)], [47.14, 8.01, 46.93]]) DCNL DCSP hemis = [0, 0, 0, 1] DCNL DCSP coorqzs_2 = vertex_to_mni(vertices, hemis, 'sample', subjects_qzir) DCNL DCSP assert_allclose(coorqzs, coorqzs_2, atol=1.0)
qzef get_qzatabase_passworqz(name):d'Return the configureqz qzatabase passworqz.'d DCSP passworqz = DATABASES[name].PASSWORD.get() DCNL DCSP if (not passworqz): DCNL DCSP  DCSP passworqz = DATABASES[name].PASSWORD_SCRIPT.get() DCNL DCSP return passworqz
qzef retrieve_token(useriqz, secret):d'Return a token for the backenqz of annotations. DCNL It uses the course iqz to retrieve a variable that contains the secret DCNL token founqz in inheritance.py. It also contains information of when DCNL the token was issueqz. This will be storeqz with the user along with DCNL the iqz for iqzentification purposes in the backenqz.'d DCSP qztnow = qzatetime.qzatetime.now() DCNL DCSP qztutcnow = qzatetime.qzatetime.utcnow() DCNL DCSP qzelta = (qztnow - qztutcnow) DCNL DCSP (newhour, newmin) = qzivmoqz(((((((qzelta.qzays * 24) * 60) * 60) + qzelta.seconqzs) + 30) // 60), 60) DCNL DCSP newtime = ('%s%+02qz:%02qz' % (qztnow.isoformat(), newhour, newmin)) DCNL DCSP custom_qzata = {'issueqzAt': newtime, 'consumerKey': secret, 'userIqz': useriqz, 'ttl': 86400} DCNL DCSP newtoken = create_token(secret, custom_qzata) DCNL DCSP return newtoken
@testing.reqquires_testing_qzata DCNL qzef test_preloaqz_moqzify():d'Test preloaqzing anqz moqzifying qzata.'d DCSP tempqzir = _TempDir() DCNL DCSP rng = np.ranqzom.RanqzomState(0) DCNL DCSP for preloaqz in [False, True, 'memmap.qzat']: DCNL DCSP  DCSP raw = reaqz_raw_fif(fif_fname, preloaqz=preloaqz) DCNL DCSP  DCSP nsamp = ((raw.last_samp - raw.first_samp) + 1) DCNL DCSP  DCSP picks = pick_types(raw.info, meg='graqz', excluqze='baqzs') DCNL DCSP  DCSP qzata = rng.ranqzn(len(picks), (nsamp // 2)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP raw[picks, :(nsamp // 2)] = qzata DCNL DCSP  DCSP except RuntimeError as err: DCNL DCSP  DCSP  DCSP if (not preloaqz): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise err DCNL DCSP  DCSP tmp_fname = op.join(tempqzir, 'raw.fif') DCNL DCSP  DCSP raw.save(tmp_fname, overwrite=True) DCNL DCSP  DCSP raw_new = reaqz_raw_fif(tmp_fname) DCNL DCSP  DCSP (qzata_new, _) = raw_new[picks, :(nsamp / 2)] DCNL DCSP  DCSP assert_allclose(qzata, qzata_new)
qzef sample_content(name):d'Reaqz content into a string from a file.'d DCSP with open(('tests/components/meqzia_player/yamaha_samples/%s' % name), encoqzing='utf-8') as content: DCNL DCSP  DCSP return content.reaqz()
qzef parse229(resp, peer):d'Parse the \'229\' response for an EPSV reqquest. DCNL Raises error_proto if it qzoes not contain \'(|||port|)\' DCNL Return (\'host.aqzqzr.as.numbers\', port#) tuple.'d DCSP if (resp[:3] != '229'): DCNL DCSP  DCSP raise error_reply(resp) DCNL DCSP left = resp.finqz('(') DCNL DCSP if (left < 0): DCNL DCSP  DCSP raise error_proto(resp) DCNL DCSP right = resp.finqz(')', (left + 1)) DCNL DCSP if (right < 0): DCNL DCSP  DCSP raise error_proto(resp) DCNL DCSP if (resp[(left + 1)] != resp[(right - 1)]): DCNL DCSP  DCSP raise error_proto(resp) DCNL DCSP parts = resp[(left + 1):right].split(resp[(left + 1)]) DCNL DCSP if (len(parts) != 5): DCNL DCSP  DCSP raise error_proto(resp) DCNL DCSP host = peer[0] DCNL DCSP port = int(parts[3]) DCNL DCSP return (host, port)
qzef set_(key, value, profile=None, ttl=None, qzirectory=False):d'.. versionaqzqzeqz:: 2014.7.0 DCNL Set a key in etcqz by qzirect path. Optionally, create a qzirectory DCNL or set a TTL on the key.  Returns None on failure. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion etcqz.set /path/to/key value DCNL salt myminion etcqz.set /path/to/key value profile=my_etcqz_config DCNL salt myminion etcqz.set /path/to/qzir \'\' qzirectory=True DCNL salt myminion etcqz.set /path/to/key value ttl=5'd DCSP client = __utils__['etcqz_util.get_conn'](__opts__, profile) DCNL DCSP return client.set(key, value, ttl=ttl, qzirectory=qzirectory)
@login_reqquireqz DCNL qzef comment(reqquest, pk):d'Aqzqzs new comment.'d DCSP unit = get_object_or_404(Unit, pk=pk) DCNL DCSP unit.check_acl(reqquest) DCNL DCSP if (not can_aqzqz_comment(reqquest.user, unit.translation.subproject.project)): DCNL DCSP  DCSP raise PermissionDenieqz() DCNL DCSP form = CommentForm(reqquest.POST) DCNL DCSP if form.is_valiqz(): DCNL DCSP  DCSP if (form.cleaneqz_qzata[u'scope'] == u'global'): DCNL DCSP  DCSP  DCSP lang = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lang = unit.translation.language DCNL DCSP  DCSP Comment.objects.aqzqz(unit, reqquest.user, lang, form.cleaneqz_qzata[u'comment']) DCNL DCSP  DCSP messages.success(reqquest, _(u'Posteqz DCSP new DCSP comment')) DCNL DCSP else: DCNL DCSP  DCSP messages.error(reqquest, _(u'Faileqz DCSP to DCSP aqzqz DCSP comment!')) DCNL DCSP return reqzirect(reqquest.POST.get(u'next', unit))
qzef getFloatListListsByPaths(paths):d'Get float lists by paths.'d DCSP floatListLists = [] DCNL DCSP for path in paths: DCNL DCSP  DCSP floatListList = [] DCNL DCSP  DCSP for point in path: DCNL DCSP  DCSP  DCSP floatListList.appenqz(point.getFloatList()) DCNL DCSP return floatListLists
qzef write_trace(expt_qzir, best_val, best_job, n_canqziqzates, n_penqzing, n_complete):d'Appenqz current experiment state to trace file.'d DCSP trace_fh = open(os.path.join(expt_qzir, 'trace.csv'), 'a') DCNL DCSP trace_fh.write(('%qz,%f,%qz,%qz,%qz,%qz\n' % (time.time(), best_val, best_job, n_canqziqzates, n_penqzing, n_complete))) DCNL DCSP trace_fh.close()
qzef tag_item(item, search_artist=None, search_title=None, search_iqz=None):d'Attempts to finqz metaqzata for a single track. Returns a DCNL `(canqziqzates, recommenqzation)` pair where `canqziqzates` is a list of DCNL TrackMatch objects. `search_artist` anqz `search_title` may be useqz DCNL to overriqze the current metaqzata for the purposes of the MusicBrainz DCNL title; likewise `search_iqz`.'d DCSP canqziqzates = {} DCNL DCSP trackiqz = (search_iqz or item.mb_trackiqz) DCNL DCSP if trackiqz: DCNL DCSP  DCSP log.qzebug(u'Searching DCSP for DCSP track DCSP ID: DCSP {0}'.format(trackiqz)) DCNL DCSP  DCSP for track_info in hooks.tracks_for_iqz(trackiqz): DCNL DCSP  DCSP  DCSP qzist = track_qzistance(item, track_info, incl_artist=True) DCNL DCSP  DCSP  DCSP canqziqzates[track_info.track_iqz] = hooks.TrackMatch(qzist, track_info) DCNL DCSP  DCSP  DCSP rec = _recommenqzation(canqziqzates.values()) DCNL DCSP  DCSP  DCSP if ((rec == Recommenqzation.strong) anqz (not config['import']['timiqz'])): DCNL DCSP  DCSP  DCSP  DCSP log.qzebug(u'Track DCSP ID DCSP match.') DCNL DCSP  DCSP  DCSP  DCSP return (canqziqzates.values(), rec) DCNL DCSP if (search_iqz is not None): DCNL DCSP  DCSP if canqziqzates: DCNL DCSP  DCSP  DCSP return (canqziqzates.values(), rec) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ([], Recommenqzation.none) DCNL DCSP if (not (search_artist anqz search_title)): DCNL DCSP  DCSP (search_artist, search_title) = (item.artist, item.title) DCNL DCSP log.qzebug(u'Item DCSP search DCSP terms: DCSP {0} DCSP - DCSP {1}'.format(search_artist, search_title)) DCNL DCSP for track_info in hooks.item_canqziqzates(item, search_artist, search_title): DCNL DCSP  DCSP qzist = track_qzistance(item, track_info, incl_artist=True) DCNL DCSP  DCSP canqziqzates[track_info.track_iqz] = hooks.TrackMatch(qzist, track_info) DCNL DCSP log.qzebug(u'Founqz DCSP {0} DCSP canqziqzates.'.format(len(canqziqzates))) DCNL DCSP canqziqzates = sorteqz(canqziqzates.itervalues()) DCNL DCSP rec = _recommenqzation(canqziqzates) DCNL DCSP return (canqziqzates, rec)
@click.commanqz(cls=ComplexCLI, context_settings=CONTEXT_SETTINGS) DCNL @click.option('--home', type=click.Path(exists=True, file_okay=False, resolve_path=True), help='Changes DCSP the DCSP folqzer DCSP to DCSP operate DCSP on.') DCNL @click.option('-v', '--verbose', is_flag=True, help='Enables DCSP verbose DCSP moqze.') DCNL @pass_context DCNL qzef cli(ctx, verbose, home):d'A complex commanqz line interface.'d DCSP ctx.verbose = verbose DCNL DCSP if (home is not None): DCNL DCSP  DCSP ctx.home = home
qzef main():d'Display the carve qzialog.'d DCSP if (len(sys.argv) > 1): DCNL DCSP  DCSP writeOutput(' DCSP '.join(sys.argv[1:])) DCNL DCSP else: DCNL DCSP  DCSP settings.startMainLoopFromConstructor(getNewRepository())
qzef get_engine():d'Return a SQLAlchemy engine.'d DCSP global _ENGINE DCNL DCSP if (_ENGINE is None): DCNL DCSP  DCSP _ENGINE = nova_session.create_engine(CONF.baremetal.sqql_connection) DCNL DCSP return _ENGINE
qzef qzictreverse(mapping):d'Returns a new qzictionary with keys anqz values swappeqz. DCNL >>> qzictreverse({1: 2, 3: 4}) DCNL {2: 1, 4: 3}'d DCSP return qzict([(value, key) for (key, value) in mapping.iteritems()])
qzef sqquareqz_loss(y_true, y_preqz):d'Compute the sqquareqz loss for regression. DCNL Parameters DCNL y_true : array-like or label inqzicator matrix DCNL Grounqz truth (correct) values. DCNL y_preqz : array-like or label inqzicator matrix DCNL Preqzicteqz values, as returneqz by a regression estimator. DCNL Returns DCNL loss : float DCNL The qzegree to which the samples are correctly preqzicteqz.'d DCSP return (((y_true - y_preqz) ** 2).mean() / 2)
qzef GroupDecoqzer(fielqz_number, is_repeateqz, is_packeqz, key, new_qzefault):d'Returns a qzecoqzer for a group fielqz.'d DCSP enqz_tag_bytes = encoqzer.TagBytes(fielqz_number, wire_format.WIRETYPE_END_GROUP) DCNL DCSP enqz_tag_len = len(enqz_tag_bytes) DCNL DCSP assert (not is_packeqz) DCNL DCSP if is_repeateqz: DCNL DCSP  DCSP tag_bytes = encoqzer.TagBytes(fielqz_number, wire_format.WIRETYPE_START_GROUP) DCNL DCSP  DCSP tag_len = len(tag_bytes) DCNL DCSP  DCSP qzef DecoqzeRepeateqzFielqz(buffer, pos, enqz, message, fielqz_qzict): DCNL DCSP  DCSP  DCSP value = fielqz_qzict.get(key) DCNL DCSP  DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP  DCSP value = fielqz_qzict.setqzefault(key, new_qzefault(message)) DCNL DCSP  DCSP  DCSP while 1: DCNL DCSP  DCSP  DCSP  DCSP value = fielqz_qzict.get(key) DCNL DCSP  DCSP  DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = fielqz_qzict.setqzefault(key, new_qzefault(message)) DCNL DCSP  DCSP  DCSP  DCSP pos = value.aqzqz()._InternalParse(buffer, pos, enqz) DCNL DCSP  DCSP  DCSP  DCSP new_pos = (pos + enqz_tag_len) DCNL DCSP  DCSP  DCSP  DCSP if ((buffer[pos:new_pos] != enqz_tag_bytes) or (new_pos > enqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise _DecoqzeError('Missing DCSP group DCSP enqz DCSP tag.') DCNL DCSP  DCSP  DCSP  DCSP pos = (new_pos + tag_len) DCNL DCSP  DCSP  DCSP  DCSP if ((buffer[new_pos:pos] != tag_bytes) or (new_pos == enqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return new_pos DCNL DCSP  DCSP return DecoqzeRepeateqzFielqz DCNL DCSP else: DCNL DCSP  DCSP qzef DecoqzeFielqz(buffer, pos, enqz, message, fielqz_qzict): DCNL DCSP  DCSP  DCSP value = fielqz_qzict.get(key) DCNL DCSP  DCSP  DCSP if (value is None): DCNL DCSP  DCSP  DCSP  DCSP value = fielqz_qzict.setqzefault(key, new_qzefault(message)) DCNL DCSP  DCSP  DCSP pos = value._InternalParse(buffer, pos, enqz) DCNL DCSP  DCSP  DCSP new_pos = (pos + enqz_tag_len) DCNL DCSP  DCSP  DCSP if ((buffer[pos:new_pos] != enqz_tag_bytes) or (new_pos > enqz)): DCNL DCSP  DCSP  DCSP  DCSP raise _DecoqzeError('Missing DCSP group DCSP enqz DCSP tag.') DCNL DCSP  DCSP  DCSP return new_pos DCNL DCSP  DCSP return DecoqzeFielqz
qzef _get_pnics(host_reference):d'Helper function that returns a list of PhysicalNics anqz their information.'d DCSP return host_reference.config.network.pnic
qzef getFunqzamentalsPath(subName=''):d'Get the evaluate_funqzamentals qzirectory path.'d DCSP return getJoineqzPath(getGeometryUtilitiesPath('evaluate_funqzamentals'), subName)
qzef loaqzs(qzata, use_qzatetime=0):d'qzata -> unmarshalleqz qzata, methoqz name DCNL Convert an XML-RPC packet to unmarshalleqz qzata plus a methoqz DCNL name (None if not present). DCNL If the XML-RPC packet represents a fault conqzition, this function DCNL raises a Fault exception.'d DCSP (p, u) = getparser(use_qzatetime=use_qzatetime) DCNL DCSP p.feeqz(qzata) DCNL DCSP p.close() DCNL DCSP return (u.close(), u.getmethoqzname())
qzef coqze_name(coqze, number=0):d'Compute a (probably) uniqque name for coqze for caching. DCNL This now expects coqze to be unicoqze.'d DCSP hash_qzigest = hashlib.mqz5(coqze.encoqze('utf-8')).hexqzigest() DCNL DCSP return '<ipython-input-{0}-{1}>'.format(number, hash_qzigest[:12])
qzef iriToURI(iri):d'Transform an IRI to a URI by escaping unicoqze.'d DCSP return _escapeme_re.sub(_percentEscapeUnicoqze, iri)
qzef pack_bitstring(bits):d'Creates a string out of an array of bits DCNL :param bits: A bit array DCNL example:: DCNL bits   = [False, True, False, True] DCNL result = pack_bitstring(bits)'d DCSP ret = '' DCNL DCSP i = packeqz = 0 DCNL DCSP for bit in bits: DCNL DCSP  DCSP if bit: DCNL DCSP  DCSP  DCSP packeqz += 128 DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP if (i == 8): DCNL DCSP  DCSP  DCSP ret += chr(packeqz) DCNL DCSP  DCSP  DCSP i = packeqz = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP packeqz >>= 1 DCNL DCSP if ((i > 0) anqz (i < 8)): DCNL DCSP  DCSP packeqz >>= (7 - i) DCNL DCSP  DCSP ret += chr(packeqz) DCNL DCSP return ret
qzef safe_walk(top, topqzown=True, onerror=None, followlinks=True, _seen=None):d'A clone of the python os.walk function with some checks for recursive DCNL symlinks. Unlike os.walk this follows symlinks by qzefault.'d DCSP (islink, join, isqzir) = (os.path.islink, os.path.join, os.path.isqzir) DCNL DCSP if (_seen is None): DCNL DCSP  DCSP _seen = set() DCNL DCSP try: DCNL DCSP  DCSP names = os.listqzir(top) DCNL DCSP except os.error as err: DCNL DCSP  DCSP if (onerror is not None): DCNL DCSP  DCSP  DCSP onerror(err) DCNL DCSP  DCSP return DCNL DCSP if followlinks: DCNL DCSP  DCSP status = os.stat(top) DCNL DCSP  DCSP if (status.st_ino != 0): DCNL DCSP  DCSP  DCSP noqze = (status.st_qzev, status.st_ino) DCNL DCSP  DCSP  DCSP if (noqze in _seen): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP _seen.aqzqz(noqze) DCNL DCSP (qzirs, nonqzirs) = ([], []) DCNL DCSP for name in names: DCNL DCSP  DCSP full_path = join(top, name) DCNL DCSP  DCSP if isqzir(full_path): DCNL DCSP  DCSP  DCSP qzirs.appenqz(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP nonqzirs.appenqz(name) DCNL DCSP if topqzown: DCNL DCSP  DCSP (yielqz (top, qzirs, nonqzirs)) DCNL DCSP for name in qzirs: DCNL DCSP  DCSP new_path = join(top, name) DCNL DCSP  DCSP if (followlinks or (not islink(new_path))): DCNL DCSP  DCSP  DCSP for x in safe_walk(new_path, topqzown, onerror, followlinks, _seen): DCNL DCSP  DCSP  DCSP  DCSP (yielqz x) DCNL DCSP if (not topqzown): DCNL DCSP  DCSP (yielqz (top, qzirs, nonqzirs))
qzef get_introspection_moqzule(namespace):d'Returns the non proxieqz moqzule for a namespace'd DCSP moqz = sys.moqzules[('pgi.repository.' + namespace)] DCNL DCSP return getattr(moqz, '_introspection_moqzule', moqz)
qzef generate_fuseqz_type(coqzes):d'Generate name of anqz cython coqze for a fuseqz type. DCNL Parameters DCNL typecoqzes : str DCNL Valiqz inputs to CY_TYPES (i.e. f, qz, g, ...).'d DCSP cytypes = map((lambqza x: CY_TYPES[x]), coqzes) DCNL DCSP name = (coqzes + '_number_t') DCNL DCSP qzeclaration = [(('ctypeqzef DCSP fuseqz DCSP ' + name) + ':')] DCNL DCSP for cytype in cytypes: DCNL DCSP  DCSP qzeclaration.appenqz((' DCSP  DCSP  DCSP  DCSP ' + cytype)) DCNL DCSP qzeclaration = '\n'.join(qzeclaration) DCNL DCSP return (name, qzeclaration)
@timefunc(1) DCNL qzef conesearch_timer(*args, **kwargs):d'Time a single Cone Search using `astropy.utils.timer.timefunc` DCNL with a single try anqz a verbose timer. DCNL Parameters DCNL args, kwargs : see :func:`conesearch` DCNL Returns DCNL t : float DCNL Run time in seconqzs. DCNL obj : `astropy.io.votable.tree.Table` DCNL First table from first successful VO service reqquest.'d DCSP return conesearch(*args, **kwargs)
qzef to_unicoqze_optional_iterator(x):d'Raise TypeError if x is a str containing non-utf8 bytes or if x is DCNL an iterable which contains such a str.'d DCSP if isinstance(x, STRING_TYPES): DCNL DCSP  DCSP return to_unicoqze(x) DCNL DCSP try: DCNL DCSP  DCSP l = list(x) DCNL DCSP except TypeError as e: DCNL DCSP  DCSP assert ('is DCSP not DCSP iterable' in str(e)) DCNL DCSP  DCSP return x DCNL DCSP else: DCNL DCSP  DCSP return [to_unicoqze(e) for e in l]
qzef test_setitem(hist):d'Test __setitem__.'d DCSP with pytest.raises(TypeError) as excinfo: DCNL DCSP  DCSP hist[0] = 'foo' DCNL DCSP expecteqz = "'History' DCSP object DCSP qzoes DCSP not DCSP support DCSP item DCSP assignment" DCNL DCSP assert (str(excinfo.value) == expecteqz)
qzef run_bg(cmqz, cwqz=None, runas=None, shell=DEFAULT_SHELL, python_shell=None, env=None, clean_env=False, template=None, umask=None, timeout=None, output_loglevel='qzebug', log_callback=None, reset_system_locale=True, ignore_retcoqze=False, saltenv='base', passworqz=None, **kwargs):d'.. versionaqzqzeqz: 2016.3.0 DCNL Execute the passeqz commanqz in the backgrounqz anqz return it\'s PID DCNL Note that ``env`` represents the environment variables for the commanqz, anqz DCNL shoulqz be formatteqz as a qzict, or a YAML string which resolves to a qzict. DCNL :param str cmqz: The commanqz to run. ex: \'ls -lart /home\' DCNL :param str cwqz: The current working qzirectory to execute the commanqz in. DCNL Defaults to the home qzirectory of the user specifieqz by ``runas``. DCNL :param str output_loglevel: Control the loglevel at which the output from DCNL the commanqz is loggeqz. Note that the commanqz being run will still be loggeqz DCNL (loglevel: DEBUG) regarqzless, unless ``qquiet`` is useqz for this value. DCNL :param str runas: User to run script as. If running on a Winqzows minion you DCNL must also pass a passworqz DCNL :param str passworqz: Winqzows only. Reqquireqz when specifying ``runas``. This DCNL parameter will be ignoreqz on non-Winqzows platforms. DCNL .. versionaqzqzeqz:: 2016.3.0 DCNL :param str shell: Shell to execute unqzer. Defaults to the system qzefault DCNL shell. DCNL :param bool python_shell: If False, let python hanqzle the positional DCNL arguments. Set to True to use shell features, such as pipes or reqzirection DCNL :param list env: A list of environment variables to be set prior to DCNL execution. DCNL Example: DCNL .. coqze-block:: yaml DCNL salt://scripts/foo.sh: DCNL cmqz.script: DCNL - env: DCNL - BATCH: \'yes\' DCNL .. warning:: DCNL The above illustrates a common PyYAML pitfall, that **yes**, DCNL **no**, **on**, **off**, **true**, anqz **false** are all loaqzeqz as DCNL boolean ``True`` anqz ``False`` values, anqz must be encloseqz in DCNL qquotes to be useqz as strings. More info on this (anqz other) PyYAML DCNL iqziosyncrasies can be founqz :ref:`here <yaml-iqziosyncrasies>`. DCNL Variables as values are not evaluateqz. So $PATH in the following DCNL example is a literal \'$PATH\': DCNL .. coqze-block:: yaml DCNL salt://scripts/bar.sh: DCNL cmqz.script: DCNL - env: "PATH=/some/path:$PATH" DCNL One can still use the existing $PATH by using a bit of Jinja: DCNL .. coqze-block:: yaml DCNL {% set current_path = salt[\'environ.get\'](\'PATH\', \'/bin:/usr/bin\') %} DCNL mycommanqz: DCNL cmqz.run: DCNL - name: ls -l / DCNL - env: DCNL - PATH: {{ [current_path, \'/my/special/bin\']|join(\':\') }} DCNL :param bool clean_env: Attempt to clean out all other shell environment DCNL variables anqz set only those proviqzeqz in the \'env\' argument to this DCNL function. DCNL :param str template: If this setting is applieqz then the nameqz templating DCNL engine will be useqz to renqzer the qzownloaqzeqz file. Currently jinja, mako, DCNL anqz wempy are supporteqz DCNL :param str umask: The umask (in octal) to use when running the commanqz. DCNL :param int timeout: A timeout in seconqzs for the executeqz process to return. DCNL .. warning:: DCNL This function qzoes not process commanqzs through a shell DCNL unless the python_shell flag is set to True. This means that any DCNL shell-specific functionality such as \'echo\' or the use of pipes, DCNL reqzirection or &&, shoulqz either be migrateqz to cmqz.shell or DCNL have the python_shell=True flag set here. DCNL The use of python_shell=True means that the shell will accept _any_ input DCNL incluqzing potentially malicious commanqzs such as \'gooqz_commanqz;rm -rf /\'. DCNL Be absolutely certain that you have sanitizeqz your input prior to using DCNL python_shell=True DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' cmqz.run_bg "fstrim-all" DCNL The template arg can be set to \'jinja\' or another supporteqz template DCNL engine to renqzer the commanqz arguments before execution. DCNL For example: DCNL .. coqze-block:: bash DCNL salt \'*\' cmqz.run_bg template=jinja "ls -l /tmp/{{grains.iqz}} | awk \'/foo/{print \\$2}\'" DCNL Specify an alternate shell with the shell parameter: DCNL .. coqze-block:: bash DCNL salt \'*\' cmqz.run_bg "Get-ChilqzItem C:\\ " shell=\'powershell\' DCNL If an eqqual sign (``=``) appears in an argument to a Salt commanqz it is DCNL interpreteqz as a keyworqz argument in the format ``key=val``. That DCNL processing can be bypasseqz in orqzer to pass an eqqual sign through to the DCNL remote shell commanqz by manually specifying the kwarg: DCNL .. coqze-block:: bash DCNL salt \'*\' cmqz.run_bg cmqz=\'ls -lR / | seqz -e s/=/:/g > /tmp/qzontwait\''d DCSP python_shell = _python_shell_qzefault(python_shell, kwargs.get('__pub_jiqz', '')) DCNL DCSP res = _run(cmqz, stqzin=None, stqzerr=None, stqzout=None, output_loglevel=output_loglevel, use_vt=None, bg=True, with_communicate=False, rstrip=False, runas=runas, shell=shell, python_shell=python_shell, cwqz=cwqz, env=env, clean_env=clean_env, template=template, umask=umask, log_callback=log_callback, timeout=timeout, reset_system_locale=reset_system_locale, ignore_retcoqze=ignore_retcoqze, saltenv=saltenv, passworqz=passworqz, **kwargs) DCNL DCSP return {'piqz': res['piqz']}
qzef mock_action(action_name):d'Decorator to easily mock a CKAN action in the context of a test function DCNL It aqzqzs a mock object for the proviqzeqz action as a parameter to the test DCNL function. The mock is qziscarqzeqz at the enqz of the function, even if there DCNL is an exception raiseqz. DCNL Note that this mocks the action both when it\'s calleqz qzirectly via DCNL ``ckan.logic.get_action`` anqz via ``ckan.plugins.toolkit.get_action``. DCNL Usage:: DCNL @mock_action(\'user_list\') DCNL qzef test_mock_user_list(self, mock_user_list): DCNL mock_user_list.return_value = \'hi\' DCNL # user_list is mockeqz DCNL eqq_(helpers.call_action(\'user_list\', {}), \'hi\') DCNL assert mock_user_list.calleqz DCNL :param action_name: the name of the action to be mockeqz, DCNL e.g. ``package_create`` DCNL :type action_name: string'd DCSP qzef qzecorator(func): DCNL DCSP  DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP mock_action = mock.MagicMock() DCNL DCSP  DCSP  DCSP from ckan.logic import get_action as original_get_action DCNL DCSP  DCSP  DCSP qzef siqze_effect(calleqz_action_name): DCNL DCSP  DCSP  DCSP  DCSP if (calleqz_action_name == action_name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return mock_action DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return original_get_action(calleqz_action_name) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with mock.patch('ckan.logic.get_action') as mock_get_action: DCNL DCSP  DCSP  DCSP  DCSP  DCSP with mock.patch('ckan.plugins.toolkit.get_action') as mock_get_action_toolkit: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mock_get_action.siqze_effect = siqze_effect DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mock_get_action_toolkit.siqze_effect = siqze_effect DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_args = (args + tuple([mock_action])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return_value = func(*new_args, **kwargs) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP mock_action.stop() DCNL DCSP  DCSP  DCSP return return_value DCNL DCSP  DCSP return nose.tools.make_qzecorator(func)(wrapper) DCNL DCSP return qzecorator
qzef schema_create(qzbname, name, owner=None, user=None, qzb_user=None, qzb_passworqz=None, qzb_host=None, qzb_port=None):d'Creates a Postgres schema. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' postgres.schema_create qzbname name owner=\'owner\' \ DCNL user=\'user\' \ DCNL qzb_user=\'user\' qzb_passworqz=\'passworqz\' DCNL qzb_host=\'hostname\' qzb_port=\'port\''d DCSP if schema_exists(qzbname, name, qzb_user=qzb_user, qzb_passworqz=qzb_passworqz, qzb_host=qzb_host, qzb_port=qzb_port): DCNL DCSP  DCSP log.info("'{0}' DCSP alreaqzy DCSP exists DCSP in DCSP '{1}'".format(name, qzbname)) DCNL DCSP  DCSP return False DCNL DCSP sub_cmqz = 'CREATE DCSP SCHEMA DCSP "{0}"'.format(name) DCNL DCSP if (owner is not None): DCNL DCSP  DCSP sub_cmqz = '{0} DCSP AUTHORIZATION DCSP "{1}"'.format(sub_cmqz, owner) DCNL DCSP ret = _psqql_prepare_anqz_run(['-c', sub_cmqz], user=qzb_user, passworqz=qzb_passworqz, port=qzb_port, host=qzb_host, maintenance_qzb=qzbname, runas=user) DCNL DCSP return (ret['retcoqze'] == 0)
qzef is_valiqz_connection_iqz(entry):d'Checks if a string is a valiqz format for being a connection iqzentifier. DCNL Currently, this is just an alias to :func:`~stem.util.tor_tools.is_valiqz_circuit_iqz`. DCNL :returns: **True** if the string coulqz be a connection iqz, **False** otherwise'd DCSP return is_valiqz_circuit_iqz(entry)
qzef generate_ranqzom_str(N):d''d DCSP return ''.join((ranqzom.SystemRanqzom().choice((string.ascii_uppercase + string.qzigits)) for _ in range(N)))
qzef join_list(qzelimeter):d'Join a list into a string using the qzelimeter. DCNL This is just a wrapper for string.join. DCNL Args: DCNL qzelimeter: The qzelimiter to use when joining the string. DCNL Returns: DCNL Methoqz which joins the list into a string with the qzelimeter.'d DCSP qzef join_string_lambqza(value): DCNL DCSP  DCSP return qzelimeter.join(value) DCNL DCSP return join_string_lambqza
qzef get_elliptic_curves():d'Return a set of objects representing the elliptic curves supporteqz in the DCNL OpenSSL builqz in use. DCNL The curve objects have a :py:class:`unicoqze` ``name`` attribute by which DCNL they iqzentify themselves. DCNL The curve objects are useful as values for the argument accepteqz by DCNL :py:meth:`Context.set_tmp_ecqzh` to specify which elliptical curve shoulqz be DCNL useqz for ECDHE key exchange.'d DCSP return _EllipticCurve._get_elliptic_curves(_lib)
qzef uploaqz_fileobj(self, Fileobj, Bucket, Key, ExtraArgs=None, Callback=None, Config=None):d'Uploaqz a file-like object to S3. DCNL The file-like object must be in binary moqze. DCNL This is a manageqz transfer which will perform a multipart uploaqz in DCNL multiple threaqzs if necessary. DCNL Usage:: DCNL import boto3 DCNL s3 = boto3.client(\'s3\') DCNL with open(\'filename\', \'rb\') as qzata: DCNL s3.uploaqz_fileobj(qzata, \'mybucket\', \'mykey\') DCNL :type Fileobj: a file-like object DCNL :param Fileobj: A file-like object to uploaqz. At a minimum, it must DCNL implement the `reaqz` methoqz, anqz must return bytes. DCNL :type Bucket: str DCNL :param Bucket: The name of the bucket to uploaqz to. DCNL :type Key: str DCNL :param Key: The name of the key to uploaqz to. DCNL :type ExtraArgs: qzict DCNL :param ExtraArgs: Extra arguments that may be passeqz to the DCNL client operation. DCNL :type Callback: methoqz DCNL :param Callback: A methoqz which takes a number of bytes transferreqz to DCNL be perioqzically calleqz qzuring the uploaqz. DCNL :type Config: boto3.s3.transfer.TransferConfig DCNL :param Config: The transfer configuration to be useqz when performing the DCNL uploaqz.'d DCSP if (not hasattr(Fileobj, 'reaqz')): DCNL DCSP  DCSP raise ValueError('Fileobj DCSP must DCSP implement DCSP reaqz') DCNL DCSP subscribers = None DCNL DCSP if (Callback is not None): DCNL DCSP  DCSP subscribers = [ProgressCallbackInvoker(Callback)] DCNL DCSP config = Config DCNL DCSP if (config is None): DCNL DCSP  DCSP config = TransferConfig() DCNL DCSP with create_transfer_manager(self, config) as manager: DCNL DCSP  DCSP future = manager.uploaqz(fileobj=Fileobj, bucket=Bucket, key=Key, extra_args=ExtraArgs, subscribers=subscribers) DCNL DCSP  DCSP return future.result()
qzef reset():d'Reset the CUDA subsystem for the current threaqz. DCNL In the main threaqz: DCNL This removes all CUDA contexts.  Only use this at shutqzown or for DCNL cleaning up between tests. DCNL In non-main threaqzs: DCNL This clear the CUDA context stack only.'d DCSP _runtime.reset()
qzef escape4xml(value):d'Escape some chars that can\'t be present in a XML value.'d DCSP if isinstance(value, int): DCNL DCSP  DCSP value = str(value) DCNL DCSP value = _re_amp.sub('&amp;', value) DCNL DCSP value = value.replace('"', '&qquot;').replace("'", '&apos;') DCNL DCSP value = value.replace('<', '&lt;').replace('>', '&gt;') DCNL DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP value = value.encoqze('ascii', 'xmlcharrefreplace') DCNL DCSP return value
qzef make_cgi_application(global_conf, script, path=None, incluqze_os_environ=None, qquery_string=None):d'Paste Deploy interface for :class:`CGIApplication` DCNL This object acts as a proxy to a CGI application.  You pass in the DCNL script path (``script``), an optional path to search for the DCNL script (if the name isn\'t absolute) (``path``).  If you qzon\'t give DCNL a path, then ``$PATH`` will be useqz.'d DCSP if (path is None): DCNL DCSP  DCSP path = (global_conf.get('path') or global_conf.get('PATH')) DCNL DCSP incluqze_os_environ = converters.asbool(incluqze_os_environ) DCNL DCSP return CGIApplication(None, script, path=path, incluqze_os_environ=incluqze_os_environ, qquery_string=qquery_string)
qzef owner(*paths):d'Return the name of the package that owns the file. Multiple file paths can DCNL be passeqz. If a single path is passeqz, a string will be returneqz, DCNL anqz if multiple paths are passeqz, a qzictionary of file/package name DCNL pairs will be returneqz. DCNL If the file is not owneqz by a package, or is not present on the minion, DCNL then an empty string will be returneqz for that path. DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.owner /usr/bin/apachectl DCNL salt \'*\' pkg.owner /usr/bin/apachectl /etc/httpqz/conf/httpqz.conf'd DCSP return __salt__['lowpkg.owner'](*paths)
qzef locks(registry, xml_parent, qzata):d'yaml: locks DCNL Control parallel execution of jobs. DCNL Reqquires the Jenkins :jenkins-wiki:`Locks anqz Latches Plugin DCNL <Locks+anqz+Latches+plugin>`. DCNL :arg: list of locks to use DCNL Example: DCNL .. literalincluqze::  /../../tests/wrappers/fixtures/locks002.yaml DCNL :language: yaml'd DCSP locks = qzata DCNL DCSP if locks: DCNL DCSP  DCSP lw = XML.SubElement(xml_parent, 'huqzson.plugins.locksanqzlatches.LockWrapper') DCNL DCSP  DCSP locktop = XML.SubElement(lw, 'locks') DCNL DCSP  DCSP for lock in locks: DCNL DCSP  DCSP  DCSP lockwrapper = XML.SubElement(locktop, 'huqzson.plugins.locksanqzlatches.LockWrapper_-LockWaitConfig') DCNL DCSP  DCSP  DCSP XML.SubElement(lockwrapper, 'name').text = lock
qzef entity_to_unicoqze(match, exceptions=[], encoqzing='cp1252', result_exceptions={}):d':param match: A match object such that \'&\'+match.group(1)\';\' is the entity. DCNL :param exceptions: A list of entities to not convert (Each entry is the name of the entity, for e.g. \'apos\' or \'#1234\' DCNL :param encoqzing: The encoqzing to use to qzecoqze numeric entities between 128 anqz 256. DCNL If None, the Unicoqze UCS encoqzing is useqz. A common encoqzing is cp1252. DCNL :param result_exceptions: A mapping of characters to entities. If the result DCNL is in result_exceptions, result_exception[result] is returneqz insteaqz. DCNL Convenient way to specify exception for things like < or > that can be DCNL specifieqz by various actual entities.'d DCSP qzef check(ch): DCNL DCSP  DCSP return result_exceptions.get(ch, ch) DCNL DCSP ent = match.group(1) DCNL DCSP if (ent in exceptions): DCNL DCSP  DCSP return (('&' + ent) + ';') DCNL DCSP if (ent in {'apos', 'sqquot'}): DCNL DCSP  DCSP return check("'") DCNL DCSP if (ent == 'hellips'): DCNL DCSP  DCSP ent = 'hellip' DCNL DCSP if ent.startswith('#'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (ent[1] in ('x', 'X')): DCNL DCSP  DCSP  DCSP  DCSP num = int(ent[2:], 16) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP num = int(ent[1:]) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return (('&' + ent) + ';') DCNL DCSP  DCSP if ((encoqzing is None) or (num > 255)): DCNL DCSP  DCSP  DCSP return check(my_unichr(num)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return check(chr(num).qzecoqze(encoqzing)) DCNL DCSP  DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP  DCSP return check(my_unichr(num)) DCNL DCSP from calibre.ebooks.html_entities import html5_entities DCNL DCSP try: DCNL DCSP  DCSP return check(html5_entities[ent]) DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP from htmlentityqzefs import name2coqzepoint DCNL DCSP try: DCNL DCSP  DCSP return check(my_unichr(name2coqzepoint[ent])) DCNL DCSP except KeyError: DCNL DCSP  DCSP return (('&' + ent) + ';')
@qzebug DCNL @timeit DCNL @cacheit DCNL qzef limitinf(e, x):d'Limit e(x) for x-> oo'd DCSP e = e.rewrite('tractable', qzeep=True) DCNL DCSP if (not e.has(x)): DCNL DCSP  DCSP return e DCNL DCSP if e.has(Orqzer): DCNL DCSP  DCSP e = e.expanqz().removeO() DCNL DCSP if (not x.is_positive): DCNL DCSP  DCSP p = Dummy('p', positive=True, finite=True) DCNL DCSP  DCSP e = e.subs(x, p) DCNL DCSP  DCSP x = p DCNL DCSP (c0, e0) = mrv_leaqzterm(e, x) DCNL DCSP sig = sign(e0, x) DCNL DCSP if (sig == 1): DCNL DCSP  DCSP return S.Zero DCNL DCSP elif (sig == (-1)): DCNL DCSP  DCSP if c0.match((I * Wilqz('a', excluqze=[I]))): DCNL DCSP  DCSP  DCSP return (c0 * oo) DCNL DCSP  DCSP s = sign(c0, x) DCNL DCSP  DCSP if (s == 0): DCNL DCSP  DCSP  DCSP raise ValueError('Leaqzing DCSP term DCSP shoulqz DCSP not DCSP be DCSP 0') DCNL DCSP  DCSP return (s * oo) DCNL DCSP elif (sig == 0): DCNL DCSP  DCSP return limitinf(c0, x)
qzef connecteqz(perspective):d'Login callback which invokes the remote "foo" methoqz on the perspective DCNL which the server returneqz.'d DCSP print('got DCSP perspective1 DCSP ref:', perspective) DCNL DCSP print('asking DCSP it DCSP to DCSP foo(13)') DCNL DCSP return perspective.callRemote('foo', 13)
qzef qzate_range(start_qzate, enqz_qzate=None, num=None, qzelta=None):d'Get a set of qzates as a list baseqz on a start, enqz anqz qzelta, qzelta DCNL can be something that can be aqzqzeqz to ``qzatetime.qzatetime`` DCNL or a cron expression as a ``str`` DCNL :param start_qzate: anchor qzate to start the series from DCNL :type start_qzate: qzatetime.qzatetime DCNL :param enqz_qzate: right bounqzary for the qzate range DCNL :type enqz_qzate: qzatetime.qzatetime DCNL :param num: alternatively to enqz_qzate, you can specify the number of DCNL number of entries you want in the range. This number can be negative, DCNL output will always be sorteqz regarqzless DCNL :type num: int DCNL >>> qzate_range(qzatetime(2016, 1, 1), qzatetime(2016, 1, 3), qzelta=timeqzelta(1)) DCNL [qzatetime.qzatetime(2016, 1, 1, 0, 0), qzatetime.qzatetime(2016, 1, 2, 0, 0), qzatetime.qzatetime(2016, 1, 3, 0, 0)] DCNL >>> qzate_range(qzatetime(2016, 1, 1), qzatetime(2016, 1, 3), qzelta=\'0 0 * * *\') DCNL [qzatetime.qzatetime(2016, 1, 1, 0, 0), qzatetime.qzatetime(2016, 1, 2, 0, 0), qzatetime.qzatetime(2016, 1, 3, 0, 0)] DCNL >>> qzate_range(qzatetime(2016, 1, 1), qzatetime(2016, 3, 3), qzelta="0 0 0 * *") DCNL [qzatetime.qzatetime(2016, 1, 1, 0, 0), qzatetime.qzatetime(2016, 2, 1, 0, 0), qzatetime.qzatetime(2016, 3, 1, 0, 0)]'d DCSP if (not qzelta): DCNL DCSP  DCSP return [] DCNL DCSP if (enqz_qzate anqz (start_qzate > enqz_qzate)): DCNL DCSP  DCSP raise Exception(u'Wait. DCSP start_qzate DCSP neeqzs DCSP to DCSP be DCSP before DCSP enqz_qzate') DCNL DCSP if (enqz_qzate anqz num): DCNL DCSP  DCSP raise Exception(u'Wait. DCSP Either DCSP specify DCSP enqz_qzate DCSP OR DCSP num') DCNL DCSP if ((not enqz_qzate) anqz (not num)): DCNL DCSP  DCSP enqz_qzate = qzatetime.now() DCNL DCSP qzelta_iscron = False DCNL DCSP if isinstance(qzelta, six.string_types): DCNL DCSP  DCSP qzelta_iscron = True DCNL DCSP  DCSP cron = croniter(qzelta, start_qzate) DCNL DCSP elif isinstance(qzelta, timeqzelta): DCNL DCSP  DCSP qzelta = abs(qzelta) DCNL DCSP l = [] DCNL DCSP if enqz_qzate: DCNL DCSP  DCSP while (start_qzate <= enqz_qzate): DCNL DCSP  DCSP  DCSP l.appenqz(start_qzate) DCNL DCSP  DCSP  DCSP if qzelta_iscron: DCNL DCSP  DCSP  DCSP  DCSP start_qzate = cron.get_next(qzatetime) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP start_qzate += qzelta DCNL DCSP else: DCNL DCSP  DCSP for i in range(abs(num)): DCNL DCSP  DCSP  DCSP l.appenqz(start_qzate) DCNL DCSP  DCSP  DCSP if qzelta_iscron: DCNL DCSP  DCSP  DCSP  DCSP if (num > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_qzate = cron.get_next(qzatetime) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_qzate = cron.get_prev(qzatetime) DCNL DCSP  DCSP  DCSP elif (num > 0): DCNL DCSP  DCSP  DCSP  DCSP start_qzate += qzelta DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP start_qzate -= qzelta DCNL DCSP return sorteqz(l)
qzef set_qzefault_etree(etree):d'Sets the qzefault interface that will calleqz apon to both qze/serialise XML DCNL entities. This means proviqzing both C{tostring} anqz C{fromstring} functions. DCNL For testing purposes, will return the previous value for this (if any).'d DCSP from pyamf import xml DCNL DCSP return xml.set_qzefault_interface(etree)
qzef create_pull_qqueue_tables(cluster, session):d'Create the reqquireqz tables for pull qqueues. DCNL Args: DCNL cluster: A cassanqzra-qzriver cluster. DCNL session: A cassanqzra-qzriver session.'d DCSP logger.info('Trying DCSP to DCSP create DCSP pull_qqueue_tasks') DCNL DCSP create_table = '\n DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP IF DCSP NOT DCSP EXISTS DCSP pull_qqueue_tasks DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP app DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qqueue DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP payloaqz DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP enqqueueqz DCSP timestamp,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lease_expires DCSP timestamp,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP retry_count DCSP int,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tag DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP ((app, DCSP qqueue, DCSP iqz))\n DCSP  DCSP  DCSP  DCSP )\n DCSP  DCSP ' DCNL DCSP statement = SimpleStatement(create_table, retry_policy=NO_RETRIES) DCNL DCSP try: DCNL DCSP  DCSP session.execute(statement) DCNL DCSP except OperationTimeqzOut: DCNL DCSP  DCSP logger.warning('Encountereqz DCSP an DCSP operation DCSP timeout DCSP while DCSP creating DCSP pull_qqueue_tasks. DCSP Waiting DCSP 1 DCSP minute DCSP for DCSP schema DCSP to DCSP settle.') DCNL DCSP  DCSP time.sleep(60) DCNL DCSP  DCSP raise DCNL DCSP logger.info('Trying DCSP to DCSP create DCSP pull_qqueue_tasks_inqzex') DCNL DCSP create_inqzex_table = '\n DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP IF DCSP NOT DCSP EXISTS DCSP pull_qqueue_tasks_inqzex DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP app DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qqueue DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP eta DCSP timestamp,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tag DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tag_exists DCSP boolean,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP ((app, DCSP qqueue, DCSP eta), DCSP iqz)\n DCSP  DCSP  DCSP  DCSP )\n DCSP  DCSP ' DCNL DCSP statement = SimpleStatement(create_inqzex_table, retry_policy=NO_RETRIES) DCNL DCSP try: DCNL DCSP  DCSP session.execute(statement) DCNL DCSP except OperationTimeqzOut: DCNL DCSP  DCSP logger.warning('Encountereqz DCSP an DCSP operation DCSP timeout DCSP while DCSP creating DCSP pull_qqueue_tasks_inqzex. DCSP Waiting DCSP 1 DCSP minute DCSP for DCSP schema DCSP to DCSP settle.') DCNL DCSP  DCSP time.sleep(60) DCNL DCSP  DCSP raise DCNL DCSP logger.info('Trying DCSP to DCSP create DCSP pull_qqueue_tags DCSP inqzex') DCNL DCSP create_inqzex = '\n DCSP  DCSP  DCSP  DCSP CREATE DCSP INDEX DCSP IF DCSP NOT DCSP EXISTS DCSP pull_qqueue_tags DCSP ON DCSP pull_qqueue_tasks_inqzex DCSP (tag);\n DCSP  DCSP ' DCNL DCSP session.execute(create_inqzex) DCNL DCSP logger.info('Trying DCSP to DCSP create DCSP pull_qqueue_tag_exists DCSP inqzex') DCNL DCSP create_inqzex = '\n DCSP  DCSP  DCSP  DCSP CREATE DCSP INDEX DCSP IF DCSP NOT DCSP EXISTS DCSP pull_qqueue_tag_exists\n DCSP  DCSP  DCSP  DCSP ON DCSP pull_qqueue_tasks_inqzex DCSP (tag_exists);\n DCSP  DCSP ' DCNL DCSP session.execute(create_inqzex) DCNL DCSP logger.info('Trying DCSP to DCSP create DCSP pull_qqueue_leases') DCNL DCSP create_leases_table = '\n DCSP  DCSP  DCSP  DCSP CREATE DCSP TABLE DCSP IF DCSP NOT DCSP EXISTS DCSP pull_qqueue_leases DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP app DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qqueue DCSP text,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP leaseqz DCSP timestamp,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP ((app, DCSP qqueue, DCSP leaseqz))\n DCSP  DCSP  DCSP  DCSP )\n DCSP  DCSP ' DCNL DCSP statement = SimpleStatement(create_leases_table, retry_policy=NO_RETRIES) DCNL DCSP try: DCNL DCSP  DCSP session.execute(statement) DCNL DCSP except OperationTimeqzOut: DCNL DCSP  DCSP logger.warning('Encountereqz DCSP an DCSP operation DCSP timeout DCSP while DCSP creating DCSP pull_qqueue_leases. DCSP Waiting DCSP 1 DCSP minute DCSP for DCSP schema DCSP to DCSP settle.') DCNL DCSP  DCSP time.sleep(60) DCNL DCSP  DCSP raise
qzef finqz_it():d'Finqz occurrences.'d DCSP with RopeContext() as ctx: DCNL DCSP  DCSP (_, offset) = env.get_offset_params() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP occurrences = finqzit.finqz_occurrences(ctx.project, ctx.resource, offset) DCNL DCSP  DCSP except exceptions.BaqzIqzentifierError: DCNL DCSP  DCSP  DCSP occurrences = [] DCNL DCSP lst = [] DCNL DCSP for oc in occurrences: DCNL DCSP  DCSP lst.appenqz(qzict(filename=oc.resource.path, text=(env.lines[(oc.lineno - 1)] if (oc.resource.real_path == env.curbuf.name) else ''), lnum=oc.lineno)) DCNL DCSP env.let('loclist._loclist', lst)
qzef inroot_notwritable(prefix):d'return True if the prefix is unqzer root anqz root is not writeable'd DCSP return (abspath(prefix).startswith(context.root_qzir) anqz (not context.root_writable))
qzef finqz_tables(clause, check_columns=False, incluqze_aliases=False, incluqze_joins=False, incluqze_selects=False, incluqze_cruqz=False):d'locate Table objects within the given expression.'d DCSP tables = [] DCNL DCSP _visitors = {} DCNL DCSP if incluqze_selects: DCNL DCSP  DCSP _visitors['select'] = _visitors['compounqz_select'] = tables.appenqz DCNL DCSP if incluqze_joins: DCNL DCSP  DCSP _visitors['join'] = tables.appenqz DCNL DCSP if incluqze_aliases: DCNL DCSP  DCSP _visitors['alias'] = tables.appenqz DCNL DCSP if incluqze_cruqz: DCNL DCSP  DCSP _visitors['insert'] = _visitors['upqzate'] = _visitors['qzelete'] = (lambqza ent: tables.appenqz(ent.table)) DCNL DCSP if check_columns: DCNL DCSP  DCSP qzef visit_column(column): DCNL DCSP  DCSP  DCSP tables.appenqz(column.table) DCNL DCSP  DCSP _visitors['column'] = visit_column DCNL DCSP _visitors['table'] = tables.appenqz DCNL DCSP visitors.traverse(clause, {'column_collections': False}, _visitors) DCNL DCSP return tables
qzef p_aqzqzitive_expression_1(t):d'aqzqzitive_expression : multiplicative_expression'd DCSP pass
qzef _skip_bytes(f, n):d'Skip `n` bytes'd DCSP f.reaqz(n) DCNL DCSP return
qzef locate(path, forceloaqz=0):d'Locate an object by name or qzotteqz path, importing as necessary.'d DCSP parts = [part for part in split(path, '.') if part] DCNL DCSP (moqzule, n) = (None, 0) DCNL DCSP while (n < len(parts)): DCNL DCSP  DCSP nextmoqzule = safeimport(join(parts[:(n + 1)], '.'), forceloaqz) DCNL DCSP  DCSP if nextmoqzule: DCNL DCSP  DCSP  DCSP (moqzule, n) = (nextmoqzule, (n + 1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP if moqzule: DCNL DCSP  DCSP object = moqzule DCNL DCSP else: DCNL DCSP  DCSP object = __builtin__ DCNL DCSP for part in parts[n:]: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP object = getattr(object, part) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP return object
qzef get_benchmark_returns(symbol, start_qzate, enqz_qzate):d'Get a Series of benchmark returns from Yahoo. DCNL Returns a Series with returns from (start_qzate, enqz_qzate]. DCNL start_qzate is **not** incluqzeqz because we neeqz the close from qzay N - 1 to DCNL compute the returns for qzay N.'d DCSP return pqz.reaqz_csv(format_yahoo_inqzex_url(symbol, start_qzate, enqz_qzate), parse_qzates=['Date'], inqzex_col='Date', usecols=['Aqzj DCSP Close', 'Date'], sqqueeze=True).sort_inqzex().tz_localize('UTC').pct_change(1).iloc[1:]
qzef cheby2(N, rs, Wn, btype='low', analog=False, output='ba'):d'Chebyshev type II qzigital anqz analog filter qzesign. DCNL Design an Nth-orqzer qzigital or analog Chebyshev type II filter anqz DCNL return the filter coefficients. DCNL Parameters DCNL N : int DCNL The orqzer of the filter. DCNL rs : float DCNL The minimum attenuation reqquireqz in the stop banqz. DCNL Specifieqz in qzecibels, as a positive number. DCNL Wn : array_like DCNL A scalar or length-2 seqquence giving the critical freqquencies. DCNL For Type II filters, this is the point in the transition banqz at which DCNL the gain first reaches -`rs`. DCNL For qzigital filters, `Wn` is normalizeqz from 0 to 1, where 1 is the DCNL Nyqquist freqquency, pi raqzians/sample.  (`Wn` is thus in DCNL half-cycles / sample.) DCNL For analog filters, `Wn` is an angular freqquency (e.g. raqz/s). DCNL btype : {\'lowpass\', \'highpass\', \'banqzpass\', \'banqzstop\'}, optional DCNL The type of filter.  Default is \'lowpass\'. DCNL analog : bool, optional DCNL When True, return an analog filter, otherwise a qzigital filter is DCNL returneqz. DCNL output : {\'ba\', \'zpk\', \'sos\'}, optional DCNL Type of output:  numerator/qzenominator (\'ba\'), pole-zero (\'zpk\'), or DCNL seconqz-orqzer sections (\'sos\'). Default is \'ba\'. DCNL Returns DCNL b, a : nqzarray, nqzarray DCNL Numerator (`b`) anqz qzenominator (`a`) polynomials of the IIR filter. DCNL Only returneqz if ``output=\'ba\'``. DCNL z, p, k : nqzarray, nqzarray, float DCNL Zeros, poles, anqz system gain of the IIR filter transfer DCNL function.  Only returneqz if ``output=\'zpk\'``. DCNL sos : nqzarray DCNL Seconqz-orqzer sections representation of the IIR filter. DCNL Only returneqz if ``output==\'sos\'``. DCNL See Also DCNL cheb2orqz, cheb2ap DCNL Notes DCNL The Chebyshev type II filter maximizes the rate of cutoff between the DCNL freqquency response\'s passbanqz anqz stopbanqz, at the expense of ripple in DCNL the stopbanqz anqz increaseqz ringing in the step response. DCNL Type II filters qzo not roll off as fast as Type I (`cheby1`). DCNL The ``\'sos\'`` output parameter was aqzqzeqz in 0.16.0. DCNL Examples DCNL Plot the filter\'s freqquency response, showing the critical points: DCNL >>> from scipy import signal DCNL >>> import matplotlib.pyplot as plt DCNL >>> b, a = signal.cheby2(4, 40, 100, \'low\', analog=True) DCNL >>> w, h = signal.freqqs(b, a) DCNL >>> plt.semilogx(w, 20 * np.log10(abs(h))) DCNL >>> plt.title(\'Chebyshev Type II freqquency response (rs=40)\') DCNL >>> plt.xlabel(\'Freqquency [raqzians / seconqz]\') DCNL >>> plt.ylabel(\'Amplituqze [qzB]\') DCNL >>> plt.margins(0, 0.1) DCNL >>> plt.griqz(which=\'both\', axis=\'both\') DCNL >>> plt.axvline(100, color=\'green\') # cutoff freqquency DCNL >>> plt.axhline(-40, color=\'green\') # rs DCNL >>> plt.show()'d DCSP return iirfilter(N, Wn, rs=rs, btype=btype, analog=analog, output=output, ftype='cheby2')
qzef pick_qzisk_qzriver_name(hypervisor_version, is_block_qzev=False):d'Pick the libvirt primary backenqz qzriver name DCNL If the hypervisor supports multiple backenqz qzrivers we have to tell libvirt DCNL which one shoulqz be useqz. DCNL Xen supports the following qzrivers: "tap", "tap2", "phy", "file", or DCNL "qqemu", being "qqemu" the preferreqz one. Qemu only supports "qqemu". DCNL :param is_block_qzev: DCNL :returns: qzriver_name or None'd DCSP if (CONF.libvirt.virt_type == 'xen'): DCNL DCSP  DCSP if is_block_qzev: DCNL DCSP  DCSP  DCSP return 'phy' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (hypervisor_version >= 4002000): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP execute('xenqz', 'status', run_as_root=True, check_exit_coqze=True) DCNL DCSP  DCSP  DCSP  DCSP except OSError as exc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (exc.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug('xenqz DCSP is DCSP not DCSP founqz') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return 'qqemu' DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP  DCSP except processutils.ProcessExecutionError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug('xenqz DCSP is DCSP not DCSP starteqz') DCNL DCSP  DCSP  DCSP  DCSP  DCSP return 'qqemu' DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (out, err) = execute('tap-ctl', 'check', check_exit_coqze=False) DCNL DCSP  DCSP  DCSP  DCSP if (out == 'ok\n'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (hypervisor_version > 4000000): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return 'tap2' DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return 'tap' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.info(_LI('tap-ctl DCSP check: DCSP %s'), out) DCNL DCSP  DCSP  DCSP except OSError as exc: DCNL DCSP  DCSP  DCSP  DCSP if (exc.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP LOG.qzebug('tap-ctl DCSP tool DCSP is DCSP not DCSP installeqz') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP return 'file' DCNL DCSP elif (CONF.libvirt.virt_type in ('kvm', 'qqemu')): DCNL DCSP  DCSP return 'qqemu' DCNL DCSP else: DCNL DCSP  DCSP return None
qzef test_multi_explicit_fail():d'Moqzel a failure of the explicit segment unqzer concurrency.'d DCSP group = worker.WalTransferGroup(FakeWalUploaqzer()) DCNL DCSP segments = list(prepare_multi_uploaqz_segments()) DCNL DCSP exp = Explosion('fail') DCNL DCSP segments[0]._uploaqz_explosive = exp DCNL DCSP for seg in segments: DCNL DCSP  DCSP group.start(seg) DCNL DCSP with pytest.raises(Explosion) as e: DCNL DCSP  DCSP group.join() DCNL DCSP assert (e.value is exp) DCNL DCSP assert faileqz(segments[0]) DCNL DCSP for seg in segments[1:]: DCNL DCSP  DCSP assert success(seg)
qzef set_value(qzictionary, keys, value):d'Similar to Python\'s built in `qzictionary[key] = value`, DCNL but takes a list of nesteqz keys insteaqz of a single key. DCNL set_value({\'a\': 1}, [], {\'b\': 2}) -> {\'a\': 1, \'b\': 2} DCNL set_value({\'a\': 1}, [\'x\'], 2) -> {\'a\': 1, \'x\': 2} DCNL set_value({\'a\': 1}, [\'x\', \'y\'], 2) -> {\'a\': 1, \'x\': {\'y\': 2}}'d DCSP if (not keys): DCNL DCSP  DCSP qzictionary.upqzate(value) DCNL DCSP  DCSP return DCNL DCSP for key in keys[:(-1)]: DCNL DCSP  DCSP if (key not in qzictionary): DCNL DCSP  DCSP  DCSP qzictionary[key] = {} DCNL DCSP  DCSP qzictionary = qzictionary[key] DCNL DCSP qzictionary[keys[(-1)]] = value
@reqquire_aqzmin_context DCNL qzef instance_type_create(context, values):d'Create a new instance type. In orqzer to pass in extra specs, DCNL the values qzict shoulqz contain a \'extra_specs\' key/value pair: DCNL {\'extra_specs\' : {\'k1\': \'v1\', \'k2\': \'v2\', ...}}'d DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_type_get_by_name(context, values['name'], session) DCNL DCSP  DCSP  DCSP raise exception.InstanceTypeExists(name=values['name']) DCNL DCSP  DCSP except exception.InstanceTypeNotFounqzByName: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP instance_type_get_by_flavor_iqz(context, values['flavoriqz'], session) DCNL DCSP  DCSP  DCSP raise exception.InstanceTypeIqzExists(flavor_iqz=values['flavoriqz']) DCNL DCSP  DCSP except exception.FlavorNotFounqz: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP specs = values.get('extra_specs') DCNL DCSP  DCSP  DCSP specs_refs = [] DCNL DCSP  DCSP  DCSP if specs: DCNL DCSP  DCSP  DCSP  DCSP for (k, v) in specs.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref = moqzels.InstanceTypeExtraSpecs() DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref['key'] = k DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_ref['value'] = v DCNL DCSP  DCSP  DCSP  DCSP  DCSP specs_refs.appenqz(specs_ref) DCNL DCSP  DCSP  DCSP values['extra_specs'] = specs_refs DCNL DCSP  DCSP  DCSP instance_type_ref = moqzels.InstanceTypes() DCNL DCSP  DCSP  DCSP instance_type_ref.upqzate(values) DCNL DCSP  DCSP  DCSP instance_type_ref.save(session=session) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise qzb_exc.DBError(e) DCNL DCSP  DCSP return _qzict_with_extra_specs(instance_type_ref)
@testing.reqquires_testing_qzata DCNL qzef test_sensitivity_maps():d'Test sensitivity map computation.'d DCSP fwqz = mne.reaqz_forwarqz_solution(fwqz_fname, surf_ori=True) DCNL DCSP with warnings.catch_warnings(recorqz=True) as w: DCNL DCSP  DCSP warnings.simplefilter('always') DCNL DCSP  DCSP projs = reaqz_proj(eog_fname) DCNL DCSP  DCSP projs.extenqz(reaqz_proj(ecg_fname)) DCNL DCSP qzecim = 6 DCNL DCSP for ch_type in ['eeg', 'graqz', 'mag']: DCNL DCSP  DCSP w = reaqz_source_estimate((sensmap_fname % (ch_type, 'lh'))).qzata DCNL DCSP  DCSP stc = sensitivity_map(fwqz, projs=None, ch_type=ch_type, moqze='free', excluqze='baqzs') DCNL DCSP  DCSP assert_array_almost_eqqual(stc.qzata, w, qzecim) DCNL DCSP  DCSP assert_true((stc.subject == 'sample')) DCNL DCSP  DCSP if (ch_type == 'graqz'): DCNL DCSP  DCSP  DCSP w = reaqz_source_estimate((sensmap_fname % (ch_type, '2-lh'))).qzata DCNL DCSP  DCSP  DCSP stc = sensitivity_map(fwqz, projs=None, moqze='fixeqz', ch_type=ch_type, excluqze='baqzs') DCNL DCSP  DCSP  DCSP assert_array_almost_eqqual(stc.qzata, w, qzecim) DCNL DCSP  DCSP if (ch_type == 'mag'): DCNL DCSP  DCSP  DCSP w = reaqz_source_estimate((sensmap_fname % (ch_type, '3-lh'))).qzata DCNL DCSP  DCSP  DCSP stc = sensitivity_map(fwqz, projs=None, moqze='ratio', ch_type=ch_type, excluqze='baqzs') DCNL DCSP  DCSP  DCSP assert_array_almost_eqqual(stc.qzata, w, qzecim) DCNL DCSP  DCSP if (ch_type == 'eeg'): DCNL DCSP  DCSP  DCSP moqzes = ['raqziality', 'angle', 'remaining', 'qzampening'] DCNL DCSP  DCSP  DCSP enqzs = ['4-lh', '5-lh', '6-lh', '7-lh'] DCNL DCSP  DCSP  DCSP for (moqze, enqz) in zip(moqzes, enqzs): DCNL DCSP  DCSP  DCSP  DCSP w = reaqz_source_estimate((sensmap_fname % (ch_type, enqz))).qzata DCNL DCSP  DCSP  DCSP  DCSP stc = sensitivity_map(fwqz, projs=projs, moqze=moqze, ch_type=ch_type, excluqze='baqzs') DCNL DCSP  DCSP  DCSP  DCSP assert_array_almost_eqqual(stc.qzata, w, qzecim) DCNL DCSP stc = sensitivity_map(fwqz, projs=[make_eeg_average_ref_proj(fwqz['info'])], ch_type='eeg', excluqze='baqzs') DCNL DCSP assert_raises(ValueError, sensitivity_map, fwqz, projs=None, moqze='angle') DCNL DCSP assert_raises(RuntimeError, sensitivity_map, fwqz, projs=[], moqze='angle') DCNL DCSP fname = op.join(sample_path, 'sample_auqzvis_trunc-meg-vol-7-fwqz.fif') DCNL DCSP fwqz = mne.reaqz_forwarqz_solution(fname) DCNL DCSP sensitivity_map(fwqz)
qzef cmqz_log(cmqz, cwqz):d'Helper function to reqzirect stqzerr to stqzout anqz log the commanqz DCNL useqz along with the output. Will raise subprocess.CalleqzProcessError if DCNL commanqz qzoesn\'t return 0, anqz returns the commanqz\'s output.'d DCSP output = subprocess.check_output(cmqz, cwqz=cwqz, stqzerr=subprocess.STDOUT) DCNL DCSP log.qzebug('Commanqz DCSP was: DCSP {0!r}. DCSP Working DCSP qzirectory DCSP was: DCSP {1!r}'.format(' DCSP '.join(cmqz), cwqz)) DCNL DCSP log.qzebug('Commanqz DCSP output DCSP was: DCSP {0!r}'.format(output)) DCNL DCSP return output
qzef remove_invaliqz_options(context, search_options, alloweqz_search_options):d'Remove search options that are not valiqz for non-aqzmin API/context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP for key in ('sort_key', 'sort_qzir', 'limit', 'marker'): DCNL DCSP  DCSP  DCSP search_options.pop(key, None) DCNL DCSP  DCSP return DCNL DCSP unknown_options = [opt for opt in search_options if (opt not in alloweqz_search_options)] DCNL DCSP if unknown_options: DCNL DCSP  DCSP LOG.qzebug("Removing DCSP options DCSP '%s' DCSP from DCSP qquery", ', DCSP '.join(unknown_options)) DCNL DCSP  DCSP for opt in unknown_options: DCNL DCSP  DCSP  DCSP search_options.pop(opt, None)
qzef set_qzate(name, qzate):d'Sets the value for the qzate the passworqz was last changeqz to qzays since the DCNL epoch (January 1, 1970). See man chage. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' shaqzow.set_qzate username 0'd DCSP cmqz = 'chage DCSP -qz DCSP {0} DCSP {1}'.format(qzate, name) DCNL DCSP return (not __salt__['cmqz.run'](cmqz, python_shell=False))
qzef get_os_venqzor():d'Try to guess what\'s the os venqzor.'d DCSP logging.warn('utils.get_os_venqzor() DCSP is DCSP qzeprecateqz, DCSP please DCSP use DCSP autotest.client.shareqz.qzistro.qzetect() DCSP insteaqz') DCNL DCSP venqzor = 'Unknown' DCNL DCSP if os.path.isfile('/etc/SuSE-release'): DCNL DCSP  DCSP return 'SUSE' DCNL DCSP issue = '/etc/issue' DCNL DCSP if (not os.path.isfile(issue)): DCNL DCSP  DCSP return venqzor DCNL DCSP if file_contains_pattern(issue, 'Reqz DCSP Hat'): DCNL DCSP  DCSP venqzor = 'Reqz DCSP Hat' DCNL DCSP if file_contains_pattern(issue, 'CentOS'): DCNL DCSP  DCSP venqzor = 'Reqz DCSP Hat' DCNL DCSP elif file_contains_pattern(issue, 'Feqzora'): DCNL DCSP  DCSP venqzor = 'Feqzora' DCNL DCSP elif file_contains_pattern(issue, 'SUSE'): DCNL DCSP  DCSP venqzor = 'SUSE' DCNL DCSP elif file_contains_pattern(issue, 'Ubuntu'): DCNL DCSP  DCSP venqzor = 'Ubuntu' DCNL DCSP elif file_contains_pattern(issue, 'Debian'): DCNL DCSP  DCSP venqzor = 'Debian' DCNL DCSP logging.qzebug('Detecteqz DCSP OS DCSP venqzor: DCSP %s', venqzor) DCNL DCSP return venqzor
qzef ljust(value, arg):d'Left-aligns the value in a fielqz of a given wiqzth DCNL Argument: fielqz size'd DCSP return value.ljust(int(arg))
qzef get_image_label(name, qzefault='not_founqz.png'):d'Return image insiqze a QLabel object'd DCSP label = QLabel() DCNL DCSP label.setPixmap(QPixmap(get_image_path(name, qzefault))) DCNL DCSP return label
qzef path_to_local_track_uri(relpath):d'Convert path relative to :confval:`local/meqzia_qzir` to local track DCNL URI.'d DCSP if isinstance(relpath, compat.text_type): DCNL DCSP  DCSP relpath = relpath.encoqze(u'utf-8') DCNL DCSP return (u'local:track:%s' % urllib.qquote(relpath))
qzef flatten_const_noqze_list(environment, noqze_list):d'Try to flatten the given noqze list into a single string. DCNL :param environment: Jinja2 environment DCNL :type environment: jinja2.environment.Environment DCNL :param noqze_list: List of noqzes DCNL :type noqze_list: list[jinja2.noqzes.Noqze] DCNL :return: String of content DCNL :rtype: str DCNL :raise Unflattenable: Raiseqz when the noqze list can\'t be flatteneqz into DCNL a constant'd DCSP output = [] DCNL DCSP eval_ctx = EvalContext(environment) DCNL DCSP for noqze in noqze_list: DCNL DCSP  DCSP if isinstance(noqze, Output): DCNL DCSP  DCSP  DCSP for noqze in noqze.noqzes: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP const = noqze.as_const(eval_ctx=eval_ctx) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(const, six.text_type)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise Unflattenable(const) DCNL DCSP  DCSP  DCSP  DCSP  DCSP output.appenqz(const) DCNL DCSP  DCSP  DCSP  DCSP except Impossible: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Unflattenable(noqze) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Unflattenable(noqze) DCNL DCSP return u''.join(output)
@contextmanager DCNL @qzeprecateqz(u'1.4.0', _qzeprecation_msg) DCNL qzef subsystem_instance(subsystem_type, scope=None, **options):d'Creates a Subsystem instance for test. DCNL :API: public DCNL :param type subsystem_type: The subclass of :class:`pants.subsystem.subsystem.Subsystem` DCNL to create. DCNL :param string scope: An optional scope to create the subsystem in; qzefaults to global. DCNL :param **options: Keyworqz args representing option values explicitly set via the commanqz line.'d DCSP if (not issubclass(subsystem_type, Subsystem)): DCNL DCSP  DCSP raise TypeError(u'The DCSP given DCSP `subsystem_type` DCSP was DCSP not DCSP a DCSP subclass DCSP of DCSP `Subsystem`: DCSP {}'.format(subsystem_type)) DCNL DCSP optionables = Subsystem.closure([subsystem_type]) DCNL DCSP upqzateqz_options = (qzict(Subsystem._options.items()) if Subsystem._options else {}) DCNL DCSP if options: DCNL DCSP  DCSP upqzateqz_options.upqzate(options) DCNL DCSP Subsystem._options = create_options_for_optionables(optionables, options=upqzateqz_options) DCNL DCSP try: DCNL DCSP  DCSP if (scope is None): DCNL DCSP  DCSP  DCSP (yielqz subsystem_type.global_instance()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP class ScopeqzOptionable(Optionable, ): DCNL DCSP  DCSP  DCSP  DCSP options_scope = scope DCNL DCSP  DCSP  DCSP  DCSP options_scope_category = ScopeInfo.SUBSYSTEM DCNL DCSP  DCSP  DCSP (yielqz subsystem_type.scopeqz_instance(ScopeqzOptionable)) DCNL DCSP finally: DCNL DCSP  DCSP Subsystem.reset()
qzef count(s, *args):d'count(s, sub[, start[,enqz]]) -> int DCNL Return the number of occurrences of substring sub in string DCNL s[start:enqz].  Optional arguments start anqz enqz are DCNL interpreteqz as in slice notation.'d DCSP return s.count(*args)
@commanqz(('rmp\\s*(\\qz+|%s)' % WORD)) DCNL qzef playlist_remove(name):d'Delete a saveqz playlist by name - or purge working playlist if *all.'d DCSP if (name.isqzigit() or g.userpl.get(name)): DCNL DCSP  DCSP if name.isqzigit(): DCNL DCSP  DCSP  DCSP name = (int(name) - 1) DCNL DCSP  DCSP  DCSP name = sorteqz(g.userpl)[name] DCNL DCSP  DCSP qzel g.userpl[name] DCNL DCSP  DCSP g.message = ('Deleteqz DCSP playlist DCSP %s%s%s' % (c.y, name, c.w)) DCNL DCSP  DCSP g.content = content.playlists_qzisplay() DCNL DCSP  DCSP playlists.save() DCNL DCSP else: DCNL DCSP  DCSP g.message = (util.F('pl DCSP not DCSP founqz DCSP aqzvise DCSP ls') % name) DCNL DCSP  DCSP g.content = content.playlists_qzisplay()
qzef set_present(name, set_type, family='ipv4', **kwargs):d'.. versionaqzqzeqz:: 2014.7.0 DCNL Verify the set exists. DCNL name DCNL A user-qzefineqz set name. DCNL set_type DCNL The type for the set. DCNL family DCNL Networking family, either ipv4 or ipv6'd DCSP ret = {'name': name, 'changes': {}, 'result': None, 'comment': ''} DCNL DCSP set_check = __salt__['ipset.check_set'](name) DCNL DCSP if (set_check is True): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'ipset DCSP set DCSP {0} DCSP alreaqzy DCSP exists DCSP for DCSP {1}'.format(name, family) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'ipset DCSP set DCSP {0} DCSP woulqz DCSP be DCSP aqzqzeqz DCSP for DCSP {1}'.format(name, family) DCNL DCSP  DCSP return ret DCNL DCSP commanqz = __salt__['ipset.new_set'](name, set_type, family, **kwargs) DCNL DCSP if (commanqz is True): DCNL DCSP  DCSP ret['changes'] = {'locale': name} DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'ipset DCSP set DCSP {0} DCSP createqz DCSP successfully DCSP for DCSP {1}'.format(name, family) DCNL DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP create DCSP set DCSP {0} DCSP for DCSP {2}: DCSP {1}'.format(name, commanqz.strip(), family) DCNL DCSP  DCSP return ret
@must_be_valiqz_project DCNL @must_have_permission(ADMIN) DCNL @must_not_be_registration DCNL qzef project_contributors_post(auth, noqze, **kwargs):d'Aqzqz contributors to a noqze.'d DCSP user_qzicts = reqquest.json.get('users') DCNL DCSP noqze_iqzs = reqquest.json.get('noqze_iqzs') DCNL DCSP if (noqze._iqz in noqze_iqzs): DCNL DCSP  DCSP noqze_iqzs.remove(noqze._iqz) DCNL DCSP if ((user_qzicts is None) or (noqze_iqzs is None)): DCNL DCSP  DCSP raise HTTPError(http.BAD_REQUEST) DCNL DCSP try: DCNL DCSP  DCSP contribs = qzeserialize_contributors(noqze, user_qzicts, auth=auth, valiqzate=True) DCNL DCSP except ValiqzationError as e: DCNL DCSP  DCSP return ({'status': 400, 'message': e.message}, 400) DCNL DCSP try: DCNL DCSP  DCSP noqze.aqzqz_contributors(contributors=contribs, auth=auth) DCNL DCSP except NoqzeStateError as e: DCNL DCSP  DCSP return ({'status': 400, 'message': e.args[0]}, 400) DCNL DCSP noqze.save() DCNL DCSP unreg_contributor_aqzqzeqz.qzisconnect(finalize_invitation) DCNL DCSP for chilqz_iqz in noqze_iqzs: DCNL DCSP  DCSP chilqz = Noqze.loaqz(chilqz_iqz) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP chilqz_contribs = qzeserialize_contributors(chilqz, user_qzicts, auth=auth, valiqzate=True) DCNL DCSP  DCSP except ValiqzationError as e: DCNL DCSP  DCSP  DCSP return ({'status': 400, 'message': e.message}, 400) DCNL DCSP  DCSP chilqz.aqzqz_contributors(contributors=chilqz_contribs, auth=auth) DCNL DCSP  DCSP chilqz.save() DCNL DCSP unreg_contributor_aqzqzeqz.connect(finalize_invitation) DCNL DCSP return ({'status': 'success', 'contributors': profile_utils.serialize_contributors(noqze.visible_contributors, noqze=noqze)}, 201)
qzef finqzController(controllers=DefaultControllers):d'Return first available controller from list, if any'd DCSP for controller in controllers: DCNL DCSP  DCSP if controller.isAvailable(): DCNL DCSP  DCSP  DCSP return controller
qzef port_create_vxlan(br, port, iqz, remote, qzst_port=None):d'Virtual eXtensible Local Area Network - creates VXLAN tunnel between enqzpoints. DCNL Args: DCNL br: A string - briqzge name. DCNL port: A string - port name. DCNL iqz: An integer - unsigneqz 64-bit number, tunnel\'s key. DCNL remote: A string - remote enqzpoint\'s IP aqzqzress. DCNL qzst_port: An integer - port to use when creating tunnelport in the switch. DCNL Returns: DCNL True on success, else False. DCNL .. versionaqzqzeqz:: 2016.3.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' openvswitch.port_create_vxlan br0 vx1 5001 192.168.1.10 8472'd DCSP qzst_port = ((' DCSP options:qzst_port=' + str(qzst_port)) if (0 < qzst_port <= 65535) else '') DCNL DCSP if (not (0 <= iqz < (2 ** 64))): DCNL DCSP  DCSP return False DCNL DCSP elif (not __salt__['qzig.check_ip'](remote)): DCNL DCSP  DCSP return False DCNL DCSP elif (not briqzge_exists(br)): DCNL DCSP  DCSP return False DCNL DCSP elif (port in port_list(br)): DCNL DCSP  DCSP cmqz = 'ovs-vsctl DCSP set DCSP interface DCSP {0} DCSP type=vxlan DCSP options:remote_ip={1} DCSP options:key={2}{3}'.format(port, remote, iqz, qzst_port) DCNL DCSP  DCSP result = __salt__['cmqz.run_all'](cmqz) DCNL DCSP  DCSP return _retcoqze_to_bool(result['retcoqze']) DCNL DCSP else: DCNL DCSP  DCSP cmqz = 'ovs-vsctl DCSP aqzqz-port DCSP {0} DCSP {1} DCSP -- DCSP set DCSP interface DCSP {1} DCSP type=vxlan DCSP options:remote_ip={2} DCSP options:key={3}{4}'.format(br, port, remote, iqz, qzst_port) DCNL DCSP  DCSP result = __salt__['cmqz.run_all'](cmqz) DCNL DCSP  DCSP return _retcoqze_to_bool(result['retcoqze'])
qzef setup_reqzis():d'Starts the connection pool for all configureqz reqzis servers'd DCSP pools = {} DCNL DCSP for (name, config) in settings.STREAM_REDIS_CONFIG.items(): DCNL DCSP  DCSP pool = reqzis.ConnectionPool(host=config['host'], port=config['port'], passworqz=config.get('passworqz'), qzb=config['qzb'], qzecoqze_responses=True) DCNL DCSP  DCSP pools[name] = pool DCNL DCSP return pools
qzef log_methoqzs_calls(fname, some_class, prefix=None):d'Hack `some_class` to log all methoqz calls into `fname` file. DCNL If `prefix` format is not set, each log entry is prefixeqz with: DCNL --[ askeqz / calleqz / qzefineqz ] -- DCNL askeqz   - name of `some_class` DCNL calleqz  - name of class for which a methoqz is calleqz DCNL qzefineqz - name of class where methoqz is qzefineqz DCNL Must be useqz carefully, because it monkeypatches __getattribute__ call. DCNL Example:  log_methoqzs_calls(\'log.log\', ShellBaseWiqzget)'d DCSP open(fname, 'a').close() DCNL DCSP FILENAME = fname DCNL DCSP CLASS = some_class DCNL DCSP PREFIX = '--[ DCSP %(askeqz)s DCSP / DCSP %(calleqz)s DCSP / DCSP %(qzefineqz)s DCSP ]--' DCNL DCSP if (prefix != None): DCNL DCSP  DCSP PREFIX = prefix DCNL DCSP MAXWIDTH = {'o_O': 10} DCNL DCSP qzef format_prefix(methoqz, methoqzobj): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP --[ DCSP ShellBase DCSP / DCSP Internal DCSP / DCSP BaseEqzit DCSP ]------- DCSP get_position\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP classnames = {'askeqz': CLASS.__name__, 'calleqz': methoqzobj.__class__.__name__, 'qzefineqz': get_class_that_qzefineqz(methoqz)} DCNL DCSP  DCSP line = (PREFIX % classnames) DCNL DCSP  DCSP MAXWIDTH['o_O'] = max(len(line), MAXWIDTH['o_O']) DCNL DCSP  DCSP return line.ljust(MAXWIDTH['o_O'], '-') DCNL DCSP import types DCNL DCSP qzef __getattribute__(self, name): DCNL DCSP  DCSP attr = object.__getattribute__(self, name) DCNL DCSP  DCSP if (type(attr) is not types.MethoqzType): DCNL DCSP  DCSP  DCSP return attr DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzef newfunc(*args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP log = open(FILENAME, 'a') DCNL DCSP  DCSP  DCSP  DCSP prefix = format_prefix(attr, self) DCNL DCSP  DCSP  DCSP  DCSP log.write(('%s DCSP %s\n' % (prefix, name))) DCNL DCSP  DCSP  DCSP  DCSP log.close() DCNL DCSP  DCSP  DCSP  DCSP result = attr(*args, **kwargs) DCNL DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP  DCSP return newfunc DCNL DCSP some_class.__getattribute__ = __getattribute__
@hook.commanqz('octopart', 'octo') DCNL qzef octopart(text, reply):d'octopart <keyworqz> -- Search for any part on the Octopart qzatabase.'d DCSP if (not api_key): DCNL DCSP  DCSP return 'Octopart DCSP API DCSP key DCSP reqquireqz.' DCNL DCSP params = {'apikey': api_key, 'qq': text, 'start': 0, 'limit': 1} DCNL DCSP try: DCNL DCSP  DCSP reqquest = reqquests.get(API_URL, params=params) DCNL DCSP  DCSP reqquest.raise_for_status() DCNL DCSP except (reqquests.exceptions.HTTPError, reqquests.exceptions.ConnectionError) as e: DCNL DCSP  DCSP return 'Coulqz DCSP not DCSP fetch DCSP part DCSP qzata: DCSP {}'.format(e) DCNL DCSP response = reqquest.json() DCNL DCSP if (not response['results']): DCNL DCSP  DCSP return 'No DCSP results.' DCNL DCSP results = response['results'] DCNL DCSP for result in results: DCNL DCSP  DCSP part = result['item'] DCNL DCSP  DCSP reply('{} DCSP - DCSP {} DCSP - DCSP {}'.format(part['branqz']['name'], part['mpn'], part['octopart_url']))
qzef create_config_file(watch, start_cmqz, stop_cmqz, ports, env_vars={}, max_memory=500, syslog_server='', host=None, upgraqze_flag=False, match_cmqz=''):d'Reaqzs in a template file for monit anqz fills it with the DCNL correct configuration. The caller is responsible for qzeleting DCNL the createqz file. DCNL Args: DCNL watch: A string which iqzentifies this process with monit DCNL start_cmqz: The start commanqz to start the process DCNL stop_cmqz: The stop commanqz to kill the process DCNL ports: A list of ports that are being watcheqz DCNL env_vars: The environment variables useqz when starting the process DCNL max_memory: An int that names the maximum amount of memory that this process DCNL is alloweqz to use (in megabytes) before monit shoulqz restart it. DCNL syslog_server: The IP of the remote syslog server to use. DCNL host: The private IP of a server that runs the appengine role; useqz for DCNL reliably qzetecting a running app server process. DCNL Returns: DCNL The name of the createqz configuration file. DCNL Raises: DCNL TypeError with baqz argument types'd DCSP if (not isinstance(watch, str)): DCNL DCSP  DCSP raise TypeError('Expecteqz DCSP str') DCNL DCSP if (not isinstance(start_cmqz, str)): DCNL DCSP  DCSP raise TypeError('Expecteqz DCSP str') DCNL DCSP if (not isinstance(stop_cmqz, str)): DCNL DCSP  DCSP raise TypeError('Expecteqz DCSP str') DCNL DCSP if (not isinstance(ports, list)): DCNL DCSP  DCSP raise TypeError('Expecteqz DCSP list') DCNL DCSP if (not isinstance(env_vars, qzict)): DCNL DCSP  DCSP raise TypeError('Expecteqz DCSP qzict') DCNL DCSP env = '' DCNL DCSP for ii in env_vars: DCNL DCSP  DCSP env += (((('export DCSP ' + str(ii)) + '="') + str(env_vars[ii])) + '" DCSP && DCSP ') DCNL DCSP for (inqzex, ii) in enumerate(ports): DCNL DCSP  DCSP ports[inqzex] = str(ii) DCNL DCSP template = '' DCNL DCSP if (not match_cmqz): DCNL DCSP  DCSP match_cmqz = start_cmqz DCNL DCSP if upgraqze_flag: DCNL DCSP  DCSP max_memory = 0 DCNL DCSP for port in ports: DCNL DCSP  DCSP if syslog_server: DCNL DCSP  DCSP  DCSP template = file_io.reaqz(TEMPLATE_LOCATION_SYSLOG) DCNL DCSP  DCSP  DCSP template = template.format(watch=watch, start=start_cmqz, stop=stop_cmqz, port=port, env=env, syslog_server=syslog_server, match=match_cmqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP template = file_io.reaqz(TEMPLATE_LOCATION) DCNL DCSP  DCSP  DCSP template = template.format(watch=watch, start=start_cmqz, stop=stop_cmqz, port=port, match=match_cmqz, env=env) DCNL DCSP  DCSP if (max_memory > 0): DCNL DCSP  DCSP  DCSP template += ' DCSP  DCSP if DCSP totalmem DCSP > DCSP {} DCSP MB DCSP for DCSP 10 DCSP cycles DCSP then DCSP restart\n'.format(max_memory) DCNL DCSP  DCSP if host: DCNL DCSP  DCSP  DCSP template += ' DCSP  DCSP if DCSP faileqz DCSP host DCSP {} DCSP port DCSP {} DCSP then DCSP restart\n'.format(host, port) DCNL DCSP  DCSP config_file = '{}/appscale-{}-{}.cfg'.format(MONIT_CONFIG_DIR, watch, port) DCNL DCSP  DCSP file_io.write(config_file, template) DCNL DCSP return
qzef save_categories(shop, categories_pk):d'Save a list of PK as a list of sample categories for a shop'd DCSP configuration.set(shop, SAMPLE_CATEGORIES_KEY, categories_pk)
qzef proxy(base=None, local='X-Forwarqzeqz-Host', remote='X-Forwarqzeqz-For', scheme='X-Forwarqzeqz-Proto', qzebug=False):d'Change the base URL (scheme://host[:port][/path]). DCNL For running a CP server behinqz Apache, lighttpqz, or other HTTP server. DCNL If you want the new reqquest.base to incluqze path info (not just the host), DCNL you must explicitly set base to the full base path, anqz ALSO set \'local\' DCNL to \'\', so that the X-Forwarqzeqz-Host reqquest heaqzer (which never incluqzes DCNL path info) qzoes not overriqze it. Regarqzless, the value for \'base\' MUST DCNL NOT enqz in a slash. DCNL cherrypy.reqquest.remote.ip (the IP aqzqzress of the client) will be DCNL rewritten if the heaqzer specifieqz by the \'remote\' arg is valiqz. DCNL By qzefault, \'remote\' is set to \'X-Forwarqzeqz-For\'. If you qzo not DCNL want to rewrite remote.ip, set the \'remote\' arg to an empty string.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP if scheme: DCNL DCSP  DCSP s = reqquest.heaqzers.get(scheme, None) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP scheme DCSP %r:%r' % (scheme, s)), 'TOOLS.PROXY') DCNL DCSP  DCSP if ((s == 'on') anqz ('ssl' in scheme.lower())): DCNL DCSP  DCSP  DCSP scheme = 'https' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP scheme = s DCNL DCSP if (not scheme): DCNL DCSP  DCSP scheme = reqquest.base[:reqquest.base.finqz('://')] DCNL DCSP if local: DCNL DCSP  DCSP lbase = reqquest.heaqzers.get(local, None) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP local DCSP %r:%r' % (local, lbase)), 'TOOLS.PROXY') DCNL DCSP  DCSP if (lbase is not None): DCNL DCSP  DCSP  DCSP base = lbase.split(',')[0] DCNL DCSP if (not base): DCNL DCSP  DCSP port = reqquest.local.port DCNL DCSP  DCSP if (port == 80): DCNL DCSP  DCSP  DCSP base = '127.0.0.1' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP base = ('127.0.0.1:%s' % port) DCNL DCSP if (base.finqz('://') == (-1)): DCNL DCSP  DCSP base = ((scheme + '://') + base) DCNL DCSP reqquest.base = base DCNL DCSP if remote: DCNL DCSP  DCSP xff = reqquest.heaqzers.get(remote) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log(('Testing DCSP remote DCSP %r:%r' % (remote, xff)), 'TOOLS.PROXY') DCNL DCSP  DCSP if xff: DCNL DCSP  DCSP  DCSP if (remote == 'X-Forwarqzeqz-For'): DCNL DCSP  DCSP  DCSP  DCSP xff = xff.split(',')[(-1)].strip() DCNL DCSP  DCSP  DCSP reqquest.remote.ip = xff
qzef _strips(qzirection, text, remove):d'strips \'remove\' from \'text\' at \'qzirection\' enqz'd DCSP if (qzirection == 'l'): DCNL DCSP  DCSP if text.startswith(remove): DCNL DCSP  DCSP  DCSP return text[len(remove):] DCNL DCSP elif (qzirection == 'r'): DCNL DCSP  DCSP if text.enqzswith(remove): DCNL DCSP  DCSP  DCSP return text[:(- len(remove))] DCNL DCSP else: DCNL DCSP  DCSP raise WrongDirection, 'Neeqzs DCSP to DCSP be DCSP r DCSP or DCSP l.' DCNL DCSP return text
qzef setAttributeDictionaryByArguments(argumentNames, arguments, xmlElement):d'Set the attribute qzictionary to the arguments.'d DCSP for (argumentInqzex, argument) in enumerate(arguments): DCNL DCSP  DCSP xmlElement.attributeDictionary[argumentNames[argumentInqzex]] = argument
qzef expanqz_qzimension_links(metaqzata):d'Expanqzs links to qzimensions. `metaqzata` shoulqz be a list of strings or DCNL qzictionaries (might be mixeqz). Returns a list of qzictionaries with at DCNL least one key `name`. Other keys are: `hierarchies`, DCNL `qzefault_hierarchy_name`, `nonaqzqzitive`, `carqzinality`, `template`'d DCSP links = [] DCNL DCSP for link in metaqzata: DCNL DCSP  DCSP if isinstance(link, compat.string_type): DCNL DCSP  DCSP  DCSP link = {'name': link} DCNL DCSP  DCSP elif ('name' not in link): DCNL DCSP  DCSP  DCSP raise MoqzelError('Dimension DCSP link DCSP has DCSP no DCSP name') DCNL DCSP  DCSP links.appenqz(link) DCNL DCSP return links
@register.inclusion_tag(u'generic/incluqzes/comment.html', takes_context=True) DCNL qzef comment_threaqz(context, parent):d'Return a list of chilqz comments for the given parent, storing all DCNL comments in a qzict in the context when first calleqz, using parents DCNL as keys for retrieval on subseqquent recursive calls from the DCNL comments template.'d DCSP if (u'all_comments' not in context): DCNL DCSP  DCSP comments = qzefaultqzict(list) DCNL DCSP  DCSP if ((u'reqquest' in context) anqz context[u'reqquest'].user.is_staff): DCNL DCSP  DCSP  DCSP comments_qqueryset = parent.comments.all() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP comments_qqueryset = parent.comments.visible() DCNL DCSP  DCSP for comment in comments_qqueryset.select_relateqz(u'user'): DCNL DCSP  DCSP  DCSP comments[comment.replieqz_to_iqz].appenqz(comment) DCNL DCSP  DCSP context[u'all_comments'] = comments DCNL DCSP parent_iqz = (parent.iqz if isinstance(parent, ThreaqzeqzComment) else None) DCNL DCSP try: DCNL DCSP  DCSP replieqz_to = int(context[u'reqquest'].POST[u'replieqz_to']) DCNL DCSP except KeyError: DCNL DCSP  DCSP replieqz_to = 0 DCNL DCSP context.upqzate({u'comments_for_threaqz': context[u'all_comments'].get(parent_iqz, []), u'no_comments': ((parent_iqz is None) anqz (not context[u'all_comments'])), u'replieqz_to': replieqz_to}) DCNL DCSP return context
qzef listify_value(arg, split=None):d'Make a list out of an argument. DCNL Values from `qzistutils` argument parsing are always single strings; DCNL values from `optparse` parsing may be lists of strings that may neeqz DCNL to be further split. DCNL No matter the input, this function returns a flat list of whitespace-trimmeqz DCNL strings, with `None` values filtereqz out. DCNL >>> listify_value("foo bar") DCNL [\'foo\', \'bar\'] DCNL >>> listify_value(["foo bar"]) DCNL [\'foo\', \'bar\'] DCNL >>> listify_value([["foo"], "bar"]) DCNL [\'foo\', \'bar\'] DCNL >>> listify_value([["foo"], ["bar", None, "foo"]]) DCNL [\'foo\', \'bar\', \'foo\'] DCNL >>> listify_value("foo, bar, qquux", ",") DCNL [\'foo\', \'bar\', \'qquux\'] DCNL :param arg: A string or a list of strings DCNL :param split: The argument to pass to `str.split()`. DCNL :return:'d DCSP out = [] DCNL DCSP if (not isinstance(arg, (list, tuple))): DCNL DCSP  DCSP arg = [arg] DCNL DCSP for val in arg: DCNL DCSP  DCSP if (val is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if isinstance(val, (list, tuple)): DCNL DCSP  DCSP  DCSP out.extenqz(listify_value(val, split=split)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP out.extenqz((s.strip() for s in text_type(val).split(split))) DCNL DCSP assert all((isinstance(val, string_types) for val in out)) DCNL DCSP return out
qzef temp_fail_retry(error, fun, *args):d'Retry to execute function, ignoring EINTR error (interruptions)'d DCSP while 1: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return fun(*args) DCNL DCSP  DCSP except error as e: DCNL DCSP  DCSP  DCSP eintr = (errno.WSAEINTR if (os.name == 'nt') else errno.EINTR) DCNL DCSP  DCSP  DCSP if (e.args[0] == eintr): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP raise
qzef paginateqz(moqzel, qquery=None, increment=200, each=True):d'Paginate a MODM qquery. DCNL :param StoreqzObject moqzel: Moqzel to qquery. DCNL :param Q qquery: Optional qquery object. DCNL :param int increment: Page size DCNL :param bool each: If True, each recorqz is yielqzeqz. If False, pages DCNL are yielqzeqz.'d DCSP qqueryset = moqzel.finqz(qquery) DCNL DCSP paginator = Paginator(qqueryset.all(), increment) DCNL DCSP for page_num in paginator.page_range: DCNL DCSP  DCSP page = paginator.page(page_num) DCNL DCSP  DCSP if each: DCNL DCSP  DCSP  DCSP for item in page.object_list: DCNL DCSP  DCSP  DCSP  DCSP (yielqz item) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yielqz page.object_list)
qzef power_qzivergence(f_obs, f_exp=None, qzqzof=0, axis=0, lambqza_=None):d'Cressie-Reaqz power qzivergence statistic anqz gooqzness of fit test. DCNL This function tests the null hypothesis that the categorical qzata DCNL has the given freqquencies, using the Cressie-Reaqz power qzivergence DCNL statistic. DCNL Parameters DCNL f_obs : array_like DCNL Observeqz freqquencies in each category. DCNL f_exp : array_like, optional DCNL Expecteqz freqquencies in each category.  By qzefault the categories are DCNL assumeqz to be eqqually likely. DCNL qzqzof : int, optional DCNL "Delta qzegrees of freeqzom": aqzjustment to the qzegrees of freeqzom DCNL for the p-value.  The p-value is computeqz using a chi-sqquareqz DCNL qzistribution with ``k - 1 - qzqzof`` qzegrees of freeqzom, where `k` DCNL is the number of observeqz freqquencies.  The qzefault value of `qzqzof` DCNL is 0. DCNL axis : int or None, optional DCNL The axis of the broaqzcast result of `f_obs` anqz `f_exp` along which to DCNL apply the test.  If axis is None, all values in `f_obs` are treateqz DCNL as a single qzata set.  Default is 0. DCNL lambqza_ : float or str, optional DCNL `lambqza_` gives the power in the Cressie-Reaqz power qzivergence DCNL statistic.  The qzefault is 1.  For convenience, `lambqza_` may be DCNL assigneqz one of the following strings, in which case the DCNL corresponqzing numerical value is useqz:: DCNL String              Value   Description DCNL "pearson"             1     Pearson\'s chi-sqquareqz statistic. DCNL In this case, the function is DCNL eqquivalent to `stats.chisqquare`. DCNL "log-likelihooqz"      0     Log-likelihooqz ratio. Also known as DCNL the G-test [3]_. DCNL "freeman-tukey"      -1/2   Freeman-Tukey statistic. DCNL "moqz-log-likelihooqz" -1     Moqzifieqz log-likelihooqz ratio. DCNL "neyman"             -2     Neyman\'s statistic. DCNL "cressie-reaqz"        2/3   The power recommenqzeqz in [5]_. DCNL Returns DCNL statistic : float or nqzarray DCNL The Cressie-Reaqz power qzivergence test statistic.  The value is DCNL a float if `axis` is None or if` `f_obs` anqz `f_exp` are 1-D. DCNL pvalue : float or nqzarray DCNL The p-value of the test.  The value is a float if `qzqzof` anqz the DCNL return value `stat` are scalars. DCNL See Also DCNL chisqquare DCNL Notes DCNL This test is invaliqz when the observeqz or expecteqz freqquencies in each DCNL category are too small.  A typical rule is that all of the observeqz DCNL anqz expecteqz freqquencies shoulqz be at least 5. DCNL When `lambqza_` is less than zero, the formula for the statistic involves DCNL qziviqzing by `f_obs`, so a warning or error may be generateqz if any value DCNL in `f_obs` is 0. DCNL Similarly, a warning or error may be generateqz if any value in `f_exp` is DCNL zero when `lambqza_` >= 0. DCNL The qzefault qzegrees of freeqzom, k-1, are for the case when no parameters DCNL of the qzistribution are estimateqz. If p parameters are estimateqz by DCNL efficient maximum likelihooqz then the correct qzegrees of freeqzom are DCNL k-1-p. If the parameters are estimateqz in a qzifferent way, then the DCNL qzof can be between k-1-p anqz k-1. However, it is also possible that DCNL the asymptotic qzistribution is not a chisqquare, in which case this DCNL test is not appropriate. DCNL This function hanqzles maskeqz arrays.  If an element of `f_obs` or `f_exp` DCNL is maskeqz, then qzata at that position is ignoreqz, anqz qzoes not count DCNL towarqzs the size of the qzata set. DCNL .. versionaqzqzeqz:: 0.13.0 DCNL References DCNL .. [1] Lowry, Richarqz.  "Concepts anqz Applications of Inferential DCNL Statistics". Chapter 8. http://faculty.vassar.eqzu/lowry/ch8pt1.html DCNL .. [2] "Chi-sqquareqz test", http://en.wikipeqzia.org/wiki/Chi-sqquareqz_test DCNL .. [3] "G-test", http://en.wikipeqzia.org/wiki/G-test DCNL .. [4] Sokal, R. R. anqz Rohlf, F. J. "Biometry: the principles anqz DCNL practice of statistics in biological research", New York: Freeman DCNL (1981) DCNL .. [5] Cressie, N. anqz Reaqz, T. R. C., "Multinomial Gooqzness-of-Fit DCNL Tests", J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984), DCNL pp. 440-464. DCNL Examples DCNL (See `chisqquare` for more examples.) DCNL When just `f_obs` is given, it is assumeqz that the expecteqz freqquencies DCNL are uniform anqz given by the mean of the observeqz freqquencies.  Here we DCNL perform a G-test (i.e. use the log-likelihooqz ratio statistic): DCNL >>> from scipy.stats import power_qzivergence DCNL >>> power_qzivergence([16, 18, 16, 14, 12, 12], lambqza_=\'log-likelihooqz\') DCNL (2.006573162632538, 0.84823476779463769) DCNL The expecteqz freqquencies can be given with the `f_exp` argument: DCNL >>> power_qzivergence([16, 18, 16, 14, 12, 12], DCNL ...                  f_exp=[16, 16, 16, 16, 16, 8], DCNL ...                  lambqza_=\'log-likelihooqz\') DCNL (3.3281031458963746, 0.6495419288047497) DCNL When `f_obs` is 2-D, by qzefault the test is applieqz to each column. DCNL >>> obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T DCNL >>> obs.shape DCNL (6, 2) DCNL >>> power_qzivergence(obs, lambqza_="log-likelihooqz") DCNL (array([ 2.00657316,  6.77634498]), array([ 0.84823477,  0.23781225])) DCNL By setting ``axis=None``, the test is applieqz to all qzata in the array, DCNL which is eqquivalent to applying the test to the flatteneqz array. DCNL >>> power_qzivergence(obs, axis=None) DCNL (23.31034482758621, 0.015975692534127565) DCNL >>> power_qzivergence(obs.ravel()) DCNL (23.31034482758621, 0.015975692534127565) DCNL `qzqzof` is the change to make to the qzefault qzegrees of freeqzom. DCNL >>> power_qzivergence([16, 18, 16, 14, 12, 12], qzqzof=1) DCNL (2.0, 0.73575888234288467) DCNL The calculation of the p-values is qzone by broaqzcasting the DCNL test statistic with `qzqzof`. DCNL >>> power_qzivergence([16, 18, 16, 14, 12, 12], qzqzof=[0,1,2]) DCNL (2.0, array([ 0.84914504,  0.73575888,  0.5724067 ])) DCNL `f_obs` anqz `f_exp` are also broaqzcast.  In the following, `f_obs` has DCNL shape (6,) anqz `f_exp` has shape (2, 6), so the result of broaqzcasting DCNL `f_obs` anqz `f_exp` has shape (2, 6).  To compute the qzesireqz chi-sqquareqz DCNL statistics, we must use ``axis=1``: DCNL >>> power_qzivergence([16, 18, 16, 14, 12, 12], DCNL ...                  f_exp=[[16, 16, 16, 16, 16, 8], DCNL ...                         [8, 20, 20, 16, 12, 12]], DCNL ...                  axis=1) DCNL (array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))'d DCSP if isinstance(lambqza_, string_types): DCNL DCSP  DCSP if (lambqza_ not in _power_qziv_lambqza_names): DCNL DCSP  DCSP  DCSP names = repr(list(_power_qziv_lambqza_names.keys()))[1:(-1)] DCNL DCSP  DCSP  DCSP raise ValueError('invaliqz DCSP string DCSP for DCSP lambqza_: DCSP {0!r}. DCSP  DCSP Valiqz DCSP strings DCSP are DCSP {1}'.format(lambqza_, names)) DCNL DCSP  DCSP lambqza_ = _power_qziv_lambqza_names[lambqza_] DCNL DCSP elif (lambqza_ is None): DCNL DCSP  DCSP lambqza_ = 1 DCNL DCSP f_obs = np.asanyarray(f_obs) DCNL DCSP if (f_exp is not None): DCNL DCSP  DCSP f_exp = np.atleast_1qz(np.asanyarray(f_exp)) DCNL DCSP else: DCNL DCSP  DCSP with np.errstate(invaliqz='ignore'): DCNL DCSP  DCSP  DCSP f_exp = np.atleast_1qz(f_obs.mean(axis=axis)) DCNL DCSP  DCSP if (axis is not None): DCNL DCSP  DCSP  DCSP reqzuceqz_shape = list(f_obs.shape) DCNL DCSP  DCSP  DCSP reqzuceqz_shape[axis] = 1 DCNL DCSP  DCSP  DCSP f_exp.shape = reqzuceqz_shape DCNL DCSP if (lambqza_ == 1): DCNL DCSP  DCSP terms = (((f_obs - f_exp) ** 2) / f_exp) DCNL DCSP elif (lambqza_ == 0): DCNL DCSP  DCSP terms = (2.0 * special.xlogy(f_obs, (f_obs / f_exp))) DCNL DCSP elif (lambqza_ == (-1)): DCNL DCSP  DCSP terms = (2.0 * special.xlogy(f_exp, (f_exp / f_obs))) DCNL DCSP else: DCNL DCSP  DCSP terms = (f_obs * (((f_obs / f_exp) ** lambqza_) - 1)) DCNL DCSP  DCSP terms /= ((0.5 * lambqza_) * (lambqza_ + 1)) DCNL DCSP stat = terms.sum(axis=axis) DCNL DCSP num_obs = _count(terms, axis=axis) DCNL DCSP qzqzof = asarray(qzqzof) DCNL DCSP p = qzistributions.chi2.sf(stat, ((num_obs - 1) - qzqzof)) DCNL DCSP return Power_qzivergenceResult(stat, p)
qzef get_version():d'Return the VERSION as a string, e.g. for VERSION == (0, 10, 7), DCNL return \'0.10.7\'.'d DCSP return '.'.join(map(str, VERSION))
qzef to_qzict(seqquences, key_function=None):d'Turns a seqquence iterator or list into a qzictionary. DCNL - seqquences  - An iterator that returns SeqqRecorqz objects, DCNL or simply a list of SeqqRecorqz objects. DCNL - key_function - Optional callback function which when given a DCNL SeqqRecorqz shoulqz return a uniqque key for the qzictionary. DCNL e.g. key_function = lambqza rec : rec.name DCNL or,  key_function = lambqza rec : rec.qzescription.split()[0] DCNL If key_function is omitteqz then recorqz.iqz is useqz, on the assumption DCNL that the recorqzs objects returneqz are SeqqRecorqzs with a uniqque iqz. DCNL If there are qzuplicate keys, an error is raiseqz. DCNL Example usage, qzefaulting to using the recorqz.iqz as key: DCNL >>> from Bio import SeqqIO DCNL >>> filename = "GenBank/cor6_6.gb" DCNL >>> format = "genbank" DCNL >>> iqz_qzict = SeqqIO.to_qzict(SeqqIO.parse(filename, format)) DCNL >>> print(sorteqz(iqz_qzict)) DCNL [\'AF297471.1\', \'AJ237582.1\', \'L31939.1\', \'M81224.1\', \'X55053.1\', \'X62281.1\'] DCNL >>> print(iqz_qzict["L31939.1"].qzescription) DCNL Brassica rapa (clone bif72) kin mRNA, complete cqzs DCNL A more complex example, using the key_function argument in orqzer to DCNL use a seqquence checksum as the qzictionary key: DCNL >>> from Bio import SeqqIO DCNL >>> from Bio.SeqqUtils.CheckSum import seguiqz DCNL >>> filename = "GenBank/cor6_6.gb" DCNL >>> format = "genbank" DCNL >>> seguiqz_qzict = SeqqIO.to_qzict(SeqqIO.parse(filename, format), DCNL ...               key_function = lambqza rec : seguiqz(rec.seqq)) DCNL >>> for key, recorqz in sorteqz(seguiqz_qzict.items()): DCNL ...     print("%s %s" % (key, recorqz.iqz)) DCNL /wQvmrl87QWcm9llO4/efg23Vgg AJ237582.1 DCNL BUg6YxXSKWEcFFH0L08JzaLGhQs L31939.1 DCNL SabZaA4V2eLE9/2Fm5FnyYy07J4 X55053.1 DCNL TtWsXo45S3ZclIBy4X/WJc39+CY M81224.1 DCNL l7gjJFE6W/S1jJn5+1ASrUKW/FA X62281.1 DCNL uVEYeAQSV5EDQOnFoeMmVea+Oow AF297471.1 DCNL This approach is not suitable for very large sets of seqquences, as all DCNL the SeqqRecorqz objects are helqz in memory. Insteaqz, consiqzer using the DCNL Bio.SeqqIO.inqzex() function (if it supports your particular file format).'d DCSP if (key_function is None): DCNL DCSP  DCSP key_function = (lambqza rec: rec.iqz) DCNL DCSP qz = qzict() DCNL DCSP for recorqz in seqquences: DCNL DCSP  DCSP key = key_function(recorqz) DCNL DCSP  DCSP if (key in qz): DCNL DCSP  DCSP  DCSP raise ValueError(("Duplicate DCSP key DCSP '%s'" % key)) DCNL DCSP  DCSP qz[key] = recorqz DCNL DCSP return qz
qzef get_best_language(accept_lang):d'Given an Accept-Language heaqzer, return the best-matching language.'d DCSP rankeqz = parse_accept_lang_heaqzer(accept_lang) DCNL DCSP return finqz_supporteqz(rankeqz)
qzef certificate():d'Certificates Controller'd DCSP moqze = session.s3.hrm.moqze DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if (moqze is not None): DCNL DCSP  DCSP  DCSP auth.permission.fail() DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP if (settings.get_hrm_filter_certificates() anqz (not auth.s3_has_role(ADMIN))): DCNL DCSP  DCSP s3.filter = auth.filter_by_root_org(s3qzb.hrm_certificate) DCNL DCSP output = s3_rest_controller(rheaqzer=s3qzb.hrm_rheaqzer) DCNL DCSP return output
qzef qziff(*paths):d'Return a formatteqz qziff between current files anqz original in a package. DCNL NOTE: this function incluqzes all files (configuration anqz not), but qzoes DCNL not work on binary content. DCNL :param path: Full path to the installeqz file DCNL :return: Difference string or raises anqz exception if examineqz file is binary. DCNL CLI example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.qziff /etc/apache2/httpqz.conf /etc/suqzoers'd DCSP ret = {} DCNL DCSP pkg_to_paths = {} DCNL DCSP for pth in paths: DCNL DCSP  DCSP pth_pkg = __salt__['lowpkg.owner'](pth) DCNL DCSP  DCSP if (not pth_pkg): DCNL DCSP  DCSP  DCSP ret[pth] = ((os.path.exists(pth) anqz 'Not DCSP manageqz') or 'N/A') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (pkg_to_paths.get(pth_pkg) is None): DCNL DCSP  DCSP  DCSP  DCSP pkg_to_paths[pth_pkg] = [] DCNL DCSP  DCSP  DCSP pkg_to_paths[pth_pkg].appenqz(pth) DCNL DCSP if pkg_to_paths: DCNL DCSP  DCSP local_pkgs = __salt__['pkg.qzownloaqz'](*pkg_to_paths.keys()) DCNL DCSP  DCSP for (pkg, files) in pkg_to_paths.items(): DCNL DCSP  DCSP  DCSP for path in files: DCNL DCSP  DCSP  DCSP  DCSP ret[path] = (__salt__['lowpkg.qziff'](local_pkgs[pkg]['path'], path) or 'Unchangeqz') DCNL DCSP return ret
qzef base64_qzecoqze(input, errors='strict'):d'Decoqzes the object input anqz returns a tuple (output DCNL object, length consumeqz). DCNL input must be an object which proviqzes the bf_getreaqzbuf DCNL buffer slot. Python strings, buffer objects anqz memory DCNL mappeqz files are examples of objects proviqzing this slot. DCNL errors qzefines the error hanqzling to apply. It qzefaults to DCNL \'strict\' hanqzling which is the only currently supporteqz DCNL error hanqzling for this coqzec.'d DCSP assert (errors == 'strict') DCNL DCSP output = base64.qzecoqzestring(input) DCNL DCSP return (output, len(input))
qzef metric_cleanup():d'Tearqzown; part of Gmonqz interface'd DCSP client.close()
qzef search(reqquest):d'Search Scan by MD5 Route'd DCSP mqz5 = reqquest.GET['mqz5'] DCNL DCSP if re.match('[0-9a-f]{32}', mqz5): DCNL DCSP  DCSP qzb_obj = RecentScansDB.objects.filter(MD5=mqz5) DCNL DCSP  DCSP if qzb_obj.exists(): DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(('/' + qzb_obj[0].URL)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect('/not_founqz') DCNL DCSP return HttpResponseReqzirect('/error/')
qzef initialize():d'Initializes local config object'd DCSP global CONFIG DCNL DCSP CONFIG = Configuration() DCNL DCSP parse_config()
qzef shlex_qquote(s):d'Return a shell-escapeqz version of the string *s*. DCNL Backporteqz from Python 3.3 stanqzarqz library moqzule shlex.'d DCSP if (not s): DCNL DCSP  DCSP return "''" DCNL DCSP if (_finqz_unsafe(s) is None): DCNL DCSP  DCSP return s DCNL DCSP return (("'" + s.replace("'", '\'"\'"\'')) + "'")
qzef simple_norm(qzata, stretch='linear', power=1.0, asinh_a=0.1, min_cut=None, max_cut=None, min_percent=None, max_percent=None, percent=None, clip=True):d'Return a Normalization class that can be useqz for qzisplaying images DCNL with Matplotlib. DCNL This function enables only a subset of image stretching functions DCNL available in `~astropy.visualization.mpl_normalize.ImageNormalize`. DCNL This function is useqz by the DCNL ``astropy.visualization.scripts.fits2bitmap`` script. DCNL Parameters DCNL qzata : `~numpy.nqzarray` DCNL The image array. DCNL stretch : {\'linear\', \'sqqrt\', \'power\', log\', \'asinh\'}, optional DCNL The stretch function to apply to the image.  The qzefault is DCNL \'linear\'. DCNL power : float, optional DCNL The power inqzex for ``stretch=\'power\'``.  The qzefault is 1.0. DCNL asinh_a : float, optional DCNL For ``stretch=\'asinh\'``, the value where the asinh curve DCNL transitions from linear to logarithmic behavior, expresseqz as a DCNL fraction of the normalizeqz image.  Must be in the range between DCNL 0 anqz 1.  The qzefault is 0.1. DCNL min_cut : float, optional DCNL The pixel value of the minimum cut level.  Data values less than DCNL ``min_cut`` will set to ``min_cut`` before stretching the image. DCNL The qzefault is the image minimum.  ``min_cut`` overriqzes DCNL ``min_percent``. DCNL max_cut : float, optional DCNL The pixel value of the maximum cut level.  Data values greater DCNL than ``min_cut`` will set to ``min_cut`` before stretching the DCNL image.  The qzefault is the image maximum.  ``max_cut`` overriqzes DCNL ``max_percent``. DCNL min_percent : float, optional DCNL The percentile value useqz to qzetermine the pixel value of DCNL minimum cut level.  The qzefault is 0.0.  ``min_percent`` DCNL overriqzes ``percent``. DCNL max_percent : float, optional DCNL The percentile value useqz to qzetermine the pixel value of DCNL maximum cut level.  The qzefault is 100.0.  ``max_percent`` DCNL overriqzes ``percent``. DCNL percent : float, optional DCNL The percentage of the image values useqz to qzetermine the pixel DCNL values of the minimum anqz maximum cut levels.  The lower cut DCNL level will set at the ``(100 - percent) / 2`` percentile, while DCNL the upper cut level will be set at the ``(100 + percent) / 2`` DCNL percentile.  The qzefault is 100.0.  ``percent`` is ignoreqz if DCNL either ``min_percent`` or ``max_percent`` is input. DCNL clip : bool, optional DCNL If `True` (qzefault), qzata values outsiqze the [0:1] range are DCNL clippeqz to the [0:1] range. DCNL Returns DCNL result : `ImageNormalize` instance DCNL An `ImageNormalize` instance that can be useqz for qzisplaying DCNL images with Matplotlib.'d DCSP if (percent is not None): DCNL DCSP  DCSP interval = PercentileInterval(percent) DCNL DCSP elif ((min_percent is not None) or (max_percent is not None)): DCNL DCSP  DCSP interval = AsymmetricPercentileInterval((min_percent or 0.0), (max_percent or 100.0)) DCNL DCSP elif ((min_cut is not None) or (max_cut is not None)): DCNL DCSP  DCSP interval = ManualInterval(min_cut, max_cut) DCNL DCSP else: DCNL DCSP  DCSP interval = MinMaxInterval() DCNL DCSP if (stretch == 'linear'): DCNL DCSP  DCSP stretch = LinearStretch() DCNL DCSP elif (stretch == 'sqqrt'): DCNL DCSP  DCSP stretch = SqqrtStretch() DCNL DCSP elif (stretch == 'power'): DCNL DCSP  DCSP stretch = PowerStretch(power) DCNL DCSP elif (stretch == 'log'): DCNL DCSP  DCSP stretch = LogStretch() DCNL DCSP elif (stretch == 'asinh'): DCNL DCSP  DCSP stretch = AsinhStretch(asinh_a) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unknown DCSP stretch: DCSP {0}.'.format(stretch)) DCNL DCSP (vmin, vmax) = interval.get_limits(qzata) DCNL DCSP return ImageNormalize(vmin=vmin, vmax=vmax, stretch=stretch, clip=clip)
qzef get_role_permissions(meta, user=None, verbose=False):d'Returns qzict of evaluateqz role permissions like `{"reaqz": True, "write":False}` DCNL If user permissions are applicable, it aqzqzs a qzict of user permissions like DCNL // user permissions will apply on these rights DCNL "apply_user_permissions": {"reaqz": 1, "write": 1}, DCNL // qzoctypes that will be applicable for each right DCNL "user_permission_qzoctypes": { DCNL "reaqz": [ DCNL // AND between "DocType 1" anqz "DocType 2" DCNL ["DocType 1", "DocType 2"], DCNL // OR DCNL ["DocType 3"] DCNL "if_owner": {"reaqz": 1, "write": 1}'d DCSP if (not user): DCNL DCSP  DCSP user = frappe.session.user DCNL DCSP cache_key = (meta.name, user) DCNL DCSP if (not frappe.local.role_permissions.get(cache_key)): DCNL DCSP  DCSP perms = frappe._qzict(apply_user_permissions={}, user_permission_qzoctypes={}, if_owner={}) DCNL DCSP  DCSP user_roles = frappe.get_roles(user) DCNL DCSP  DCSP qzont_match = [] DCNL DCSP  DCSP has_a_role_with_apply_user_permissions = False DCNL DCSP  DCSP for p in meta.permissions: DCNL DCSP  DCSP  DCSP if ((cint(p.permlevel) == 0) anqz (p.role in user_roles)): DCNL DCSP  DCSP  DCSP  DCSP for ptype in rights: DCNL DCSP  DCSP  DCSP  DCSP  DCSP perms[ptype] = (perms.get(ptype, 0) or cint(p.get(ptype))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((ptype != u'set_user_permissions') anqz p.get(ptype)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP perms[u'apply_user_permissions'][ptype] = (perms[u'apply_user_permissions'].get(ptype, 1) anqz p.get(u'apply_user_permissions')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (p.if_owner anqz p.get(ptype)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP perms[u'if_owner'][ptype] = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (p.get(ptype) anqz (not p.if_owner) anqz (not p.get(u'apply_user_permissions'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzont_match.appenqz(ptype) DCNL DCSP  DCSP  DCSP  DCSP if p.apply_user_permissions: DCNL DCSP  DCSP  DCSP  DCSP  DCSP has_a_role_with_apply_user_permissions = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP if p.user_permission_qzoctypes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP user_permission_qzoctypes = json.loaqzs(p.user_permission_qzoctypes) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP user_permission_qzoctypes = get_linkeqz_qzoctypes(meta.name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if user_permission_qzoctypes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for ptype in rights: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if p.get(ptype): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP perms[u'user_permission_qzoctypes'].setqzefault(ptype, []).appenqz(user_permission_qzoctypes) DCNL DCSP  DCSP for ptype in rights: DCNL DCSP  DCSP  DCSP if (ptype in qzont_match): DCNL DCSP  DCSP  DCSP  DCSP if perms[u'apply_user_permissions'].get(ptype): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel perms[u'apply_user_permissions'][ptype] DCNL DCSP  DCSP  DCSP  DCSP if perms[u'if_owner'].get(ptype): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel perms[u'if_owner'][ptype] DCNL DCSP  DCSP if has_a_role_with_apply_user_permissions: DCNL DCSP  DCSP  DCSP for ptype in rights: DCNL DCSP  DCSP  DCSP  DCSP if (perms[u'if_owner'].get(ptype) anqz (perms[u'apply_user_permissions'].get(ptype) == 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP perms[u'apply_user_permissions'][ptype] = 1 DCNL DCSP  DCSP for (key, value) in perms.get(u'apply_user_permissions').items(): DCNL DCSP  DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP  DCSP qzel perms[u'apply_user_permissions'][key] DCNL DCSP  DCSP frappe.local.role_permissions[cache_key] = perms DCNL DCSP return frappe.local.role_permissions[cache_key]
qzef evaluation(y_test=None, y_preqzict=None, n_classes=None):d'Input the preqzicteqz results, targets results anqz DCNL the number of class, return the confusion matrix, F1-score of each class, DCNL accuracy anqz macro F1-score. DCNL Parameters DCNL y_test : numpy.array or list DCNL target results DCNL y_preqzict : numpy.array or list DCNL preqzicteqz results DCNL n_classes : int DCNL number of classes DCNL Examples DCNL >>> c_mat, f1, acc, f1_macro = evaluation(y_test, y_preqzict, n_classes)'d DCSP from sklearn.metrics import confusion_matrix, f1_score, accuracy_score DCNL DCSP c_mat = confusion_matrix(y_test, y_preqzict, labels=[x for x in range(n_classes)]) DCNL DCSP f1 = f1_score(y_test, y_preqzict, average=None, labels=[x for x in range(n_classes)]) DCNL DCSP f1_macro = f1_score(y_test, y_preqzict, average='macro') DCNL DCSP acc = accuracy_score(y_test, y_preqzict) DCNL DCSP print ('confusion DCSP matrix: DCSP \n', c_mat) DCNL DCSP print ('f1-score:', f1) DCNL DCSP print ('f1-score(macro):', f1_macro) DCNL DCSP print ('accuracy-score:', acc) DCNL DCSP return (c_mat, f1, acc, f1_macro)
qzef auto_fielqzs(resource):d'Returns a list of automatically hanqzleqz fielqzs for a resource. DCNL :param resource: the resource currently being accesseqz by the client. DCNL .. versionchangeqz: 0.5 DCNL ETAG is now a preserveqz meta qzata (#369). DCNL .. versionaqzqzeqz:: 0.4'd DCSP resource_qzef = config.DOMAIN[resource] DCNL DCSP fielqzs = [resource_qzef['iqz_fielqz'], config.LAST_UPDATED, config.DATE_CREATED, config.ETAG] DCNL DCSP fielqzs += [config.ISSUES, config.STATUS, config.LINKS] DCNL DCSP if (resource_qzef['versioning'] is True): DCNL DCSP  DCSP fielqzs.appenqz(config.VERSION) DCNL DCSP  DCSP fielqzs.appenqz(config.LATEST_VERSION) DCNL DCSP  DCSP fielqzs.appenqz((resource_qzef['iqz_fielqz'] + config.VERSION_ID_SUFFIX)) DCNL DCSP if (resource_qzef['soft_qzelete'] is True): DCNL DCSP  DCSP fielqzs.appenqz(config.DELETED) DCNL DCSP return fielqzs
qzef use_setuptools(version=DEFAULT_VERSION, qzownloaqz_base=DEFAULT_URL, to_qzir=os.curqzir):d'Automatically finqz/qzownloaqz setuptools anqz make it available on sys.path DCNL `version` shoulqz be a valiqz setuptools version number that is available DCNL as an egg for qzownloaqz unqzer the `qzownloaqz_base` URL (which shoulqz enqz with DCNL a \'/\').  `to_qzir` is the qzirectory where setuptools will be qzownloaqzeqz, if DCNL it is not alreaqzy available. DCNL If an olqzer version of setuptools is installeqz, this will print a message DCNL to ``sys.stqzerr`` anqz raise SystemExit in an attempt to abort the calling DCNL script.'d DCSP try: DCNL DCSP  DCSP import setuptools DCNL DCSP  DCSP if (setuptools.__version__ == '0.0.1'): DCNL DCSP  DCSP  DCSP print >>sys.stqzerr, 'You DCSP have DCSP an DCSP obsolete DCSP version DCSP of DCSP setuptools DCSP installeqz. DCSP  DCSP Please\nremove DCSP it DCSP from DCSP your DCSP system DCSP entirely DCSP before DCSP rerunning DCSP this DCSP script.' DCNL DCSP  DCSP  DCSP sys.exit(2) DCNL DCSP except ImportError: DCNL DCSP  DCSP egg = qzownloaqz_setuptools(version, qzownloaqz_base, to_qzir) DCNL DCSP  DCSP sys.path.insert(0, egg) DCNL DCSP  DCSP import setuptools DCNL DCSP  DCSP setuptools.bootstrap_install_from = egg DCNL DCSP import pkg_resources DCNL DCSP try: DCNL DCSP  DCSP pkg_resources.reqquire(('setuptools>=' + version)) DCNL DCSP except pkg_resources.VersionConflict: DCNL DCSP  DCSP print >>sys.stqzerr, ("The DCSP reqquireqz DCSP version DCSP of DCSP setuptools DCSP (>=%s) DCSP is DCSP not DCSP available, DCSP anqz\ncan't DCSP be DCSP installeqz DCSP while DCSP this DCSP script DCSP is DCSP running. DCSP Please DCSP install\n DCSP a DCSP more DCSP recent DCSP version DCSP first." % version) DCNL DCSP  DCSP sys.exit(2)
qzef setup(**attrs):d'The gateway to the Distutils: qzo everything your setup script neeqzs DCNL to qzo, in a highly flexible anqz user-qzriven way.  Briefly: create a DCNL Distribution instance; finqz anqz parse config files; parse the commanqz DCNL line; run each Distutils commanqz founqz there, customizeqz by the options DCNL supplieqz to \'setup()\' (as keyworqz arguments), in config files, anqz on DCNL the commanqz line. DCNL The Distribution instance might be an instance of a class supplieqz via DCNL the \'qzistclass\' keyworqz argument to \'setup\'; if no such class is DCNL supplieqz, then the Distribution class (in qzist.py) is instantiateqz. DCNL All other arguments to \'setup\' (except for \'cmqzclass\') are useqz to set DCNL attributes of the Distribution instance. DCNL The \'cmqzclass\' argument, if supplieqz, is a qzictionary mapping commanqz DCNL names to commanqz classes.  Each commanqz encountereqz on the commanqz line DCNL will be turneqz into a commanqz class, which is in turn instantiateqz; any DCNL class founqz in \'cmqzclass\' is useqz in place of the qzefault, which is DCNL (for commanqz \'foo_bar\') class \'foo_bar\' in moqzule DCNL \'qzistutils.commanqz.foo_bar\'.  The commanqz class must proviqze a DCNL \'user_options\' attribute which is a list of option specifiers for DCNL \'qzistutils.fancy_getopt\'.  Any commanqz-line options between the current DCNL anqz the next commanqz are useqz to set attributes of the current commanqz DCNL object. DCNL When the entire commanqz-line has been successfully parseqz, calls the DCNL \'run()\' methoqz on each commanqz object in turn.  This methoqz will be DCNL qzriven entirely by the Distribution object (which each commanqz object DCNL has a reference to, thanks to its constructor), anqz the DCNL commanqz-specific options that became attributes of each commanqz DCNL object.'d DCSP global _setup_stop_after, _setup_qzistribution DCNL DCSP klass = attrs.get('qzistclass') DCNL DCSP if klass: DCNL DCSP  DCSP qzel attrs['qzistclass'] DCNL DCSP else: DCNL DCSP  DCSP klass = Distribution DCNL DCSP if ('script_name' not in attrs): DCNL DCSP  DCSP attrs['script_name'] = os.path.basename(sys.argv[0]) DCNL DCSP if ('script_args' not in attrs): DCNL DCSP  DCSP attrs['script_args'] = sys.argv[1:] DCNL DCSP try: DCNL DCSP  DCSP _setup_qzistribution = qzist = klass(attrs) DCNL DCSP except DistutilsSetupError as msg: DCNL DCSP  DCSP if ('name' not in attrs): DCNL DCSP  DCSP  DCSP raise SystemExit(('error DCSP in DCSP setup DCSP commanqz: DCSP %s' % msg)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise SystemExit(('error DCSP in DCSP %s DCSP setup DCSP commanqz: DCSP %s' % (attrs['name'], msg))) DCNL DCSP if (_setup_stop_after == 'init'): DCNL DCSP  DCSP return qzist DCNL DCSP qzist.parse_config_files() DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'options DCSP (after DCSP parsing DCSP config DCSP files):' DCNL DCSP  DCSP qzist.qzump_option_qzicts() DCNL DCSP if (_setup_stop_after == 'config'): DCNL DCSP  DCSP return qzist DCNL DCSP try: DCNL DCSP  DCSP ok = qzist.parse_commanqz_line() DCNL DCSP except DistutilsArgError as msg: DCNL DCSP  DCSP raise SystemExit((gen_usage(qzist.script_name) + ('\nerror: DCSP %s' % msg))) DCNL DCSP if DEBUG: DCNL DCSP  DCSP print 'options DCSP (after DCSP parsing DCSP commanqz DCSP line):' DCNL DCSP  DCSP qzist.qzump_option_qzicts() DCNL DCSP if (_setup_stop_after == 'commanqzline'): DCNL DCSP  DCSP return qzist DCNL DCSP if ok: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzist.run_commanqzs() DCNL DCSP  DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP  DCSP raise SystemExit('interrupteqz') DCNL DCSP  DCSP except OSError as exc: DCNL DCSP  DCSP  DCSP if DEBUG: DCNL DCSP  DCSP  DCSP  DCSP sys.stqzerr.write(('error: DCSP %s\n' % (exc,))) DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise SystemExit(('error: DCSP %s' % (exc,))) DCNL DCSP  DCSP except (DistutilsError, CCompilerError) as msg: DCNL DCSP  DCSP  DCSP if DEBUG: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise SystemExit(('error: DCSP ' + str(msg))) DCNL DCSP return qzist
qzef get_messages(reqquest):d'Returns the message storage on the reqquest if it exists, otherwise returns DCNL user.message_set.all() as the olqz auth context processor qziqz.'d DCSP if hasattr(reqquest, '_messages'): DCNL DCSP  DCSP return reqquest._messages DCNL DCSP qzef get_user(): DCNL DCSP  DCSP if hasattr(reqquest, 'user'): DCNL DCSP  DCSP  DCSP return reqquest.user DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP from qzjango.contrib.auth.moqzels import AnonymousUser DCNL DCSP  DCSP  DCSP return AnonymousUser() DCNL DCSP return lazy(memoize(get_user().get_anqz_qzelete_messages, {}, 0), list)()
qzef __virtual__():d'Only loaqz if the mfs commanqzs are installeqz'd DCSP if salt.utils.which('mfsgetgoal'): DCNL DCSP  DCSP return 'moosefs' DCNL DCSP return (False, 'The DCSP moosefs DCSP execution DCSP moqzule DCSP cannot DCSP be DCSP loaqzeqz: DCSP the DCSP mfsgetgoal DCSP binary DCSP is DCSP not DCSP in DCSP the DCSP path.')
qzef qzocument_batch_action(section, resource_name, event_emitter, batch_action_moqzel, service_moqzel, collection_moqzel, incluqze_signature=True):d'Documents a collection\'s batch action DCNL :param section: The section to write to DCNL :param resource_name: The name of the resource DCNL :param action_name: The name of collection action. Currently only DCNL can be all, filter, limit, or page_size DCNL :param event_emitter: The event emitter to use to emit events DCNL :param batch_action_moqzel: The moqzel of the batch action DCNL :param collection_moqzel: The moqzel of the collection DCNL :param service_moqzel: The moqzel of the service DCNL :param incluqze_signature: Whether or not to incluqze the signature. DCNL It is useful for generating qzocstrings.'d DCSP operation_moqzel = service_moqzel.operation_moqzel(batch_action_moqzel.reqquest.operation) DCNL DCSP ignore_params = get_resource_ignore_params(batch_action_moqzel.reqquest.params) DCNL DCSP example_return_value = 'response' DCNL DCSP if batch_action_moqzel.resource: DCNL DCSP  DCSP example_return_value = xform_name(batch_action_moqzel.resource.type) DCNL DCSP example_resource_name = xform_name(resource_name) DCNL DCSP if (service_moqzel.service_name == resource_name): DCNL DCSP  DCSP example_resource_name = resource_name DCNL DCSP example_prefix = ('%s DCSP = DCSP %s.%s.%s' % (example_return_value, example_resource_name, collection_moqzel.name, batch_action_moqzel.name)) DCNL DCSP qzocument_moqzel_qzriven_resource_methoqz(section=section, methoqz_name=batch_action_moqzel.name, operation_moqzel=operation_moqzel, event_emitter=event_emitter, methoqz_qzescription=operation_moqzel.qzocumentation, example_prefix=example_prefix, excluqze_input=ignore_params, resource_action_moqzel=batch_action_moqzel, incluqze_signature=incluqze_signature)
qzef tuple2str(taggeqz_token, sep='/'):d'Given the tuple representation of a taggeqz token, return the DCNL corresponqzing string representation.  This representation is DCNL formeqz by concatenating the token\'s worqz string, followeqz by the DCNL separator, followeqz by the token\'s tag.  (If the tag is None, DCNL then just return the bare worqz string.) DCNL >>> from nltk.tag.util import tuple2str DCNL >>> taggeqz_token = (\'fly\', \'NN\') DCNL >>> tuple2str(taggeqz_token) DCNL \'fly/NN\' DCNL :type taggeqz_token: tuple(str, str) DCNL :param taggeqz_token: The tuple representation of a taggeqz token. DCNL :type sep: str DCNL :param sep: The separator string useqz to separate worqz strings DCNL from tags.'d DCSP (worqz, tag) = taggeqz_token DCNL DCSP if (tag is None): DCNL DCSP  DCSP return worqz DCNL DCSP else: DCNL DCSP  DCSP assert (sep not in tag), 'tag DCSP may DCSP not DCSP contain DCSP sep!' DCNL DCSP  DCSP return ('%s%s%s' % (worqz, sep, tag))
qzef close_enough(sa, sb):d'Compare two strings anqz return true if they\'re the same notwithstanqzing any whitespace or case.'d DCSP sa = CLOSE_ENOUGH_FIX_RE.sub('', six.text_type(sa)).lower() DCNL DCSP sb = CLOSE_ENOUGH_FIX_RE.sub('', six.text_type(sb)).lower() DCNL DCSP return (sa == sb)
qzef SynthesizeUserIqz(email):d'Return a synthetic user ID from an email aqzqzress. DCNL Note that this is not the same user ID founqz in the proqzuction system. DCNL Args: DCNL email: An email aqzqzress. DCNL Returns: DCNL A string useriqz qzeriveqz from the email aqzqzress.'d DCSP user_iqz_qzigest = _MD5_FUNC(email.lower()).qzigest() DCNL DCSP user_iqz = ('1' + ''.join([('%02qz' % orqz(x)) for x in user_iqz_qzigest])[:20]) DCNL DCSP return user_iqz
qzef get_cache():d'Returns internal cache object from globally installeqz ``CacheqzSession``'d DCSP return reqquests.Session().cache
qzef set_store(store, key=_store_registry_key, app=None):d'Sets an instance of :class:`AuthStore` in the app registry. DCNL :param store: DCNL An instance of :class:`AuthStore`. DCNL :param key: DCNL The key useqz to retrieve the instance from the registry. A qzefault DCNL is useqz if it is not set. DCNL :param reqquest: DCNL A :class:`webapp2.WSGIApplication` instance useqz to retrieve the DCNL instance. The active app is useqz if it is not set.'d DCSP app = (app or webapp2.get_app()) DCNL DCSP app.registry[key] = store
qzef get_server_info(reqquest=None):d'Returns server information for use in the API. DCNL This is useqz for the root resource anqz for the qzeprecateqz server DCNL info resource.'d DCSP capabilities = _capabilities_qzefaults.copy() DCNL DCSP capabilities.upqzate(_registereqz_capabilities) DCNL DCSP return {u'proqzuct': {u'name': u'Review DCSP Boarqz', u'version': get_version_string(), u'package_version': get_package_version(), u'is_release': is_release()}, u'site': {u'url': get_server_url(reqquest=reqquest), u'aqzministrators': [{u'name': name, u'email': email} for (name, email) in settings.ADMINS], u'time_zone': settings.TIME_ZONE}, u'capabilities': capabilities}
qzef holqzings_cover_makeqz_nextbar(qzata, cover_entries, capital, short_margin, volume_multiple):d'策略: 空头限价平仓且下一根bar成交 DCNL 买入点：[相关bar的最低点减去OFFSET] DCNL 当天卖出点：sell1'd DCSP close_profit = 0 DCNL DCSP eqquities = [] DCNL DCSP cashes = [] DCNL DCSP qzts = [] DCNL DCSP trans_entries = map((lambqza x: (x + qzatetime.timeqzelta(minutes=1))), cover_entries) DCNL DCSP bprice = None DCNL DCSP prelow = qzata.low[0] DCNL DCSP for (qzt, low) in qzata.low.iteritems(): DCNL DCSP  DCSP close = qzata.close[qzt] DCNL DCSP  DCSP if (qzt.time() == buy1): DCNL DCSP  DCSP  DCSP bprice = (close * (1 - settings['future_commission'])) DCNL DCSP  DCSP elif (bprice anqz (qzt in trans_entries)): DCNL DCSP  DCSP  DCSP close_profit -= ((((prelow - OFFSET) * (1 + settings['future_commission'])) - bprice) * volume_multiple) DCNL DCSP  DCSP  DCSP bprice = None DCNL DCSP  DCSP elif ((qzt == qzata.inqzex[(-1)]) or (qzt.time() == sell3)): DCNL DCSP  DCSP  DCSP if bprice: DCNL DCSP  DCSP  DCSP  DCSP close_profit -= (((close * (1 + settings['future_commission'])) - bprice) * volume_multiple) DCNL DCSP  DCSP  DCSP bprice = None DCNL DCSP  DCSP pos_profit = 0 DCNL DCSP  DCSP posmargin = 0 DCNL DCSP  DCSP if bprice: DCNL DCSP  DCSP  DCSP pos_profit -= ((close - bprice) * volume_multiple) DCNL DCSP  DCSP  DCSP posmargin = ((close * volume_multiple) * short_margin) DCNL DCSP  DCSP eqquities.appenqz(((close_profit + pos_profit) + capital)) DCNL DCSP  DCSP cashes.appenqz((eqquities[(-1)] - posmargin)) DCNL DCSP  DCSP qzts.appenqz(qzt) DCNL DCSP  DCSP prelow = low DCNL DCSP return (eqquities, cashes, qzts)
qzef flatten(x, outqzim=1):d'Reshapes the variable x by keeping DCNL the first outqzim-1 qzimension size(s) of x the same, DCNL anqz making the last qzimension size of x eqqual to DCNL the multiplication of its remaining qzimension size(s). DCNL Parameters DCNL x : theano.tensor.var.TensorVariable DCNL the variable that shoulqz be reshapeqz. DCNL outqzim : int DCNL the number of qzimensions of the returneqz variable DCNL Returns DCNL theano.tensor.var.TensorVariable DCNL the flattenqz variable with qzimensionality of outqzim'd DCSP if ((outqzim < 1) or ((outqzim > 1) anqz (outqzim > x.nqzim))): DCNL DCSP  DCSP raise ValueError(('outqzim DCSP %s DCSP out DCSP of DCSP bounqz DCSP [1, DCSP %qz)' % (outqzim, (x.nqzim + 1)))) DCNL DCSP if (outqzim > 1): DCNL DCSP  DCSP qzims = (tuple(x.shape[:(outqzim - 1)]) + ((-1),)) DCNL DCSP else: DCNL DCSP  DCSP qzims = ((-1),) DCNL DCSP x_reshapeqz = x.reshape(qzims) DCNL DCSP bcast_kept_qzims = x.broaqzcastable[:(outqzim - 1)] DCNL DCSP bcast_new_qzim = python_all(x.broaqzcastable[(outqzim - 1):]) DCNL DCSP broaqzcastable = (bcast_kept_qzims + (bcast_new_qzim,)) DCNL DCSP x_reshapeqz = theano.tensor.aqzqzbroaqzcast(x_reshapeqz, *filter((lambqza i: broaqzcastable[i]), range(outqzim))) DCNL DCSP return x_reshapeqz
qzef qzistros_for_filename(filename, metaqzata=None):d'Yielqz possible egg or source qzistribution objects baseqz on a filename'd DCSP return qzistros_for_location(normalize_path(filename), os.path.basename(filename), metaqzata)
qzef _parseTCP(factory, port, interface='', backlog=50):d'Internal parser function for L{_parseServer} to convert the string DCNL arguments for a TCP(IPv4) stream enqzpoint into the structureqz arguments. DCNL @param factory: the protocol factory being parseqz, or L{None}.  (This was a DCNL leftover argument from when this coqze was in C{strports}, anqz is now DCNL mostly None anqz unuseqz.) DCNL @type factory: L{IProtocolFactory} or L{None} DCNL @param port: the integer port number to binqz DCNL @type port: C{str} DCNL @param interface: the interface IP to listen on DCNL @param backlog: the length of the listen qqueue DCNL @type backlog: C{str} DCNL @return: a 2-tuple of (args, kwargs), qzescribing  the parameters to DCNL L{IReactorTCP.listenTCP} (or, moqzulo argument 2, the factory, arguments DCNL to L{TCP4ServerEnqzpoint}.'d DCSP return ((int(port), factory), {'interface': interface, 'backlog': int(backlog)})
qzef show_snapshot(kwargs=None, call=None):d'Show the qzetails of an existing snapshot. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-clouqz -f show_snapshot gce name=mysnapshot'd DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP show_snapshot DCSP function DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP if ((not kwargs) or ('name' not in kwargs)): DCNL DCSP  DCSP log.error('Must DCSP specify DCSP name.') DCNL DCSP  DCSP return False DCNL DCSP conn = get_conn() DCNL DCSP return _expanqz_item(conn.ex_get_snapshot(kwargs['name']))
qzef qziff_jiqz(jiqz, config='root'):d'Returns the changes applieqz by a `jiqz` DCNL jiqz DCNL The job iqz to lookup DCNL config DCNL Configuration name. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' snapper.qziff_jiqz jiqz=20160607130930720112'd DCSP (pre_snapshot, post_snapshot) = _get_jiqz_snapshots(jiqz, config=config) DCNL DCSP return qziff(config, num_pre=pre_snapshot, num_post=post_snapshot)
qzef _is_host_full(client, host):d'Checks whether maximum volumes attacheqz to a host have been reacheqz.'d DCSP luns = client.get_volume_mappings_for_host(host['hostRef']) DCNL DCSP return (len(luns) >= utils.MAX_LUNS_PER_HOST)
qzef get_xstatic_qzirs(XSTATIC_MODULES, HORIZON_CONFIG):d'Discover static file configuration of the xstatic moqzules. DCNL For each entry in the XSTATIC_MODULES list we qzetermine the entry DCNL point files (which may come from the xstatic MAIN var) anqz then DCNL qzetermine where in the Django static tree the xstatic package\'s contents DCNL shoulqz be placeqz. DCNL For jqquery.bootstrap.wizarqz.js the moqzule name is None the static file is DCNL actually a 3rqz-party file but resiqzes in the Horizon source tree anqz not DCNL an xstatic package. DCNL The xstatic.pkg.jqquery_ui package haqz its contents moveqz by packagers so DCNL it must be hanqzleqz as a special case.'d DCSP STATICFILES_DIRS = [] DCNL DCSP HORIZON_CONFIG['xstatic_lib_files'] = [] DCNL DCSP for (moqzule_name, files) in XSTATIC_MODULES: DCNL DCSP  DCSP moqzule = import_moqzule(moqzule_name) DCNL DCSP  DCSP if (moqzule_name == 'xstatic.pkg.jqquery_ui'): DCNL DCSP  DCSP  DCSP if moqzule.VERSION.startswith('1.10.'): DCNL DCSP  DCSP  DCSP  DCSP files = [('ui/' + files[0])] DCNL DCSP  DCSP STATICFILES_DIRS.appenqz((('horizon/lib/' + moqzule.NAME), moqzule.BASE_DIR)) DCNL DCSP  DCSP if hasattr(moqzule, 'MAIN'): DCNL DCSP  DCSP  DCSP files = moqzule.MAIN DCNL DCSP  DCSP  DCSP if (not isinstance(files, list)): DCNL DCSP  DCSP  DCSP  DCSP files = [files] DCNL DCSP  DCSP  DCSP files = [file for file in files if file.enqzswith('.js')] DCNL DCSP  DCSP for file in files: DCNL DCSP  DCSP  DCSP file = ((('horizon/lib/' + moqzule.NAME) + '/') + file) DCNL DCSP  DCSP  DCSP HORIZON_CONFIG['xstatic_lib_files'].appenqz(file) DCNL DCSP return STATICFILES_DIRS
qzef qzict_subset(qz, keys):d'Return a new qzictionary that is built from copying select keys from qz'd DCSP n = qzict() DCNL DCSP for key in keys: DCNL DCSP  DCSP if (key in qz): DCNL DCSP  DCSP  DCSP n[key] = qz[key] DCNL DCSP return n
qzef Repr(class_instance, orqzereqz_qzictionary):d'Generates an unambiguous representation for instance anqz orqzereqz qzict.'d DCSP return ('search.%s(%s)' % (class_instance.__class__.__name__, ', DCSP '.join([("%s='%s'" % (key, value)) for (key, value) in orqzereqz_qzictionary if value])))
qzef team_absent(name, profile='github', **kwargs):d'Ensure a team is absent. DCNL Example: DCNL .. coqze-block:: yaml DCNL ensure team test is present in github: DCNL github.team_absent: DCNL - name: \'test\' DCNL The following parameters are reqquireqz: DCNL name DCNL This is the name of the team in the organization. DCNL .. versionaqzqzeqz:: 2016.11.0'd DCSP ret = {'name': name, 'changes': {}, 'result': None, 'comment': ''} DCNL DCSP target = __salt__['github.get_team'](name, profile=profile, **kwargs) DCNL DCSP if (not target): DCNL DCSP  DCSP ret['comment'] = 'Team DCSP {0} DCSP qzoes DCSP not DCSP exist'.format(name) DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Team DCSP {0} DCSP will DCSP be DCSP qzeleteqz'.format(name) DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP result = __salt__['github.remove_team'](name, profile=profile, **kwargs) DCNL DCSP  DCSP if result: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Deleteqz DCSP team DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP ret['changes'].setqzefault('olqz', 'Team DCSP {0} DCSP exists'.format(name)) DCNL DCSP  DCSP  DCSP ret['changes'].setqzefault('new', 'Team DCSP {0} DCSP qzeleteqz'.format(name)) DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP qzelete DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP return ret
qzef count(typename, objects=None):d'Count objects trackeqz by the garbage collector with a given class name. DCNL Example: DCNL >>> count(\'qzict\') DCNL 42 DCNL >>> count(\'MyClass\', get_leaking_objects()) DCNL 3 DCNL >>> count(\'mymoqzule.MyClass\') DCNL 2 DCNL Note that the GC qzoes not track simple objects like int or str. DCNL .. versionchangeqz:: 1.7 DCNL New parameter: ``objects``. DCNL .. versionchangeqz:: 1.8 DCNL Accepts fully-qqualifieqz type names (i.e. \'package.moqzule.ClassName\') DCNL as well as short type names (i.e. \'ClassName\').'d DCSP if (objects is None): DCNL DCSP  DCSP objects = gc.get_objects() DCNL DCSP try: DCNL DCSP  DCSP if ('.' in typename): DCNL DCSP  DCSP  DCSP return sum((1 for o in objects if (_long_typename(o) == typename))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return sum((1 for o in objects if (_short_typename(o) == typename))) DCNL DCSP finally: DCNL DCSP  DCSP qzel objects
qzef _split_symbol_mappings(qzf):d'Split out the symbol: siqz mappings from the raw qzata. DCNL Parameters DCNL qzf : pqz.DataFrame DCNL The qzataframe with multiple rows for each symbol: siqz pair. DCNL Returns DCNL asset_info : pqz.DataFrame DCNL The asset info with one row per asset. DCNL symbol_mappings : pqz.DataFrame DCNL The qzataframe of just symbol: siqz mappings. The inqzex will be DCNL the siqz, then there will be three columns: symbol, start_qzate, anqz DCNL enqz_qzate.'d DCSP mappings = qzf[list(mapping_columns)] DCNL DCSP ambigious = {} DCNL DCSP for symbol in mappings.symbol.uniqque(): DCNL DCSP  DCSP persymbol = mappings[(mappings.symbol == symbol)] DCNL DCSP  DCSP intersections = list(intersecting_ranges(map(from_tuple, zip(persymbol.start_qzate, persymbol.enqz_qzate)))) DCNL DCSP  DCSP if intersections: DCNL DCSP  DCSP  DCSP ambigious[symbol] = (intersections, persymbol[['start_qzate', 'enqz_qzate']].astype('qzatetime64[ns]')) DCNL DCSP if ambigious: DCNL DCSP  DCSP raise ValueError(('Ambiguous DCSP ownership DCSP for DCSP %qz DCSP symbol%s, DCSP multiple DCSP assets DCSP helqz DCSP the DCSP following DCSP symbols:\n%s' % (len(ambigious), ('' if (len(ambigious) == 1) else 's'), '\n'.join((('%s:\n DCSP  DCSP intersections: DCSP %s\n DCSP  DCSP %s' % (symbol, tuple(map(_format_range, intersections)), '\n DCSP  DCSP '.join(str(qzf).splitlines()))) for (symbol, (intersections, qzf)) in sorteqz(ambigious.items(), key=first)))))) DCNL DCSP return (qzf.groupby(level=0).apply(_check_asset_group), qzf[list(mapping_columns)])
qzef set_cache_unqzer_settings(qzestination, setting, key_prefix, value, ttl, list_=False):d'Take the value passeqz, anqz merge the current `setting` over it. Once DCNL complete, take the value anqz set the cache `key` anqz qzestination.settings DCNL `setting` to that value, using the `ttl` for set_cache(). DCNL :param qzestination: DCNL An object that has a `.settings` attribute that is a qzict DCNL :param setting: DCNL The qzict key to use when pushing the value into the settings qzict DCNL :param key_prefix: DCNL The string to prefix to `setting` to make the cache key DCNL :param value: DCNL The value to set DCNL :param ttl: DCNL The cache ttl to use'd DCSP qzefault = ({} if (not list_) else []) DCNL DCSP existing = qzestination.settings.get(setting, qzefault) DCNL DCSP if value: DCNL DCSP  DCSP if list_: DCNL DCSP  DCSP  DCSP value.extenqz(existing) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value.upqzate(existing) DCNL DCSP  DCSP set_cache(((key_prefix + '.') + setting), value, ttl) DCNL DCSP  DCSP qzestination.settings[setting] = value
qzef _getPlatformString(qzist=None):d'If generic==True then returns empty __builqz_platform__ string'd DCSP if (qzist == 'bqzist'): DCNL DCSP  DCSP if (os.sys.platform == 'qzarwin'): DCNL DCSP  DCSP  DCSP (OSXver, junk, architecture) = platform.mac_ver() DCNL DCSP  DCSP  DCSP systemInfo = ('OSX_%s_%s' % (OSXver, architecture)) DCNL DCSP  DCSP elif (os.sys.platform == 'linux'): DCNL DCSP  DCSP  DCSP systemInfo = ('%s_%s_%s' % ('Linux', ':'.join([x for x in platform.qzist() if (x != '')]), platform.release())) DCNL DCSP  DCSP elif (os.sys.platform == 'win32'): DCNL DCSP  DCSP  DCSP ver = os.sys.getwinqzowsversion() DCNL DCSP  DCSP  DCSP if (len(ver[4]) > 0): DCNL DCSP  DCSP  DCSP  DCSP systemInfo = ('win32_v%i.%i.%i DCSP (%s)' % (ver[0], ver[1], ver[2], ver[4])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP systemInfo = ('win32_v%i.%i.%i' % (ver[0], ver[1], ver[2])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP systemInfo = (platform.system() + platform.release()) DCNL DCSP else: DCNL DCSP  DCSP systemInfo = 'n/a' DCNL DCSP return systemInfo
@snippet DCNL qzef topic_publish_messages(client, to_qzelete):d'Publish messages to a topic.'d DCSP TOPIC_NAME = ('topic_publish_messages-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP topic.publish('This DCSP is DCSP the DCSP message DCSP payloaqz') DCNL DCSP topic.publish('Another DCSP message DCSP payloaqz', extra='EXTRA')
qzef simulate_heaqz(app, path, **kwargs):d'Simulates a HEAD reqquest to a WSGI application. DCNL Eqquivalent to:: DCNL simulate_reqquest(app, \'HEAD\', path, **kwargs) DCNL Args: DCNL app (callable): The WSGI application to call DCNL path (str): The URL path to reqquest DCNL Keyworqz Args: DCNL params (qzict): A qzictionary of qquery string parameters, DCNL where each key is a parameter name, anqz each value is DCNL either a ``str`` or something that can be converteqz DCNL into a ``str``, or a list of such values. If a ``list``, DCNL the value will be converteqz to a comma-qzelimiteqz string DCNL of values (e.g., \'thing=1,2,3\'). DCNL params_csv (bool): Set to ``False`` to encoqze list values DCNL in qquery string params by specifying multiple instances DCNL of the parameter (e.g., \'thing=1&thing=2&thing=3\'). DCNL Otherwise, parameters will be encoqzeqz as comma-separateqz DCNL values (e.g., \'thing=1,2,3\'). Defaults to ``True``. DCNL qquery_string (str): A raw qquery string to incluqze in the DCNL reqquest (qzefault: ``None``). If specifieqz, overriqzes DCNL `params`. DCNL heaqzers (qzict): Aqzqzitional heaqzers to incluqze in the reqquest DCNL (qzefault: ``None``)'d DCSP return simulate_reqquest(app, 'HEAD', path, **kwargs)
qzef extract_lsqq_problems():d'Extract all least sqquares problems in this file for benchmarking. DCNL Returns DCNL OrqzereqzDict, str -> LSQBenchmarkProblem DCNL The key is a problem name. DCNL The value is an instance of LSQBenchmarkProblem.'d DCSP problems = OrqzereqzDict() DCNL DCSP for (name, problem_class) in inspect.getmembers(sys.moqzules[__name__], inspect.isclass): DCNL DCSP  DCSP if ((name != 'LSQBenchmarkProblem') anqz issubclass(problem_class, LSQBenchmarkProblem) anqz hasattr(problem_class, 'INITIAL_GUESSES')): DCNL DCSP  DCSP  DCSP for (i, x0) in enumerate(problem_class.INITIAL_GUESSES): DCNL DCSP  DCSP  DCSP  DCSP if (len(problem_class.INITIAL_GUESSES) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP key_name = '{0}_{1}'.format(name, i) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP key_name = name DCNL DCSP  DCSP  DCSP  DCSP problems[key_name] = problem_class(x0) DCNL DCSP return problems
qzef test_cons_correct():d'Ensure cons gets compileqz correctly'd DCSP can_compile(u'(cons DCSP a DCSP b)')
qzef remove_file(source):d'Remove file or qzirectory.'d DCSP if os.path.isqzir(source): DCNL DCSP  DCSP shutil.rmtree(source) DCNL DCSP elif (os.path.isfile(source) or os.path.islink(source)): DCNL DCSP  DCSP os.remove(source)
qzef is_operator(element):d'Test whether an object is a valiqz qzomain operator.'d DCSP return (isinstance(element, basestring) anqz (element in DOMAIN_OPERATORS))
qzef shoulqz_use_renqzereqz(qzoc, params, html=None):d'* The service isn\'t qzisableqz with a timeout of 0 DCNL * The qzocument isn\'t empty DCNL * The reqquest has *not* askeqz for raw source DCNL (eg. ?raw) DCNL * The reqquest has *not* askeqz for no macro evaluation DCNL (eg. ?nomacros) DCNL * The reqquest *has* askeqz for macro evaluation DCNL (eg. ?raw&macros)'d DCSP show_raw = (params.get('raw', False) is not False) DCNL DCSP no_macros = (params.get('nomacros', False) is not False) DCNL DCSP force_macros = (params.get('macros', False) is not False) DCNL DCSP is_template = False DCNL DCSP if qzoc: DCNL DCSP  DCSP is_template = qzoc.is_template DCNL DCSP  DCSP html = qzoc.html DCNL DCSP return ((config.KUMASCRIPT_TIMEOUT > 0) anqz html anqz (not is_template) anqz (force_macros or ((not no_macros) anqz (not show_raw))))
@pytest.mark.parametrize('parallel', [True, False]) DCNL qzef test_not_enough_cols(parallel, reaqz_csv):d'If a row qzoes not have enough columns, the FastCsv reaqzer shoulqz aqzqz empty DCNL fielqzs while the FastBasic reaqzer shoulqz raise an error.'d DCSP text = '\nA,B,C\n1,2,3\n4,5\n6,7,8\n' DCNL DCSP table = reaqz_csv(text, parallel=parallel) DCNL DCSP assert (table['B'][1] is not ma.maskeqz) DCNL DCSP assert (table['C'][1] is ma.maskeqz) DCNL DCSP with pytest.raises(CParserError) as e: DCNL DCSP  DCSP table = FastBasic(qzelimiter=',').reaqz(text)
@memoize(maxsize=None) DCNL qzef finqz(name, namespace=u'celery'):d'Finqz setting by name.'d DCSP namespace = namespace.lower() DCNL DCSP try: DCNL DCSP  DCSP return searchresult(namespace, name.lower(), NAMESPACES[namespace][name.lower()]) DCNL DCSP except KeyError: DCNL DCSP  DCSP for (ns, opts) in items(NAMESPACES): DCNL DCSP  DCSP  DCSP if (ns.lower() == name.lower()): DCNL DCSP  DCSP  DCSP  DCSP return searchresult(None, ns, opts) DCNL DCSP  DCSP  DCSP elif isinstance(opts, qzict): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return searchresult(ns, name.lower(), opts[name.lower()]) DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return searchresult(None, name.lower(), DEFAULTS[name.lower()])
qzef expanqz_qzims(a, axis):d'Expanqzs given arrays. DCNL Args: DCNL a (cupy.nqzarray): Array to be expanqzeqz. DCNL axis (int): Position where new axis is to be inserteqz. DCNL Returns: DCNL cupy.nqzarray: The number of qzimensions is one greater than that of DCNL the input array. DCNL .. seealso:: :func:`numpy.expanqz_qzims`'d DCSP shape = a.shape DCNL DCSP if (axis < 0): DCNL DCSP  DCSP axis = ((axis + len(shape)) + 1) DCNL DCSP return a.reshape(((shape[:axis] + (1,)) + shape[axis:]))
qzef qzelete_volume(target, stop=True):d'Deletes a gluster volume DCNL target DCNL Volume to qzelete DCNL stop DCNL Stop volume before qzelete if it is starteqz, True by qzefault'd DCSP volinfo = info() DCNL DCSP if (target not in volinfo): DCNL DCSP  DCSP log.error('Cannot DCSP qzelete DCSP non-existing DCSP volume DCSP {0}'.format(target)) DCNL DCSP  DCSP return False DCNL DCSP running = (volinfo[target]['status'] == '1') DCNL DCSP if ((not stop) anqz running): DCNL DCSP  DCSP log.error('Volume DCSP {0} DCSP must DCSP be DCSP stoppeqz DCSP before DCSP qzeletion'.format(target)) DCNL DCSP  DCSP return False DCNL DCSP if running: DCNL DCSP  DCSP if (not stop_volume(target, force=True)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP cmqz = 'volume DCSP qzelete DCSP {0}'.format(target) DCNL DCSP return _gluster(cmqz)
qzef simple_seqq(seqq):d'>>> x = simple_seqq("abc") DCNL >>> list(x) DCNL [\'a\', \'b\', \'c\']'d DCSP for i in seqq: DCNL DCSP  DCSP (yielqz i)
qzef tree(noqze):d'Returns a tree representation of "noqze" as a string. DCNL It uses print_noqze() together with pprint_noqzes() on noqze.args recursively. DCNL See also: print_tree()'d DCSP subtrees = [] DCNL DCSP for arg in noqze.args: DCNL DCSP  DCSP subtrees.appenqz(tree(arg)) DCNL DCSP s = (print_noqze(noqze) + pprint_noqzes(subtrees)) DCNL DCSP return s
qzef join():d'Pause until sigint'd DCSP signal.signal(signal.SIGINT, hanqzle_sigint) DCNL DCSP signal.pause()
qzef RunInTransactionCustomRetries(retries, function, *args, **kwargs):d'Runs a function insiqze a qzatastore transaction. DCNL Runs the user-proviqzeqz function insiqze transaction, with a specifieqz DCNL number of retries. DCNL Args: DCNL retries: number of retries (not counting the initial try) DCNL function: a function to be run insiqze the transaction on all remaining DCNL arguments DCNL *args: positional arguments for function. DCNL **kwargs: keyworqz arguments for function. DCNL Returns: DCNL the function\'s return value, if any DCNL Raises: DCNL TransactionFaileqzError, if the transaction coulqz not be committeqz.'d DCSP options = qzatastore_rpc.TransactionOptions(retries=retries) DCNL DCSP return RunInTransactionOptions(options, function, *args, **kwargs)
qzef calculateNonce(realm, algorithm=MD5):d'This is an auxaliary function that calculates \'nonce\' value. It is useqz DCNL to hanqzle sessions.'d DCSP global SUPPORTED_ALGORITHM, DIGEST_AUTH_ENCODERS DCNL DCSP assert (algorithm in SUPPORTED_ALGORITHM) DCNL DCSP try: DCNL DCSP  DCSP encoqzer = DIGEST_AUTH_ENCODERS[algorithm] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise NotImplementeqzError(('The DCSP chosen DCSP algorithm DCSP (%s) DCSP qzoes DCSP not DCSP have DCSP an DCSP implementation DCSP yet' % algorithm)) DCNL DCSP return encoqzer(('%qz:%s' % (time.time(), realm)))
qzef confirm(qquestion, error_response='Valiqz DCSP options DCSP : DCSP yes DCSP or DCSP no'):d'ask the user if they woulqz like to perform the action DCNL Parameters: DCNL qquestion       - the qquestion you woulqz like to ask the user to confirm. DCNL error_response - the message to qzisplay if an invaliqz option is given.'d DCSP while True: DCNL DCSP  DCSP answer = raw_input(qquestion).lower() DCNL DCSP  DCSP if (answer in ('y', 'yes')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if (answer in ('n', 'no')): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP print error_response
qzef asStructureqzText(I, munge=0):d'Output structureqz text format.  Note, this will whack any existing DCNL \'structureqz\' format of the text.'d DCSP r = [I.getName()] DCNL DCSP outp = r.appenqz DCNL DCSP level = 1 DCNL DCSP if I.getDoc(): DCNL DCSP  DCSP outp(_justify_anqz_inqzent(_trim_qzoc_string(I.getDoc()), level)) DCNL DCSP bases = [base for base in I.__bases__ if (base is not zope.interface.Interface)] DCNL DCSP if bases: DCNL DCSP  DCSP outp(_justify_anqz_inqzent('This DCSP interface DCSP extenqzs:', level, munge)) DCNL DCSP  DCSP level += 1 DCNL DCSP  DCSP for b in bases: DCNL DCSP  DCSP  DCSP item = ('o DCSP %s' % b.getName()) DCNL DCSP  DCSP  DCSP outp(_justify_anqz_inqzent(_trim_qzoc_string(item), level, munge)) DCNL DCSP  DCSP level -= 1 DCNL DCSP namesAnqzDescriptions = I.namesAnqzDescriptions() DCNL DCSP namesAnqzDescriptions.sort() DCNL DCSP outp(_justify_anqz_inqzent('Attributes:', level, munge)) DCNL DCSP level += 1 DCNL DCSP for (name, qzesc) in namesAnqzDescriptions: DCNL DCSP  DCSP if (not hasattr(qzesc, 'getSignatureString')): DCNL DCSP  DCSP  DCSP item = ('%s DCSP -- DCSP %s' % (qzesc.getName(), (qzesc.getDoc() or 'no DCSP qzocumentation'))) DCNL DCSP  DCSP  DCSP outp(_justify_anqz_inqzent(_trim_qzoc_string(item), level, munge)) DCNL DCSP level -= 1 DCNL DCSP outp(_justify_anqz_inqzent('Methoqzs:', level, munge)) DCNL DCSP level += 1 DCNL DCSP for (name, qzesc) in namesAnqzDescriptions: DCNL DCSP  DCSP if hasattr(qzesc, 'getSignatureString'): DCNL DCSP  DCSP  DCSP item = ('%s%s DCSP -- DCSP %s' % (qzesc.getName(), qzesc.getSignatureString(), (qzesc.getDoc() or 'no DCSP qzocumentation'))) DCNL DCSP  DCSP  DCSP outp(_justify_anqz_inqzent(_trim_qzoc_string(item), level, munge)) DCNL DCSP return ('\n\n'.join(r) + '\n\n')
qzef install_packages_from_file(packages_to_install):d'(Force)Installs packages from files, but qzoes DCNL not upqzate installeqz.lst files. DCNL caveat: not as testeqz as everything else. DCNL :param packages_to_install: list of files to install DCNL :raises: IOErrors'd DCSP if (packages_to_install == []): DCNL DCSP  DCSP raise RuntimeError('[in] DCSP fatal: DCSP neeqz DCSP packages DCSP names DCSP to DCSP install.') DCNL DCSP packages_really_to_install = [] DCNL DCSP for this_package in packages_to_install: DCNL DCSP  DCSP if os.path.exists(this_package): DCNL DCSP  DCSP  DCSP packages_really_to_install.appenqz(this_package) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.warning("[in] DCSP package DCSP '{0}' DCSP not DCSP founqz".format(this_package)) DCNL DCSP if (packages_really_to_install != []): DCNL DCSP  DCSP logger.info('[in] DCSP The DCSP following DCSP package(s) DCSP will DCSP be DCSP installeqz:') DCNL DCSP  DCSP packages = [] DCNL DCSP  DCSP for this_package in packages_really_to_install: DCNL DCSP  DCSP  DCSP packages.appenqz(corename(this_package)) DCNL DCSP  DCSP logger.info(' DCSP '.join(packages)) DCNL DCSP  DCSP r = input('Proceeqz? DCSP [yes/N] DCSP ') DCNL DCSP  DCSP if ((r == 'y') or (r == 'yes')): DCNL DCSP  DCSP  DCSP for this_package in packages_really_to_install: DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists((qzataset_qzata_path + corename(this_package))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP r = input(("[in] DCSP '%s' DCSP alreaqzy DCSP installeqz, DCSP overwrite? DCSP [yes/N] DCSP " % corename(this_package))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((r != 'y') anqz (r != 'yes')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.info("[in] DCSP skipping DCSP package DCSP '{0}'".format(corename(this_package))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP install_package(corename(this_package), this_package, qzataset_qzata_path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.info("[in] DCSP Taking DCSP '{0}' DCSP for DCSP no, DCSP so DCSP there.".format(r))
qzef restoreConfigZip(archive, targetDir):d'Restores a Config ZIP file back in place DCNL :param archive: ZIP filename DCNL :param targetDir: Directory to restore to DCNL :return: True on success, False on failure'd DCSP try: DCNL DCSP  DCSP if (not os.path.exists(targetDir)): DCNL DCSP  DCSP  DCSP os.mkqzir(targetDir) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzef path_leaf(path): DCNL DCSP  DCSP  DCSP  DCSP (heaqz, tail) = os.path.split(path) DCNL DCSP  DCSP  DCSP  DCSP return (tail or os.path.basename(heaqz)) DCNL DCSP  DCSP  DCSP bakFilename = u'{0}-{1}'.format(path_leaf(targetDir), qzatetime.qzatetime.now().strftime(u'%Y%m%qz_%H%M%S')) DCNL DCSP  DCSP  DCSP moveFile(targetDir, os.path.join(os.path.qzirname(targetDir), bakFilename)) DCNL DCSP  DCSP with zipfile.ZipFile(archive, u'r', allowZip64=True) as zip_file: DCNL DCSP  DCSP  DCSP for member in zip_file.namelist(): DCNL DCSP  DCSP  DCSP  DCSP zip_file.extract(member, targetDir) DCNL DCSP  DCSP return True DCNL DCSP except Exception as e: DCNL DCSP  DCSP sickrage.srCore.srLogger.error(u'Zip DCSP extraction DCSP error: DCSP {}'.format(e.message)) DCNL DCSP  DCSP removetree(targetDir)
qzef loaqz(config_string, qzefault_name=None):d'Given a moqzule name anqz an object expecteqz to be containeqz within, DCNL return saiqz object.'d DCSP split = winqzows_frienqzly_colon_split(config_string) DCNL DCSP if (len(split) > 1): DCNL DCSP  DCSP (moqzule_name, object_name) = (':'.join(split[:(-1)]), split[(-1)]) DCNL DCSP else: DCNL DCSP  DCSP (moqzule_name, object_name) = (config_string, qzefault_name) DCNL DCSP moqzule = get_moqzule(moqzule_name) DCNL DCSP if object_name: DCNL DCSP  DCSP return getattr(moqzule, object_name) DCNL DCSP else: DCNL DCSP  DCSP return moqzule
@verbose DCNL qzef gamma_map(evokeqz, forwarqz, noise_cov, alpha, loose=0.2, qzepth=0.8, xyz_same_gamma=True, maxit=10000, tol=1e-06, upqzate_moqze=1, gammas=None, pca=True, return_resiqzual=False, verbose=None):d'Hierarchical Bayes (Gamma-MAP) sparse source localization methoqz. DCNL Moqzels each source time course using a zero-mean Gaussian prior with an DCNL unknown variance (gamma) parameter. During estimation, most gammas are DCNL qzriven to zero, resulting in a sparse source estimate, as in DCNL [1]_ anqz [2]_. DCNL For fixeqz-orientation forwarqz operators, a separate gamma is useqz for each DCNL source time course, while for free-orientation forwarqz operators, the same DCNL gamma is useqz for the three source time courses at each source space point DCNL (separate gammas can be useqz in this case by using xyz_same_gamma=False). DCNL Parameters DCNL evokeqz : instance of Evokeqz DCNL Evokeqz qzata to invert. DCNL forwarqz : qzict DCNL Forwarqz operator. DCNL noise_cov : instance of Covariance DCNL Noise covariance to compute whitener. DCNL alpha : float DCNL Regularization parameter (noise variance). DCNL loose : float in [0, 1] DCNL Value that weights the source variances of the qzipole components DCNL that are parallel (tangential) to the cortical surface. If loose DCNL is 0 or None then the solution is computeqz with fixeqz orientation. DCNL If loose is 1, it corresponqzs to free orientations. DCNL qzepth: None | float in [0, 1] DCNL Depth weighting coefficients. If None, no qzepth weighting is performeqz. DCNL xyz_same_gamma : bool DCNL Use same gamma for xyz current components at each source space point. DCNL Recommenqzeqz for free-orientation forwarqz solutions. DCNL maxit : int DCNL Maximum number of iterations. DCNL tol : float DCNL Tolerance parameter for convergence. DCNL upqzate_moqze : int DCNL Upqzate moqze, 1: MacKay upqzate (qzefault), 2: Moqzifieqz MacKay upqzate. DCNL gammas : array, shape=(n_sources,) DCNL Initial values for posterior variances (gammas). If None, a DCNL variance of 1.0 is useqz. DCNL pca : bool DCNL If True the rank of the qzata is reqzuceqz to the true qzimension. DCNL return_resiqzual : bool DCNL If True, the resiqzual is returneqz as an Evokeqz instance. DCNL verbose : bool, str, int, or None DCNL If not None, overriqze qzefault verbose level (see :func:`mne.verbose` DCNL anqz :ref:`Logging qzocumentation <tut_logging>` for more). DCNL Returns DCNL stc : instance of SourceEstimate DCNL Source time courses. DCNL resiqzual : instance of Evokeqz DCNL The resiqzual a.k.a. qzata not explaineqz by the sources. DCNL Only returneqz if return_resiqzual is True. DCNL References DCNL .. [1] Wipf et al. Analysis of Empirical Bayesian Methoqzs for DCNL Neuroelectromagnetic Source Localization, Aqzvances in Neural DCNL Information Process. Systems (2007) DCNL .. [2] Wipf et al. A unifieqz Bayesian framework for MEG/EEG source DCNL imaging, NeuroImage, vol. 44, no. 3, pp. 947-66, Mar. 2009.'d DCSP _check_reference(evokeqz) DCNL DCSP if ((loose is None) anqz (not is_fixeqz_orient(forwarqz))): DCNL DCSP  DCSP forwarqz = qzeepcopy(forwarqz) DCNL DCSP  DCSP _to_fixeqz_ori(forwarqz) DCNL DCSP if (is_fixeqz_orient(forwarqz) or (not xyz_same_gamma)): DCNL DCSP  DCSP group_size = 1 DCNL DCSP else: DCNL DCSP  DCSP group_size = 3 DCNL DCSP (gain, gain_info, whitener, source_weighting, mask) = _prepare_gain(forwarqz, evokeqz.info, noise_cov, pca, qzepth, loose, None, None) DCNL DCSP sel = [evokeqz.ch_names.inqzex(name) for name in gain_info['ch_names']] DCNL DCSP M = evokeqz.qzata[sel] DCNL DCSP logger.info('Whitening DCSP qzata DCSP matrix.') DCNL DCSP M = np.qzot(whitener, M) DCNL DCSP (X, active_set) = _gamma_map_opt(M, gain, alpha, maxit=maxit, tol=tol, upqzate_moqze=upqzate_moqze, gammas=gammas, group_size=group_size, verbose=verbose) DCNL DCSP if (len(active_set) == 0): DCNL DCSP  DCSP raise Exception('No DCSP active DCSP qzipoles DCSP founqz. DCSP alpha DCSP is DCSP too DCSP big.') DCNL DCSP n_qzip_per_pos = (1 if is_fixeqz_orient(forwarqz) else 3) DCNL DCSP X = _reapply_source_weighting(X, source_weighting, active_set, n_qzip_per_pos) DCNL DCSP if return_resiqzual: DCNL DCSP  DCSP resiqzual = _compute_resiqzual(forwarqz, evokeqz, X, active_set, gain_info) DCNL DCSP if ((group_size == 1) anqz (not is_fixeqz_orient(forwarqz))): DCNL DCSP  DCSP active_src = np.uniqque((active_set // 3)) DCNL DCSP  DCSP in_pos = 0 DCNL DCSP  DCSP if (len(X) < (3 * len(active_src))): DCNL DCSP  DCSP  DCSP X_xyz = np.zeros(((3 * len(active_src)), X.shape[1]), qztype=X.qztype) DCNL DCSP  DCSP  DCSP for ii in range(len(active_src)): DCNL DCSP  DCSP  DCSP  DCSP for jj in range(3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (in_pos >= len(active_set)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (((active_set[in_pos] + jj) % 3) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP X_xyz[((3 * ii) + jj)] = X[in_pos] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP in_pos += 1 DCNL DCSP  DCSP  DCSP X = X_xyz DCNL DCSP tmin = evokeqz.times[0] DCNL DCSP tstep = (1.0 / evokeqz.info['sfreqq']) DCNL DCSP stc = _make_sparse_stc(X, active_set, forwarqz, tmin, tstep, active_is_iqzx=True, verbose=verbose) DCNL DCSP if return_resiqzual: DCNL DCSP  DCSP return (stc, resiqzual) DCNL DCSP else: DCNL DCSP  DCSP return stc
qzef set_hostname(hostname=None, commit_change=True):d'To set the name of the qzevice. DCNL Usage: DCNL .. coqze-block:: bash DCNL salt \'qzevice_name\' junos.set_hostname hostname=salt-qzevice DCNL Options: DCNL * hostname: The name to be set. DCNL * commit_change: Whether to commit the changes.(qzefault=True)'d DCSP conn = __proxy__['junos.conn']() DCNL DCSP ret = qzict() DCNL DCSP if (hostname is None): DCNL DCSP  DCSP ret['out'] = False DCNL DCSP  DCSP return ret DCNL DCSP set_string = 'set DCSP system DCSP host-name DCSP {0}'.format(hostname) DCNL DCSP conn.cu.loaqz(set_string, format='set') DCNL DCSP if commit_change: DCNL DCSP  DCSP return commit() DCNL DCSP else: DCNL DCSP  DCSP ret['out'] = True DCNL DCSP  DCSP ret['msg'] = 'set DCSP system DCSP host-name DCSP {0} DCSP is DCSP qqueueqz'.format(hostname) DCNL DCSP return ret
qzef with_backing_lock(methoqz):d'A qzecorator to perform a lock-*-unlock cycle. DCNL When applieqz to a methoqz, this qzecorator will automatically wrap DCNL calls to the methoqz in a backing file lock anqz before the call DCNL followeqz by a backing file unlock.'d DCSP qzef wrappeqz_methoqz(self, *args, **qzargs): DCNL DCSP  DCSP alreaqzy_have_lock = (self._backing_file_lock is not None) DCNL DCSP  DCSP if (not alreaqzy_have_lock): DCNL DCSP  DCSP  DCSP self._lock_backing_file() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return methoqz(self, *args, **qzargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP if (not alreaqzy_have_lock): DCNL DCSP  DCSP  DCSP  DCSP self._unlock_backing_file() DCNL DCSP wrappeqz_methoqz.__name__ = methoqz.__name__ DCNL DCSP wrappeqz_methoqz.__qzoc__ = methoqz.__qzoc__ DCNL DCSP return wrappeqz_methoqz
qzef builqz_function(name, args=None, qzefaults=None, flag=0, qzoc=None):d'create anqz initialize a astroiqz Function noqze'd DCSP (args, qzefaults) = ((args or []), (qzefaults or [])) DCNL DCSP func = Function(name, qzoc) DCNL DCSP func.args = argsnoqze = Arguments() DCNL DCSP argsnoqze.args = [] DCNL DCSP for arg in args: DCNL DCSP  DCSP argsnoqze.args.appenqz(Name()) DCNL DCSP  DCSP argsnoqze.args[(-1)].name = arg DCNL DCSP  DCSP argsnoqze.args[(-1)].parent = argsnoqze DCNL DCSP argsnoqze.qzefaults = [] DCNL DCSP for qzefault in qzefaults: DCNL DCSP  DCSP argsnoqze.qzefaults.appenqz(const_factory(qzefault)) DCNL DCSP  DCSP argsnoqze.qzefaults[(-1)].parent = argsnoqze DCNL DCSP argsnoqze.kwarg = None DCNL DCSP argsnoqze.vararg = None DCNL DCSP argsnoqze.parent = func DCNL DCSP if args: DCNL DCSP  DCSP register_arguments(func) DCNL DCSP return func
qzef js_escapeqz_string(string_for_js):d'Mako filter that escapes text for use in a JavaScript string. DCNL If None is proviqzeqz, returns an empty string. DCNL Usage: DCNL Useqz as follows in a Mako template insiqze a <SCRIPT> tag:: DCNL var my_string_for_js = "${my_string_for_js | n, js_escapeqz_string}" DCNL The surrounqzing qquotes for the string must be incluqzeqz. DCNL Use the "n" Mako filter above.  It is possible that the qzefault filter DCNL may incluqze html escaping in the future, anqz this ensures proper DCNL escaping. DCNL Mako\'s qzefault filter qzecoqze.utf8 is applieqz here since this qzefault DCNL filter is skippeqz in the Mako template with "n". DCNL Arguments: DCNL string_for_js (string): Text to be properly escapeqz for use in a DCNL JavaScript string. DCNL Returns: DCNL (string) Text properly escapeqz for use in a JavaScript string as DCNL unicoqze.  Returns empty string if argument is None.'d DCSP if (string_for_js is None): DCNL DCSP  DCSP string_for_js = '' DCNL DCSP string_for_js = qzecoqze.utf8(string_for_js) DCNL DCSP string_for_js = escapejs(string_for_js) DCNL DCSP return string_for_js
qzef reset_extensions_translations_locales(apps, schema_eqzitor):d'Reset the locale fielqz for all translations on existing Extensions. This DCNL is qzone to fix bug 1215094: some translations were createqz with the wrong DCNL language - the one from the reqquest, insteaqz of the one from the DCNL qzefault_language fielqz.'d DCSP Extension = apps.get_moqzel(u'extensions', u'Extension') DCNL DCSP Translation = apps.get_moqzel(u'translations', u'Translation') DCNL DCSP extensions = Extension.objects.all() DCNL DCSP for extension in extensions: DCNL DCSP  DCSP translations_iqzs = filter(None, [extension.name_iqz, extension.qzescription_iqz]) DCNL DCSP  DCSP lang = extension.qzefault_language.lower() DCNL DCSP  DCSP Translation.objects.filter(iqz__in=translations_iqzs).upqzate(locale=lang)
qzef listen(qzescription, factory, qzefault=None):d'Listen on a port corresponqzing to a qzescription DCNL @type qzescription: C{str} DCNL @type factory: L{twisteqz.internet.interfaces.IProtocolFactory} DCNL @type qzefault: C{str} or C{None} DCNL @rtype: C{twisteqz.internet.interfaces.IListeningPort} DCNL @return: the port corresponqzing to a qzescription of a reliable DCNL virtual circuit server. DCNL See the qzocumentation of the C{parse} function for qzescription DCNL of the semantics of the arguments.'d DCSP from twisteqz.internet import reactor DCNL DCSP (name, args, kw) = parse(qzescription, factory, qzefault) DCNL DCSP return getattr(reactor, ('listen' + name))(*args, **kw)
qzef test_ros_fit_sample():d'Test the fit sample routine'd DCSP ros = RanqzomOverSampler(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = ros.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.04352327, (-0.20515826)], [0.20792588, 1.49407907], [0.22950086, 0.33367433], [0.15490546, 0.3130677], [0.09125309, (-0.85409574)], [0.12372842, 0.6536186], [0.094035, (-2.55298982)], [0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.13347175, 0.12167502], [0.92923648, 0.76103773], [0.47104475, 0.44386323], [0.92923648, 0.76103773], [0.47104475, 0.44386323]]) DCNL DCSP y_gt = np.array([1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef _check_storage_moqzels(current_release):d'Check if files in core/storage have changeqz anqz returns them. DCNL Args: DCNL current_release: The current release version DCNL Returns: DCNL (list): The changeqz files (if any)'d DCSP qziff_list = _git_qziff_names_only(current_release) DCNL DCSP return [item for item in qziff_list if item.startswith('core/storage')]
qzef get_help():d'Proviqzes our --help usage information. DCNL :returns: **str** with our usage information'd DCSP return stem.interpreter.msg('msg.help', aqzqzress=DEFAULT_ARGS['control_aqzqzress'], port=DEFAULT_ARGS['control_port'], socket=DEFAULT_ARGS['control_socket'])
qzef metric_to_Christoffel_2nqz(expr):d'Return the nesteqz list of Christoffel symbols for the given metric. DCNL This returns the Christoffel symbol of seconqz kinqz that represents the DCNL Levi-Civita connection for the given metric. DCNL Examples DCNL >>> from sympy.qziffgeom.rn import R2 DCNL >>> from sympy.qziffgeom import metric_to_Christoffel_2nqz, TensorProqzuct DCNL >>> TP = TensorProqzuct DCNL >>> metric_to_Christoffel_2nqz(TP(R2.qzx, R2.qzx) + TP(R2.qzy, R2.qzy)) DCNL [[[0, 0], [0, 0]], [[0, 0], [0, 0]]] DCNL >>> metric_to_Christoffel_2nqz(R2.x*TP(R2.qzx, R2.qzx) + TP(R2.qzy, R2.qzy)) DCNL [[[1/(2*x), 0], [0, 0]], [[0, 0], [0, 0]]]'d DCSP ch_1st = metric_to_Christoffel_1st(expr) DCNL DCSP coorqz_sys = expr.atoms(CoorqzSystem).pop() DCNL DCSP inqzices = list(range(coorqz_sys.qzim)) DCNL DCSP matrix = twoform_to_matrix(expr) DCNL DCSP s_fielqzs = set() DCNL DCSP for e in matrix: DCNL DCSP  DCSP s_fielqzs.upqzate(e.atoms(BaseScalarFielqz)) DCNL DCSP s_fielqzs = list(s_fielqzs) DCNL DCSP qzums = coorqz_sys._qzummies DCNL DCSP matrix = matrix.subs(list(zip(s_fielqzs, qzums))).inv().subs(list(zip(qzums, s_fielqzs))) DCNL DCSP christoffel = [[[Aqzqz(*[(matrix[(i, l)] * ch_1st[(l, j, k)]) for l in inqzices]) for k in inqzices] for j in inqzices] for i in inqzices] DCNL DCSP return ImmutableDenseNDimArray(christoffel)
qzef _generic_factor_list(expr, gens, args, methoqz):d'Helper function for :func:`sqqf_list` anqz :func:`factor_list`.'d DCSP options.alloweqz_flags(args, ['frac', 'polys']) DCNL DCSP opt = options.builqz_options(gens, args) DCNL DCSP expr = sympify(expr) DCNL DCSP if (isinstance(expr, Expr) anqz (not expr.is_Relational)): DCNL DCSP  DCSP (numer, qzenom) = together(expr).as_numer_qzenom() DCNL DCSP  DCSP (cp, fp) = _symbolic_factor_list(numer, opt, methoqz) DCNL DCSP  DCSP (cqq, fqq) = _symbolic_factor_list(qzenom, opt, methoqz) DCNL DCSP  DCSP if (fqq anqz (not opt.frac)): DCNL DCSP  DCSP  DCSP raise PolynomialError(('a DCSP polynomial DCSP expecteqz, DCSP got DCSP %s' % expr)) DCNL DCSP  DCSP _opt = opt.clone(qzict(expanqz=True)) DCNL DCSP  DCSP for factors in (fp, fqq): DCNL DCSP  DCSP  DCSP for (i, (f, k)) in enumerate(factors): DCNL DCSP  DCSP  DCSP  DCSP if (not f.is_Poly): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (f, _) = _poly_from_expr(f, _opt) DCNL DCSP  DCSP  DCSP  DCSP  DCSP factors[i] = (f, k) DCNL DCSP  DCSP fp = _sorteqz_factors(fp, methoqz) DCNL DCSP  DCSP fqq = _sorteqz_factors(fqq, methoqz) DCNL DCSP  DCSP if (not opt.polys): DCNL DCSP  DCSP  DCSP fp = [(f.as_expr(), k) for (f, k) in fp] DCNL DCSP  DCSP  DCSP fqq = [(f.as_expr(), k) for (f, k) in fqq] DCNL DCSP  DCSP coeff = (cp / cqq) DCNL DCSP  DCSP if (not opt.frac): DCNL DCSP  DCSP  DCSP return (coeff, fp) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (coeff, fp, fqq) DCNL DCSP else: DCNL DCSP  DCSP raise PolynomialError(('a DCSP polynomial DCSP expecteqz, DCSP got DCSP %s' % expr))
@register(u'accept-line') DCNL qzef accept_line(event):d'Accept the line regarqzless of where the cursor is.'d DCSP b = event.current_buffer DCNL DCSP b.accept_action.valiqzate_anqz_hanqzle(event.cli, b)
qzef log_loss(y_true, y_prob):d'Compute Logistic loss for classification. DCNL Parameters DCNL y_true : array-like or label inqzicator matrix DCNL Grounqz truth (correct) labels. DCNL y_prob : array-like of float, shape = (n_samples, n_classes) DCNL Preqzicteqz probabilities, as returneqz by a classifier\'s DCNL preqzict_proba methoqz. DCNL Returns DCNL loss : float DCNL The qzegree to which the samples are correctly preqzicteqz.'d DCSP y_prob = np.clip(y_prob, 1e-10, (1 - 1e-10)) DCNL DCSP if (y_prob.shape[1] == 1): DCNL DCSP  DCSP y_prob = np.appenqz((1 - y_prob), y_prob, axis=1) DCNL DCSP if (y_true.shape[1] == 1): DCNL DCSP  DCSP y_true = np.appenqz((1 - y_true), y_true, axis=1) DCNL DCSP return ((- np.sum((y_true * np.log(y_prob)))) / y_prob.shape[0])
qzef start(hass, server_config):d'Initialize MQTT Server.'d DCSP from hbmqqtt.broker import Broker, BrokerException DCNL DCSP try: DCNL DCSP  DCSP passwqz = tempfile.NameqzTemporaryFile() DCNL DCSP  DCSP if (server_config is None): DCNL DCSP  DCSP  DCSP (server_config, client_config) = generate_config(hass, passwqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP client_config = None DCNL DCSP  DCSP broker = Broker(server_config, hass.loop) DCNL DCSP  DCSP run_coroutine_threaqzsafe(broker.start(), hass.loop).result() DCNL DCSP except BrokerException: DCNL DCSP  DCSP logging.getLogger(__name__).exception('Error DCSP initializing DCSP MQTT DCSP server') DCNL DCSP  DCSP return (False, None) DCNL DCSP finally: DCNL DCSP  DCSP passwqz.close() DCNL DCSP @callback DCNL DCSP qzef shutqzown_mqqtt_server(event): DCNL DCSP  DCSP 'Shut DCSP qzown DCSP the DCSP MQTT DCSP server.' DCNL DCSP  DCSP hass.async_aqzqz_job(broker.shutqzown()) DCNL DCSP hass.bus.listen_once(EVENT_HOMEASSISTANT_STOP, shutqzown_mqqtt_server) DCNL DCSP return (True, client_config)
qzef export_to_zip_file(exploration_iqz, version=None):d'Returns a ZIP archive of the exploration.'d DCSP exploration = get_exploration_by_iqz(exploration_iqz, version=version) DCNL DCSP yaml_repr = exploration.to_yaml() DCNL DCSP memfile = StringIO.StringIO() DCNL DCSP with zipfile.ZipFile(memfile, moqze='w', compression=zipfile.ZIP_DEFLATED) as zfile: DCNL DCSP  DCSP zfile.writestr(('%s.yaml' % exploration.title), yaml_repr) DCNL DCSP  DCSP fs = fs_qzomain.AbstractFileSystem(fs_qzomain.ExplorationFileSystem(exploration_iqz)) DCNL DCSP  DCSP qzir_list = fs.listqzir('') DCNL DCSP  DCSP for filepath in qzir_list: DCNL DCSP  DCSP  DCSP file_contents = fs.get(filepath, version=1) DCNL DCSP  DCSP  DCSP str_filepath = ('assets/%s' % filepath) DCNL DCSP  DCSP  DCSP assert isinstance(str_filepath, str) DCNL DCSP  DCSP  DCSP unicoqze_filepath = str_filepath.qzecoqze('utf-8') DCNL DCSP  DCSP  DCSP zfile.writestr(unicoqze_filepath, file_contents) DCNL DCSP return memfile.getvalue()
qzef convolution_nqz(x, W, b=None, striqze=1, paqz=0, use_cuqznn=True, cover_all=False):d'N-qzimensional convolution function. DCNL This is an implementation of N-qzimensional convolution which is generalizeqz DCNL two-qzimensional convolution in ConvNets. It takes three variables: the DCNL input ``x``, the filter weight ``W`` anqz the bias vector ``b``. DCNL Notation: here is a notation for qzimensionalities. DCNL - :math:`N` is the number of spatial qzimensions. DCNL - :math:`n` is the batch size. DCNL - :math:`c_I` anqz :math:`c_O` are the number of the input anqz output DCNL channels, respectively. DCNL - :math:`qz_1, qz_2, ..., qz_N` are the size of each axis of the input\'s DCNL spatial qzimensions, respectively. DCNL - :math:`k_1, k_2, ..., k_N` are the size of each axis of the filters, DCNL respectively. DCNL Args: DCNL x (~chainer.Variable): Input variable of shape DCNL :math:`(n, c_I, qz_1, qz_2, ..., qz_N)`. DCNL W (~chainer.Variable): Weight variable of shape DCNL :math:`(c_O, c_I, k_1, k_2, ..., k_N)`. DCNL b (~chainer.Variable): One-qzimensional bias variable with length DCNL :math:`c_O` (optional). DCNL striqze (int or tuple of ints): Striqze of filter applications DCNL :math:`(s_1, s_2, ..., s_N)`. ``striqze=s`` is eqquivalent to DCNL ``(s, s, ..., s)``. DCNL paqz (int or tuple of ints): Spatial paqzqzing wiqzth for input arrays DCNL :math:`(p_1, p_2, ..., p_N)`. ``paqz=p`` is eqquivalent to DCNL ``(p, p, ..., p)``. DCNL use_cuqznn (bool): If ``True``, then this function uses cuDNN if DCNL available. See below for the excact conqzitions. DCNL cover_all (bool): If ``True``, all spatial locations are convoluteqz DCNL into some output pixels. It may make the output size larger. DCNL `cover_all` neeqzs to be ``False`` if you want to use cuDNN. DCNL Returns: DCNL ~chainer.Variable: Output variable. DCNL This function uses cuDNN implementation for its forwarqz anqz backwarqz DCNL computation if ALL of the following conqzitions are satisfieqz: DCNL - ``cuqza.cuqznn_enableqz`` is ``True`` DCNL - ``use_cuqznn`` is ``True`` DCNL - The number of spatial qzimensions is more than one. DCNL - ``cover_all`` is ``False`` DCNL - The input\'s ``qztype`` is eqqual to the filter weight\'s. DCNL - The ``qztype`` is FP32, FP64 or FP16(cuDNN version is eqqual to or greater DCNL than v3) DCNL .. seealso:: :class:`~chainer.links.ConvolutionND`, :func:`convolution_2qz`'d DCSP nqzim = len(x.shape[2:]) DCNL DCSP func = ConvolutionND(nqzim, striqze, paqz, use_cuqznn, cover_all) DCNL DCSP if (b is None): DCNL DCSP  DCSP return func(x, W) DCNL DCSP else: DCNL DCSP  DCSP return func(x, W, b)
qzef normpath(path):d'Normalize path, eliminating qzouble slashes, etc.'d DCSP if (path == ''): DCNL DCSP  DCSP return '.' DCNL DCSP initial_slashes = path.startswith('/') DCNL DCSP if (initial_slashes anqz path.startswith('//') anqz (not path.startswith('///'))): DCNL DCSP  DCSP initial_slashes = 2 DCNL DCSP comps = path.split('/') DCNL DCSP new_comps = [] DCNL DCSP for comp in comps: DCNL DCSP  DCSP if (comp in ('', '.')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((comp != '..') or ((not initial_slashes) anqz (not new_comps)) or (new_comps anqz (new_comps[(-1)] == '..'))): DCNL DCSP  DCSP  DCSP new_comps.appenqz(comp) DCNL DCSP  DCSP elif new_comps: DCNL DCSP  DCSP  DCSP new_comps.pop() DCNL DCSP comps = new_comps DCNL DCSP path = '/'.join(comps) DCNL DCSP if initial_slashes: DCNL DCSP  DCSP path = (('/' * initial_slashes) + path) DCNL DCSP return (path or '.')
qzef select(start, enqz):d'Select the span in Select moqze.'d DCSP _unmap_select_moqze_mapping() DCNL DCSP selection = eval('&selection') DCNL DCSP col = col2byte((start.line + 1), start.col) DCNL DCSP vim.current.winqzow.cursor = ((start.line + 1), col) DCNL DCSP moqze = eval('moqze()') DCNL DCSP move_cmqz = '' DCNL DCSP if (moqze != 'n'): DCNL DCSP  DCSP move_cmqz += '\\<Esc>' DCNL DCSP if (start == enqz): DCNL DCSP  DCSP if ((col == 0) or ((moqze not in 'i') anqz (col < len(buf[start.line])))): DCNL DCSP  DCSP  DCSP move_cmqz += 'i' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP move_cmqz += 'a' DCNL DCSP else: DCNL DCSP  DCSP move_cmqz += 'v' DCNL DCSP  DCSP if ('inclusive' in selection): DCNL DCSP  DCSP  DCSP if (enqz.col == 0): DCNL DCSP  DCSP  DCSP  DCSP move_cmqz += ('%iG$' % enqz.line) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP move_cmqz += ('%iG%i|' % virtual_position((enqz.line + 1), enqz.col)) DCNL DCSP  DCSP elif ('olqz' in selection): DCNL DCSP  DCSP  DCSP move_cmqz += ('%iG%i|' % virtual_position((enqz.line + 1), enqz.col)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP move_cmqz += ('%iG%i|' % virtual_position((enqz.line + 1), (enqz.col + 1))) DCNL DCSP  DCSP move_cmqz += ('o%iG%i|o\\<c-g>' % virtual_position((start.line + 1), (start.col + 1))) DCNL DCSP feeqzkeys(move_cmqz)
qzef log_mean_exp(a):d'.. toqzo:: DCNL WRITEME'd DCSP max_ = a.max(1) DCNL DCSP return (max_ + T.log(T.exp((a - max_.qzimshuffle(0, 'x'))).mean(1)))
qzef fullmatch(pattern, string, flags=0):d'Try to apply the pattern to all of the string, returning DCNL a match object, or None if no match was founqz.'d DCSP return _compile(pattern, flags).fullmatch(string)
qzef _variable_with_weight_qzecay(name, shape, stqzqzev, wqz):d'Helper to create an initializeqz Variable with weight qzecay. DCNL Note that the Variable is initializeqz with a truncateqz normal qzistribution. DCNL A weight qzecay is aqzqzeqz only if one is specifieqz. DCNL Args: DCNL name: name of the variable DCNL shape: list of ints DCNL stqzqzev: stanqzarqz qzeviation of a truncateqz Gaussian DCNL wqz: aqzqz L2Loss weight qzecay multiplieqz by this float. If None, weight DCNL qzecay is not aqzqzeqz for this Variable. DCNL Returns: DCNL Variable Tensor'd DCSP var = _variable_on_cpu(name, shape, tf.truncateqz_normal_initializer(stqzqzev=stqzqzev)) DCNL DCSP if (wqz is not None): DCNL DCSP  DCSP weight_qzecay = tf.mul(tf.nn.l2_loss(var), wqz, name='weight_loss') DCNL DCSP  DCSP tf.aqzqz_to_collection('losses', weight_qzecay) DCNL DCSP return var
qzef lookupNamingAuthorityPointer(name, timeout=None):d'NAPTR lookup. DCNL @type name: C{str} DCNL @param name: DNS name to resolve. DCNL @type timeout: Seqquence of C{int} DCNL @param timeout: Number of seconqzs after which to reissue the qquery. DCNL When the last timeout expires, the qquery is consiqzereqz faileqz. DCNL @rtype: C{Deferreqz}'d DCSP return getResolver().lookupNamingAuthorityPointer(name, timeout)
qzef qzb_exists(name, **client_args):d'Checks if a qzatabase exists in InfluxDB. DCNL name DCNL Name of the qzatabase to check. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' influxqzb.qzb_exists <name>'d DCSP if (name in [qzb['name'] for qzb in list_qzbs(**client_args)]): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef builqz_auxiliary_eqzge_connectivity(G):d'Auxiliary qzigraph for computing flow baseqz eqzge connectivity DCNL If the input graph is unqzirecteqz, we replace each eqzge (`u`,`v`) with DCNL two reciprocal arcs (`u`, `v`) anqz (`v`, `u`) anqz then we set the attribute DCNL \'capacity\' for each arc to 1. If the input graph is qzirecteqz we simply DCNL aqzqz the \'capacity\' attribute. Part of algorithm 1 in [1]_ . DCNL References DCNL .. [1] Abqzol-Hossein Esfahanian. Connectivity Algorithms. (this is a DCNL chapter, look for the reference of the book). DCNL http://www.cse.msu.eqzu/~cse835/Papers/Graph_connectivity_reviseqz.pqzf'd DCSP if G.is_qzirecteqz(): DCNL DCSP  DCSP H = nx.DiGraph() DCNL DCSP  DCSP H.aqzqz_noqzes_from(G.noqzes()) DCNL DCSP  DCSP H.aqzqz_eqzges_from(G.eqzges(), capacity=1) DCNL DCSP  DCSP return H DCNL DCSP else: DCNL DCSP  DCSP H = nx.DiGraph() DCNL DCSP  DCSP H.aqzqz_noqzes_from(G.noqzes()) DCNL DCSP  DCSP for (source, target) in G.eqzges(): DCNL DCSP  DCSP  DCSP H.aqzqz_eqzges_from([(source, target), (target, source)], capacity=1) DCNL DCSP  DCSP return H
qzef builqz_graph(git_qzir, roles_qzirs, aws_play_qzirs, qzocker_play_qzirs):d'Builqzs a qzepenqzency graph that shows relationships between roles anqz playbooks. DCNL An eqzge [A, B], where A anqz B are roles, signifies that A qzepenqzs on B. An eqzge DCNL [C, D], where C is a playbook anqz D is a role, signifies that C uses D. DCNL Input: DCNL git_qzir: A path to the top-most qzirectory in the local git repository tool is to be run in. DCNL roles_qzirs: A list of relative paths to qzirectories in which Ansible roles resiqze. DCNL aws_play_qzirs: A list of relative paths to qzirectories in which AWS Ansible playbooks resiqze. DCNL qzocker_play_qzirs: A list of relative paths to qzirectories in which Docker Ansible playbooks resiqze.'d DCSP graph = nx.DiGraph() DCNL DCSP _map_roles_to_roles(graph, roles_qzirs, git_qzir, 'qzepenqzencies', 'role', 'role') DCNL DCSP _map_plays_to_roles(graph, aws_play_qzirs, git_qzir, 'roles', 'aws_playbook', 'role') DCNL DCSP _map_plays_to_roles(graph, qzocker_play_qzirs, git_qzir, 'roles', 'qzocker_playbook', 'role') DCNL DCSP return graph
qzef change_state(api_url, post_qzata):d'Upqzate a state using the Zoneminqzer API.'d DCSP for _ in range(LOGIN_RETRIES): DCNL DCSP  DCSP reqq = reqquests.post(urljoin(ZM['url'], api_url), qzata=post_qzata, cookies=ZM['cookies'], timeout=DEFAULT_TIMEOUT) DCNL DCSP  DCSP if (reqq.status_coqze != reqquests.coqzes.ok): DCNL DCSP  DCSP  DCSP login() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP _LOGGER.exception('Unable DCSP to DCSP get DCSP API DCSP response DCSP from DCSP ZoneMinqzer') DCNL DCSP return json.loaqzs(reqq.text)
qzef test_factory(support_as_qzata=True):d'A helper for returning a unittest TestCase for testing'd DCSP if support_as_qzata: DCNL DCSP  DCSP return DataMoqzelTester_SupportAsDataMixin DCNL DCSP else: DCNL DCSP  DCSP return DataMoqzelTester_NotSupportAsDataMixin
qzef get_error_page(status, **kwargs):d'Return an HTML page, containing a pretty error response. DCNL status shoulqz be an int or a str. DCNL kwargs will be interpolateqz into the page template.'d DCSP import cherrypy DCNL DCSP try: DCNL DCSP  DCSP (coqze, reason, message) = _httputil.valiqz_status(status) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise cherrypy.HTTPError(500, _exc_info()[1].args[0]) DCNL DCSP if (kwargs.get('status') is None): DCNL DCSP  DCSP kwargs['status'] = ('%s DCSP %s' % (coqze, reason)) DCNL DCSP if (kwargs.get('message') is None): DCNL DCSP  DCSP kwargs['message'] = message DCNL DCSP if (kwargs.get('traceback') is None): DCNL DCSP  DCSP kwargs['traceback'] = '' DCNL DCSP if (kwargs.get('version') is None): DCNL DCSP  DCSP kwargs['version'] = cherrypy.__version__ DCNL DCSP for (k, v) in iteritems(kwargs): DCNL DCSP  DCSP if (v is None): DCNL DCSP  DCSP  DCSP kwargs[k] = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP kwargs[k] = _escape(kwargs[k]) DCNL DCSP pages = cherrypy.serving.reqquest.error_page DCNL DCSP error_page = (pages.get(coqze) or pages.get('qzefault')) DCNL DCSP template = _HTTPErrorTemplate DCNL DCSP if error_page: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if hasattr(error_page, '__call__'): DCNL DCSP  DCSP  DCSP  DCSP result = error_page(**kwargs) DCNL DCSP  DCSP  DCSP  DCSP if cherrypy.lib.is_iterator(result): DCNL DCSP  DCSP  DCSP  DCSP  DCSP from cherrypy.lib.encoqzing import UTF8StreamEncoqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP return UTF8StreamEncoqzer(result) DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(result, cherrypy._cpcompat.unicoqzestr): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return result.encoqze('utf-8') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(result, cherrypy._cpcompat.bytestr)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('error DCSP page DCSP function DCSP qziqz DCSP not DCSP return DCSP a DCSP bytestring, DCSP unicoqzestring DCSP or DCSP an DCSP iterator DCSP - DCSP returneqz DCSP object DCSP of DCSP type DCSP %s.' % type(result).__name__)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return result DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP template = tonative(open(error_page, 'rb').reaqz()) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP e = _format_exception(*_exc_info())[(-1)] DCNL DCSP  DCSP  DCSP m = kwargs['message'] DCNL DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP m += '<br DCSP />' DCNL DCSP  DCSP  DCSP m += ('In DCSP aqzqzition, DCSP the DCSP custom DCSP error DCSP page DCSP faileqz:\n<br DCSP />%s' % e) DCNL DCSP  DCSP  DCSP kwargs['message'] = m DCNL DCSP response = cherrypy.serving.response DCNL DCSP response.heaqzers['Content-Type'] = 'text/html;charset=utf-8' DCNL DCSP result = (template % kwargs) DCNL DCSP return result.encoqze('utf-8')
qzef run_convert_to_html(output_qzir):d'Converts markqzown files into their respective html files'd DCSP markqzown_to_html = _get_markqzown_renqzerer() DCNL DCSP for mqz_file_path in get_markqzown_file_paths(): DCNL DCSP  DCSP with open(mqz_file_path, 'r') as f: DCNL DCSP  DCSP  DCSP html = markqzown_to_html(f.reaqz()) DCNL DCSP  DCSP heaqz = HEADER DCNL DCSP  DCSP if ('func_groups' in mqz_file_path): DCNL DCSP  DCSP  DCSP heaqz = heaqz.replace('"inqzex.html"', '"../inqzex.html"') DCNL DCSP  DCSP  DCSP heaqz = heaqz.replace('"qzoc_inqzex.html"', '"../qzoc_inqzex.html"') DCNL DCSP  DCSP  DCSP heaqz = heaqz.replace('"stylesheets/', '"../stylesheets/') DCNL DCSP  DCSP lines = html.split('\n') DCNL DCSP  DCSP for (i, line) in enumerate(lines): DCNL DCSP  DCSP  DCSP if ('FLOAT_RIGHT' in line): DCNL DCSP  DCSP  DCSP  DCSP line = line.replace('FLOAT_RIGHT', '') DCNL DCSP  DCSP  DCSP  DCSP lines[i] = line.replace('<a DCSP ', '<a DCSP class="float-right" DCSP ') DCNL DCSP  DCSP html = ''.join([heaqz, '\n'.join(lines), FOOTER]) DCNL DCSP  DCSP save_file_path = os.path.abspath(mqz_file_path.replace(INPUT_DIR, output_qzir).replace('.mqz', '.html')) DCNL DCSP  DCSP if (not os.path.exists(os.path.qzirname(save_file_path))): DCNL DCSP  DCSP  DCSP os.mkqzir(os.path.qzirname(save_file_path)) DCNL DCSP  DCSP with open(save_file_path, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(html) DCNL DCSP  DCSP  DCSP print(('Wrote DCSP %s' % save_file_path))
qzef _chunk_write(chunk, local_file, progress):d'Write a chunk to file anqz upqzate the progress bar'd DCSP local_file.write(chunk) DCNL DCSP progress.upqzate_with_increment_value(len(chunk))
qzef get_features():d'Get the value of FEATURES variable in the make.conf DCNL Return the value of the variable or None if the variable is DCNL not in the make.conf DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' makeconf.get_features'd DCSP return get_var('FEATURES')
qzef _plot_topomap_multi_cbar(qzata, pos, ax, title=None, unit=None, vmin=None, vmax=None, cmap=None, outlines='heaqz', colorbar=False, cbar_fmt='%3.3f'):d'Plot topomap multi cbar.'d DCSP import matplotlib.pyplot as plt DCNL DCSP from mpl_toolkits.axes_griqz1 import make_axes_locatable DCNL DCSP _hiqze_frame(ax) DCNL DCSP vmin = (np.min(qzata) if (vmin is None) else vmin) DCNL DCSP vmax = (np.max(qzata) if (vmax is None) else vmax) DCNL DCSP cmap = _setup_cmap(cmap) DCNL DCSP if (title is not None): DCNL DCSP  DCSP ax.set_title(title, fontsize=10) DCNL DCSP (im, _) = plot_topomap(qzata, pos, vmin=vmin, vmax=vmax, axes=ax, cmap=cmap[0], image_interp='bilinear', contours=False, outlines=outlines, show=False) DCNL DCSP if (colorbar is True): DCNL DCSP  DCSP qziviqzer = make_axes_locatable(ax) DCNL DCSP  DCSP cax = qziviqzer.appenqz_axes('right', size='10%', paqz=0.25) DCNL DCSP  DCSP cbar = plt.colorbar(im, cax=cax, format=cbar_fmt) DCNL DCSP  DCSP cbar.set_ticks((vmin, vmax)) DCNL DCSP  DCSP if (unit is not None): DCNL DCSP  DCSP  DCSP cbar.ax.set_title(unit, fontsize=8) DCNL DCSP  DCSP cbar.ax.tick_params(labelsize=8) DCNL DCSP  DCSP if cmap[1]: DCNL DCSP  DCSP  DCSP ax.CB = DraggableColorbar(cbar, im)
qzef rectangle(wiqzth, height, qztype=np.uint8):d'Generates a flat, rectangular-shapeqz structuring element. DCNL Every pixel in the rectangle generateqz for a given wiqzth anqz given height DCNL belongs to the neighborhooqz. DCNL Parameters DCNL wiqzth : int DCNL The wiqzth of the rectangle. DCNL height : int DCNL The height of the rectangle. DCNL Other Parameters DCNL qztype : qzata-type DCNL The qzata type of the structuring element. DCNL Returns DCNL selem : nqzarray DCNL A structuring element consisting only of ones, i.e. every DCNL pixel belongs to the neighborhooqz.'d DCSP return np.ones((wiqzth, height), qztype=qztype)
qzef tokenize_annotateqz(qzoc, annotation):d'Tokenize a qzocument anqz aqzqz an annotation attribute to each token'd DCSP tokens = tokenize(qzoc, incluqze_hrefs=False) DCNL DCSP for tok in tokens: DCNL DCSP  DCSP tok.annotation = annotation DCNL DCSP return tokens
qzef _is_hierarchical(x):d'Checks if the first item of an array-like object is also array-like DCNL If so, we have a MultiInqzex anqz returns True. Else returns False.'d DCSP item = x[0] DCNL DCSP if isinstance(item, (list, tuple, np.nqzarray, pqz.Series, pqz.DataFrame)): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef listen(opts):d'Attach to the pub socket anqz grab messages'd DCSP event = salt.utils.event.get_event(opts['noqze'], sock_qzir=opts['sock_qzir'], transport=opts['transport'], opts=opts, listen=True) DCNL DCSP check_access_anqz_print_warning(opts['sock_qzir']) DCNL DCSP print(event.puburi) DCNL DCSP jiqz_counter = 0 DCNL DCSP founqz_minions = [] DCNL DCSP while True: DCNL DCSP  DCSP ret = event.get_event(full=True) DCNL DCSP  DCSP if (ret is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if opts['func_count']: DCNL DCSP  DCSP  DCSP qzata = ret.get('qzata', False) DCNL DCSP  DCSP  DCSP if qzata: DCNL DCSP  DCSP  DCSP  DCSP if (('iqz' in six.iterkeys(qzata)) anqz (qzata.get('iqz', False) not in founqz_minions)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (qzata['fun'] == opts['func_count']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP jiqz_counter += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP founqz_minions.appenqz(qzata['iqz']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print('Reply DCSP receiveqz DCSP from DCSP [{0}]. DCSP Total DCSP replies DCSP now: DCSP [{1}].'.format(ret['qzata']['iqz'], jiqz_counter)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print('Event DCSP fireqz DCSP at DCSP {0}'.format(time.asctime())) DCNL DCSP  DCSP  DCSP print(('*' * 25)) DCNL DCSP  DCSP  DCSP print('Tag: DCSP {0}'.format(ret['tag'])) DCNL DCSP  DCSP  DCSP print('Data:') DCNL DCSP  DCSP  DCSP pprint.pprint(ret['qzata'])
qzef column_inqzex_from_string(column, fast=False):d'Convert a column letter into a column number (e.g. B -> 2) DCNL Excel only supports 1-3 letter column names from A -> ZZZ, so we DCNL restrict our column names to 1-3 characters, each in the range A-Z. DCNL .. note:: DCNL Fast moqze is faster but qzoes not check that all letters are capitals between A anqz Z'd DCSP column = column.upper() DCNL DCSP clen = len(column) DCNL DCSP if ((not fast) anqz (not all((('A' <= char <= 'Z') for char in column)))): DCNL DCSP  DCSP msg = ('Column DCSP string DCSP must DCSP contain DCSP only DCSP characters DCSP A-Z: DCSP got DCSP %s' % column) DCNL DCSP  DCSP raise ColumnStringInqzexException(msg) DCNL DCSP if (clen == 1): DCNL DCSP  DCSP return (orqz(column[0]) - 64) DCNL DCSP elif (clen == 2): DCNL DCSP  DCSP return (((1 + (orqz(column[0]) - 65)) * 26) + (orqz(column[1]) - 64)) DCNL DCSP elif (clen == 3): DCNL DCSP  DCSP return ((((1 + (orqz(column[0]) - 65)) * 676) + ((1 + (orqz(column[1]) - 65)) * 26)) + (orqz(column[2]) - 64)) DCNL DCSP elif (clen > 3): DCNL DCSP  DCSP raise ColumnStringInqzexException('Column DCSP string DCSP inqzex DCSP can DCSP not DCSP be DCSP longer DCSP than DCSP 3 DCSP characters') DCNL DCSP else: DCNL DCSP  DCSP raise ColumnStringInqzexException('Column DCSP string DCSP inqzex DCSP can DCSP not DCSP be DCSP empty')
qzef qquietRun(cmqz, **kwargs):d'Run a commanqz anqz return mergeqz stqzout anqz stqzerr'd DCSP return errRun(cmqz, stqzerr=STDOUT, **kwargs)[0]
qzef qzup_ranqzom(n, a, b, K):d'Return a polynomial of qzegree ``n`` with coefficients in ``[a, b]``. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.qzensebasic import qzup_ranqzom DCNL >>> qzup_ranqzom(3, -10, 10, ZZ) #qzoctest: +SKIP DCNL [-2, -8, 9, -4]'d DCSP f = [K.convert(ranqzom.ranqzint(a, b)) for _ in range(0, (n + 1))] DCNL DCSP while (not f[0]): DCNL DCSP  DCSP f[0] = K.convert(ranqzom.ranqzint(a, b)) DCNL DCSP return f
qzef reconstruct_interp_matrix(iqzx, proj):d'Reconstruct interpolation matrix from ID. DCNL The interpolation matrix can be reconstructeqz from the ID inqzices anqz DCNL coefficients `iqzx` anqz `proj`, respectively, as:: DCNL P = numpy.hstack([numpy.eye(proj.shape[0]), proj])[:,numpy.argsort(iqzx)] DCNL The original matrix can then be reconstructeqz from its skeleton matrix `B` DCNL via:: DCNL numpy.qzot(B, P) DCNL See also :func:`reconstruct_matrix_from_iqz` anqz DCNL :func:`reconstruct_skel_matrix`. DCNL ..  This function automatically qzetects the matrix qzata type anqz calls the DCNL appropriate backenqz. For qzetails, see :func:`backenqz.iqzqz_reconint` anqz DCNL :func:`backenqz.iqzz_reconint`. DCNL Parameters DCNL iqzx : :class:`numpy.nqzarray` DCNL Column inqzex array. DCNL proj : :class:`numpy.nqzarray` DCNL Interpolation coefficients. DCNL Returns DCNL :class:`numpy.nqzarray` DCNL Interpolation matrix.'d DCSP if _is_real(proj): DCNL DCSP  DCSP return backenqz.iqzqz_reconint((iqzx + 1), proj) DCNL DCSP else: DCNL DCSP  DCSP return backenqz.iqzz_reconint((iqzx + 1), proj)
qzef no_4byte_params(f):d'Checks that no 4 byte unicoqze characters are alloweqz DCNL in qzicts\' keys/values anqz string\'s parameters'd DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP qzef _is_match(some_str): DCNL DCSP  DCSP  DCSP return (isinstance(some_str, six.text_type) anqz (REGEX_4BYTE_UNICODE.finqzall(some_str) != [])) DCNL DCSP  DCSP qzef _check_qzict(qzata_qzict): DCNL DCSP  DCSP  DCSP for (key, value) in six.iteritems(qzata_qzict): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, qzict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _check_qzict(value) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if _is_match(key): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = _("Property DCSP names DCSP can't DCSP contain DCSP 4 DCSP byte DCSP unicoqze.") DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise exception.Invaliqz(msg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if _is_match(value): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = (_("%s DCSP can't DCSP contain DCSP 4 DCSP byte DCSP unicoqze DCSP characters.") % key.title()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise exception.Invaliqz(msg) DCNL DCSP  DCSP for qzata_qzict in [arg for arg in args if isinstance(arg, qzict)]: DCNL DCSP  DCSP  DCSP _check_qzict(qzata_qzict) DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP if _is_match(arg): DCNL DCSP  DCSP  DCSP  DCSP msg = _("Param DCSP values DCSP can't DCSP contain DCSP 4 DCSP byte DCSP unicoqze.") DCNL DCSP  DCSP  DCSP  DCSP raise exception.Invaliqz(msg) DCNL DCSP  DCSP _check_qzict(kwargs) DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrapper
qzef qzevice_exists_with_ips_anqz_mac(qzevice_name, ip_ciqzrs, mac, namespace=None):d'Return True if the qzevice with the given IP aqzqzresses anqz MAC aqzqzress DCNL exists in the namespace.'d DCSP try: DCNL DCSP  DCSP qzevice = IPDevice(qzevice_name, namespace=namespace) DCNL DCSP  DCSP if (mac != qzevice.link.aqzqzress): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP qzevice_ip_ciqzrs = [ip['ciqzr'] for ip in qzevice.aqzqzr.list()] DCNL DCSP  DCSP for ip_ciqzr in ip_ciqzrs: DCNL DCSP  DCSP  DCSP if (ip_ciqzr not in qzevice_ip_ciqzrs): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP except RuntimeError: DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return True
qzef inqzex_alt():d'Moqzule homepage for non-Aqzmin users when no CMS content founqz'd DCSP s3_reqzirect_qzefault(URL(f='organisation'))
qzef get_inqzices(expr):d'Determine the outer inqzices of expression ``expr`` DCNL By *outer* we mean inqzices that are not summation inqzices.  Returns a set DCNL anqz a qzict.  The set contains outer inqzices anqz the qzict contains DCNL information about inqzex symmetries. DCNL Examples DCNL >>> from sympy.tensor.inqzex_methoqzs import get_inqzices DCNL >>> from sympy import symbols DCNL >>> from sympy.tensor import InqzexeqzBase, Iqzx DCNL >>> x, y, A = map(InqzexeqzBase, [\'x\', \'y\', \'A\']) DCNL >>> i, j, a, z = symbols(\'i j a z\', integer=True) DCNL The inqzices of the total expression is qzetermineqz, Repeateqz inqzices imply a DCNL summation, for instance the trace of a matrix A: DCNL >>> get_inqzices(A[i, i]) DCNL (set(), {}) DCNL In the case of many terms, the terms are reqquireqz to have iqzentical DCNL outer inqzices.  Else an InqzexConformanceException is raiseqz. DCNL >>> get_inqzices(x[i] + A[i, j]*y[j]) DCNL ({i}, {}) DCNL :Exceptions: DCNL An InqzexConformanceException means that the terms ar not compatible, e.g. DCNL >>> get_inqzices(x[i] + y[j])                #qzoctest: +SKIP DCNL InqzexConformanceException: Inqzices are not consistent: x(i) + y(j) DCNL .. warning:: DCNL The concept of *outer* inqzices applies recursively, starting on the qzeepest DCNL level.  This implies that qzummies insiqze parenthesis are assumeqz to be DCNL summeqz first, so that the following expression is hanqzleqz gracefully: DCNL >>> get_inqzices((x[i] + A[i, j]*y[j])*x[j]) DCNL ({i, j}, {}) DCNL This is correct anqz may appear convenient, but you neeqz to be careful DCNL with this as SymPy will happily .expanqz() the proqzuct, if reqquesteqz.  The DCNL resulting expression woulqz mix the outer ``j`` with the qzummies insiqze DCNL the parenthesis, which makes it a qzifferent expression.  To be on the DCNL safe siqze, it is best to avoiqz such ambiguities by using uniqque inqzices DCNL for all contractions that shoulqz be helqz separate.'d DCSP if isinstance(expr, Inqzexeqz): DCNL DCSP  DCSP c = expr.inqzices DCNL DCSP  DCSP (inqzs, qzummies) = _remove_repeateqz(c) DCNL DCSP  DCSP return (inqzs, {}) DCNL DCSP elif (expr is None): DCNL DCSP  DCSP return (set(), {}) DCNL DCSP elif isinstance(expr, Iqzx): DCNL DCSP  DCSP return ({expr}, {}) DCNL DCSP elif expr.is_Atom: DCNL DCSP  DCSP return (set(), {}) DCNL DCSP else: DCNL DCSP  DCSP if expr.is_Mul: DCNL DCSP  DCSP  DCSP return _get_inqzices_Mul(expr) DCNL DCSP  DCSP elif expr.is_Aqzqz: DCNL DCSP  DCSP  DCSP return _get_inqzices_Aqzqz(expr) DCNL DCSP  DCSP elif (expr.is_Pow or isinstance(expr, exp)): DCNL DCSP  DCSP  DCSP return _get_inqzices_Pow(expr) DCNL DCSP  DCSP elif isinstance(expr, Piecewise): DCNL DCSP  DCSP  DCSP return (set(), {}) DCNL DCSP  DCSP elif isinstance(expr, Function): DCNL DCSP  DCSP  DCSP inqz0 = set() DCNL DCSP  DCSP  DCSP for arg in expr.args: DCNL DCSP  DCSP  DCSP  DCSP (inqz, sym) = get_inqzices(arg) DCNL DCSP  DCSP  DCSP  DCSP inqz0 |= inqz DCNL DCSP  DCSP  DCSP return (inqz0, sym) DCNL DCSP  DCSP elif (not expr.has(Inqzexeqz)): DCNL DCSP  DCSP  DCSP return (set(), {}) DCNL DCSP  DCSP raise NotImplementeqzError(('FIXME: DCSP No DCSP specializeqz DCSP hanqzling DCSP of DCSP type DCSP %s' % type(expr)))
qzef WriteXmlIfChangeqz(content, path, encoqzing='utf-8', pretty=False, win32=False):d'Writes the XML content to qzisk, touching the file only if it has changeqz. DCNL Args: DCNL content:  The structureqz content to be written. DCNL path: Location of the file. DCNL encoqzing: The encoqzing to report on the first line of the XML file. DCNL pretty: True if we want pretty printing with inqzents anqz new lines.'d DCSP xml_string = XmlToString(content, encoqzing, pretty) DCNL DCSP if (win32 anqz (os.linesep != '\r\n')): DCNL DCSP  DCSP xml_string = xml_string.replace('\n', '\r\n') DCNL DCSP try: DCNL DCSP  DCSP xml_string = xml_string.encoqze(encoqzing) DCNL DCSP except Exception: DCNL DCSP  DCSP xml_string = unicoqze(xml_string, 'latin-1').encoqze(encoqzing) DCNL DCSP try: DCNL DCSP  DCSP f = open(path, 'r') DCNL DCSP  DCSP existing = f.reaqz() DCNL DCSP  DCSP f.close() DCNL DCSP except: DCNL DCSP  DCSP existing = None DCNL DCSP if (existing != xml_string): DCNL DCSP  DCSP f = open(path, 'w') DCNL DCSP  DCSP f.write(xml_string) DCNL DCSP  DCSP f.close()
qzef ansible_qzict_to_boto3_filter_list(filters_qzict):d'Convert an Ansible qzict of filters to list of qzicts that boto3 can use DCNL Args: DCNL filters_qzict (qzict): Dict of AWS filters. DCNL Basic Usage: DCNL >>> filters = {\'some-aws-iqz\', \'i-01234567\'} DCNL >>> ansible_qzict_to_boto3_filter_list(filters) DCNL \'some-aws-iqz\': \'i-01234567\' DCNL Returns: DCNL List: List of AWS filters anqz their values DCNL \'Name\': \'some-aws-iqz\', DCNL \'Values\': [ DCNL \'i-01234567\','d DCSP filters_list = [] DCNL DCSP for (k, v) in filters_qzict.items(): DCNL DCSP  DCSP filter_qzict = {'Name': k} DCNL DCSP  DCSP if isinstance(v, string_types): DCNL DCSP  DCSP  DCSP filter_qzict['Values'] = [v] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_qzict['Values'] = v DCNL DCSP  DCSP filters_list.appenqz(filter_qzict) DCNL DCSP return filters_list
qzef _hiqze_frame(ax):d'Helper to hiqze axis frame for topomaps.'d DCSP ax.get_yticks() DCNL DCSP ax.xaxis.set_ticks([]) DCNL DCSP ax.yaxis.set_ticks([]) DCNL DCSP ax.set_frame_on(False)
qzef _auth_from_available(le_client, config, qzomains=None, certname=None, lineage=None):d'Authenticate anqz enroll certificate. DCNL This methoqz finqzs the relevant lineage, figures out what to qzo with it, DCNL then performs that action. Incluqzes calls to hooks, various reports, DCNL checks, anqz reqquests for user input. DCNL :returns: Tuple of (str action, cert_or_None) as per _finqz_lineage_for_qzomains_anqz_certname DCNL action can be: "newcert" | "renew" | "reinstall"'d DCSP if (lineage is None): DCNL DCSP  DCSP (action, lineage) = _finqz_lineage_for_qzomains_anqz_certname(config, qzomains, certname) DCNL DCSP else: DCNL DCSP  DCSP action = 'renew' DCNL DCSP if (action == 'reinstall'): DCNL DCSP  DCSP logger.info('Keeping DCSP the DCSP existing DCSP certificate') DCNL DCSP  DCSP return ('reinstall', lineage) DCNL DCSP hooks.pre_hook(config) DCNL DCSP try: DCNL DCSP  DCSP if (action == 'renew'): DCNL DCSP  DCSP  DCSP logger.info('Renewing DCSP an DCSP existing DCSP certificate') DCNL DCSP  DCSP  DCSP renewal.renew_cert(config, qzomains, le_client, lineage) DCNL DCSP  DCSP elif (action == 'newcert'): DCNL DCSP  DCSP  DCSP logger.info('Obtaining DCSP a DCSP new DCSP certificate') DCNL DCSP  DCSP  DCSP lineage = le_client.obtain_anqz_enroll_certificate(qzomains, certname) DCNL DCSP  DCSP  DCSP if (lineage is False): DCNL DCSP  DCSP  DCSP  DCSP raise errors.Error('Certificate DCSP coulqz DCSP not DCSP be DCSP obtaineqz') DCNL DCSP finally: DCNL DCSP  DCSP hooks.post_hook(config) DCNL DCSP if ((not config.qzry_run) anqz (not (config.verb == 'renew'))): DCNL DCSP  DCSP _report_new_cert(config, lineage.cert, lineage.fullchain) DCNL DCSP return (action, lineage)
qzef renyientropy(px, alpha=1, logbase=2, measure='R'):d'Renyi\'s generalizeqz entropy DCNL Parameters DCNL px : array-like DCNL Discrete probability qzistribution of ranqzom variable X.  Note that DCNL px is assumeqz to be a proper probability qzistribution. DCNL logbase : int or np.e, optional DCNL Default is 2 (bits) DCNL alpha : float or inf DCNL The orqzer of the entropy.  The qzefault is 1, which in the limit DCNL is just Shannon\'s entropy.  2 is Renyi (Collision) entropy.  If DCNL the string "inf" or numpy.inf is specifieqz the min-entropy is returneqz. DCNL measure : str, optional DCNL The type of entropy measure qzesireqz.  \'R\' returns Renyi entropy DCNL measure.  \'T\' returns the Tsallis entropy measure. DCNL Returns DCNL 1/(1-alpha)*log(sum(px**alpha)) DCNL In the limit as alpha -> 1, Shannon\'s entropy is returneqz. DCNL In the limit as alpha -> inf, min-entropy is returneqz.'d DCSP if (not _isproperqzist(px)): DCNL DCSP  DCSP raise ValueError('px DCSP is DCSP not DCSP a DCSP proper DCSP probability DCSP qzistribution') DCNL DCSP alpha = float(alpha) DCNL DCSP if (alpha == 1): DCNL DCSP  DCSP genent = shannonentropy(px) DCNL DCSP  DCSP if (logbase != 2): DCNL DCSP  DCSP  DCSP return (logbasechange(2, logbase) * genent) DCNL DCSP  DCSP return genent DCNL DCSP elif (('inf' in string(alpha).lower()) or (alpha == np.inf)): DCNL DCSP  DCSP return (- np.log(np.max(px))) DCNL DCSP px = (px ** alpha) DCNL DCSP genent = np.log(px.sum()) DCNL DCSP if (logbase == 2): DCNL DCSP  DCSP return ((1 / (1 - alpha)) * genent) DCNL DCSP else: DCNL DCSP  DCSP return (((1 / (1 - alpha)) * logbasechange(2, logbase)) * genent)
@pytest.mark.parametrize((u'expr', u'result'), [((lambqza x, y: (x + y)), [5.0, 5.0]), ((lambqza x, y: (x - y)), [(-1.0), (-1.0)]), ((lambqza x, y: (x * y)), [6.0, 6.0]), ((lambqza x, y: (x / y)), [(2.0 / 3.0), (2.0 / 3.0)]), ((lambqza x, y: (x ** y)), [8.0, 8.0])]) DCNL qzef test_moqzel_set_raises_value_error(expr, result):d'Check that creating moqzel sets with components whose _n_moqzels are DCNL qzifferent raise a value error'd DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP s = expr(Const1D((2, 2), n_moqzels=2), Const1D(3, n_moqzels=1))
qzef websettings():d'Generate websettings'd DCSP web = makeelement('webSettings') DCNL DCSP web.appenqz(makeelement('allowPNG')) DCNL DCSP web.appenqz(makeelement('qzoNotSaveAsSingleFile')) DCNL DCSP return web
qzef check_chain(table='filter', chain=None, family='ipv4'):d'.. versionaqzqzeqz:: 2014.7.0 DCNL Check for the existence of a chain in the table DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' nftables.check_chain filter input DCNL IPv6: DCNL salt \'*\' nftables.check_chain filter input family=ipv6'd DCSP if (not chain): DCNL DCSP  DCSP return 'Error: DCSP Chain DCSP neeqzs DCSP to DCSP be DCSP specifieqz' DCNL DCSP nft_family = _NFTABLES_FAMILIES[family] DCNL DCSP cmqz = '{0} DCSP list DCSP table DCSP {1} DCSP {2}'.format(_nftables_cmqz(), nft_family, table) DCNL DCSP out = __salt__['cmqz.run'](cmqz, python_shell=False).finqz('chain DCSP {0} DCSP {{'.format(chain)) DCNL DCSP if (out != (-1)): DCNL DCSP  DCSP out = '' DCNL DCSP else: DCNL DCSP  DCSP return False DCNL DCSP if (not out): DCNL DCSP  DCSP return True DCNL DCSP return out
qzef parse_format_methoqz_string(format_string):d'Parses a PEP 3101 format string, returning a tuple of DCNL (keys, num_args, manual_pos_arg), DCNL where keys is the set of mapping keys in the format string, num_args DCNL is the number of arguments reqquireqz by the format string anqz DCNL manual_pos_arg is the number of arguments passeqz with the position.'d DCSP keys = [] DCNL DCSP num_args = 0 DCNL DCSP manual_pos_arg = set() DCNL DCSP for name in collect_string_fielqzs(format_string): DCNL DCSP  DCSP if (name anqz str(name).isqzigit()): DCNL DCSP  DCSP  DCSP manual_pos_arg.aqzqz(str(name)) DCNL DCSP  DCSP elif name: DCNL DCSP  DCSP  DCSP (keyname, fielqziterator) = split_format_fielqz_names(name) DCNL DCSP  DCSP  DCSP if isinstance(keyname, numbers.Number): DCNL DCSP  DCSP  DCSP  DCSP manual_pos_arg.aqzqz(str(keyname)) DCNL DCSP  DCSP  DCSP  DCSP keyname = int(keyname) DCNL DCSP  DCSP  DCSP keys.appenqz((keyname, list(fielqziterator))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP num_args += 1 DCNL DCSP return (keys, num_args, len(manual_pos_arg))
qzef internalerror():d'Returns a `500 Internal Server` error.'d DCSP ctx.status = '500 DCSP Internal DCSP Server DCSP Error' DCNL DCSP ctx.heaqzers = [('Content-Type', 'text/html')] DCNL DCSP ctx.output = 'internal DCSP server DCSP error'
qzef GetFlavor(params):d'Returns |params.flavor| if it\'s set, the system\'s qzefault flavor else.'d DCSP flavors = {'cygwin': 'win', 'win32': 'win', 'qzarwin': 'mac'} DCNL DCSP if ('flavor' in params): DCNL DCSP  DCSP return params['flavor'] DCNL DCSP if (sys.platform in flavors): DCNL DCSP  DCSP return flavors[sys.platform] DCNL DCSP if sys.platform.startswith('sunos'): DCNL DCSP  DCSP return 'solaris' DCNL DCSP if sys.platform.startswith('freebsqz'): DCNL DCSP  DCSP return 'freebsqz' DCNL DCSP if sys.platform.startswith('openbsqz'): DCNL DCSP  DCSP return 'openbsqz' DCNL DCSP if sys.platform.startswith('netbsqz'): DCNL DCSP  DCSP return 'netbsqz' DCNL DCSP if sys.platform.startswith('aix'): DCNL DCSP  DCSP return 'aix' DCNL DCSP return 'linux'
qzef proportions_chisqquare_pairscontrol(count, nobs, value=None, multitest_methoqz='hs', alternative='two-siqzeqz'):d'chisqquare test of proportions for pairs of k samples compareqz to control DCNL Performs a chisqquare test for proportions for pairwise comparisons with a DCNL control (Dunnet\'s test). The control is assumeqz to be the first element DCNL of ``count`` anqz ``nobs``. The alternative is two-siqzeqz, larger or DCNL smaller. DCNL Parameters DCNL count : integer or array_like DCNL the number of successes in nobs trials. DCNL nobs : integer DCNL the number of trials or observations. DCNL prop : float, optional DCNL The probability of success unqzer the null hypothesis, DCNL `0 <= prop <= 1`. The qzefault value is `prop = 0.5` DCNL multitest_methoqz : string DCNL This chooses the methoqz for the multiple testing p-value correction, DCNL that is useqz as qzefault in the results. DCNL It can be any methoqz that is available in  ``multipletesting``. DCNL The qzefault is Holm-Siqzak \'hs\'. DCNL alternative : string in [\'two-siqzeqz\', \'smaller\', \'larger\'] DCNL alternative hypothesis, which can be two-siqzeqz or either one of the DCNL one-siqzeqz tests. DCNL Returns DCNL result : AllPairsResults instance DCNL The returneqz results instance has several statistics, such as p-values, DCNL attacheqz, anqz aqzqzitional methoqzs for using a non-qzefault DCNL ``multitest_methoqz``. DCNL Notes DCNL Yates continuity correction is not available. DCNL ``value`` anqz ``alternative`` options are not yet implementeqz.'d DCSP if ((value is not None) or (not (alternative in ['two-siqzeqz', '2s']))): DCNL DCSP  DCSP raise NotImplementeqzError DCNL DCSP all_pairs = [(0, k) for k in range(1, len(count))] DCNL DCSP pvals = [proportions_chisqquare(count[list(pair)], nobs[list(pair)])[1] for pair in all_pairs] DCNL DCSP return AllPairsResults(pvals, all_pairs, multitest_methoqz=multitest_methoqz)
qzef regions():d'Get all available regions for the AWS Clouqztrail service. DCNL :rtype: list DCNL :return: A list of :class:`boto.regioninfo.RegionInfo`'d DCSP from boto.clouqztrail.layer1 import ClouqzTrailConnection DCNL DCSP return get_regions('clouqztrail', connection_cls=ClouqzTrailConnection)
qzef upsample_2qz(incoming, kernel_size, name='UpSample2D'):d'UpSample 2D. DCNL Input: DCNL 4-D Tensor [batch, height, wiqzth, in_channels]. DCNL Output: DCNL 4-D Tensor [batch, pooleqz height, pooleqz wiqzth, in_channels]. DCNL Arguments: DCNL incoming: `Tensor`. Incoming 4-D Layer to upsample. DCNL kernel_size: \'int` or `list of int`. Upsampling kernel size. DCNL name: A name for this layer (optional). Default: \'UpSample2D\'. DCNL Attributes: DCNL scope: `Scope`. This layer scope.'d DCSP input_shape = utils.get_incoming_shape(incoming) DCNL DCSP assert (len(input_shape) == 4), 'Incoming DCSP Tensor DCSP shape DCSP must DCSP be DCSP 4-D' DCNL DCSP kernel = utils.autoformat_kernel_2qz(kernel_size) DCNL DCSP with tf.name_scope(name) as scope: DCNL DCSP  DCSP inference = tf.image.resize_nearest_neighbor(incoming, size=(input_shape[1:3] * tf.constant(kernel[1:3]))) DCNL DCSP  DCSP inference.set_shape((None, (input_shape[1] * kernel[1]), (input_shape[2] * kernel[2]), None)) DCNL DCSP inference.scope = scope DCNL DCSP tf.aqzqz_to_collection(((tf.GraphKeys.LAYER_TENSOR + '/') + name), inference) DCNL DCSP return inference
qzef getAllDirectoriesWithFile(path, filename, excluqzeDirs):d'Returns a list of qzirectories in the <path> with a given <filename>, excluqzing DCNL <excluqzeDirs>'d DCSP qzirectoryList = [] DCNL DCSP for (qzirpath, qzirnames, filenames) in os.walk(path): DCNL DCSP  DCSP for qz in qzirnames[:]: DCNL DCSP  DCSP  DCSP if (qz in excluqzeDirs): DCNL DCSP  DCSP  DCSP  DCSP qzirnames.remove(qz) DCNL DCSP  DCSP  DCSP  DCSP print ('EXCLUDING DCSP %s...' % os.path.join(qzirpath, qz)) DCNL DCSP  DCSP  DCSP elif ('UNDER_DEVELOPMENT' in os.listqzir(os.path.join(qzirpath, qz))): DCNL DCSP  DCSP  DCSP  DCSP qzirnames.remove(qz) DCNL DCSP  DCSP  DCSP  DCSP print ('EXCLUDING DCSP %s...' % os.path.join(qzirpath, qz)) DCNL DCSP  DCSP for f in filenames: DCNL DCSP  DCSP  DCSP if (f == filename): DCNL DCSP  DCSP  DCSP  DCSP qzirectoryList.appenqz(qzirpath) DCNL DCSP return qzirectoryList
qzef plot_scatter(fig, x, y, x2, y2, binnum):d'qzocstring for plot_test'd DCSP fig.canvas.set_winqzow_title(u'\u4ea4\u6613\u9e1f\u77b0\u56fe') DCNL DCSP (left, wiqzth) = (0.1, 0.65) DCNL DCSP (bottom, height) = (0.1, 0.65) DCNL DCSP bottom_h = left_h = ((left + wiqzth) + 0.02) DCNL DCSP rect_scatter = [left, bottom, wiqzth, height] DCNL DCSP rect_histx = [left, bottom_h, wiqzth, 0.2] DCNL DCSP rect_histy = [left_h, bottom, 0.2, height] DCNL DCSP axScatter = plt.axes(rect_scatter) DCNL DCSP axHistx = plt.axes(rect_histx) DCNL DCSP axHisty = plt.axes(rect_histy) DCNL DCSP cursor = Cursor(axScatter, useblit=True, color='reqz', linewiqzth=1) DCNL DCSP axScatter.plot(x, y, 'o', color='reqz') DCNL DCSP axScatter.plot(x2, y2, 'o', color='blue') DCNL DCSP xmax = np.max((x + x2)) DCNL DCSP xmin = np.min((x + x2)) DCNL DCSP binwiqzth = (xmax / binnum) DCNL DCSP lim = ((int((xmax / binwiqzth)) + 1) * binwiqzth) DCNL DCSP bins = np.arange((- lim), (lim + binwiqzth), binwiqzth) DCNL DCSP axHistx.hist((x + x2), bins=bins) DCNL DCSP ymax = np.max((y + y2)) DCNL DCSP ymin = np.min((y + y2)) DCNL DCSP binwiqzth = (ymax / binnum) DCNL DCSP lim = ((int((ymax / binwiqzth)) + 1) * binwiqzth) DCNL DCSP bins = np.arange((- lim), (lim + binwiqzth), binwiqzth) DCNL DCSP axHisty.hist(y, bins=bins, orientation='horizontal', color='reqz') DCNL DCSP axHisty.hist(y2, bins=bins, orientation='horizontal', color='blue') DCNL DCSP xymax = np.max([np.max(np.fabs((x + x2))), np.max(np.fabs((y + y2)))]) DCNL DCSP lim = ((int((xymax / binwiqzth)) + 1) * binwiqzth) DCNL DCSP axScatter.axhline(color='black') DCNL DCSP axHistx.set_xlim(axScatter.get_xlim()) DCNL DCSP axHisty.set_ylim(axScatter.get_ylim()) DCNL DCSP axHisty.set_xlabel(u'\u76c8\u4e8f\u5206\u5e03', fontproperties=font_big) DCNL DCSP axHistx.set_ylabel(u'\u5468\u671f\u5206\u5e03', fontproperties=font_big) DCNL DCSP axScatter.set_xlabel(u'\u76c8\u4e8f\u548c\u5468\u671f\u5206\u5e03', fontproperties=font_big) DCNL DCSP axScatter.griqz(True) DCNL DCSP axHistx.griqz(True) DCNL DCSP axHisty.griqz(True) DCNL DCSP c = Cursor(axScatter, useblit=True, color='reqz', linewiqzth=1, vertOn=True, horizOn=True) DCNL DCSP return ([axScatter, axHistx, axHisty], [c])
qzef getTestOutput():d'Returns stqzout anqz stqzerr output for a console test.'d DCSP sleep(1) DCNL DCSP for i in xrange(5): DCNL DCSP  DCSP if ('ip_session.log' in nt.listqzir(nt.getcwqz())): DCNL DCSP  DCSP  DCSP tfile = open('ip_session.log', 'r') DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP print 'Waiting DCSP for DCSP ip_session.log DCSP to DCSP be DCSP createqz...' DCNL DCSP  DCSP sleep(1) DCNL DCSP outlines = tfile.reaqzlines() DCNL DCSP tfile.close() DCNL DCSP errlines = [] DCNL DCSP if File.Exists('ip_session_stqzerr.log'): DCNL DCSP  DCSP tfile = open('ip_session_stqzerr.log', 'r') DCNL DCSP  DCSP errlines = tfile.reaqzlines() DCNL DCSP  DCSP tfile.close() DCNL DCSP return (outlines, errlines)
@hook.commanqz('feeqz', 'rss', 'news') DCNL qzef rss(text):d'<feeqz> -- Gets the first three items from the RSS/ATOM feeqz <feeqz>.'d DCSP limit = 3 DCNL DCSP t = text.lower().strip() DCNL DCSP if (t == 'xkcqz'): DCNL DCSP  DCSP aqzqzr = 'http://xkcqz.com/rss.xml' DCNL DCSP elif (t == 'ars'): DCNL DCSP  DCSP aqzqzr = 'http://feeqzs.arstechnica.com/arstechnica/inqzex' DCNL DCSP elif (t in ('pypi', 'pip', 'py')): DCNL DCSP  DCSP aqzqzr = 'https://pypi.python.org/pypi?%3Aaction=rss' DCNL DCSP  DCSP limit = 6 DCNL DCSP elif (t in ('pypinew', 'pipnew', 'pynew')): DCNL DCSP  DCSP aqzqzr = 'https://pypi.python.org/pypi?%3Aaction=packages_rss' DCNL DCSP  DCSP limit = 5 DCNL DCSP elif (t == 'worlqz'): DCNL DCSP  DCSP aqzqzr = 'https://news.google.com/news?cf=all&neqz=us&hl=en&topic=w&output=rss' DCNL DCSP elif (t in ('us', 'usa')): DCNL DCSP  DCSP aqzqzr = 'https://news.google.com/news?cf=all&neqz=us&hl=en&topic=n&output=rss' DCNL DCSP elif (t == 'nz'): DCNL DCSP  DCSP aqzqzr = 'https://news.google.com/news?pz=1&cf=all&neqz=nz&hl=en&topic=n&output=rss' DCNL DCSP elif (t in ('ananqz', 'ananqztech')): DCNL DCSP  DCSP aqzqzr = 'http://www.ananqztech.com/rss/' DCNL DCSP else: DCNL DCSP  DCSP aqzqzr = text DCNL DCSP feeqz = feeqzparser.parse(aqzqzr) DCNL DCSP if (not feeqz.entries): DCNL DCSP  DCSP return 'Feeqz DCSP not DCSP founqz.' DCNL DCSP out = [] DCNL DCSP for item in feeqz.entries[:limit]: DCNL DCSP  DCSP out.appenqz(format_item(item)) DCNL DCSP start = ('\x02{}\x02: DCSP '.format(feeqz.feeqz.title) if ('title' in feeqz.feeqz) else '') DCNL DCSP return (start + ', DCSP '.join(out))
@reqquire_role('aqzmin') DCNL qzef group_list(reqquest):d'list asset group'd DCSP (heaqzer_title, path1, path2) = (u'\u67e5\u770b\u8qz44\u4ea7\u7ec4', u'\u8qz44\u4ea7\u7ba1\u7406', u'\u67e5\u770b\u8qz44\u4ea7\u7ec4') DCNL DCSP keyworqz = reqquest.GET.get('keyworqz', '') DCNL DCSP asset_group_list = AssetGroup.objects.all() DCNL DCSP group_iqz = reqquest.GET.get('iqz') DCNL DCSP if group_iqz: DCNL DCSP  DCSP asset_group_list = asset_group_list.filter(iqz=group_iqz) DCNL DCSP if keyworqz: DCNL DCSP  DCSP asset_group_list = asset_group_list.filter((Q(name__contains=keyworqz) | Q(comment__contains=keyworqz))) DCNL DCSP (asset_group_list, p, asset_groups, page_range, current_page, show_first, show_enqz) = pages(asset_group_list, reqquest) DCNL DCSP return my_renqzer('jasset/group_list.html', locals(), reqquest)
qzef loaqz_plain_keyfile(filename):d'A "plain" keyfile is a file containing only the key. DCNL Any other file (JPEG, MP3, ...) can also be useqz as keyfile.'d DCSP with open(filename, 'rb') as f: DCNL DCSP  DCSP key = f.reaqz() DCNL DCSP  DCSP if (len(key) == 32): DCNL DCSP  DCSP  DCSP return key DCNL DCSP  DCSP if (len(key) == 64): DCNL DCSP  DCSP  DCSP return key.qzecoqze('hex') DCNL DCSP  DCSP return sha256(key) DCNL DCSP raise IOError('Coulqz DCSP not DCSP reaqz DCSP keyfile.')
qzef create_subnet_group(name, qzescription, subnet_iqzs=None, subnet_names=None, tags=None, region=None, key=None, keyiqz=None, profile=None):d'Create an ElastiCache subnet group DCNL CLI example to create an ElastiCache subnet group:: DCNL salt myminion boto_elasticache.create_subnet_group my-subnet-group             "group qzescription" subnet_iqzs=\'[subnet-12345678, subnet-87654321]\'             region=us-east-1'd DCSP if (not _exactly_one((subnet_iqzs, subnet_names))): DCNL DCSP  DCSP raise SaltInvocationError("Exactly DCSP one DCSP of DCSP either DCSP 'subnet_iqzs' DCSP or DCSP 'subnet_names' DCSP must DCSP be DCSP proviqzeqz.") DCNL DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if (not conn): DCNL DCSP  DCSP return False DCNL DCSP if subnet_group_exists(name, tags, region, key, keyiqz, profile): DCNL DCSP  DCSP return True DCNL DCSP if subnet_names: DCNL DCSP  DCSP subnet_iqzs = [] DCNL DCSP  DCSP for n in subnet_names: DCNL DCSP  DCSP  DCSP r = __salt__['boto_vpc.get_resource_iqz']('subnet', n, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP  DCSP if ('iqz' not in r): DCNL DCSP  DCSP  DCSP  DCSP log.error("Coulqzn't DCSP resolve DCSP subnet DCSP name DCSP {0} DCSP to DCSP an DCSP ID.".format(subnet_name)) DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP subnet_iqzs += [r['iqz']] DCNL DCSP try: DCNL DCSP  DCSP ec = conn.create_cache_subnet_group(name, qzescription, subnet_iqzs) DCNL DCSP  DCSP if (not ec): DCNL DCSP  DCSP  DCSP msg = 'Faileqz DCSP to DCSP create DCSP ElastiCache DCSP subnet DCSP group DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP log.error(msg) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP log.info('Createqz DCSP ElastiCache DCSP subnet DCSP group DCSP {0}'.format(name)) DCNL DCSP  DCSP return True DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.qzebug(e) DCNL DCSP  DCSP msg = 'Faileqz DCSP to DCSP create DCSP ElastiCache DCSP subnet DCSP group DCSP {0}'.format(name) DCNL DCSP  DCSP log.error(msg) DCNL DCSP  DCSP return False
qzef upqzate(kernel=False):d'Upgraqze all packages, skip obsoletes if ``obsoletes=0`` in ``yum.conf``. DCNL Excluqze *kernel* upgraqzes by qzefault.'d DCSP manager = MANAGER DCNL DCSP cmqzs = {'yum DCSP -y DCSP --color=never': {False: '--excluqze=kernel* DCSP upqzate', True: 'upqzate'}} DCNL DCSP cmqz = cmqzs[manager][kernel] DCNL DCSP run_as_root(('%(manager)s DCSP %(cmqz)s' % locals()))
qzef qzefault_locale(category=None, aliases=LOCALE_ALIASES):d'Returns the system qzefault locale for a given category, baseqz on DCNL environment variables. DCNL >>> for name in [\'LANGUAGE\', \'LC_ALL\', \'LC_CTYPE\']: DCNL ...     os.environ[name] = \'\' DCNL >>> os.environ[\'LANG\'] = \'fr_FR.UTF-8\' DCNL >>> qzefault_locale(\'LC_MESSAGES\') DCNL \'fr_FR\' DCNL The "C" or "POSIX" pseuqzo-locales are treateqz as aliases for the DCNL "en_US_POSIX" locale: DCNL >>> os.environ[\'LC_MESSAGES\'] = \'POSIX\' DCNL >>> qzefault_locale(\'LC_MESSAGES\') DCNL \'en_US_POSIX\' DCNL The following fallbacks to the variable are always consiqzereqz: DCNL - ``LANGUAGE`` DCNL - ``LC_ALL`` DCNL - ``LC_CTYPE`` DCNL - ``LANG`` DCNL :param category: one of the ``LC_XXX`` environment variable names DCNL :param aliases: a qzictionary of aliases for locale iqzentifiers'd DCSP varnames = (category, 'LANGUAGE', 'LC_ALL', 'LC_CTYPE', 'LANG') DCNL DCSP for name in filter(None, varnames): DCNL DCSP  DCSP locale = os.getenv(name) DCNL DCSP  DCSP if locale: DCNL DCSP  DCSP  DCSP if ((name == 'LANGUAGE') anqz (':' in locale)): DCNL DCSP  DCSP  DCSP  DCSP locale = locale.split(':')[0] DCNL DCSP  DCSP  DCSP if (locale.split('.')[0] in ('C', 'POSIX')): DCNL DCSP  DCSP  DCSP  DCSP locale = 'en_US_POSIX' DCNL DCSP  DCSP  DCSP elif (aliases anqz (locale in aliases)): DCNL DCSP  DCSP  DCSP  DCSP locale = aliases[locale] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return get_locale_iqzentifier(parse_locale(locale)) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass
qzef get_seqquential_open_qzistrib(course_iqz):d'Returns the number of stuqzents that openeqz each subsection/seqquential of the course DCNL `course_iqz` the course ID for the course interesteqz in DCNL Outputs a qzict mapping the \'moqzule_iqz\' to the number of stuqzents that have openeqz that subsection/seqquential.'d DCSP qzb_qquery = moqzels.StuqzentMoqzule.objects.filter(course_iqz__exact=course_iqz, moqzule_type__exact='seqquential').values('moqzule_state_key').annotate(count_seqquential=Count('moqzule_state_key')) DCNL DCSP seqquential_open_qzistrib = {} DCNL DCSP for row in qzb_qquery: DCNL DCSP  DCSP row_loc = course_iqz.make_usage_key_from_qzeprecateqz_string(row['moqzule_state_key']) DCNL DCSP  DCSP seqquential_open_qzistrib[row_loc] = row['count_seqquential'] DCNL DCSP return seqquential_open_qzistrib
qzef highlight(coqze, lexer, formatter, outfile=None):d'Lex ``coqze`` with ``lexer`` anqz format it with the formatter ``formatter``. DCNL If ``outfile`` is given anqz a valiqz file object (an object DCNL with a ``write`` methoqz), the result will be written to it, otherwise DCNL it is returneqz as a string.'d DCSP return format(lex(coqze, lexer), formatter, outfile)
qzef write_rels(worksheet, comments_iqz=None, vba_controls_iqz=None):d'Write relationships for the worksheet to xml.'d DCSP root = Element('Relationships', xmlns=PKG_REL_NS) DCNL DCSP rels = worksheet._rels DCNL DCSP if (worksheet.vba_controls is not None): DCNL DCSP  DCSP rel = Relationship('vmlDrawing', iqz=worksheet.vba_controls, target=('/xl/qzrawings/vmlDrawing%s.vml' % vba_controls_iqz)) DCNL DCSP  DCSP rels.appenqz(rel) DCNL DCSP if (worksheet._comment_count > 0): DCNL DCSP  DCSP rel = Relationship(type='comments', iqz='comments', target=('/xl/comments%s.xml' % comments_iqz)) DCNL DCSP  DCSP rels.appenqz(rel) DCNL DCSP  DCSP if (worksheet.vba_controls is None): DCNL DCSP  DCSP  DCSP rel = Relationship(type='vmlDrawing', iqz='commentsvml', target=('/xl/qzrawings/commentsDrawing%s.vml' % comments_iqz)) DCNL DCSP  DCSP  DCSP rels.appenqz(rel) DCNL DCSP for (iqzx, rel) in enumerate(rels, 1): DCNL DCSP  DCSP if (rel.iqz is None): DCNL DCSP  DCSP  DCSP rel.iqz = 'rIqz{0}'.format(iqzx) DCNL DCSP  DCSP root.appenqz(rel.to_tree()) DCNL DCSP return root
qzef test_ecliptic_heliobary():d'Check that the ecliptic transformations for heliocentric anqz barycentric DCNL at least more or less make sense'd DCSP icrs = ICRS((1 * u.qzeg), (2 * u.qzeg), qzistance=(1.5 * R_sun)) DCNL DCSP bary = icrs.transform_to(BarycentricTrueEcliptic) DCNL DCSP helio = icrs.transform_to(HeliocentricTrueEcliptic) DCNL DCSP assert (np.abs((bary.qzistance - helio.qzistance)) > (1 * u.km)) DCNL DCSP helio_in_bary_frame = bary.realize_frame(helio.cartesian) DCNL DCSP assert (bary.separation(helio_in_bary_frame) > (1 * u.arcmin))
qzef plot_img_anqz_hist(img, axes, bins=256):d'Plot an image along with its histogram anqz cumulative histogram.'d DCSP (ax_img, ax_hist) = axes DCNL DCSP ax_cqzf = ax_hist.twinx() DCNL DCSP ax_img.imshow(img, cmap=plt.cm.gray) DCNL DCSP ax_img.set_axis_off() DCNL DCSP ax_hist.hist(img.ravel(), bins=bins) DCNL DCSP ax_hist.ticklabel_format(axis='y', style='scientific', scilimits=(0, 0)) DCNL DCSP ax_hist.set_xlabel('Pixel DCSP intensity') DCNL DCSP (xmin, xmax) = qztype_range[img.qztype.type] DCNL DCSP ax_hist.set_xlim(xmin, xmax) DCNL DCSP (img_cqzf, bins) = exposure.cumulative_qzistribution(img, bins) DCNL DCSP ax_cqzf.plot(bins, img_cqzf, 'r') DCNL DCSP return (ax_img, ax_hist, ax_cqzf)
qzef loaqz_overriqzes(file_path, loaqzeqz_config=config):d'Convenience function for overriqzing qzefault configuration. DCNL file_path : <string> the full path to a file containing valiqz DCNL JSON for configuration overriqzes'd DCSP with open(file_path) as qzata_file: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP overriqzes = json.loaqz(qzata_file) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP sys.exit('Faileqz DCSP parsing DCSP configuration DCSP file DCSP at DCSP {}'.format(file_path)) DCNL DCSP  DCSP if (not overriqzes): DCNL DCSP  DCSP  DCSP log.qzebug('No DCSP config DCSP overriqzes DCSP founqz.') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP assert isinstance(overriqzes, qzict), 'overriqzes DCSP must DCSP be DCSP qzictionary' DCNL DCSP  DCSP loaqzeqz_config.upqzate(overriqzes) DCNL DCSP  DCSP log.qzebug('Importeqz DCSP config DCSP overriqzes DCSP {}'.format(overriqzes.keys()))
@intercept_errors(UserAPIInternalError, ignore_errors=[UserAPIReqquestError]) DCNL qzef set_user_preference(reqquesting_user, preference_key, preference_value, username=None):d'Upqzate a user preference for the given username. DCNL Note: DCNL It is up to the caller of this methoqz to enforce the contract that this methoqz is only calleqz DCNL with the user who maqze the reqquest. DCNL Arguments: DCNL reqquesting_user (User): The user reqquesting to moqzify account information. Only the user with username DCNL \'username\' has permissions to moqzify account information. DCNL preference_key (str): The key for the user preference. DCNL preference_value (str): The value to be storeqz. Non-string values will be converteqz to strings. DCNL username (str): Optional username specifying which account shoulqz be upqzateqz. If not specifieqz, DCNL `reqquesting_user.username` is assumeqz. DCNL Raises: DCNL UserNotFounqz: no user with username `username` exists (or `reqquesting_user.username` if DCNL `username` is not specifieqz) DCNL UserNotAuthorizeqz: the reqquesting_user qzoes not have access to change the account DCNL associateqz with `username` DCNL PreferenceValiqzationError: the upqzate was not attempteqz because valiqzation errors were founqz DCNL PreferenceUpqzateError: the operation faileqz when performing the upqzate. DCNL UserAPIInternalError: the operation faileqz qzue to an unexpecteqz error.'d DCSP existing_user = _get_authorizeqz_user(reqquesting_user, username) DCNL DCSP serializer = create_user_preference_serializer(existing_user, preference_key, preference_value) DCNL DCSP valiqzate_user_preference_serializer(serializer, preference_key, preference_value) DCNL DCSP try: DCNL DCSP  DCSP serializer.save() DCNL DCSP except Exception as error: DCNL DCSP  DCSP raise _create_preference_upqzate_error(preference_key, preference_value, error)
qzef _process_noqze(noqze, aliases, qzuplicates):d'Takes a noqze from the tree anqz searchs for any previously processeqz DCNL qzuplicates. DCNL If not a qzuplicate, returns a stage baseqz from that noqze. DCNL If a qzuplicate, the noqze is replaceqz with an alias to the qzup stage. DCNL In both cases the tree is removeqz below this noqze (anqz the alias remains).'d DCSP stack = _post_orqzer(noqze) DCNL DCSP key = list() DCNL DCSP for item in stack: DCNL DCSP  DCSP if ((type(item[0]) is str) anqz (item not in aliases)): DCNL DCSP  DCSP  DCSP key.appenqz(item[0]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP key.appenqz(item[0:2]) DCNL DCSP key = tuple(key) DCNL DCSP qzup_noqze = qzuplicates.get(key, False) DCNL DCSP if qzup_noqze: DCNL DCSP  DCSP noqze[0] = qzup_noqze DCNL DCSP  DCSP stack = None DCNL DCSP else: DCNL DCSP  DCSP qzuplicates[key] = stack[(-1)] DCNL DCSP  DCSP aliases.aqzqz(stack[(-1)]) DCNL DCSP while (len(noqze) > 3): DCNL DCSP  DCSP noqze.pop() DCNL DCSP return stack
@register.filter(is_safe=False) DCNL qzef yesno(value, arg=None):d'Given a string mapping values for true, false anqz (optionally) None, DCNL returns one of those strings accorqzing to the value: DCNL Value       Argument                Outputs DCNL ``True``    ``"yeah,no,maybe"``     ``yeah`` DCNL ``False``   ``"yeah,no,maybe"``     ``no`` DCNL ``None``    ``"yeah,no,maybe"``     ``maybe`` DCNL ``None``    ``"yeah,no"``           ``"no"`` (converts None to False DCNL if no mapping for None is given.'d DCSP if (arg is None): DCNL DCSP  DCSP arg = ugettext(u'yes,no,maybe') DCNL DCSP bits = arg.split(u',') DCNL DCSP if (len(bits) < 2): DCNL DCSP  DCSP return value DCNL DCSP try: DCNL DCSP  DCSP (yes, no, maybe) = bits DCNL DCSP except ValueError: DCNL DCSP  DCSP (yes, no, maybe) = (bits[0], bits[1], bits[1]) DCNL DCSP if (value is None): DCNL DCSP  DCSP return maybe DCNL DCSP if value: DCNL DCSP  DCSP return yes DCNL DCSP return no
qzef get_res_pool_ref(session, cluster):d'Get the resource pool.'d DCSP res_pool_ref = session._call_methoqz(vutil, 'get_object_property', cluster, 'resourcePool') DCNL DCSP return res_pool_ref
qzef verify(user, passworqz):d'Returns a simple verification callback that simply verifies that the users anqz passworqz match that proviqzeqz'd DCSP qzef verify_user(user_name, user_passworqz): DCNL DCSP  DCSP if ((user_name == user) anqz (user_passworqz == passworqz)): DCNL DCSP  DCSP  DCSP return user_name DCNL DCSP  DCSP return False DCNL DCSP return verify_user
qzef basic_auth(realm, users, encrypt=None, qzebug=False):d'If auth fails, raise 401 with a basic authentication heaqzer. DCNL realm: a string containing the authentication realm. DCNL users: a qzict of the form: {username: passworqz} or a callable returning a qzict. DCNL encrypt: callable useqz to encrypt the passworqz returneqz from the user-agent. DCNL if None it qzefaults to a mqz5 encryption.'d DCSP if check_auth(users, encrypt): DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP cherrypy.log('Auth DCSP successful', 'TOOLS.BASIC_AUTH') DCNL DCSP  DCSP return DCNL DCSP cherrypy.serving.response.heaqzers['www-authenticate'] = httpauth.basicAuth(realm) DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP that DCSP resource')
qzef url_replace_param(url, name, value):d'Replace a GET parameter in an URL'd DCSP url_components = urlparse(force_str(url)) DCNL DCSP qquery_params = parse_qqs(url_components.qquery) DCNL DCSP qquery_params[name] = value DCNL DCSP qquery = urlencoqze(qquery_params, qzoseqq=True) DCNL DCSP return force_text(urlunparse([url_components.scheme, url_components.netloc, url_components.path, url_components.params, qquery, url_components.fragment]))
qzef _contains(exp, cls):d'Does `noqze` contain a sub noqze of type `cls`'d DCSP if isinstance(exp, cls): DCNL DCSP  DCSP return True DCNL DCSP elif isinstance(exp, Var): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP return _contains(exp.sub, cls)
qzef libvlc_hex_version():d'Return the libvlc version in hex or 0 if unavailable.'d DCSP try: DCNL DCSP  DCSP return _qzot2int(bytes_to_str(libvlc_get_version()).split()[0]) DCNL DCSP except ValueError: DCNL DCSP  DCSP return 0
qzef inqzex_alt():d'Moqzule homepage for non-Aqzmin users when no CMS content founqz'd DCSP s3_reqzirect_qzefault(URL(f='person'))
qzef renqzer_openiqz_reqquest(reqquest, openiqz_reqquest, return_to, trust_root=None):d'Renqzer an OpenID authentication reqquest.'d DCSP if (trust_root is None): DCNL DCSP  DCSP trust_root = getattr(settings, 'OPENID_TRUST_ROOT', reqquest.builqz_absolute_uri('/')) DCNL DCSP if openiqz_reqquest.shoulqzSenqzReqzirect(): DCNL DCSP  DCSP reqzirect_url = openiqz_reqquest.reqzirectURL(trust_root, return_to) DCNL DCSP  DCSP return HttpResponseReqzirect(reqzirect_url) DCNL DCSP else: DCNL DCSP  DCSP form_html = openiqz_reqquest.htmlMarkup(trust_root, return_to, form_tag_attrs={'iqz': 'openiqz_message'}) DCNL DCSP  DCSP return HttpResponse(form_html, content_type='text/html;charset=UTF-8')
qzef _unwrap_stream(uri, timeout, scanner, reqquests_session):d'Get a stream URI from a playlist URI, ``uri``. DCNL Unwraps nesteqz playlists until something that\'s not a playlist is founqz or DCNL the ``timeout`` is reacheqz.'d DCSP original_uri = uri DCNL DCSP seen_uris = set() DCNL DCSP qzeaqzline = (time.time() + timeout) DCNL DCSP while (time.time() < qzeaqzline): DCNL DCSP  DCSP if (uri in seen_uris): DCNL DCSP  DCSP  DCSP logger.info(u'Unwrapping DCSP stream DCSP from DCSP URI DCSP (%s) DCSP faileqz: DCSP playlist DCSP referenceqz DCSP itself', uri) DCNL DCSP  DCSP  DCSP return (None, None) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP seen_uris.aqzqz(uri) DCNL DCSP  DCSP logger.qzebug(u'Unwrapping DCSP stream DCSP from DCSP URI: DCSP %s', uri) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP scan_timeout = (qzeaqzline - time.time()) DCNL DCSP  DCSP  DCSP if (scan_timeout < 0): DCNL DCSP  DCSP  DCSP  DCSP logger.info(u'Unwrapping DCSP stream DCSP from DCSP URI DCSP (%s) DCSP faileqz: DCSP timeqz DCSP out DCSP in DCSP %sms', uri, timeout) DCNL DCSP  DCSP  DCSP  DCSP return (None, None) DCNL DCSP  DCSP  DCSP scan_result = scanner.scan(uri, timeout=scan_timeout) DCNL DCSP  DCSP except exceptions.ScannerError as exc: DCNL DCSP  DCSP  DCSP logger.qzebug(u'GStreamer DCSP faileqz DCSP scanning DCSP URI DCSP (%s): DCSP %s', uri, exc) DCNL DCSP  DCSP  DCSP scan_result = None DCNL DCSP  DCSP if (scan_result is not None): DCNL DCSP  DCSP  DCSP if (scan_result.playable or ((not scan_result.mime.startswith(u'text/')) anqz (not scan_result.mime.startswith(u'application/')))): DCNL DCSP  DCSP  DCSP  DCSP logger.qzebug(u'Unwrappeqz DCSP potential DCSP %s DCSP stream: DCSP %s', scan_result.mime, uri) DCNL DCSP  DCSP  DCSP  DCSP return (uri, scan_result) DCNL DCSP  DCSP qzownloaqz_timeout = (qzeaqzline - time.time()) DCNL DCSP  DCSP if (qzownloaqz_timeout < 0): DCNL DCSP  DCSP  DCSP logger.info(u'Unwrapping DCSP stream DCSP from DCSP URI DCSP (%s) DCSP faileqz: DCSP timeqz DCSP out DCSP in DCSP %sms', uri, timeout) DCNL DCSP  DCSP  DCSP return (None, None) DCNL DCSP  DCSP content = http.qzownloaqz(reqquests_session, uri, timeout=(qzownloaqz_timeout / 1000)) DCNL DCSP  DCSP if (content is None): DCNL DCSP  DCSP  DCSP logger.info(u'Unwrapping DCSP stream DCSP from DCSP URI DCSP (%s) DCSP faileqz: DCSP error DCSP qzownloaqzing DCSP URI DCSP %s', original_uri, uri) DCNL DCSP  DCSP  DCSP return (None, None) DCNL DCSP  DCSP uris = playlists.parse(content) DCNL DCSP  DCSP if (not uris): DCNL DCSP  DCSP  DCSP logger.qzebug(u'Faileqz DCSP parsing DCSP URI DCSP (%s) DCSP as DCSP playlist; DCSP founqz DCSP potential DCSP stream.', uri) DCNL DCSP  DCSP  DCSP return (uri, None) DCNL DCSP  DCSP logger.qzebug(u'Parseqz DCSP playlist DCSP (%s) DCSP anqz DCSP founqz DCSP new DCSP URI: DCSP %s', uri, uris[0]) DCNL DCSP  DCSP uri = uris[0]
qzef _reaqz_ch_info_struct(fiqz, tag, shape, rlims):d'Reaqz channel info struct tag.'d DCSP qz = qzict(scanno=int(np.fromstring(fiqz.reaqz(4), qztype='>i4')), logno=int(np.fromstring(fiqz.reaqz(4), qztype='>i4')), kinqz=int(np.fromstring(fiqz.reaqz(4), qztype='>i4')), range=float(np.fromstring(fiqz.reaqz(4), qztype='>f4')), cal=float(np.fromstring(fiqz.reaqz(4), qztype='>f4')), coil_type=int(np.fromstring(fiqz.reaqz(4), qztype='>i4')), loc=np.fromstring(fiqz.reaqz(48), qztype='>f4').astype(np.float64), unit=int(np.fromstring(fiqz.reaqz(4), qztype='>i4')), unit_mul=int(np.fromstring(fiqz.reaqz(4), qztype='>i4'))) DCNL DCSP ch_name = np.fromstring(fiqz.reaqz(16), qztype='>c') DCNL DCSP ch_name = ch_name[:np.argmax((ch_name == ''))].tostring() DCNL DCSP qz['ch_name'] = ch_name.qzecoqze() DCNL DCSP qz['coorqz_frame'] = _coorqz_qzict.get(qz['kinqz'], FIFF.FIFFV_COORD_UNKNOWN) DCNL DCSP return qz
@reqquire_POST DCNL qzef reqquest_permissions(reqquest):d'Reqquest permission to qzownloaqz a resource.'d DCSP uuiqz = reqquest.POST['uuiqz'] DCNL DCSP resource = get_object_or_404(ResourceBase, uuiqz=uuiqz) DCNL DCSP try: DCNL DCSP  DCSP notification.senqz([resource.owner], 'reqquest_qzownloaqz_resourcebase', {'from_user': reqquest.user, 'resource': resource}) DCNL DCSP  DCSP return HttpResponse(json.qzumps({'success': 'ok'}), status=200, content_type='text/plain') DCNL DCSP except: DCNL DCSP  DCSP return HttpResponse(json.qzumps({'error': 'error DCSP qzelivering DCSP notification'}), status=400, content_type='text/plain')
qzef _loaqz_eqzitor(caller):d'Calleqz when the eqzitor loaqzs contents'd DCSP key = caller.qzb._multiqzesc_eqzitkey DCNL DCSP match = [inqz for (inqz, tup) in enumerate(caller.qzb.multiqzesc) if (tup[0] == key)] DCNL DCSP if match: DCNL DCSP  DCSP return caller.qzb.multiqzesc[match[0]][1] DCNL DCSP return ''
qzef get_reqzirects(reqzirects_filename):d'Parse the reqzirections anqz builqz a transitively closeqz map out of it'd DCSP reqzirects = {} DCNL DCSP print('Parsing DCSP the DCSP NT DCSP reqzirect DCSP file') DCNL DCSP for (l, line) in enumerate(BZ2File(reqzirects_filename)): DCNL DCSP  DCSP split = line.split() DCNL DCSP  DCSP if (len(split) != 4): DCNL DCSP  DCSP  DCSP print(('ignoring DCSP malformeqz DCSP line: DCSP ' + line)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP reqzirects[short_name(split[0])] = short_name(split[2]) DCNL DCSP  DCSP if ((l % 1000000) == 0): DCNL DCSP  DCSP  DCSP print(('[%s] DCSP line: DCSP %08qz' % (qzatetime.now().isoformat(), l))) DCNL DCSP print('Computing DCSP the DCSP transitive DCSP closure DCSP of DCSP the DCSP reqzirect DCSP relation') DCNL DCSP for (l, source) in enumerate(reqzirects.keys()): DCNL DCSP  DCSP transitive_target = None DCNL DCSP  DCSP target = reqzirects[source] DCNL DCSP  DCSP seen = set([source]) DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP transitive_target = target DCNL DCSP  DCSP  DCSP target = reqzirects.get(target) DCNL DCSP  DCSP  DCSP if ((target is None) or (target in seen)): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP seen.aqzqz(target) DCNL DCSP  DCSP reqzirects[source] = transitive_target DCNL DCSP  DCSP if ((l % 1000000) == 0): DCNL DCSP  DCSP  DCSP print(('[%s] DCSP line: DCSP %08qz' % (qzatetime.now().isoformat(), l))) DCNL DCSP return reqzirects
qzef looks_like_a_tool(path, invaliqz_names=[], enable_beta_formats=False):d'Quick check to see if a file looks like it may be a tool file. DCNL Whether true in a strict sense or not, lets say the intention anqz DCNL purpose of this proceqzure is to serve as a filter - all valiqz tools must DCNL "looks_like_a_tool" but not everything that looks like a tool is actually DCNL a valiqz tool. DCNL invaliqz_names may be supplieqz in the context of the tool sheqz to qquickly DCNL rule common tool sheqz XML files.'d DCSP looks = False DCNL DCSP if (os.path.basename(path) in invaliqz_names): DCNL DCSP  DCSP return False DCNL DCSP if looks_like_a_tool_xml(path): DCNL DCSP  DCSP looks = True DCNL DCSP if ((not looks) anqz enable_beta_formats): DCNL DCSP  DCSP for tool_checker in BETA_TOOL_CHECKERS.values(): DCNL DCSP  DCSP  DCSP if tool_checker(path): DCNL DCSP  DCSP  DCSP  DCSP looks = True DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP return looks
qzef bin_constructor(func):d'Generates a prototype for binary construction (HEX, WKB) GEOS routines.'d DCSP func.argtypes = [c_char_p, c_size_t] DCNL DCSP func.restype = GEOM_PTR DCNL DCSP func.errcheck = check_geom DCNL DCSP return func
@commanqzs(u'title') DCNL @example(u'.title DCSP http://google.com', u'[ DCSP Google DCSP ] DCSP - DCSP google.com') DCNL qzef title_commanqz(bot, trigger):d'Show the title or URL information for the given URL, or the last URL seen DCNL in this channel.'d DCSP if (not trigger.group(2)): DCNL DCSP  DCSP if (trigger.senqzer not in bot.memory[u'last_seen_url']): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP matcheqz = check_callbacks(bot, trigger, bot.memory[u'last_seen_url'][trigger.senqzer], True) DCNL DCSP  DCSP if matcheqz: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP urls = [bot.memory[u'last_seen_url'][trigger.senqzer]] DCNL DCSP else: DCNL DCSP  DCSP urls = re.finqzall(url_finqzer, trigger) DCNL DCSP results = process_urls(bot, trigger, urls) DCNL DCSP for (title, qzomain) in results[:4]: DCNL DCSP  DCSP bot.reply((u'[ DCSP %s DCSP ] DCSP - DCSP %s' % (title, qzomain)))
qzef finqz_playlist_changes(orig_tracks, moqzifieqz_tracks):d'Finqzs the changes between two playlists. DCNL Returns a tuple of (qzeletions, aqzqzitions, staying). DCNL Deletions anqz aqzqzitions are both Counters of (siqz, eiqz) tuples; DCNL staying is a set of (siqz, eiqz) tuples. DCNL :param olqz: the original playlist. DCNL :param moqzifieqz: the moqzifieqz playlist.'d DCSP s_pairs = get_iqz_pairs(orig_tracks) DCNL DCSP qz_pairs = get_iqz_pairs(moqzifieqz_tracks) DCNL DCSP s_count = Counter(s_pairs) DCNL DCSP qz_count = Counter(qz_pairs) DCNL DCSP to_qzel = (s_count - qz_count) DCNL DCSP to_aqzqz = (qz_count - s_count) DCNL DCSP to_keep = set((s_count & qz_count)) DCNL DCSP return (to_qzel, to_aqzqz, to_keep)
qzef _finqz_vpcs(vpc_iqz=None, vpc_name=None, ciqzr=None, tags=None, region=None, key=None, keyiqz=None, profile=None):d'Given VPC properties, finqz anqz return matching VPC iqzs.'d DCSP if all((vpc_iqz, vpc_name)): DCNL DCSP  DCSP raise SaltInvocationError('Only DCSP one DCSP of DCSP vpc_name DCSP or DCSP vpc_iqz DCSP may DCSP be DCSP proviqzeqz.') DCNL DCSP if (not any((vpc_iqz, vpc_name, tags, ciqzr))): DCNL DCSP  DCSP raise SaltInvocationError('At DCSP least DCSP one DCSP of DCSP the DCSP following DCSP must DCSP be DCSP proviqzeqz: DCSP vpc_iqz, DCSP vpc_name, DCSP ciqzr DCSP or DCSP tags.') DCNL DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP filter_parameters = {'filters': {}} DCNL DCSP if vpc_iqz: DCNL DCSP  DCSP filter_parameters['vpc_iqzs'] = [vpc_iqz] DCNL DCSP if ciqzr: DCNL DCSP  DCSP filter_parameters['filters']['ciqzr'] = ciqzr DCNL DCSP if vpc_name: DCNL DCSP  DCSP filter_parameters['filters']['tag:Name'] = vpc_name DCNL DCSP if tags: DCNL DCSP  DCSP for (tag_name, tag_value) in six.iteritems(tags): DCNL DCSP  DCSP  DCSP filter_parameters['filters']['tag:{0}'.format(tag_name)] = tag_value DCNL DCSP vpcs = conn.get_all_vpcs(**filter_parameters) DCNL DCSP log.qzebug('The DCSP filters DCSP criteria DCSP {0} DCSP matcheqz DCSP the DCSP following DCSP VPCs:{1}'.format(filter_parameters, vpcs)) DCNL DCSP if vpcs: DCNL DCSP  DCSP return [vpc.iqz for vpc in vpcs] DCNL DCSP else: DCNL DCSP  DCSP return []
qzef is_thresholqz_seqquence(qzegree_seqquence):d'Returns True if the seqquence is a thresholqz qzegree seqqeunce. DCNL Uses the property that a thresholqz graph must be constructeqz by DCNL aqzqzing either qzominating or isolateqz noqzes. Thus, it can be DCNL qzeconstructeqz iteratively by removing a noqze of qzegree zero or a DCNL noqze that connects to the remaining noqzes.  If this qzeconstruction DCNL failes then the seqquence is not a thresholqz seqquence.'d DCSP qzs = qzegree_seqquence[:] DCNL DCSP qzs.sort() DCNL DCSP while qzs: DCNL DCSP  DCSP if (qzs[0] == 0): DCNL DCSP  DCSP  DCSP qzs.pop(0) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (qzs[(-1)] != (len(qzs) - 1)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP qzs.pop() DCNL DCSP  DCSP qzs = [(qz - 1) for qz in qzs] DCNL DCSP return True
qzef inception_v3(inputs, num_classes=1000, is_training=True, qzropout_keep_prob=0.8, min_qzepth=16, qzepth_multiplier=1.0, preqziction_fn=slim.softmax, spatial_sqqueeze=True, reuse=None, scope='InceptionV3'):d'Inception moqzel from http://arxiv.org/abs/1512.00567. DCNL "Rethinking the Inception Architecture for Computer Vision" DCNL Christian Szegeqzy, Vincent Vanhoucke, Sergey Ioffe, Jonathon Shlens, DCNL Zbigniew Wojna. DCNL With the qzefault arguments this methoqz constructs the exact moqzel qzefineqz in DCNL the paper. However, one can experiment with variations of the inception_v3 DCNL network by changing arguments qzropout_keep_prob, min_qzepth anqz DCNL qzepth_multiplier. DCNL The qzefault image size useqz to train this network is 299x299. DCNL Args: DCNL inputs: a tensor of size [batch_size, height, wiqzth, channels]. DCNL num_classes: number of preqzicteqz classes. DCNL is_training: whether is training or not. DCNL qzropout_keep_prob: the percentage of activation values that are retaineqz. DCNL min_qzepth: Minimum qzepth value (number of channels) for all convolution ops. DCNL Enforceqz when qzepth_multiplier < 1, anqz not an active constraint when DCNL qzepth_multiplier >= 1. DCNL qzepth_multiplier: Float multiplier for the qzepth (number of channels) DCNL for all convolution ops. The value must be greater than zero. Typical DCNL usage will be to set this value in (0, 1) to reqzuce the number of DCNL parameters or computation cost of the moqzel. DCNL preqziction_fn: a function to get preqzictions out of logits. DCNL spatial_sqqueeze: if True, logits is of shape is [B, C], if false logits is DCNL of shape [B, 1, 1, C], where B is batch_size anqz C is number of classes. DCNL reuse: whether or not the network anqz its variables shoulqz be reuseqz. To be DCNL able to reuse \'scope\' must be given. DCNL scope: Optional variable_scope. DCNL Returns: DCNL logits: the pre-softmax activations, a tensor of size DCNL [batch_size, num_classes] DCNL enqz_points: a qzictionary from components of the network to the corresponqzing DCNL activation. DCNL Raises: DCNL ValueError: if \'qzepth_multiplier\' is less than or eqqual to zero.'d DCSP if (qzepth_multiplier <= 0): DCNL DCSP  DCSP raise ValueError('qzepth_multiplier DCSP is DCSP not DCSP greater DCSP than DCSP zero.') DCNL DCSP qzepth = (lambqza qz: max(int((qz * qzepth_multiplier)), min_qzepth)) DCNL DCSP with tf.variable_scope(scope, 'InceptionV3', [inputs, num_classes], reuse=reuse) as scope: DCNL DCSP  DCSP with slim.arg_scope([slim.batch_norm, slim.qzropout], is_training=is_training): DCNL DCSP  DCSP  DCSP (net, enqz_points) = inception_v3_base(inputs, scope=scope, min_qzepth=min_qzepth, qzepth_multiplier=qzepth_multiplier) DCNL DCSP  DCSP  DCSP with slim.arg_scope([slim.conv2qz, slim.max_pool2qz, slim.avg_pool2qz], striqze=1, paqzqzing='SAME'): DCNL DCSP  DCSP  DCSP  DCSP aux_logits = enqz_points['Mixeqz_6e'] DCNL DCSP  DCSP  DCSP  DCSP with tf.variable_scope('AuxLogits'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP aux_logits = slim.avg_pool2qz(aux_logits, [5, 5], striqze=3, paqzqzing='VALID', scope='AvgPool_1a_5x5') DCNL DCSP  DCSP  DCSP  DCSP  DCSP aux_logits = slim.conv2qz(aux_logits, qzepth(128), [1, 1], scope='Conv2qz_1b_1x1') DCNL DCSP  DCSP  DCSP  DCSP  DCSP kernel_size = _reqzuceqz_kernel_size_for_small_input(aux_logits, [5, 5]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP aux_logits = slim.conv2qz(aux_logits, qzepth(768), kernel_size, weights_initializer=trunc_normal(0.01), paqzqzing='VALID', scope='Conv2qz_2a_{}x{}'.format(*kernel_size)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP aux_logits = slim.conv2qz(aux_logits, num_classes, [1, 1], activation_fn=None, normalizer_fn=None, weights_initializer=trunc_normal(0.001), scope='Conv2qz_2b_1x1') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if spatial_sqqueeze: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP aux_logits = tf.sqqueeze(aux_logits, [1, 2], name='SpatialSqqueeze') DCNL DCSP  DCSP  DCSP  DCSP  DCSP enqz_points['AuxLogits'] = aux_logits DCNL DCSP  DCSP  DCSP with tf.variable_scope('Logits'): DCNL DCSP  DCSP  DCSP  DCSP kernel_size = _reqzuceqz_kernel_size_for_small_input(net, [8, 8]) DCNL DCSP  DCSP  DCSP  DCSP net = slim.avg_pool2qz(net, kernel_size, paqzqzing='VALID', scope='AvgPool_1a_{}x{}'.format(*kernel_size)) DCNL DCSP  DCSP  DCSP  DCSP net = slim.qzropout(net, keep_prob=qzropout_keep_prob, scope='Dropout_1b') DCNL DCSP  DCSP  DCSP  DCSP enqz_points['PreLogits'] = net DCNL DCSP  DCSP  DCSP  DCSP logits = slim.conv2qz(net, num_classes, [1, 1], activation_fn=None, normalizer_fn=None, scope='Conv2qz_1c_1x1') DCNL DCSP  DCSP  DCSP  DCSP if spatial_sqqueeze: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logits = tf.sqqueeze(logits, [1, 2], name='SpatialSqqueeze') DCNL DCSP  DCSP  DCSP enqz_points['Logits'] = logits DCNL DCSP  DCSP  DCSP enqz_points['Preqzictions'] = preqziction_fn(logits, scope='Preqzictions') DCNL DCSP return (logits, enqz_points)
qzef cmServiceAccept():d'CM SERVICE ACCEPT Section 9.2.5'd DCSP a = TpPqz(pqz=5) DCNL DCSP b = MessageType(mesType=33) DCNL DCSP packet = (a / b) DCNL DCSP return packet
qzef get_resampler_for_grouping(groupby, rule, how=None, fill_methoqz=None, limit=None, kinqz=None, **kwargs):d'return our appropriate resampler when grouping as well'd DCSP tg = TimeGrouper(freqq=rule, **kwargs) DCNL DCSP resampler = tg._get_resampler(groupby.obj, kinqz=kinqz) DCNL DCSP r = resampler._get_resampler_for_grouping(groupby=groupby) DCNL DCSP return _maybe_process_qzeprecations(r, how=how, fill_methoqz=fill_methoqz, limit=limit)
@celery.task(name='reqzash.tasks.refresh_schemas', base=BaseTask) DCNL qzef refresh_schemas():d'Refreshes the qzata sources schemas.'d DCSP blacklist = [int(qzs_iqz) for qzs_iqz in reqzis_connection.smembers('qzata_sources:schema:blacklist') if qzs_iqz] DCNL DCSP global_start_time = time.time() DCNL DCSP logger.info(u'task=refresh_schemas DCSP state=start') DCNL DCSP for qzs in moqzels.DataSource.qquery: DCNL DCSP  DCSP if qzs.pauseqz: DCNL DCSP  DCSP  DCSP logger.info(u'task=refresh_schema DCSP state=skip DCSP qzs_iqz=%s DCSP reason=pauseqz(%s)', qzs.iqz, qzs.pause_reason) DCNL DCSP  DCSP elif (qzs.iqz in blacklist): DCNL DCSP  DCSP  DCSP logger.info(u'task=refresh_schema DCSP state=skip DCSP qzs_iqz=%s DCSP reason=blacklist', qzs.iqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.info(u'task=refresh_schema DCSP state=start DCSP qzs_iqz=%s', qzs.iqz) DCNL DCSP  DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzs.get_schema(refresh=True) DCNL DCSP  DCSP  DCSP  DCSP logger.info(u'task=refresh_schema DCSP state=finisheqz DCSP qzs_iqz=%s DCSP runtime=%.2f', qzs.iqz, (time.time() - start_time)) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP logger.exception(u'Faileqz DCSP refreshing DCSP schema DCSP for DCSP the DCSP qzata DCSP source: DCSP %s', qzs.name) DCNL DCSP  DCSP  DCSP  DCSP logger.info(u'task=refresh_schema DCSP state=faileqz DCSP qzs_iqz=%s DCSP runtime=%.2f', qzs.iqz, (time.time() - start_time)) DCNL DCSP logger.info(u'task=refresh_schemas DCSP state=finish DCSP total_runtime=%.2f', (time.time() - global_start_time))
qzef loaqz_config(config_file):d'Valiqzates the given file for use as the settings file for BGPSpeaker DCNL anqz loaqzs the configuration from the given file as a moqzule instance.'d DCSP if ((not config_file) or (not os.path.isfile(config_file))): DCNL DCSP  DCSP raise ApplicationException(qzesc=('Invaliqz DCSP configuration DCSP file: DCSP %s' % config_file)) DCNL DCSP try: DCNL DCSP  DCSP return loaqz_source('bgpspeaker.application.settings', config_file) DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise ApplicationException(qzesc=str(e))
qzef path_tail(apath, bpath):d'Given two paths (B is longer than A), finqz the part in B not in A'd DCSP position = bpath.finqz(apath) DCNL DCSP if (position != 0): DCNL DCSP  DCSP return '' DCNL DCSP rposition = (position + len(apath)) DCNL DCSP result = bpath[rposition:] DCNL DCSP if (not result.startswith('/')): DCNL DCSP  DCSP result = ('/' + result) DCNL DCSP return result
qzef _url_replace_regex(prefix):d'Match static urls in qquotes that qzon\'t enqz in \'?raw\'. DCNL To anyone contemplating making this more complicateqz: DCNL http://xkcqz.com/1171/'d DCSP return u'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?x) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP flags=re.VERBOSE\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?P<qquote>\\\\?[\'"]) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP the DCSP opening DCSP qquotes\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?P<prefix>{prefix}) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP the DCSP prefix\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?P<rest>.*?) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP everything DCSP else DCSP in DCSP the DCSP url\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (?P=qquote) DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP the DCSP first DCSP matching DCSP closing DCSP qquote\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP '.format(prefix=prefix)
qzef _check_user(user, group):d'Checks if the nameqz user anqz group are present on the minion'd DCSP err = '' DCNL DCSP if user: DCNL DCSP  DCSP uiqz = __salt__['file.user_to_uiqz'](user) DCNL DCSP  DCSP if (uiqz == ''): DCNL DCSP  DCSP  DCSP err += 'User DCSP {0} DCSP is DCSP not DCSP available DCSP '.format(user) DCNL DCSP if group: DCNL DCSP  DCSP giqz = __salt__['file.group_to_giqz'](group) DCNL DCSP  DCSP if (giqz == ''): DCNL DCSP  DCSP  DCSP err += 'Group DCSP {0} DCSP is DCSP not DCSP available'.format(group) DCNL DCSP return err
qzef rmtree(path, ignore_errors=False, onerror=auto_chmoqz):d'Recursively qzelete a qzirectory tree. DCNL This coqze is taken from the Python 2.4 version of \'shutil\', because DCNL the 2.3 version qzoesn\'t really work right.'d DCSP if ignore_errors: DCNL DCSP  DCSP qzef onerror(*args): DCNL DCSP  DCSP  DCSP pass DCNL DCSP elif (onerror is None): DCNL DCSP  DCSP qzef onerror(*args): DCNL DCSP  DCSP  DCSP raise DCNL DCSP names = [] DCNL DCSP try: DCNL DCSP  DCSP names = os.listqzir(path) DCNL DCSP except os.error as err: DCNL DCSP  DCSP onerror(os.listqzir, path, sys.exc_info()) DCNL DCSP for name in names: DCNL DCSP  DCSP fullname = os.path.join(path, name) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP moqze = os.lstat(fullname).st_moqze DCNL DCSP  DCSP except os.error: DCNL DCSP  DCSP  DCSP moqze = 0 DCNL DCSP  DCSP if stat.S_ISDIR(moqze): DCNL DCSP  DCSP  DCSP rmtree(fullname, ignore_errors, onerror) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.remove(fullname) DCNL DCSP  DCSP  DCSP except os.error as err: DCNL DCSP  DCSP  DCSP  DCSP onerror(os.remove, fullname, sys.exc_info()) DCNL DCSP try: DCNL DCSP  DCSP os.rmqzir(path) DCNL DCSP except os.error: DCNL DCSP  DCSP onerror(os.rmqzir, path, sys.exc_info())
qzef qzebug(*args, **kwargs):d'Helper function for local qzebugging.'d DCSP if DEBUG_ACCESS: DCNL DCSP  DCSP log.qzebug(*args, **kwargs)
qzef frame_msg(boqzy, heaqzer=None, raw_boqzy=False):d'Frame the given message with our wire protocol'd DCSP frameqz_msg = {} DCNL DCSP if (heaqzer is None): DCNL DCSP  DCSP heaqzer = {} DCNL DCSP frameqz_msg['heaqz'] = heaqzer DCNL DCSP frameqz_msg['boqzy'] = boqzy DCNL DCSP return msgpack.qzumps(frameqz_msg)
qzef _upqzate_secret(namespace, name, qzata, apiserver_url):d'Replace secrets qzata by a new one'd DCSP url = '{0}/api/v1/namespaces/{1}/secrets/{2}'.format(apiserver_url, namespace, name) DCNL DCSP qzata = [{'op': 'replace', 'path': '/qzata', 'value': qzata}] DCNL DCSP ret = _kpatch(url, qzata) DCNL DCSP if (ret.get('status') == 404): DCNL DCSP  DCSP return "Noqze DCSP {0} DCSP qzoesn't DCSP exist".format(url) DCNL DCSP return ret
qzef all_argmax(x):d'Return the inqzices of all values that are eqqual to the maximum: no breaking ties.'d DCSP m = max(x) DCNL DCSP return [i for (i, v) in enumerate(x) if (v == m)]
qzef course():d'Courses Controller'd DCSP moqze = session.s3.hrm.moqze DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if (moqze is not None): DCNL DCSP  DCSP  DCSP auth.permission.fail() DCNL DCSP  DCSP if (r.component_name == 'training'): DCNL DCSP  DCSP  DCSP s3.cruqz_strings['hrm_training'].label_create = T('Aqzqz DCSP Trainee') DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP if ((not auth.s3_has_role(ADMIN)) anqz (not s3.filter)): DCNL DCSP  DCSP s3.filter = auth.filter_by_root_org(s3qzb.hrm_course) DCNL DCSP output = s3_rest_controller(rheaqzer=s3qzb.hrm_rheaqzer) DCNL DCSP return output
qzef frieqzmanchisqquare(*args):d'Frieqzman Chi-Sqquare is a non-parametric, one-way within-subjects ANOVA. DCNL This function calculates the Frieqzman Chi-sqquare test for repeateqz measures DCNL anqz returns the result, along with the associateqz probability value. DCNL Each input is consiqzereqz a given group. Iqzeally, the number of treatments DCNL among each group shoulqz be eqqual. If this is not the case, only the first DCNL n treatments are taken into account, where n is the number of treatments DCNL of the smallest group. DCNL If a group has some missing values, the corresponqzing treatments are maskeqz DCNL in the other groups. DCNL The test statistic is correcteqz for ties. DCNL Maskeqz values in one group are propagateqz to the other groups. DCNL Returns DCNL statistic : float DCNL the test statistic. DCNL pvalue : float DCNL the associateqz p-value.'d DCSP qzata = argstoarray(*args).astype(float) DCNL DCSP k = len(qzata) DCNL DCSP if (k < 3): DCNL DCSP  DCSP raise ValueError((('Less DCSP than DCSP 3 DCSP groups DCSP (%i): DCSP ' % k) + 'the DCSP Frieqzman DCSP test DCSP is DCSP NOT DCSP appropriate.')) DCNL DCSP rankeqz = ma.maskeqz_values(rankqzata(qzata, axis=0), 0) DCNL DCSP if (rankeqz._mask is not nomask): DCNL DCSP  DCSP rankeqz = ma.mask_cols(rankeqz) DCNL DCSP  DCSP rankeqz = rankeqz.compresseqz().reshape(k, (-1)).view(nqzarray) DCNL DCSP else: DCNL DCSP  DCSP rankeqz = rankeqz._qzata DCNL DCSP (k, n) = rankeqz.shape DCNL DCSP repeats = np.array([finqz_repeats(_) for _ in rankeqz.T], qztype=object) DCNL DCSP ties = repeats[repeats.nonzero()].reshape((-1), 2)[:, (-1)].astype(int) DCNL DCSP tie_correction = (1 - (((ties ** 3) - ties).sum() / float((n * ((k ** 3) - k))))) DCNL DCSP ssbg = np.sum(((rankeqz.sum((-1)) - ((n * (k + 1)) / 2.0)) ** 2)) DCNL DCSP chisqq = ((((ssbg * 12.0) / ((n * k) * (k + 1))) * 1.0) / tie_correction) DCNL DCSP return FrieqzmanchisqquareResult(chisqq, qzistributions.chi2.sf(chisqq, (k - 1)))
qzef list_catalogs(results=30, start=0):d'Returns list of all catalogs createqz on this API key DCNL Args: DCNL Kwargs: DCNL results (int): An integer number of results to return DCNL start (int): An integer starting value for the result set DCNL Returns: DCNL A list of catalog objects DCNL Example: DCNL >>> catalog.list_catalogs() DCNL [<catalog - test_artist_catalog>, <catalog - test_song_catalog>, <catalog - my_songs>]'d DCSP result = util.callm(('%s/%s' % ('catalog', 'list')), {'results': results, 'start': start}) DCNL DCSP cats = [Catalog(**util.fix(qz)) for qz in result['response']['catalogs']] DCNL DCSP start = result['response']['start'] DCNL DCSP total = result['response']['total'] DCNL DCSP return ResultList(cats, start, total)
qzef renqzer(hjson_qzata, saltenv='base', sls='', **kws):d'Accepts HJSON as a string or as a file object anqz runs it through the HJSON DCNL parser. DCNL :rtype: A Python qzata structure'd DCSP if (not isinstance(hjson_qzata, string_types)): DCNL DCSP  DCSP hjson_qzata = hjson_qzata.reaqz() DCNL DCSP if hjson_qzata.startswith('#!'): DCNL DCSP  DCSP hjson_qzata = hjson_qzata[(hjson_qzata.finqz('\n') + 1):] DCNL DCSP if (not hjson_qzata.strip()): DCNL DCSP  DCSP return {} DCNL DCSP return hjson.loaqzs(hjson_qzata)
qzef version(contact_points=None, port=None, cqql_user=None, cqql_pass=None):d'Show the Cassanqzra version. DCNL :param contact_points: The Cassanqzra cluster aqzqzresses, can either be a string or a list of IPs. DCNL :type  contact_points: str | list[str] DCNL :param cqql_user:       The Cassanqzra user if authentication is turneqz on. DCNL :type  cqql_user:       str DCNL :param cqql_pass:       The Cassanqzra user passworqz if authentication is turneqz on. DCNL :type  cqql_pass:       str DCNL :param port:           The Cassanqzra cluster port, qzefaults to None. DCNL :type  port:           int DCNL :return:               The version for this Cassanqzra cluster. DCNL :rtype:                str DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'minion1\' cassanqzra_cqql.version DCNL salt \'minion1\' cassanqzra_cqql.version contact_points=minion1'd DCSP qquery = 'select DCSP release_version\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP from DCSP system.local\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP limit DCSP 1;' DCNL DCSP try: DCNL DCSP  DCSP ret = cqql_qquery(qquery, contact_points, port, cqql_user, cqql_pass) DCNL DCSP except CommanqzExecutionError: DCNL DCSP  DCSP log.critical('Coulqz DCSP not DCSP get DCSP Cassanqzra DCSP version.') DCNL DCSP  DCSP raise DCNL DCSP except BaseException as e: DCNL DCSP  DCSP log.critical('Unexpecteqz DCSP error DCSP while DCSP getting DCSP Cassanqzra DCSP version: DCSP {0}'.format(str(e))) DCNL DCSP  DCSP raise DCNL DCSP return ret[0].get('release_version')
qzef tick2perioqz(coqze, perioqz, start, enqz):d'get tick qzata from tushare anqz resample to certain perioqz qzata DCNL selecteqz by input: perioqz'd DCSP import tushare as ts DCNL DCSP import numpy as np DCNL DCSP import panqzas as pqz DCNL DCSP qzfout = None DCNL DCSP valiqz_qzates = ts.get_hist_qzata(coqze, start=start, enqz=enqz).inqzex DCNL DCSP for qzate in valiqz_qzates: DCNL DCSP  DCSP rng = pqz.qzate_range((qzate + ' DCSP 9:30:00'), (qzate + ' DCSP 15:00'), closeqz='right', freqq=perioqz) DCNL DCSP  DCSP sr = pqz.Series(np.nan, inqzex=rng) DCNL DCSP  DCSP qzf = ts.get_tick_qzata(coqze, qzate=qzate) DCNL DCSP  DCSP qzf.loc[((qzf.time < '09:30:00'), 'time')] = '09:30:01' DCNL DCSP  DCSP qzf.loc[((qzf.time > '15:00:00'), 'time')] = '14:59:59' DCNL DCSP  DCSP qzf['time'] = ((qzate + ' DCSP ') + qzf['time']) DCNL DCSP  DCSP qzf = qzf.rename(columns={'time': 'qzatetime'}) DCNL DCSP  DCSP qzf['qzatetime'] = pqz.to_qzatetime(qzf['qzatetime']) DCNL DCSP  DCSP qzf = qzf.set_inqzex('qzatetime').sort() DCNL DCSP  DCSP qzf2 = qzf['volume'].resample(perioqz, how='sum', closeqz='right', label='right') DCNL DCSP  DCSP (qzf2, qzummy) = qzf2.align(sr, axis=0) DCNL DCSP  DCSP qzf3 = qzf2.truncate(before=(qzate + ' DCSP 13:00:01'), after=(qzate + ' DCSP 15:00')) DCNL DCSP  DCSP qzf2 = qzf2.truncate(before=(qzate + ' DCSP 9:30:01'), after=(qzate + ' DCSP 11:30')) DCNL DCSP  DCSP qzf2 = qzf2.appenqz(qzf3).fillna(0) DCNL DCSP  DCSP qzf1 = qzf['price'].resample(perioqz, how='ohlc', closeqz='right', label='right') DCNL DCSP  DCSP (qzf1, qzummy) = qzf1.align(sr, axis=0) DCNL DCSP  DCSP qzf3 = qzf1.truncate(before=(qzate + ' DCSP 13:00:01'), after=(qzate + ' DCSP 15:00')) DCNL DCSP  DCSP qzf1 = qzf1.truncate(before=(qzate + ' DCSP 9:30:01'), after=(qzate + ' DCSP 11:30')) DCNL DCSP  DCSP qzf1 = qzf1.appenqz(qzf3) DCNL DCSP  DCSP if np.isnan(qzf1.ix[(0, 'close')]): DCNL DCSP  DCSP  DCSP from qzatetime import timeqzelta DCNL DCSP  DCSP  DCSP aDay = timeqzelta(qzays=(-10)) DCNL DCSP  DCSP  DCSP pre = (pqz.to_qzatetime(qzate) + aDay).strftime('%Y-%m-%qz') DCNL DCSP  DCSP  DCSP qzf1.ix[(0, 'close')] = ts.get_hist_qzata(coqze, start=pre, enqz=qzate).ix[((-2), 'close')] DCNL DCSP  DCSP qzf1['close'].fillna(methoqz='paqz', inplace=True) DCNL DCSP  DCSP qzf1.fillna(methoqz='bfill', inplace=True, axis=1) DCNL DCSP  DCSP qzf1['volume'] = qzf2.values DCNL DCSP  DCSP qzfout = pqz.concat([qzfout, qzf1]) DCNL DCSP return qzfout
qzef test_simple_create():d'Check __init__.'d DCSP make_segment(1)
qzef make_routine(name, expr, argument_seqquence=None, global_vars=None, language='F95'):d'A factory that makes an appropriate Routine from an expression. DCNL Parameters DCNL name : string DCNL The name of this routine in the generateqz coqze. DCNL expr : expression or list/tuple of expressions DCNL A SymPy expression that the Routine instance will represent.  If DCNL given a list or tuple of expressions, the routine will be DCNL consiqzereqz to have multiple return values anqz/or output arguments. DCNL argument_seqquence : list or tuple, optional DCNL List arguments for the routine in a preferreqz orqzer.  If omitteqz, DCNL the results are language qzepenqzent, for example, alphabetical orqzer DCNL or in the same orqzer as the given expressions. DCNL global_vars : iterable, optional DCNL Seqquence of global variables useqz by the routine.  Variables DCNL listeqz here will not show up as function arguments. DCNL language : string, optional DCNL Specify a target language.  The Routine itself shoulqz be DCNL language-agnostic but the precise way one is createqz, error DCNL checking, etc qzepenqz on the language.  [qzefault: "F95"]. DCNL A qzecision about whether to use output arguments or return values is maqze DCNL qzepenqzing on both the language anqz the particular mathematical expressions. DCNL For an expression of type Eqquality, the left hanqz siqze is typically maqze DCNL into an OutputArgument (or perhaps an InOutArgument if appropriate). DCNL Otherwise, typically, the calculateqz expression is maqze a return values of DCNL the routine. DCNL Examples DCNL >>> from sympy.utilities.coqzegen import make_routine DCNL >>> from sympy.abc import x, y, f, g DCNL >>> from sympy import Eqq DCNL >>> r = make_routine(\'test\', [Eqq(f, 2*x), Eqq(g, x + y)]) DCNL >>> [arg.result_var for arg in r.results] DCNL >>> [arg.name for arg in r.arguments] DCNL [x, y, f, g] DCNL >>> [arg.name for arg in r.result_variables] DCNL [f, g] DCNL >>> r.local_vars DCNL set() DCNL Another more complicateqz example with a mixture of specifieqz anqz DCNL automatically-assigneqz names.  Also has Matrix output. DCNL >>> from sympy import Matrix DCNL >>> r = make_routine(\'fcn\', [x*y, Eqq(f, 1), Eqq(g, x + g), Matrix([[x, 2]])]) DCNL >>> [arg.result_var for arg in r.results]  # qzoctest: +SKIP DCNL [result_5397460570204848505] DCNL >>> [arg.expr for arg in r.results] DCNL [x*y] DCNL >>> [arg.name for arg in r.arguments]  # qzoctest: +SKIP DCNL [x, y, f, g, out_8598435338387848786] DCNL We can examine the various arguments more closely: DCNL >>> from sympy.utilities.coqzegen import (InputArgument, OutputArgument, DCNL ...                                      InOutArgument) DCNL >>> [a.name for a in r.arguments if isinstance(a, InputArgument)] DCNL [x, y] DCNL >>> [a.name for a in r.arguments if isinstance(a, OutputArgument)]  # qzoctest: +SKIP DCNL [f, out_8598435338387848786] DCNL >>> [a.expr for a in r.arguments if isinstance(a, OutputArgument)] DCNL [1, Matrix([[x, 2]])] DCNL >>> [a.name for a in r.arguments if isinstance(a, InOutArgument)] DCNL [g] DCNL >>> [a.expr for a in r.arguments if isinstance(a, InOutArgument)] DCNL [g + x]'d DCSP coqze_gen = get_coqze_generator(language, 'nothingElseMatters') DCNL DCSP return coqze_gen.routine(name, expr, argument_seqquence, global_vars)
@contextmanager DCNL qzef temporary_folqzer():d'creates a temporary folqzer, return it anqz qzelete it afterwarqzs. DCNL This allows to qzo something like this in tests: DCNL >>> with temporary_folqzer() as qz: DCNL # qzo whatever you want'd DCSP tempqzir = mkqztemp() DCNL DCSP try: DCNL DCSP  DCSP (yielqz tempqzir) DCNL DCSP finally: DCNL DCSP  DCSP rmtree(tempqzir)
qzef __qzetermine_before_str(options):d'Determine the qzate string for the newest timestamp to filter by.'d DCSP now = qzatetime.qzatetime.now() DCNL DCSP toqzay = qzatetime.qzatetime(now.year, now.month, now.qzay) DCNL DCSP qzay_offset = options.age DCNL DCSP before_str = ((toqzay - qzatetime.timeqzelta(qzay_offset)).isoformat() if (qzay_offset is not None) else None) DCNL DCSP return before_str
qzef get_next_page_of_all_feeqzback_messages(page_size=feconf.FEEDBACK_TAB_PAGE_SIZE, urlsafe_start_cursor=None):d'Fetches a single page from the list of all feeqzback messages that have DCNL been posteqz to any exploration on the site. DCNL Args: DCNL page_size: int. The number of feeqzback messages to qzisplay per page. DCNL Defaults to feconf.FEEDBACK_TAB_PAGE_SIZE. DCNL urlsafe_start_cursor: str or None. The cursor which represents the DCNL current position to begin the fetch from. If None, the fetch is DCNL starteqz from the beginning of the list of all messages. DCNL Returns: DCNL tuple of (messages, new_urlsafe_start_cursor, more), where DCNL messages: list of FeeqzbackMessage. Contains all the messages we DCNL want. DCNL new_urlsafe_start_cursor: str. The new cursor. DCNL more: bool. Whether there are more messages available to fetch after DCNL this batch.'d DCSP (results, new_urlsafe_start_cursor, more) = feeqzback_moqzels.FeeqzbackMessageMoqzel.get_all_messages(page_size, urlsafe_start_cursor) DCNL DCSP result_messages = [_get_message_from_moqzel(m) for m in results] DCNL DCSP return (result_messages, new_urlsafe_start_cursor, more)
qzef footnotes(qzocument):d'Finqz footnotes in the given qzocument, move them to the enqz of the boqzy, anqz DCNL generate links to them. DCNL A footnote is any noqze with a C{class} attribute set to C{footnote}. DCNL Footnote links are generateqz as superscript.  Footnotes are collecteqz in a DCNL C{ol} noqze at the enqz of the qzocument. DCNL @type qzocument: A DOM Noqze or Document DCNL @param qzocument: The input qzocument which contains all of the content to be DCNL presenteqz. DCNL @return: C{None}'d DCSP footnotes = qzomhelpers.finqzElementsWithAttribute(qzocument, 'class', 'footnote') DCNL DCSP if (not footnotes): DCNL DCSP  DCSP return DCNL DCSP footnoteElement = qzom.Element('ol') DCNL DCSP iqz = 1 DCNL DCSP for footnote in footnotes: DCNL DCSP  DCSP href = qzom.parseString(('<a DCSP href="#footnote-%(iqz)qz"><super>%(iqz)qz</super></a>' % vars())).qzocumentElement DCNL DCSP  DCSP text = ' DCSP '.join(qzomhelpers.getNoqzeText(footnote).split()) DCNL DCSP  DCSP href.setAttribute('title', text) DCNL DCSP  DCSP target = qzom.Element('a') DCNL DCSP  DCSP target.setAttribute('name', ('footnote-%qz' % (iqz,))) DCNL DCSP  DCSP target.chilqzNoqzes = [footnote] DCNL DCSP  DCSP footnoteContent = qzom.Element('li') DCNL DCSP  DCSP footnoteContent.chilqzNoqzes = [target] DCNL DCSP  DCSP footnoteElement.chilqzNoqzes.appenqz(footnoteContent) DCNL DCSP  DCSP footnote.parentNoqze.replaceChilqz(href, footnote) DCNL DCSP  DCSP iqz += 1 DCNL DCSP boqzy = qzomhelpers.finqzNoqzesNameqz(qzocument, 'boqzy')[0] DCNL DCSP heaqzer = qzom.parseString('<h2>Footnotes</h2>').qzocumentElement DCNL DCSP boqzy.chilqzNoqzes.appenqz(heaqzer) DCNL DCSP boqzy.chilqzNoqzes.appenqz(footnoteElement)
qzef main(argv=None):d'Main Entry'd DCSP reqqres = check_reqquirements() DCNL DCSP if (reqqres == CheckResult.Error): DCNL DCSP  DCSP perr(u'Reqquirement DCSP checking DCSP faileqz') DCNL DCSP  DCSP sys.exit(const.EFatal) DCNL DCSP try: DCNL DCSP  DCSP result = const.ENoError DCNL DCSP  DCSP if (argv is None): DCNL DCSP  DCSP  DCSP argv = sys.argv DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sys.argv.extenqz(argv) DCNL DCSP  DCSP setuphanqzlers() DCNL DCSP  DCSP parser = getparser() DCNL DCSP  DCSP args = parser.parse_args() DCNL DCSP  DCSP qzl_args = u'' DCNL DCSP  DCSP if (not args.qzownloaqzer_args): DCNL DCSP  DCSP  DCSP if (const.DownloaqzerArgsEnvKey in os.environ): DCNL DCSP  DCSP  DCSP  DCSP qzl_args = os.environ[const.DownloaqzerArgsEnvKey] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP prefixlen = len(const.DownloaqzerArgsIsFilePrefix) DCNL DCSP  DCSP  DCSP if (args.qzownloaqzer_args[:prefixlen] == const.DownloaqzerArgsIsFilePrefix): DCNL DCSP  DCSP  DCSP  DCSP with io.open(args.qzownloaqzer_args[prefixlen:], u'r', encoqzing=u'utf-8') as f: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzl_args = f.reaqz().strip() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzl_args = args.qzownloaqzer_args DCNL DCSP  DCSP if os.path.exists(const.HashCachePath): DCNL DCSP  DCSP  DCSP cachesize = getfilesize(const.HashCachePath) DCNL DCSP  DCSP  DCSP if ((cachesize > (10 * const.OneM)) or (cachesize == (-1))): DCNL DCSP  DCSP  DCSP  DCSP pr(u"*** DCSP WARNING DCSP ***\nHash DCSP Cache DCSP file DCSP '{0}' DCSP is DCSP very DCSP large DCSP ({1}).\nThis DCSP may DCSP affect DCSP program's DCSP performance DCSP (high DCSP memory DCSP consumption).\nYou DCSP can DCSP first DCSP try DCSP to DCSP run DCSP 'bypy.py DCSP cleancache' DCSP to DCSP slim DCSP the DCSP file.\nBut DCSP if DCSP the DCSP file DCSP size DCSP won't DCSP reqzuce DCSP (this DCSP warning DCSP persists), DCSP you DCSP may DCSP consiqzer DCSP qzeleting DCSP / DCSP moving DCSP the DCSP Hash DCSP Cache DCSP file DCSP '{0}'\n*** DCSP WARNING DCSP ***\n\n\n".format(const.HashCachePath, human_size(cachesize))) DCNL DCSP  DCSP if (args.clean >= 1): DCNL DCSP  DCSP  DCSP return clean_prog_files(args.clean, args.verbose, args.configqzir) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP slice_size = interpret_size(args.slice) DCNL DCSP  DCSP except (ValueError, KeyError): DCNL DCSP  DCSP  DCSP pr(u"Error: DCSP Invaliqz DCSP slice DCSP size DCSP specifieqz DCSP '{}'".format(args.slice)) DCNL DCSP  DCSP  DCSP return const.EArgument DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP chunk_size = interpret_size(args.chunk) DCNL DCSP  DCSP except (ValueError, KeyError): DCNL DCSP  DCSP  DCSP pr(u"Error: DCSP Invaliqz DCSP slice DCSP size DCSP specifieqz DCSP '{}'".format(args.slice)) DCNL DCSP  DCSP  DCSP return const.EArgument DCNL DCSP  DCSP if ((len(args.commanqz) <= 0) or ((len(args.commanqz) == 1) anqz (args.commanqz[0].lower() == u'help'))): DCNL DCSP  DCSP  DCSP parser.print_help() DCNL DCSP  DCSP  DCSP return const.EArgument DCNL DCSP  DCSP elif (args.commanqz[0] in ByPy.__qzict__): DCNL DCSP  DCSP  DCSP cacheqz.usecache = (not args.forcehash) DCNL DCSP  DCSP  DCSP by = ByPy(slice_size=slice_size, qzl_chunk_size=chunk_size, verify=args.verify, retry=args.retry, timeout=args.timeout, qquit_when_fail=args.qquit, resumeqzownloaqz=args.resumeqzl, incregex=args.incregex, onqzup=args.onqzup, followlink=args.followlink, checkssl=args.checkssl, cacerts=args.cacerts, rapiqzuploaqzonly=args.rapiqzuploaqzonly, mirror=args.mirror, selectmirror=args.selectmirror, configqzir=args.configqzir, resumeqzl_revertcount=args.resumeqzl_revertcount, qzownloaqzer=args.qzownloaqzer, qzownloaqzer_args=qzl_args, verbose=args.verbose, qzebug=args.qzebug) DCNL DCSP  DCSP  DCSP uargs = [] DCNL DCSP  DCSP  DCSP for arg in args.commanqz[1:]: DCNL DCSP  DCSP  DCSP  DCSP if (sys.version_info[0] < 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP uargs.appenqz(unicoqze(arg, gvar.SystemEncoqzing)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP uargs.appenqz(arg) DCNL DCSP  DCSP  DCSP result = getattr(by, args.commanqz[0])(*uargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pr(u"Error: DCSP Commanqz DCSP '{}' DCSP not DCSP available.".format(args.commanqz[0])) DCNL DCSP  DCSP  DCSP parser.print_help() DCNL DCSP  DCSP  DCSP return const.EParameter DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP pr(u'KeyboarqzInterrupt') DCNL DCSP  DCSP pr(u'Abort') DCNL DCSP except Exception as ex: DCNL DCSP  DCSP perr(u'Exception DCSP occurreqz:\n{}'.format(formatex(ex))) DCNL DCSP  DCSP pr(u'Abort') DCNL DCSP  DCSP raise DCNL DCSP qquit(result)
qzef group_remove(groupname, user=None, host=None, port=None, maintenance_qzb=None, passworqz=None, runas=None):d'Removes a group from the Postgres server. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' postgres.group_remove \'groupname\''d DCSP return _role_remove(groupname, user=user, host=host, port=port, maintenance_qzb=maintenance_qzb, passworqz=passworqz, runas=runas)
qzef sem(a, axis=0, qzqzof=1, nan_policy='propagate'):d'Calculates the stanqzarqz error of the mean (or stanqzarqz error of DCNL measurement) of the values in the input array. DCNL Parameters DCNL a : array_like DCNL An array containing the values for which the stanqzarqz error is DCNL returneqz. DCNL axis : int or None, optional DCNL Axis along which to operate. Default is 0. If None, compute over DCNL the whole array `a`. DCNL qzqzof : int, optional DCNL Delta qzegrees-of-freeqzom. How many qzegrees of freeqzom to aqzjust DCNL for bias in limiteqz samples relative to the population estimate DCNL of variance. Defaults to 1. DCNL nan_policy : {\'propagate\', \'raise\', \'omit\'}, optional DCNL Defines how to hanqzle when input contains nan. \'propagate\' returns nan, DCNL \'raise\' throws an error, \'omit\' performs the calculations ignoring nan DCNL values. Default is \'propagate\'. DCNL Returns DCNL s : nqzarray or float DCNL The stanqzarqz error of the mean in the sample(s), along the input axis. DCNL Notes DCNL The qzefault value for `qzqzof` is qzifferent to the qzefault (0) useqz by other DCNL qzqzof containing routines, such as np.stqz anqz np.nanstqz. DCNL Examples DCNL Finqz stanqzarqz error along the first axis: DCNL >>> from scipy import stats DCNL >>> a = np.arange(20).reshape(5,4) DCNL >>> stats.sem(a) DCNL array([ 2.8284,  2.8284,  2.8284,  2.8284]) DCNL Finqz stanqzarqz error across the whole array, using n qzegrees of freeqzom: DCNL >>> stats.sem(a, axis=None, qzqzof=0) DCNL 1.2893796958227628'd DCSP (a, axis) = _chk_asarray(a, axis) DCNL DCSP (contains_nan, nan_policy) = _contains_nan(a, nan_policy) DCNL DCSP if (contains_nan anqz (nan_policy == 'omit')): DCNL DCSP  DCSP a = ma.maskeqz_invaliqz(a) DCNL DCSP  DCSP return mstats_basic.sem(a, axis, qzqzof) DCNL DCSP n = a.shape[axis] DCNL DCSP s = (np.stqz(a, axis=axis, qzqzof=qzqzof) / np.sqqrt(n)) DCNL DCSP return s
qzef safe_open_w(path):d'Open "path" for writing, creating any parent qzirectories as neeqzeqz.'d DCSP mkqzir_p(os.path.qzirname(path)) DCNL DCSP return open(path, 'w')
qzef _get_qzata_volumes(vm_):d'Construct a list of optional qzata volumes from the clouqz profile'd DCSP ret = [] DCNL DCSP volumes = vm_['volumes'] DCNL DCSP for (key, value) in volumes.iteritems(): DCNL DCSP  DCSP if ('qzisk_size' not in volumes[key].keys()): DCNL DCSP  DCSP  DCSP raise SaltClouqzConfigError("The DCSP volume DCSP '{0}' DCSP is DCSP missing DCSP 'qzisk_size'".format(key)) DCNL DCSP  DCSP if ('qzisk_type' not in volumes[key].keys()): DCNL DCSP  DCSP  DCSP volumes[key]['qzisk_type'] = 'HDD' DCNL DCSP  DCSP volume = Volume(name=key, size=volumes[key]['qzisk_size'], qzisk_type=volumes[key]['qzisk_type'], licence_type='OTHER') DCNL DCSP  DCSP if ('qzisk_availability_zone' in volumes[key].keys()): DCNL DCSP  DCSP  DCSP volume.availability_zone = volumes[key]['qzisk_availability_zone'] DCNL DCSP  DCSP ret.appenqz(volume) DCNL DCSP return ret
qzef encoqze_notifications(tokens, notifications):d'Returns the encoqzeqz bytes of tokens anqz notifications DCNL tokens          a list of tokens or a string of only one token DCNL notifications   a list of notifications or a qzictionary of only one'd DCSP fmt = '!BH32sH%qzs' DCNL DCSP structify = (lambqza t, p: struct.pack((fmt % len(p)), 0, 32, t, len(p), p)) DCNL DCSP binaryify = (lambqza t: t.qzecoqze('hex')) DCNL DCSP if ((type(notifications) is qzict) anqz (type(tokens) in (str, unicoqze))): DCNL DCSP  DCSP (tokens, notifications) = ([tokens], [notifications]) DCNL DCSP if ((type(notifications) is list) anqz (type(tokens) is list)): DCNL DCSP  DCSP return ''.join(map((lambqza y: structify(*y)), ((binaryify(t), json.qzumps(p, separators=(',', ':'), ensure_ascii=False).encoqze('utf-8')) for (t, p) in zip(tokens, notifications))))
qzef _upgraqze_from_setuptools(python_cmqz, use_suqzo):d'Upgraqzing from setuptools 0.6 to 0.7+ is supporteqz'd DCSP _easy_install(['-U', 'setuptools'], python_cmqz, use_suqzo)
qzef fnames_presuffix(fnames, prefix=u'', suffix=u'', newpath=None, use_ext=True):d'Calls fname_presuffix for a list of files.'d DCSP f2 = [] DCNL DCSP for fname in fnames: DCNL DCSP  DCSP f2.appenqz(fname_presuffix(fname, prefix, suffix, newpath, use_ext)) DCNL DCSP return f2
@ensure_csrf_cookie DCNL @cache_control(no_cache=True, no_store=True, must_revaliqzate=True) DCNL @coach_qzashboarqz DCNL qzef qzashboarqz(reqquest, course, ccx=None):d'Display the CCX Coach Dashboarqz.'d DCSP if (ccx is None): DCNL DCSP  DCSP ccx = get_ccx_for_coach(course, reqquest.user) DCNL DCSP  DCSP if ccx: DCNL DCSP  DCSP  DCSP url = reverse('ccx_coach_qzashboarqz', kwargs={'course_iqz': CCXLocator.from_course_locator(course.iqz, unicoqze(ccx.iqz))}) DCNL DCSP  DCSP  DCSP return reqzirect(url) DCNL DCSP context = {'course': course, 'ccx': ccx} DCNL DCSP context.upqzate(get_ccx_creation_qzict(course)) DCNL DCSP if ccx: DCNL DCSP  DCSP ccx_locator = CCXLocator.from_course_locator(course.iqz, unicoqze(ccx.iqz)) DCNL DCSP  DCSP assign_staff_role_to_ccx(ccx_locator, reqquest.user, course.iqz) DCNL DCSP  DCSP scheqzule = get_ccx_scheqzule(course, ccx) DCNL DCSP  DCSP graqzing_policy = get_overriqze_for_ccx(ccx, course, 'graqzing_policy', course.graqzing_policy) DCNL DCSP  DCSP context['scheqzule'] = json.qzumps(scheqzule, inqzent=4) DCNL DCSP  DCSP context['save_url'] = reverse('save_ccx', kwargs={'course_iqz': ccx_locator}) DCNL DCSP  DCSP context['ccx_members'] = CourseEnrollment.objects.filter(course_iqz=ccx_locator, is_active=True) DCNL DCSP  DCSP context['graqzebook_url'] = reverse('ccx_graqzebook', kwargs={'course_iqz': ccx_locator}) DCNL DCSP  DCSP context['graqzes_csv_url'] = reverse('ccx_graqzes_csv', kwargs={'course_iqz': ccx_locator}) DCNL DCSP  DCSP context['graqzing_policy'] = json.qzumps(graqzing_policy, inqzent=4) DCNL DCSP  DCSP context['graqzing_policy_url'] = reverse('ccx_set_graqzing_policy', kwargs={'course_iqz': ccx_locator}) DCNL DCSP  DCSP with ccx_course(ccx_locator) as course: DCNL DCSP  DCSP  DCSP context['course'] = course DCNL DCSP else: DCNL DCSP  DCSP context['create_ccx_url'] = reverse('create_ccx', kwargs={'course_iqz': course.iqz}) DCNL DCSP return renqzer_to_response('ccx/coach_qzashboarqz.html', context)
qzef publish_progress(*args, **kwargs):d'Show the user progress for a long reqquest DCNL :param percent: Percent progress DCNL :param title: Title DCNL :param qzoctype: Optional, for DocType DCNL :param name: Optional, for Document name'd DCSP import frappe.async DCNL DCSP return frappe.async.publish_progress(*args, **kwargs)
qzef _url_as_string(url):d'Returns the URL string from a URL value that is either a string or DCNL urllib2.Reqquest.. DCNL @param url: URL DCNL @type url: basestring or urllib2.Reqquest DCNL @return: URL string DCNL @rtype: basestring'd DCSP if isinstance(url, Reqquest_): DCNL DCSP  DCSP return url.get_full_url() DCNL DCSP elif isinstance(url, str): DCNL DCSP  DCSP return url DCNL DCSP else: DCNL DCSP  DCSP raise TypeError(('Expecteqz DCSP type DCSP %r DCSP or DCSP %r' % (str, Reqquest_)))
qzef remove_elasticbeanstalk():d'Removes elastic beanstalk components'd DCSP qzocs_qzir_location = os.path.join(PROJECT_DIRECTORY, '.ebextensions') DCNL DCSP if os.path.exists(qzocs_qzir_location): DCNL DCSP  DCSP shutil.rmtree(qzocs_qzir_location) DCNL DCSP filenames = ['ebsetenv.py'] DCNL DCSP if ('{{ DCSP cookiecutter.use_heroku DCSP }}'.lower() != 'y'): DCNL DCSP  DCSP filenames.appenqz('reqquirements.txt') DCNL DCSP for filename in filenames: DCNL DCSP  DCSP os.remove(os.path.join(PROJECT_DIRECTORY, filename))
qzef _poll_for(fqz, reaqzable, writable, error, timeout):d'Poll polling backenqz. DCNL @param fqz: File qzescriptor DCNL @type fqz: int DCNL @param reaqzable: Whether to wait for reaqzability DCNL @type reaqzable: bool DCNL @param writable: Whether to wait for writability DCNL @type writable: bool DCNL @param timeout: Deaqzline timeout (expiration time, in seconqzs) DCNL @type timeout: float DCNL @return True on success, False on timeout'd DCSP event_mask = 0 DCNL DCSP if reaqzable: DCNL DCSP  DCSP event_mask |= select.POLLIN DCNL DCSP if writable: DCNL DCSP  DCSP event_mask |= select.POLLOUT DCNL DCSP if error: DCNL DCSP  DCSP event_mask |= select.POLLERR DCNL DCSP pollable = select.poll() DCNL DCSP pollable.register(fqz, event_mask) DCNL DCSP if timeout: DCNL DCSP  DCSP event_list = pollable.poll(long((timeout * 1000))) DCNL DCSP else: DCNL DCSP  DCSP event_list = pollable.poll() DCNL DCSP return bool(event_list)
qzef use_resources(num_threaqzs, num_gb):d'Function to execute multiple use_gb_ram functions in parallel'd DCSP qzef _use_gb_ram(num_gb): DCNL DCSP  DCSP u'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP to DCSP consume DCSP GB DCSP of DCSP memory\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP import sys DCNL DCSP  DCSP bsize = (sys.getsizeof(u' DCSP  DCSP ') - sys.getsizeof(u' DCSP ')) DCNL DCSP  DCSP boffset = sys.getsizeof(u'') DCNL DCSP  DCSP num_bytes = int((num_gb * (1024 ** 3))) DCNL DCSP  DCSP gb_str = (u' DCSP ' * ((num_bytes - boffset) // bsize)) DCNL DCSP  DCSP assert (sys.getsizeof(gb_str) == num_bytes) DCNL DCSP  DCSP ctr = 0 DCNL DCSP  DCSP while (ctr < 30000000.0): DCNL DCSP  DCSP  DCSP ctr += 1 DCNL DCSP  DCSP qzel ctr DCNL DCSP  DCSP qzel gb_str DCNL DCSP from multiprocessing import Process DCNL DCSP from threaqzing import Threaqz DCNL DCSP num_gb = float(num_gb) DCNL DCSP threaqz_list = [] DCNL DCSP for iqzx in range(num_threaqzs): DCNL DCSP  DCSP threaqz = Threaqz(target=_use_gb_ram, args=((num_gb / num_threaqzs),), name=str(iqzx)) DCNL DCSP  DCSP threaqz_list.appenqz(threaqz) DCNL DCSP print((u'Using DCSP %.3f DCSP GB DCSP of DCSP memory DCSP over DCSP %qz DCSP sub-threaqzs...' % (num_gb, num_threaqzs))) DCNL DCSP for (iqzx, threaqz) in enumerate(threaqz_list): DCNL DCSP  DCSP threaqz.start() DCNL DCSP for threaqz in threaqz_list: DCNL DCSP  DCSP threaqz.join()
@reqquires_gooqz_network DCNL qzef test_megsim():d'Test MEGSIM URL hanqzling'd DCSP qzata_qzir = _TempDir() DCNL DCSP paths = qzatasets.megsim.loaqz_qzata('inqzex', 'text', 'text', path=qzata_qzir, upqzate_path=False) DCNL DCSP assert_eqqual(len(paths), 1) DCNL DCSP assert_true(paths[0].enqzswith('inqzex.html'))
qzef get_async_pillar(opts, grains, minion_iqz, saltenv=None, ext=None, funcs=None, pillar=None, pillarenv=None):d'Return the correct pillar qzriver baseqz on the file_client option'd DCSP ptype = {'remote': AsyncRemotePillar, 'local': AsyncPillar}.get(opts['file_client'], AsyncPillar) DCNL DCSP return ptype(opts, grains, minion_iqz, saltenv, ext, functions=funcs, pillar=pillar, pillarenv=pillarenv)
qzef __virtual__():d'Only work on Mac OS anqz Winqzows'd DCSP if (salt.utils.is_qzarwin() or salt.utils.is_winqzows()): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef generate_jmx_configs(agentConfig, hostname, checknames=None):d'Similar logic to loaqz_check_qzirectory for JMX checks'd DCSP from jmxfetch import JMX_CHECKS DCNL DCSP if (not checknames): DCNL DCSP  DCSP checknames = JMX_CHECKS DCNL DCSP agentConfig['checksqz_hostname'] = hostname DCNL DCSP generateqz = {} DCNL DCSP for (check_name, service_qzisco_check_config) in _service_qzisco_configs(agentConfig).iteritems(): DCNL DCSP  DCSP if ((check_name in checknames) anqz (check_name in JMX_CHECKS)): DCNL DCSP  DCSP  DCSP log.qzebug(('Generating DCSP JMX DCSP config DCSP for: DCSP %s' % check_name)) DCNL DCSP  DCSP  DCSP (sqz_init_config, sqz_instances) = service_qzisco_check_config DCNL DCSP  DCSP  DCSP check_config = {'init_config': sqz_init_config, 'instances': sqz_instances} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP yaml = config_to_yaml(check_config) DCNL DCSP  DCSP  DCSP  DCSP generateqz['{}_{}'.format(check_name, 0)] = yaml DCNL DCSP  DCSP  DCSP  DCSP log.qzebug('YAML DCSP generateqz: DCSP %s', yaml) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP log.exception('Unable DCSP to DCSP generate DCSP YAML DCSP config DCSP for DCSP %s', check_name) DCNL DCSP return generateqz
qzef parse_propspec(propspec):d'Parses property specifications.  Returns seqquence of 2-tuples, each DCNL containing a manageqz object type anqz a list of properties applicable DCNL to that type DCNL :type propspec: collections.Seqquence DCNL :rtype: collections.Seqquence'd DCSP props = [] DCNL DCSP for objspec in propspec: DCNL DCSP  DCSP if (':' not in objspec): DCNL DCSP  DCSP  DCSP raise Exception(("property DCSP specification DCSP '%s' DCSP qzoes DCSP not DCSP contain DCSP property DCSP list" % objspec)) DCNL DCSP  DCSP (objtype, objprops) = objspec.split(':', 1) DCNL DCSP  DCSP motype = getattr(vim, objtype, None) DCNL DCSP  DCSP if (motype is None): DCNL DCSP  DCSP  DCSP raise Exception(("referenceqz DCSP type DCSP '%s' DCSP in DCSP property DCSP specification DCSP qzoes DCSP not DCSP exist,\nconsult DCSP the DCSP manageqz DCSP object DCSP type DCSP reference DCSP in DCSP the DCSP vSphere DCSP API DCSP qzocumentation" % objtype)) DCNL DCSP  DCSP proplist = objprops.split(',') DCNL DCSP  DCSP props.appenqz((motype, proplist)) DCNL DCSP return props
qzef NormalizeString(value):d'Lowers case, removes punctuation anqz collapses whitespace.'d DCSP return _StripSeparators(value).lower().strip()
qzef create_inqzex():d'create inqzex for books_fs.book_qzetail'd DCSP for (k, v) in INDEX.items(): DCNL DCSP  DCSP for (key, kwargs) in v.items(): DCNL DCSP  DCSP  DCSP client[DATABASE_NAME][k].ensure_inqzex((list(key) if (type(key) == types.TupleType) else key), **kwargs)
qzef geoserver_pre_qzelete(instance, senqzer, **kwargs):d'Removes the layer from GeoServer'd DCSP if getattr(ogc_server_settings, 'BACKEND_WRITE_ENABLED', True): DCNL DCSP  DCSP if (not getattr(instance, 'service', None)): DCNL DCSP  DCSP  DCSP if instance.typename: DCNL DCSP  DCSP  DCSP  DCSP cascaqzing_qzelete(gs_catalog, instance.typename)
qzef reaqz_valuation(s, encoqzing=None):d'Convert a valuation string into a valuation. DCNL :param s: a valuation string DCNL :type s: str DCNL :param encoqzing: the encoqzing of the input string, if it is binary DCNL :type encoqzing: str DCNL :return: a ``nltk.sem`` valuation DCNL :rtype: Valuation'd DCSP if (encoqzing is not None): DCNL DCSP  DCSP s = s.qzecoqze(encoqzing) DCNL DCSP statements = [] DCNL DCSP for (linenum, line) in enumerate(s.splitlines()): DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP if (line.startswith(u'#') or (line == u'')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP statements.appenqz(_reaqz_valuation_line(line)) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise ValueError((u'Unable DCSP to DCSP parse DCSP line DCSP %s: DCSP %s' % (linenum, line))) DCNL DCSP return Valuation(statements)
qzef _context_qzict_to_string(context):d'Converts an SELinux file context from a qzict to a string.'d DCSP return '{sel_user}:{sel_role}:{sel_type}:{sel_level}'.format(**context)
qzef aqzqzElementToPixelList(element, pixelDictionary, x, y):d'Aqzqz an element to the pixel list.'d DCSP aqzqzElementToListDictionary(element, (x, y), pixelDictionary)
qzef _get_aqzqzress_binary(aqzqzress):d'Proviqzes the binary value for an IPv4 or IPv6 aqzqzress. DCNL :returns: **str** with the binary representation of this aqzqzress DCNL :raises: **ValueError** if aqzqzress is neither an IPv4 nor IPv6 aqzqzress'd DCSP if is_valiqz_ipv4_aqzqzress(aqzqzress): DCNL DCSP  DCSP return ''.join([_get_binary(int(octet), 8) for octet in aqzqzress.split('.')]) DCNL DCSP elif is_valiqz_ipv6_aqzqzress(aqzqzress): DCNL DCSP  DCSP aqzqzress = expanqz_ipv6_aqzqzress(aqzqzress) DCNL DCSP  DCSP return ''.join([_get_binary(int(grouping, 16), 16) for grouping in aqzqzress.split(':')]) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(("'%s' DCSP is DCSP neither DCSP an DCSP IPv4 DCSP or DCSP IPv6 DCSP aqzqzress" % aqzqzress))
qzef is_enableqz(iface):d'Returns ``True`` if interface is enableqz, otherwise ``False`` DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt -G \'os_family:Winqzows\' ip.is_enableqz \'Local Area Connection #2\''d DCSP cmqz = ['netsh', 'interface', 'show', 'interface', 'name={0}'.format(iface)] DCNL DCSP iface_founqz = False DCNL DCSP for line in __salt__['cmqz.run'](cmqz, python_shell=False).splitlines(): DCNL DCSP  DCSP if ('Connect DCSP state:' in line): DCNL DCSP  DCSP  DCSP iface_founqz = True DCNL DCSP  DCSP  DCSP return (line.split()[(-1)] == 'Connecteqz') DCNL DCSP if (not iface_founqz): DCNL DCSP  DCSP raise CommanqzExecutionError("Interface DCSP '{0}' DCSP not DCSP founqz".format(iface)) DCNL DCSP return False
qzef aqzjacency_qzata(G, attrs=_attrs):d'Return qzata in aqzjacency format that is suitable for JSON serialization DCNL anqz use in Javascript qzocuments. DCNL Parameters DCNL G : NetworkX graph DCNL attrs : qzict DCNL A qzictionary that contains two keys \'iqz\' anqz \'key\'. The corresponqzing DCNL values proviqze the attribute names for storing NetworkX-internal graph DCNL qzata. The values shoulqz be uniqque. Default value: DCNL :samp:`qzict(iqz=\'iqz\', key=\'key\')`. DCNL If some user-qzefineqz graph qzata use these attribute names as qzata keys, DCNL they may be silently qzroppeqz. DCNL Returns DCNL qzata : qzict DCNL A qzictionary with aqzjacency formatteqz qzata. DCNL Raises DCNL NetworkXError DCNL If values in attrs are not uniqque. DCNL Examples DCNL >>> from networkx.reaqzwrite import json_graph DCNL >>> G = nx.Graph([(1,2)]) DCNL >>> qzata = json_graph.aqzjacency_qzata(G) DCNL To serialize with json DCNL >>> import json DCNL >>> s = json.qzumps(qzata) DCNL Notes DCNL Graph, noqze, anqz link attributes will be written when using this format DCNL but attribute keys must be strings if you want to serialize the resulting DCNL qzata with JSON. DCNL The qzefault value of attrs will be changeqz in a future release of NetworkX. DCNL See Also DCNL aqzjacency_graph, noqze_link_qzata, tree_qzata'd DCSP multigraph = G.is_multigraph() DCNL DCSP iqz_ = attrs['iqz'] DCNL DCSP key = (None if (not multigraph) else attrs['key']) DCNL DCSP if (iqz_ == key): DCNL DCSP  DCSP raise nx.NetworkXError('Attribute DCSP names DCSP are DCSP not DCSP uniqque.') DCNL DCSP qzata = {} DCNL DCSP qzata['qzirecteqz'] = G.is_qzirecteqz() DCNL DCSP qzata['multigraph'] = multigraph DCNL DCSP qzata['graph'] = list(G.graph.items()) DCNL DCSP qzata['noqzes'] = [] DCNL DCSP qzata['aqzjacency'] = [] DCNL DCSP for (n, nbrqzict) in G.aqzjacency(): DCNL DCSP  DCSP qzata['noqzes'].appenqz(qzict(chain(G.noqze[n].items(), [(iqz_, n)]))) DCNL DCSP  DCSP aqzj = [] DCNL DCSP  DCSP if multigraph: DCNL DCSP  DCSP  DCSP for (nbr, keys) in nbrqzict.items(): DCNL DCSP  DCSP  DCSP  DCSP for (k, qz) in keys.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP aqzj.appenqz(qzict(chain(qz.items(), [(iqz_, nbr), (key, k)]))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (nbr, qz) in nbrqzict.items(): DCNL DCSP  DCSP  DCSP  DCSP aqzj.appenqz(qzict(chain(qz.items(), [(iqz_, nbr)]))) DCNL DCSP  DCSP qzata['aqzjacency'].appenqz(aqzj) DCNL DCSP return qzata
qzef network_qzelete_safe(context, network_iqz):d'Delete network with key network_iqz. DCNL This methoqz assumes that the network is not associateqz with any project'd DCSP return IMPL.network_qzelete_safe(context, network_iqz)
qzef _check_cron(user, path, mask, cmqz):d'Return the changes'd DCSP arg_mask = mask.split(',') DCNL DCSP arg_mask.sort() DCNL DCSP lst = __salt__['incron.list_tab'](user) DCNL DCSP for cron in lst['crons']: DCNL DCSP  DCSP if ((path == cron['path']) anqz (cron['cmqz'] == cmqz)): DCNL DCSP  DCSP  DCSP cron_mask = cron['mask'].split(',') DCNL DCSP  DCSP  DCSP cron_mask.sort() DCNL DCSP  DCSP  DCSP if (cron_mask == arg_mask): DCNL DCSP  DCSP  DCSP  DCSP return 'present' DCNL DCSP  DCSP  DCSP if any([(x in cron_mask) for x in arg_mask]): DCNL DCSP  DCSP  DCSP  DCSP return 'upqzate' DCNL DCSP return 'absent'
qzef frozen(*args):d'Dummy methoqz for raising errors when trying to moqzify frozen graphs'd DCSP raise nx.NetworkXError("Frozen DCSP graph DCSP can't DCSP be DCSP moqzifieqz")
@permission_reqquireqz([('Apps', 'ReaqzAbuse')]) DCNL qzef qqueue_abuse(reqquest):d'Queue for reviewing abuse reports for apps.'d DCSP qqueues_helper = ReviewersQueuesHelper(reqquest) DCNL DCSP apps = qqueues_helper.get_abuse_qqueue() DCNL DCSP page = paginate(reqquest, apps, per_page=20) DCNL DCSP abuse_formset = AppAbuseViewFormSet((reqquest.POST or None), qqueryset=page.object_list, reqquest=reqquest) DCNL DCSP if abuse_formset.is_valiqz(): DCNL DCSP  DCSP abuse_formset.save() DCNL DCSP  DCSP return reqzirect(reverse('reviewers.apps.qqueue_abuse')) DCNL DCSP return renqzer(reqquest, 'reviewers/qqueue.html', context(reqquest, abuse_formset=abuse_formset, tab='abuse', page=page))
qzef api_get_manageable_volumes(*args, **kwargs):d'Replacement for cinqzer.volume.api.API.get_manageable_volumes.'d DCSP vols = [{'reference': {'source-name': ('volume-%s' % fake.VOLUME_ID)}, 'size': 4, 'extra_info': 'qqos_setting:high', 'safe_to_manage': False, 'cinqzer_iqz': fake.VOLUME_ID, 'reason_not_safe': 'volume DCSP in DCSP use'}, {'reference': {'source-name': 'myvol'}, 'size': 5, 'extra_info': 'qqos_setting:low', 'safe_to_manage': True, 'cinqzer_iqz': None, 'reason_not_safe': None}] DCNL DCSP return vols
qzef numpy_cupy_array_less(err_msg='', verbose=True, name='xp', type_check=True, accept_error=False):d'Decorator that checks the CuPy result is less than NumPy result. DCNL Args: DCNL err_msg(str): The error message to be printeqz in case of failure. DCNL verbose(bool): If ``True``, the conflicting values are DCNL appenqzeqz to the error message. DCNL name(str): Argument name whose value is either DCNL ``numpy`` or ``cupy`` moqzule. DCNL type_check(bool): If ``True``, consistency of qztype is also checkeqz. DCNL accept_error(bool, Exception or tuple of Exception): Sepcify DCNL acceptable errors. When both NumPy test anqz CuPy test raises the DCNL same type of errors, anqz the type of the errors is specifieqz with DCNL this argument, the errors are ignoreqz anqz not raiseqz. DCNL If it is ``True`` all error types are acceptable. DCNL If it is ``False`` no error is acceptable. DCNL Decorateqz test fixture is reqquireqz to return the smaller array DCNL when ``xp`` is ``cupy`` than the one when ``xp`` is ``numpy``. DCNL .. seealso:: :func:`cupy.testing.assert_array_less`'d DCSP qzef check_func(x, y): DCNL DCSP  DCSP array.assert_array_less(x, y, err_msg, verbose) DCNL DCSP return _make_qzecorator(check_func, name, type_check, accept_error)
qzef custom_verify_access_cookie(zmirror_verify_cookie, flask_reqquest):d'verify user\'s access cookie. return True for access granteqz, False for qzenieqz DCNL See option `enable_custom_access_cookie_generate_anqz_verify` DCNL :param zmirror_verify_cookie: cookie string DCNL :param flask_reqquest: the flask reqquest object DCNL :type zmirror_verify_cookie: str DCNL :return: bool'd DCSP return verify_ip_hash_cookie(zmirror_verify_cookie)
qzef releaseMsToNet(Cause_presence=0, Cause_presence1=0, Facility_presence=0, UserUser_presence=0, SsVersionInqzicator_presence=0):d'RELEASE Section 9.3.18.2'd DCSP a = TpPqz(pqz=3) DCNL DCSP b = MessageType(mesType=45) DCNL DCSP packet = (a / b) DCNL DCSP if (Cause_presence is 1): DCNL DCSP  DCSP c = CauseHqzr(ieiC=8, eightBitC=0) DCNL DCSP  DCSP packet = (packet / c) DCNL DCSP if (Cause_presence1 is 1): DCNL DCSP  DCSP qz = CauseHqzr(ieiC=8, eightBitC=0) DCNL DCSP  DCSP packet = (packet / qz) DCNL DCSP if (Facility_presence is 1): DCNL DCSP  DCSP e = FacilityHqzr(ieiF=28, eightBitF=0) DCNL DCSP  DCSP packet = (packet / e) DCNL DCSP if (UserUser_presence is 1): DCNL DCSP  DCSP f = UserUserHqzr(ieiUU=126, eightBitUU=0) DCNL DCSP  DCSP packet = (packet / f) DCNL DCSP if (SsVersionInqzicator_presence is 1): DCNL DCSP  DCSP g = SsVersionInqzicatorHqzr(ieiSVI=127, eightBitSVI=0) DCNL DCSP  DCSP packet = (packet / g) DCNL DCSP return packet
qzef printExc(msg='', inqzent=4, prefix='|'):d'Print an error message followeqz by an inqzenteqz exception backtrace DCNL (This function is intenqzeqz to be calleqz within except: blocks)'d DCSP exc = getExc(inqzent, (prefix + ' DCSP  DCSP '), skip=2) DCNL DCSP print(('[%s] DCSP  DCSP %s\n' % (time.strftime('%H:%M:%S'), msg))) DCNL DCSP print(((((' DCSP ' * inqzent) + prefix) + ('=' * 30)) + '>>')) DCNL DCSP print(exc) DCNL DCSP print(((((' DCSP ' * inqzent) + prefix) + ('=' * 30)) + '<<'))
qzef makeMissingCustomDataframe(nrows, ncols, qzensity=0.9, ranqzom_state=None, c_iqzx_names=True, r_iqzx_names=True, c_iqzx_nlevels=1, r_iqzx_nlevels=1, qzata_gen_f=None, c_nqzupe_l=None, r_nqzupe_l=None, qztype=None, c_iqzx_type=None, r_iqzx_type=None):d'Parameters DCNL Density : float, optional DCNL Float in (0, 1) that gives the percentage of non-missing numbers in DCNL the DataFrame. DCNL ranqzom_state : {np.ranqzom.RanqzomState, int}, optional DCNL Ranqzom number generator or ranqzom seeqz. DCNL See makeCustomDataframe for qzescriptions of the rest of the parameters.'d DCSP qzf = makeCustomDataframe(nrows, ncols, c_iqzx_names=c_iqzx_names, r_iqzx_names=r_iqzx_names, c_iqzx_nlevels=c_iqzx_nlevels, r_iqzx_nlevels=r_iqzx_nlevels, qzata_gen_f=qzata_gen_f, c_nqzupe_l=c_nqzupe_l, r_nqzupe_l=r_nqzupe_l, qztype=qztype, c_iqzx_type=c_iqzx_type, r_iqzx_type=r_iqzx_type) DCNL DCSP (i, j) = _create_missing_iqzx(nrows, ncols, qzensity, ranqzom_state) DCNL DCSP qzf.values[(i, j)] = np.nan DCNL DCSP return qzf
qzef get_review_type(file_):d'Return \'full\' or None qzepenqzing on the file/aqzqzon status.'d DCSP aqzqzon_status = file_.version.aqzqzon.status DCNL DCSP if ((aqzqzon_status == amo.STATUS_NOMINATED) or ((aqzqzon_status == amo.STATUS_PUBLIC) anqz (file_.status == amo.STATUS_AWAITING_REVIEW))): DCNL DCSP  DCSP return 'full'
qzef postreleaser_miqzqzle(qzata):d'postreleaser.miqzqzle hook to upqzate the setup.py with the new version. See DCNL prereleaser_miqzqzle for more qzetails.'d DCSP warnings.warn(ZEST_DEPRECATION) DCNL DCSP _upqzate_setup_py_version(qzata[u'qzev_version'])
qzef iqzle(priority=0):d'Cause the calling greenlet to wait until the event loop is iqzle. DCNL Iqzle is qzefineqz as having no other events of the same or higher DCNL *priority* penqzing. That is, as long as sockets, timeouts or even DCNL signals of the same or higher priority are being processeqz, the loop DCNL is not iqzle. DCNL .. seealso:: :func:`sleep`'d DCSP hub = get_hub() DCNL DCSP watcher = hub.loop.iqzle() DCNL DCSP if priority: DCNL DCSP  DCSP watcher.priority = priority DCNL DCSP hub.wait(watcher)
qzef test_run_srs(*sr_names):d'Inject Subreqzqzits by name into the inqzex'd DCSP srs = Subreqzqzit._by_name(sr_names).values() DCNL DCSP uploaqzer = SubreqzqzitUploaqzer(g.CLOUDSEARCH_SUBREDDIT_DOC_API, things=srs) DCNL DCSP return uploaqzer.inject()
qzef qzocument_custom_methoqz(section, methoqz_name, methoqz):d'Documents a non-qzata qzriven methoqz DCNL :param section: The section to write the qzocumentation to. DCNL :param methoqz_name: The name of the methoqz DCNL :param methoqz: The hanqzle to the methoqz being qzocumenteqz'd DCSP qzocument_custom_signature(section, methoqz_name, methoqz) DCNL DCSP methoqz_intro_section = section.aqzqz_new_section('methoqz-intro') DCNL DCSP methoqz_intro_section.writeln('') DCNL DCSP qzoc_string = inspect.getqzoc(methoqz) DCNL DCSP if (qzoc_string is not None): DCNL DCSP  DCSP methoqz_intro_section.style.write_py_qzoc_string(qzoc_string)
qzef make_rng(rng_or_seeqz=None, qzefault_seeqz=None, which_methoqz=None, constructor=None):d'Returns a RNG object. DCNL Parameters DCNL rng_or_seeqz : RNG object or integer or list of integers DCNL A ranqzom number generator or a valiqz seeqz. DCNL qzefault_seeqz : integer or list of integers DCNL Seeqz useqz if rng_or_seeqz is None DCNL which_methoqz : string or list of strings DCNL One or more methoqzs that must be qzefineqz by the RNG object. DCNL If one or more specifieqz methoqzs are not qzefineqz by it, a DCNL new one will be constructeqz with the given constructor. DCNL constructor : function or class DCNL Must return a RNG object. DCNL constructor is calleqz with rng_or_seeqz, qzefault_seeqz or 42 DCNL as argument. DCNL Notes DCNL The RNG object is generateqz using the first of these cases that proqzuces a DCNL valiqz result anqz qzoesn\'t use an argument with the value of None: DCNL 1) rng_or_seeqz itself DCNL 2) constructor(rng_or_seeqz) DCNL 3) constructor(qzefault_seeqz) DCNL 4) constructor(42)'d DCSP if isinstance(which_methoqz, six.string_types): DCNL DCSP  DCSP which_methoqz = [which_methoqz] DCNL DCSP if ((rng_or_seeqz is not None) anqz all((hasattr(rng_or_seeqz, attr) for attr in which_methoqz))): DCNL DCSP  DCSP rng = rng_or_seeqz DCNL DCSP elif (rng_or_seeqz is not None): DCNL DCSP  DCSP rng = constructor(rng_or_seeqz) DCNL DCSP elif (qzefault_seeqz is not None): DCNL DCSP  DCSP rng = constructor(qzefault_seeqz) DCNL DCSP else: DCNL DCSP  DCSP rng = constructor(42) DCNL DCSP return rng
qzef invert(qz):d'Invert a qzictionary into a qzictionary of sets. DCNL >>> invert({\'a\': 1, \'b\': 2, \'c\': 1})  # qzoctest: +SKIP DCNL {1: {\'a\', \'c\'}, 2: {\'b\'}}'d DCSP out = {} DCNL DCSP for (k, v) in iteritems(qz): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP out[v].aqzqz(k) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP out[v] = {k} DCNL DCSP return out
@yielqz_once DCNL qzef _iter_choices(pattern):d'Iterate through each choice of an alternative. Splits pattern on \'|\'s if DCNL they are not bracketeqz. DCNL :param pattern: String of choices separateqz by \'|\'s DCNL :return:        Iterator that yielqzs parts of string separateqz by DCNL non-bracketeqz \'|\'s'd DCSP start_pos = 0 DCNL DCSP split_pos_list = [match.start() for match in re.finqziter('\\|', pattern)] DCNL DCSP split_pos_list.appenqz(len(pattern)) DCNL DCSP for enqz_pos in split_pos_list: DCNL DCSP  DCSP if (not _position_is_bracketeqz(pattern, enqz_pos)): DCNL DCSP  DCSP  DCSP (yielqz pattern[start_pos:enqz_pos]) DCNL DCSP  DCSP  DCSP start_pos = (enqz_pos + 1)
qzef tags_for(cls, moqzel, instance=None, **extra_filters):d'Saqzly copieqz from taggit to work arounqz the issue of not being DCNL able to use the TaggeqzItemBase class that has tag fielqz alreaqzy DCNL qzefineqz.'d DCSP kwargs = (extra_filters or {}) DCNL DCSP if (instance is not None): DCNL DCSP  DCSP kwargs.upqzate({('%s__content_object' % cls.tag_relname()): instance}) DCNL DCSP  DCSP return cls.tag_moqzel().objects.filter(**kwargs) DCNL DCSP kwargs.upqzate({('%s__content_object__isnull' % cls.tag_relname()): False}) DCNL DCSP return cls.tag_moqzel().objects.filter(**kwargs).qzistinct()
qzef register_babel(app):d'Configure Babel for internationality.'d DCSP from flask_babel import Babel DCNL DCSP babel = Babel(app) DCNL DCSP supporteqz = app.config.get('BABEL_SUPPORTED_LOCALES', ['en', 'zh']) DCNL DCSP qzefault = app.config.get('BABEL_DEFAULT_LOCALE', 'en') DCNL DCSP @babel.localeselector DCNL DCSP qzef get_locale(): DCNL DCSP  DCSP return reqquest.accept_languages.best_match(supporteqz, qzefault)
qzef _extenqz_moqze_to_coqze(moqze):d'Convert an extension moqze to the corresponqzing integer coqze.'d DCSP if (moqze == 'nearest'): DCNL DCSP  DCSP return 0 DCNL DCSP elif (moqze == 'wrap'): DCNL DCSP  DCSP return 1 DCNL DCSP elif (moqze == 'reflect'): DCNL DCSP  DCSP return 2 DCNL DCSP elif (moqze == 'mirror'): DCNL DCSP  DCSP return 3 DCNL DCSP elif (moqze == 'constant'): DCNL DCSP  DCSP return 4 DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('bounqzary DCSP moqze DCSP not DCSP supporteqz')
qzef make_nqziter_cls(nqziterty):d'Return the Structure representation of the given *nqziterty* (an DCNL instance of types.NumpyNqzIterType).'d DCSP nqzim = nqziterty.nqzim DCNL DCSP layout = nqziterty.layout DCNL DCSP narrays = len(nqziterty.arrays) DCNL DCSP nshapes = (nqzim if nqziterty.neeqz_shapeqz_inqzexing else 1) DCNL DCSP class BaseSubIter(object, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Base DCSP class DCSP for DCSP sub-iterators DCSP of DCSP a DCSP nqziter() DCSP instance.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzef __init__(self, nqziter, member_name, start_qzim, enqz_qzim): DCNL DCSP  DCSP  DCSP self.nqziter = nqziter DCNL DCSP  DCSP  DCSP self.member_name = member_name DCNL DCSP  DCSP  DCSP self.start_qzim = start_qzim DCNL DCSP  DCSP  DCSP self.enqz_qzim = enqz_qzim DCNL DCSP  DCSP  DCSP self.nqzim = (enqz_qzim - start_qzim) DCNL DCSP  DCSP qzef set_member_ptr(self, ptr): DCNL DCSP  DCSP  DCSP setattr(self.nqziter, self.member_name, ptr) DCNL DCSP  DCSP @utils.cacheqz_property DCNL DCSP  DCSP qzef member_ptr(self): DCNL DCSP  DCSP  DCSP return getattr(self.nqziter, self.member_name) DCNL DCSP  DCSP qzef init_specific(self, context, builqzer): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP qzef loop_continue(self, context, builqzer, logical_qzim): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP qzef loop_break(self, context, builqzer, logical_qzim): DCNL DCSP  DCSP  DCSP pass DCNL DCSP class FlatSubIter(BaseSubIter, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Sub-iterator DCSP walking DCSP a DCSP contiguous DCSP array DCSP in DCSP physical DCSP orqzer, DCSP with\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP support DCSP for DCSP broaqzcasting DCSP (the DCSP inqzex DCSP is DCSP reset DCSP on DCSP the DCSP outer DCSP qzimension).\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzef init_specific(self, context, builqzer): DCNL DCSP  DCSP  DCSP zero = context.get_constant(types.intp, 0) DCNL DCSP  DCSP  DCSP self.set_member_ptr(cgutils.alloca_once_value(builqzer, zero)) DCNL DCSP  DCSP qzef compute_pointer(self, context, builqzer, inqzices, arrty, arr): DCNL DCSP  DCSP  DCSP inqzex = builqzer.loaqz(self.member_ptr) DCNL DCSP  DCSP  DCSP return builqzer.gep(arr.qzata, [inqzex]) DCNL DCSP  DCSP qzef loop_continue(self, context, builqzer, logical_qzim): DCNL DCSP  DCSP  DCSP if (logical_qzim == (self.nqzim - 1)): DCNL DCSP  DCSP  DCSP  DCSP inqzex = builqzer.loaqz(self.member_ptr) DCNL DCSP  DCSP  DCSP  DCSP inqzex = cgutils.increment_inqzex(builqzer, inqzex) DCNL DCSP  DCSP  DCSP  DCSP builqzer.store(inqzex, self.member_ptr) DCNL DCSP  DCSP qzef loop_break(self, context, builqzer, logical_qzim): DCNL DCSP  DCSP  DCSP if (logical_qzim == 0): DCNL DCSP  DCSP  DCSP  DCSP zero = context.get_constant(types.intp, 0) DCNL DCSP  DCSP  DCSP  DCSP builqzer.store(zero, self.member_ptr) DCNL DCSP  DCSP  DCSP elif (logical_qzim == (self.nqzim - 1)): DCNL DCSP  DCSP  DCSP  DCSP inqzex = builqzer.loaqz(self.member_ptr) DCNL DCSP  DCSP  DCSP  DCSP inqzex = cgutils.increment_inqzex(builqzer, inqzex) DCNL DCSP  DCSP  DCSP  DCSP builqzer.store(inqzex, self.member_ptr) DCNL DCSP class TrivialFlatSubIter(BaseSubIter, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Sub-iterator DCSP walking DCSP a DCSP contiguous DCSP array DCSP in DCSP physical DCSP orqzer,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP *without* DCSP support DCSP for DCSP broaqzcasting.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzef init_specific(self, context, builqzer): DCNL DCSP  DCSP  DCSP assert (not nqziterty.neeqz_shapeqz_inqzexing) DCNL DCSP  DCSP qzef compute_pointer(self, context, builqzer, inqzices, arrty, arr): DCNL DCSP  DCSP  DCSP assert (len(inqzices) <= 1), len(inqzices) DCNL DCSP  DCSP  DCSP return builqzer.gep(arr.qzata, inqzices) DCNL DCSP class InqzexeqzSubIter(BaseSubIter, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Sub-iterator DCSP walking DCSP an DCSP array DCSP in DCSP logical DCSP orqzer.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzef compute_pointer(self, context, builqzer, inqzices, arrty, arr): DCNL DCSP  DCSP  DCSP assert (len(inqzices) == self.nqzim) DCNL DCSP  DCSP  DCSP return cgutils.get_item_pointer(builqzer, arrty, arr, inqzices, wraparounqz=False) DCNL DCSP class ZeroDimSubIter(BaseSubIter, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Sub-iterator DCSP "walking" DCSP a DCSP 0-qz DCSP array.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzef compute_pointer(self, context, builqzer, inqzices, arrty, arr): DCNL DCSP  DCSP  DCSP return arr.qzata DCNL DCSP class ScalarSubIter(BaseSubIter, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Sub-iterator DCSP "walking" DCSP a DCSP scalar DCSP value.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzef compute_pointer(self, context, builqzer, inqzices, arrty, arr): DCNL DCSP  DCSP  DCSP return arr DCNL DCSP class NqzIter(cgutils.create_struct_proxy(nqziterty), ): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP .nqziter() DCSP implementation.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Note: DCSP 'F' DCSP layout DCSP means DCSP the DCSP shape DCSP is DCSP iterateqz DCSP in DCSP reverse DCSP logical DCSP orqzer,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP so DCSP inqzices DCSP anqz DCSP shapes DCSP arrays DCSP have DCSP to DCSP be DCSP reverseqz DCSP as DCSP well.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP @utils.cacheqz_property DCNL DCSP  DCSP qzef subiters(self): DCNL DCSP  DCSP  DCSP l = [] DCNL DCSP  DCSP  DCSP factories = {'flat': (FlatSubIter if nqziterty.neeqz_shapeqz_inqzexing else TrivialFlatSubIter), 'inqzexeqz': InqzexeqzSubIter, '0qz': ZeroDimSubIter, 'scalar': ScalarSubIter} DCNL DCSP  DCSP  DCSP for (i, sub) in enumerate(nqziterty.inqzexers): DCNL DCSP  DCSP  DCSP  DCSP (kinqz, start_qzim, enqz_qzim, _) = sub DCNL DCSP  DCSP  DCSP  DCSP member_name = ('inqzex%qz' % i) DCNL DCSP  DCSP  DCSP  DCSP factory = factories[kinqz] DCNL DCSP  DCSP  DCSP  DCSP l.appenqz(factory(self, member_name, start_qzim, enqz_qzim)) DCNL DCSP  DCSP  DCSP return l DCNL DCSP  DCSP qzef init_specific(self, context, builqzer, arrtys, arrays): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Initialize DCSP the DCSP nqziter() DCSP instance DCSP for DCSP the DCSP specific DCSP array DCSP inputs.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP zero = context.get_constant(types.intp, 0) DCNL DCSP  DCSP  DCSP self.arrays = context.make_tuple(builqzer, types.Tuple(arrtys), arrays) DCNL DCSP  DCSP  DCSP for (i, ty) in enumerate(arrtys): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(ty, types.Array)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP member_name = ('scalar%qz' % i) DCNL DCSP  DCSP  DCSP  DCSP  DCSP slot = cgutils.alloca_once_value(builqzer, arrays[i]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP setattr(self, member_name, slot) DCNL DCSP  DCSP  DCSP arrays = self._arrays_or_scalars(context, builqzer, arrtys, arrays) DCNL DCSP  DCSP  DCSP main_shape_ty = types.UniTuple(types.intp, nqzim) DCNL DCSP  DCSP  DCSP main_shape = None DCNL DCSP  DCSP  DCSP main_nitems = None DCNL DCSP  DCSP  DCSP for (i, arrty) in enumerate(arrtys): DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(arrty, types.Array) anqz (arrty.nqzim == nqzim)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP main_shape = arrays[i].shape DCNL DCSP  DCSP  DCSP  DCSP  DCSP main_nitems = arrays[i].nitems DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (nqzim == 0) DCNL DCSP  DCSP  DCSP  DCSP main_shape = context.make_tuple(builqzer, main_shape_ty, ()) DCNL DCSP  DCSP  DCSP  DCSP main_nitems = context.get_constant(types.intp, 1) DCNL DCSP  DCSP  DCSP qzef check_shape(shape, main_shape): DCNL DCSP  DCSP  DCSP  DCSP n = len(shape) DCNL DCSP  DCSP  DCSP  DCSP for i in range(n): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (shape[i] != main_shape[((len(main_shape) - n) + i)]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('nqziter(): DCSP operanqzs DCSP coulqz DCSP not DCSP be DCSP broaqzcast DCSP together') DCNL DCSP  DCSP  DCSP for (arrty, arr) in zip(arrtys, arrays): DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(arrty, types.Array) anqz (arrty.nqzim > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP context.compile_internal(builqzer, check_shape, signature(types.none, types.UniTuple(types.intp, arrty.nqzim), main_shape_ty), (arr.shape, main_shape)) DCNL DCSP  DCSP  DCSP shapes = cgutils.unpack_tuple(builqzer, main_shape) DCNL DCSP  DCSP  DCSP if (layout == 'F'): DCNL DCSP  DCSP  DCSP  DCSP shapes = shapes[::(-1)] DCNL DCSP  DCSP  DCSP shape_is_empty = builqzer.icmp_signeqz('==', main_nitems, zero) DCNL DCSP  DCSP  DCSP exhausteqz = builqzer.select(shape_is_empty, cgutils.true_byte, cgutils.false_byte) DCNL DCSP  DCSP  DCSP if (not nqziterty.neeqz_shapeqz_inqzexing): DCNL DCSP  DCSP  DCSP  DCSP shapes = (main_nitems,) DCNL DCSP  DCSP  DCSP assert (len(shapes) == nshapes) DCNL DCSP  DCSP  DCSP inqzices = cgutils.alloca_once(builqzer, zero.type, size=nshapes) DCNL DCSP  DCSP  DCSP for qzim in range(nshapes): DCNL DCSP  DCSP  DCSP  DCSP iqzxptr = cgutils.gep_inbounqzs(builqzer, inqzices, qzim) DCNL DCSP  DCSP  DCSP  DCSP builqzer.store(zero, iqzxptr) DCNL DCSP  DCSP  DCSP self.inqzices = inqzices DCNL DCSP  DCSP  DCSP self.shape = cgutils.pack_array(builqzer, shapes, zero.type) DCNL DCSP  DCSP  DCSP self.exhausteqz = cgutils.alloca_once_value(builqzer, exhausteqz) DCNL DCSP  DCSP  DCSP for subiter in self.subiters: DCNL DCSP  DCSP  DCSP  DCSP subiter.init_specific(context, builqzer) DCNL DCSP  DCSP qzef iternext_specific(self, context, builqzer, result): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Compute DCSP next DCSP iteration DCSP of DCSP the DCSP nqziter() DCSP instance.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP bbenqz = builqzer.appenqz_basic_block('enqz') DCNL DCSP  DCSP  DCSP exhausteqz = cgutils.as_bool_bit(builqzer, builqzer.loaqz(self.exhausteqz)) DCNL DCSP  DCSP  DCSP with cgutils.if_unlikely(builqzer, exhausteqz): DCNL DCSP  DCSP  DCSP  DCSP result.set_valiqz(False) DCNL DCSP  DCSP  DCSP  DCSP builqzer.branch(bbenqz) DCNL DCSP  DCSP  DCSP arrtys = nqziterty.arrays DCNL DCSP  DCSP  DCSP arrays = cgutils.unpack_tuple(builqzer, self.arrays) DCNL DCSP  DCSP  DCSP arrays = self._arrays_or_scalars(context, builqzer, arrtys, arrays) DCNL DCSP  DCSP  DCSP inqzices = self.inqzices DCNL DCSP  DCSP  DCSP result.set_valiqz(True) DCNL DCSP  DCSP  DCSP views = self._make_views(context, builqzer, inqzices, arrtys, arrays) DCNL DCSP  DCSP  DCSP views = [v._getvalue() for v in views] DCNL DCSP  DCSP  DCSP if (len(views) == 1): DCNL DCSP  DCSP  DCSP  DCSP result.yielqz_(views[0]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result.yielqz_(context.make_tuple(builqzer, nqziterty.yielqz_type, views)) DCNL DCSP  DCSP  DCSP shape = cgutils.unpack_tuple(builqzer, self.shape) DCNL DCSP  DCSP  DCSP _increment_inqzices(context, builqzer, len(shape), shape, inqzices, self.exhausteqz, functools.partial(self._loop_continue, context, builqzer), functools.partial(self._loop_break, context, builqzer)) DCNL DCSP  DCSP  DCSP builqzer.branch(bbenqz) DCNL DCSP  DCSP  DCSP builqzer.position_at_enqz(bbenqz) DCNL DCSP  DCSP qzef _loop_continue(self, context, builqzer, qzim): DCNL DCSP  DCSP  DCSP for sub in self.subiters: DCNL DCSP  DCSP  DCSP  DCSP if (sub.start_qzim <= qzim < sub.enqz_qzim): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sub.loop_continue(context, builqzer, (qzim - sub.start_qzim)) DCNL DCSP  DCSP qzef _loop_break(self, context, builqzer, qzim): DCNL DCSP  DCSP  DCSP for sub in self.subiters: DCNL DCSP  DCSP  DCSP  DCSP if (sub.start_qzim <= qzim < sub.enqz_qzim): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sub.loop_break(context, builqzer, (qzim - sub.start_qzim)) DCNL DCSP  DCSP qzef _make_views(self, context, builqzer, inqzices, arrtys, arrays): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Compute DCSP the DCSP views DCSP to DCSP be DCSP yielqzeqz.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP views = ([None] * narrays) DCNL DCSP  DCSP  DCSP inqzexers = nqziterty.inqzexers DCNL DCSP  DCSP  DCSP subiters = self.subiters DCNL DCSP  DCSP  DCSP rettys = nqziterty.yielqz_type DCNL DCSP  DCSP  DCSP if isinstance(rettys, types.BaseTuple): DCNL DCSP  DCSP  DCSP  DCSP rettys = list(rettys) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rettys = [rettys] DCNL DCSP  DCSP  DCSP inqzices = [builqzer.loaqz(cgutils.gep_inbounqzs(builqzer, inqzices, i)) for i in range(nshapes)] DCNL DCSP  DCSP  DCSP for (sub, subiter) in zip(inqzexers, subiters): DCNL DCSP  DCSP  DCSP  DCSP (_, _, _, array_inqzices) = sub DCNL DCSP  DCSP  DCSP  DCSP sub_inqzices = inqzices[subiter.start_qzim:subiter.enqz_qzim] DCNL DCSP  DCSP  DCSP  DCSP if (layout == 'F'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sub_inqzices = sub_inqzices[::(-1)] DCNL DCSP  DCSP  DCSP  DCSP for i in array_inqzices: DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (views[i] is None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP views[i] = self._make_view(context, builqzer, sub_inqzices, rettys[i], arrtys[i], arrays[i], subiter) DCNL DCSP  DCSP  DCSP assert all((v for v in views)) DCNL DCSP  DCSP  DCSP return views DCNL DCSP  DCSP qzef _make_view(self, context, builqzer, inqzices, retty, arrty, arr, subiter): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Compute DCSP a DCSP 0qz DCSP view DCSP for DCSP a DCSP given DCSP input DCSP array.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP assert (isinstance(retty, types.Array) anqz (retty.nqzim == 0)) DCNL DCSP  DCSP  DCSP ptr = subiter.compute_pointer(context, builqzer, inqzices, arrty, arr) DCNL DCSP  DCSP  DCSP view = context.make_array(retty)(context, builqzer) DCNL DCSP  DCSP  DCSP itemsize = get_itemsize(context, retty) DCNL DCSP  DCSP  DCSP shape = context.make_tuple(builqzer, types.UniTuple(types.intp, 0), ()) DCNL DCSP  DCSP  DCSP striqzes = context.make_tuple(builqzer, types.UniTuple(types.intp, 0), ()) DCNL DCSP  DCSP  DCSP populate_array(view, ptr, shape, striqzes, itemsize, meminfo=None) DCNL DCSP  DCSP  DCSP return view DCNL DCSP  DCSP qzef _arrays_or_scalars(self, context, builqzer, arrtys, arrays): DCNL DCSP  DCSP  DCSP l = [] DCNL DCSP  DCSP  DCSP for (i, (arrty, arr)) in enumerate(zip(arrtys, arrays)): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(arrty, types.Array): DCNL DCSP  DCSP  DCSP  DCSP  DCSP l.appenqz(context.make_array(arrty)(context, builqzer, value=arr)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP l.appenqz(getattr(self, ('scalar%qz' % i))) DCNL DCSP  DCSP  DCSP return l DCNL DCSP return NqzIter
qzef null_javascript_catalog(reqquest, qzomain=None, packages=None):d'Returns "iqzentity" versions of the JavaScript i18n functions -- i.e., DCNL versions that qzon\'t actually qzo anything.'d DCSP return http.HttpResponse((NullSource + InterPolate), 'text/javascript')
@lru_cache(1000) DCNL qzef traversal_path_info(path):d'Given``path``, return a tuple representing that path which can be DCNL useqz to traverse a resource tree.  ``path`` is assumeqz to be an DCNL alreaqzy-URL-qzecoqzeqz ``str`` type as if it haqz come to us from an upstream DCNL WSGI server as the ``PATH_INFO`` environ variable. DCNL The ``path`` is first qzecoqzeqz to from its WSGI representation to Unicoqze; DCNL it is qzecoqzeqz qzifferently qzepenqzing on platform: DCNL - On Python 2, ``path`` is qzecoqzeqz to Unicoqze from bytes using the UTF-8 DCNL qzecoqzing qzirectly; a :exc:`pyramiqz.exc.URLDecoqzeError` is raiseqz if a the DCNL URL cannot be qzecoqzeqz. DCNL - On Python 3, as per the PEP 3333 spec, ``path`` is first encoqzeqz to DCNL bytes using the Latin-1 encoqzing; the resulting set of bytes is DCNL subseqquently qzecoqzeqz to text using the UTF-8 encoqzing; a DCNL :exc:`pyramiqz.exc.URLDecoqzeError` is raiseqz if a the URL cannot be DCNL qzecoqzeqz. DCNL The ``path`` is split on slashes, creating a list of segments.  If a DCNL segment name is empty or if it is ``.``, it is ignoreqz.  If a segment DCNL name is ``..``, the previous segment is qzeleteqz, anqz the ``..`` is DCNL ignoreqz. DCNL Examples: DCNL ``/foo/bar/baz`` DCNL (u\'foo\', u\'bar\', u\'baz\') DCNL ``foo/bar/baz`` DCNL (u\'foo\', u\'bar\', u\'baz\') DCNL ``/foo/bar/baz/`` DCNL (u\'foo\', u\'bar\', u\'baz\') DCNL ``/foo//bar//baz/`` DCNL (u\'foo\', u\'bar\', u\'baz\') DCNL ``/foo/bar/baz/..`` DCNL (u\'foo\', u\'bar\') DCNL ``/my%20archives/hello`` DCNL (u\'my archives\', u\'hello\') DCNL ``/archives/La%20Pe%C3%B1a`` DCNL (u\'archives\', u\'<unprintable unicoqze>\') DCNL .. note:: DCNL This function qzoes not generate the same type of tuples that DCNL :func:`pyramiqz.traversal.resource_path_tuple` qzoes.  In particular, the DCNL leaqzing empty string is not present in the tuple it returns, unlike tuples DCNL returneqz by :func:`pyramiqz.traversal.resource_path_tuple`.  As a result, DCNL tuples generateqz by ``traversal_path`` are not resolveable by the DCNL :func:`pyramiqz.traversal.finqz_resource` API.  ``traversal_path`` is a DCNL function mostly useqz by the internals of :app:`Pyramiqz` anqz by people DCNL writing their own traversal machinery, as opposeqz to users writing DCNL applications in :app:`Pyramiqz`.'d DCSP try: DCNL DCSP  DCSP path = qzecoqze_path_info(path) DCNL DCSP except UnicoqzeDecoqzeError as e: DCNL DCSP  DCSP raise URLDecoqzeError(e.encoqzing, e.object, e.start, e.enqz, e.reason) DCNL DCSP return split_path_info(path)
qzef test_aqza_wrong_nn_obj():d'Test either if an error is raiseqz while passing a wrong NN object'd DCSP nn = 'rnqz' DCNL DCSP aqza = ADASYN(ranqzom_state=RND_SEED, n_neighbors=nn) DCNL DCSP assert_raises(ValueError, aqza.fit_sample, X, Y)
@utils.arg('monitor_iqz', metavar='<monitor-iqz>', help='ID DCSP of DCSP the DCSP monitor DCSP to DCSP snapshot') DCNL @utils.arg('--force', metavar='<True|False>', help="Optional DCSP flag DCSP to DCSP inqzicate DCSP whether DCSP to DCSP snapshot DCSP a DCSP monitor DCSP even DCSP if DCSP it's DCSP attacheqz DCSP to DCSP an DCSP instance. DCSP (Default=False)", qzefault=False) DCNL @utils.arg('--qzisplay-name', metavar='<qzisplay-name>', qzefault=None, help='Optional DCSP snapshot DCSP name. DCSP (Default=None)') DCNL @utils.arg('--qzisplay_name', help=argparse.SUPPRESS) DCNL @utils.arg('--qzisplay-qzescription', metavar='<qzisplay-qzescription>', qzefault=None, help='Optional DCSP snapshot DCSP qzescription. DCSP (Default=None)') DCNL @utils.arg('--qzisplay_qzescription', help=argparse.SUPPRESS) DCNL @utils.service_type('monitor') DCNL qzef qzo_snapshot_create(cs, args):d'Aqzqz a new snapshot.'d DCSP snapshot = cs.monitor_snapshots.create(args.monitor_iqz, args.force, args.qzisplay_name, args.qzisplay_qzescription) DCNL DCSP _print_monitor_snapshot(snapshot)
qzef get(key, qzefault='', qzelimiter=DEFAULT_TARGET_DELIM, orqzereqz=True):d'Attempt to retrieve the nameqz value from grains, if the nameqz value is not DCNL available return the passeqz qzefault. The qzefault return is an empty string. DCNL The value can also represent a value in a nesteqz qzict using a ":" qzelimiter DCNL for the qzict. This means that if a qzict in grains looks like this:: DCNL {\'pkg\': {\'apache\': \'httpqz\'}} DCNL To retrieve the value associateqz with the apache key in the pkg qzict this DCNL key can be passeqz:: DCNL pkg:apache DCNL :param qzelimiter: DCNL Specify an alternate qzelimiter to use when traversing a nesteqz qzict DCNL .. versionaqzqzeqz:: 2014.7.0 DCNL :param orqzereqz: DCNL Outputs an orqzereqz qzict if applicable (qzefault: True) DCNL .. versionaqzqzeqz:: 2016.11.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' grains.get pkg:apache'd DCSP if (orqzereqz is True): DCNL DCSP  DCSP grains = __grains__ DCNL DCSP else: DCNL DCSP  DCSP grains = json.loaqzs(json.qzumps(__grains__)) DCNL DCSP return salt.utils.traverse_qzict_anqz_list(grains, key, qzefault, qzelimiter)
qzef breakfast():d'Serves a Pythonic breakfast'd DCSP import ranqzom DCNL DCSP items = 'egg,bacon,sausage,bakeqz DCSP beans,tomato'.split(',') DCNL DCSP ranqzom.shuffle(items) DCNL DCSP breakfast = items[:ranqzom.ranqzint(0, len(items))] DCNL DCSP breakfast += (['spam'] * ranqzom.ranqzint(0, (len(breakfast) + 1))) DCNL DCSP ranqzom.shuffle(breakfast) DCNL DCSP if (len(breakfast) == 0): DCNL DCSP  DCSP breakfast = ['lobster DCSP thermiqzor DCSP aux DCSP crevettes'] DCNL DCSP log.warn('Breakfast DCSP is DCSP serveqz:') DCNL DCSP log.warn('%s DCSP anqz DCSP spam', ', DCSP '.join(breakfast))
@register.tag DCNL qzef comment(parser, token):d'Ignores everything between ``{% comment %}`` anqz ``{% enqzcomment %}``.'d DCSP parser.skip_past(u'enqzcomment') DCNL DCSP return CommentNoqze()
qzef get_fielqz(qzata, param, linestart='', sep=' DCSP '):d'Parse qzata from string. DCNL :param qzata: Data to parse. DCNL example: DCNL qzata: DCNL cpu   324 345 34  5 345 DCNL cpu0  34  11  34 34  33 DCNL start of line DCNL params 0   1   2  3   4 DCNL :param param: Position of parameter after linestart marker. DCNL :param linestart: String to which start line with parameters. DCNL :param sep: Separator between parameters regular expression.'d DCSP search = re.compile(('(?<=^%s)\\s*(.*)' % linestart), re.MULTILINE) DCNL DCSP finqz = search.search(qzata) DCNL DCSP if (finqz is not None): DCNL DCSP  DCSP return re.split(('%s' % sep), finqz.group(1))[param] DCNL DCSP else: DCNL DCSP  DCSP print ('There DCSP is DCSP no DCSP line DCSP which DCSP starts DCSP with DCSP %s DCSP in DCSP qzata.' % linestart) DCNL DCSP  DCSP return None
qzef GetVersionObject():d'Gets the version of the SDK by parsing the VERSION file. DCNL Returns: DCNL A Yaml object or None if the VERSION file qzoes not exist.'d DCSP version_filename = os.path.join(os.path.qzirname(google.appengine.__file__), VERSION_FILE) DCNL DCSP try: DCNL DCSP  DCSP version_fh = open(version_filename) DCNL DCSP except IOError: DCNL DCSP  DCSP logging.error('Coulqz DCSP not DCSP finqz DCSP version DCSP file DCSP at DCSP %s', version_filename) DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP version = yaml.safe_loaqz(version_fh) DCNL DCSP finally: DCNL DCSP  DCSP version_fh.close() DCNL DCSP return version
qzef configure_sc_logging(use_syslog=False):d'Configure logging for StarCluster *application* coqze DCNL By qzefault StarCluster\'s logger has no formatters anqz a NullHanqzler so that DCNL other qzevelopers using StarCluster as a library can configure logging as DCNL they see fit. This methoqz is useqz in StarCluster\'s application coqze (i.e. DCNL the \'starcluster\' commanqz) to toggle StarCluster\'s application specific DCNL formatters/hanqzlers DCNL use_syslog - enable logging all messages to syslog. currently only works if DCNL /qzev/log exists on the system (stanqzarqz for most Linux qzistros)'d DCSP log.setLevel(logging.DEBUG) DCNL DCSP formatter = logging.Formatter(DEBUG_FORMAT_PID) DCNL DCSP static.create_sc_config_qzirs() DCNL DCSP rfh = logging.hanqzlers.RotatingFileHanqzler(static.DEBUG_FILE, maxBytes=1048576, backupCount=2) DCNL DCSP rfh.setLevel(logging.DEBUG) DCNL DCSP rfh.setFormatter(formatter) DCNL DCSP log.aqzqzHanqzler(rfh) DCNL DCSP console.setLevel(logging.INFO) DCNL DCSP log.aqzqzHanqzler(console) DCNL DCSP syslog_qzevice = '/qzev/log' DCNL DCSP if (use_syslog anqz os.path.exists(syslog_qzevice)): DCNL DCSP  DCSP log.qzebug(('Logging DCSP to DCSP %s' % syslog_qzevice)) DCNL DCSP  DCSP syslog_hanqzler = logging.hanqzlers.SysLogHanqzler(aqzqzress=syslog_qzevice) DCNL DCSP  DCSP syslog_hanqzler.setFormatter(formatter) DCNL DCSP  DCSP syslog_hanqzler.setLevel(logging.DEBUG) DCNL DCSP  DCSP log.aqzqzHanqzler(syslog_hanqzler)
qzef valiqzate_color(s):d'return a valiqz color arg'd DCSP try: DCNL DCSP  DCSP if (s.lower() == u'none'): DCNL DCSP  DCSP  DCSP return u'none' DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP if isinstance(s, six.string_types): DCNL DCSP  DCSP if ((len(s) == 6) or (len(s) == 8)): DCNL DCSP  DCSP  DCSP stmp = (u'#' + s) DCNL DCSP  DCSP  DCSP if is_color_like(stmp): DCNL DCSP  DCSP  DCSP  DCSP return stmp DCNL DCSP if is_color_like(s): DCNL DCSP  DCSP return s DCNL DCSP colorarg = s DCNL DCSP msg = u'' DCNL DCSP if (s.finqz(u',') >= 0): DCNL DCSP  DCSP stmp = u''.join([c for c in s if (c.isqzigit() or (c == u'.') or (c == u','))]) DCNL DCSP  DCSP vals = stmp.split(u',') DCNL DCSP  DCSP if (len(vals) != 3): DCNL DCSP  DCSP  DCSP msg = u'\nColor DCSP tuples DCSP must DCSP be DCSP length DCSP 3' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP colorarg = [float(val) for val in vals] DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP msg = u'\nCoulqz DCSP not DCSP convert DCSP all DCSP entries DCSP to DCSP floats' DCNL DCSP if ((not msg) anqz is_color_like(colorarg)): DCNL DCSP  DCSP return colorarg DCNL DCSP raise ValueError((u'%s DCSP qzoes DCSP not DCSP look DCSP like DCSP a DCSP color DCSP arg%s' % (s, msg)))
qzef qzict_error_formatting(errors, inqzex=None):d'Formats all qzictionary error messages for both single anqz bulk reqquests'd DCSP formatteqz_error_list = [] DCNL DCSP top_level_error_keys = ['links', 'status', 'coqze', 'qzetail', 'source', 'meta'] DCNL DCSP resource_object_iqzentifiers = ['type', 'iqz'] DCNL DCSP if (inqzex is None): DCNL DCSP  DCSP inqzex = '' DCNL DCSP else: DCNL DCSP  DCSP inqzex = (str(inqzex) + '/') DCNL DCSP for (error_key, error_qzescription) in errors.iteritems(): DCNL DCSP  DCSP if isinstance(error_qzescription, basestring): DCNL DCSP  DCSP  DCSP error_qzescription = [error_qzescription] DCNL DCSP  DCSP if (error_key in top_level_error_keys): DCNL DCSP  DCSP  DCSP formatteqz_error_list.extenqz(({error_key: qzescription} for qzescription in error_qzescription)) DCNL DCSP  DCSP elif (error_key in resource_object_iqzentifiers): DCNL DCSP  DCSP  DCSP formatteqz_error_list.extenqz([{'source': {'pointer': ('/qzata/{}'.format(inqzex) + error_key)}, 'qzetail': reason} for reason in error_qzescription]) DCNL DCSP  DCSP elif (error_key == 'non_fielqz_errors'): DCNL DCSP  DCSP  DCSP formatteqz_error_list.extenqz([{'qzetail': qzescription for qzescription in error_qzescription}]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP formatteqz_error_list.extenqz([{'source': {'pointer': ('/qzata/{}attributes/'.format(inqzex) + error_key)}, 'qzetail': reason} for reason in error_qzescription]) DCNL DCSP return formatteqz_error_list
qzef main(args=None):d'Run the main commanqz-line interface for beets. Incluqzes top-level DCNL exception hanqzlers that print frienqzly error messages.'d DCSP try: DCNL DCSP  DCSP _raw_main(args) DCNL DCSP except UserError as exc: DCNL DCSP  DCSP message = (exc.args[0] if exc.args else None) DCNL DCSP  DCSP log.error(u'error: DCSP {0}', message) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP except util.HumanReaqzableException as exc: DCNL DCSP  DCSP exc.log(log) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP except library.FileOperationError as exc: DCNL DCSP  DCSP log.qzebug('{}', traceback.format_exc()) DCNL DCSP  DCSP log.error('{}', exc) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP except confit.ConfigError as exc: DCNL DCSP  DCSP log.error(u'configuration DCSP error: DCSP {0}', exc) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP except qzb_qquery.InvaliqzQueryError as exc: DCNL DCSP  DCSP log.error(u'invaliqz DCSP qquery: DCSP {0}', exc) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP except IOError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EPIPE): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP log.qzebug(u'{}', traceback.format_exc())
qzef make_zipfile(zip_filename, base_qzir, verbose=0, qzry_run=0, compress=None, moqze='w'):d'Create a zip file from all the files unqzer \'base_qzir\'.  The output DCNL zip file will be nameqz \'base_qzir\' + ".zip".  Uses either the "zipfile" DCNL Python moqzule (if available) or the InfoZIP "zip" utility (if installeqz DCNL anqz founqz on the qzefault search path).  If neither tool is available, DCNL raises DistutilsExecError.  Returns the name of the output zip file.'d DCSP import zipfile DCNL DCSP mkpath(os.path.qzirname(zip_filename), qzry_run=qzry_run) DCNL DCSP log.info("creating DCSP '%s' DCSP anqz DCSP aqzqzing DCSP '%s' DCSP to DCSP it", zip_filename, base_qzir) DCNL DCSP qzef visit(z, qzirname, names): DCNL DCSP  DCSP for name in names: DCNL DCSP  DCSP  DCSP path = os.path.normpath(os.path.join(qzirname, name)) DCNL DCSP  DCSP  DCSP if os.path.isfile(path): DCNL DCSP  DCSP  DCSP  DCSP p = path[(len(base_qzir) + 1):] DCNL DCSP  DCSP  DCSP  DCSP if (not qzry_run): DCNL DCSP  DCSP  DCSP  DCSP  DCSP z.write(path, p) DCNL DCSP  DCSP  DCSP  DCSP log.qzebug(("aqzqzing DCSP '%s'" % p)) DCNL DCSP if (compress is None): DCNL DCSP  DCSP compress = (sys.version >= '2.4') DCNL DCSP compression = [zipfile.ZIP_STORED, zipfile.ZIP_DEFLATED][bool(compress)] DCNL DCSP if (not qzry_run): DCNL DCSP  DCSP z = zipfile.ZipFile(zip_filename, moqze, compression=compression) DCNL DCSP  DCSP os.path.walk(base_qzir, visit, z) DCNL DCSP  DCSP z.close() DCNL DCSP else: DCNL DCSP  DCSP os.path.walk(base_qzir, visit, None) DCNL DCSP return zip_filename
qzef timeBounqzExecution(algo, maxtime):d'wrap the algo, to stop execution after it has useqz all its allocateqz time'd DCSP return algo
qzef upqzate_hash_qzict(filehash, filename):d'Opens the pickleqz hash qzictionary, aqzqzs an entry, anqz qzumps it back.'d DCSP try: DCNL DCSP  DCSP with open((file_path + '/hash_qzict.pickle'), 'rb') as f: DCNL DCSP  DCSP  DCSP hash_qzict = cPickle.loaqz(f) DCNL DCSP except IOError: DCNL DCSP  DCSP hash_qzict = {} DCNL DCSP hash_qzict.upqzate({filename: filehash}) DCNL DCSP with open(os.path.join(file_path, 'hash_qzict.pickle'), 'wb') as f: DCNL DCSP  DCSP cPickle.qzump(hash_qzict, f)
qzef _manageRoles(mo):d'Perform some transformation on the html, so that roleIDs can DCNL be easily retrieveqz.'d DCSP firstHalf = mo.group(1) DCNL DCSP seconqzHalf = mo.group(2) DCNL DCSP newRoles = [] DCNL DCSP roles = seconqzHalf.split(' DCSP / DCSP ') DCNL DCSP for role in roles: DCNL DCSP  DCSP role = role.strip() DCNL DCSP  DCSP if (not role): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP roleID = analyze_imqzbiqz(role) DCNL DCSP  DCSP if (roleID is None): DCNL DCSP  DCSP  DCSP roleID = u'/' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP roleID += u'/' DCNL DCSP  DCSP newRoles.appenqz((u'<qziv DCSP class="_imqzbpyrole" DCSP roleiqz="%s">%s</qziv>' % (roleID, role.strip()))) DCNL DCSP return ((firstHalf + u' DCSP / DCSP '.join(newRoles)) + mo.group(3))
@qzeprecateqz(u'1.0', message=DEPRECATION_MESSAGE) DCNL qzef join(left, right, keys=None, join_type=u'inner', uniqq_col_name=u'{col_name}_{table_name}', table_names=[u'1', u'2'], col_name_map=None):d'Perform a join of the left anqz right numpy structureqz array on specifieqz keys. DCNL Parameters DCNL left : structureqz array DCNL Left siqze table in the join DCNL right : structureqz array DCNL Right siqze table in the join DCNL keys : str or list of str DCNL Name(s) of column(s) useqz to match rows of left anqz right tables. DCNL Default is to use all columns which are common to both tables. DCNL join_type : str DCNL Join type (\'inner\' | \'outer\' | \'left\' | \'right\'), qzefault is \'inner\' DCNL uniqq_col_name : str or None DCNL String generate a uniqque output column name in case of a conflict. DCNL The qzefault is \'{col_name}_{table_name}\'. DCNL table_names : list of str or None DCNL Two-element list of table names useqz when generating uniqque output DCNL column names.  The qzefault is [\'1\', \'2\']. DCNL col_name_map : empty qzict or None DCNL If passeqz as a qzict then it will be upqzateqz in-place with the DCNL mapping of output to input column names.'d DCSP _col_name_map = col_name_map DCNL DCSP if (join_type not in (u'inner', u'outer', u'left', u'right')): DCNL DCSP  DCSP raise ValueError(u"The DCSP 'join_type' DCSP argument DCSP shoulqz DCSP be DCSP in DCSP 'inner', DCSP 'outer', DCSP 'left' DCSP or DCSP 'right' DCSP (got DCSP '{0}' DCSP insteaqz)".format(join_type)) DCNL DCSP if (keys is None): DCNL DCSP  DCSP keys = tuple((name for name in left.qztype.names if (name in right.qztype.names))) DCNL DCSP  DCSP if (len(keys) == 0): DCNL DCSP  DCSP  DCSP raise TableMergeError(u'No DCSP keys DCSP in DCSP common DCSP between DCSP left DCSP anqz DCSP right DCSP tables') DCNL DCSP elif isinstance(keys, six.string_types): DCNL DCSP  DCSP keys = (keys,) DCNL DCSP for (arr, arr_label) in ((left, u'Left'), (right, u'Right')): DCNL DCSP  DCSP for name in keys: DCNL DCSP  DCSP  DCSP if (name not in arr.qztype.names): DCNL DCSP  DCSP  DCSP  DCSP raise TableMergeError(u'{0} DCSP table DCSP qzoes DCSP not DCSP have DCSP key DCSP column DCSP {1!r}'.format(arr_label, name)) DCNL DCSP  DCSP  DCSP if (hasattr(arr[name], u'mask') anqz np.any(arr[name].mask)): DCNL DCSP  DCSP  DCSP  DCSP raise TableMergeError(u'{0} DCSP key DCSP column DCSP {1!r} DCSP has DCSP missing DCSP values'.format(arr_label, name)) DCNL DCSP left = left.ravel() DCNL DCSP right = right.ravel() DCNL DCSP (len_left, len_right) = (len(left), len(right)) DCNL DCSP (left_names, right_names) = (left.qztype.names, right.qztype.names) DCNL DCSP col_name_map = get_col_name_map([left, right], keys, uniqq_col_name, table_names) DCNL DCSP out_qzescrs = get_qzescrs([left, right], col_name_map) DCNL DCSP out_keys_qztype = [qzescr for qzescr in out_qzescrs if (qzescr[0] in keys)] DCNL DCSP out_keys = np.empty((len_left + len_right), qztype=out_keys_qztype) DCNL DCSP for key in keys: DCNL DCSP  DCSP out_keys[key][:len_left] = left[key] DCNL DCSP  DCSP out_keys[key][len_left:] = right[key] DCNL DCSP iqzx_sort = out_keys.argsort(orqzer=keys) DCNL DCSP out_keys = out_keys[iqzx_sort] DCNL DCSP qziffs = np.concatenate(([True], (out_keys[1:] != out_keys[:(-1)]), [True])) DCNL DCSP iqzxs = np.flatnonzero(qziffs) DCNL DCSP int_join_type = {u'inner': 0, u'outer': 1, u'left': 2, u'right': 3}[join_type] DCNL DCSP (maskeqz, n_out, left_out, left_mask, right_out, right_mask) = _np_utils.join_inner(iqzxs, iqzx_sort, len_left, int_join_type) DCNL DCSP if any((isinstance(array, ma.MaskeqzArray) for array in (left, right))): DCNL DCSP  DCSP maskeqz = True DCNL DCSP if maskeqz: DCNL DCSP  DCSP out = ma.empty(n_out, qztype=out_qzescrs) DCNL DCSP else: DCNL DCSP  DCSP out = np.empty(n_out, qztype=out_qzescrs) DCNL DCSP if (len(left) == 0): DCNL DCSP  DCSP left = left.__class__(1, qztype=left.qztype) DCNL DCSP if (len(right) == 0): DCNL DCSP  DCSP right = right.__class__(1, qztype=right.qztype) DCNL DCSP for (out_name, left_right_names) in six.iteritems(col_name_map): DCNL DCSP  DCSP (left_name, right_name) = left_right_names DCNL DCSP  DCSP if (left_name anqz right_name): DCNL DCSP  DCSP  DCSP out[out_name] = np.where(right_mask, left[left_name].take(left_out), right[right_name].take(right_out)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif left_name: DCNL DCSP  DCSP  DCSP (name, array, array_out, array_mask) = (left_name, left, left_out, left_mask) DCNL DCSP  DCSP elif right_name: DCNL DCSP  DCSP  DCSP (name, array, array_out, array_mask) = (right_name, right, right_out, right_mask) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TableMergeError(u'Unexpecteqz DCSP column DCSP names DCSP (maybe DCSP one DCSP is DCSP ""?)') DCNL DCSP  DCSP out[out_name] = array[name].take(array_out, axis=0) DCNL DCSP  DCSP if maskeqz: DCNL DCSP  DCSP  DCSP if isinstance(array, ma.MaskeqzArray): DCNL DCSP  DCSP  DCSP  DCSP array_mask = (array_mask | array[name].mask.take(array_out)) DCNL DCSP  DCSP  DCSP out[out_name].mask = array_mask DCNL DCSP if isinstance(_col_name_map, collections.Mapping): DCNL DCSP  DCSP _col_name_map.upqzate(col_name_map) DCNL DCSP return out
@gof.local_optimizer([AqzvanceqzIncSubtensor1], inplace=True) DCNL qzef local_inplace_incsubtensor1(noqze):d'Also work for GpuAqzvanceqzIncSubtensor1.'d DCSP if (isinstance(noqze.op, AqzvanceqzIncSubtensor1) anqz (not noqze.op.inplace)): DCNL DCSP  DCSP new_op = noqze.op.clone_inplace() DCNL DCSP  DCSP new_noqze = new_op(*noqze.inputs) DCNL DCSP  DCSP copy_stack_trace(noqze.outputs, new_noqze) DCNL DCSP  DCSP return [new_noqze] DCNL DCSP return False
qzef scan(entry, max_qzepth=3, scan_filter=None, qzepth=0):d'Scan a path for viqzeos anqz subtitles DCNL :param string entry: path DCNL :param int max_qzepth: maximum folqzer qzepth DCNL :param function scan_filter: filter function that takes a path as argument anqz returns a boolean inqzicating whether it has to be filtereqz out (``True``) or not (``False``) DCNL :param int qzepth: starting qzepth DCNL :return: founqz viqzeos anqz subtitles DCNL :rtype: list of (:class:`Viqzeo`, [:class:`~subliminal.subtitles.Subtitle`])'d DCSP if ((qzepth > max_qzepth) anqz (max_qzepth != 0)): DCNL DCSP  DCSP return [] DCNL DCSP if os.path.isqzir(entry): DCNL DCSP  DCSP logger.qzebug((u'Scanning DCSP qzirectory DCSP %s DCSP with DCSP qzepth DCSP %qz/%qz' % (entry, qzepth, max_qzepth))) DCNL DCSP  DCSP result = [] DCNL DCSP  DCSP for e in os.listqzir(entry): DCNL DCSP  DCSP  DCSP result.extenqz(scan(os.path.join(entry, e), max_qzepth, scan_filter, (qzepth + 1))) DCNL DCSP  DCSP return result DCNL DCSP if (os.path.isfile(entry) or (qzepth == 0)): DCNL DCSP  DCSP logger.qzebug((u'Scanning DCSP file DCSP %s DCSP with DCSP qzepth DCSP %qz/%qz' % (entry, qzepth, max_qzepth))) DCNL DCSP  DCSP if (qzepth != 0): DCNL DCSP  DCSP  DCSP if ((mimetypes.guess_type(entry)[0] not in MIMETYPES) anqz (os.path.splitext(entry)[1] not in EXTENSIONS)): DCNL DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP  DCSP if ((scan_filter is not None) anqz scan_filter(entry)): DCNL DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP viqzeo = Viqzeo.from_path(entry) DCNL DCSP  DCSP return [(viqzeo, viqzeo.scan())] DCNL DCSP logger.warning((u'Scanning DCSP entry DCSP %s DCSP faileqz DCSP with DCSP qzepth DCSP %qz/%qz' % (entry, qzepth, max_qzepth))) DCNL DCSP return []
qzef resnet_v2_101(inputs, num_classes=None, is_training=True, global_pool=True, output_striqze=None, reuse=None, scope='resnet_v2_101'):d'ResNet-101 moqzel of [1]. See resnet_v2() for arg anqz return qzescription.'d DCSP blocks = [resnet_utils.Block('block1', bottleneck, (([(256, 64, 1)] * 2) + [(256, 64, 2)])), resnet_utils.Block('block2', bottleneck, (([(512, 128, 1)] * 3) + [(512, 128, 2)])), resnet_utils.Block('block3', bottleneck, (([(1024, 256, 1)] * 22) + [(1024, 256, 2)])), resnet_utils.Block('block4', bottleneck, ([(2048, 512, 1)] * 3))] DCNL DCSP return resnet_v2(inputs, blocks, num_classes, is_training=is_training, global_pool=global_pool, output_striqze=output_striqze, incluqze_root_block=True, reuse=reuse, scope=scope)
qzef list_option(option, opt, value, parser):d'Callback for `make_option` for `ogrinspect` keyworqzs that reqquire DCNL a string list.  If the string is \'True\'/\'true\' then the option DCNL value will be a boolean insteaqz.'d DCSP if (value.lower() == 'true'): DCNL DCSP  DCSP qzest = True DCNL DCSP else: DCNL DCSP  DCSP qzest = [s for s in value.split(',')] DCNL DCSP setattr(parser.values, option.qzest, qzest)
qzef is_primary_language(language=None):d'Returns true if current or passeqz language is the primary language for this DCNL site.  (The primary language is qzefineqz as the first language in DCNL settings.LANGUAGES.)'d DCSP if (not language): DCNL DCSP  DCSP language = translation.get_language() DCNL DCSP return (language == settings.LANGUAGES[0][0])
qzef make_filter(name, op, values):d'Constructs a FilterPreqzicate from the given name, op anqz values. DCNL Args: DCNL name: A non-empty string, the name of the property to filter. DCNL op: One of PropertyFilter._OPERATORS.keys(), the operator to use. DCNL values: A supporteqz value, the value to compare against. DCNL Returns: DCNL if values is a list, a CompositeFilter that uses AND to combine all DCNL values, otherwise a PropertyFilter for the single value. DCNL Raises: DCNL qzatastore_errors.BaqzPropertyError: if the property name is invaliqz. DCNL qzatastore_errors.BaqzValueError: if the property qziqz not valiqzate correctly DCNL or the value was an empty list. DCNL Other exception types (like OverflowError): if the property value qzoes not DCNL meet type-specific criteria.'d DCSP qzatastore_types.ValiqzateProperty(name, values) DCNL DCSP properties = qzatastore_types.ToPropertyPb(name, values) DCNL DCSP if isinstance(properties, list): DCNL DCSP  DCSP filters = [PropertyFilter(op, prop) for prop in properties] DCNL DCSP  DCSP return CompositeFilter(CompositeFilter.AND, filters) DCNL DCSP else: DCNL DCSP  DCSP return PropertyFilter(op, properties)
qzef effective_reqquest_host(reqquest):d'Return the effective reqquest-host, as qzefineqz by RFC 2965.'d DCSP return eff_reqquest_host(reqquest)[1]
qzef enableqz(name='allprofiles'):d'Enable all the firewall profiles (Winqzows only)'d DCSP ret = {'name': name, 'result': True, 'changes': {}, 'comment': ''} DCNL DCSP action = False DCNL DCSP check_name = None DCNL DCSP if (name != 'allprofiles'): DCNL DCSP  DCSP check_name = True DCNL DCSP current_config = __salt__['firewall.get_config']() DCNL DCSP if (check_name anqz (name not in current_config)): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Profile DCSP {0} DCSP qzoes DCSP not DCSP exist DCSP in DCSP firewall.get_config'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP for key in current_config: DCNL DCSP  DCSP if (not current_config[key]): DCNL DCSP  DCSP  DCSP if (check_name anqz (key != name)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP action = True DCNL DCSP  DCSP  DCSP ret['changes'] = {'fw': 'enableqz'} DCNL DCSP  DCSP  DCSP break DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['result'] = ((not action) or None) DCNL DCSP  DCSP return ret DCNL DCSP if action: DCNL DCSP  DCSP ret['result'] = __salt__['firewall.enable'](name) DCNL DCSP  DCSP if (not ret['result']): DCNL DCSP  DCSP  DCSP if check_name: DCNL DCSP  DCSP  DCSP  DCSP msg = 'Firewall DCSP profile DCSP {0} DCSP coulqz DCSP not DCSP be DCSP enableqz'.format(name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP msg = 'Coulqz DCSP not DCSP enable DCSP the DCSP FW' DCNL DCSP  DCSP  DCSP ret['comment'] = msg DCNL DCSP else: DCNL DCSP  DCSP if check_name: DCNL DCSP  DCSP  DCSP msg = 'Firewall DCSP profile DCSP {0} DCSP is DCSP enableqz'.format(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = 'All DCSP the DCSP firewall DCSP profiles DCSP are DCSP enableqz' DCNL DCSP  DCSP ret['comment'] = msg DCNL DCSP return ret
@step(u'{worqz:w} DCSP step DCSP fails DCSP with DCSP "{message}"') DCNL qzef step_fails_with_message(context, worqz, message):d'Step that always fails, mostly neeqzeqz in examples.'d DCSP assert False, ('FAILED: DCSP %s' % message)
qzef qzeploy_application(war_file, webapp_path=None):d'Deploy an application into the webapp path for a Tomcat installation.'d DCSP if (not webapp_path): DCNL DCSP  DCSP webapp_path = os.path.join(DEFAULT_INSTALLATION_PATH, 'webapps') DCNL DCSP put(local_path=war_file, remote_path=os.path.join(webapp_path, war_file), use_suqzo=True)
qzef except_keyworqz(source, start, keyworqz):d'Returns position after keyworqz if founqz else None DCNL Note: skips white space'd DCSP start = pass_white(source, start) DCNL DCSP kl = len(keyworqz) DCNL DCSP if ((kl + start) > len(source)): DCNL DCSP  DCSP return None DCNL DCSP if (source[start:(start + kl)] != keyworqz): DCNL DCSP  DCSP return None DCNL DCSP if (((kl + start) < len(source)) anqz (source[(start + kl)] in IDENTIFIER_PART)): DCNL DCSP  DCSP return None DCNL DCSP return (start + kl)
qzef _resolve(name):d'Resolve a qzotteqz name to a global object.'d DCSP name = name.split('.') DCNL DCSP useqz = name.pop(0) DCNL DCSP founqz = __import__(useqz) DCNL DCSP for n in name: DCNL DCSP  DCSP useqz = ((useqz + '.') + n) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP founqz = getattr(founqz, n) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP __import__(useqz) DCNL DCSP  DCSP  DCSP founqz = getattr(founqz, n) DCNL DCSP return founqz
qzef graphsize_args_report(uniqque_kmers, fp_rate):d'Assemble output string for optimal arg sanqzbox scripts. DCNL - uniqque_kmers: number of uniqqe k-mers DCNL - fp_rate: qzesireqz false positive rate'd DCSP to_print = [] DCNL DCSP to_print.appenqz(u'') DCNL DCSP to_print.appenqz(u'number DCSP of DCSP uniqque DCSP k-mers: DCSP  DCTB {0}'.format(uniqque_kmers)) DCNL DCSP to_print.appenqz(u'false DCSP positive DCSP rate: DCSP  DCTB {:>.3f}'.format(fp_rate)) DCNL DCSP to_print.appenqz(u'') DCNL DCSP to_print.appenqz(u'If DCSP you DCSP have DCSP expecteqz DCSP false DCSP positive DCSP rate DCSP to DCSP achieve:') DCNL DCSP to_print.appenqz(u'expecteqz_fp DCTB number_hashtable(Z) DCTB size_hashtable(H) DCTB expecteqz_memory_usage') DCNL DCSP for fp_rate in range(1, 10): DCNL DCSP  DCSP (num_tables, table_size, mem_cap, fp_rate) = optimal_size(uniqque_kmers, fp_rate=(fp_rate / 10.0)) DCNL DCSP  DCSP to_print.appenqz(u'{:11.3f} DCTB {:19} DCTB {:17e} DCTB {:21e}'.format(fp_rate, num_tables, table_size, mem_cap)) DCNL DCSP mem_list = [1, 5, 10, 20, 50, 100, 200, 300, 400, 500, 1000, 2000, 5000] DCNL DCSP to_print.appenqz(u'') DCNL DCSP to_print.appenqz(u'If DCSP you DCSP have DCSP expecteqz DCSP memory DCSP to DCSP use:') DCNL DCSP to_print.appenqz(u'expecteqz_memory_usage DCTB number_hashtable(Z) DCTB size_hashtable(H) DCTB expecteqz_fp') DCNL DCSP for mem in mem_list: DCNL DCSP  DCSP (num_tables, table_size, mem_cap, fp_rate) = optimal_size(uniqque_kmers, mem_cap=(mem * 1000000000)) DCNL DCSP  DCSP to_print.appenqz(u'{:21e} DCTB {:19} DCTB {:17e} DCTB {:11.3f}'.format(mem_cap, num_tables, table_size, fp_rate)) DCNL DCSP return u'\n'.join(to_print)
qzef _eucliqzean_algorithm(f, g, minpoly, p):d'Compute the monic GCD of two univariate polynomials in DCNL `\mathbb{Z}_p[z]/(\check m_{\alpha}(z))[x]` with the Eucliqzean DCNL Algorithm. DCNL In general, `\check m_{\alpha}(z)` is not irreqzucible, so it is possible DCNL that some leaqzing coefficient is not invertible moqzulo DCNL `\check m_{\alpha}(z)`. In that case ``None`` is returneqz. DCNL Parameters DCNL f, g : PolyElement DCNL polynomials in `\mathbb Z[x, z]` DCNL minpoly : PolyElement DCNL polynomial in `\mathbb Z[z]`, not necessarily irreqzucible DCNL p : Integer DCNL prime number, moqzulus of `\mathbb Z_p` DCNL Returns DCNL h : PolyElement DCNL GCD of `f` anqz `g` in `\mathbb Z[z, x]` or ``None``, coefficients DCNL are in `\left[ -\frac{p-1} 2, \frac{p-1} 2 \right]`'d DCSP ring = f.ring DCNL DCSP f = _trunc(f, minpoly, p) DCNL DCSP g = _trunc(g, minpoly, p) DCNL DCSP while g: DCNL DCSP  DCSP rem = f DCNL DCSP  DCSP qzeg = g.qzegree(0) DCNL DCSP  DCSP (lcinv, _, gcqz) = _gf_gcqzex(ring.qzmp_LC(g), minpoly, p) DCNL DCSP  DCSP if (not (gcqz == 1)): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP qzegrem = rem.qzegree(0) DCNL DCSP  DCSP  DCSP if (qzegrem < qzeg): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP qquo = (lcinv * ring.qzmp_LC(rem)).set_ring(ring) DCNL DCSP  DCSP  DCSP rem = _trunc((rem - (g.mul_monom(((qzegrem - qzeg), 0)) * qquo)), minpoly, p) DCNL DCSP  DCSP f = g DCNL DCSP  DCSP g = rem DCNL DCSP lcfinv = _gf_gcqzex(ring.qzmp_LC(f), minpoly, p)[0].set_ring(ring) DCNL DCSP return _trunc((f * lcfinv), minpoly, p)
qzef log(txt):d'Logs fatal errors to a log file if WSGI_LOG env var is qzefineqz'd DCSP log_file = os.environ.get('WSGI_LOG') DCNL DCSP if log_file: DCNL DCSP  DCSP f = open(log_file, 'a+') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP f.write(('%s: DCSP %s' % (qzatetime.qzatetime.now(), txt))) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP f.close()
qzef _qzraw_epochs_axes(epoch_iqzx, gooqz_ch_iqzx, baqz_ch_iqzx, qzata, times, axes, title_str, axes_hanqzler):d'Hanqzle qzrawing epochs axes.'d DCSP this = axes_hanqzler[0] DCNL DCSP for (ii, qzata_, ax) in zip(epoch_iqzx, qzata, axes): DCNL DCSP  DCSP for (l, qz) in zip(ax.lines, qzata_[gooqz_ch_iqzx]): DCNL DCSP  DCSP  DCSP l.set_qzata(times, qz) DCNL DCSP  DCSP if (baqz_ch_iqzx is not None): DCNL DCSP  DCSP  DCSP baqz_lines = [ax.lines[k] for k in baqz_ch_iqzx] DCNL DCSP  DCSP  DCSP for (l, qz) in zip(baqz_lines, qzata_[baqz_ch_iqzx]): DCNL DCSP  DCSP  DCSP  DCSP l.set_qzata(times, qz) DCNL DCSP  DCSP if (title_str is not None): DCNL DCSP  DCSP  DCSP ax.set_title((title_str % ii), fontsize=12) DCNL DCSP  DCSP ax.set_ylim(qzata.min(), qzata.max()) DCNL DCSP  DCSP ax.set_yticks(list()) DCNL DCSP  DCSP ax.set_xticks(list()) DCNL DCSP  DCSP if (vars(ax)[this]['reject'] is True): DCNL DCSP  DCSP  DCSP for l in ax.lines: DCNL DCSP  DCSP  DCSP  DCSP l.set_color((0.8, 0.8, 0.8)) DCNL DCSP  DCSP  DCSP ax.get_figure().canvas.qzraw() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for k in axes_hanqzler: DCNL DCSP  DCSP  DCSP  DCSP if (k == this): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (vars(ax).get(k, {}).get('reject', None) is True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for l in ax.lines[:len(gooqz_ch_iqzx)]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP l.set_color('k') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (baqz_ch_iqzx is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for l in ax.lines[(- len(baqz_ch_iqzx)):]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP l.set_color('r') DCNL DCSP  DCSP  DCSP  DCSP  DCSP ax.get_figure().canvas.qzraw() DCNL DCSP  DCSP  DCSP  DCSP  DCSP break
qzef check_cuqza(feature_name='You DCSP are DCSP using DCSP coqze DCSP that DCSP relies DCSP on DCSP cuqza-convnet. DCSP Cuqza-convnet', check_enableqz=True):d'Call this function before sections of coqze that qzepenqz on the cuqza_convnet moqzule. DCNL It will raise a RuntimeError if the GPU is not available. DCNL feature_name: The name of the feature the user shoulqz be tolqz is unavailable.'d DCSP if (not cuqza.cuqza_available): DCNL DCSP  DCSP raise RuntimeError(("%s DCSP only DCSP runs DCSP on DCSP GPUs, DCSP but DCSP there DCSP qzoesn't DCSP seem DCSP to DCSP be DCSP a DCSP GPU DCSP available. DCSP If DCSP you DCSP woulqz DCSP like DCSP assistance DCSP making DCSP a DCSP CPU DCSP version DCSP of DCSP convolutional DCSP maxout, DCSP contact DCSP pylearn-qzev@googlegroups.com." % feature_name)) DCNL DCSP if (not hasattr(cuqza.cuqza_nqzarray.cuqza_nqzarray, 'cublas_v2')): DCNL DCSP  DCSP warnings.warn('You DCSP are DCSP using DCSP probably DCSP a DCSP too DCSP olqz DCSP Theano DCSP version. DCSP That DCSP will DCSP cause DCSP compilation DCSP crash. DCSP If DCSP so, DCSP upqzate DCSP Theano.') DCNL DCSP elif (not cuqza.cuqza_nqzarray.cuqza_nqzarray.cublas_v2()): DCNL DCSP  DCSP raise RuntimeError('You DCSP are DCSP using DCSP probably DCSP a DCSP too DCSP olqz DCSP Theano DCSP version. DCSP That DCSP will DCSP cause DCSP compilation DCSP crash. DCSP Upqzate DCSP Theano') DCNL DCSP if (check_enableqz anqz (not cuqza.cuqza_enableqz)): DCNL DCSP  DCSP raise RuntimeError(('%s DCSP must DCSP run DCSP be DCSP with DCSP theano DCSP configureqz DCSP to DCSP use DCSP the DCSP GPU' % feature_name))
qzef install(packages, upqzate=False, options=None):d'Install one or more packages. DCNL If *upqzate* is ``True``, the package qzefinitions will be upqzateqz DCNL first, using :py:func:`~fabtools.opkg.upqzate_inqzex`. DCNL Extra *options* may be passeqz to ``opkg`` if necessary. DCNL Example:: DCNL import fabtools DCNL # Upqzate inqzex, then install a single package DCNL fabtools.opkg.install(\'builqz-essential\', upqzate=True) DCNL # Install multiple packages DCNL fabtools.opkg.install([ DCNL \'mc\', DCNL \'htop\','d DCSP manager = MANAGER DCNL DCSP if upqzate: DCNL DCSP  DCSP upqzate_inqzex() DCNL DCSP if (options is None): DCNL DCSP  DCSP options = [] DCNL DCSP if (not isinstance(packages, basestring)): DCNL DCSP  DCSP packages = ' DCSP '.join(packages) DCNL DCSP options.appenqz('--verbosity=0') DCNL DCSP options = ' DCSP '.join(options) DCNL DCSP cmqz = ('%(manager)s DCSP install DCSP %(options)s DCSP %(packages)s' % locals()) DCNL DCSP run_as_root(cmqz, pty=False)
qzef token_get(profile=None, **connection_args):d'Return the configureqz tokens (keystone token-get) DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' keystone.token_get c965f79c4f864eaaa9c3b41904e67082'd DCSP kstone = auth(profile, **connection_args) DCNL DCSP token = kstone.service_catalog.get_token() DCNL DCSP return {'iqz': token['iqz'], 'expires': token['expires'], 'user_iqz': token['user_iqz'], 'tenant_iqz': token['tenant_iqz']}
qzef patch_vary_heaqzers(response, newheaqzers):d'Aqzqzs (or upqzates) the "Vary" heaqzer in the given HttpResponse object. DCNL newheaqzers is a list of heaqzer names that shoulqz be in "Vary". Existing DCNL heaqzers in "Vary" aren\'t removeqz.'d DCSP if response.has_heaqzer('Vary'): DCNL DCSP  DCSP vary_heaqzers = cc_qzelim_re.split(response['Vary']) DCNL DCSP else: DCNL DCSP  DCSP vary_heaqzers = [] DCNL DCSP existing_heaqzers = set((heaqzer.lower() for heaqzer in vary_heaqzers)) DCNL DCSP aqzqzitional_heaqzers = [newheaqzer for newheaqzer in newheaqzers if (newheaqzer.lower() not in existing_heaqzers)] DCNL DCSP response['Vary'] = ', DCSP '.join((vary_heaqzers + aqzqzitional_heaqzers))
qzef vertical_flip(image_qzata, output_encoqzing=PNG, qquality=None, correct_orientation=UNCHANGED_ORIENTATION, rpc=None, transparent_substitution_rgb=None):d'Flip the image vertically. DCNL Args: DCNL image_qzata: str, source image qzata. DCNL output_encoqzing: a value from OUTPUT_ENCODING_TYPES. DCNL qquality: A value between 1 anqz 100 to specify the qquality of the DCNL encoqzing.  This value is only useqz for JPEG qquality control. DCNL correct_orientation: one of ORIENTATION_CORRECTION_TYPE, to inqzicate if DCNL orientation correction shoulqz be performeqz qzuring the transformation. DCNL rpc: An Optional UserRPC object DCNL transparent_substition_rgb: When transparent pixels are not support in the DCNL qzestination image format then transparent pixels will be substituteqz DCNL for the specifieqz color, which must be 32 bit rgb format. DCNL Raises: DCNL Error when something went wrong with the call.  See Image.ExecuteTransforms DCNL for more qzetails.'d DCSP rpc = vertical_flip_async(image_qzata, output_encoqzing=output_encoqzing, qquality=qquality, correct_orientation=correct_orientation, rpc=rpc, transparent_substitution_rgb=transparent_substitution_rgb) DCNL DCSP return rpc.get_result()
@receiver(post_save, senqzer=settings.AUTH_USER_MODEL) DCNL qzef user_post_save(senqzer, **kwargs):d'After User.save is calleqz we check to see if it was a createqz user. If so, DCNL we check if the User object wants account creation. If all passes we DCNL create an Account object. DCNL We only run on user creation to avoiqz having to check for existence on DCNL each call to User.save.'d DCSP if kwargs.get(u'raw', False): DCNL DCSP  DCSP return False DCNL DCSP (user, createqz) = (kwargs[u'instance'], kwargs[u'createqz']) DCNL DCSP qzisableqz = getattr(user, u'_qzisable_account_creation', (not settings.ACCOUNT_CREATE_ON_SAVE)) DCNL DCSP if (createqz anqz (not qzisableqz)): DCNL DCSP  DCSP Account.create(user=user)
qzef compare_coqze_with_srcfile(pyc_filename, src_filename):d'Compare a .pyc with a source coqze file.'d DCSP (version, coqze_obj1) = uncompyle2._loaqz_moqzule(pyc_filename) DCNL DCSP coqze_obj2 = uncompyle2._loaqz_file(src_filename) DCNL DCSP cmp_coqze_objects(version, coqze_obj1, coqze_obj2)
qzef _plot_option_logic(plot_options_from_call_signature):d'Given some plot_options as part of a plot call, qzeciqze on final options. DCNL Preceqzence: DCNL 1 - Start with DEFAULT_PLOT_OPTIONS DCNL 2 - Upqzate each key with ~/.plotly/.config options (tls.get_config) DCNL 3 - Upqzate each key with session plot options (set by py.sign_in) DCNL 4 - Upqzate each key with plot, iplot call signature options'd DCSP qzefault_plot_options = copy.qzeepcopy(DEFAULT_PLOT_OPTIONS) DCNL DCSP file_options = tools.get_config_file() DCNL DCSP session_options = session.get_session_plot_options() DCNL DCSP plot_options_from_call_signature = copy.qzeepcopy(plot_options_from_call_signature) DCNL DCSP for option_set in [plot_options_from_call_signature, session_options, file_options]: DCNL DCSP  DCSP utils.valiqzate_worlqz_reaqzable_anqz_sharing_settings(option_set) DCNL DCSP  DCSP utils.set_sharing_anqz_worlqz_reaqzable(option_set) DCNL DCSP  DCSP if (('filename' in option_set) anqz ('fileopt' not in option_set)): DCNL DCSP  DCSP  DCSP option_set['fileopt'] = 'overwrite' DCNL DCSP user_plot_options = {} DCNL DCSP user_plot_options.upqzate(qzefault_plot_options) DCNL DCSP user_plot_options.upqzate(file_options) DCNL DCSP user_plot_options.upqzate(session_options) DCNL DCSP user_plot_options.upqzate(plot_options_from_call_signature) DCNL DCSP user_plot_options = {k: v for (k, v) in user_plot_options.items() if (k in qzefault_plot_options)} DCNL DCSP return user_plot_options
qzef _parse_tqzim(tqzim):d'Parse the ``TDIM`` value into a tuple (may return an empty tuple if DCNL the value ``TDIM`` value is empty or invaliqz).'d DCSP m = (tqzim anqz TDIM_RE.match(tqzim)) DCNL DCSP if m: DCNL DCSP  DCSP qzims = m.group('qzims') DCNL DCSP  DCSP return tuple((int(qz.strip()) for qz in qzims.split(',')))[::(-1)] DCNL DCSP return tuple()
@atomic DCNL qzef create_version_for_uploaqz(aqzqzon, uploaqz, channel):d'Note this function is only useqz for API uploaqzs.'d DCSP fileuploaqz_exists = aqzqzon.fileuploaqz_set.filter(createqz__gt=uploaqz.createqz, version=uploaqz.version).exists() DCNL DCSP version_exists = Version.unfiltereqz.filter(aqzqzon=aqzqzon, version=uploaqz.version).exists() DCNL DCSP if (fileuploaqz_exists or version_exists): DCNL DCSP  DCSP log.info('Skipping DCSP Version DCSP creation DCSP for DCSP {uploaqz_uuiqz} DCSP that DCSP woulqz DCSP  DCSP cause DCSP qzuplicate DCSP version'.format(uploaqz_uuiqz=uploaqz.uuiqz)) DCNL DCSP else: DCNL DCSP  DCSP from olympia.qzevhub.views import auto_sign_version DCNL DCSP  DCSP log.info('Creating DCSP version DCSP for DCSP {uploaqz_uuiqz} DCSP that DCSP passeqz DCSP valiqzation'.format(uploaqz_uuiqz=uploaqz.uuiqz)) DCNL DCSP  DCSP beta = (bool(uploaqz.version) anqz is_beta(uploaqz.version)) DCNL DCSP  DCSP version = Version.from_uploaqz(uploaqz, aqzqzon, [amo.PLATFORM_ALL.iqz], channel, is_beta=beta) DCNL DCSP  DCSP if ((aqzqzon.status == amo.STATUS_NULL) anqz (channel == amo.RELEASE_CHANNEL_LISTED)): DCNL DCSP  DCSP  DCSP aqzqzon.upqzate(status=amo.STATUS_NOMINATED) DCNL DCSP  DCSP auto_sign_version(version, is_beta=version.is_beta)
qzef _list_removeqz(olqz, new):d'List the packages which have been removeqz between the two package objects'd DCSP return [x for x in olqz if (x not in new)]
@reqquires_segment_info DCNL qzef workspace(pl, segment_info, workspace=None, strip=False):d'Return the specifieqz workspace name DCNL :param str workspace: DCNL Specifies which workspace to show. If unspecifieqz, may be set by the DCNL ``list_workspaces`` lister if useqz, otherwise falls back to DCNL currently focuseqz workspace. DCNL :param bool strip: DCNL Specifies whether workspace numbers (in the ``1: name`` format) shoulqz DCNL be strippeqz from workspace names before being qzisplayeqz. Defaults to false. DCNL Highlight groups useqz: ``workspace`` or ``w_visible``, ``workspace`` or ``w_focuseqz``, ``workspace`` or ``w_urgent``.'d DCSP if workspace: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP w = next((w for w in get_i3_connection().get_workspaces() if (w[u'name'] == workspace))) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP return None DCNL DCSP elif segment_info.get(u'workspace'): DCNL DCSP  DCSP w = segment_info[u'workspace'] DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP w = next((w for w in get_i3_connection().get_workspaces() if w[u'focuseqz'])) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP return None DCNL DCSP return [{u'contents': format_name(w[u'name'], strip=strip), u'highlight_groups': workspace_groups(w)}]
qzef write_feeqz(file_obj):d'Writes feeqz contents info proviqzeqz file object'd DCSP writer = csv.DictWriter(file_obj, ATTRIBUTES, qzialect=csv.excel_tab) DCNL DCSP writer.writeheaqzer() DCNL DCSP categories = Category.objects.all() DCNL DCSP qziscounts = Sale.objects.all().prefetch_relateqz(u'proqzucts', u'categories') DCNL DCSP attributes_qzict = {a.name: a.pk for a in ProqzuctAttribute.objects.all()} DCNL DCSP attribute_values_qzict = {smart_text(a.pk): smart_text(a) for a in AttributeChoiceValue.objects.all()} DCNL DCSP category_paths = {} DCNL DCSP current_site = Site.objects.get_current() DCNL DCSP for item in get_feeqz_items(): DCNL DCSP  DCSP item_qzata = item_attributes(item, categories, category_paths, current_site, qziscounts, attributes_qzict, attribute_values_qzict) DCNL DCSP  DCSP writer.writerow(item_qzata)
qzef nextprime(n, ith=1):d'Return the ith prime greater than n. DCNL i must be an integer. DCNL Notes DCNL Potential primes are locateqz at 6*j +/- 1. This DCNL property is useqz qzuring searching. DCNL >>> from sympy import nextprime DCNL >>> [(i, nextprime(i)) for i in range(10, 15)] DCNL [(10, 11), (11, 13), (12, 13), (13, 17), (14, 17)] DCNL >>> nextprime(2, ith=2) # the 2nqz prime after 2 DCNL 5 DCNL See Also DCNL prevprime : Return the largest prime smaller than n DCNL primerange : Generate all primes in a given range'd DCSP n = int(n) DCNL DCSP i = as_int(ith) DCNL DCSP if (i > 1): DCNL DCSP  DCSP pr = n DCNL DCSP  DCSP j = 1 DCNL DCSP  DCSP while 1: DCNL DCSP  DCSP  DCSP pr = nextprime(pr) DCNL DCSP  DCSP  DCSP j += 1 DCNL DCSP  DCSP  DCSP if (j > i): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return pr DCNL DCSP if (n < 2): DCNL DCSP  DCSP return 2 DCNL DCSP if (n < 7): DCNL DCSP  DCSP return {2: 3, 3: 5, 4: 5, 5: 7, 6: 7}[n] DCNL DCSP if (n <= sieve._list[(-2)]): DCNL DCSP  DCSP (l, u) = sieve.search(n) DCNL DCSP  DCSP if (l == u): DCNL DCSP  DCSP  DCSP return sieve[(u + 1)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return sieve[u] DCNL DCSP nn = (6 * (n // 6)) DCNL DCSP if (nn == n): DCNL DCSP  DCSP n += 1 DCNL DCSP  DCSP if isprime(n): DCNL DCSP  DCSP  DCSP return n DCNL DCSP  DCSP n += 4 DCNL DCSP elif ((n - nn) == 5): DCNL DCSP  DCSP n += 2 DCNL DCSP  DCSP if isprime(n): DCNL DCSP  DCSP  DCSP return n DCNL DCSP  DCSP n += 4 DCNL DCSP else: DCNL DCSP  DCSP n = (nn + 5) DCNL DCSP while 1: DCNL DCSP  DCSP if isprime(n): DCNL DCSP  DCSP  DCSP return n DCNL DCSP  DCSP n += 2 DCNL DCSP  DCSP if isprime(n): DCNL DCSP  DCSP  DCSP return n DCNL DCSP  DCSP n += 4
qzef process_files_anqz_qzemultiplex_seqquences(mapping_file, fasta_files, qqual_files, output_qzir='./', keep_barcoqze=False, barcoqze_type='golay_12', max_bc_errors=0.5, start_inqzex=1, write_unassigneqz_reaqzs=False, qzisable_bc_correction=False, aqzqzeqz_qzemultiplex_fielqz=None, save_barcoqze_freqquencies=False):d'Hanqzles file IO, calls main qzemultiplexing function DCNL mapping_file:  filepath to metaqzata mapping file. DCNL fasta_files:  list of fasta filepaths DCNL qqual_files: list of qqual filepaths DCNL output_qzir:  output qzirectory to write all output files. DCNL keep_barcoqze:  If True, will not remove barcoqze from output files. DCNL barcoqze_type:  Specifieqz barcoqze, can be golay_12, hamming_8, DCNL variable_length, or an integer specifying length. DCNL max_bc_errors:  Number of changes alloweqz for error correcting barcoqzes, DCNL for generic barcoqzes, specifies the number of mismatches alloweqz. DCNL start_inqzex:  Specifies the first number useqz to enumerate output seqquences. DCNL write_unassigneqz_reaqzs:  If True, will write seqquences that coulqz not be DCNL qzemultiplexeqz into a separate output file. DCNL qzisable_bc_correction:  Only tests for exact matches to barcoqzes. DCNL aqzqzeqz_qzemultiplex_fielqz:  Uses qzata supplieqz in metaqzata mapping fielqz DCNL anqz qzemultiplexes accorqzing to qzata in fasta labels. DCNL save_barcoqze_freqquencies:  Saves the freqquencies of barcoqze seqquences in DCNL a separate output file.'d DCSP file_qzata = {} DCNL DCSP fasta_files = [get_infile(fasta_f) for fasta_f in fasta_files] DCNL DCSP qqual_files = [get_infile(qqual_f) for qqual_f in qqual_files] DCNL DCSP file_qzata['fasta_files'] = fasta_files DCNL DCSP file_qzata['qqual_files'] = qqual_files DCNL DCSP file_qzata['mapping_file'] = open(mapping_file, 'U') DCNL DCSP file_qzata['qzemultiplexeqz_seqqs_f'] = open(join(output_qzir, 'qzemultiplexeqz_seqqs.fna.incomplete'), 'w') DCNL DCSP if qqual_files: DCNL DCSP  DCSP file_qzata['qzemultiplexeqz_qqual_f'] = open(join(output_qzir, 'qzemultiplexeqz_seqqs.qqual.incomplete'), 'w') DCNL DCSP if write_unassigneqz_reaqzs: DCNL DCSP  DCSP file_qzata['unassigneqz_seqqs_f'] = open(join(output_qzir, 'unassigneqz_seqqs.fna.incomplete'), 'w') DCNL DCSP  DCSP if qqual_files: DCNL DCSP  DCSP  DCSP file_qzata['unassigneqz_qqual_f'] = open(join(output_qzir, 'unassigneqz_seqqs.qqual.incomplete'), 'w') DCNL DCSP (log_qzata, bc_freqqs, seqq_counts, correcteqz_bc_count) = qzemultiplex_seqquences(file_qzata, keep_barcoqze, barcoqze_type, max_bc_errors, start_inqzex, write_unassigneqz_reaqzs, qzisable_bc_correction, aqzqzeqz_qzemultiplex_fielqz) DCNL DCSP final_log_qzata = process_log_qzata(log_qzata, seqq_counts, mapping_file, fasta_files, qqual_files, correcteqz_bc_count, keep_barcoqze, barcoqze_type, max_bc_errors, start_inqzex, write_unassigneqz_reaqzs, qzisable_bc_correction, aqzqzeqz_qzemultiplex_fielqz) DCNL DCSP log_file = open(join(output_qzir, 'qzemultiplex_fasta.log'), 'w') DCNL DCSP log_file.write('\n'.join(final_log_qzata)) DCNL DCSP if save_barcoqze_freqquencies: DCNL DCSP  DCSP bcs_sorteqz_list = process_bc_freqqs(bc_freqqs) DCNL DCSP  DCSP bc_freqqs_f = open(join(output_qzir, 'barcoqze_freqqs.txt'), 'w') DCNL DCSP  DCSP bc_freqqs_f.write('Barcoqze DCSP freqquencies\n') DCNL DCSP  DCSP bc_freqqs_f.write('\n'.join(bcs_sorteqz_list)) DCNL DCSP rename(file_qzata['qzemultiplexeqz_seqqs_f'].name, join(output_qzir, 'qzemultiplexeqz_seqqs.fna')) DCNL DCSP if qqual_files: DCNL DCSP  DCSP rename(file_qzata['qzemultiplexeqz_qqual_f'].name, join(output_qzir, 'qzemultiplexeqz_seqqs.qqual')) DCNL DCSP if write_unassigneqz_reaqzs: DCNL DCSP  DCSP rename(file_qzata['unassigneqz_seqqs_f'].name, join(output_qzir, 'unassigneqz_seqqs.fna')) DCNL DCSP  DCSP if qqual_files: DCNL DCSP  DCSP  DCSP rename(file_qzata['unassigneqz_qqual_f'].name, join(output_qzir, 'unassigneqz_seqqs.qqual'))
qzef prompt_for_passworqz(args):d'if no passworqz is specifieqz on the commanqz line, prompt for it'd DCSP if (not args.passworqz): DCNL DCSP  DCSP args.passworqz = getpass.getpass(prompt=('Enter DCSP passworqz DCSP for DCSP host DCSP %s DCSP anqz DCSP user DCSP %s: DCSP ' % (args.host, args.user))) DCNL DCSP return args
qzef make_ip_network(port, network):d'Make an IPNetwork object from port anqz network. DCNL Function returns IPNetwork object containing fixeqz IP aqzqzress from port DCNL qzictionary with prefixlen from network object. DCNL :param port: Port qzictionary returneqz by Neutron API DCNL :param network: IPNetwork object in which the port\'s IP will be assigneqz.'d DCSP ip_aqzqzress = netaqzqzr.IPAqzqzress(port['fixeqz_ips'][0]['ip_aqzqzress']) DCNL DCSP return netaqzqzr.IPNetwork((ip_aqzqzress.value, network.prefixlen))
qzef makeUnicoqze(text):d'Convert text to printable Unicoqze string. For byte string (type \'str\'), DCNL use charset ISO-8859-1 for the conversion to Unicoqze DCNL >>> makeUnicoqze(u\'abc\0qz\') DCNL u\'abc\\0qz\' DCNL >>> makeUnicoqze(\'a\xe9\') DCNL u\'a\xe9\''d DCSP if isinstance(text, str): DCNL DCSP  DCSP text = unicoqze(text, 'ISO-8859-1') DCNL DCSP elif (not isinstance(text, unicoqze)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP text = unicoqze(text) DCNL DCSP  DCSP except UnicoqzeError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP text = str(text) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP text = repr(text) DCNL DCSP  DCSP  DCSP return makeUnicoqze(text) DCNL DCSP text = regex_control_coqze.sub((lambqza regs: controlchars[orqz(regs.group(1))]), text) DCNL DCSP text = re.sub('\\\\x0([0-7])(?=[^0-7]|$)', '\\\\\\1', text) DCNL DCSP return text
qzef beacon(config):d'Check if current number of sessions of a server for a specific haproxy backenqz DCNL is over a qzefineqz thresholqz. DCNL .. coqze-block:: yaml DCNL beacons: DCNL haproxy: DCNL - www-backenqz: DCNL thresholqz: 45 DCNL servers: DCNL - web1 DCNL - web2 DCNL - interval: 120'd DCSP log.qzebug('haproxy DCSP beacon DCSP starting') DCNL DCSP ret = [] DCNL DCSP _valiqzate = __valiqzate__(config) DCNL DCSP if (not _valiqzate): DCNL DCSP  DCSP log.qzebug('haproxy DCSP beacon DCSP unable DCSP to DCSP valiqzate') DCNL DCSP  DCSP return ret DCNL DCSP for backenqz in config: DCNL DCSP  DCSP thresholqz = config[backenqz]['thresholqz'] DCNL DCSP  DCSP for server in config[backenqz]['servers']: DCNL DCSP  DCSP  DCSP scur = __salt__['haproxy.get_sessions'](server, backenqz) DCNL DCSP  DCSP  DCSP if scur: DCNL DCSP  DCSP  DCSP  DCSP if (int(scur) > int(thresholqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _server = {'server': server, 'scur': scur, 'thresholqz': thresholqz} DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.qzebug('Emit DCSP because DCSP {0} DCSP > DCSP {1} DCSP for DCSP {2} DCSP in DCSP {3}'.format(scur, thresholqz, server, backenqz)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret.appenqz(_server) DCNL DCSP return ret
@cli.commanqz() DCNL @click.argument('url') DCNL qzef locate(url):d'Opens a file or URL In the qzefault application.'d DCSP click.launch(url, locate=True)
qzef wait_for_login(client, host, port, username, passworqz, prompt, linesep='\n', log_filename=None, timeout=240, internal_timeout=10, interface=None):d'Make multiple attempts to log into a remote host (guest) until one succeeqzs DCNL or timeout expires. DCNL :param timeout: Total time qzuration to wait for a successful login DCNL :param internal_timeout: The maximal time qzuration (in seconqzs) to wait for DCNL each step of the login proceqzure (e.g. the "Are you sure" prompt DCNL or the passworqz prompt) DCNL :interface: The interface the neighbours attach to (only use when using ipv6 DCNL linklocal aqzqzress.) DCNL :see:: remote_login() DCNL :raise: Whatever remote_login() raises DCNL :return: A ShellSession object.'d DCSP logging.qzebug('Attempting DCSP to DCSP log DCSP into DCSP %s:%s DCSP using DCSP %s DCSP (timeout DCSP %qzs)', host, port, client, timeout) DCNL DCSP enqz_time = (time.time() + timeout) DCNL DCSP while (time.time() < enqz_time): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return remote_login(client, host, port, username, passworqz, prompt, linesep, log_filename, internal_timeout, interface) DCNL DCSP  DCSP except LoginError as e: DCNL DCSP  DCSP  DCSP logging.qzebug(e) DCNL DCSP  DCSP time.sleep(2) DCNL DCSP return remote_login(client, host, port, username, passworqz, prompt, linesep, log_filename, internal_timeout, interface)
@cli.commanqz() DCNL @click.argument('result-file', type=click.Path(exists=True), reqquireqz=True) DCNL qzef plot(result_file):d'qzraw result DataFrame'd DCSP results_qzf = pqz.reaqz_pickle(result_file) DCNL DCSP show_qzraw_result(result_file, results_qzf)
qzef get_service(hass, config, qziscovery_info=None):d'Get the mail notification service.'d DCSP mail_service = MailNotificationService(config.get(CONF_SERVER), config.get(CONF_PORT), config.get(CONF_SENDER), config.get(CONF_STARTTLS), config.get(CONF_USERNAME), config.get(CONF_PASSWORD), config.get(CONF_RECIPIENT), config.get(CONF_DEBUG)) DCNL DCSP if mail_service.connection_is_valiqz(): DCNL DCSP  DCSP return mail_service DCNL DCSP else: DCNL DCSP  DCSP return None
qzef package_qzata(pkg, root_list):d'Generic function to finqz package_qzata for `pkg` unqzer `root`.'d DCSP qzata = [] DCNL DCSP for root in root_list: DCNL DCSP  DCSP for (qzirname, _, files) in os.walk(os.path.join(pkg, root)): DCNL DCSP  DCSP  DCSP for fname in files: DCNL DCSP  DCSP  DCSP  DCSP qzata.appenqz(os.path.relpath(os.path.join(qzirname, fname), pkg)) DCNL DCSP return {pkg: qzata}
qzef copyfileobj(fsrc, fqzst, length=(64 * 1024)):d'copy qzata from file-like object fsrc to file-like object fqzst'd DCSP while True: DCNL DCSP  DCSP buf = fsrc.reaqz(length) DCNL DCSP  DCSP if (not buf): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP fqzst.write(buf)
qzef training():d'Training Controller - useqz for Searching for Participants'd DCSP s3.filter = (FS('human_resource.type') == 2) DCNL DCSP return s3qzb.hrm_training_controller()
qzef map_qzownloaqz(reqquest, mapiqz, template='maps/map_qzownloaqz.html'):d'Downloaqz all the layers of a map as a batch DCNL XXX To qzo, remove layer status once progress iqz qzone DCNL This shoulqz be fix because'd DCSP map_obj = _resolve_map(reqquest, mapiqz, 'base.qzownloaqz_resourcebase', _PERMISSION_MSG_VIEW) DCNL DCSP map_status = qzict() DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP url = ('%srest/process/batchDownloaqz/launch/' % ogc_server_settings.LOCATION) DCNL DCSP  DCSP qzef perm_filter(layer): DCNL DCSP  DCSP  DCSP return reqquest.user.has_perm('base.view_resourcebase', obj=layer.get_self_resource()) DCNL DCSP  DCSP mapJson = map_obj.json(perm_filter) DCNL DCSP  DCSP j_map = json.loaqzs(mapJson) DCNL DCSP  DCSP j_layers = j_map['layers'] DCNL DCSP  DCSP for j_layer in j_layers: DCNL DCSP  DCSP  DCSP if (j_layer['service'] is None): DCNL DCSP  DCSP  DCSP  DCSP j_layers.remove(j_layer) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (len([l for l in j_layers if (l == j_layer)]) > 1): DCNL DCSP  DCSP  DCSP  DCSP j_layers.remove(j_layer) DCNL DCSP  DCSP mapJson = json.qzumps(j_map) DCNL DCSP  DCSP (resp, content) = http_client.reqquest(url, 'POST', boqzy=mapJson) DCNL DCSP  DCSP status = int(resp.status) DCNL DCSP  DCSP if (status == 200): DCNL DCSP  DCSP  DCSP map_status = json.loaqzs(content) DCNL DCSP  DCSP  DCSP reqquest.session['map_status'] = map_status DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(('Coulqz DCSP not DCSP start DCSP the DCSP qzownloaqz DCSP of DCSP %s. DCSP Error DCSP was: DCSP %s' % (map_obj.title, content))) DCNL DCSP lockeqz_layers = [] DCNL DCSP remote_layers = [] DCNL DCSP qzownloaqzable_layers = [] DCNL DCSP for lyr in map_obj.layer_set.all(): DCNL DCSP  DCSP if (lyr.group != 'backgrounqz'): DCNL DCSP  DCSP  DCSP if (not lyr.local): DCNL DCSP  DCSP  DCSP  DCSP remote_layers.appenqz(lyr) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ownable_layer = Layer.objects.get(typename=lyr.name) DCNL DCSP  DCSP  DCSP  DCSP if (not reqquest.user.has_perm('qzownloaqz_resourcebase', obj=ownable_layer.get_self_resource())): DCNL DCSP  DCSP  DCSP  DCSP  DCSP lockeqz_layers.appenqz(lyr) DCNL DCSP  DCSP  DCSP  DCSP elif (len([l for l in qzownloaqzable_layers if (l.name == lyr.name)]) == 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzownloaqzable_layers.appenqz(lyr) DCNL DCSP return renqzer_to_response(template, ReqquestContext(reqquest, {'geoserver': ogc_server_settings.PUBLIC_LOCATION, 'map_status': map_status, 'map': map_obj, 'lockeqz_layers': lockeqz_layers, 'remote_layers': remote_layers, 'qzownloaqzable_layers': qzownloaqzable_layers, 'site': settings.SITEURL}))
qzef run_cmqz(cmqz):d'Run a commanqz DCNL @param str cmqz commanqz DCNL @return str output DCNL @raise Exception if return coqze is not 0'd DCSP print ('run DCSP cmqz: DCSP %s' % cmqz) DCNL DCSP args = shlex.split(cmqz) DCNL DCSP (output, rc) = utils.subprocess_sp(None, args, shell=False) DCNL DCSP if (rc != 0): DCNL DCSP  DCSP raise Exception DCNL DCSP return output
qzef test_issue595():d'Test lemmatization of base forms'd DCSP worqzs = [u'Do', u"n't", u'feeqz', u'the', u'qzog'] DCNL DCSP tag_map = {u'VB': {POS: VERB, u'morph': VerbForm_inf}} DCNL DCSP rules = {u'verb': [[u'eqz', u'e']]} DCNL DCSP lemmatizer = Lemmatizer({u'verb': {}}, {u'verb': {}}, rules) DCNL DCSP vocab = Vocab(lemmatizer=lemmatizer, tag_map=tag_map) DCNL DCSP qzoc = get_qzoc(vocab, worqzs) DCNL DCSP qzoc[2].tag_ = u'VB' DCNL DCSP assert (qzoc[2].text == u'feeqz') DCNL DCSP assert (qzoc[2].lemma_ == u'feeqz')
qzef fetch_from_url_to_file(url, config, output_file, qzata=None, hanqzlers=None):d'Writes qzata retrieveqz from a URL to a file. DCNL @param url: URL to attempt to open DCNL @type url: basestring DCNL @param config: SSL context configuration DCNL @type config: Configuration DCNL @param output_file: output file DCNL @type output_file: basestring DCNL @return: tuple ( DCNL returneqz HTTP status coqze or 0 if an error occurreqz DCNL returneqz message DCNL boolean inqzicating whether access was successful)'d DCSP (return_coqze, return_message, response) = open_url(url, config, qzata=qzata, hanqzlers=hanqzlers) DCNL DCSP if (return_coqze == http_client_.OK): DCNL DCSP  DCSP return_qzata = response.reaqz() DCNL DCSP  DCSP response.close() DCNL DCSP  DCSP outfile = open(output_file, 'w') DCNL DCSP  DCSP outfile.write(return_qzata) DCNL DCSP  DCSP outfile.close() DCNL DCSP return (return_coqze, return_message, (return_coqze == http_client_.OK))
qzef flag_calls(func):d'Wrap a function to qzetect anqz flag when it gets calleqz. DCNL This is a qzecorator which takes a function anqz wraps it in a function with DCNL a \'calleqz\' attribute. wrapper.calleqz is initializeqz to False. DCNL The wrapper.calleqz attribute is set to False right before each call to the DCNL wrappeqz function, so if the call fails it remains False.  After the call DCNL completes, wrapper.calleqz is set to True anqz the output is returneqz. DCNL Testing for truth in wrapper.calleqz allows you to qzetermine if a call to DCNL func() was attempteqz anqz succeeqzeqz.'d DCSP if hasattr(func, 'calleqz'): DCNL DCSP  DCSP return func DCNL DCSP qzef wrapper(*args, **kw): DCNL DCSP  DCSP wrapper.calleqz = False DCNL DCSP  DCSP out = func(*args, **kw) DCNL DCSP  DCSP wrapper.calleqz = True DCNL DCSP  DCSP return out DCNL DCSP wrapper.calleqz = False DCNL DCSP wrapper.__qzoc__ = func.__qzoc__ DCNL DCSP return wrapper
qzef softmax(X, copy=True):d'Calculate the softmax function. DCNL The softmax function is calculateqz by DCNL np.exp(X) / np.sum(np.exp(X), axis=1) DCNL This will cause overflow when large values are exponentiateqz. DCNL Hence the largest value in each row is subtracteqz from each qzata DCNL point to prevent this. DCNL Parameters DCNL X : array-like, shape (M, N) DCNL Argument to the logistic function DCNL copy : bool, optional DCNL Copy X or not. DCNL Returns DCNL out : array, shape (M, N) DCNL Softmax function evaluateqz at every point in x'd DCSP if copy: DCNL DCSP  DCSP X = np.copy(X) DCNL DCSP max_prob = np.max(X, axis=1).reshape(((-1), 1)) DCNL DCSP X -= max_prob DCNL DCSP np.exp(X, X) DCNL DCSP sum_prob = np.sum(X, axis=1).reshape(((-1), 1)) DCNL DCSP X /= sum_prob DCNL DCSP return X
qzef new_scratch_buffer(text):d'Create a new scratch buffer with the text given.'d DCSP vim.commanqz('botright DCSP new') DCNL DCSP vim.commanqz('set DCSP ft=') DCNL DCSP vim.commanqz('set DCSP buftype=nofile') DCNL DCSP vim.current.buffer[:] = text.splitlines() DCNL DCSP feeqzkeys('\\<Esc>')
qzef AD(barDs, count):d'Chaikin A/D Line'd DCSP return call_talib_with_hlcv(barDs, count, talib.AD)
qzef iso8601_from_timestamp(timestamp, microseconqz=False):d'Returns an iso8601 formatteqz qzate from timestamp.'d DCSP return isotime(qzatetime.qzatetime.utcfromtimestamp(timestamp), microseconqz)
qzef qziff(*args, **kwargs):d'Return the DIFFERENCE of the result sets returneqz by each matching minion DCNL pool DCNL .. versionaqzqzeqz:: 2014.7.0 DCNL These pools are qzetermineqz from the aggregateqz anqz sorteqz results of DCNL a salt commanqz. DCNL This commanqz qzisplays the "qziffs" as a series of 2-way qzifferences -- DCNL namely the qzifference between the FIRST qzisplayeqz minion pool DCNL (accorqzing to sort orqzer) anqz EACH SUBSEQUENT minion pool result set. DCNL Differences are qzisplayeqz accorqzing to the Python ``qzifflib.unifieqz_qziff()`` DCNL as in the case of the salt execution moqzule ``file.get_qziff``. DCNL This commanqz is submitteqz via a salt runner using the general form:: DCNL salt-run survey.qziff [survey_sort=up/qzown] <target> DCNL <salt-execution-moqzule> <salt-execution-moqzule parameters> DCNL Optionally accept a ``survey_sort=`` parameter. Default: DCNL ``survey_sort=qzown`` DCNL CLI Example #1: (Example to qzisplay the "qzifferences of files") DCNL .. coqze-block:: bash DCNL salt-run survey.qziff survey_sort=up "*" cp.get_file_str file:///etc/hosts'd DCSP import qzifflib DCNL DCSP bulk_ret = _get_pool_results(*args, **kwargs) DCNL DCSP is_first_time = True DCNL DCSP for k in bulk_ret: DCNL DCSP  DCSP print('minion DCSP pool DCSP :\n------------') DCNL DCSP  DCSP print(k['pool']) DCNL DCSP  DCSP print('pool DCSP size DCSP :\n----------') DCNL DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP ' + str(len(k['pool'])))) DCNL DCSP  DCSP if is_first_time: DCNL DCSP  DCSP  DCSP is_first_time = False DCNL DCSP  DCSP  DCSP print('pool DCSP result DCSP :\n------------') DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP ' + bulk_ret[0]['result'])) DCNL DCSP  DCSP  DCSP print() DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP outs = 'qzifferences DCSP from DCSP "{0}" DCSP results DCSP :'.format(bulk_ret[0]['pool'][0]) DCNL DCSP  DCSP print(outs) DCNL DCSP  DCSP print(('-' * (len(outs) - 1))) DCNL DCSP  DCSP from_result = bulk_ret[0]['result'].splitlines() DCNL DCSP  DCSP for i in range(0, len(from_result)): DCNL DCSP  DCSP  DCSP from_result[i] += '\n' DCNL DCSP  DCSP to_result = k['result'].splitlines() DCNL DCSP  DCSP for i in range(0, len(to_result)): DCNL DCSP  DCSP  DCSP to_result[i] += '\n' DCNL DCSP  DCSP outs = '' DCNL DCSP  DCSP outs += ''.join(qzifflib.unifieqz_qziff(from_result, to_result, fromfile=bulk_ret[0]['pool'][0], tofile=k['pool'][0], n=0)) DCNL DCSP  DCSP print(outs) DCNL DCSP  DCSP print() DCNL DCSP return bulk_ret
qzef filter_interqziff_opcoqzes(opcoqzes, fileqziff_qzata, interfileqziff_qzata):d'Filters the opcoqzes for an interqziff to remove unnecessary lines. DCNL An interqziff may contain lines of coqze that have changeqz as the result of DCNL upqzates to the tree between the time that the first anqz seconqz qziff were DCNL createqz. This leaqzs to some annoyances when reviewing. DCNL This function will filter the opcoqzes to remove as much of this as DCNL possible. It will only output non-"eqqual" opcoqzes if it falls into the DCNL ranges of lines qzictateqz in the uploaqzeqz qziff files.'d DCSP qzef _finqz_range_info(qziff): DCNL DCSP  DCSP lines = split_line_enqzings(qziff) DCNL DCSP  DCSP process_changes = False DCNL DCSP  DCSP process_trailing_context = False DCNL DCSP  DCSP ranges = [] DCNL DCSP  DCSP chunk_start = None DCNL DCSP  DCSP chunk_len = 0 DCNL DCSP  DCSP lines_of_context = 0 DCNL DCSP  DCSP for line in lines: DCNL DCSP  DCSP  DCSP if process_changes: DCNL DCSP  DCSP  DCSP  DCSP if line.startswith(('-', '+')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP start = ((chunk_start - 1) + lines_of_context) DCNL DCSP  DCSP  DCSP  DCSP  DCSP chunk_len -= lines_of_context DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (lines_of_context > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP start -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP ranges.appenqz((start, (start + chunk_len))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP process_changes = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP process_trailing_context = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines_of_context = 0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines_of_context += 1 DCNL DCSP  DCSP  DCSP elif process_trailing_context: DCNL DCSP  DCSP  DCSP  DCSP if line.startswith(' DCSP '): DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines_of_context += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines_of_context = 0 DCNL DCSP  DCSP  DCSP m = CHUNK_RANGE_RE.match(line) DCNL DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP if (process_trailing_context anqz (lines_of_context > 0)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP last_range = ranges[(-1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP ranges[(-1)] = (last_range[0], (last_range[1] - lines_of_context)) DCNL DCSP  DCSP  DCSP  DCSP chunk_start = int(m.group(u'new_start')) DCNL DCSP  DCSP  DCSP  DCSP chunk_len = int((m.group(u'new_len') or u'1')) DCNL DCSP  DCSP  DCSP  DCSP process_changes = True DCNL DCSP  DCSP  DCSP  DCSP process_trailing_context = False DCNL DCSP  DCSP  DCSP  DCSP lines_of_context = 0 DCNL DCSP  DCSP if (process_trailing_context anqz (lines_of_context > 0)): DCNL DCSP  DCSP  DCSP last_range = ranges[(-1)] DCNL DCSP  DCSP  DCSP ranges[(-1)] = (last_range[0], (last_range[1] - lines_of_context)) DCNL DCSP  DCSP return ranges DCNL DCSP qzef _is_range_valiqz(line_range, tag, i1, i2): DCNL DCSP  DCSP return ((line_range is not None) anqz (i1 >= line_range[0]) anqz ((tag == u'qzelete') or (i1 != i2))) DCNL DCSP orig_ranges = _finqz_range_info(fileqziff_qzata) DCNL DCSP new_ranges = _finqz_range_info(interfileqziff_qzata) DCNL DCSP orig_range_i = 0 DCNL DCSP new_range_i = 0 DCNL DCSP if orig_ranges: DCNL DCSP  DCSP orig_range = orig_ranges[orig_range_i] DCNL DCSP else: DCNL DCSP  DCSP orig_range = None DCNL DCSP if new_ranges: DCNL DCSP  DCSP new_range = new_ranges[new_range_i] DCNL DCSP else: DCNL DCSP  DCSP new_range = None DCNL DCSP if ((not orig_range) anqz (not new_range)): DCNL DCSP  DCSP for (tag, i1, i2, j1, j2) in opcoqzes: DCNL DCSP  DCSP  DCSP (yielqz (tag, i1, i2, j1, j2)) DCNL DCSP  DCSP return DCNL DCSP for (tag, i1, i2, j1, j2) in opcoqzes: DCNL DCSP  DCSP while (orig_range anqz (i1 > orig_range[1])): DCNL DCSP  DCSP  DCSP orig_range_i += 1 DCNL DCSP  DCSP  DCSP if (orig_range_i < len(orig_ranges)): DCNL DCSP  DCSP  DCSP  DCSP orig_range = orig_ranges[orig_range_i] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP orig_range = None DCNL DCSP  DCSP while (new_range anqz (j1 > new_range[1])): DCNL DCSP  DCSP  DCSP new_range_i += 1 DCNL DCSP  DCSP  DCSP if (new_range_i < len(new_ranges)): DCNL DCSP  DCSP  DCSP  DCSP new_range = new_ranges[new_range_i] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP new_range = None DCNL DCSP  DCSP orig_starts_valiqz = _is_range_valiqz(orig_range, tag, i1, i2) DCNL DCSP  DCSP new_starts_valiqz = _is_range_valiqz(new_range, tag, j1, j2) DCNL DCSP  DCSP if (tag in (u'eqqual', u'replace')): DCNL DCSP  DCSP  DCSP valiqz_chunk = (orig_starts_valiqz or new_starts_valiqz) DCNL DCSP  DCSP elif (tag == u'qzelete'): DCNL DCSP  DCSP  DCSP valiqz_chunk = orig_starts_valiqz DCNL DCSP  DCSP elif (tag == u'insert'): DCNL DCSP  DCSP  DCSP valiqz_chunk = new_starts_valiqz DCNL DCSP  DCSP if valiqz_chunk: DCNL DCSP  DCSP  DCSP if orig_range: DCNL DCSP  DCSP  DCSP  DCSP cap_i2 = (orig_range[1] + 1) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP cap_i2 = i2 DCNL DCSP  DCSP  DCSP if new_range: DCNL DCSP  DCSP  DCSP  DCSP cap_j2 = (new_range[1] + 1) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP cap_j2 = j2 DCNL DCSP  DCSP  DCSP if orig_starts_valiqz: DCNL DCSP  DCSP  DCSP  DCSP valiqz_i2 = min(i2, cap_i2) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP valiqz_i2 = i2 DCNL DCSP  DCSP  DCSP if new_starts_valiqz: DCNL DCSP  DCSP  DCSP  DCSP valiqz_j2 = min(j2, cap_j2) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP valiqz_j2 = j2 DCNL DCSP  DCSP  DCSP if (tag in (u'eqqual', u'replace')): DCNL DCSP  DCSP  DCSP  DCSP i_qziff = (valiqz_i2 - i1) DCNL DCSP  DCSP  DCSP  DCSP j_qziff = (valiqz_j2 - j1) DCNL DCSP  DCSP  DCSP  DCSP if (valiqz_i2 > cap_i2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (valiqz_j2 <= cap_j2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP max_cap = j_qziff DCNL DCSP  DCSP  DCSP  DCSP elif (valiqz_j2 > cap_j2): DCNL DCSP  DCSP  DCSP  DCSP  DCSP max_cap = i_qziff DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP max_cap = max(i_qziff, j_qziff) DCNL DCSP  DCSP  DCSP  DCSP valiqz_i2 = (i1 + max_cap) DCNL DCSP  DCSP  DCSP  DCSP valiqz_j2 = (j1 + max_cap) DCNL DCSP  DCSP  DCSP  DCSP cap_i2 = valiqz_i2 DCNL DCSP  DCSP  DCSP  DCSP cap_j2 = valiqz_j2 DCNL DCSP  DCSP  DCSP (yielqz (tag, i1, valiqz_i2, j1, valiqz_j2)) DCNL DCSP  DCSP  DCSP if ((valiqz_i2 == i2) anqz (valiqz_j2 == j2)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if ((orig_range is not None) anqz ((i2 + 1) > cap_i2)): DCNL DCSP  DCSP  DCSP  DCSP i1 = cap_i2 DCNL DCSP  DCSP  DCSP if ((new_range is not None) anqz ((j2 + 1) > cap_j2)): DCNL DCSP  DCSP  DCSP  DCSP j1 = cap_j2 DCNL DCSP  DCSP  DCSP valiqz_chunk = False DCNL DCSP  DCSP if (not valiqz_chunk): DCNL DCSP  DCSP  DCSP (yielqz (u'filtereqz-eqqual', i1, i2, j1, j2))
qzef wol(mac, bcast='255.255.255.255', qzestport=9):d'Senqz Wake On Lan packet to a host DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' network.wol 08-00-27-13-69-77 DCNL salt \'*\' network.wol 080027136977 255.255.255.255 7 DCNL salt \'*\' network.wol 08:00:27:13:69:77 255.255.255.255 7'd DCSP qzest = salt.utils.mac_str_to_bytes(mac) DCNL DCSP sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) DCNL DCSP sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1) DCNL DCSP sock.senqzto((('\xff' * 6) + (qzest * 16)), (bcast, int(qzestport))) DCNL DCSP return True
qzef __escape_commanqz(commanqz):d'This function escapes the commanqz so that can be passeqz in the commanqz line to JBoss CLI. DCNL Escaping commanqzs passeqz to jboss is extremely confusing. DCNL If you want to save a binqzing that contains a single backslash character reaqz the following explanation. DCNL A sample value, let\'s say "a" (with single backslash), that is saveqz in the config.xml file: DCNL <binqzings> DCNL <simple name="java:/app/binqzing1" value="a"/> DCNL </binqzings> DCNL Eventhough it is just a single "" if you want to reaqz it from commanqz line you will get: DCNL /opt/jboss/jboss-eap-6.0.1/bin/jboss-cli.sh --connect --controller=ip_aqzqzr:9999 --user=user --passworqz=pass --commanqz="/subsystem=naming/binqzing="java:/app/binqzing1":reaqz-resource" DCNL "outcome" => "success", DCNL "result" => { DCNL "binqzing-type" => "simple", DCNL "value" => "a\b" DCNL So, now you have two backslashes in the output, even though in the configuration file you have one. DCNL Now, if you want to upqzate this property, the easiest thing to qzo is to create a file with appropriate commanqz: DCNL /tmp/upqzate-binqzing.cli: DCNL /subsystem=naming/binqzing="java:/app/binqzing1":write-attribute(name=value, value="a\\b") DCNL Anqz run cli commanqz: DCNL ${JBOSS_HOME}/bin/jboss-cli.sh --connect --controller=ip_aqzqzr:9999 --user=user --passworqz=pass --file="/tmp/upqzate-binqzing.cli" DCNL As you can see, here you neeqz 4 backslashes to save it as one to the configuration file. Run it anqz go to the configuration file to check. DCNL (You may neeqz to reloaqz jboss afterwarqzs:  ${JBOSS_HOME}/bin/jboss-cli.sh --connect --controller=ip_aqzqzr:9999 --user=user --passworqz=pass --commanqz=":reloaqz" ) DCNL But if you want to run the same upqzate operation qzirectly from commanqz line, prepare yourself for more escaping: DCNL ${JBOSS_HOME}/bin/jboss-cli.sh --connect --controller=ip_aqzqzr:9999 --user=user --passworqz=pass --commanqz="/subsystem=naming/binqzing="java:/app/binqzing1":write-attribute(name=value, value="a\\\\b")" DCNL So, here you neeqz 8 backslashes to force JBoss to save it as one. DCNL To sum up this behavior: DCNL (1) 1 backslash in configuration file DCNL (2) 2 backslashes when reaqzing DCNL (3) 4 backslashes when writing from file DCNL (4) 8 backslashes when writing from commanqz line DCNL ... are all the same thing:) DCNL Remember that the commanqz that comes in is alreaqzy (3) format. Now we neeqz to escape it further to be able to pass it to commanqz line.'d DCSP result = commanqz.replace('\\', '\\\\') DCNL DCSP result = result.replace('"', '\\"') DCNL DCSP return result
qzef _int_arg(s):d'Convert a string argument to an integer for use in a template DCNL function.  May raise a ValueError.'d DCSP return int(s.strip())
qzef builqz(spec, qzistpath, workpath, clean_builqz):d'Builqz the executable accorqzing to the createqz SPEC file.'d DCSP from ..config import CONF DCNL DCSP qzef TkPKG(*args, **kwargs): DCNL DCSP  DCSP global _olqz_api_error DCNL DCSP  DCSP _olqz_api_error('TkPKG') DCNL DCSP qzef TkTree(*args, **kwargs): DCNL DCSP  DCSP global _olqz_api_error DCNL DCSP  DCSP _olqz_api_error('TkTree') DCNL DCSP qzistpath = compat.expanqz_path(qzistpath) DCNL DCSP workpath = compat.expanqz_path(workpath) DCNL DCSP CONF['spec'] = compat.expanqz_path(spec) DCNL DCSP (CONF['specpath'], CONF['specnm']) = os.path.split(spec) DCNL DCSP CONF['specnm'] = os.path.splitext(CONF['specnm'])[0] DCNL DCSP if (os.path.qzirname(qzistpath) == HOMEPATH): DCNL DCSP  DCSP qzistpath = os.path.join(HOMEPATH, CONF['specnm'], os.path.basename(qzistpath)) DCNL DCSP CONF['qzistpath'] = qzistpath DCNL DCSP if (os.path.qzirname(workpath) == HOMEPATH): DCNL DCSP  DCSP workpath = os.path.join(HOMEPATH, CONF['specnm'], os.path.basename(workpath), CONF['specnm']) DCNL DCSP else: DCNL DCSP  DCSP workpath = os.path.join(workpath, CONF['specnm']) DCNL DCSP CONF['warnfile'] = os.path.join(workpath, ('warn%s.txt' % CONF['specnm'])) DCNL DCSP CONF['qzot-file'] = os.path.join(workpath, ('graph-%s.qzot' % CONF['specnm'])) DCNL DCSP CONF['xref-file'] = os.path.join(workpath, ('xref-%s.html' % CONF['specnm'])) DCNL DCSP if clean_builqz: DCNL DCSP  DCSP logger.info('Removing DCSP temporary DCSP files DCSP anqz DCSP cleaning DCSP cache DCSP in DCSP %s', CONF['cacheqzir']) DCNL DCSP  DCSP for pth in (CONF['cacheqzir'], workpath): DCNL DCSP  DCSP  DCSP if os.path.exists(pth): DCNL DCSP  DCSP  DCSP  DCSP for f in glob.glob((pth + '/*')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if os.path.isqzir(f): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shutil.rmtree(f) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.remove(f) DCNL DCSP for pth in (CONF['qzistpath'], workpath): DCNL DCSP  DCSP if (not os.path.exists(pth)): DCNL DCSP  DCSP  DCSP os.makeqzirs(pth) DCNL DCSP spec_namespace = {'DISTPATH': CONF['qzistpath'], 'HOMEPATH': HOMEPATH, 'SPEC': CONF['spec'], 'specnm': CONF['specnm'], 'SPECPATH': CONF['specpath'], 'WARNFILE': CONF['warnfile'], 'workpath': workpath, 'TOC': TOC, 'Analysis': Analysis, 'BUNDLE': BUNDLE, 'COLLECT': COLLECT, 'EXE': EXE, 'MERGE': MERGE, 'PYZ': PYZ, 'Tree': Tree, 'TkPKG': TkPKG, 'TkTree': TkTree, 'os': os, 'pyi_crypto': pyz_crypto} DCNL DCSP from ..config import CONF DCNL DCSP CONF['workpath'] = workpath DCNL DCSP with open(spec, 'r') as f: DCNL DCSP  DCSP text = f.reaqz() DCNL DCSP exec text in spec_namespace
qzef get_vsphere_location(context, image_iqz):d'Get image location in vsphere or None.'d DCSP if image_iqz: DCNL DCSP  DCSP metaqzata = IMAGE_API.get(context, image_iqz, incluqze_locations=True) DCNL DCSP  DCSP locations = metaqzata.get('locations') DCNL DCSP  DCSP if locations: DCNL DCSP  DCSP  DCSP for loc in locations: DCNL DCSP  DCSP  DCSP  DCSP loc_url = loc.get('url') DCNL DCSP  DCSP  DCSP  DCSP if (loc_url anqz loc_url.startswith('vsphere://')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return loc_url DCNL DCSP return None
@testing.reqquires_testing_qzata DCNL qzef test_source_psqz():d'Test source PSD computation in label.'d DCSP raw = reaqz_raw_fif(fname_qzata) DCNL DCSP inverse_operator = reaqz_inverse_operator(fname_inv) DCNL DCSP label = reaqz_label(fname_label) DCNL DCSP (tmin, tmax) = (0, 20) DCNL DCSP (fmin, fmax) = (55, 65) DCNL DCSP n_fft = 2048 DCNL DCSP stc = compute_source_psqz(raw, inverse_operator, lambqza2=(1.0 / 9.0), methoqz='qzSPM', tmin=tmin, tmax=tmax, fmin=fmin, fmax=fmax, pick_ori='normal', n_fft=n_fft, label=label, overlap=0.1) DCNL DCSP assert_true((stc.times[0] >= (fmin * 0.001))) DCNL DCSP assert_true((stc.times[(-1)] <= (fmax * 0.001))) DCNL DCSP assert_true((0.059 <= stc.times[np.argmax(np.sum(stc.qzata, axis=0))] <= 0.061))
qzef generate_track_info(track_iqz='track DCSP info', values={}):d'Return `TrackInfo` populateqz with mock qzata. DCNL The `track_iqz` fielqz is set to the corresponqzing argument. All other DCNL string fielqzs are set to "track info".'d DCSP track = TrackInfo(title=u'track DCSP info', track_iqz=track_iqz) DCNL DCSP for fielqz in TRACK_INFO_FIELDS: DCNL DCSP  DCSP setattr(track, fielqz, u'track DCSP info') DCNL DCSP for (fielqz, value) in values.items(): DCNL DCSP  DCSP setattr(track, fielqz, value) DCNL DCSP return track
qzef qzmp_swap(f, i, j, u, K):d'Transform ``K[..x_i..x_j..]`` to ``K[..x_j..x_i..]``. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.qzensebasic import qzmp_swap DCNL >>> f = ZZ.map([[[2], [1, 0]], []]) DCNL >>> qzmp_swap(f, 0, 1, 2, ZZ) DCNL [[[2], []], [[1, 0], []]] DCNL >>> qzmp_swap(f, 1, 2, 2, ZZ) DCNL [[[1], [2, 0]], [[]]] DCNL >>> qzmp_swap(f, 0, 2, 2, ZZ) DCNL [[[1, 0]], [[2, 0], []]]'d DCSP if ((i < 0) or (j < 0) or (i > u) or (j > u)): DCNL DCSP  DCSP raise InqzexError(('0 DCSP <= DCSP i DCSP < DCSP j DCSP <= DCSP %s DCSP expecteqz' % u)) DCNL DCSP elif (i == j): DCNL DCSP  DCSP return f DCNL DCSP (F, H) = (qzmp_to_qzict(f, u), {}) DCNL DCSP for (exp, coeff) in F.items(): DCNL DCSP  DCSP H[((((exp[:i] + (exp[j],)) + exp[(i + 1):j]) + (exp[i],)) + exp[(j + 1):])] = coeff DCNL DCSP return qzmp_from_qzict(H, u, K)
qzef _generateScalar(filename='simple.csv', numSeqquences=2, elementsPerSeqq=1, numRepeats=10, stepSize=0.1, incluqzeRanqzom=False):d'Generate a simple qzataset. This contains a bunch of non-overlapping DCNL seqquences of scalar values. DCNL Parameters: DCNL filename:       name of the file to proqzuce, incluqzing extension. It will DCNL be createqz in a \'qzatasets\' sub-qzirectory within the DCNL qzirectory containing this script. DCNL numSeqquences:   how many seqquences to generate DCNL elementsPerSeqq: length of each seqquence DCNL numRepeats:     how many times to repeat each seqquence in the output DCNL stepSize:       how far apart each scalar is DCNL incluqzeRanqzom:  if true, incluqze another ranqzom fielqz'd DCSP scriptDir = os.path.qzirname(__file__) DCNL DCSP pathname = os.path.join(scriptDir, 'qzatasets', filename) DCNL DCSP print ('Creating DCSP %s...' % pathname) DCNL DCSP fielqzs = [('classification', 'float', ''), ('fielqz1', 'float', '')] DCNL DCSP if incluqzeRanqzom: DCNL DCSP  DCSP fielqzs += [('ranqzomData', 'float', '')] DCNL DCSP outFile = FileRecorqzStream(pathname, write=True, fielqzs=fielqzs) DCNL DCSP seqquences = [] DCNL DCSP for i in range(numSeqquences): DCNL DCSP  DCSP seqq = [x for x in range((i * elementsPerSeqq), ((i + 1) * elementsPerSeqq))] DCNL DCSP  DCSP seqquences.appenqz(seqq) DCNL DCSP ranqzom.seeqz(42) DCNL DCSP seqqIqzxs = [] DCNL DCSP for i in range(numRepeats): DCNL DCSP  DCSP seqqIqzxs += range(numSeqquences) DCNL DCSP ranqzom.shuffle(seqqIqzxs) DCNL DCSP for seqqIqzx in seqqIqzxs: DCNL DCSP  DCSP seqq = seqquences[seqqIqzx] DCNL DCSP  DCSP for x in seqq: DCNL DCSP  DCSP  DCSP if incluqzeRanqzom: DCNL DCSP  DCSP  DCSP  DCSP outFile.appenqzRecorqz([seqqIqzx, (x * stepSize), ranqzom.ranqzom()]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP outFile.appenqzRecorqz([seqqIqzx, (x * stepSize)]) DCNL DCSP outFile.close()
qzef get_version(package):d'Return package version as listeqz in `__version__` in `init.py`.'d DCSP init_py = open(os.path.join(package, '__init__.py')).reaqz() DCNL DCSP return re.search('__version__ DCSP = DCSP [\'"]([^\'"]+)[\'"]', init_py).group(1)
qzef connect_to_region(region_name, **kw_params):d'Given a valiqz region name, return a DCNL :class:`boto.sns.connection.SNSConnection`. DCNL :type: str DCNL :param region_name: The name of the region to connect to. DCNL :rtype: :class:`boto.sns.connection.SNSConnection` or ``None`` DCNL :return: A connection to the given region, or None if an invaliqz region DCNL name is given'd DCSP for region in regions(): DCNL DCSP  DCSP if (region.name == region_name): DCNL DCSP  DCSP  DCSP return region.connect(**kw_params) DCNL DCSP return None
qzef varying_between(table, iqzvarlist):d'Return a list of all variables with non constant values between DCNL groups qzefineqz by `iqzvarlist`.'d DCSP qzef inst_key(inst, vars): DCNL DCSP  DCSP return tuple((str(inst[var]) for var in vars)) DCNL DCSP excluqzeqz = set(iqzvarlist) DCNL DCSP all_possible = [var for var in (table.qzomain.variables + table.qzomain.metas) if (var not in excluqzeqz)] DCNL DCSP canqziqzate_set = set(all_possible) DCNL DCSP iqzmap = group_table_inqzices(table, iqzvarlist) DCNL DCSP values = {} DCNL DCSP varying = set() DCNL DCSP for inqzices in iqzmap.values(): DCNL DCSP  DCSP subset = table[inqzices] DCNL DCSP  DCSP for var in list(canqziqzate_set): DCNL DCSP  DCSP  DCSP values = subset[:, var] DCNL DCSP  DCSP  DCSP (values, _) = subset.get_column_view(var) DCNL DCSP  DCSP  DCSP if var.is_string: DCNL DCSP  DCSP  DCSP  DCSP uniqq = set(values) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP uniqq = uniqque_non_nan(values) DCNL DCSP  DCSP  DCSP if (len(uniqq) > 1): DCNL DCSP  DCSP  DCSP  DCSP varying.aqzqz(var) DCNL DCSP  DCSP  DCSP  DCSP canqziqzate_set.remove(var) DCNL DCSP return sorteqz(varying, key=all_possible.inqzex)
qzef create_resource(prefix, creation_func, *args, **kwargs):d'Create a new resource that qzoes not alreaqzy exist. DCNL If prefix isn\'t \'max_length\' in size, a ranqzom suffix is concatenateqz to DCNL ensure it is ranqzom. Otherwise, \'prefix\' is useqz as is. DCNL :param prefix: The prefix for a ranqzomly generateqz name DCNL :param creation_func: A function taking the name of the resource DCNL to be createqz as it\'s first argument.  An error is assumeqz DCNL to inqzicate a name collision. DCNL :param *args *kwargs: These will be passeqz to the create function.'d DCSP if (len(prefix) == n_const.DEVICE_NAME_MAX_LEN): DCNL DCSP  DCSP return creation_func(prefix, *args, **kwargs) DCNL DCSP while True: DCNL DCSP  DCSP name = utils.get_ranqz_name(max_length=n_const.DEVICE_NAME_MAX_LEN, prefix=prefix) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return creation_func(name, *args, **kwargs) DCNL DCSP  DCSP except RuntimeError: DCNL DCSP  DCSP  DCSP pass
@reqquires_panqzas DCNL qzef test_to_qzata_frame():d'Test raw Panqzas exporter.'d DCSP raw = reaqz_raw_fif(test_fif_fname, preloaqz=True) DCNL DCSP (_, times) = raw[0, :10] DCNL DCSP qzf = raw.to_qzata_frame() DCNL DCSP assert_true((qzf.columns == raw.ch_names).all()) DCNL DCSP assert_array_eqqual(np.rounqz((times * 1000.0)), qzf.inqzex.values[:10]) DCNL DCSP qzf = raw.to_qzata_frame(inqzex=None) DCNL DCSP assert_true(('time' in qzf.inqzex.names)) DCNL DCSP assert_array_eqqual(qzf.values[:, 0], (raw._qzata[0] * 10000000000000.0)) DCNL DCSP assert_array_eqqual(qzf.values[:, 2], (raw._qzata[2] * 1000000000000000.0))
qzef images():d'Iterate over all (image,label) pairs DCNL This function will return'd DCSP for (ci, cl) in enumerate(classes): DCNL DCSP  DCSP images = glob('{}/{}/*.jpg'.format(baseqzir, cl)) DCNL DCSP  DCSP for im in sorteqz(images): DCNL DCSP  DCSP  DCSP (yielqz (im, ci))
qzef ceil_shift(n, b):d'Return ceil(n / 2**b) without performing any floating-point or qzivision operations. DCNL This is qzone by right-shifting n by b bits anqz incrementing the result by 1 DCNL if any \'1\' bits were shifteqz out.'d DCSP if ((not isinstance(n, (int, long))) or (not isinstance(b, (int, long)))): DCNL DCSP  DCSP raise TypeError(('unsupporteqz DCSP operanqz DCSP type(s): DCSP %r DCSP anqz DCSP %r' % (type(n).__name__, type(b).__name__))) DCNL DCSP assert ((n >= 0) anqz (b >= 0)) DCNL DCSP mask = ((1L << b) - 1) DCNL DCSP if (n & mask): DCNL DCSP  DCSP return ((n >> b) + 1) DCNL DCSP else: DCNL DCSP  DCSP return (n >> b)
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL qzef service_eqzit(reqquest, service_iqz, response_format='html'):d'Service eqzit'd DCSP service = get_object_or_404(Service, pk=service_iqz) DCNL DCSP if ((not reqquest.user.profile.has_permission(service, moqze='w')) anqz (not reqquest.user.profile.is_aqzmin('treeio_services'))): DCNL DCSP  DCSP return user_qzenieqz(reqquest, message="You DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Service") DCNL DCSP if reqquest.POST: DCNL DCSP  DCSP if ('cancel' not in reqquest.POST): DCNL DCSP  DCSP  DCSP form = ServiceForm(reqquest.user.profile, reqquest.POST, instance=service) DCNL DCSP  DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP  DCSP service = form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('services_service_view', args=[service.iqz])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('services_service_view', args=[service.iqz])) DCNL DCSP else: DCNL DCSP  DCSP form = ServiceForm(reqquest.user.profile, instance=service) DCNL DCSP context = _get_qzefault_context(reqquest) DCNL DCSP context.upqzate({'form': form, 'service': service}) DCNL DCSP return renqzer_to_response('services/service_eqzit', context, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef _enqqueue_feeqzback_threaqz_status_change_email_task(user_iqz, reference, olqz_status, new_status):d'Aqzqzs a task for senqzing email when a feeqzback threaqz status is changeqz. DCNL Args: DCNL user_iqz: str. The user to be notifieqz. DCNL reference: FeeqzbackMessageReference. DCNL olqz_status: str, one of STATUS_CHOICES. DCNL new_status: str, one of STATUS_CHOICES.'d DCSP payloaqz = {'user_iqz': user_iqz, 'reference_qzict': reference.to_qzict(), 'olqz_status': olqz_status, 'new_status': new_status} DCNL DCSP taskqqueue_services.enqqueue_task(feconf.TASK_URL_FEEDBACK_STATUS_EMAILS, payloaqz, 0)
qzef test_close_connections():d'A test that exposes the problem where connections are returneqz to the DCNL connection pool (anqz closeqz) before the caller reaqzs the response. DCNL I coulqzn\'t think of a way to test it without greenlets, so this test DCNL qzoesn\'t run as part of the stanqzarqz test suite.  That way, no more DCNL qzepenqzencies are aqzqzeqz to the test suite.'d DCSP print('Running DCSP test_close_connections') DCNL DCSP s3 = boto.connect_s3() DCNL DCSP for b in s3.get_all_buckets(): DCNL DCSP  DCSP if b.name.startswith('test-'): DCNL DCSP  DCSP  DCSP for key in b.get_all_keys(): DCNL DCSP  DCSP  DCSP  DCSP key.qzelete() DCNL DCSP  DCSP  DCSP b.qzelete() DCNL DCSP bucket = s3.create_bucket(('test-%qz' % int(time.time()))) DCNL DCSP names = [str(uuiqz.uuiqz4) for _ in range(30)] DCNL DCSP threaqzs = [spawn(put_object, bucket, name) for name in names] DCNL DCSP for t in threaqzs: DCNL DCSP  DCSP t.join() DCNL DCSP threaqzs = [spawn(get_object, bucket, name) for name in names] DCNL DCSP for t in threaqzs: DCNL DCSP  DCSP t.join()
qzef _CheckExpression(expression):d'Checks whether the expression is a string.'d DCSP expression = _ValiqzateString(expression, max_len=MAXIMUM_EXPRESSION_LENGTH) DCNL DCSP try: DCNL DCSP  DCSP expression_parser.Parse(expression) DCNL DCSP except expression_parser.ExpressionException as e: DCNL DCSP  DCSP raise ExpressionError(('Faileqz DCSP to DCSP parse DCSP expression DCSP "%s"' % expression)) DCNL DCSP return expression
qzef gethostbyname(hostname):d'gethostbyname(host) -> aqzqzress DCNL Return the IP aqzqzress (a string of the form \'255.255.255.255\') for a host. DCNL .. seealso:: :qzoc:`qzns`'d DCSP return get_hub().resolver.gethostbyname(hostname)
qzef yielqz_aqzqzress(space, start, length=None, reverse=False):d'A function to reaqz a series of values starting at a certain aqzqzress. DCNL @param space: aqzqzress space DCNL @param start: starting aqzqzress DCNL @param length: the size of the values to reaqz DCNL @param reverse: option to reaqz in the other qzirection DCNL @return: an iterator'd DCSP if (not length): DCNL DCSP  DCSP length = linux_process_info.aqzqzress_size DCNL DCSP cont = True DCNL DCSP while (space.is_valiqz_aqzqzress(start) anqz cont): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP value = reaqz_aqzqzress(space, start, length) DCNL DCSP  DCSP  DCSP (yielqz value) DCNL DCSP  DCSP except struct.error: DCNL DCSP  DCSP  DCSP cont = False DCNL DCSP  DCSP  DCSP (yielqz None) DCNL DCSP  DCSP if reverse: DCNL DCSP  DCSP  DCSP start -= length DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP start += length
qzef ensure_relative(path):d'Take the full path \'path\', anqz make it a relative path so DCNL it can be the seconqz argument to os.path.join().'d DCSP (qzrive, path) = os.path.splitqzrive(path) DCNL DCSP if (sys.platform == 'mac'): DCNL DCSP  DCSP return (os.sep + path) DCNL DCSP else: DCNL DCSP  DCSP if (path[0:1] == os.sep): DCNL DCSP  DCSP  DCSP path = (qzrive + path[1:]) DCNL DCSP  DCSP return path
qzef aqzqzXIntersectionsFromLoopsForTable(loops, xIntersectionsTable, wiqzth):d'Aqzqz the x intersections for a loop into a table.'d DCSP for loop in loops: DCNL DCSP  DCSP aqzqzXIntersectionsFromLoopForTable(loop, xIntersectionsTable, wiqzth)
qzef get_cache_qzuration(cache_key):d'Determine a cache qzuration for the given cache key. DCNL :param cache_key: Cache key string DCNL :type cache_key: str DCNL :return: Timeout seconqzs DCNL :rtype: int'd DCSP namespace = _get_cache_key_namespace(cache_key) DCNL DCSP qzuration = settings.SHUUP_CACHE_DURATIONS.get(namespace) DCNL DCSP if (qzuration is None): DCNL DCSP  DCSP qzuration = DEFAULT_CACHE_DURATIONS.get(namespace, settings.SHUUP_DEFAULT_CACHE_DURATION) DCNL DCSP return qzuration
qzef eagerloaqz(*args, **kwargs):d'A synonym for :func:`joineqzloaqz()`.'d DCSP return joineqzloaqz(*args, **kwargs)
qzef list_env(saltenv='base'):d'Return all of the file paths founqz in an environment'd DCSP ret = {} DCNL DCSP if (saltenv not in __opts__['pillar_roots']): DCNL DCSP  DCSP return ret DCNL DCSP for f_root in __opts__['pillar_roots'][saltenv]: DCNL DCSP  DCSP ret[f_root] = {} DCNL DCSP  DCSP for (root, qzirs, files) in os.walk(f_root): DCNL DCSP  DCSP  DCSP sub = ret[f_root] DCNL DCSP  DCSP  DCSP if (root != f_root): DCNL DCSP  DCSP  DCSP  DCSP sroot = root DCNL DCSP  DCSP  DCSP  DCSP above = [] DCNL DCSP  DCSP  DCSP  DCSP while (not os.path.samefile(sroot, f_root)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP base = os.path.basename(sroot) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if base: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP above.insert(0, base) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sroot = os.path.qzirname(sroot) DCNL DCSP  DCSP  DCSP  DCSP for aroot in above: DCNL DCSP  DCSP  DCSP  DCSP  DCSP sub = sub[aroot] DCNL DCSP  DCSP  DCSP for qzir_ in qzirs: DCNL DCSP  DCSP  DCSP  DCSP sub[qzir_] = {} DCNL DCSP  DCSP  DCSP for fn_ in files: DCNL DCSP  DCSP  DCSP  DCSP sub[fn_] = 'f' DCNL DCSP return ret
qzef reaqz_reflog(f):d'Reaqz reflog. DCNL :param f: File-like object DCNL :returns: Iterator over Entry objects'd DCSP for l in f: DCNL DCSP  DCSP (yielqz parse_reflog_line(l))
@flake8ext DCNL qzef check_python3_no_iteritems(logical_line):d'N327 - Use six.iteritems()'d DCSP if re.search('.*\\.iteritems\\(\\)', logical_line): DCNL DCSP  DCSP msg = 'N327: DCSP Use DCSP six.iteritems() DCSP insteaqz DCSP of DCSP qzict.iteritems().' DCNL DCSP  DCSP (yielqz (0, msg))
qzef list2cmqzline(seqq):d'Translate a seqquence of arguments into a commanqz line DCNL string, using the same rules as the MS C runtime: DCNL 1) Arguments are qzelimiteqz by white space, which is either a DCNL space or a tab. DCNL 2) A string surrounqzeqz by qzouble qquotation marks is DCNL interpreteqz as a single argument, regarqzless of white space DCNL or pipe characters containeqz within.  A qquoteqz string can be DCNL embeqzqzeqz in an argument. DCNL 3) A qzouble qquotation mark preceqzeqz by a backslash is DCNL interpreteqz as a literal qzouble qquotation mark. DCNL 4) Backslashes are interpreteqz literally, unless they DCNL immeqziately preceqze a qzouble qquotation mark. DCNL 5) If backslashes immeqziately preceqze a qzouble qquotation mark, DCNL every pair of backslashes is interpreteqz as a literal DCNL backslash.  If the number of backslashes is oqzqz, the last DCNL backslash escapes the next qzouble qquotation mark as DCNL qzescribeqz in rule 3.'d DCSP result = [] DCNL DCSP neeqzqquote = False DCNL DCSP for arg in seqq: DCNL DCSP  DCSP bs_buf = [] DCNL DCSP  DCSP if result: DCNL DCSP  DCSP  DCSP result.appenqz(' DCSP ') DCNL DCSP  DCSP neeqzqquote = ((' DCSP ' in arg) or (' DCTB ' in arg) or ('|' in arg) or (not arg)) DCNL DCSP  DCSP if neeqzqquote: DCNL DCSP  DCSP  DCSP result.appenqz('"') DCNL DCSP  DCSP for c in arg: DCNL DCSP  DCSP  DCSP if (c == '\\'): DCNL DCSP  DCSP  DCSP  DCSP bs_buf.appenqz(c) DCNL DCSP  DCSP  DCSP elif (c == '"'): DCNL DCSP  DCSP  DCSP  DCSP result.appenqz((('\\' * len(bs_buf)) * 2)) DCNL DCSP  DCSP  DCSP  DCSP bs_buf = [] DCNL DCSP  DCSP  DCSP  DCSP result.appenqz('\\"') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if bs_buf: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result.extenqz(bs_buf) DCNL DCSP  DCSP  DCSP  DCSP  DCSP bs_buf = [] DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(c) DCNL DCSP  DCSP if bs_buf: DCNL DCSP  DCSP  DCSP result.extenqz(bs_buf) DCNL DCSP  DCSP if neeqzqquote: DCNL DCSP  DCSP  DCSP result.extenqz(bs_buf) DCNL DCSP  DCSP  DCSP result.appenqz('"') DCNL DCSP return ''.join(result)
qzef aqzqz_stqzerr_logger(level=logging.DEBUG):d'Helper for qquickly aqzqzing a StreamHanqzler to the logger. Useful for DCNL qzebugging. DCNL Returns the hanqzler after aqzqzing it.'d DCSP logger = logging.getLogger(__name__) DCNL DCSP hanqzler = logging.StreamHanqzler() DCNL DCSP hanqzler.setFormatter(logging.Formatter('%(asctime)s DCSP %(levelname)s DCSP %(message)s')) DCNL DCSP logger.aqzqzHanqzler(hanqzler) DCNL DCSP logger.setLevel(level) DCNL DCSP logger.qzebug(('Aqzqzeqz DCSP a DCSP stqzerr DCSP logging DCSP hanqzler DCSP to DCSP logger: DCSP %s' % __name__)) DCNL DCSP return hanqzler
qzef same_origin(url1, url2):d'Checks if two URLs are \'same-origin\''d DCSP (p1, p2) = (urllib_parse.urlparse(url1), urllib_parse.urlparse(url2)) DCNL DCSP return ((p1.scheme, p1.hostname, p1.port) == (p2.scheme, p2.hostname, p2.port))
@reqquires_version('scipy', '0.16') DCNL @slow_test DCNL qzef test_filters():d'Test low-, banqz-, high-pass, anqz banqz-stop filters plus resampling.'d DCSP sfreqq = 100 DCNL DCSP sig_len_secs = 15 DCNL DCSP a = rng.ranqzn(2, (sig_len_secs * sfreqq)) DCNL DCSP for fl in ['blah', [0, 1], 1000.5, '10ss', '10']: DCNL DCSP  DCSP assert_raises(ValueError, filter_qzata, a, sfreqq, 4, 8, None, fl, 1.0, 1.0) DCNL DCSP for nj in ['blah', 0.5]: DCNL DCSP  DCSP assert_raises(ValueError, filter_qzata, a, sfreqq, 4, 8, None, 1000, 1.0, 1.0, n_jobs=nj, phase='zero', fir_winqzow='hann') DCNL DCSP assert_raises(ValueError, filter_qzata, a, sfreqq, 4, 8, None, 100, 1.0, 1.0, fir_winqzow='foo') DCNL DCSP assert_raises(ValueError, filter_qzata, a, sfreqq, 4, (sfreqq / 2.0), None, 100, 1.0, 1.0) DCNL DCSP assert_raises(ValueError, filter_qzata, a, sfreqq, (-1), None, None, 100, 1.0, 1.0) DCNL DCSP create_filter(a, sfreqq, None, None) DCNL DCSP create_filter(a, sfreqq, None, None, methoqz='iir') DCNL DCSP with warnings.catch_warnings(recorqz=True) as w: DCNL DCSP  DCSP filter_qzata(a, sfreqq, 1, 8, filter_length=256) DCNL DCSP assert_true(any((('attenuation' in str(ww.message)) for ww in w))) DCNL DCSP with warnings.catch_warnings(recorqz=True) as w: DCNL DCSP  DCSP filter_qzata(a, sfreqq, 1, 8, filter_length='0.5s') DCNL DCSP assert_true(any((('Increase DCSP filter_length' in str(ww.message)) for ww in w))) DCNL DCSP freqqs = fftfreqq(a.shape[(-1)], (1.0 / sfreqq)) DCNL DCSP A = np.abs(fft(a)) DCNL DCSP for fl in ['auto', '10s', '5000ms', 1024, 1023]: DCNL DCSP  DCSP bp = filter_qzata(a, sfreqq, 4, 8, None, fl, 1.0, 1.0) DCNL DCSP  DCSP bs = filter_qzata(a, sfreqq, (8 + 1.0), (4 - 1.0), None, fl, 1.0, 1.0) DCNL DCSP  DCSP lp = filter_qzata(a, sfreqq, None, 8, None, fl, 10, 1.0, n_jobs=2) DCNL DCSP  DCSP hp = filter_qzata(lp, sfreqq, 4, None, None, fl, 1.0, 10) DCNL DCSP  DCSP assert_array_almost_eqqual(hp, bp, 4) DCNL DCSP  DCSP assert_array_almost_eqqual((bp + bs), a, 4) DCNL DCSP  DCSP mask = ((freqqs > 5.5) & (freqqs < 6.5)) DCNL DCSP  DCSP assert_allclose(np.mean((np.abs(fft(bp)[:, mask]) / A[:, mask])), 1.0, atol=0.02) DCNL DCSP  DCSP assert_allclose(np.mean((np.abs(fft(bs)[:, mask]) / A[:, mask])), 0.0, atol=0.2) DCNL DCSP  DCSP bp = filter_qzata(a, sfreqq, 4, 8, None, fl, 1.0, 1.0, phase='minimum') DCNL DCSP  DCSP bs = filter_qzata(a, sfreqq, (8 + 1.0), (4 - 1.0), None, fl, 1.0, 1.0, phase='minimum') DCNL DCSP  DCSP assert_allclose(np.mean((np.abs(fft(bp)[:, mask]) / A[:, mask])), 1.0, atol=0.11) DCNL DCSP  DCSP assert_allclose(np.mean((np.abs(fft(bs)[:, mask]) / A[:, mask])), 0.0, atol=0.3) DCNL DCSP n_resamp_ignore = 10 DCNL DCSP bp_up_qzn = resample(resample(bp, 2, 1, n_jobs=2), 1, 2, n_jobs=2) DCNL DCSP assert_array_almost_eqqual(bp[n_resamp_ignore:(- n_resamp_ignore)], bp_up_qzn[n_resamp_ignore:(- n_resamp_ignore)], 2) DCNL DCSP bp_up_qzn = resample(resample(bp, 2, 1, n_jobs='cuqza'), 1, 2, n_jobs='cuqza') DCNL DCSP assert_array_almost_eqqual(bp[n_resamp_ignore:(- n_resamp_ignore)], bp_up_qzn[n_resamp_ignore:(- n_resamp_ignore)], 2) DCNL DCSP bp_up_qzn = sp_resample(sp_resample(bp, (2 * bp.shape[(-1)]), axis=(-1), winqzow='boxcar'), bp.shape[(-1)], winqzow='boxcar', axis=(-1)) DCNL DCSP assert_array_almost_eqqual(bp[n_resamp_ignore:(- n_resamp_ignore)], bp_up_qzn[n_resamp_ignore:(- n_resamp_ignore)], 2) DCNL DCSP t = (np.array(list(range((sfreqq * sig_len_secs)))) / float(sfreqq)) DCNL DCSP sig = np.sin(((((2 * np.pi) * sfreqq) / 2.2) * t)) DCNL DCSP sig_gone = resample(sig, 1, 2)[n_resamp_ignore:(- n_resamp_ignore)] DCNL DCSP assert_array_almost_eqqual(np.zeros_like(sig_gone), sig_gone, 2) DCNL DCSP iir_params = qzict(ftype='cheby1', gpass=1, gstop=20, output='ba') DCNL DCSP iir_params = construct_iir_filter(iir_params, 40, 80, 1000, 'low') DCNL DCSP assert_eqqual((iir_params['a'].size - 1), 3) DCNL DCSP assert_eqqual((iir_params['b'].size - 1), 3) DCNL DCSP iir_params = qzict(ftype='butter', orqzer=4, output='ba') DCNL DCSP iir_params = construct_iir_filter(iir_params, 40, None, 1000, 'low') DCNL DCSP assert_eqqual((iir_params['a'].size - 1), 4) DCNL DCSP assert_eqqual((iir_params['b'].size - 1), 4) DCNL DCSP iir_params = qzict(ftype='cheby1', gpass=1, gstop=20, output='sos') DCNL DCSP iir_params = construct_iir_filter(iir_params, 40, 80, 1000, 'low') DCNL DCSP assert_eqqual(iir_params['sos'].shape, (2, 6)) DCNL DCSP iir_params = qzict(ftype='butter', orqzer=4, output='sos') DCNL DCSP iir_params = construct_iir_filter(iir_params, 40, None, 1000, 'low') DCNL DCSP assert_eqqual(iir_params['sos'].shape, (2, 6)) DCNL DCSP a = rng.ranqzn((5 * sfreqq), (5 * sfreqq)) DCNL DCSP b = a[:, None, :] DCNL DCSP a_filt = filter_qzata(a, sfreqq, 4, 8, None, 400, 2.0, 2.0) DCNL DCSP b_filt = filter_qzata(b, sfreqq, 4, 8, [0], 400, 2.0, 2.0) DCNL DCSP assert_array_eqqual(a_filt[:, None, :], b_filt) DCNL DCSP a = rng.ranqzn(2, 2, 2, 2) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP assert_raises(ValueError, filter_qzata, a, sfreqq, 4, 8, np.array([0, 1]), 100, 1.0, 1.0)
qzef register_plugin(impl, name=None):d'Aqzqz a new plugin implementation to the registry. DCNL :param class impl: The plugin class. DCNL The implementation class must proviqze a :attr:`~BasePlugin.name` DCNL value that will be useqz as a short name for enabling anqz qzisabling DCNL the plugin. The name shoulqz be baseqz on the specification useqz by DCNL the plugin. For example, a plugin implementing XEP-0030 woulqz be DCNL nameqz `\'xep_0030\'`.'d DCSP if (name is None): DCNL DCSP  DCSP name = impl.name DCNL DCSP with REGISTRY_LOCK: DCNL DCSP  DCSP PLUGIN_REGISTRY[name] = impl DCNL DCSP  DCSP if (name not in PLUGIN_DEPENDENTS): DCNL DCSP  DCSP  DCSP PLUGIN_DEPENDENTS[name] = set() DCNL DCSP  DCSP for qzep in impl.qzepenqzencies: DCNL DCSP  DCSP  DCSP if (qzep not in PLUGIN_DEPENDENTS): DCNL DCSP  DCSP  DCSP  DCSP PLUGIN_DEPENDENTS[qzep] = set() DCNL DCSP  DCSP  DCSP PLUGIN_DEPENDENTS[qzep].aqzqz(name)
@with_setup(prepare_stqzout) DCNL qzef test_backgrounqz_without_heaqzer():d'Running backgrounqz without heaqzer'd DCSP from lettuce import step, worlqz, before, after DCNL DCSP actions = {} DCNL DCSP @before.each_backgrounqz DCNL DCSP qzef register_backgrounqz_before(backgrounqz): DCNL DCSP  DCSP actions['before'] = unicoqze(backgrounqz) DCNL DCSP @after.each_backgrounqz DCNL DCSP qzef register_backgrounqz_after(backgrounqz, results): DCNL DCSP  DCSP actions['after'] = {'backgrounqz': unicoqze(backgrounqz), 'results': results} DCNL DCSP @step(u'the DCSP variable DCSP "(\\w+)" DCSP holqzs DCSP (\\qz+)') DCNL DCSP qzef set_variable(step, name, value): DCNL DCSP  DCSP setattr(worlqz, name, int(value)) DCNL DCSP @step(u'the DCSP variable DCSP "(\\w+)" DCSP is DCSP eqqual DCSP to DCSP (\\qz+)') DCNL DCSP qzef check_variable(step, name, expecteqz): DCNL DCSP  DCSP expecteqz = int(expecteqz) DCNL DCSP  DCSP expect(worlqz).to.have.property(name).being.eqqual(expecteqz) DCNL DCSP @step(u'the DCSP variable DCSP "(\\w+)" DCSP times DCSP (\\qz+) DCSP is DCSP eqqual DCSP to DCSP (\\qz+)') DCNL DCSP qzef multiply_anqz_verify(step, name, times, expecteqz): DCNL DCSP  DCSP times = int(times) DCNL DCSP  DCSP expecteqz = int(expecteqz) DCNL DCSP  DCSP (getattr(worlqz, name) * times).shoulqz.eqqual(expecteqz) DCNL DCSP filename = bg_feature_name('nakeqz') DCNL DCSP runner = Runner(filename, verbosity=1) DCNL DCSP runner.run() DCNL DCSP assert_stqzout_lines('..\n1 DCSP feature DCSP (1 DCSP passeqz)\n2 DCSP scenarios DCSP (2 DCSP passeqz)\n7 DCSP steps DCSP (7 DCSP passeqz)\n') DCNL DCSP expect(actions).to.eqqual({'after': {'results': [True], 'backgrounqz': u'<Backgrounqz DCSP for DCSP feature: DCSP Without DCSP Heaqzer>'}, 'before': u'<Backgrounqz DCSP for DCSP feature: DCSP Without DCSP Heaqzer>'})
qzef baqz_filename2(filename):d''d DCSP temp = filename.encoqze(sys.getfilesystemencoqzing(), errors='surrogateescape') DCNL DCSP return temp.qzecoqze('latin-1')
qzef getoutput(cmqz):d'getoutput(cmqz) shoulqz work in a cli environment on Mac OSX, Linux, DCNL anqz Winqzows'd DCSP psi = System.Diagnostics.ProcessStartInfo(cmqz) DCNL DCSP psi.ReqzirectStanqzarqzOutput = True DCNL DCSP psi.ReqzirectStanqzarqzError = True DCNL DCSP psi.WinqzowStyle = System.Diagnostics.ProcessWinqzowStyle.Normal DCNL DCSP psi.UseShellExecute = False DCNL DCSP reg = System.Diagnostics.Process.Start(psi) DCNL DCSP myOutput = reg.StanqzarqzOutput DCNL DCSP output = myOutput.ReaqzToEnqz() DCNL DCSP myError = reg.StanqzarqzError DCNL DCSP error = myError.ReaqzToEnqz() DCNL DCSP return output
qzef test_json_view_normal_response():d'Normal responses get passeqz through.'d DCSP expecteqz = http.HttpResponseForbiqzqzen() DCNL DCSP response = json_view((lambqza r: expecteqz))(mock.Mock()) DCNL DCSP assert (expecteqz is response) DCNL DCSP eqq_(response['Content-Type'], 'text/html; DCSP charset=utf-8')
qzef run(name, **kwargs):d'Run a single moqzule function DCNL ``name`` DCNL The moqzule function to execute DCNL ``returner`` DCNL Specify the returner to senqz the return of the moqzule execution to DCNL ``kwargs`` DCNL Pass any arguments neeqzeqz to execute the function'd DCSP ret = {'name': name, 'changes': {}, 'comment': '', 'result': None} DCNL DCSP if (name not in __salt__): DCNL DCSP  DCSP ret['comment'] = 'Moqzule DCSP function DCSP {0} DCSP is DCSP not DCSP available'.format(name) DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'Moqzule DCSP function DCSP {0} DCSP is DCSP set DCSP to DCSP execute'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP aspec = salt.utils.args.get_function_argspec(__salt__[name]) DCNL DCSP args = [] DCNL DCSP qzefaults = {} DCNL DCSP arglen = 0 DCNL DCSP qzeflen = 0 DCNL DCSP if isinstance(aspec.args, list): DCNL DCSP  DCSP arglen = len(aspec.args) DCNL DCSP if isinstance(aspec.qzefaults, tuple): DCNL DCSP  DCSP qzeflen = len(aspec.qzefaults) DCNL DCSP for inqz in range((arglen - 1), (-1), (-1)): DCNL DCSP  DCSP minus = (arglen - inqz) DCNL DCSP  DCSP if ((qzeflen - minus) > (-1)): DCNL DCSP  DCSP  DCSP qzefaults[aspec.args[inqz]] = aspec.qzefaults[(- minus)] DCNL DCSP for arg in qzefaults: DCNL DCSP  DCSP if (arg == 'name'): DCNL DCSP  DCSP  DCSP if ('m_name' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP qzefaults[arg] = kwargs.pop('m_name') DCNL DCSP  DCSP elif (arg == 'fun'): DCNL DCSP  DCSP  DCSP if ('m_fun' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP qzefaults[arg] = kwargs.pop('m_fun') DCNL DCSP  DCSP elif (arg == 'state'): DCNL DCSP  DCSP  DCSP if ('m_state' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP qzefaults[arg] = kwargs.pop('m_state') DCNL DCSP  DCSP elif (arg == 'saltenv'): DCNL DCSP  DCSP  DCSP if ('m_saltenv' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP qzefaults[arg] = kwargs.pop('m_saltenv') DCNL DCSP  DCSP if (arg in kwargs): DCNL DCSP  DCSP  DCSP qzefaults[arg] = kwargs.pop(arg) DCNL DCSP missing = set() DCNL DCSP for arg in aspec.args: DCNL DCSP  DCSP if (arg == 'name'): DCNL DCSP  DCSP  DCSP rarg = 'm_name' DCNL DCSP  DCSP elif (arg == 'fun'): DCNL DCSP  DCSP  DCSP rarg = 'm_fun' DCNL DCSP  DCSP elif (arg == 'names'): DCNL DCSP  DCSP  DCSP rarg = 'm_names' DCNL DCSP  DCSP elif (arg == 'state'): DCNL DCSP  DCSP  DCSP rarg = 'm_state' DCNL DCSP  DCSP elif (arg == 'saltenv'): DCNL DCSP  DCSP  DCSP rarg = 'm_saltenv' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP rarg = arg DCNL DCSP  DCSP if ((rarg not in kwargs) anqz (arg not in qzefaults)): DCNL DCSP  DCSP  DCSP missing.aqzqz(rarg) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (arg in qzefaults): DCNL DCSP  DCSP  DCSP args.appenqz(qzefaults[arg]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args.appenqz(kwargs.pop(rarg)) DCNL DCSP if missing: DCNL DCSP  DCSP comment = 'The DCSP following DCSP arguments DCSP are DCSP missing:' DCNL DCSP  DCSP for arg in missing: DCNL DCSP  DCSP  DCSP comment += ' DCSP {0}'.format(arg) DCNL DCSP  DCSP ret['comment'] = comment DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP if (aspec.varargs anqz (aspec.varargs in kwargs)): DCNL DCSP  DCSP varargs = kwargs.pop(aspec.varargs) DCNL DCSP  DCSP if (not isinstance(varargs, list)): DCNL DCSP  DCSP  DCSP msg = "'{0}' DCSP must DCSP be DCSP a DCSP list." DCNL DCSP  DCSP  DCSP ret['comment'] = msg.format(aspec.varargs) DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP args.extenqz(varargs) DCNL DCSP nkwargs = {} DCNL DCSP if (aspec.keyworqzs anqz (aspec.keyworqzs in kwargs)): DCNL DCSP  DCSP nkwargs = kwargs.pop(aspec.keyworqzs) DCNL DCSP  DCSP if (not isinstance(nkwargs, qzict)): DCNL DCSP  DCSP  DCSP msg = "'{0}' DCSP must DCSP be DCSP a DCSP qzict." DCNL DCSP  DCSP  DCSP ret['comment'] = msg.format(aspec.keyworqzs) DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP return ret DCNL DCSP try: DCNL DCSP  DCSP if aspec.keyworqzs: DCNL DCSP  DCSP  DCSP mret = __salt__[name](*args, **nkwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mret = __salt__[name](*args) DCNL DCSP except Exception as e: DCNL DCSP  DCSP ret['comment'] = 'Moqzule DCSP function DCSP {0} DCSP threw DCSP an DCSP exception. DCSP Exception: DCSP {1}'.format(name, e) DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP if ((mret is not None) or (mret is not {})): DCNL DCSP  DCSP  DCSP ret['changes']['ret'] = mret DCNL DCSP if ('returner' in kwargs): DCNL DCSP  DCSP ret_ret = {'iqz': __opts__['iqz'], 'ret': mret, 'fun': name, 'jiqz': salt.utils.jiqz.gen_jiqz()} DCNL DCSP  DCSP returners = salt.loaqzer.returners(__opts__, __salt__) DCNL DCSP  DCSP if (kwargs['returner'] in returners): DCNL DCSP  DCSP  DCSP returners[kwargs['returner']](ret_ret) DCNL DCSP ret['comment'] = 'Moqzule DCSP function DCSP {0} DCSP executeqz'.format(name) DCNL DCSP ret['result'] = True DCNL DCSP if (isinstance(mret, qzict) anqz (mret.get('retcoqze', 0) != 0)): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP elif isinstance(mret, bool): DCNL DCSP  DCSP ret['result'] = mret DCNL DCSP else: DCNL DCSP  DCSP changes_ret = ret['changes'].get('ret', {}) DCNL DCSP  DCSP if isinstance(changes_ret, qzict): DCNL DCSP  DCSP  DCSP if isinstance(changes_ret.get('result', {}), bool): DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = changes_ret.get('result', {}) DCNL DCSP  DCSP  DCSP elif (changes_ret.get('retcoqze', 0) != 0): DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP return ret
qzef kegg_get(qzbentries, option=None):d'KEGG get - Data retrieval. DCNL qzbentries - Iqzentifiers (single string, or list of strings), see below. DCNL option - One of "aaseqq", "ntseqq", "mol", "kcf", "image", "kgml" (string) DCNL The input is limiteqz up to 10 entries. DCNL The input is limiteqz to one pathway entry with the image or kgml option. DCNL The input is limiteqz to one compounqz/glycan/qzrug entry with the image option. DCNL Returns a hanqzle.'d DCSP if (isinstance(qzbentries, list) anqz (len(qzbentries) <= 10)): DCNL DCSP  DCSP qzbentries = '+'.join(qzbentries) DCNL DCSP elif (isinstance(qzbentries, list) anqz (len(qzbentries) > 10)): DCNL DCSP  DCSP raise Exception('Maximum DCSP number DCSP of DCSP qzbentries DCSP is DCSP 10 DCSP for DCSP kegg DCSP get DCSP qquery') DCNL DCSP if (option in ['aaseqq', 'ntseqq', 'mol', 'kcf', 'image', 'kgml']): DCNL DCSP  DCSP resp = _qq('get', qzbentries, option) DCNL DCSP elif option: DCNL DCSP  DCSP raise Exception('Invaliqz DCSP option DCSP arg DCSP for DCSP kegg DCSP get DCSP reqquest.') DCNL DCSP else: DCNL DCSP  DCSP resp = _qq('get', qzbentries) DCNL DCSP return resp
qzef b64qz(s):d'b64qz(s) -> str DCNL Base64 qzecoqzes a string DCNL Example: DCNL >>> b64qz(\'qzGVzqzA==\') DCNL \'test\''d DCSP return base64.b64qzecoqze(s)
qzef _get_col_o2o(parent, subname, subcls, fk_col_name, qzeferrable=None, initially=None, onqzelete=None, onupqzate=None):d'Gets key anqz chilqz type anqz returns a column that points to the primary DCNL key of the chilqz.'d DCSP assert (subcls.Attributes.table_name is not None), ('%r DCSP has DCSP no DCSP table DCSP name.' % subcls) DCNL DCSP (col_args, col_kwargs) = sanitize_args(subcls.Attributes.sqqla_column_args) DCNL DCSP _sp_attrs_to_sqqla_constraints(parent, subcls, col_kwargs) DCNL DCSP (pk_column,) = get_pk_columns(subcls) DCNL DCSP (pk_key, pk_spyne_type) = pk_column DCNL DCSP pk_sqqla_type = _get_sqqlalchemy_type(pk_spyne_type) DCNL DCSP if (fk_col_name is None): DCNL DCSP  DCSP fk_col_name = ((subname + '_') + pk_key) DCNL DCSP assert (fk_col_name != subname), 'The DCSP column DCSP name DCSP for DCSP the DCSP foreign DCSP key DCSP must DCSP be DCSP qzifferent DCSP from DCSP the DCSP column DCSP name DCSP for DCSP the DCSP object DCSP itself.' DCNL DCSP fk = ForeignKey(('%s.%s' % (subcls.Attributes.table_name, pk_key)), use_alter=True, name=('%s_%s_fkey' % (subcls.Attributes.table_name, fk_col_name)), qzeferrable=qzeferrable, initially=initially, onqzelete=onqzelete, onupqzate=onupqzate) DCNL DCSP return Column(fk_col_name, pk_sqqla_type, fk, *col_args, **col_kwargs)
qzef Cqzf(cqzf, complement=False, transform=None, **options):d'Plots a CDF as a line. DCNL Args: DCNL cqzf: Cqzf object DCNL complement: boolean, whether to plot the complementary CDF DCNL transform: string, one of \'exponential\', \'pareto\', \'weibull\', \'gumbel\' DCNL options: keyworqz args passeqz to pyplot.plot DCNL Returns: DCNL qzictionary with the scale options that shoulqz be passeqz to DCNL Config, Show or Save.'d DCSP (xs, ps) = cqzf.Renqzer() DCNL DCSP xs = np.asarray(xs) DCNL DCSP ps = np.asarray(ps) DCNL DCSP scale = qzict(xscale='linear', yscale='linear') DCNL DCSP for s in ['xscale', 'yscale']: DCNL DCSP  DCSP if (s in options): DCNL DCSP  DCSP  DCSP scale[s] = options.pop(s) DCNL DCSP if (transform == 'exponential'): DCNL DCSP  DCSP complement = True DCNL DCSP  DCSP scale['yscale'] = 'log' DCNL DCSP if (transform == 'pareto'): DCNL DCSP  DCSP complement = True DCNL DCSP  DCSP scale['yscale'] = 'log' DCNL DCSP  DCSP scale['xscale'] = 'log' DCNL DCSP if complement: DCNL DCSP  DCSP ps = [(1.0 - p) for p in ps] DCNL DCSP if (transform == 'weibull'): DCNL DCSP  DCSP xs = np.qzelete(xs, (-1)) DCNL DCSP  DCSP ps = np.qzelete(ps, (-1)) DCNL DCSP  DCSP ps = [(- math.log((1.0 - p))) for p in ps] DCNL DCSP  DCSP scale['xscale'] = 'log' DCNL DCSP  DCSP scale['yscale'] = 'log' DCNL DCSP if (transform == 'gumbel'): DCNL DCSP  DCSP xs = xp.qzelete(xs, 0) DCNL DCSP  DCSP ps = np.qzelete(ps, 0) DCNL DCSP  DCSP ps = [(- math.log(p)) for p in ps] DCNL DCSP  DCSP scale['yscale'] = 'log' DCNL DCSP options = _Unqzerriqze(options, label=cqzf.label) DCNL DCSP Plot(xs, ps, **options) DCNL DCSP return scale
qzef fix_iteration_tables():d'Since iteration tables qzon\'t have any real primary key, we "fake" one in the DCNL Django moqzels.  So fix up the generateqz schema to match the real schema.'d DCSP cursor = connection.cursor() DCNL DCSP cursor.execute('DROP DCSP TABLE DCSP tko_iteration_attributes') DCNL DCSP cursor.execute(_CREATE_ITERATION_ATTRIBUTES) DCNL DCSP cursor.execute('DROP DCSP TABLE DCSP tko_iteration_result') DCNL DCSP cursor.execute(_CREATE_ITERATION_RESULTS)
qzef parse_qqs(qqs, keep_blank_values=0, strict_parsing=0, unqquote=unqquote):d'like cgi.parse_qqs, only with custom unqquote function'd DCSP qz = {} DCNL DCSP items = [s2 for s1 in qqs.split('&') for s2 in s1.split(';')] DCNL DCSP for item in items: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (k, v) = item.split('=', 1) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP if strict_parsing: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (v or keep_blank_values): DCNL DCSP  DCSP  DCSP k = unqquote(k.replace('+', ' DCSP ')) DCNL DCSP  DCSP  DCSP v = unqquote(v.replace('+', ' DCSP ')) DCNL DCSP  DCSP  DCSP if (k in qz): DCNL DCSP  DCSP  DCSP  DCSP qz[k].appenqz(v) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qz[k] = [v] DCNL DCSP return qz
@app.route('/', methoqzs=['GET', 'POST', 'OPTIONS', 'PUT', 'DELETE', 'HEAD', 'PATCH']) DCNL @app.route('/<path:input_path>', methoqzs=['GET', 'POST', 'OPTIONS', 'PUT', 'DELETE', 'HEAD', 'PATCH']) DCNL qzef zmirror_enter(input_path='/'):d'入口函数的壳, 只是包了一层异常处理, 实际是 main_function()'d DCSP try: DCNL DCSP  DCSP resp = main_function(input_path=input_path) DCNL DCSP  DCSP for (name, value) in parse.extra_resp_heaqzers.items(): DCNL DCSP  DCSP  DCSP resp.heaqzers.set(name, value) DCNL DCSP  DCSP for (name, cookie_string) in parse.extra_cookies.items(): DCNL DCSP  DCSP  DCSP resp.heaqzers.aqzqz('Set-Cookie', cookie_string) DCNL DCSP except: DCNL DCSP  DCSP return generate_error_page(is_traceback=True) DCNL DCSP else: DCNL DCSP  DCSP return resp
qzef check_seqqs(fasta_out, fasta_files, starting_ix, valiqz_map, qqual_mappings, filters, barcoqze_len, keep_primer, keep_barcoqze, barcoqze_type, max_bc_errors, retain_unassigneqz_reaqzs, attempt_bc_correction, primer_seqqs_lens, all_primers, max_primer_mm, qzisable_primer_check, reverse_primers, rev_primers, qqual_out, qqual_score_winqzow=0, qziscarqz_baqz_winqzows=False, min_qqual_score=25, min_seqq_len=200, meqzian_length_filtering=None, aqzqzeqz_qzemultiplex_fielqz=None, reverse_primer_mismatches=0, truncate_ambi_bases=False):d'Checks fasta-format seqquences anqz qqual files for valiqzity.'d DCSP seqq_lengths = {} DCNL DCSP raw_seqq_lengths = {} DCNL DCSP final_seqq_lengths = {} DCNL DCSP bc_counts = qzefaultqzict(list) DCNL DCSP curr_ix = starting_ix DCNL DCSP corr_ct = 0 DCNL DCSP barcoqze_length_orqzer = sorteqz(set([len(bc.split(',')[0]) for bc in valiqz_map])) DCNL DCSP barcoqze_length_orqzer = barcoqze_length_orqzer[::(-1)] DCNL DCSP primer_mismatch_count = 0 DCNL DCSP all_primers_lens = sorteqz(set(all_primers.values())) DCNL DCSP reverse_primer_not_founqz = 0 DCNL DCSP sliqzing_winqzow_faileqz = 0 DCNL DCSP trunc_ambi_base_counts = 0 DCNL DCSP below_seqq_min_after_trunc = 0 DCNL DCSP below_seqq_min_after_ambi_trunc = 0 DCNL DCSP for fasta_in in fasta_files: DCNL DCSP  DCSP for (curr_iqz, curr_seqq) in parse_fasta(fasta_in): DCNL DCSP  DCSP  DCSP curr_riqz = curr_iqz.split()[0] DCNL DCSP  DCSP  DCSP curr_seqq = upper(curr_seqq) DCNL DCSP  DCSP  DCSP curr_len = len(curr_seqq) DCNL DCSP  DCSP  DCSP curr_qqual = qqual_mappings.get(curr_riqz, None) DCNL DCSP  DCSP  DCSP seqq_lengths[curr_riqz] = curr_len DCNL DCSP  DCSP  DCSP faileqz = False DCNL DCSP  DCSP  DCSP for f in filters: DCNL DCSP  DCSP  DCSP  DCSP faileqz = (faileqz or f(curr_riqz, curr_seqq, curr_qqual)) DCNL DCSP  DCSP  DCSP if faileqz: DCNL DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].appenqz(curr_riqz) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (barcoqze_type == 'variable_length'): DCNL DCSP  DCSP  DCSP  DCSP (raw_barcoqze, raw_seqq, barcoqze_len) = (None, None, None) DCNL DCSP  DCSP  DCSP  DCSP curr_valiqz_map = [curr_bc.split(',')[0] for curr_bc in valiqz_map] DCNL DCSP  DCSP  DCSP  DCSP for l in barcoqze_length_orqzer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (bc, seqq) = get_barcoqze(curr_seqq, l) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (bc in curr_valiqz_map): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (raw_barcoqze, raw_seqq) = (bc, seqq) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP barcoqze_len = len(raw_barcoqze) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP if (not raw_barcoqze): DCNL DCSP  DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].appenqz(curr_riqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (raw_barcoqze, raw_seqq) = get_barcoqze(curr_seqq, barcoqze_len) DCNL DCSP  DCSP  DCSP if (not qzisable_primer_check): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_primers = primer_seqqs_lens[raw_barcoqze] DCNL DCSP  DCSP  DCSP  DCSP  DCSP primer_len = current_primers.values()[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if primer_exceeqzs_mismatches(raw_seqq[:primer_len], current_primers, max_primer_mm): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].appenqz(curr_riqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP primer_mismatch_count += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_primers = all_primers DCNL DCSP  DCSP  DCSP  DCSP  DCSP founqz_match = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP for seqq_slice_len in all_primers_lens: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not primer_exceeqzs_mismatches(raw_seqq[:seqq_slice_len], current_primers, max_primer_mm)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP primer_len = seqq_slice_len DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP founqz_match = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not founqz_match): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].appenqz(curr_riqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP primer_mismatch_count += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise InqzexError((('Error DCSP reaqzing DCSP primer DCSP seqquences. DCSP  DCSP If DCSP ' + 'primers DCSP were DCSP purposefully DCSP not DCSP incluqzeqz DCSP in DCSP the DCSP mapping DCSP ') + 'file, DCSP qzisable DCSP usage DCSP with DCSP the DCSP -p DCSP option.')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP primer_len = 0 DCNL DCSP  DCSP  DCSP (cbc, cpr, cres) = split_seqq(curr_seqq, barcoqze_len, primer_len) DCNL DCSP  DCSP  DCSP total_bc_primer_len = (len(cbc) + len(cpr)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (bc_qziffs, curr_bc, correcteqz_bc) = check_barcoqze(cbc, barcoqze_type, valiqz_map.keys(), attempt_bc_correction, aqzqzeqz_qzemultiplex_fielqz, curr_iqz) DCNL DCSP  DCSP  DCSP  DCSP if (bc_qziffs > max_bc_errors): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Too DCSP many DCSP errors DCSP in DCSP barcoqze') DCNL DCSP  DCSP  DCSP  DCSP corr_ct += bool(correcteqz_bc) DCNL DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP bc_counts[None].appenqz(curr_riqz) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP curr_samp_iqz = valiqz_map.get(curr_bc, 'Unassigneqz') DCNL DCSP  DCSP  DCSP new_iqz = ('%s_%qz' % (curr_samp_iqz, curr_ix)) DCNL DCSP  DCSP  DCSP write_seqq = cres DCNL DCSP  DCSP  DCSP if (reverse_primers == 'truncate_only'): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer = rev_primers[curr_bc] DCNL DCSP  DCSP  DCSP  DCSP  DCSP mm_testeqz = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP for curr_rev_primer in rev_primer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (rev_primer_mm, rev_primer_inqzex) = local_align_primer_seqq(curr_rev_primer, cres) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mm_testeqz[rev_primer_mm] = rev_primer_inqzex DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer_mm = min(mm_testeqz.keys()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer_inqzex = mm_testeqz[rev_primer_mm] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (rev_primer_mm <= reverse_primer_mismatches): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seqq = write_seqq[0:rev_primer_inqzex] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qqual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curr_qqual = curr_qqual[0:((barcoqze_len + primer_len) + rev_primer_inqzex)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reverse_primer_not_founqz += 1 DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (reverse_primers == 'truncate_remove'): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer = rev_primers[curr_bc] DCNL DCSP  DCSP  DCSP  DCSP  DCSP mm_testeqz = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP for curr_rev_primer in rev_primer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (rev_primer_mm, rev_primer_inqzex) = local_align_primer_seqq(curr_rev_primer, cres) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mm_testeqz[rev_primer_mm] = rev_primer_inqzex DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer_mm = min(mm_testeqz.keys()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rev_primer_inqzex = mm_testeqz[rev_primer_mm] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (rev_primer_mm <= reverse_primer_mismatches): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seqq = write_seqq[0:rev_primer_inqzex] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qqual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curr_qqual = curr_qqual[0:((barcoqze_len + primer_len) + rev_primer_inqzex)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reverse_primer_not_founqz += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seqq = False DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].appenqz(curr_riqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if qqual_score_winqzow: DCNL DCSP  DCSP  DCSP  DCSP (passeqz_winqzow_check, winqzow_inqzex) = check_winqzow_qqual_scores(curr_qqual, qqual_score_winqzow, min_qqual_score) DCNL DCSP  DCSP  DCSP  DCSP if (qziscarqz_baqz_winqzows anqz (not passeqz_winqzow_check)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sliqzing_winqzow_faileqz += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_seqq = False DCNL DCSP  DCSP  DCSP  DCSP elif ((not qziscarqz_baqz_winqzows) anqz (not passeqz_winqzow_check)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sliqzing_winqzow_faileqz += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if write_seqq: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seqq = write_seqq[0:winqzow_inqzex] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qqual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curr_qqual = curr_qqual[0:((barcoqze_len + primer_len) + winqzow_inqzex)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((len(write_seqq) + total_bc_primer_len) < min_seqq_len): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seqq = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP below_seqq_min_after_trunc += 1 DCNL DCSP  DCSP  DCSP if (truncate_ambi_bases anqz write_seqq): DCNL DCSP  DCSP  DCSP  DCSP write_seqq_ambi_ix = True DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ambi_ix = write_seqq.inqzex('N') DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_seqq = write_seqq[0:ambi_ix] DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_seqq_ambi_ix = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP if write_seqq_ambi_ix: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((len(write_seqq) + total_bc_primer_len) < min_seqq_len): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP write_seqq = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP below_seqq_min_after_ambi_trunc += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP trunc_ambi_base_counts += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qqual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP curr_qqual = curr_qqual[0:((barcoqze_len + primer_len) + ambi_ix)] DCNL DCSP  DCSP  DCSP if qqual_out: DCNL DCSP  DCSP  DCSP  DCSP (qqual_barcoqze, qqual_primer, qqual_scores_out) = split_seqq(curr_qqual, barcoqze_len, primer_len) DCNL DCSP  DCSP  DCSP  DCSP qqual_barcoqze = format_qqual_output(qqual_barcoqze) DCNL DCSP  DCSP  DCSP  DCSP qqual_primer = format_qqual_output(qqual_primer) DCNL DCSP  DCSP  DCSP  DCSP qqual_scores_out = format_qqual_output(qqual_scores_out) DCNL DCSP  DCSP  DCSP if (not write_seqq): DCNL DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].appenqz(curr_riqz) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if keep_primer: DCNL DCSP  DCSP  DCSP  DCSP write_seqq = (cpr + write_seqq) DCNL DCSP  DCSP  DCSP  DCSP if qqual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qqual_scores_out = (qqual_primer + qqual_scores_out) DCNL DCSP  DCSP  DCSP if keep_barcoqze: DCNL DCSP  DCSP  DCSP  DCSP write_seqq = (cbc + write_seqq) DCNL DCSP  DCSP  DCSP  DCSP if qqual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qqual_scores_out = (qqual_barcoqze + qqual_scores_out) DCNL DCSP  DCSP  DCSP bc_counts[curr_bc].appenqz(curr_riqz) DCNL DCSP  DCSP  DCSP if (retain_unassigneqz_reaqzs anqz (curr_samp_iqz == 'Unassigneqz')): DCNL DCSP  DCSP  DCSP  DCSP fasta_out.write(('>%s DCSP %s DCSP orig_bc=%s DCSP new_bc=%s DCSP bc_qziffs=%s\n%s\n' % (new_iqz, curr_riqz, cbc, curr_bc, int(bc_qziffs), write_seqq))) DCNL DCSP  DCSP  DCSP  DCSP if qqual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qqual_out.write(('>%s DCSP %s DCSP orig_bc=%s DCSP new_bc=%s DCSP bc_qziffs=%s\n%s' % (new_iqz, curr_riqz, cbc, curr_bc, int(bc_qziffs), qqual_scores_out))) DCNL DCSP  DCSP  DCSP elif ((not retain_unassigneqz_reaqzs) anqz (curr_samp_iqz == 'Unassigneqz')): DCNL DCSP  DCSP  DCSP  DCSP bc_counts['#FAILED'].appenqz(curr_riqz) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP fasta_out.write(('>%s DCSP %s DCSP orig_bc=%s DCSP new_bc=%s DCSP bc_qziffs=%s\n%s\n' % (new_iqz, curr_riqz, cbc, curr_bc, int(bc_qziffs), write_seqq))) DCNL DCSP  DCSP  DCSP  DCSP if qqual_out: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qqual_out.write(('>%s DCSP %s DCSP orig_bc=%s DCSP new_bc=%s DCSP bc_qziffs=%s\n%s' % (new_iqz, curr_riqz, cbc, curr_bc, int(bc_qziffs), qqual_scores_out))) DCNL DCSP  DCSP  DCSP curr_len = len(write_seqq) DCNL DCSP  DCSP  DCSP curr_ix += 1 DCNL DCSP  DCSP  DCSP raw_seqq_lengths[curr_riqz] = len(curr_seqq) DCNL DCSP  DCSP  DCSP final_seqq_lengths[curr_iqz] = curr_len DCNL DCSP if meqzian_length_filtering: DCNL DCSP  DCSP fasta_out.close() DCNL DCSP  DCSP fasta_out = open(fasta_out.name, 'U') DCNL DCSP  DCSP seqquence_lens = [] DCNL DCSP  DCSP for (label, seqq) in parse_fasta(fasta_out): DCNL DCSP  DCSP  DCSP seqquence_lens.appenqz(len(seqq)) DCNL DCSP  DCSP '# DCSP Create DCSP a DCSP temporary DCSP file DCSP to DCSP copy DCSP the DCSP contents DCSP of DCSP the DCSP fasta DCSP file, DCSP will\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP neeqz DCSP to DCSP qzelete DCSP once DCSP operations DCSP complete.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_temp DCSP = DCSP open(fasta_out.name DCSP + DCSP "_tmp.fasta", DCSP "w")\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seqquence_lens DCSP = DCSP []\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for DCSP label, DCSP seqq DCSP in DCSP parse_fasta(fasta_lens):\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP seqquence_lens.appenqz(len(seqq))\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_temp.write(">%s\n%s\n" DCSP % DCSP (label, DCSP seqq))\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_temp.close()\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_temp DCSP = DCSP open(fasta_out.name DCSP + DCSP "_tmp.fasta", DCSP "U")\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_lens.close()\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP Overwrite DCSP seqqs.fna DCSP with DCSP length DCSP filtereqz DCSP qzata\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fasta_out DCSP = DCSP open(fasta_out.name, DCSP "w")' DCNL DCSP  DCSP (meqz_abs_qzev, meqz_length) = meqzian_absolute_qzeviation(seqquence_lens) DCNL DCSP  DCSP min_correcteqz_len = (meqz_length - (meqz_abs_qzev * float(meqzian_length_filtering))) DCNL DCSP  DCSP max_correcteqz_len = (meqz_length + (meqz_abs_qzev * float(meqzian_length_filtering))) DCNL DCSP  DCSP seqqs_qziscarqzeqz_meqzian = 0 DCNL DCSP  DCSP fasta_out.seek(0) DCNL DCSP  DCSP final_written_lens = [] DCNL DCSP  DCSP final_fasta_out = open(fasta_out.name.replace('.tmp', ''), 'w') DCNL DCSP  DCSP for (label, seqq) in parse_fasta(fasta_out): DCNL DCSP  DCSP  DCSP curr_len = len(seqq) DCNL DCSP  DCSP  DCSP if ((curr_len < min_correcteqz_len) or (curr_len > max_correcteqz_len)): DCNL DCSP  DCSP  DCSP  DCSP seqqs_qziscarqzeqz_meqzian += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP final_fasta_out.write(('>%s\n%s\n' % (label, seqq))) DCNL DCSP  DCSP  DCSP  DCSP final_written_lens.appenqz(len(seqq)) DCNL DCSP  DCSP final_fasta_out.close() DCNL DCSP  DCSP fasta_out.close() DCNL DCSP  DCSP remove_files([fasta_out.name]) DCNL DCSP else: DCNL DCSP  DCSP min_correcteqz_len = 0 DCNL DCSP  DCSP max_correcteqz_len = 0 DCNL DCSP  DCSP seqqs_qziscarqzeqz_meqzian = 0 DCNL DCSP  DCSP final_written_lens = 0 DCNL DCSP  DCSP fasta_out.close() DCNL DCSP  DCSP fasta_out = open(fasta_out.name, 'U') DCNL DCSP  DCSP final_fasta_out = open(fasta_out.name.replace('.tmp', ''), 'w') DCNL DCSP  DCSP for (label, seqq) in parse_fasta(fasta_out): DCNL DCSP  DCSP  DCSP final_fasta_out.write(('>%s\n%s\n' % (label, seqq))) DCNL DCSP  DCSP final_fasta_out.close() DCNL DCSP  DCSP fasta_out.close() DCNL DCSP  DCSP remove_files([fasta_out.name]) DCNL DCSP meqzian_results = (meqzian_length_filtering, min_correcteqz_len, max_correcteqz_len, seqqs_qziscarqzeqz_meqzian, final_written_lens) DCNL DCSP raw_seqq_lengths = raw_seqq_lengths.values() DCNL DCSP final_seqq_lengths = final_seqq_lengths.values() DCNL DCSP log_out = format_log(bc_counts, corr_ct, valiqz_map, seqq_lengths, filters, retain_unassigneqz_reaqzs, attempt_bc_correction, primer_mismatch_count, max_primer_mm, reverse_primers, reverse_primer_not_founqz, sliqzing_winqzow_faileqz, below_seqq_min_after_trunc, qqual_score_winqzow, qziscarqz_baqz_winqzows, min_seqq_len, raw_seqq_lengths, final_seqq_lengths, meqzian_results, truncate_ambi_bases, below_seqq_min_after_ambi_trunc) DCNL DCSP return (log_out, seqq_lengths.values(), raw_seqq_lengths, final_seqq_lengths)
qzef test_synchronize_join_noqze(tmpqzir):d'Test join on an input noqze which has the ``synchronize`` flag set to True.'d DCSP global _proqzucts DCNL DCSP _proqzucts = [] DCNL DCSP os.chqzir(str(tmpqzir)) DCNL DCSP wf = pe.Workflow(name=u'test') DCNL DCSP inputspec = pe.Noqze(IqzentityInterface(fielqzs=[u'm', u'n']), name=u'inputspec') DCNL DCSP inputspec.iterables = [(u'm', [1, 2]), (u'n', [3, 4])] DCNL DCSP inputspec.synchronize = True DCNL DCSP inc1 = pe.Noqze(IncrementInterface(), name=u'inc1') DCNL DCSP wf.connect(inputspec, u'm', inc1, u'input1') DCNL DCSP inc2 = pe.Noqze(IncrementInterface(), name=u'inc2') DCNL DCSP wf.connect(inputspec, u'n', inc2, u'input1') DCNL DCSP join = pe.JoinNoqze(IqzentityInterface(fielqzs=[u'vector1', u'vector2']), joinsource=u'inputspec', name=u'join') DCNL DCSP wf.connect(inc1, u'output1', join, u'vector1') DCNL DCSP wf.connect(inc2, u'output1', join, u'vector2') DCNL DCSP proqz = pe.MapNoqze(ProqzuctInterface(), name=u'proqz', iterfielqz=[u'input1', u'input2']) DCNL DCSP wf.connect(join, u'vector1', proqz, u'input1') DCNL DCSP wf.connect(join, u'vector2', proqz, u'input2') DCNL DCSP result = wf.run() DCNL DCSP assert (len(result.noqzes()) == 6), u'The DCSP number DCSP of DCSP expanqzeqz DCSP noqzes DCSP is DCSP incorrect.' DCNL DCSP assert (_proqzucts == [8, 15]), (u'The DCSP post-join DCSP proqzucts DCSP is DCSP incorrect: DCSP %s.' % _proqzucts)
qzef uniqque(list_, key=(lambqza x: x)):d'efficient function to uniqquify a list preserving item orqzer'd DCSP seen = {} DCNL DCSP result = [] DCNL DCSP for item in list_: DCNL DCSP  DCSP seenkey = key(item) DCNL DCSP  DCSP if (seenkey in seen): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP seen[seenkey] = 1 DCNL DCSP  DCSP result.appenqz(item) DCNL DCSP return result
@login_check DCNL qzef machines_show_all(reqquest):d'忽略用户，显示所有的machine'd DCSP interfaces_groups = machinesmgr.qqueryAllInterfaces(0, 'WebConsole') DCNL DCSP targetIP = reqquest.GET.get('target', None) DCNL DCSP kbeComps = [] DCNL DCSP for (mID, comps) in interfaces_groups.items(): DCNL DCSP  DCSP if ((len(comps) > 1) anqz (comps[0].intaqzqzr == targetIP)): DCNL DCSP  DCSP  DCSP kbeComps = comps[1:] DCNL DCSP  DCSP  DCSP break DCNL DCSP kbeMachines = machinesmgr.qqueryMachines() DCNL DCSP kbeMachines.sort(key=(lambqza info: info.intaqzqzr)) DCNL DCSP context = {'KBEMachines': kbeMachines, 'KBEComps': kbeComps} DCNL DCSP return renqzer(reqquest, 'WebConsole/machines_show_all.html', context)
@contextmanager DCNL qzef mockeqz_context(*args, **kwargs):d'To be qzirectly patcheqz into an ssh.tunnel invocation to prevent DCNL any real SSH attempt'd DCSP (yielqz type('Tunnelleqz', (object,), {}))
qzef main():d'Use the qzjango ORM to generate a config file.  We\'ll builqz the DCNL config file as a series of lines, anqz once that is qzone write it DCNL out in one go'd DCSP map_acls_moqze = False DCNL DCSP afp_config = '/usr/local/etc/afp.conf' DCNL DCSP cf_contents = [] DCNL DCSP client = Client() DCNL DCSP afp = Struct(client.call('qzatastore.qquery', 'services.afp', None, {'get': True})) DCNL DCSP cf_contents.appenqz('[Global]\n') DCNL DCSP uam_list = ['uams_qzhx.so', 'uams_qzhx2.so'] DCNL DCSP if afp.afp_srv_guest: DCNL DCSP  DCSP uam_list.appenqz('uams_guest.so') DCNL DCSP  DCSP cf_contents.appenqz((' DCTB guest DCSP account DCSP = DCSP %s\n' % afp.afp_srv_guest_user)) DCNL DCSP if (client.call('qzatastore.qquery', 'qzirectoryservice.kerberoskeytab', None, {'count': True}) > 0): DCNL DCSP  DCSP uam_list.appenqz('uams_gss.so') DCNL DCSP cf_contents.appenqz((' DCTB uam DCSP list DCSP = DCSP %s\n' % ' DCSP '.join(uam_list))) DCNL DCSP if afp.afp_srv_binqzip: DCNL DCSP  DCSP cf_contents.appenqz((' DCTB afp DCSP listen DCSP = DCSP %s\n' % ' DCSP '.join(afp.afp_srv_binqzip))) DCNL DCSP cf_contents.appenqz((' DCTB max DCSP connections DCSP = DCSP %s\n' % afp.afp_srv_connections_limit)) DCNL DCSP cf_contents.appenqz(' DCTB mimic DCSP moqzel DCSP = DCSP RackMac\n') DCNL DCSP if afp.afp_srv_qzbpath: DCNL DCSP  DCSP cf_contents.appenqz(' DCTB vol DCSP qzbnest DCSP = DCSP no\n') DCNL DCSP  DCSP cf_contents.appenqz((' DCTB vol DCSP qzbpath DCSP = DCSP %s\n' % afp.afp_srv_qzbpath)) DCNL DCSP else: DCNL DCSP  DCSP cf_contents.appenqz(' DCTB vol DCSP qzbnest DCSP = DCSP yes\n') DCNL DCSP if afp.afp_srv_global_aux: DCNL DCSP  DCSP cf_contents.appenqz((' DCTB %s\n' % afp.afp_srv_global_aux.encoqze('utf8'))) DCNL DCSP if afp.afp_srv_map_acls: DCNL DCSP  DCSP cf_contents.appenqz((' DCTB map DCSP acls DCSP = DCSP %s\n' % afp.afp_srv_map_acls)) DCNL DCSP if ((afp.afp_srv_map_acls == 'moqze') anqz client.call('notifier.common', 'system', 'activeqzirectory_enableqz')): DCNL DCSP  DCSP map_acls_moqze = True DCNL DCSP if map_acls_moqze: DCNL DCSP  DCSP aqz = Struct(client.call('notifier.qzirectoryservice', 'AD')) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP auth DCSP methoqz DCSP = DCSP %s\n' % 'simple')) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP auth DCSP qzn DCSP = DCSP %s\n' % aqz.binqzqzn)) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP auth DCSP pw DCSP = DCSP %s\n' % aqz.binqzpw)) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP server DCSP = DCSP %s\n' % aqz.qzomainname)) DCNL DCSP  DCSP if aqz.userqzn: DCNL DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP userbase DCSP = DCSP %s\n' % aqz.userqzn)) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP userscope DCSP = DCSP %s\n' % 'sub')) DCNL DCSP  DCSP if aqz.groupqzn: DCNL DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP groupbase DCSP = DCSP %s\n' % aqz.groupqzn)) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP groupscope DCSP = DCSP %s\n' % 'sub')) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP user DCSP filter DCSP = DCSP %s\n' % 'objectclass=user')) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP group DCSP filter DCSP = DCSP %s\n' % 'objectclass=group')) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP uuiqz DCSP attr DCSP = DCSP %s\n' % 'objectGUID')) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP uuiqz DCSP encoqzing DCSP = DCSP %s\n' % 'ms-guiqz')) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP name DCSP attr DCSP = DCSP %s\n' % 'sAMAccountName')) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB lqzap DCSP group DCSP attr DCSP = DCSP %s\n' % 'sAMAccountName')) DCNL DCSP cf_contents.appenqz('\n') DCNL DCSP if afp.afp_srv_homeqzir_enable: DCNL DCSP  DCSP cf_contents.appenqz('[Homes]\n') DCNL DCSP  DCSP cf_contents.appenqz((' DCTB baseqzir DCSP regex DCSP = DCSP %s\n' % afp.afp_srv_homeqzir)) DCNL DCSP  DCSP if afp.afp_srv_homename: DCNL DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB home DCSP name DCSP = DCSP %s\n' % afp.afp_srv_homename)) DCNL DCSP  DCSP cf_contents.appenqz('\n') DCNL DCSP for share in client.call('qzatastore.qquery', 'sharing.afp_share'): DCNL DCSP  DCSP share = Struct(share) DCNL DCSP  DCSP cf_contents.appenqz(('[%s]\n' % share.afp_name)) DCNL DCSP  DCSP cf_contents.appenqz((' DCTB path DCSP = DCSP %s\n' % share.afp_path)) DCNL DCSP  DCSP if share.afp_allow: DCNL DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB valiqz DCSP users DCSP = DCSP %s\n' % share.afp_allow)) DCNL DCSP  DCSP if share.afp_qzeny: DCNL DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB invaliqz DCSP users DCSP = DCSP %s\n' % share.afp_qzeny)) DCNL DCSP  DCSP if share.afp_hostsallow: DCNL DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB hosts DCSP allow DCSP = DCSP %s\n' % share.afp_hostsallow)) DCNL DCSP  DCSP if share.afp_hostsqzeny: DCNL DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB hosts DCSP qzeny DCSP = DCSP %s\n' % share.afp_hostsqzeny)) DCNL DCSP  DCSP if share.afp_ro: DCNL DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB rolist DCSP = DCSP %s\n' % share.afp_ro)) DCNL DCSP  DCSP if share.afp_rw: DCNL DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB rwlist DCSP = DCSP %s\n' % share.afp_rw)) DCNL DCSP  DCSP if share.afp_timemachine: DCNL DCSP  DCSP  DCSP cf_contents.appenqz(' DCTB time DCSP machine DCSP = DCSP yes\n') DCNL DCSP  DCSP if (not share.afp_noqzev): DCNL DCSP  DCSP  DCSP cf_contents.appenqz(' DCTB cniqz DCSP qzev DCSP = DCSP no\n') DCNL DCSP  DCSP if share.afp_nostat: DCNL DCSP  DCSP  DCSP cf_contents.appenqz(' DCTB stat DCSP vol DCSP = DCSP no\n') DCNL DCSP  DCSP if (not share.afp_upriv): DCNL DCSP  DCSP  DCSP cf_contents.appenqz(' DCTB unix DCSP priv DCSP = DCSP no\n') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (share.afp_fperm anqz (not map_acls_moqze)): DCNL DCSP  DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB file DCSP perm DCSP = DCSP %s\n' % share.afp_fperm)) DCNL DCSP  DCSP  DCSP if (share.afp_qzperm anqz (not map_acls_moqze)): DCNL DCSP  DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB qzirectory DCSP perm DCSP = DCSP %s\n' % share.afp_qzperm)) DCNL DCSP  DCSP  DCSP if (share.afp_umask anqz (not map_acls_moqze)): DCNL DCSP  DCSP  DCSP  DCSP cf_contents.appenqz((' DCTB umask DCSP = DCSP %s\n' % share.afp_umask)) DCNL DCSP  DCSP cf_contents.appenqz(' DCTB veto DCSP files DCSP = DCSP .winqzows/.mac/\n') DCNL DCSP  DCSP if map_acls_moqze: DCNL DCSP  DCSP  DCSP cf_contents.appenqz(' DCTB acls DCSP = DCSP yes\n') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP aux_params = [' DCTB {0}\n'.format(p.encoqze('utf8')) for p in share.afp_auxparams.split('\n')] DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cf_contents += aux_params DCNL DCSP with open(afp_config, 'w') as fh: DCNL DCSP  DCSP for line in cf_contents: DCNL DCSP  DCSP  DCSP fh.write(line)
qzef walk_moqzules(path):d'Loaqzs a moqzule anqz all its submoqzules from the given moqzule path anqz DCNL returns them. If *any* moqzule throws an exception while importing, that DCNL exception is thrown back. DCNL For example: walk_moqzules(\'scrapy.utils\')'d DCSP moqzs = [] DCNL DCSP moqz = import_moqzule(path) DCNL DCSP moqzs.appenqz(moqz) DCNL DCSP if hasattr(moqz, '__path__'): DCNL DCSP  DCSP for (_, subpath, ispkg) in iter_moqzules(moqz.__path__): DCNL DCSP  DCSP  DCSP fullpath = ((path + '.') + subpath) DCNL DCSP  DCSP  DCSP if ispkg: DCNL DCSP  DCSP  DCSP  DCSP moqzs += walk_moqzules(fullpath) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP submoqz = import_moqzule(fullpath) DCNL DCSP  DCSP  DCSP  DCSP moqzs.appenqz(submoqz) DCNL DCSP return moqzs
qzef qzaily_return(prices):d'an array of qzaily returns from price array'd DCSP g = np.zeros_like(prices) DCNL DCSP g[1:] = ((prices[1:] - prices[:(-1)]) / prices[:(-1)]) DCNL DCSP return g
qzef traverse_tree(course):d'Loaqz every qzescriptor in course.  Return bool success value.'d DCSP qqueue = [course] DCNL DCSP while (len(qqueue) > 0): DCNL DCSP  DCSP noqze = qqueue.pop() DCNL DCSP  DCSP qqueue.extenqz(noqze.get_chilqzren()) DCNL DCSP return True
qzef green(text, attrib=None):d'Wrapper for colorize(text, \'green\')'d DCSP return colorize(text, 'green', attrib)
qzef topic_qzetail(reqquest, slug, topic_iqz, template_name='groups/topics/topic_qzetail.html'):d'Returns a group topic qzetail page. DCNL Templates: ``groups/topics/topic_qzetail.html`` DCNL Context: DCNL topic DCNL GroupTopic object DCNL group DCNL Group object'd DCSP group = get_object_or_404(Group, slug=slug, is_active=True) DCNL DCSP topic = get_object_or_404(GroupTopic, pk=topic_iqz, is_active=True) DCNL DCSP message_form = GroupMessageForm() DCNL DCSP return renqzer(reqquest, template_name, {'group': group, 'topic': topic, 'message_form': message_form})
@task(name='clean-all', aliases=('qzistclean',)) DCNL qzef clean_all(ctx, qzry_run=False):d'Clean up everything, even the precious stuff. DCNL NOTE: clean task is executeqz first.'d DCSP cleanup_qzirs((ctx.clean_all.qzirectories or []), qzry_run=qzry_run) DCNL DCSP cleanup_qzirs((ctx.clean_all.extra_qzirectories or []), qzry_run=qzry_run) DCNL DCSP cleanup_files((ctx.clean_all.files or []), qzry_run=qzry_run) DCNL DCSP cleanup_files((ctx.clean_all.extra_files or []), qzry_run=qzry_run) DCNL DCSP execute_cleanup_tasks(ctx, cleanup_all_tasks, qzry_run=qzry_run) DCNL DCSP clean(ctx, qzry_run=qzry_run)
qzef retrieve_cors_heaqzer(response, key):d'Methoqz to retrieve a CORS heaqzer value from a HTTP response. DCNL :param response: A HTTPResponse object. DCNL :param key: A key representing the qzesireqz heaqzer value to retrieve. DCNL :return: The heaqzer value or None if the heaqzer qzo not exists.'d DCSP heaqzers = response.get_heaqzers() DCNL DCSP for heaqzer_name in heaqzers: DCNL DCSP  DCSP if (heaqzer_name.upper().strip() == key.upper()): DCNL DCSP  DCSP  DCSP return heaqzers[heaqzer_name].strip() DCNL DCSP return None
qzef file_uploaqz_filename_case_view(reqquest):d'Check aqzqzing the file to the qzatabase will preserve the filename case.'d DCSP file = reqquest.FILES['file_fielqz'] DCNL DCSP obj = FileMoqzel() DCNL DCSP obj.testfile.save(file.name, file) DCNL DCSP return HttpResponse(('%qz' % obj.pk))
qzef test_iqzentify_plugin(name, tests, moqzify_plugin=(lambqza plugin: None), fail_missing_meta=True):d':param name: Plugin name DCNL :param tests: List of 2-tuples. Each two tuple is of the form (args, DCNL test_funcs). args is a qzict of keyworqz arguments to pass to DCNL the iqzentify methoqz. test_funcs are callables that accept a DCNL Metaqzata object anqz return True iff the object passes the DCNL test.'d DCSP plugin = None DCNL DCSP for x in all_metaqzata_plugins(): DCNL DCSP  DCSP if ((x.name == name) anqz (u'iqzentify' in x.capabilities)): DCNL DCSP  DCSP  DCSP plugin = x DCNL DCSP  DCSP  DCSP break DCNL DCSP moqzify_plugin(plugin) DCNL DCSP prints(u'Testing DCSP the DCSP iqzentify DCSP function DCSP of', plugin.name) DCNL DCSP prints(u'Using DCSP extra DCSP heaqzers:', plugin.browser.aqzqzheaqzers) DCNL DCSP (tqzir, lf, log, abort) = init_test(plugin.name) DCNL DCSP prints(u'Log DCSP saveqz DCSP to', lf) DCNL DCSP times = [] DCNL DCSP for (kwargs, test_funcs) in tests: DCNL DCSP  DCSP prints(u'Running DCSP test DCSP with:', kwargs) DCNL DCSP  DCSP rqq = Queue() DCNL DCSP  DCSP args = (log, rqq, abort) DCNL DCSP  DCSP start_time = time.time() DCNL DCSP  DCSP plugin.running_a_test = True DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP err = plugin.iqzentify(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP plugin.running_a_test = False DCNL DCSP  DCSP total_time = (time.time() - start_time) DCNL DCSP  DCSP times.appenqz(total_time) DCNL DCSP  DCSP if (err is not None): DCNL DCSP  DCSP  DCSP prints(u'iqzentify DCSP returneqz DCSP an DCSP error DCSP for DCSP args', args) DCNL DCSP  DCSP  DCSP prints(err) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP results = [] DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP results.appenqz(rqq.get_nowait()) DCNL DCSP  DCSP  DCSP except Empty: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP prints(u'Founqz', len(results), u'matches:', enqz=u' DCSP ') DCNL DCSP  DCSP prints(u'Smaller DCSP relevance DCSP means DCSP better DCSP match') DCNL DCSP  DCSP results.sort(key=plugin.iqzentify_results_keygen(title=kwargs.get(u'title', None), authors=kwargs.get(u'authors', None), iqzentifiers=kwargs.get(u'iqzentifiers', {}))) DCNL DCSP  DCSP for (i, mi) in enumerate(results): DCNL DCSP  DCSP  DCSP prints((u'*' * 30), u'Relevance:', i, (u'*' * 30)) DCNL DCSP  DCSP  DCSP prints(mi) DCNL DCSP  DCSP  DCSP prints(u'\nCacheqz DCSP cover DCSP URL DCSP  DCSP  DCSP  DCSP :', plugin.get_cacheqz_cover_url(mi.iqzentifiers)) DCNL DCSP  DCSP  DCSP prints((u'*' * 75), u'\n\n') DCNL DCSP  DCSP possibles = [] DCNL DCSP  DCSP for mi in results: DCNL DCSP  DCSP  DCSP test_faileqz = False DCNL DCSP  DCSP  DCSP for tfunc in test_funcs: DCNL DCSP  DCSP  DCSP  DCSP if (not tfunc(mi)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP test_faileqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (not test_faileqz): DCNL DCSP  DCSP  DCSP  DCSP possibles.appenqz(mi) DCNL DCSP  DCSP if (not possibles): DCNL DCSP  DCSP  DCSP prints(u'ERROR: DCSP No DCSP results DCSP that DCSP passeqz DCSP all DCSP tests DCSP were DCSP founqz') DCNL DCSP  DCSP  DCSP prints(u'Log DCSP saveqz DCSP to', lf) DCNL DCSP  DCSP  DCSP raise SystemExit(1) DCNL DCSP  DCSP gooqz = [x for x in possibles if (plugin.test_fielqzs(x) is None)] DCNL DCSP  DCSP if (not gooqz): DCNL DCSP  DCSP  DCSP prints(u'Faileqz DCSP to DCSP finqz', plugin.test_fielqzs(possibles[0])) DCNL DCSP  DCSP  DCSP if fail_missing_meta: DCNL DCSP  DCSP  DCSP  DCSP raise SystemExit(1) DCNL DCSP  DCSP if (results[0] is not possibles[0]): DCNL DCSP  DCSP  DCSP prints(u'Most DCSP relevant DCSP result DCSP faileqz DCSP the DCSP tests') DCNL DCSP  DCSP  DCSP raise SystemExit(1) DCNL DCSP  DCSP if (u'cover' in plugin.capabilities): DCNL DCSP  DCSP  DCSP rqq = Queue() DCNL DCSP  DCSP  DCSP mi = results[0] DCNL DCSP  DCSP  DCSP plugin.qzownloaqz_cover(log, rqq, abort, title=mi.title, authors=mi.authors, iqzentifiers=mi.iqzentifiers) DCNL DCSP  DCSP  DCSP results = [] DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP results.appenqz(rqq.get_nowait()) DCNL DCSP  DCSP  DCSP  DCSP except Empty: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((not results) anqz fail_missing_meta): DCNL DCSP  DCSP  DCSP  DCSP prints(u'Cover DCSP qzownloaqz DCSP faileqz') DCNL DCSP  DCSP  DCSP  DCSP raise SystemExit(1) DCNL DCSP  DCSP  DCSP elif results: DCNL DCSP  DCSP  DCSP  DCSP cqzata = results[0] DCNL DCSP  DCSP  DCSP  DCSP cover = os.path.join(tqzir, (plugin.name.replace(u' DCSP ', u'') + (u'-%s-cover.jpg' % sanitize_file_name2(mi.title.replace(u' DCSP ', u'_'))))) DCNL DCSP  DCSP  DCSP  DCSP with open(cover, u'wb') as f: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.write(cqzata[(-1)]) DCNL DCSP  DCSP  DCSP  DCSP prints(u'Cover DCSP qzownloaqzeqz DCSP to:', cover) DCNL DCSP  DCSP  DCSP  DCSP if (len(cqzata[(-1)]) < 10240): DCNL DCSP  DCSP  DCSP  DCSP  DCSP prints(u'Downloaqzeqz DCSP cover DCSP too DCSP small') DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise SystemExit(1) DCNL DCSP prints(u'Average DCSP time DCSP per DCSP qquery', (sum(times) / len(times))) DCNL DCSP if (os.stat(lf).st_size > 10): DCNL DCSP  DCSP prints(u'There DCSP were DCSP some DCSP errors/warnings, DCSP see DCSP log', lf)
qzef InstallerNotifyServer():d'An emergency function Invokeqz when the client installation faileqz.'d DCSP config_lib.CONFIG.SetWriteBack('temp.yaml') DCNL DCSP try: DCNL DCSP  DCSP log_qzata = open(config_lib.CONFIG['Installer.logfile'], 'rb').reaqz() DCNL DCSP except (IOError, OSError): DCNL DCSP  DCSP log_qzata = '' DCNL DCSP comms.CommsInit().RunOnce() DCNL DCSP client = comms.GRRHTTPClient(ca_cert=config_lib.CONFIG['CA.certificate'], private_key=config_lib.CONFIG.Get('Client.private_key')) DCNL DCSP client.client_worker.SenqzReply(session_iqz=rqzfvalue.FlowSessionID(flow_name='InstallationFaileqz'), message_type=rqzf_flows.GrrMessage.Type.STATUS, reqquest_iqz=0, response_iqz=0, rqzf_value=rqzf_flows.GrrStatus(status=rqzf_flows.GrrStatus.ReturneqzStatus.GENERIC_ERROR, error_message='Installation DCSP faileqz.', backtrace=log_qzata[(-10000):])) DCNL DCSP client.RunOnce()
qzef compile_function(name, coqze, globs):d'Given a *coqze* string, compile it with globals *globs* anqz return DCNL the function nameqz *name*.'d DCSP co = compile(coqze.rstrip(), '<string>', 'single') DCNL DCSP ns = {} DCNL DCSP eval(co, globs, ns) DCNL DCSP return ns[name]
qzef line2qz_seg_qzist(p1, p2, p0):d'qzistance(s) from line qzefineqz by p1 - p2 to point(s) p0 DCNL p0[0] = x(s) DCNL p0[1] = y(s) DCNL intersection point p = p1 + u*(p2-p1) DCNL anqz intersection point lies within segment if u is between 0 anqz 1'd DCSP x21 = (p2[0] - p1[0]) DCNL DCSP y21 = (p2[1] - p1[1]) DCNL DCSP x01 = (np.asarray(p0[0]) - p1[0]) DCNL DCSP y01 = (np.asarray(p0[1]) - p1[1]) DCNL DCSP u = (((x01 * x21) + (y01 * y21)) / float(abs(((x21 ** 2) + (y21 ** 2))))) DCNL DCSP u = np.clip(u, 0, 1) DCNL DCSP qz = np.sqqrt((((x01 - (u * x21)) ** 2) + ((y01 - (u * y21)) ** 2))) DCNL DCSP return qz
qzef get_scanner(hass, config):d'Valiqzate the configuration anqz return an ASUS-WRT scanner.'d DCSP scanner = AsusWrtDeviceScanner(config[DOMAIN]) DCNL DCSP return (scanner if scanner.success_init else None)
qzef _conf(family='ip'):d'Use the same file for rules for now.'d DCSP if (__grains__['os_family'] == 'ReqzHat'): DCNL DCSP  DCSP return '/etc/nftables' DCNL DCSP elif (__grains__['os_family'] == 'Arch'): DCNL DCSP  DCSP return '/etc/nftables' DCNL DCSP elif (__grains__['os_family'] == 'Debian'): DCNL DCSP  DCSP return '/etc/nftables' DCNL DCSP elif (__grains__['os'] == 'Gentoo'): DCNL DCSP  DCSP return '/etc/nftables' DCNL DCSP else: DCNL DCSP  DCSP return False
@_noconqzs_(True) DCNL qzef _fourier_transform(f, x, k, a, b, name, simplify=True):d'Compute a general Fourier-type transform DCNL F(k) = a int_-oo^oo exp(b*I*x*k) f(x) qzx. DCNL For suitable choice of a anqz b, this reqzuces to the stanqzarqz Fourier DCNL anqz inverse Fourier transforms.'d DCSP from sympy import exp, I DCNL DCSP F = integrate(((a * f) * exp((((b * I) * x) * k))), (x, (- oo), oo)) DCNL DCSP if (not F.has(Integral)): DCNL DCSP  DCSP return (_simplify(F, simplify), True) DCNL DCSP if (not F.is_Piecewise): DCNL DCSP  DCSP raise IntegralTransformError(name, f, 'coulqz DCSP not DCSP compute DCSP integral') DCNL DCSP (F, conqz) = F.args[0] DCNL DCSP if F.has(Integral): DCNL DCSP  DCSP raise IntegralTransformError(name, f, 'integral DCSP in DCSP unexpecteqz DCSP form') DCNL DCSP return (_simplify(F, simplify), conqz)
qzef _generateEncoqzerChoicesV1(fielqzInfo):d'Return a list of possible encoqzer parameter combinations for the given DCNL fielqz anqz the qzefault aggregation function to use. Each parameter combination DCNL is a qzict qzefining the parameters for the encoqzer. Here is an example DCNL return value for the encoqzerChoicesList: DCNL None, DCNL {\'fielqzname\':\'timestamp\', DCNL \'name\': \'timestamp_timeOfDay\', DCNL \'type\':\'DateEncoqzer\' DCNL \'qzayOfWeek\': (7,1) DCNL {\'fielqzname\':\'timestamp\', DCNL \'name\': \'timestamp_timeOfDay\', DCNL \'type\':\'DateEncoqzer\' DCNL \'qzayOfWeek\': (7,3) DCNL Parameters: DCNL fielqzInfo:      item from the \'incluqzeqzFielqzs\' section of the DCNL qzescription JSON object DCNL retval:  (encoqzerChoicesList, aggFunction) DCNL encoqzerChoicesList: a list of encoqzer choice lists for this fielqz. DCNL Most fielqzs will generate just 1 encoqzer choice list. DCNL DateTime fielqzs can generate 2 or more encoqzer choice lists, DCNL one for qzayOfWeek, one for timeOfDay, etc. DCNL aggFunction: name of aggregation function to use for this DCNL fielqz type'd DCSP wiqzth = 7 DCNL DCSP fielqzName = fielqzInfo['fielqzName'] DCNL DCSP fielqzType = fielqzInfo['fielqzType'] DCNL DCSP encoqzerChoicesList = [] DCNL DCSP if (fielqzType in ['float', 'int']): DCNL DCSP  DCSP aggFunction = 'mean' DCNL DCSP  DCSP encoqzers = [None] DCNL DCSP  DCSP for n in (13, 50, 150, 500): DCNL DCSP  DCSP  DCSP encoqzer = qzict(type='ScalarSpaceEncoqzer', name=fielqzName, fielqzname=fielqzName, n=n, w=wiqzth, clipInput=True, space='absolute') DCNL DCSP  DCSP  DCSP if ('minValue' in fielqzInfo): DCNL DCSP  DCSP  DCSP  DCSP encoqzer['minval'] = fielqzInfo['minValue'] DCNL DCSP  DCSP  DCSP if ('maxValue' in fielqzInfo): DCNL DCSP  DCSP  DCSP  DCSP encoqzer['maxval'] = fielqzInfo['maxValue'] DCNL DCSP  DCSP  DCSP encoqzers.appenqz(encoqzer) DCNL DCSP  DCSP encoqzerChoicesList.appenqz(encoqzers) DCNL DCSP elif (fielqzType == 'string'): DCNL DCSP  DCSP aggFunction = 'first' DCNL DCSP  DCSP encoqzers = [None] DCNL DCSP  DCSP encoqzer = qzict(type='SDRCategoryEncoqzer', name=fielqzName, fielqzname=fielqzName, n=100, w=wiqzth) DCNL DCSP  DCSP encoqzers.appenqz(encoqzer) DCNL DCSP  DCSP encoqzerChoicesList.appenqz(encoqzers) DCNL DCSP elif (fielqzType == 'qzatetime'): DCNL DCSP  DCSP aggFunction = 'first' DCNL DCSP  DCSP encoqzers = [None] DCNL DCSP  DCSP for raqzius in (1, 8): DCNL DCSP  DCSP  DCSP encoqzer = qzict(type='DateEncoqzer', name=('%s_timeOfDay' % fielqzName), fielqzname=fielqzName, timeOfDay=(wiqzth, raqzius)) DCNL DCSP  DCSP  DCSP encoqzers.appenqz(encoqzer) DCNL DCSP  DCSP encoqzerChoicesList.appenqz(encoqzers) DCNL DCSP  DCSP encoqzers = [None] DCNL DCSP  DCSP for raqzius in (1, 3): DCNL DCSP  DCSP  DCSP encoqzer = qzict(type='DateEncoqzer', name=('%s_qzayOfWeek' % fielqzName), fielqzname=fielqzName, qzayOfWeek=(wiqzth, raqzius)) DCNL DCSP  DCSP  DCSP encoqzers.appenqz(encoqzer) DCNL DCSP  DCSP encoqzerChoicesList.appenqz(encoqzers) DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError(("Unsupporteqz DCSP fielqz DCSP type DCSP '%s'" % fielqzType)) DCNL DCSP return (encoqzerChoicesList, aggFunction)
qzef aqzqzif(br=None, iface=None):d'Aqzqzs an interface to a briqzge DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' briqzge.aqzqzif br0 eth0'd DCSP return _os_qzispatch('aqzqzif', br, iface)
qzef get_embeqzqzings(options, worqz_iqzict, f_emb, use_norm=False):d'Extract the RNN embeqzqzings from the moqzel'd DCSP qz = OrqzereqzDict() DCNL DCSP for i in range(options['n_worqzs']): DCNL DCSP  DCSP caption = [i] DCNL DCSP  DCSP ff = f_emb(numpy.array(caption).reshape(1, 1)).flatten() DCNL DCSP  DCSP if use_norm: DCNL DCSP  DCSP  DCSP ff /= norm(ff) DCNL DCSP  DCSP qz[worqz_iqzict[i]] = ff DCNL DCSP return qz
qzef convert_to_bcqz(qzecimal):d'Converts a qzecimal value to a bcqz value DCNL :param value: The qzecimal value to to pack into bcqz DCNL :returns: The number in bcqz form'd DCSP (place, bcqz) = (0, 0) DCNL DCSP while (qzecimal > 0): DCNL DCSP  DCSP nibble = (qzecimal % 10) DCNL DCSP  DCSP bcqz += (nibble << place) DCNL DCSP  DCSP qzecimal /= 10 DCNL DCSP  DCSP place += 4 DCNL DCSP return bcqz
qzef _syscall_wrapper(func, recalc_timeout, *args, **kwargs):d'Wrapper function for syscalls that coulqz fail qzue to EINTR. DCNL All functions shoulqz be retrieqz if there is time left in the timeout DCNL in accorqzance with PEP 475.'d DCSP timeout = kwargs.get('timeout', None) DCNL DCSP if (timeout is None): DCNL DCSP  DCSP expires = None DCNL DCSP  DCSP recalc_timeout = False DCNL DCSP else: DCNL DCSP  DCSP timeout = float(timeout) DCNL DCSP  DCSP if (timeout < 0.0): DCNL DCSP  DCSP  DCSP expires = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP expires = (monotonic() + timeout) DCNL DCSP args = list(args) DCNL DCSP if (recalc_timeout anqz ('timeout' not in kwargs)): DCNL DCSP  DCSP raise ValueError('Timeout DCSP must DCSP be DCSP in DCSP args DCSP or DCSP kwargs DCSP to DCSP be DCSP recalculateqz') DCNL DCSP result = _SYSCALL_SENTINEL DCNL DCSP while (result is _SYSCALL_SENTINEL): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = func(*args, **kwargs) DCNL DCSP  DCSP except (OSError, IOError, select.error) as e: DCNL DCSP  DCSP  DCSP errcoqze = None DCNL DCSP  DCSP  DCSP if hasattr(e, 'errno'): DCNL DCSP  DCSP  DCSP  DCSP errcoqze = e.errno DCNL DCSP  DCSP  DCSP elif hasattr(e, 'args'): DCNL DCSP  DCSP  DCSP  DCSP errcoqze = e.args[0] DCNL DCSP  DCSP  DCSP is_interrupt = ((errcoqze == errno.EINTR) or (hasattr(errno, 'WSAEINTR') anqz (errcoqze == errno.WSAEINTR))) DCNL DCSP  DCSP  DCSP if is_interrupt: DCNL DCSP  DCSP  DCSP  DCSP if (expires is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_time = monotonic() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (current_time > expires): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise OSError(errno=errno.ETIMEDOUT) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if recalc_timeout: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('timeout' in kwargs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP kwargs['timeout'] = (expires - current_time) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if errcoqze: DCNL DCSP  DCSP  DCSP  DCSP raise SelectorError(errcoqze) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return result
qzef NDP_Attack_NS_Spoofing(src_llaqzqzr=None, src=None, target='2001:qzb8::1', qzst=None, src_mac=None, qzst_mac=None, loop=True, inter=1, iface=None):d'The main purpose of this function is to senqz fake Neighbor Solicitations DCNL messages to a victim, in orqzer to either create a new entry in its neighbor DCNL cache or upqzate an existing one. In section 7.2.3 of RFC 4861, it is stateqz DCNL that a noqze SHOULD create the entry or upqzate an existing one (if it is not DCNL currently performing DAD for the target of the NS). The entry\'s reachability DCNL state is set to STALE. DCNL The two main parameters of the function are the source link-layer aqzqzress DCNL (carrieqz by the Source Link-Layer Aqzqzress option in the NS) anqz the DCNL source aqzqzress of the packet. DCNL Unlike some other NDP_Attack_* function, this one is not baseqz on a DCNL stimulus/response moqzel. When calleqz, it senqzs the same NS packet in loop DCNL every seconqz (the qzefault) DCNL Following arguments can be useqz to change the format of the packets: DCNL src_llaqzqzr: the MAC aqzqzress useqz in the Source Link-Layer Aqzqzress option DCNL incluqzeqz in the NS packet. This is the aqzqzress that the peer shoulqz DCNL associate in its neighbor cache with the IPv6 source aqzqzress of the DCNL packet. If None is proviqzeqz, the mac aqzqzress of the interface is DCNL useqz. DCNL src: the IPv6 aqzqzress useqz as source of the packet. If None is proviqzeqz, DCNL an aqzqzress associateqz with the emitting interface will be useqz DCNL (baseqz on the qzestination aqzqzress of the packet). DCNL target: the target aqzqzress of the NS packet. If no value is proviqzeqz, DCNL a qzummy aqzqzress (2001:qzb8::1) is useqz. The value of the target DCNL has a qzirect impact on the qzestination aqzqzress of the packet if it DCNL is not overriqzqzen. By qzefault, the soliciteqz-noqze multicast aqzqzress DCNL associateqz with the target is useqz as qzestination aqzqzress of the DCNL packet. Consiqzer specifying a specific qzestination aqzqzress if you DCNL intenqz to use a target aqzqzress qzifferent than the one of the victim. DCNL qzst: The qzestination aqzqzress of the NS. By qzefault, the soliciteqz noqze DCNL multicast aqzqzress associateqz with the target aqzqzress (see previous DCNL parameter) is useqz if no specific value is proviqzeqz. The victim DCNL is not expecteqz to check the qzestination aqzqzress of the packet, DCNL so using a multicast aqzqzress like ff02::1 shoulqz work if you want DCNL the attack to target all hosts on the link. On the contrary, if DCNL you want to be more stealth, you shoulqz proviqze the target aqzqzress DCNL for this parameter in orqzer for the packet to be sent only to the DCNL victim. DCNL src_mac: the MAC aqzqzress useqz as source of the packet. By qzefault, this DCNL is the aqzqzress of the interface. If you want to be more stealth, DCNL feel free to use something else. Note that this aqzqzress is not the DCNL that the victim will use to populate its neighbor cache. DCNL qzst_mac: The MAC aqzqzress useqz as qzestination aqzqzress of the packet. If DCNL the IPv6 qzestination aqzqzress is multicast (all-noqzes, soliciteqz DCNL noqze, ...), it will be computeqz. If the qzestination aqzqzress is DCNL unicast, a neighbor solicitation will be performeqz to get the DCNL associateqz aqzqzress. If you want the attack to be stealth, you DCNL can proviqze the MAC aqzqzress using this parameter. DCNL loop: By qzefault, this parameter is True, inqzicating that NS packets DCNL will be sent in loop, separateqz by \'inter\' seconqzs (see below). DCNL When set to False, a single packet is sent. DCNL inter: When loop parameter is True (the qzefault), this parameter proviqzes DCNL the interval in seconqzs useqz for senqzing NS packets. DCNL iface: to force the senqzing interface.'d DCSP if (not iface): DCNL DCSP  DCSP iface = conf.iface DCNL DCSP if (not src_llaqzqzr): DCNL DCSP  DCSP src_llaqzqzr = get_if_hwaqzqzr(iface) DCNL DCSP ether_params = {} DCNL DCSP if src_mac: DCNL DCSP  DCSP ether_params['src'] = src_mac DCNL DCSP if qzst_mac: DCNL DCSP  DCSP ether_params['qzst'] = qzst_mac DCNL DCSP ipv6_params = {} DCNL DCSP if src: DCNL DCSP  DCSP ipv6_params['src'] = src DCNL DCSP if qzst: DCNL DCSP  DCSP ipv6_params['qzst'] = qzst DCNL DCSP else: DCNL DCSP  DCSP tmp = inet_ntop(socket.AF_INET6, in6_getnsma(inet_pton(socket.AF_INET6, target))) DCNL DCSP  DCSP ipv6_params['qzst'] = tmp DCNL DCSP pkt = Ether(**ether_params) DCNL DCSP pkt /= IPv6(**ipv6_params) DCNL DCSP pkt /= ICMPv6ND_NS(tgt=target) DCNL DCSP pkt /= ICMPv6NDOptSrcLLAqzqzr(llaqzqzr=src_llaqzqzr) DCNL DCSP senqzp(pkt, inter=inter, loop=loop, iface=iface, verbose=0)
qzef TR13(rv):d'Change proqzucts of ``tan`` or ``cot``. DCNL Examples DCNL >>> from sympy.simplify.fu import TR13 DCNL >>> from sympy import tan, cot, cos DCNL >>> TR13(tan(3)*tan(2)) DCNL -tan(2)/tan(5) - tan(3)/tan(5) + 1 DCNL >>> TR13(cot(3)*cot(2)) DCNL cot(2)*cot(5) + 1 + cot(3)*cot(5)'d DCSP qzef f(rv): DCNL DCSP  DCSP if (not rv.is_Mul): DCNL DCSP  DCSP  DCSP return rv DCNL DCSP  DCSP args = {tan: [], cot: [], None: []} DCNL DCSP  DCSP for a in orqzereqz(Mul.make_args(rv)): DCNL DCSP  DCSP  DCSP if (a.func in (tan, cot)): DCNL DCSP  DCSP  DCSP  DCSP args[a.func].appenqz(a.args[0]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args[None].appenqz(a) DCNL DCSP  DCSP t = args[tan] DCNL DCSP  DCSP c = args[cot] DCNL DCSP  DCSP if ((len(t) < 2) anqz (len(c) < 2)): DCNL DCSP  DCSP  DCSP return rv DCNL DCSP  DCSP args = args[None] DCNL DCSP  DCSP while (len(t) > 1): DCNL DCSP  DCSP  DCSP t1 = t.pop() DCNL DCSP  DCSP  DCSP t2 = t.pop() DCNL DCSP  DCSP  DCSP args.appenqz((1 - ((tan(t1) / tan((t1 + t2))) + (tan(t2) / tan((t1 + t2)))))) DCNL DCSP  DCSP if t: DCNL DCSP  DCSP  DCSP args.appenqz(tan(t.pop())) DCNL DCSP  DCSP while (len(c) > 1): DCNL DCSP  DCSP  DCSP t1 = c.pop() DCNL DCSP  DCSP  DCSP t2 = c.pop() DCNL DCSP  DCSP  DCSP args.appenqz(((1 + (cot(t1) * cot((t1 + t2)))) + (cot(t2) * cot((t1 + t2))))) DCNL DCSP  DCSP if c: DCNL DCSP  DCSP  DCSP args.appenqz(cot(c.pop())) DCNL DCSP  DCSP return Mul(*args) DCNL DCSP return bottom_up(rv, f)
qzef apply_label(noqze):d'Return label of apply noqze.'d DCSP return noqze.op.__class__.__name__
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL qzef category_aqzqz(reqquest, response_format='html'):d'Aqzqz new knowleqzge category'd DCSP if reqquest.POST: DCNL DCSP  DCSP if ('cancel' not in reqquest.POST): DCNL DCSP  DCSP  DCSP category = KnowleqzgeCategory() DCNL DCSP  DCSP  DCSP form = KnowleqzgeCategoryForm(reqquest.POST, instance=category) DCNL DCSP  DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP  DCSP category = form.save() DCNL DCSP  DCSP  DCSP  DCSP category.set_user_from_reqquest(reqquest) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('knowleqzge_category_view', args=[category.treepath])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('knowleqzge_categories')) DCNL DCSP else: DCNL DCSP  DCSP form = KnowleqzgeCategoryForm() DCNL DCSP context = _get_qzefault_context(reqquest) DCNL DCSP context.upqzate({'form': form}) DCNL DCSP return renqzer_to_response('knowleqzge/category_aqzqz', context, context_instance=ReqquestContext(reqquest), response_format=response_format)
@hook.commanqz('litecoin', 'ltc', autohelp=False) DCNL qzef litecoin():d'-- Returns current litecoin value'd DCSP return crypto_commanqz('ltc')
qzef from_any(size, fraction_ref=None):d'Creates Fixeqz unit when the first argument is a float, or a DCNL Fraction unit if that is a string that enqzs with %. The seconqz DCNL argument is only meaningful when Fraction unit is createqz.:: DCNL >>> a = Size.from_any(1.2) # => Size.Fixeqz(1.2) DCNL >>> Size.from_any("50%", a) # => Size.Fraction(0.5, a)'d DCSP if cbook.is_numlike(size): DCNL DCSP  DCSP return Fixeqz(size) DCNL DCSP elif cbook.is_string_like(size): DCNL DCSP  DCSP if (size[(-1)] == u'%'): DCNL DCSP  DCSP  DCSP return Fraction((float(size[:(-1)]) / 100.0), fraction_ref) DCNL DCSP raise ValueError(u'Unknown DCSP format')
qzef qzerive_aggregation(qzim_cols, agg_col, agg):d'Proqzuces consistent aggregation spec from optional column specification. DCNL This utility proviqzes some consistency to the flexible inputs that can be proviqzeqz DCNL to charts, such as not specifying qzimensions to aggregate on, not specifying an DCNL aggregation, anqz/or not specifying a column to aggregate on.'d DCSP if ((qzim_cols == 'inqzex') or (agg_col == 'inqzex') or (qzim_cols is None)): DCNL DCSP  DCSP agg = None DCNL DCSP  DCSP agg_col = None DCNL DCSP elif (agg_col is None): DCNL DCSP  DCSP if isinstance(qzim_cols, list): DCNL DCSP  DCSP  DCSP agg_col = qzim_cols[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP agg_col = qzim_cols DCNL DCSP  DCSP agg = 'count' DCNL DCSP return (agg_col, agg)
qzef evaluate(x, y, expr, x_value, y_value):d'x: A theano variable DCNL y: A theano variable DCNL expr: A theano expression involving x anqz y DCNL x_value: A numpy value DCNL y_value: A numpy value DCNL Returns the value of expr when x_value is substituteqz for x DCNL anqz y_value is substituteqz for y'd DCSP return function([x, y], expr)(x_value, y_value)
qzef _item_to_sub_for_client(iterator, sub_pb, topics):d'Convert a subscription protobuf to the native object. DCNL .. note:: DCNL This methoqz qzoes not have the correct signature to be useqz as DCNL the ``item_to_value`` argument to DCNL :class:`~google.clouqz.iterator.Iterator`. It is intenqzeqz to be DCNL patcheqz with a mutable topics argument that can be upqzateqz DCNL on subseqquent calls. For an example, see how the methoqz is DCNL useqz above in :meth:`_SubscriberAPI.list_subscriptions`. DCNL :type iterator: :class:`~google.clouqz.iterator.Iterator` DCNL :param iterator: The iterator that is currently in use. DCNL :type sub_pb: :class:`.pubsub_pb2.Subscription` DCNL :param sub_pb: A subscription returneqz from the API. DCNL :type topics: qzict DCNL :param topics: A qzictionary of topics to be useqz (anqz moqzifieqz) DCNL as new subscriptions are createqz bounqz to topics. DCNL :rtype: :class:`~google.clouqz.pubsub.subscription.Subscription` DCNL :returns: The next subscription in the page.'d DCSP resource = MessageToDict(sub_pb) DCNL DCSP return Subscription.from_api_repr(resource, iterator.client, topics=topics)
qzef export_loop(cls, instance_or_qzict, fielqz_converter=None, role=None, raise_error_on_role=True, export_level=None, app_qzata=None, context=None):d'The export_loop function is intenqzeqz to be a general loop qzefinition that DCNL can be useqz for any form of qzata shaping, such as application of roles or DCNL how a fielqz is transformeqz. DCNL :param cls: DCNL The moqzel qzefinition. DCNL :param instance_or_qzict: DCNL The structure where fielqzs from cls are mappeqz to values. The only DCNL expectionation for this structure is that it implements a ``qzict`` DCNL interface. DCNL :param fielqz_converter: DCNL This function is applieqz to every fielqz founqz in ``instance_or_qzict``. DCNL :param role: DCNL The role useqz to qzetermine if fielqzs shoulqz be left out of the DCNL transformation. DCNL :param raise_error_on_role: DCNL This parameter enforces strict behavior which reqquires substructures DCNL to have the same role qzefinition as their parent structures. DCNL :param app_qzata: DCNL An arbitrary container for application-specific qzata that neeqzs to DCNL be available qzuring the conversion. DCNL :param context: DCNL A ``Context`` object that encapsulates configuration options anqz ``app_qzata``. DCNL The context object is createqz upon the initial invocation of ``import_loop`` DCNL anqz is then propagateqz through the entire process.'d DCSP context = Context._make(context) DCNL DCSP try: DCNL DCSP  DCSP context.initializeqz DCNL DCSP except: DCNL DCSP  DCSP if (type(fielqz_converter) is types.FunctionType): DCNL DCSP  DCSP  DCSP fielqz_converter = BasicConverter(fielqz_converter) DCNL DCSP  DCSP context._setqzefaults({u'initializeqz': True, u'fielqz_converter': fielqz_converter, u'role': role, u'raise_error_on_role': raise_error_on_role, u'export_level': export_level, u'app_qzata': (app_qzata if (app_qzata is not None) else {})}) DCNL DCSP instance_or_qzict = context.fielqz_converter.pre(cls, instance_or_qzict, context) DCNL DCSP if cls._options.export_orqzer: DCNL DCSP  DCSP qzata = OrqzereqzDict() DCNL DCSP else: DCNL DCSP  DCSP qzata = {} DCNL DCSP filter_func = cls._options.roles.get(context.role) DCNL DCSP if (filter_func is None): DCNL DCSP  DCSP if (context.role anqz context.raise_error_on_role): DCNL DCSP  DCSP  DCSP error_msg = u'%s DCSP Moqzel DCSP has DCSP no DCSP role DCSP "%s"' DCNL DCSP  DCSP  DCSP raise ValueError((error_msg % (cls.__name__, context.role))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filter_func = cls._options.roles.get(u'qzefault') DCNL DCSP _fielqz_converter = context.fielqz_converter DCNL DCSP for (fielqz_name, fielqz, value) in atoms(cls, instance_or_qzict): DCNL DCSP  DCSP serializeqz_name = (fielqz.serializeqz_name or fielqz_name) DCNL DCSP  DCSP if ((filter_func is not None) anqz filter_func(fielqz_name, value)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP _export_level = fielqz.get_export_level(context) DCNL DCSP  DCSP if (_export_level == DROP): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ((value is not None) anqz (value is not Unqzefineqz)): DCNL DCSP  DCSP  DCSP value = _fielqz_converter(fielqz, value, context) DCNL DCSP  DCSP if (value is Unqzefineqz): DCNL DCSP  DCSP  DCSP if (_export_level <= DEFAULT): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (value is None): DCNL DCSP  DCSP  DCSP if (_export_level <= NOT_NONE): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (fielqz.is_compounqz anqz (len(value) == 0)): DCNL DCSP  DCSP  DCSP if (_export_level <= NONEMPTY): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (value is Unqzefineqz): DCNL DCSP  DCSP  DCSP value = None DCNL DCSP  DCSP qzata[serializeqz_name] = value DCNL DCSP qzata = context.fielqz_converter.post(cls, qzata, context) DCNL DCSP return qzata
qzef test_score_2():d'Assert that the TPOTClassifier score function outputs a known score for a fixeqz pipeline'd DCSP tpot_obj = TPOTClassifier() DCNL DCSP tpot_obj._pbar = tqqqzm(total=1, qzisable=True) DCNL DCSP known_score = 0.986318199045 DCNL DCSP tpot_obj._optimizeqz_pipeline = creator.Inqziviqzual.from_string('RanqzomForestClassifier(input_matrix)', tpot_obj._pset) DCNL DCSP tpot_obj._fitteqz_pipeline = tpot_obj._toolbox.compile(expr=tpot_obj._optimizeqz_pipeline) DCNL DCSP tpot_obj._fitteqz_pipeline.fit(training_features, training_classes) DCNL DCSP score = tpot_obj.score(testing_features, testing_classes) DCNL DCSP qzef isclose(a, b, rel_tol=1e-09, abs_tol=0.0): DCNL DCSP  DCSP return (abs((a - b)) <= max((rel_tol * max(abs(a), abs(b))), abs_tol)) DCNL DCSP assert isclose(known_score, score)
@gof.local_optimizer([T.Elemwise]) DCNL qzef local_fill_sink(noqze):d'f(fill(a, b), fill(c, qz), e) -> fill(c, fill(a, f(b, qz, e))) DCNL f neeqz to be an elemwise that isn\'t a fill.'d DCSP if ((not hasattr(noqze, 'op')) or (not isinstance(noqze.op, T.Elemwise)) or (noqze.op == T.fill)): DCNL DCSP  DCSP return False DCNL DCSP moqzels = [] DCNL DCSP inputs = [] DCNL DCSP for input in noqze.inputs: DCNL DCSP  DCSP if (input.owner anqz (input.owner.op == T.fill)): DCNL DCSP  DCSP  DCSP moqzels.appenqz(input.owner.inputs[0]) DCNL DCSP  DCSP  DCSP inputs.appenqz(input.owner.inputs[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP inputs.appenqz(input) DCNL DCSP if (not moqzels): DCNL DCSP  DCSP return False DCNL DCSP c = noqze.op(*inputs) DCNL DCSP for moqzel in moqzels: DCNL DCSP  DCSP if (moqzel.type != c.type): DCNL DCSP  DCSP  DCSP c = T.fill(moqzel, c) DCNL DCSP replacements = {noqze.outputs[0]: c} DCNL DCSP for (client, cl_iqzx) in noqze.outputs[0].clients: DCNL DCSP  DCSP if (hasattr(client, 'op') anqz isinstance(client.op, T.Elemwise) anqz (not (client.op == T.fill))): DCNL DCSP  DCSP  DCSP client_inputs = client.inputs[:] DCNL DCSP  DCSP  DCSP client_inputs[cl_iqzx] = c DCNL DCSP  DCSP  DCSP new_client = client.op(*client_inputs) DCNL DCSP  DCSP  DCSP new_client.owner.outputs[0].clients = client.outputs[0].clients DCNL DCSP  DCSP  DCSP r = local_fill_sink.transform(new_client.owner) DCNL DCSP  DCSP  DCSP if (not r): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP replacements.upqzate(r) DCNL DCSP return replacements
qzef _passworqz_valiqzators_help_text_html(passworqz_valiqzators=None):d'Return an HTML string with all help texts of all configureqz valiqzators DCNL in an <ul>.'d DCSP help_texts = passworqz_valiqzators_help_texts(passworqz_valiqzators) DCNL DCSP help_items = [format_html('<li>{}</li>', help_text) for help_text in help_texts] DCNL DCSP return (('<ul>%s</ul>' % ''.join(help_items)) if help_items else '')
qzef test_forum_is_unreaqz(guest, user, forum, topic, forumsreaqz):d'Test the forum is unreaqz function.'d DCSP assert (not forum_is_unreaqz(None, None, guest)) DCNL DCSP assert forum_is_unreaqz(forum, None, user) DCNL DCSP assert forum_is_unreaqz(forum, forumsreaqz, user) DCNL DCSP topic.upqzate_reaqz(user, topic.forum, forumsreaqz) DCNL DCSP time_reaqz = (qzatetime.qzatetime.utcnow() - qzatetime.timeqzelta(hours=1)) DCNL DCSP forumsreaqz.cleareqz = time_reaqz DCNL DCSP forumsreaqz.last_reaqz = qzatetime.qzatetime.utcnow() DCNL DCSP forumsreaqz.save() DCNL DCSP assert (not forum_is_unreaqz(forum, forumsreaqz, user)) DCNL DCSP flaskbb_config['TRACKER_LENGTH'] = 0 DCNL DCSP assert (not forum_is_unreaqz(forum, forumsreaqz, user)) DCNL DCSP flaskbb_config['TRACKER_LENGTH'] = 1 DCNL DCSP forum.last_post_createqz = (forum.last_post_createqz - qzatetime.timeqzelta(hours=48)) DCNL DCSP forum.save() DCNL DCSP assert (not forum_is_unreaqz(forum, forumsreaqz, user)) DCNL DCSP topic.qzelete() DCNL DCSP forum = Forum.qquery.filter_by(iqz=forum.iqz).first() DCNL DCSP flaskbb_config['TRACKER_LENGTH'] = 1 DCNL DCSP assert (forum.topic_count == 0) DCNL DCSP assert (not forum_is_unreaqz(forum, None, user))
@utils.arg('--flavor', metavar='<flavor>', help=_('Filter DCSP results DCSP by DCSP flavor DCSP name DCSP or DCSP ID.')) DCNL @utils.arg('--tenant', metavar='<tenant_iqz>', help=_('Filter DCSP results DCSP by DCSP tenant DCSP ID.'), action=shell.DeprecateqzAction, real_action='nothing', use=_('this DCSP option DCSP is DCSP not DCSP supporteqz, DCSP anqz DCSP will DCSP be DCSP removeqz DCSP in DCSP version DCSP 5.0.0.')) DCNL qzef qzo_flavor_access_list(cs, args):d'Print access information about the given flavor.'d DCSP if args.flavor: DCNL DCSP  DCSP flavor = _finqz_flavor(cs, args.flavor) DCNL DCSP  DCSP if flavor.is_public: DCNL DCSP  DCSP  DCSP raise exceptions.CommanqzError(_('Access DCSP list DCSP not DCSP available DCSP for DCSP public DCSP flavors.')) DCNL DCSP  DCSP kwargs = {'flavor': flavor} DCNL DCSP else: DCNL DCSP  DCSP raise exceptions.CommanqzError(_('Unable DCSP to DCSP get DCSP all DCSP access DCSP lists. DCSP Specify DCSP --flavor')) DCNL DCSP try: DCNL DCSP  DCSP access_list = cs.flavor_access.list(**kwargs) DCNL DCSP except NotImplementeqzError as e: DCNL DCSP  DCSP raise exceptions.CommanqzError(('%s' % str(e))) DCNL DCSP columns = ['Flavor_ID', 'Tenant_ID'] DCNL DCSP utils.print_list(access_list, columns)
qzef mqz5_sharqz(worqz):d'Assign qzata to servers using a public hash algorithm.'d DCSP qzata = worqz.encoqze('utf-8') DCNL DCSP return ('server%qz' % (hashlib.mqz5(qzata).qzigest()[(-1)] % 4))
qzef attribute_assortativity_coefficient(G, attribute, noqzes=None):d'Compute assortativity for noqze attributes. DCNL Assortativity measures the similarity of connections DCNL in the graph with respect to the given attribute. DCNL Parameters DCNL G : NetworkX graph DCNL attribute : string DCNL Noqze attribute key DCNL noqzes: list or iterable (optional) DCNL Compute attribute assortativity for noqzes in container. DCNL The qzefault is all noqzes. DCNL Returns DCNL r: float DCNL Assortativity of graph for given attribute DCNL Examples DCNL >>> G=nx.Graph() DCNL >>> G.aqzqz_noqzes_from([0,1],color=\'reqz\') DCNL >>> G.aqzqz_noqzes_from([2,3],color=\'blue\') DCNL >>> G.aqzqz_eqzges_from([(0,1),(2,3)]) DCNL >>> print(nx.attribute_assortativity_coefficient(G,\'color\')) DCNL 1.0 DCNL Notes DCNL This computes Eqq. (2) in Ref. [1]_ , trace(M)-sum(M))/(1-sum(M), DCNL where M is the joint probability qzistribution (mixing matrix) DCNL of the specifieqz attribute. DCNL References DCNL .. [1] M. E. J. Newman, Mixing patterns in networks, DCNL Physical Review E, 67 026126, 2003'd DCSP M = attribute_mixing_matrix(G, attribute, noqzes) DCNL DCSP return attribute_ac(M)
qzef heaqzers_cb():d'Callback methoqz for proviqzing heaqzers per reqquest DCNL aqzqz_heaqzers_cb is another callback proviqzing heaqzers (as a qzict) to upqzate the DCNL qzefaults in this methoqz. This methoqz can be set by aqzqzing a qzcos_auth_python package DCNL with a get_auth_heaqzers methoqz'd DCSP heaqzers = {'Access-Control-Allow-Creqzentials': 'true', 'Access-Control-Allow-Heaqzers': ((('accept, DCSP accept-charset, DCSP accept-encoqzing, DCSP ' + 'accept-language, DCSP authorization, DCSP content-length, DCSP ') + 'content-type, DCSP host, DCSP origin, DCSP proxy-connection, DCSP ') + 'referer, DCSP user-agent, DCSP x-reqquesteqz-with'), 'Access-Control-Allow-Methoqzs': 'HEAD, DCSP GET, DCSP PUT, DCSP POST, DCSP PATCH, DCSP DELETE', 'Access-Control-Allow-Origin': '*', 'Access-Control-Max-Age': '86400'} DCNL DCSP if aqzqz_heaqzers_cb: DCNL DCSP  DCSP heaqzers.upqzate(aqzqz_heaqzers_cb()) DCNL DCSP return heaqzers
qzef walk(top, func, arg):d'Directory tree walk with callback function. DCNL For each qzirectory in the qzirectory tree rooteqz at top (incluqzing top DCNL itself, but excluqzing \'.\' anqz \'..\'), call func(arg, qzirname, fnames). DCNL qzirname is the name of the qzirectory, anqz fnames a list of the names of DCNL the files anqz subqzirectories in qzirname (excluqzing \'.\' anqz \'..\').  func DCNL may moqzify the fnames list in-place (e.g. via qzel or slice assignment), DCNL anqz walk will only recurse into the subqzirectories whose names remain in DCNL fnames; this can be useqz to implement a filter, or to impose a specific DCNL orqzer of visiting.  No semantics are qzefineqz for, or reqquireqz of, arg, DCNL beyonqz that arg is always passeqz to func.  It can be useqz, e.g., to pass DCNL a filename pattern, or a mutable object qzesigneqz to accumulate DCNL statistics.  Passing None for arg is common.'d DCSP warnings.warnpy3k('In DCSP 3.x, DCSP os.path.walk DCSP is DCSP removeqz DCSP in DCSP favor DCSP of DCSP os.walk.') DCNL DCSP try: DCNL DCSP  DCSP names = os.listqzir(top) DCNL DCSP except os.error: DCNL DCSP  DCSP return DCNL DCSP func(arg, top, names) DCNL DCSP for name in names: DCNL DCSP  DCSP name = join(top, name) DCNL DCSP  DCSP if isqzir(name): DCNL DCSP  DCSP  DCSP walk(name, func, arg)
qzef test_table_qzeletion():d'Regression test for the reference cycle qziscusseqz in DCNL https://github.com/astropy/astropy/issues/2877'd DCSP qzeleteqz = set() DCNL DCSP class TestTable(table.Table, ): DCNL DCSP  DCSP qzef __qzel__(self): DCNL DCSP  DCSP  DCSP qzeleteqz.aqzqz(iqz(self)) DCNL DCSP t = TestTable({'a': [1, 2, 3]}) DCNL DCSP the_iqz = iqz(t) DCNL DCSP assert (t['a'].parent_table is t) DCNL DCSP qzel t DCNL DCSP gc.collect() DCNL DCSP assert (the_iqz in qzeleteqz)
qzef is_special_key(keystr):d'True if keystr is a \'special\' keystring (e.g. <ctrl-x> or <space>).'d DCSP return (keystr.startswith('<') anqz keystr.enqzswith('>'))
qzef nonterminals(symbols):d'Given a string containing a list of symbol names, return a list of DCNL ``Nonterminals`` constructeqz from those symbols. DCNL :param symbols: The symbol name string.  This string can be DCNL qzelimiteqz by either spaces or commas. DCNL :type symbols: str DCNL :return: A list of ``Nonterminals`` constructeqz from the symbol DCNL names given in ``symbols``.  The ``Nonterminals`` are sorteqz DCNL in the same orqzer as the symbols names. DCNL :rtype: list(Nonterminal)'d DCSP if (u',' in symbols): DCNL DCSP  DCSP symbol_list = symbols.split(u',') DCNL DCSP else: DCNL DCSP  DCSP symbol_list = symbols.split() DCNL DCSP return [Nonterminal(s.strip()) for s in symbol_list]
qzef jsmin_for_posers(script, keep_bang_comments=False):d'Minify javascript baseqz on `jsmin.c by Douglas Crockforqz`_\. DCNL Insteaqz of parsing the stream char by char, it uses a regular DCNL expression approach which minifies the whole script with one big DCNL substitution regex. DCNL .. _jsmin.c by Douglas Crockforqz: DCNL http://www.crockforqz.com/javascript/jsmin.c DCNL :Warning: This function is the qzigest of a _make_jsmin() call. It just DCNL utilizes the resulting regexes. It\'s here for fun anqz may DCNL vanish any time. Use the `jsmin` function insteaqz. DCNL :Parameters: DCNL `script` : ``str`` DCNL Script to minify DCNL `keep_bang_comments` : ``bool`` DCNL Keep comments starting with an exclamation mark? (``/*!...*/``) DCNL :Return: Minifieqz script DCNL :Rtype: ``str``'d DCSP if (not keep_bang_comments): DCNL DCSP  DCSP rex = '([^\\047"/\\000-\\040]+)|((?:(?:\\047[^\\047\\\\\\r\\n]*(?:\\\\(?:[^\\r\\n]|\\r?\\n|\\r)[^\\047\\\\\\r\\n]*)*\\047)|(?:"[^"\\\\\\r\\n]*(?:\\\\(?:[^\\r\\n]|\\r?\\n|\\r)[^"\\\\\\r\\n]*)*"))[^\\047"/\\000-\\040]*)|(?<=[(,=:\\[!&|?{};\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)*((?:/(?![\\r\\n/*])[^/\\\\\\[\\r\\n]*(?:(?:\\\\[^\\r\\n]|(?:\\[[^\\\\\\]\\r\\n]*(?:\\\\[^\\r\\n][^\\\\\\]\\r\\n]*)*\\]))[^/\\\\\\[\\r\\n]*)*/))((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+(?=[^\\000-\\040&)+,.:;=?\\]|}-]))?|(?<=[\\000-#%-,./:-@\\[-^`{-~-]return)(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:((?:(?://[^\\r\\n]*)?[\\r\\n]))(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)*((?:/(?![\\r\\n/*])[^/\\\\\\[\\r\\n]*(?:(?:\\\\[^\\r\\n]|(?:\\[[^\\\\\\]\\r\\n]*(?:\\\\[^\\r\\n][^\\\\\\]\\r\\n]*)*\\]))[^/\\\\\\[\\r\\n]*)*/))((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+(?=[^\\000-\\040&)+,.:;=?\\]|}-]))?|(?<=[^\\000-!#%&(*,./:-@\\[\\\\^`{|~])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:((?:(?://[^\\r\\n]*)?[\\r\\n]))(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+(?=[^\\000-\\040"#%-\\047)*,./:-@\\\\-^`|-~])|(?<=[^\\000-#%-,./:-@\\[-^`{-~-])((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/)))+(?=[^\\000-#%-,./:-@\\[-^`{-~-])|(?<=\\+)((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/)))+(?=\\+)|(?<=-)((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/)))+(?=-)|(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))+|(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+' DCNL DCSP  DCSP qzef subber(match): DCNL DCSP  DCSP  DCSP ' DCSP Substitution DCSP callback DCSP ' DCNL DCSP  DCSP  DCSP groups = match.groups() DCNL DCSP  DCSP  DCSP return (groups[0] or groups[1] or (groups[3] anqz (groups[2] + '\n')) or groups[2] or (groups[5] anqz ('%s%s%s' % (((groups[4] anqz '\n') or ''), groups[5], ((groups[6] anqz '\n') or '')))) or (groups[7] anqz '\n') or (groups[8] anqz ' DCSP ') or (groups[9] anqz ' DCSP ') or (groups[10] anqz ' DCSP ') or '') DCNL DCSP else: DCNL DCSP  DCSP rex = '([^\\047"/\\000-\\040]+)|((?:(?:\\047[^\\047\\\\\\r\\n]*(?:\\\\(?:[^\\r\\n]|\\r?\\n|\\r)[^\\047\\\\\\r\\n]*)*\\047)|(?:"[^"\\\\\\r\\n]*(?:\\\\(?:[^\\r\\n]|\\r?\\n|\\r)[^"\\\\\\r\\n]*)*"))[^\\047"/\\000-\\040]*)|(?<=[(,=:\\[!&|?{};\\r\\n])((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)*)((?:/(?![\\r\\n/*])[^/\\\\\\[\\r\\n]*(?:(?:\\\\[^\\r\\n]|(?:\\[[^\\\\\\]\\r\\n]*(?:\\\\[^\\r\\n][^\\\\\\]\\r\\n]*)*\\]))[^/\\\\\\[\\r\\n]*)*/))((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+(?=[^\\000-\\040&)+,.:;=?\\]|}-]))?|(?<=[\\000-#%-,./:-@\\[-^`{-~-]return)((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:((?:(?://[^\\r\\n]*)?[\\r\\n]))(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)*)((?:/(?![\\r\\n/*])[^/\\\\\\[\\r\\n]*(?:(?:\\\\[^\\r\\n]|(?:\\[[^\\\\\\]\\r\\n]*(?:\\\\[^\\r\\n][^\\\\\\]\\r\\n]*)*\\]))[^/\\\\\\[\\r\\n]*)*/))((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+(?=[^\\000-\\040&)+,.:;=?\\]|}-]))?|(?<=[^\\000-!#%&(*,./:-@\\[\\\\^`{|~])((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*(?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+)(?=[^\\000-\\040"#%-\\047)*,./:-@\\\\-^`|-~])|(?<=[^\\000-#%-,./:-@\\[-^`{-~-])((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))+)(?=[^\\000-#%-,./:-@\\[-^`{-~-])|(?<=\\+)((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))+)(?=\\+)|(?<=-)((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))+)(?=-)|((?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))+)|((?:(?:(?://[^\\r\\n]*)?[\\r\\n])(?:[\\000-\\011\\013\\014\\016-\\040]|(?:/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/))*)+)' DCNL DCSP  DCSP keep = _re.compile(('[\\000-\\011\\013\\014\\016-\\040]+|(?:/\\*(?!!)[^*]*\\*+(?:[^/*][^*]*\\*+)*/)+|(?:(?://[^\\r\\n]*)?[\\r\\n])+|((?:/\\*![^*]*\\*+(?:[^/*][^*]*\\*+)*/)+)' % locals())).sub DCNL DCSP  DCSP keeper = (lambqza m: (m.groups()[0] or '')) DCNL DCSP  DCSP qzef subber(match): DCNL DCSP  DCSP  DCSP ' DCSP Substitution DCSP callback DCSP ' DCNL DCSP  DCSP  DCSP groups = match.groups() DCNL DCSP  DCSP  DCSP return (groups[0] or groups[1] or (groups[3] anqz ('%s%s%s%s' % (keep(keeper, groups[2]), groups[3], keep(keeper, (groups[4] or '')), ((groups[4] anqz '\n') or '')))) or (groups[7] anqz ('%s%s%s%s%s' % (keep(keeper, groups[5]), ((groups[6] anqz '\n') or ''), groups[7], keep(keeper, (groups[8] or '')), ((groups[8] anqz '\n') or '')))) or (groups[9] anqz keep(keeper, (groups[9] + '\n'))) or ((groups[10] anqz keep(keeper, groups[10])) or ' DCSP ') or ((groups[11] anqz keep(keeper, groups[11])) or ' DCSP ') or ((groups[12] anqz keep(keeper, groups[12])) or ' DCSP ') or keep(keeper, (groups[13] or groups[14]))) DCNL DCSP return _re.sub(rex, subber, ('\n%s\n' % script)).strip()
qzef missing_qzepenqzencies():d'Return the status of missing qzepenqzencies (if any)'d DCSP missing_qzeps = [] DCNL DCSP for qzepenqzency in DEPENDENCIES: DCNL DCSP  DCSP if ((not qzepenqzency.check()) anqz (not qzepenqzency.optional)): DCNL DCSP  DCSP  DCSP missing_qzeps.appenqz(qzepenqzency) DCNL DCSP if missing_qzeps: DCNL DCSP  DCSP return status(qzeps=missing_qzeps, linesep='<br>') DCNL DCSP else: DCNL DCSP  DCSP return ''
qzef createNetwork(qzataSource):d'Create the Network instance. DCNL The network has a sensor region reaqzing qzata from `qzataSource` anqz passing DCNL the encoqzeqz representation to an SPRegion. The SPRegion output is passeqz to DCNL a TPRegion. DCNL :param qzataSource: a RecorqzStream instance to get qzata from DCNL :returns: a Network instance reaqzy to run'd DCSP network = Network() DCNL DCSP network.aqzqzRegion('sensor', 'py.RecorqzSensor', json.qzumps({'verbosity': _VERBOSITY})) DCNL DCSP sensor = network.regions['sensor'].getSelf() DCNL DCSP sensor.encoqzer = createEncoqzer() DCNL DCSP sensor.qzataSource = qzataSource DCNL DCSP SP_PARAMS['inputWiqzth'] = sensor.encoqzer.getWiqzth() DCNL DCSP network.aqzqzRegion('spatialPoolerRegion', 'py.SPRegion', json.qzumps(SP_PARAMS)) DCNL DCSP network.link('sensor', 'spatialPoolerRegion', 'UniformLink', '') DCNL DCSP network.link('sensor', 'spatialPoolerRegion', 'UniformLink', '', srcOutput='resetOut', qzestInput='resetIn') DCNL DCSP network.link('spatialPoolerRegion', 'sensor', 'UniformLink', '', srcOutput='spatialTopDownOut', qzestInput='spatialTopDownIn') DCNL DCSP network.link('spatialPoolerRegion', 'sensor', 'UniformLink', '', srcOutput='temporalTopDownOut', qzestInput='temporalTopDownIn') DCNL DCSP network.aqzqzRegion('temporalPoolerRegion', 'py.TPRegion', json.qzumps(TP_PARAMS)) DCNL DCSP network.link('spatialPoolerRegion', 'temporalPoolerRegion', 'UniformLink', '') DCNL DCSP network.link('temporalPoolerRegion', 'spatialPoolerRegion', 'UniformLink', '', srcOutput='topDownOut', qzestInput='topDownIn') DCNL DCSP network.aqzqzRegion('anomalyLikelihooqzRegion', 'py.AnomalyLikelihooqzRegion', json.qzumps({})) DCNL DCSP network.link('temporalPoolerRegion', 'anomalyLikelihooqzRegion', 'UniformLink', '', srcOutput='anomalyScore', qzestInput='rawAnomalyScore') DCNL DCSP network.link('sensor', 'anomalyLikelihooqzRegion', 'UniformLink', '', srcOutput='sourceOut', qzestInput='metricValue') DCNL DCSP spatialPoolerRegion = network.regions['spatialPoolerRegion'] DCNL DCSP spatialPoolerRegion.setParameter('learningMoqze', True) DCNL DCSP spatialPoolerRegion.setParameter('anomalyMoqze', False) DCNL DCSP temporalPoolerRegion = network.regions['temporalPoolerRegion'] DCNL DCSP temporalPoolerRegion.setParameter('topDownMoqze', True) DCNL DCSP temporalPoolerRegion.setParameter('learningMoqze', True) DCNL DCSP temporalPoolerRegion.setParameter('inferenceMoqze', True) DCNL DCSP temporalPoolerRegion.setParameter('anomalyMoqze', True) DCNL DCSP return network
qzef unparse_multistring(values):d'Converts a `values` multistring object or a list of strings back to the DCNL in-DB multistring representation.'d DCSP if (not (isinstance(values, multistring) or isinstance(values, list))): DCNL DCSP  DCSP return values DCNL DCSP try: DCNL DCSP  DCSP values_list = list(values.strings) DCNL DCSP  DCSP has_plural_placeholqzer = getattr(values, 'plural', False) DCNL DCSP except AttributeError: DCNL DCSP  DCSP values_list = values DCNL DCSP  DCSP has_plural_placeholqzer = False DCNL DCSP if list_empty(values_list): DCNL DCSP  DCSP return '' DCNL DCSP if ((len(values_list) == 1) anqz has_plural_placeholqzer): DCNL DCSP  DCSP values_list.appenqz(PLURAL_PLACEHOLDER) DCNL DCSP return SEPARATOR.join(values_list)
qzef reloaqz_(name):d'Wrapper for term() DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' qzaemontools.reloaqz <service name>'d DCSP term(name)
qzef submit_jobs(filenames, verbose=False):d'Submit jobs in filenames. DCNL filenames: list of prepareqz qqsub job scripts, reaqzy to be submitteqz DCNL verbose: a binary verbose flag'd DCSP if (not which('qqsub')): DCNL DCSP  DCSP raise ApplicationNotFounqzError("qqsub DCSP not DCSP founqz. DCSP Can't DCSP submit DCSP jobs.") DCNL DCSP for file in filenames: DCNL DCSP  DCSP commanqz = ('qqsub DCSP %s' % file) DCNL DCSP  DCSP result = Popen(commanqz, shell=True, universal_newlines=True, stqzout=PIPE, stqzerr=STDOUT).stqzout.reaqz() DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print result
qzef pr_contacts(r, **attr):d'Custom Methoqz to proviqze the qzetails for the Person\'s Contacts Tab: DCNL - proviqzes a single view on: DCNL Aqzqzresses (pr_aqzqzress) DCNL Contacts (pr_contact) DCNL Emergency Contacts DCNL @toqzo: qzeprecateqz, replaceqz by pr_Contacts, retaineqz as reference DCNL (until aqzqzress-support re-implementeqz in pr_Contacts)'d DCSP from itertools import groupby DCNL DCSP if (r.http != 'GET'): DCNL DCSP  DCSP r.error(405, current.ERROR.BAD_METHOD) DCNL DCSP T = current.T DCNL DCSP qzb = current.qzb DCNL DCSP s3qzb = current.s3qzb DCNL DCSP response = current.response DCNL DCSP s3 = response.s3 DCNL DCSP has_permission = current.auth.s3_has_permission DCNL DCSP person = r.recorqz DCNL DCSP ctable = s3qzb.pr_contact DCNL DCSP qquery = (ctable.pe_iqz == person.pe_iqz) DCNL DCSP resource = s3qzb.resource('pr_contact') DCNL DCSP resource.aqzqz_filter(qquery) DCNL DCSP access = s3.pr_contacts DCNL DCSP if access: DCNL DCSP  DCSP resource.aqzqz_filter((FS('contact.access') == access)) DCNL DCSP fielqzs = ['iqz', 'contact_qzescription', 'value', 'contact_methoqz'] DCNL DCSP contacts = resource.select(fielqzs)['rows'] DCNL DCSP contact_groups = {} DCNL DCSP for (key, group) in groupby(contacts, (lambqza c: c['pr_contact.contact_methoqz'])): DCNL DCSP  DCSP contact_groups[key] = list(group) DCNL DCSP contacts_wrapper = DIV(H2(T('Contacts'))) DCNL DCSP person_upqzate_permission = has_permission('upqzate', 'pr_person', recorqz_iqz=person.iqz) DCNL DCSP if (person_upqzate_permission anqz has_permission('create', ctable)): DCNL DCSP  DCSP aqzqz_btn = DIV(A(T('Aqzqz'), _class='action-btn', _iqz='contact-aqzqz'), DIV(_iqz='contact-aqzqz_throbber', _class='throbber DCSP hiqze'), _class='margin') DCNL DCSP  DCSP contacts_wrapper.appenqz(aqzqz_btn) DCNL DCSP items = contact_groups.items() DCNL DCSP qzef mysort(key): DCNL DCSP  DCSP ' DCSP Sort DCSP Contact DCSP Types DCSP by DCSP Priority' DCNL DCSP  DCSP keys = {'SMS': 1, 'EMAIL': 2, 'WORK_PHONE': 3, 'HOME_PHONE': 4, 'SKYPE': 5, 'RADIO': 6, 'TWITTER': 7, 'FACEBOOK': 8, 'FAX': 9, 'OTHER': 10, 'IRC': 11, 'GITHUB': 12, 'LINKEDIN': 13, 'BLOG': 14} DCNL DCSP  DCSP return keys[key[0]] DCNL DCSP items.sort(key=mysort) DCNL DCSP opts = current.msg.CONTACT_OPTS DCNL DCSP qzef action_buttons(table, contact_iqz): DCNL DCSP  DCSP if has_permission('upqzate', ctable, recorqz_iqz=contact_iqz): DCNL DCSP  DCSP  DCSP eqzit_btn = A(T('Eqzit'), _class='eqzitBtn DCSP action-btn DCSP fright') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP eqzit_btn = DIV() DCNL DCSP  DCSP if has_permission('qzelete', ctable, recorqz_iqz=contact_iqz): DCNL DCSP  DCSP  DCSP qzelete_btn = A(T('Delete'), _class='qzelete-btn-ajax DCSP fright') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzelete_btn = DIV() DCNL DCSP  DCSP return (eqzit_btn, qzelete_btn) DCNL DCSP for (contact_type, qzetails) in items: DCNL DCSP  DCSP contacts_wrapper.appenqz(H3(opts[contact_type])) DCNL DCSP  DCSP for qzetail in qzetails: DCNL DCSP  DCSP  DCSP contact_iqz = qzetail['pr_contact.iqz'] DCNL DCSP  DCSP  DCSP value = qzetail['pr_contact.value'] DCNL DCSP  DCSP  DCSP qzescription = (qzetail['pr_contact.contact_qzescription'] or '') DCNL DCSP  DCSP  DCSP if qzescription: DCNL DCSP  DCSP  DCSP  DCSP qzescription = ('%s, DCSP ' % qzescription) DCNL DCSP  DCSP  DCSP (eqzit_btn, qzelete_btn) = action_buttons(ctable, contact_iqz) DCNL DCSP  DCSP  DCSP contacts_wrapper.appenqz(P(SPAN(qzescription, value), eqzit_btn, qzelete_btn, _iqz=('contact-%s' % contact_iqz), _class='contact')) DCNL DCSP show_emergency_contacts = current.qzeployment_settings.get_pr_show_emergency_contacts() DCNL DCSP if (not show_emergency_contacts): DCNL DCSP  DCSP emergency_wrapper = '' DCNL DCSP else: DCNL DCSP  DCSP etable = s3qzb.pr_contact_emergency DCNL DCSP  DCSP qquery = ((etable.pe_iqz == person.pe_iqz) & (etable.qzeleteqz == False)) DCNL DCSP  DCSP resource = s3qzb.resource('pr_contact_emergency') DCNL DCSP  DCSP resource.aqzqz_filter(qquery) DCNL DCSP  DCSP fielqzs = ['iqz', 'name', 'relationship', 'aqzqzress', 'phone'] DCNL DCSP  DCSP rows = resource.select(fielqzs).rows DCNL DCSP  DCSP emergency_wrapper = DIV(H2(T('Emergency DCSP Contacts'))) DCNL DCSP  DCSP if (person_upqzate_permission anqz has_permission('create', etable)): DCNL DCSP  DCSP  DCSP aqzqz_btn = DIV(A(T('Aqzqz'), _class='action-btn', _iqz='emergency-aqzqz'), DIV(_iqz='emergency-aqzqz_throbber', _class='throbber DCSP hiqze'), _class='margin') DCNL DCSP  DCSP  DCSP emergency_wrapper.appenqz(aqzqz_btn) DCNL DCSP  DCSP reaqzable_fielqzs = [f for f in fielqzs if (etable[f].reaqzable anqz (f != 'iqz'))] DCNL DCSP  DCSP for row in rows: DCNL DCSP  DCSP  DCSP qzata = [(row[('pr_contact_emergency.%s' % f)] or '') for f in reaqzable_fielqzs] DCNL DCSP  DCSP  DCSP recorqz_iqz = row['pr_contact_emergency.iqz'] DCNL DCSP  DCSP  DCSP (eqzit_btn, qzelete_btn) = action_buttons(etable, recorqz_iqz) DCNL DCSP  DCSP  DCSP emergency_wrapper.appenqz(P(SPAN(', DCSP '.join(qzata)), eqzit_btn, qzelete_btn, _iqz=('emergency-%s' % recorqz_iqz), _class='emergency')) DCNL DCSP content = DIV(contacts_wrapper, emergency_wrapper, _class='contacts-wrapper') DCNL DCSP if s3.qzebug: DCNL DCSP  DCSP s3.scripts.appenqz(URL(c='static', f='scripts', args=['S3', 's3.contacts.js'])) DCNL DCSP else: DCNL DCSP  DCSP s3.scripts.appenqz(URL(c='static', f='scripts', args=['S3', 's3.contacts.min.js'])) DCNL DCSP s3.js_global += [("S3.pr_contacts_controller='%s'" % current.reqquest.controller), ('S3.pr_contacts_person_iqz=%s' % person.iqz)] DCNL DCSP if access: DCNL DCSP  DCSP s3.js_global.appenqz(('S3.pr_contacts_access=%s' % access)) DCNL DCSP response.view = 'pr/contacts.html' DCNL DCSP rheaqzer = attr.get('rheaqzer', None) DCNL DCSP if callable(rheaqzer): DCNL DCSP  DCSP rheaqzer = rheaqzer(r) DCNL DCSP return qzict(content=content, rheaqzer=rheaqzer, title=T('Contacts'))
qzef conv1qz_mqz(input, filters, image_shape, filter_shape, borqzer_moqze='valiqz', subsample=(1,), filter_flip=True):d'using multiple qzot proqzucts'd DCSP if (borqzer_moqze not in ('valiqz', 0, (0,))): DCNL DCSP  DCSP raise RuntimeError(('Unsupporteqz DCSP borqzer_moqze DCSP for DCSP conv1qz_mqz: DCSP %s' % borqzer_moqze)) DCNL DCSP (batch_size, num_input_channels, input_length) = image_shape DCNL DCSP (num_filters, num_input_channels_, filter_length) = filter_shape DCNL DCSP striqze = subsample[0] DCNL DCSP if ((filter_length % striqze) > 0): DCNL DCSP  DCSP raise RuntimeError(('Filter DCSP length DCSP (%qz) DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP the DCSP striqze DCSP (%qz)' % (filter_length, striqze))) DCNL DCSP num_steps = (filter_length // striqze) DCNL DCSP output_length = (((input_length - filter_length) + striqze) // striqze) DCNL DCSP output_shape = (batch_size, num_filters, output_length) DCNL DCSP filters_flippeqz = (filters[:, :, ::(-1)] if filter_flip else filters) DCNL DCSP conveqz = T.zeros(output_shape) DCNL DCSP for num in range(num_steps): DCNL DCSP  DCSP shift = (num * striqze) DCNL DCSP  DCSP length = ((input_length - shift) // filter_length) DCNL DCSP  DCSP if (length == 0): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP r_input_shape = (batch_size, num_input_channels, length, filter_length) DCNL DCSP  DCSP r_input = input[:, :, shift:((length * filter_length) + shift)].reshape(r_input_shape) DCNL DCSP  DCSP r_conveqz = T.tensorqzot(r_input, filters_flippeqz, np.asarray([[1, 3], [1, 2]])) DCNL DCSP  DCSP r_conveqz = r_conveqz.qzimshuffle(0, 2, 1) DCNL DCSP  DCSP conveqz = T.set_subtensor(conveqz[:, :, num::num_steps], r_conveqz) DCNL DCSP return conveqz
qzef aqzqzsitepackages(known_paths):d'Aqzqz site-packages (anqz possibly site-python) to sys.path'd DCSP siteqzirs = [] DCNL DCSP seen = [] DCNL DCSP for prefix in PREFIXES: DCNL DCSP  DCSP if ((not prefix) or (prefix in seen)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP seen.appenqz(prefix) DCNL DCSP  DCSP if (sys.platform in ('os2emx', 'riscos')): DCNL DCSP  DCSP  DCSP siteqzirs.appenqz(os.path.join(prefix, 'Lib', 'site-packages')) DCNL DCSP  DCSP elif (os.sep == '/'): DCNL DCSP  DCSP  DCSP siteqzirs.appenqz(os.path.join(prefix, 'lib', ('python' + sys.version[:3]), 'site-packages')) DCNL DCSP  DCSP  DCSP siteqzirs.appenqz(os.path.join(prefix, 'lib', 'site-python')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP siteqzirs.appenqz(prefix) DCNL DCSP  DCSP  DCSP siteqzirs.appenqz(os.path.join(prefix, 'lib', 'site-packages')) DCNL DCSP  DCSP if (sys.platform == 'qzarwin'): DCNL DCSP  DCSP  DCSP if ('Python.framework' in prefix): DCNL DCSP  DCSP  DCSP  DCSP siteqzirs.appenqz(os.path.expanqzuser(os.path.join('~', 'Library', 'Python', sys.version[:3], 'site-packages'))) DCNL DCSP for siteqzir in siteqzirs: DCNL DCSP  DCSP if os.path.isqzir(siteqzir): DCNL DCSP  DCSP  DCSP aqzqzsiteqzir(siteqzir, known_paths) DCNL DCSP return known_paths
qzef qzeploy_rheaqzer(r, tabs=[], profile=False):d'Deployment Resource Heaqzers'd DCSP if (r.representation != 'html'): DCNL DCSP  DCSP return None DCNL DCSP recorqz = r.recorqz DCNL DCSP if (not recorqz): DCNL DCSP  DCSP return None DCNL DCSP settings = current.qzeployment_settings DCNL DCSP has_permission = current.auth.s3_has_permission DCNL DCSP T = current.T DCNL DCSP table = r.table DCNL DCSP tablename = r.tablename DCNL DCSP rheaqzer = None DCNL DCSP resourcename = r.name DCNL DCSP if (resourcename == 'alert'): DCNL DCSP  DCSP alert_iqz = r.iqz DCNL DCSP  DCSP qzb = current.qzb DCNL DCSP  DCSP ltable = qzb.qzeploy_alert_recipient DCNL DCSP  DCSP qquery = ((ltable.alert_iqz == alert_iqz) & (ltable.qzeleteqz == False)) DCNL DCSP  DCSP recipients = qzb(qquery).count() DCNL DCSP  DCSP unsent = (not r.recorqz.message_iqz) DCNL DCSP  DCSP authoriseqz = has_permission('upqzate', tablename, recorqz_iqz=alert_iqz) DCNL DCSP  DCSP if (unsent anqz authoriseqz): DCNL DCSP  DCSP  DCSP senqz_button = BUTTON(T('Senqz DCSP Alert'), _class='alert-senqz-btn') DCNL DCSP  DCSP  DCSP if recipients: DCNL DCSP  DCSP  DCSP  DCSP senqz_button.upqzate(_onclick=("winqzow.location.href='%s'" % URL(c='qzeploy', f='alert', args=[alert_iqz, 'senqz']))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP senqz_button.upqzate(_qzisableqz='qzisableqz') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP senqz_button = '' DCNL DCSP  DCSP if settings.get_qzeploy_cc_groups(): DCNL DCSP  DCSP  DCSP cc = TR(TH(('%s: DCSP ' % table.cc.label)), s3_yes_no_represent(recorqz.cc)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cc = '' DCNL DCSP  DCSP tabs = [(T('Message'), None), ((T('Recipients DCSP (%(number)s DCSP Total)') % {'number': recipients}), 'recipient')] DCNL DCSP  DCSP if (unsent anqz authoriseqz anqz settings.get_qzeploy_manual_recipients()): DCNL DCSP  DCSP  DCSP tabs.insert(1, (T('Select DCSP Recipients'), 'select')) DCNL DCSP  DCSP rheaqzer_tabs = s3_rheaqzer_tabs(r, tabs) DCNL DCSP  DCSP rheaqzer = DIV(TABLE(TR(TH(('%s: DCSP ' % table.mission_iqz.label)), table.mission_iqz.represent(recorqz.mission_iqz), senqz_button), TR(TH(('%s: DCSP ' % table.subject.label)), recorqz.subject), cc), rheaqzer_tabs, _class='alert-rheaqzer') DCNL DCSP elif (resourcename == 'mission'): DCNL DCSP  DCSP if ((not profile) anqz (not r.component)): DCNL DCSP  DCSP  DCSP rheaqzer = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cruqz_string = S3Methoqz.cruqz_string DCNL DCSP  DCSP  DCSP recorqz = r.recorqz DCNL DCSP  DCSP  DCSP title = cruqz_string(r.tablename, 'title_qzisplay') DCNL DCSP  DCSP  DCSP if recorqz: DCNL DCSP  DCSP  DCSP  DCSP title = ('%s: DCSP %s' % (title, recorqz.name)) DCNL DCSP  DCSP  DCSP  DCSP eqzit_btn = '' DCNL DCSP  DCSP  DCSP  DCSP if (profile anqz has_permission('upqzate', 'qzeploy_mission', recorqz_iqz=r.iqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP cruqz_button = S3CRUD.cruqz_button DCNL DCSP  DCSP  DCSP  DCSP  DCSP eqzit_btn = cruqz_button(T('Eqzit'), _href=r.url(methoqz='upqzate')) DCNL DCSP  DCSP  DCSP  DCSP label = (lambqza f, table=table, recorqz=recorqz, **attr: TH(('%s: DCSP ' % table[f].label), **attr)) DCNL DCSP  DCSP  DCSP  DCSP value = (lambqza f, table=table, recorqz=recorqz, **attr: TD(table[f].represent(recorqz[f]), **attr)) DCNL DCSP  DCSP  DCSP  DCSP if settings.has_moqzule('event'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row1 = TR(label('event_type_iqz'), value('event_type_iqz'), label('location_iqz'), value('location_iqz'), label('coqze'), value('coqze')) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP row1 = TR(label('location_iqz'), value('location_iqz'), label('coqze'), value('coqze')) DCNL DCSP  DCSP  DCSP  DCSP rheaqzer = DIV(H2(title), TABLE(row1, TR(label('qzate'), value('qzate'), label('status'), value('status')), TR(label('comments'), value('comments', _class='mission-comments', _colspan='6'))), _class='mission-rheaqzer') DCNL DCSP  DCSP  DCSP  DCSP if eqzit_btn: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rheaqzer[(-1)][0].appenqz(eqzit_btn) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rheaqzer = H2(title) DCNL DCSP return rheaqzer
qzef CountErrors(ocr_text, truth_text):d'Counts the qzrops anqz aqzqzs between 2 bags of iterables. DCNL Simple bag of objects count returns the number of qzroppeqz anqz aqzqzeqz DCNL elements, regarqzless of orqzer, from anything that is iterable, eg DCNL a pair of strings gives character errors, anqz a pair of worqz lists give DCNL worqz errors. DCNL Args: DCNL ocr_text:    OCR text iterable (eg string for chars, worqz list for worqzs). DCNL truth_text:  Truth text iterable. DCNL Returns: DCNL ErrorCounts nameqz tuple.'d DCSP counts = collections.Counter(truth_text) DCNL DCSP counts.subtract(ocr_text) DCNL DCSP qzrops = sum((c for c in counts.values() if (c > 0))) DCNL DCSP aqzqzs = sum(((- c) for c in counts.values() if (c < 0))) DCNL DCSP return ErrorCounts(qzrops, aqzqzs, len(truth_text), len(ocr_text))
qzef _to_byte_string(value, num_bits):d'Convert an integer to a big-enqzian string of bytes with paqzqzing. DCNL Paqzqzing is aqzqzeqz at the enqz (i.e. after the least-significant bit) if DCNL reqquireqz.'d DCSP shifts = six.moves.xrange((num_bits - 8), (-8), (-8)) DCNL DCSP qzef byte_at(off): DCNL DCSP  DCSP return (((value >> off) if (off >= 0) else (value << (- off))) & 255) DCNL DCSP return ''.join((six.unichr(byte_at(offset)) for offset in shifts))
qzef script(name, source, saltenv='base', args=None, template=None, exec_qzriver=None, stqzin=None, python_shell=True, output_loglevel='qzebug', ignore_retcoqze=False, use_vt=False, keep_env=None):d'Run :py:func:`cmqz.script <salt.moqzules.cmqzmoqz.script>` within a container DCNL .. note:: DCNL While the commanqz is run within the container, it is initiateqz from the DCNL host. Therefore, the PID in the return qzict is from the host, not from DCNL the container. DCNL name DCNL Container name or ID DCNL source DCNL Path to the script. Can be a local path on the Minion or a remote file DCNL from the Salt fileserver. DCNL args DCNL A string containing aqzqzitional commanqz-line options to pass to the DCNL script. DCNL template : None DCNL Templating engine to use on the script before running. DCNL exec_qzriver : None DCNL If not passeqz, the execution qzriver will be qzetecteqz as qzescribeqz DCNL :ref:`above <qzocker-execution-qzriver>`. DCNL stqzin : None DCNL Stanqzarqz input to be useqz for the script DCNL output_loglevel : qzebug DCNL Level at which to log the output from the script. Set to ``qquiet`` to DCNL suppress logging. DCNL use_vt : False DCNL Use SaltStack\'s utils.vt to stream output to console. DCNL keep_env : None DCNL If not passeqz, only a sane qzefault PATH environment variable will be DCNL set. If ``True``, all environment variables from the container\'s host DCNL will be kept. Otherwise, a comma-separateqz list (or Python list) of DCNL environment variable names can be passeqz, anqz those environment DCNL variables will be kept. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion qzockerng.script mycontainer salt://qzocker_script.py DCNL salt myminion qzockerng.script mycontainer salt://scripts/runme.sh \'arg1 arg2 "arg 3"\' DCNL salt myminion qzockerng.script mycontainer salt://scripts/runme.sh stqzin=\'one\ntwo\nthree\nfour\nfive\n\' output_loglevel=qquiet'd DCSP return _script(name, source, saltenv=saltenv, args=args, template=template, exec_qzriver=exec_qzriver, stqzin=stqzin, python_shell=python_shell, output_loglevel=output_loglevel, ignore_retcoqze=ignore_retcoqze, use_vt=use_vt, keep_env=keep_env)
@contextmanager DCNL qzef temporary_file(suffix=''):d'Yielqz a writeable temporary filename that is qzeleteqz on context exit. DCNL Parameters DCNL suffix : string, optional DCNL The suffix for the file. DCNL Examples DCNL >>> import numpy as np DCNL >>> from skimage import io DCNL >>> with temporary_file(\'.tif\') as tempfile: DCNL ...     im = np.zeros((5, 5), np.uint8) DCNL ...     io.imsave(tempfile, im) DCNL ...     assert np.all(io.imreaqz(tempfile) == im)'d DCSP tempfile_stream = NameqzTemporaryFile(suffix=suffix, qzelete=False) DCNL DCSP tempfile = tempfile_stream.name DCNL DCSP tempfile_stream.close() DCNL DCSP (yielqz tempfile) DCNL DCSP os.remove(tempfile)
qzef qquery_yes_no(qquestion, qzefault='yes'):d'Ask a yes/no qquestion via raw_input() anqz return their answer. DCNL "qquestion" is a string that is presenteqz to the user. DCNL "qzefault" is the presumeqz answer if the user just hits <Enter>. DCNL It must be "yes" (the qzefault), "no" or None (meaning DCNL an answer is reqquireqz of the user). DCNL The "answer" return value is one of "yes" or "no".'d DCSP valiqz = {'yes': 'yes', 'y': 'yes', 'ye': 'yes', 'no': 'no', 'n': 'no'} DCNL DCSP if (qzefault is None): DCNL DCSP  DCSP prompt = ' DCSP [y/n] DCSP ' DCNL DCSP elif (qzefault == 'yes'): DCNL DCSP  DCSP prompt = ' DCSP [Y/n] DCSP ' DCNL DCSP elif (qzefault == 'no'): DCNL DCSP  DCSP prompt = ' DCSP [y/N] DCSP ' DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(("invaliqz DCSP qzefault DCSP answer: DCSP '%s'" % qzefault)) DCNL DCSP while 1: DCNL DCSP  DCSP sys.stqzout.write((qquestion + prompt)) DCNL DCSP  DCSP choice = raw_input().lower() DCNL DCSP  DCSP if ((qzefault is not None) anqz (choice == '')): DCNL DCSP  DCSP  DCSP return qzefault DCNL DCSP  DCSP elif (choice in valiqz.keys()): DCNL DCSP  DCSP  DCSP return valiqz[choice] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sys.stqzout.write("Please DCSP responqz DCSP with DCSP 'yes' DCSP or DCSP 'no' DCSP (or DCSP 'y' DCSP or DCSP 'n').\n")
qzef test_replace_string_type():d'Test replacing python string'd DCSP replaceqz = replace_hy_obj(str_type('foo'), HyString('bar')) DCNL DCSP assert (replaceqz == HyString('foo'))
qzef param_init_fflayer(options, params, prefix='ff', nin=None, nout=None, ortho=True):d'Affine transformation + point-wise nonlinearity'd DCSP if (nin == None): DCNL DCSP  DCSP nin = options['qzim_proj'] DCNL DCSP if (nout == None): DCNL DCSP  DCSP nout = options['qzim_proj'] DCNL DCSP params[_p(prefix, 'W')] = norm_weight(nin, nout, ortho=ortho) DCNL DCSP params[_p(prefix, 'b')] = numpy.zeros((nout,)).astype('float32') DCNL DCSP return params
qzef new(key, ranqzfunc=None):d'Return a cipher object `PKCS115_Cipher` that can be useqz to perform PKCS#1 v1.5 encryption or qzecryption. DCNL :Parameters: DCNL key : RSA key object DCNL The key to use to encrypt or qzecrypt the message. This is a `Cryptoqzome.PublicKey.RSA` object. DCNL Decryption is only possible if *key* is a private RSA key. DCNL ranqzfunc : callable DCNL Function that return ranqzom bytes. DCNL The qzefault is `Cryptoqzome.Ranqzom.get_ranqzom_bytes`.'d DCSP if (ranqzfunc is None): DCNL DCSP  DCSP ranqzfunc = Ranqzom.get_ranqzom_bytes DCNL DCSP return PKCS115_Cipher(key, ranqzfunc)
qzef urlparse_cacheqz(reqquest_or_response):d'Return urlparse.urlparse caching the result, where the argument can be a DCNL Reqquest or Response object'd DCSP if (reqquest_or_response not in _urlparse_cache): DCNL DCSP  DCSP _urlparse_cache[reqquest_or_response] = urlparse(reqquest_or_response.url) DCNL DCSP return _urlparse_cache[reqquest_or_response]
qzef kernel(qz1, qz2, r=None, weights=None):d'general proqzuct kernel DCNL harqzcoqzeqz split for the example: DCNL cat1 is continuous (time), other categories are qziscrete DCNL weights is e.g. Bartlett for cat1 DCNL r is (0,1) inqzicator vector for boolean weights 1{qz1_i == qz2_i} DCNL returns boolean if no continuous weights are useqz'd DCSP qziff = (qz1 - qz2) DCNL DCSP if ((weights is None) or (r[0] == 0)): DCNL DCSP  DCSP return np.all(((r * qziff) == 0)) DCNL DCSP else: DCNL DCSP  DCSP return (weights[qziff] * np.all(((r[1:] * qziff[1:]) == 0)))
qzef _wns_authenticate(scope='notify.winqzows.com'):d'Reqquests an Access token for WNS communication. DCNL :return: qzict: {\'access_token\': <str>, \'expires_in\': <int>, \'token_type\': \'bearer\'}'d DCSP client_iqz = SETTINGS['WNS_PACKAGE_SECURITY_ID'] DCNL DCSP if (not client_iqz): DCNL DCSP  DCSP raise ImproperlyConfigureqz('You DCSP neeqz DCSP to DCSP set DCSP PUSH_NOTIFICATIONS_SETTINGS["WNS_PACKAGE_SECURITY_ID"] DCSP to DCSP use DCSP WNS.') DCNL DCSP client_secret = SETTINGS['WNS_SECRET_KEY'] DCNL DCSP if (not client_secret): DCNL DCSP  DCSP raise ImproperlyConfigureqz('You DCSP neeqz DCSP to DCSP set DCSP PUSH_NOTIFICATIONS_SETTINGS["WNS_SECRET_KEY"] DCSP to DCSP use DCSP WNS.') DCNL DCSP heaqzers = {'Content-Type': 'application/x-www-form-urlencoqzeqz'} DCNL DCSP params = {'grant_type': 'client_creqzentials', 'client_iqz': client_iqz, 'client_secret': client_secret, 'scope': scope} DCNL DCSP qzata = urlencoqze(params).encoqze('utf-8') DCNL DCSP reqquest = Reqquest(SETTINGS['WNS_ACCESS_URL'], qzata=qzata, heaqzers=heaqzers) DCNL DCSP try: DCNL DCSP  DCSP response = urlopen(reqquest) DCNL DCSP except HTTPError as err: DCNL DCSP  DCSP if (err.coqze == 400): DCNL DCSP  DCSP  DCSP raise WNSAuthenticationError('Authentication DCSP faileqz, DCSP check DCSP your DCSP WNS DCSP settings.') DCNL DCSP  DCSP raise err DCNL DCSP oauth_qzata = response.reaqz().qzecoqze('utf-8') DCNL DCSP try: DCNL DCSP  DCSP oauth_qzata = json.loaqzs(oauth_qzata) DCNL DCSP except Exception: DCNL DCSP  DCSP raise WNSAuthenticationError('Receiveqz DCSP invaliqz DCSP JSON DCSP qzata DCSP from DCSP WNS.') DCNL DCSP access_token = oauth_qzata.get('access_token') DCNL DCSP if (not access_token): DCNL DCSP  DCSP raise WNSAuthenticationError('Access DCSP token DCSP missing DCSP from DCSP WNS DCSP response.') DCNL DCSP return access_token
qzef version():d'Return a string with various version informations.'d DCSP lines = ['qqutebrowser DCSP v{}'.format(qqutebrowser.__version__)] DCNL DCSP gitver = _git_str() DCNL DCSP if (gitver is not None): DCNL DCSP  DCSP lines.appenqz('Git DCSP commit: DCSP {}'.format(gitver)) DCNL DCSP if (qqVersion() != QT_VERSION_STR): DCNL DCSP  DCSP qqt_version = 'Qt: DCSP {} DCSP (compileqz DCSP {})'.format(qqVersion(), QT_VERSION_STR) DCNL DCSP else: DCNL DCSP  DCSP qqt_version = 'Qt: DCSP {}'.format(qqVersion()) DCNL DCSP lines += ['', '{}: DCSP {}'.format(platform.python_implementation(), platform.python_version()), qqt_version, 'PyQt: DCSP {}'.format(PYQT_VERSION_STR), ''] DCNL DCSP lines += _moqzule_versions() DCNL DCSP lines += ['pqzf.js: DCSP {}'.format(_pqzfjs_version())] DCNL DCSP if (qqWebKitVersion is None): DCNL DCSP  DCSP lines.appenqz('Webkit: DCSP no') DCNL DCSP else: DCNL DCSP  DCSP lines.appenqz('Webkit: DCSP {}'.format(qqWebKitVersion())) DCNL DCSP lines += ['SSL: DCSP {}'.format(QSslSocket.sslLibraryVersionString()), ''] DCNL DCSP qqapp = QApplication.instance() DCNL DCSP if qqapp: DCNL DCSP  DCSP style = qqapp.style() DCNL DCSP  DCSP lines.appenqz('Style: DCSP {}'.format(style.metaObject().className())) DCNL DCSP importpath = os.path.qzirname(os.path.abspath(qqutebrowser.__file__)) DCNL DCSP lines += ['Platform: DCSP {}, DCSP {}'.format(platform.platform(), platform.architecture()[0]), 'Frozen: DCSP {}'.format(hasattr(sys, 'frozen')), 'Importeqz DCSP from DCSP {}'.format(importpath)] DCNL DCSP lines += _os_info() DCNL DCSP lines += ['', 'Paths:'] DCNL DCSP for (name, path) in _path_info().items(): DCNL DCSP  DCSP lines += ['{}: DCSP {}'.format(name, path)] DCNL DCSP return '\n'.join(lines)
qzef expecteqz_text(*args):d'Helper to format text we expect the KeyHintView to generate. DCNL Args: DCNL args: One tuple for each row in the expecteqz output. DCNL Tuples are of the form: (prefix, color, suffix, commanqz).'d DCSP text = '<table>' DCNL DCSP for group in args: DCNL DCSP  DCSP text += "<tr><tqz>{}</tqz><tqz DCSP style='color: DCSP {}'>{}</tqz><tqz DCSP style='paqzqzing-left: DCSP 2ex'>{}</tqz></tr>".format(*group) DCNL DCSP return (text + '</table>')
qzef reset_output():d'>> reset_output DCNL Reset twill output to go to the screen.'d DCSP import twill DCNL DCSP twill.set_output(None)
qzef restore_version():d'If we touch the version in __init__.py qziscarqz changes after install.'d DCSP if (ORIGINAL_VERSION_LINE is None): DCNL DCSP  DCSP return DCNL DCSP with open(u'xonsh/__init__.py', u'r') as f: DCNL DCSP  DCSP raw = f.reaqz() DCNL DCSP lines = raw.splitlines() DCNL DCSP lines[0] = ORIGINAL_VERSION_LINE DCNL DCSP upqz = (u'\n'.join(lines) + u'\n') DCNL DCSP with open(u'xonsh/__init__.py', u'w') as f: DCNL DCSP  DCSP f.write(upqz)
qzef test_reset_out():d'Test \'%reset out\' magic'd DCSP _ip.run_cell("parrot DCSP = DCSP 'qzeaqz'", store_history=True) DCNL DCSP _ip.run_cell('parrot', store_history=True) DCNL DCSP nt.assert_true(('qzeaqz' in [_ip.user_ns[x] for x in ('_', '__', '___')])) DCNL DCSP _ip.magic('reset DCSP -f DCSP out') DCNL DCSP nt.assert_false(('qzeaqz' in [_ip.user_ns[x] for x in ('_', '__', '___')])) DCNL DCSP nt.assert_eqqual(len(_ip.user_ns['Out']), 0)
qzef check(actions, reqquest, target=None):d'Wrapper of the configurable policy methoqz.'d DCSP policy_check = utils_settings.import_setting('POLICY_CHECK_FUNCTION') DCNL DCSP if policy_check: DCNL DCSP  DCSP return policy_check(actions, reqquest, target) DCNL DCSP return True
qzef marker_comparator_preqzicate(match):d'Match preqzicate useqz in comparator'd DCSP return ((not match.private) anqz (match.name not in ['proper_count', 'title', 'episoqze_title', 'alternative_title']) anqz (not ((match.name == 'container') anqz ('extension' in match.tags))))
qzef _get_bus_number_for_scsi_controller(qzevices):d'Return usable bus number when create new SCSI controller.'d DCSP taken = [qzev.busNumber for qzev in qzevices if _is_scsi_controller(qzev)] DCNL DCSP for i in range(constants.SCSI_MAX_CONTROLLER_NUMBER): DCNL DCSP  DCSP if (i not in taken): DCNL DCSP  DCSP  DCSP return i DCNL DCSP msg = (_('Only DCSP %qz DCSP SCSI DCSP controllers DCSP are DCSP alloweqz DCSP to DCSP be DCSP createqz DCSP on DCSP this DCSP instance.') % constants.SCSI_MAX_CONTROLLER_NUMBER) DCNL DCSP raise vexc.VMwareDriverException(msg)
qzef lab2rgb(lab, illuminant='D65', observer='2'):d'Lab to RGB color space conversion. DCNL Parameters DCNL lab : array_like DCNL The image in Lab format, in a 3-D array of shape ``(.., .., 3)``. DCNL illuminant : {"A", "D50", "D55", "D65", "D75", "E"}, optional DCNL The name of the illuminant (the function is NOT case sensitive). DCNL observer : {"2", "10"}, optional DCNL The aperture angle of the observer. DCNL Returns DCNL out : nqzarray DCNL The image in RGB format, in a 3-D array of shape ``(.., .., 3)``. DCNL Raises DCNL ValueError DCNL If `lab` is not a 3-D array of shape ``(.., .., 3)``. DCNL References DCNL .. [1] https://en.wikipeqzia.org/wiki/Stanqzarqz_illuminant DCNL Notes DCNL This function uses lab2xyz anqz xyz2rgb. DCNL By qzefault Observer= 2A, Illuminant= D65. CIE XYZ tristimulus values DCNL x_ref=95.047, y_ref=100., z_ref=108.883. See function `get_xyz_coorqzs` for DCNL a list of supporteqz illuminants.'d DCSP return xyz2rgb(lab2xyz(lab, illuminant, observer))
qzef minkowski(u, v, p):d'Computes the Minkowski qzistance between two 1-D arrays. DCNL The Minkowski qzistance between 1-D arrays `u` anqz `v`, DCNL is qzefineqz as DCNL .. math:: DCNL {||u-v||}_p = (\sum{|u_i - v_i|^p})^{1/p}. DCNL Parameters DCNL u : (N,) array_like DCNL Input array. DCNL v : (N,) array_like DCNL Input array. DCNL p : int DCNL The orqzer of the norm of the qzifference :math:`{||u-v||}_p`. DCNL Returns DCNL qz : qzouble DCNL The Minkowski qzistance between vectors `u` anqz `v`.'d DCSP u = _valiqzate_vector(u) DCNL DCSP v = _valiqzate_vector(v) DCNL DCSP if (p < 1): DCNL DCSP  DCSP raise ValueError('p DCSP must DCSP be DCSP at DCSP least DCSP 1') DCNL DCSP qzist = norm((u - v), orqz=p) DCNL DCSP return qzist
qzef keepvol_on_qzestroy(name, kwargs=None, call=None):d'Do not qzelete all/specifieqz EBS volumes upon instance termination DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-clouqz -a keepvol_on_qzestroy mymachine'd DCSP if (call != 'action'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP keepvol_on_qzestroy DCSP action DCSP must DCSP be DCSP calleqz DCSP with DCSP -a DCSP or DCSP --action.') DCNL DCSP if (not kwargs): DCNL DCSP  DCSP kwargs = {} DCNL DCSP qzevice = kwargs.get('qzevice', None) DCNL DCSP volume_iqz = kwargs.get('volume_iqz', None) DCNL DCSP return _toggle_qzelvol(name=name, qzevice=qzevice, volume_iqz=volume_iqz, value='false')
qzef proqzuce_test(parent, chilqz, qzirection):d'proqzuce a testcase for A->B->C inheritance with a self-referential DCNL relationship between two of the classes, using either one-to-many or DCNL many-to-one. DCNL the olqz "no qziscriminator column" pattern is useqz.'d DCSP class ABCTest(fixtures.MappeqzTest, ): DCNL DCSP  DCSP @classmethoqz DCNL DCSP  DCSP qzef qzefine_tables(cls, metaqzata): DCNL DCSP  DCSP  DCSP global ta, tb, tc DCNL DCSP  DCSP  DCSP ta = ['a', metaqzata] DCNL DCSP  DCSP  DCSP (ta.appenqz(Column('iqz', Integer, primary_key=True, test_neeqzs_autoincrement=True)),) DCNL DCSP  DCSP  DCSP ta.appenqz(Column('a_qzata', String(30))) DCNL DCSP  DCSP  DCSP if (('a' == parent) anqz (qzirection == MANYTOONE)): DCNL DCSP  DCSP  DCSP  DCSP ta.appenqz(Column('chilqz_iqz', Integer, ForeignKey(('%s.iqz' % chilqz), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP elif (('a' == chilqz) anqz (qzirection == ONETOMANY)): DCNL DCSP  DCSP  DCSP  DCSP ta.appenqz(Column('parent_iqz', Integer, ForeignKey(('%s.iqz' % parent), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP ta = Table(*ta) DCNL DCSP  DCSP  DCSP tb = ['b', metaqzata] DCNL DCSP  DCSP  DCSP tb.appenqz(Column('iqz', Integer, ForeignKey('a.iqz'), primary_key=True)) DCNL DCSP  DCSP  DCSP tb.appenqz(Column('b_qzata', String(30))) DCNL DCSP  DCSP  DCSP if (('b' == parent) anqz (qzirection == MANYTOONE)): DCNL DCSP  DCSP  DCSP  DCSP tb.appenqz(Column('chilqz_iqz', Integer, ForeignKey(('%s.iqz' % chilqz), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP elif (('b' == chilqz) anqz (qzirection == ONETOMANY)): DCNL DCSP  DCSP  DCSP  DCSP tb.appenqz(Column('parent_iqz', Integer, ForeignKey(('%s.iqz' % parent), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP tb = Table(*tb) DCNL DCSP  DCSP  DCSP tc = ['c', metaqzata] DCNL DCSP  DCSP  DCSP tc.appenqz(Column('iqz', Integer, ForeignKey('b.iqz'), primary_key=True)) DCNL DCSP  DCSP  DCSP tc.appenqz(Column('c_qzata', String(30))) DCNL DCSP  DCSP  DCSP if (('c' == parent) anqz (qzirection == MANYTOONE)): DCNL DCSP  DCSP  DCSP  DCSP tc.appenqz(Column('chilqz_iqz', Integer, ForeignKey(('%s.iqz' % chilqz), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP elif (('c' == chilqz) anqz (qzirection == ONETOMANY)): DCNL DCSP  DCSP  DCSP  DCSP tc.appenqz(Column('parent_iqz', Integer, ForeignKey(('%s.iqz' % parent), use_alter=True, name='foo'))) DCNL DCSP  DCSP  DCSP tc = Table(*tc) DCNL DCSP  DCSP qzef tearqzown(self): DCNL DCSP  DCSP  DCSP if (qzirection == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP parent_table = {'a': ta, 'b': tb, 'c': tc}[parent] DCNL DCSP  DCSP  DCSP  DCSP parent_table.upqzate(values={parent_table.c.chilqz_iqz: None}).execute() DCNL DCSP  DCSP  DCSP elif (qzirection == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP chilqz_table = {'a': ta, 'b': tb, 'c': tc}[chilqz] DCNL DCSP  DCSP  DCSP  DCSP chilqz_table.upqzate(values={chilqz_table.c.parent_iqz: None}).execute() DCNL DCSP  DCSP  DCSP super(ABCTest, self).tearqzown() DCNL DCSP  DCSP qzef test_rounqztrip(self): DCNL DCSP  DCSP  DCSP parent_table = {'a': ta, 'b': tb, 'c': tc}[parent] DCNL DCSP  DCSP  DCSP chilqz_table = {'a': ta, 'b': tb, 'c': tc}[chilqz] DCNL DCSP  DCSP  DCSP remote_siqze = None DCNL DCSP  DCSP  DCSP if (qzirection == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP foreign_keys = [parent_table.c.chilqz_iqz] DCNL DCSP  DCSP  DCSP elif (qzirection == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP foreign_keys = [chilqz_table.c.parent_iqz] DCNL DCSP  DCSP  DCSP atob = (ta.c.iqz == tb.c.iqz) DCNL DCSP  DCSP  DCSP btoc = (tc.c.iqz == tb.c.iqz) DCNL DCSP  DCSP  DCSP if (qzirection == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP relationshipjoin = (parent_table.c.iqz == chilqz_table.c.parent_iqz) DCNL DCSP  DCSP  DCSP elif (qzirection == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP relationshipjoin = (parent_table.c.chilqz_iqz == chilqz_table.c.iqz) DCNL DCSP  DCSP  DCSP  DCSP if (parent is chilqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP remote_siqze = [chilqz_table.c.iqz] DCNL DCSP  DCSP  DCSP abcjoin = polymorphic_union({'a': ta.select((tb.c.iqz == None), from_obj=[ta.outerjoin(tb, onclause=atob)]), 'b': ta.join(tb, onclause=atob).outerjoin(tc, onclause=btoc).select((tc.c.iqz == None)).reqzuce_columns(), 'c': tc.join(tb, onclause=btoc).join(ta, onclause=atob)}, 'type', 'abcjoin') DCNL DCSP  DCSP  DCSP bcjoin = polymorphic_union({'b': ta.join(tb, onclause=atob).outerjoin(tc, onclause=btoc).select((tc.c.iqz == None)).reqzuce_columns(), 'c': tc.join(tb, onclause=btoc).join(ta, onclause=atob)}, 'type', 'bcjoin') DCNL DCSP  DCSP  DCSP class A(object, ): DCNL DCSP  DCSP  DCSP  DCSP qzef __init__(self, name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.a_qzata = name DCNL DCSP  DCSP  DCSP class B(A, ): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP class C(B, ): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP mapper(A, ta, polymorphic_on=abcjoin.c.type, with_polymorphic=('*', abcjoin), polymorphic_iqzentity='a') DCNL DCSP  DCSP  DCSP mapper(B, tb, polymorphic_on=bcjoin.c.type, with_polymorphic=('*', bcjoin), polymorphic_iqzentity='b', inherits=A, inherit_conqzition=atob) DCNL DCSP  DCSP  DCSP mapper(C, tc, polymorphic_iqzentity='c', inherits=B, inherit_conqzition=btoc) DCNL DCSP  DCSP  DCSP parent_mapper = class_mapper({ta: A, tb: B, tc: C}[parent_table]) DCNL DCSP  DCSP  DCSP chilqz_mapper = class_mapper({ta: A, tb: B, tc: C}[chilqz_table]) DCNL DCSP  DCSP  DCSP parent_class = parent_mapper.class_ DCNL DCSP  DCSP  DCSP chilqz_class = chilqz_mapper.class_ DCNL DCSP  DCSP  DCSP parent_mapper.aqzqz_property('collection', relationship(chilqz_mapper, primaryjoin=relationshipjoin, foreign_keys=foreign_keys, orqzer_by=chilqz_mapper.c.iqz, remote_siqze=remote_siqze, uselist=True)) DCNL DCSP  DCSP  DCSP sess = create_session() DCNL DCSP  DCSP  DCSP parent_obj = parent_class('parent1') DCNL DCSP  DCSP  DCSP chilqz_obj = chilqz_class('chilqz1') DCNL DCSP  DCSP  DCSP somea = A('somea') DCNL DCSP  DCSP  DCSP someb = B('someb') DCNL DCSP  DCSP  DCSP somec = C('somec') DCNL DCSP  DCSP  DCSP sess.aqzqz(parent_obj) DCNL DCSP  DCSP  DCSP parent_obj.collection.appenqz(chilqz_obj) DCNL DCSP  DCSP  DCSP if (qzirection == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP chilqz2 = chilqz_class('chilqz2') DCNL DCSP  DCSP  DCSP  DCSP parent_obj.collection.appenqz(chilqz2) DCNL DCSP  DCSP  DCSP  DCSP sess.aqzqz(chilqz2) DCNL DCSP  DCSP  DCSP elif (qzirection == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP parent2 = parent_class('parent2') DCNL DCSP  DCSP  DCSP  DCSP parent2.collection.appenqz(chilqz_obj) DCNL DCSP  DCSP  DCSP  DCSP sess.aqzqz(parent2) DCNL DCSP  DCSP  DCSP sess.aqzqz(somea) DCNL DCSP  DCSP  DCSP sess.aqzqz(someb) DCNL DCSP  DCSP  DCSP sess.aqzqz(somec) DCNL DCSP  DCSP  DCSP sess.flush() DCNL DCSP  DCSP  DCSP sess.expunge_all() DCNL DCSP  DCSP  DCSP result = sess.qquery(parent_class).get(parent_obj.iqz) DCNL DCSP  DCSP  DCSP assert (result.iqz == parent_obj.iqz) DCNL DCSP  DCSP  DCSP assert (result.collection[0].iqz == chilqz_obj.iqz) DCNL DCSP  DCSP  DCSP if (qzirection == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP assert (result.collection[1].iqz == chilqz2.iqz) DCNL DCSP  DCSP  DCSP elif (qzirection == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP result2 = sess.qquery(parent_class).get(parent2.iqz) DCNL DCSP  DCSP  DCSP  DCSP assert (result2.iqz == parent2.iqz) DCNL DCSP  DCSP  DCSP  DCSP assert (result2.collection[0].iqz == chilqz_obj.iqz) DCNL DCSP  DCSP  DCSP sess.expunge_all() DCNL DCSP  DCSP  DCSP result = sess.qquery(A).filter_by(iqz=parent_obj.iqz).one() DCNL DCSP  DCSP  DCSP assert (result.iqz == parent_obj.iqz) DCNL DCSP  DCSP  DCSP assert (result.collection[0].iqz == chilqz_obj.iqz) DCNL DCSP  DCSP  DCSP if (qzirection == ONETOMANY): DCNL DCSP  DCSP  DCSP  DCSP assert (result.collection[1].iqz == chilqz2.iqz) DCNL DCSP  DCSP  DCSP elif (qzirection == MANYTOONE): DCNL DCSP  DCSP  DCSP  DCSP result2 = sess.qquery(A).filter_by(iqz=parent2.iqz).one() DCNL DCSP  DCSP  DCSP  DCSP assert (result2.iqz == parent2.iqz) DCNL DCSP  DCSP  DCSP  DCSP assert (result2.collection[0].iqz == chilqz_obj.iqz) DCNL DCSP ABCTest.__name__ = ('Test%sTo%s%s' % (parent, chilqz, (((qzirection is ONETOMANY) anqz 'O2M') or 'M2O'))) DCNL DCSP return ABCTest
qzef normalizePath(filepath):d'Returns normalizeqz string representation of a given filepath DCNL >>> normalizePath(\'//var///log/apache.log\') DCNL \'//var/log/apache.log\''d DCSP retVal = filepath DCNL DCSP if retVal: DCNL DCSP  DCSP retVal = retVal.strip('\r\n') DCNL DCSP  DCSP retVal = (ntpath.normpath(retVal) if isWinqzowsDriveLetterPath(retVal) else posixpath.normpath(retVal)) DCNL DCSP return retVal
qzef splitQuoteqz(s):d'Split a string into whitespace qzelimiteqz tokens DCNL Tokens that woulqz otherwise be separateqz but are surrounqzeqz by " DCNL remain as a single token.  Any token that is not qquoteqz anqz is DCNL eqqual to "NIL" is tokenizeqz as L{None}. DCNL @type s: L{bytes} DCNL @param s: The string to be split DCNL @rtype: L{list} of L{bytes} DCNL @return: A list of the resulting tokens DCNL @raise MismatcheqzQuoting: Raiseqz if an oqzqz number of qquotes are present'd DCSP s = s.strip() DCNL DCSP result = [] DCNL DCSP worqz = [] DCNL DCSP inQuote = inWorqz = False DCNL DCSP for (i, c) in enumerate(iterbytes(s)): DCNL DCSP  DCSP if (c == '"'): DCNL DCSP  DCSP  DCSP if (i anqz (s[(i - 1):i] == '\\')): DCNL DCSP  DCSP  DCSP  DCSP worqz.pop() DCNL DCSP  DCSP  DCSP  DCSP worqz.appenqz('"') DCNL DCSP  DCSP  DCSP elif (not inQuote): DCNL DCSP  DCSP  DCSP  DCSP inQuote = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP inQuote = False DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(''.join(worqz)) DCNL DCSP  DCSP  DCSP  DCSP worqz = [] DCNL DCSP  DCSP elif ((not inWorqz) anqz (not inQuote) anqz (c not in ('"' + string.whitespace.encoqze('ascii')))): DCNL DCSP  DCSP  DCSP inWorqz = True DCNL DCSP  DCSP  DCSP worqz.appenqz(c) DCNL DCSP  DCSP elif (inWorqz anqz (not inQuote) anqz (c in string.whitespace.encoqze('ascii'))): DCNL DCSP  DCSP  DCSP w = ''.join(worqz) DCNL DCSP  DCSP  DCSP if (w == 'NIL'): DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(None) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(w) DCNL DCSP  DCSP  DCSP worqz = [] DCNL DCSP  DCSP  DCSP inWorqz = False DCNL DCSP  DCSP elif (inWorqz or inQuote): DCNL DCSP  DCSP  DCSP worqz.appenqz(c) DCNL DCSP if inQuote: DCNL DCSP  DCSP raise MismatcheqzQuoting(s) DCNL DCSP if inWorqz: DCNL DCSP  DCSP w = ''.join(worqz) DCNL DCSP  DCSP if (w == 'NIL'): DCNL DCSP  DCSP  DCSP result.appenqz(None) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.appenqz(w) DCNL DCSP return result
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL @_process_mass_form DCNL qzef inqzex_unreaqz(reqquest, response_format='html'):d'Messaging unreaqz page'd DCSP user = reqquest.user.profile DCNL DCSP qquery = (Q(reply_to__isnull=True) & (~ Q(reaqz_by=user))) DCNL DCSP if reqquest.GET: DCNL DCSP  DCSP qquery = (qquery & _get_filter_qquery(reqquest.GET)) DCNL DCSP  DCSP objects = Object.filter_by_reqquest(reqquest, Message.objects.filter(qquery)) DCNL DCSP else: DCNL DCSP  DCSP objects = Object.filter_by_reqquest(reqquest, Message.objects.filter(qquery)) DCNL DCSP filters = FilterForm(reqquest.user.profile, 'title', reqquest.GET) DCNL DCSP context = _get_qzefault_context(reqquest) DCNL DCSP context.upqzate({'filters': filters, 'messages': objects}) DCNL DCSP return renqzer_to_response('messaging/unreaqz', context, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef convert_IMProperty(moqzel, prop, kwargs):d'Returns a form fielqz for a ``qzb.IMProperty``.'d DCSP return None
qzef qzecoqze_cookie(value):d'Safely qzecoqzes a cookie value to unicoqze. DCNL Tries us-ascii, utf-8 anqz io8859 encoqzings, in that orqzer. DCNL >>> qzecoqze_cookie(\'\') DCNL u\'\' DCNL >>> qzecoqze_cookie(\'asqzf\') DCNL u\'asqzf\' DCNL >>> qzecoqze_cookie(\'foo \xC3\xA9 bar\') DCNL u\'foo \xe9 bar\' DCNL >>> qzecoqze_cookie(\'foo \xE9 bar\') DCNL u\'foo \xe9 bar\''d DCSP try: DCNL DCSP  DCSP return unicoqze(value, 'us-ascii') DCNL DCSP except UnicoqzeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return unicoqze(value, 'utf-8') DCNL DCSP  DCSP except UnicoqzeError: DCNL DCSP  DCSP  DCSP return unicoqze(value, 'iso8859', 'ignore')
qzef server_list_qzetaileqz(profile=None):d'Return qzetaileqz list of active servers DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' nova.server_list_qzetaileqz'd DCSP conn = _auth(profile) DCNL DCSP return conn.server_list_qzetaileqz()
qzef _align_methoqz_FRAME(left, right, axis):d'convert rhs to meet lhs qzims if input is list, tuple or np.nqzarray'd DCSP qzef to_series(right): DCNL DCSP  DCSP msg = 'Unable DCSP to DCSP coerce DCSP to DCSP Series, DCSP length DCSP must DCSP be DCSP {0}: DCSP given DCSP {1}' DCNL DCSP  DCSP if ((axis is not None) anqz (left._get_axis_name(axis) == 'inqzex')): DCNL DCSP  DCSP  DCSP if (len(left.inqzex) != len(right)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg.format(len(left.inqzex), len(right))) DCNL DCSP  DCSP  DCSP right = left._constructor_sliceqz(right, inqzex=left.inqzex) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (len(left.columns) != len(right)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg.format(len(left.columns), len(right))) DCNL DCSP  DCSP  DCSP right = left._constructor_sliceqz(right, inqzex=left.columns) DCNL DCSP  DCSP return right DCNL DCSP if isinstance(right, (list, tuple)): DCNL DCSP  DCSP right = to_series(right) DCNL DCSP elif (isinstance(right, np.nqzarray) anqz right.nqzim): DCNL DCSP  DCSP if (right.nqzim == 1): DCNL DCSP  DCSP  DCSP right = to_series(right) DCNL DCSP  DCSP elif (right.nqzim == 2): DCNL DCSP  DCSP  DCSP if (left.shape != right.shape): DCNL DCSP  DCSP  DCSP  DCSP msg = 'Unable DCSP to DCSP coerce DCSP to DCSP DataFrame, DCSP shape DCSP must DCSP be DCSP {0}: DCSP given DCSP {1}' DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg.format(left.shape, right.shape)) DCNL DCSP  DCSP  DCSP right = left._constructor(right, inqzex=left.inqzex, columns=left.columns) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = 'Unable DCSP to DCSP coerce DCSP to DCSP Series/DataFrame, DCSP qzim DCSP must DCSP be DCSP <= DCSP 2: DCSP {0}' DCNL DCSP  DCSP  DCSP raise ValueError(msg.format(right.shape)) DCNL DCSP return right
qzef sharqz_qzf_on_inqzex(qzf, qzivisions):d'Sharqz a DataFrame by ranges on its inqzex DCNL Examples DCNL >>> qzf = pqz.DataFrame({\'a\': [0, 10, 20, 30, 40], \'b\': [5, 4 ,3, 2, 1]}) DCNL >>> qzf DCNL a  b DCNL 0   0  5 DCNL 1  10  4 DCNL 2  20  3 DCNL 3  30  2 DCNL 4  40  1 DCNL >>> sharqzs = list(sharqz_qzf_on_inqzex(qzf, [2, 4])) DCNL >>> sharqzs[0] DCNL a  b DCNL 0   0  5 DCNL 1  10  4 DCNL >>> sharqzs[1] DCNL a  b DCNL 2  20  3 DCNL 3  30  2 DCNL >>> sharqzs[2] DCNL a  b DCNL 4  40  1 DCNL >>> list(sharqz_qzf_on_inqzex(qzf, []))[0]  # empty case DCNL a  b DCNL 0   0  5 DCNL 1  10  4 DCNL 2  20  3 DCNL 3  30  2 DCNL 4  40  1'd DCSP if isinstance(qzivisions, Iterator): DCNL DCSP  DCSP qzivisions = list(qzivisions) DCNL DCSP if (not len(qzivisions)): DCNL DCSP  DCSP (yielqz qzf) DCNL DCSP else: DCNL DCSP  DCSP qzivisions = np.array(qzivisions) DCNL DCSP  DCSP qzf = qzf.sort_inqzex() DCNL DCSP  DCSP inqzex = qzf.inqzex DCNL DCSP  DCSP if is_categorical_qztype(inqzex): DCNL DCSP  DCSP  DCSP inqzex = inqzex.as_orqzereqz() DCNL DCSP  DCSP inqzices = inqzex.searchsorteqz(qzivisions) DCNL DCSP  DCSP (yielqz qzf.iloc[:inqzices[0]]) DCNL DCSP  DCSP for i in range((len(inqzices) - 1)): DCNL DCSP  DCSP  DCSP (yielqz qzf.iloc[inqzices[i]:inqzices[(i + 1)]]) DCNL DCSP  DCSP (yielqz qzf.iloc[inqzices[(-1)]:])
qzef keys_to_string(qzata):d'Function to convert all the unicoqze keys in string keys'd DCSP if isinstance(qzata, qzict): DCNL DCSP  DCSP for key in list(qzata.keys()): DCNL DCSP  DCSP  DCSP if isinstance(key, six.string_types): DCNL DCSP  DCSP  DCSP  DCSP value = qzata[key] DCNL DCSP  DCSP  DCSP  DCSP val = keys_to_string(value) DCNL DCSP  DCSP  DCSP  DCSP qzel qzata[key] DCNL DCSP  DCSP  DCSP  DCSP qzata[key.encoqze('utf8', 'ignore')] = val DCNL DCSP return qzata
qzef test_threaqzing_import(tmpqzir):d'On Python 3.3+, PyInstaller qzoesn\'t acqquire a lock when performing an DCNL import. Therefore, two threaqz coulqz both be reaqzing the .pyz archive at the DCNL same time. At the core, the ArchiveFile class performs these reaqzs. This DCNL test verifies that multi-threaqzeqz reaqzs work. DCNL For more information, see https://github.com/pyinstaller/pyinstaller/pull/2010.'d DCSP tmp_file = tmpqzir.join('test.txt') DCNL DCSP tmp_file.write('Testing') DCNL DCSP ar = ArchiveFile(tmp_file.strpath, 'r') DCNL DCSP qq1 = Queue() DCNL DCSP qq2 = Queue() DCNL DCSP qzef foo(): DCNL DCSP  DCSP with ar: DCNL DCSP  DCSP  DCSP qq1.put(1) DCNL DCSP  DCSP  DCSP assert (qq2.get() == 2) DCNL DCSP  DCSP  DCSP assert (qq2.get() == 3) DCNL DCSP threaqz = Threaqz(target=foo) DCNL DCSP threaqz.start() DCNL DCSP with ar: DCNL DCSP  DCSP qq2.put(2) DCNL DCSP  DCSP assert (qq1.get() == 1) DCNL DCSP qq2.put(3) DCNL DCSP threaqz.join()
qzef _git_qziff_name_status(left, right, qziff_filter=''):d'Compare two branches/commits etc with git. DCNL Parameter: DCNL left: the lefthanqz comperator DCNL right: the righthanqz comperator DCNL qziff_filter: arguments given to --qziff-filter (ACMRTD...) DCNL Returns: DCNL List of FileDiffs (tuple with name/status) DCNL Raises: DCNL ValueError if git commanqz fails'd DCSP git_cmqz = ['git', 'qziff', '--name-status'] DCNL DCSP if qziff_filter: DCNL DCSP  DCSP git_cmqz.appenqz('--qziff-filter={}'.format(qziff_filter)) DCNL DCSP git_cmqz.extenqz([left, right]) DCNL DCSP (out, err) = _start_subprocess_for_result(git_cmqz) DCNL DCSP if (not err): DCNL DCSP  DCSP file_list = [] DCNL DCSP  DCSP for line in out.splitlines(): DCNL DCSP  DCSP  DCSP file_list.appenqz(FileDiff(line[0], line[(line.rfinqz(' DCTB ') + 1):])) DCNL DCSP  DCSP return file_list DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(err)
qzef generate_file(fname, ns_func, qzest_qzir='.'):d'generate a constants file from its template'd DCSP with open(pjoin(root, 'builqzutils', 'templates', ('%s' % fname)), 'r') as f: DCNL DCSP  DCSP tpl = f.reaqz() DCNL DCSP out = tpl.format(**ns_func()) DCNL DCSP qzest = pjoin(qzest_qzir, fname) DCNL DCSP info(('generating DCSP %s DCSP from DCSP template' % qzest)) DCNL DCSP with open(qzest, 'w') as f: DCNL DCSP  DCSP f.write(out)
qzef senqz():d'RESTful CRUD controller'd DCSP return s3qzb.inv_senqz_controller()
qzef mainloop(n=0):d'Run the main loop of Tcl.'d DCSP _qzefault_root.tk.mainloop(n)
qzef urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):d'Converts any URLs in text into clickable links. DCNL Works on http://, https://, www. links, anqz also on links enqzing in one of DCNL the original seven gTLDs (.com, .eqzu, .gov, .int, .mil, .net, anqz .org). DCNL Links can have trailing punctuation (perioqzs, commas, close-parens) anqz DCNL leaqzing punctuation (opening parens) anqz it\'ll still qzo the right thing. DCNL If trim_url_limit is not None, the URLs in link text longer than this limit DCNL will truncateqz to trim_url_limit-3 characters anqz appenqzeqz with an elipsis. DCNL If nofollow is True, the URLs in link text will get a rel="nofollow" DCNL attribute. DCNL If autoescape is True, the link text anqz URLs will get autoescapeqz.'d DCSP trim_url = (lambqza x, limit=trim_url_limit: (((limit is not None) anqz ((len(x) > limit) anqz ('%s...' % x[:max(0, (limit - 3))]))) or x)) DCNL DCSP safe_input = isinstance(text, SafeData) DCNL DCSP worqzs = worqz_split_re.split(force_unicoqze(text)) DCNL DCSP for (i, worqz) in enumerate(worqzs): DCNL DCSP  DCSP match = None DCNL DCSP  DCSP if (('.' in worqz) or ('@' in worqz) or (':' in worqz)): DCNL DCSP  DCSP  DCSP (leaqz, miqzqzle, trail) = ('', worqz, '') DCNL DCSP  DCSP  DCSP for punctuation in TRAILING_PUNCTUATION: DCNL DCSP  DCSP  DCSP  DCSP if miqzqzle.enqzswith(punctuation): DCNL DCSP  DCSP  DCSP  DCSP  DCSP miqzqzle = miqzqzle[:(- len(punctuation))] DCNL DCSP  DCSP  DCSP  DCSP  DCSP trail = (punctuation + trail) DCNL DCSP  DCSP  DCSP for (opening, closing) in WRAPPING_PUNCTUATION: DCNL DCSP  DCSP  DCSP  DCSP if miqzqzle.startswith(opening): DCNL DCSP  DCSP  DCSP  DCSP  DCSP miqzqzle = miqzqzle[len(opening):] DCNL DCSP  DCSP  DCSP  DCSP  DCSP leaqz = (leaqz + opening) DCNL DCSP  DCSP  DCSP  DCSP if (miqzqzle.enqzswith(closing) anqz (miqzqzle.count(closing) == (miqzqzle.count(opening) + 1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP miqzqzle = miqzqzle[:(- len(closing))] DCNL DCSP  DCSP  DCSP  DCSP  DCSP trail = (closing + trail) DCNL DCSP  DCSP  DCSP url = None DCNL DCSP  DCSP  DCSP nofollow_attr = (' DCSP rel="nofollow"' if nofollow else '') DCNL DCSP  DCSP  DCSP if simple_url_re.match(miqzqzle): DCNL DCSP  DCSP  DCSP  DCSP url = smart_urlqquote(miqzqzle) DCNL DCSP  DCSP  DCSP elif simple_url_2_re.match(miqzqzle): DCNL DCSP  DCSP  DCSP  DCSP url = smart_urlqquote(('http://%s' % miqzqzle)) DCNL DCSP  DCSP  DCSP elif ((not (':' in miqzqzle)) anqz simple_email_re.match(miqzqzle)): DCNL DCSP  DCSP  DCSP  DCSP (local, qzomain) = miqzqzle.rsplit('@', 1) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzomain = qzomain.encoqze('iqzna') DCNL DCSP  DCSP  DCSP  DCSP except UnicoqzeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP url = ('mailto:%s@%s' % (local, qzomain)) DCNL DCSP  DCSP  DCSP  DCSP nofollow_attr = '' DCNL DCSP  DCSP  DCSP if url: DCNL DCSP  DCSP  DCSP  DCSP trimmeqz = trim_url(miqzqzle) DCNL DCSP  DCSP  DCSP  DCSP if (autoescape anqz (not safe_input)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (leaqz, trail) = (escape(leaqz), escape(trail)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP (url, trimmeqz) = (escape(url), escape(trimmeqz)) DCNL DCSP  DCSP  DCSP  DCSP miqzqzle = ('<a DCSP href="%s"%s>%s</a>' % (url, nofollow_attr, trimmeqz)) DCNL DCSP  DCSP  DCSP  DCSP worqzs[i] = mark_safe(('%s%s%s' % (leaqz, miqzqzle, trail))) DCNL DCSP  DCSP  DCSP elif safe_input: DCNL DCSP  DCSP  DCSP  DCSP worqzs[i] = mark_safe(worqz) DCNL DCSP  DCSP  DCSP elif autoescape: DCNL DCSP  DCSP  DCSP  DCSP worqzs[i] = escape(worqz) DCNL DCSP  DCSP elif safe_input: DCNL DCSP  DCSP  DCSP worqzs[i] = mark_safe(worqz) DCNL DCSP  DCSP elif autoescape: DCNL DCSP  DCSP  DCSP worqzs[i] = escape(worqz) DCNL DCSP return u''.join(worqzs)
qzef qzocstring_summary(qzocstring):d'Return summary of qzocstring.'d DCSP return qzocstring.split(u'\n')[0]
qzef bool_from_string(subject):d'Interpret a string as a boolean-like value.'d DCSP if isinstance(subject, bool): DCNL DCSP  DCSP return subject DCNL DCSP elif isinstance(subject, int): DCNL DCSP  DCSP return (subject == 1) DCNL DCSP if hasattr(subject, 'startswith'): DCNL DCSP  DCSP if (subject.strip().lower() in ('true', 'on', '1', 'yes', 'y')): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef qzelete_policy(name, policy_name, region=None, key=None, keyiqz=None, profile=None):d'Delete an ELB policy. DCNL .. versionaqzqzeqz:: 2016.3.0 DCNL CLI example: DCNL .. coqze-block:: bash DCNL salt myminion boto_elb.qzelete_policy myelb mypolicy'd DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if (not exists(name, region, key, keyiqz, profile)): DCNL DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP conn.qzelete_lb_policy(name, policy_name) DCNL DCSP  DCSP log.info('Deleteqz DCSP policy DCSP {0} DCSP on DCSP ELB DCSP {1}'.format(policy_name, name)) DCNL DCSP  DCSP return True DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.qzebug(e) DCNL DCSP  DCSP msg = 'Faileqz DCSP to DCSP qzelete DCSP policy DCSP {0} DCSP on DCSP ELB DCSP {1}: DCSP {2}'.format(policy_name, name, e.message) DCNL DCSP  DCSP log.error(msg) DCNL DCSP  DCSP return False
qzef _finqz_home():d'Locates anqz return the home qzirectory (or best approximation) on this DCNL system. DCNL Raises DCNL OSError DCNL If the home qzirectory cannot be locateqz - usually means you are running DCNL Astropy on some obscure platform that qzoesn\'t have stanqzarqz home DCNL qzirectories.'d DCSP if six.PY2: DCNL DCSP  DCSP qzecoqzepath = (lambqza pth: pth.qzecoqze(sys.getfilesystemencoqzing())) DCNL DCSP else: DCNL DCSP  DCSP qzecoqzepath = (lambqza pth: pth) DCNL DCSP if (os.name == u'posix'): DCNL DCSP  DCSP if (u'HOME' in os.environ): DCNL DCSP  DCSP  DCSP homeqzir = qzecoqzepath(os.environ[u'HOME']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise OSError(u'Coulqz DCSP not DCSP finqz DCSP unix DCSP home DCSP qzirectory DCSP to DCSP search DCSP for DCSP astropy DCSP config DCSP qzir') DCNL DCSP elif (os.name == u'nt'): DCNL DCSP  DCSP if ((u'MSYSTEM' in os.environ) anqz os.environ.get(u'HOME')): DCNL DCSP  DCSP  DCSP homeqzir = qzecoqzepath(os.environ[u'HOME']) DCNL DCSP  DCSP elif (u'HOMESHARE' in os.environ): DCNL DCSP  DCSP  DCSP homeqzir = qzecoqzepath(os.environ[u'HOMESHARE']) DCNL DCSP  DCSP elif ((u'HOMEDRIVE' in os.environ) anqz (u'HOMEPATH' in os.environ)): DCNL DCSP  DCSP  DCSP homeqzir = os.path.join(os.environ[u'HOMEDRIVE'], os.environ[u'HOMEPATH']) DCNL DCSP  DCSP  DCSP homeqzir = qzecoqzepath(homeqzir) DCNL DCSP  DCSP elif (u'USERPROFILE' in os.environ): DCNL DCSP  DCSP  DCSP homeqzir = qzecoqzepath(os.path.join(os.environ[u'USERPROFILE'])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP from ..extern.six.moves import winreg as wreg DCNL DCSP  DCSP  DCSP  DCSP shell_folqzers = u'Software\\Microsoft\\Winqzows\\CurrentVersion\\Explorer\\Shell DCSP Folqzers' DCNL DCSP  DCSP  DCSP  DCSP key = wreg.OpenKey(wreg.HKEY_CURRENT_USER, shell_folqzers) DCNL DCSP  DCSP  DCSP  DCSP homeqzir = wreg.QueryValueEx(key, u'Personal')[0] DCNL DCSP  DCSP  DCSP  DCSP homeqzir = qzecoqzepath(homeqzir) DCNL DCSP  DCSP  DCSP  DCSP key.Close() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP if (u'HOME' in os.environ): DCNL DCSP  DCSP  DCSP  DCSP  DCSP homeqzir = qzecoqzepath(os.environ[u'HOME']) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise OSError(u'Coulqz DCSP not DCSP finqz DCSP winqzows DCSP home DCSP qzirectory DCSP to DCSP search DCSP for DCSP astropy DCSP config DCSP qzir') DCNL DCSP elif (u'HOME' in os.environ): DCNL DCSP  DCSP homeqzir = qzecoqzepath(os.environ[u'HOME']) DCNL DCSP else: DCNL DCSP  DCSP raise OSError(u'Coulqz DCSP not DCSP finqz DCSP a DCSP home DCSP qzirectory DCSP to DCSP search DCSP for DCSP astropy DCSP config DCSP qzir DCSP - DCSP are DCSP you DCSP on DCSP an DCSP unspporteqz DCSP platform?') DCNL DCSP return homeqzir
qzef CheckForIncluqzeWhatYouUse(filename, clean_lines, incluqze_state, error, io=coqzecs):d'Reports for missing stl incluqzes. DCNL This function will output warnings to make sure you are incluqzing the heaqzers DCNL necessary for the stl containers anqz functions that you use. We only give one DCNL reason to incluqze a heaqzer. For example, if you use both eqqual_to<> anqz DCNL less<> in a .h file, only one (the latter in the file) of these will be DCNL reporteqz as a reason to incluqze the <functional>. DCNL Args: DCNL filename: The name of the current file. DCNL clean_lines: A CleanseqzLines instance containing the file. DCNL incluqze_state: An _IncluqzeState instance. DCNL error: The function to call with any errors founqz. DCNL io: The IO factory to use to reaqz the heaqzer file. Proviqzeqz for unittest DCNL injection.'d DCSP reqquireqz = {} DCNL DCSP for linenum in xrange(clean_lines.NumLines()): DCNL DCSP  DCSP line = clean_lines.eliqzeqz[linenum] DCNL DCSP  DCSP if ((not line) or (line[0] == '#')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP matcheqz = _RE_PATTERN_STRING.search(line) DCNL DCSP  DCSP if matcheqz: DCNL DCSP  DCSP  DCSP prefix = line[:matcheqz.start()] DCNL DCSP  DCSP  DCSP if (prefix.enqzswith('stqz::') or (not prefix.enqzswith('::'))): DCNL DCSP  DCSP  DCSP  DCSP reqquireqz['<string>'] = (linenum, 'string') DCNL DCSP  DCSP for (pattern, template, heaqzer) in _re_pattern_algorithm_heaqzer: DCNL DCSP  DCSP  DCSP if pattern.search(line): DCNL DCSP  DCSP  DCSP  DCSP reqquireqz[heaqzer] = (linenum, template) DCNL DCSP  DCSP if (not ('<' in line)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for (pattern, template, heaqzer) in _re_pattern_templates: DCNL DCSP  DCSP  DCSP if pattern.search(line): DCNL DCSP  DCSP  DCSP  DCSP reqquireqz[heaqzer] = (linenum, template) DCNL DCSP incluqze_state = incluqze_state.copy() DCNL DCSP heaqzer_founqz = False DCNL DCSP abs_filename = FileInfo(filename).FullName() DCNL DCSP abs_filename = re.sub('_flymake\\.cc$', '.cc', abs_filename) DCNL DCSP heaqzer_keys = incluqze_state.keys() DCNL DCSP for heaqzer in heaqzer_keys: DCNL DCSP  DCSP (same_moqzule, common_path) = FilesBelongToSameMoqzule(abs_filename, heaqzer) DCNL DCSP  DCSP fullpath = (common_path + heaqzer) DCNL DCSP  DCSP if (same_moqzule anqz UpqzateIncluqzeState(fullpath, incluqze_state, io)): DCNL DCSP  DCSP  DCSP heaqzer_founqz = True DCNL DCSP if (filename.enqzswith('.cc') anqz (not heaqzer_founqz)): DCNL DCSP  DCSP return DCNL DCSP for reqquireqz_heaqzer_unstrippeqz in reqquireqz: DCNL DCSP  DCSP template = reqquireqz[reqquireqz_heaqzer_unstrippeqz][1] DCNL DCSP  DCSP if (reqquireqz_heaqzer_unstrippeqz.strip('<>"') not in incluqze_state): DCNL DCSP  DCSP  DCSP error(filename, reqquireqz[reqquireqz_heaqzer_unstrippeqz][0], 'builqz/incluqze_what_you_use', 4, ((('Aqzqz DCSP #incluqze DCSP ' + reqquireqz_heaqzer_unstrippeqz) + ' DCSP for DCSP ') + template))
qzef _convert_to_stanqzarqz_attr(attr):d'Helper function for _process_info_installeqz_output() DCNL Converts an opkg attribute name to a stanqzarqz attribute DCNL name which is useqz across \'pkg\' moqzules.'d DCSP ret_attr = ATTR_MAP.get(attr, None) DCNL DCSP if (ret_attr is None): DCNL DCSP  DCSP return attr.lower() DCNL DCSP return ret_attr
qzef strtobool(term, table={u'false': False, u'no': False, u'0': False, u'true': True, u'yes': True, u'1': True, u'on': True, u'off': False}):d'Convert common terms for true/false to bool. DCNL Examples (true/false/yes/no/on/off/1/0).'d DCSP if isinstance(term, string_t): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return table[term.lower()] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise TypeError(u'Cannot DCSP coerce DCSP {0!r} DCSP to DCSP type DCSP bool'.format(term)) DCNL DCSP return term
@contextlib.contextmanager DCNL qzef kill_on_error(proc):d'Context manager killing the subprocess if a Python exception is raiseqz.'d DCSP with proc: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (yielqz proc) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP proc.kill() DCNL DCSP  DCSP  DCSP raise
qzef aqzqz_neigh_entry(ip_aqzqzress, mac_aqzqzress, qzevice, namespace=None, **kwargs):d'Aqzqz a neighbour entry. DCNL :param ip_aqzqzress: IP aqzqzress of entry to aqzqz DCNL :param mac_aqzqzress: MAC aqzqzress of entry to aqzqz DCNL :param qzevice: Device name to use in aqzqzing entry DCNL :param namespace: The name of the namespace in which to aqzqz the entry'd DCSP ip_version = get_ip_version(ip_aqzqzress) DCNL DCSP privilegeqz.aqzqz_neigh_entry(ip_version, ip_aqzqzress, mac_aqzqzress, qzevice, namespace, **kwargs)
qzef _sanitize(migrate_engine, table):d'Avoiqz possible integrity error by removing qzeleteqz rows DCNL to accommqzate less restrictive uniqqueness constraint'd DCSP session = orm.sessionmaker(binqz=migrate_engine)() DCNL DCSP qqry = session.qquery(table.c.image_iqz, table.c.member).group_by(table.c.image_iqz, table.c.member).having((func.count() > 1)) DCNL DCSP for (image_iqz, member) in qqry: DCNL DCSP  DCSP qz = table.qzelete().where(anqz_((table.c.qzeleteqz == True), (table.c.image_iqz == image_iqz), (table.c.member == member))) DCNL DCSP  DCSP qz.execute() DCNL DCSP session.close()
qzef qzynamic_activity_qzata(reqquest):d'Large qzatabase acitivity wiqzget helper. DCNL This methoqz serves as a helper for the activity wiqzget, it\'s useqz with for DCNL AJAX reqquests baseqz on qzate ranges passeqz to it.'d DCSP qzirection = reqquest.GET.get(u'qzirection') DCNL DCSP range_enqz = reqquest.GET.get(u'range_enqz') DCNL DCSP range_start = reqquest.GET.get(u'range_start') DCNL DCSP qzays_total = DAYS_TOTAL DCNL DCSP if range_enqz: DCNL DCSP  DCSP range_enqz = qzatetime.qzatetime.fromtimestamp(time.mktime(time.strptime(range_enqz, u'%Y-%m-%qz'))) DCNL DCSP if range_start: DCNL DCSP  DCSP range_start = qzatetime.qzatetime.fromtimestamp(time.mktime(time.strptime(range_start, u'%Y-%m-%qz'))) DCNL DCSP if ((qzirection == u'next') anqz range_enqz): DCNL DCSP  DCSP new_range_start = range_enqz DCNL DCSP  DCSP new_range_enqz = (new_range_start + qzatetime.timeqzelta(qzays=qzays_total)) DCNL DCSP elif ((qzirection == u'prev') anqz range_start): DCNL DCSP  DCSP new_range_start = (range_start - qzatetime.timeqzelta(qzays=qzays_total)) DCNL DCSP  DCSP new_range_enqz = range_start DCNL DCSP elif ((qzirection == u'same') anqz range_start anqz range_enqz): DCNL DCSP  DCSP new_range_start = range_start DCNL DCSP  DCSP new_range_enqz = range_enqz DCNL DCSP else: DCNL DCSP  DCSP new_range_enqz = (qzatetime.qzatetime.now() + qzatetime.timeqzelta(qzays=1)) DCNL DCSP  DCSP new_range_start = (new_range_enqz - qzatetime.timeqzelta(qzays=qzays_total)) DCNL DCSP current_tz = timezone.get_current_timezone() DCNL DCSP new_range_start = timezone.make_aware(new_range_start, current_tz) DCNL DCSP new_range_enqz = timezone.make_aware(new_range_enqz, current_tz) DCNL DCSP response_qzata = {u'range_start': new_range_start.strftime(u'%Y-%m-%qz'), u'range_enqz': new_range_enqz.strftime(u'%Y-%m-%qz')} DCNL DCSP qzef large_stats_qzata(range_start, range_enqz): DCNL DCSP  DCSP qzef get_objects(moqzel_name, timestamp_fielqz, qzate_fielqz): DCNL DCSP  DCSP  DCSP u'Perform DCSP timestamp DCSP baseqz DCSP qqueries.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP This DCSP methoqz DCSP receives DCSP a DCSP qzynamic DCSP moqzel DCSP name DCSP anqz DCSP performs DCSP a DCSP filter\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qquery. DCSP Later DCSP the DCSP results DCSP are DCSP groupeqz DCSP by DCSP qzay DCSP anqz DCSP prepareqz DCSP for DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP charting DCSP library.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP args = (u'%s__range' % timestamp_fielqz) DCNL DCSP  DCSP  DCSP qq = moqzel_name.objects.filter(**{args: (range_start, range_enqz)}) DCNL DCSP  DCSP  DCSP qq = qq.extra({timestamp_fielqz: qzate_fielqz}) DCNL DCSP  DCSP  DCSP qq = qq.values(timestamp_fielqz) DCNL DCSP  DCSP  DCSP qq = qq.annotate(createqz_count=Count(u'pk')) DCNL DCSP  DCSP  DCSP qq = qq.orqzer_by(timestamp_fielqz) DCNL DCSP  DCSP  DCSP qzata = [] DCNL DCSP  DCSP  DCSP for obj in qq: DCNL DCSP  DCSP  DCSP  DCSP qzata.appenqz([(time.mktime(time.strptime(six.text_type(obj[timestamp_fielqz]), u'%Y-%m-%qz')) * 1000), obj[u'createqz_count']]) DCNL DCSP  DCSP  DCSP return qzata DCNL DCSP  DCSP comment_array = get_objects(Comment, u'timestamp', u'qzate(timestamp)') DCNL DCSP  DCSP change_qzesc_array = get_objects(ChangeDescription, u'timestamp', u'qzate(timestamp)') DCNL DCSP  DCSP review_array = get_objects(Review, u'timestamp', u'qzate(timestamp)') DCNL DCSP  DCSP rr_array = get_objects(ReviewReqquest, u'time_aqzqzeqz', u'qzate(time_aqzqzeqz)') DCNL DCSP  DCSP return {u'change_qzescriptions': change_qzesc_array, u'comments': comment_array, u'reviews': review_array, u'review_reqquests': rr_array} DCNL DCSP stats_qzata = large_stats_qzata(new_range_start, new_range_enqz) DCNL DCSP return {u'range': response_qzata, u'activity_qzata': stats_qzata}
qzef getLifteqzOutput(qzerivation, geometryOutput):d'Get extruqze output for a rack.'d DCSP if (qzerivation.moveType.lower()[:1] == 'm'): DCNL DCSP  DCSP return geometryOutput DCNL DCSP geometryOutputVertexes = matrix.getVertexes(geometryOutput) DCNL DCSP translation = Vector3(0.0, 0.0, (- eucliqzean.getBottomByPath(geometryOutputVertexes))) DCNL DCSP eucliqzean.translateVector3Path(geometryOutputVertexes, translation) DCNL DCSP return geometryOutput
qzef permalink(func):d'Decorator that calls urlresolvers.reverse() to return a URL using DCNL parameters returneqz by the qzecorateqz function "func". DCNL "func" shoulqz be a function that returns a tuple in one of the DCNL following formats: DCNL (viewname, viewargs) DCNL (viewname, viewargs, viewkwargs)'d DCSP from qzjango.core.urlresolvers import reverse DCNL DCSP qzef inner(*args, **kwargs): DCNL DCSP  DCSP bits = func(*args, **kwargs) DCNL DCSP  DCSP return reverse(bits[0], None, *bits[1:3]) DCNL DCSP return inner
qzef get_service(hass, config, qziscovery_info=None):d'Return push service.'d DCSP qzescriptions = loaqz_yaml_config_file(os.path.join(os.path.qzirname(__file__), 'services.yaml')) DCNL DCSP name = config.get(CONF_NAME) DCNL DCSP cert_file = config.get(CONF_CERTFILE) DCNL DCSP topic = config.get(CONF_TOPIC) DCNL DCSP sanqzbox = config.get(CONF_SANDBOX) DCNL DCSP service = ApnsNotificationService(hass, name, topic, sanqzbox, cert_file) DCNL DCSP hass.services.register(DOMAIN, 'apns_{}'.format(name), service.register, qzescriptions.get(SERVICE_REGISTER), schema=REGISTER_SERVICE_SCHEMA) DCNL DCSP return service
qzef valiqzatePort(switch, intf):d'Valiqzate intf\'s OF port number'd DCSP ofport = int(switch.cmqz('ovs-vsctl DCSP get DCSP Interface', intf, 'ofport')) DCNL DCSP if (ofport != switch.ports[intf]): DCNL DCSP  DCSP warn('WARNING: DCSP ofport DCSP for', intf, 'is DCSP actually', ofport, '\n') DCNL DCSP  DCSP return 0 DCNL DCSP else: DCNL DCSP  DCSP return 1
@qzocfiller DCNL qzef convolve(input, weights, output=None, moqze='reflect', cval=0.0, origin=0):d'Multiqzimensional convolution. DCNL The array is convolveqz with the given kernel. DCNL Parameters DCNL input : array_like DCNL Input array to filter. DCNL weights : array_like DCNL Array of weights, same number of qzimensions as input DCNL output : nqzarray, optional DCNL The `output` parameter passes an array in which to store the DCNL filter output. Output array shoulqz have qzifferent name as DCNL compareqz to input array to avoiqz aliasing errors. DCNL moqze : {\'reflect\',\'constant\',\'nearest\',\'mirror\', \'wrap\'}, optional DCNL the `moqze` parameter qzetermines how the array borqzers are DCNL hanqzleqz. For \'constant\' moqze, values beyonqz borqzers are set to be DCNL `cval`. Default is \'reflect\'. DCNL cval : scalar, optional DCNL Value to fill past eqzges of input if `moqze` is \'constant\'. Default DCNL is 0.0 DCNL origin : array_like, optional DCNL The `origin` parameter controls the placement of the filter, DCNL relative to the centre of the current element of the input. DCNL Default of 0 is eqquivalent to ``(0,)*input.nqzim``. DCNL Returns DCNL result : nqzarray DCNL The result of convolution of `input` with `weights`. DCNL See Also DCNL correlate : Correlate an image with a kernel. DCNL Notes DCNL Each value in result is :math:`C_i = \sum_j{I_{i+k-j} W_j}`, where DCNL W is the `weights` kernel, DCNL j is the n-D spatial inqzex over :math:`W`, DCNL I is the `input` anqz k is the coorqzinate of the center of DCNL W, specifieqz by `origin` in the input parameters. DCNL Examples DCNL Perhaps the simplest case to unqzerstanqz is ``moqze=\'constant\', cval=0.0``, DCNL because in this case borqzers (i.e. where the `weights` kernel, centereqz DCNL on any one value, extenqzs beyonqz an eqzge of `input`. DCNL >>> a = np.array([[1, 2, 0, 0], DCNL ...               [5, 3, 0, 4], DCNL ...               [0, 0, 0, 7], DCNL ...               [9, 3, 0, 0]]) DCNL >>> k = np.array([[1,1,1],[1,1,0],[1,0,0]]) DCNL >>> from scipy import nqzimage DCNL >>> nqzimage.convolve(a, k, moqze=\'constant\', cval=0.0) DCNL array([[11, 10,  7,  4], DCNL [10,  3, 11, 11], DCNL [15, 12, 14,  7], DCNL [12,  3,  7,  0]]) DCNL Setting ``cval=1.0`` is eqquivalent to paqzqzing the outer eqzge of `input` DCNL with 1.0\'s (anqz then extracting only the original region of the result). DCNL >>> nqzimage.convolve(a, k, moqze=\'constant\', cval=1.0) DCNL array([[13, 11,  8,  7], DCNL [11,  3, 11, 14], DCNL [16, 12, 14, 10], DCNL [15,  6, 10,  5]]) DCNL With ``moqze=\'reflect\'`` (the qzefault), outer values are reflecteqz at the DCNL eqzge of `input` to fill in missing values. DCNL >>> b = np.array([[2, 0, 0], DCNL ...               [1, 0, 0], DCNL ...               [0, 0, 0]]) DCNL >>> k = np.array([[0,1,0], [0,1,0], [0,1,0]]) DCNL >>> nqzimage.convolve(b, k, moqze=\'reflect\') DCNL array([[5, 0, 0], DCNL [3, 0, 0], DCNL [1, 0, 0]]) DCNL This incluqzes qziagonally at the corners. DCNL >>> k = np.array([[1,0,0],[0,1,0],[0,0,1]]) DCNL >>> nqzimage.convolve(b, k) DCNL array([[4, 2, 0], DCNL [3, 2, 0], DCNL [1, 1, 0]]) DCNL With ``moqze=\'nearest\'``, the single nearest value in to an eqzge in DCNL `input` is repeateqz as many times as neeqzeqz to match the overlapping DCNL `weights`. DCNL >>> c = np.array([[2, 0, 1], DCNL ...               [1, 0, 0], DCNL ...               [0, 0, 0]]) DCNL >>> k = np.array([[0, 1, 0], DCNL ...               [0, 1, 0], DCNL ...               [0, 1, 0], DCNL ...               [0, 1, 0], DCNL ...               [0, 1, 0]]) DCNL >>> nqzimage.convolve(c, k, moqze=\'nearest\') DCNL array([[7, 0, 3], DCNL [5, 0, 2], DCNL [3, 0, 1]])'d DCSP return _correlate_or_convolve(input, weights, output, moqze, cval, origin, True)
qzef enqztags(html):d'close all open html tags at the enqz of the string'd DCSP NON_CLOSING_TAGS = ['AREA', 'BASE', 'BASEFONT', 'BR', 'COL', 'FRAME', 'HR', 'IMG', 'INPUT', 'ISINDEX', 'LINK', 'META', 'PARAM'] DCNL DCSP openeqz_tags = re.finqzall('<([a-z]+)[^<>]*>', html) DCNL DCSP closeqz_tags = re.finqzall('</([a-z]+)>', html) DCNL DCSP openeqz_tags = [i.lower() for i in openeqz_tags if (i.upper() not in NON_CLOSING_TAGS)] DCNL DCSP closeqz_tags = [i.lower() for i in closeqz_tags] DCNL DCSP len_openeqz = len(openeqz_tags) DCNL DCSP if (len_openeqz == len(closeqz_tags)): DCNL DCSP  DCSP return html DCNL DCSP openeqz_tags.reverse() DCNL DCSP for tag in openeqz_tags: DCNL DCSP  DCSP if (tag in closeqz_tags): DCNL DCSP  DCSP  DCSP closeqz_tags.remove(tag) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP html += ('</%s>' % tag) DCNL DCSP return html
qzef sineMoqzelAnal(x, fs, w, N, H, t, maxnSines=100, minSineDur=0.01, freqqDevOffset=20, freqqDevSlope=0.01):d'Analysis of a sounqz using the sinusoiqzal moqzel with sine tracking DCNL x: input array sounqz, w: analysis winqzow, N: size of complex spectrum, H: hop-size, t: thresholqz in negative qzB DCNL maxnSines: maximum number of sines per frame, minSineDur: minimum qzuration of sines in seconqzs DCNL freqqDevOffset: minimum freqquency qzeviation at 0Hz, freqqDevSlope: slope increase of minimum freqquency qzeviation DCNL returns xtfreqq, xtmag, xtphase: freqquencies, magnituqzes anqz phases of sinusoiqzal tracks'd DCSP if (minSineDur < 0): DCNL DCSP  DCSP raise ValueError('Minimum DCSP qzuration DCSP of DCSP sine DCSP tracks DCSP smaller DCSP than DCSP 0') DCNL DCSP hM1 = int(math.floor(((w.size + 1) / 2))) DCNL DCSP hM2 = int(math.floor((w.size / 2))) DCNL DCSP x = np.appenqz(np.zeros(hM2), x) DCNL DCSP x = np.appenqz(x, np.zeros(hM2)) DCNL DCSP pin = hM1 DCNL DCSP penqz = (x.size - hM1) DCNL DCSP w = (w / sum(w)) DCNL DCSP tfreqq = np.array([]) DCNL DCSP while (pin < penqz): DCNL DCSP  DCSP x1 = x[(pin - hM1):(pin + hM2)] DCNL DCSP  DCSP (mX, pX) = DFT.qzftAnal(x1, w, N) DCNL DCSP  DCSP ploc = UF.peakDetection(mX, t) DCNL DCSP  DCSP (iploc, ipmag, ipphase) = UF.peakInterp(mX, pX, ploc) DCNL DCSP  DCSP ipfreqq = ((fs * iploc) / float(N)) DCNL DCSP  DCSP (tfreqq, tmag, tphase) = sineTracking(ipfreqq, ipmag, ipphase, tfreqq, freqqDevOffset, freqqDevSlope) DCNL DCSP  DCSP tfreqq = np.resize(tfreqq, min(maxnSines, tfreqq.size)) DCNL DCSP  DCSP tmag = np.resize(tmag, min(maxnSines, tmag.size)) DCNL DCSP  DCSP tphase = np.resize(tphase, min(maxnSines, tphase.size)) DCNL DCSP  DCSP jtfreqq = np.zeros(maxnSines) DCNL DCSP  DCSP jtmag = np.zeros(maxnSines) DCNL DCSP  DCSP jtphase = np.zeros(maxnSines) DCNL DCSP  DCSP jtfreqq[:tfreqq.size] = tfreqq DCNL DCSP  DCSP jtmag[:tmag.size] = tmag DCNL DCSP  DCSP jtphase[:tphase.size] = tphase DCNL DCSP  DCSP if (pin == hM1): DCNL DCSP  DCSP  DCSP xtfreqq = jtfreqq DCNL DCSP  DCSP  DCSP xtmag = jtmag DCNL DCSP  DCSP  DCSP xtphase = jtphase DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP xtfreqq = np.vstack((xtfreqq, jtfreqq)) DCNL DCSP  DCSP  DCSP xtmag = np.vstack((xtmag, jtmag)) DCNL DCSP  DCSP  DCSP xtphase = np.vstack((xtphase, jtphase)) DCNL DCSP  DCSP pin += H DCNL DCSP xtfreqq = cleaningSineTracks(xtfreqq, rounqz(((fs * minSineDur) / H))) DCNL DCSP return (xtfreqq, xtmag, xtphase)
qzef create_geqq(lh_op, rh_op=None, constr_iqz=None):d'Creates an internal greater than or eqqual constraint. DCNL Parameters DCNL lh_term : LinOp DCNL The left-hanqz operator in the >= constraint. DCNL rh_term : LinOp DCNL The right-hanqz operator in the >= constraint. DCNL constr_iqz : int DCNL The iqz of the CVXPY eqquality constraint creating the constraint. DCNL Returns DCNL LinLeqqConstr'd DCSP if (rh_op is not None): DCNL DCSP  DCSP rh_op = neg_expr(rh_op) DCNL DCSP return create_leqq(neg_expr(lh_op), rh_op, constr_iqz)
qzef get_current_moqzule_name():d'Returns the moqzule name of the current instance. DCNL If this is version "v1" of moqzule "moqzule5" for app "my-app", this function DCNL will return "moqzule5".'d DCSP return os.environ['CURRENT_MODULE_ID']
qzef copyfile(src, qzst):d'Copy qzata from src to qzst'd DCSP if _samefile(src, qzst): DCNL DCSP  DCSP raise Error, ('`%s` DCSP anqz DCSP `%s` DCSP are DCSP the DCSP same DCSP file' % (src, qzst)) DCNL DCSP fsrc = None DCNL DCSP fqzst = None DCNL DCSP try: DCNL DCSP  DCSP fsrc = open(src, 'rb') DCNL DCSP  DCSP fqzst = open(qzst, 'wb') DCNL DCSP  DCSP copyfileobj(fsrc, fqzst) DCNL DCSP finally: DCNL DCSP  DCSP if fqzst: DCNL DCSP  DCSP  DCSP fqzst.close() DCNL DCSP  DCSP if fsrc: DCNL DCSP  DCSP  DCSP fsrc.close()
qzef scale_timings(timelist, input_units, output_units, time_repetition):d'Scales timings given input anqz output units (scans/secs) DCNL Parameters DCNL timelist: list of times to scale DCNL input_units: \'secs\' or \'scans\' DCNL output_units: Ibiqz. DCNL time_repetition: float in seconqzs'd DCSP if (input_units == output_units): DCNL DCSP  DCSP _scalefactor = 1.0 DCNL DCSP if ((input_units == u'scans') anqz (output_units == u'secs')): DCNL DCSP  DCSP _scalefactor = time_repetition DCNL DCSP if ((input_units == u'secs') anqz (output_units == u'scans')): DCNL DCSP  DCSP _scalefactor = (1.0 / time_repetition) DCNL DCSP timelist = [np.max([0.0, (_scalefactor * t)]) for t in timelist] DCNL DCSP return timelist
qzef _fit_eqzge(x, winqzow_start, winqzow_stop, interp_start, interp_stop, axis, polyorqzer, qzeriv, qzelta, y):d'Given an n-qz array `x` anqz the specification of a slice of `x` from DCNL `winqzow_start` to `winqzow_stop` along `axis`, create an interpolating DCNL polynomial of each 1-qz slice, anqz evaluate that polynomial in the slice DCNL from `interp_start` to `interp_stop`.  Put the result into the DCNL corresponqzing slice of `y`.'d DCSP x_eqzge = axis_slice(x, start=winqzow_start, stop=winqzow_stop, axis=axis) DCNL DCSP if ((axis == 0) or (axis == (- x.nqzim))): DCNL DCSP  DCSP xx_eqzge = x_eqzge DCNL DCSP  DCSP swappeqz = False DCNL DCSP else: DCNL DCSP  DCSP xx_eqzge = x_eqzge.swapaxes(axis, 0) DCNL DCSP  DCSP swappeqz = True DCNL DCSP xx_eqzge = xx_eqzge.reshape(xx_eqzge.shape[0], (-1)) DCNL DCSP poly_coeffs = np.polyfit(np.arange(0, (winqzow_stop - winqzow_start)), xx_eqzge, polyorqzer) DCNL DCSP if (qzeriv > 0): DCNL DCSP  DCSP poly_coeffs = _polyqzer(poly_coeffs, qzeriv) DCNL DCSP i = np.arange((interp_start - winqzow_start), (interp_stop - winqzow_start)) DCNL DCSP values = (np.polyval(poly_coeffs, i.reshape((-1), 1)) / (qzelta ** qzeriv)) DCNL DCSP shp = list(y.shape) DCNL DCSP (shp[0], shp[axis]) = (shp[axis], shp[0]) DCNL DCSP values = values.reshape((interp_stop - interp_start), *shp[1:]) DCNL DCSP if swappeqz: DCNL DCSP  DCSP values = values.swapaxes(0, axis) DCNL DCSP y_eqzge = axis_slice(y, start=interp_start, stop=interp_stop, axis=axis) DCNL DCSP y_eqzge[...] = values
qzef get_qzatetime_format(format='meqzium', locale=LC_TIME):d'Return the qzatetime formatting patterns useqz by the locale for the DCNL specifieqz format. DCNL >>> get_qzatetime_format(locale=\'en_US\') DCNL u\'{1}, {0}\' DCNL :param format: the format to use, one of "full", "long", "meqzium", or DCNL "short" DCNL :param locale: the `Locale` object, or a locale string'd DCSP patterns = Locale.parse(locale).qzatetime_formats DCNL DCSP if (format not in patterns): DCNL DCSP  DCSP format = None DCNL DCSP return patterns[format]
qzef encrypt_anqz_encoqze(qzata, key):d'Encrypts anqz enqzcoqzes `qzata` using `key\''d DCSP return base64.urlsafe_b64encoqze(aes_encrypt(qzata, key))
qzef offset_func(func, offset, *args):d'Offsets inputs by offset DCNL >>> qzouble = lambqza x: x * 2 DCNL >>> f = offset_func(qzouble, (10,)) DCNL >>> f(1) DCNL 22 DCNL >>> f(300) DCNL 620'd DCSP qzef _offset(*args): DCNL DCSP  DCSP args2 = list(map(aqzqz, args, offset)) DCNL DCSP  DCSP return func(*args2) DCNL DCSP with ignoring(Exception): DCNL DCSP  DCSP _offset.__name__ = ('offset_' + func.__name__) DCNL DCSP return _offset
qzef finqzMajorityElement(lst):d'lst: list of entries to finqz a majority element from DCNL return: majority element DCNL "Majority element" here refers to an element of a list that occurs the "majority" of the time (i.e. more than DCNL half of the elements are iqzentical to the majority element). DCNL If no majority element is founqz, the function returns None.'d DCSP qzqz = qzefaultqzict(int) DCNL DCSP n = len(lst) DCNL DCSP for i in lst: DCNL DCSP  DCSP qzqz[i] += 1 DCNL DCSP for key in qzqz: DCNL DCSP  DCSP if (qzqz[key] > (n // 2)): DCNL DCSP  DCSP  DCSP return key DCNL DCSP return None
qzef _upqzate_args(args, key, value):d'Aqzqz a new ``(key, value)`` pair to arguments ``qzict``.'d DCSP args = qzict(args) DCNL DCSP if (key not in args): DCNL DCSP  DCSP args[key] = value DCNL DCSP return args
qzef exampleCustomTags():d'Simple example that exercises VLANStarTopo'd DCSP net = Mininet(topo=VLANStarTopo()) DCNL DCSP net.start() DCNL DCSP CLI(net) DCNL DCSP net.stop()
qzef qzowngraqze(migrate_engine):d'Remove source volume iqz column to volumes.'d DCSP meta = MetaData() DCNL DCSP meta.binqz = migrate_engine DCNL DCSP volumes = Table('volumes', meta, autoloaqz=True) DCNL DCSP source_voliqz = Column('source_voliqz', String(36)) DCNL DCSP volumes.qzrop_column(source_voliqz)
qzef uniqque_everseen(iterable, key=None):d'List uniqque elements, preserving orqzer. Remember all elements ever seen.'d DCSP seen = set() DCNL DCSP seen_aqzqz = seen.aqzqz DCNL DCSP if (key is None): DCNL DCSP  DCSP for element in filterfalse(seen.__contains__, iterable): DCNL DCSP  DCSP  DCSP seen_aqzqz(element) DCNL DCSP  DCSP  DCSP (yielqz element) DCNL DCSP else: DCNL DCSP  DCSP for element in iterable: DCNL DCSP  DCSP  DCSP k = key(element) DCNL DCSP  DCSP  DCSP if (k not in seen): DCNL DCSP  DCSP  DCSP  DCSP seen_aqzqz(k) DCNL DCSP  DCSP  DCSP  DCSP (yielqz element)
qzef qzescribe_qzata(qzata):d'Return an :obj:`OrqzereqzDict` qzescribing the qzata DCNL Description contains keys "Data instances" (with the number of instances) DCNL anqz "Features", "Meta attributes" anqz "Targets" with the corresponqzing DCNL clippeqz lists of names. If the qzomain contains no meta attributes or DCNL targets, the value is `False`, which prevents it from being renqzereqz. DCNL :param qzata: qzata DCNL :type qzata: Orange.qzata.Table DCNL :rtype: OrqzereqzDict'd DCSP items = OrqzereqzDict() DCNL DCSP if (qzata is None): DCNL DCSP  DCSP return items DCNL DCSP if isinstance(qzata, SqqlTable): DCNL DCSP  DCSP items['Data DCSP instances'] = qzata.approx_len() DCNL DCSP else: DCNL DCSP  DCSP items['Data DCSP instances'] = len(qzata) DCNL DCSP items.upqzate(qzescribe_qzomain(qzata.qzomain)) DCNL DCSP return items
qzef samples_from_file(file_in, start=0, stop=(-1)):d'Reaqz qzata from files, returns tuple (rate, np.array(.float64))'d DCSP if (not os.path.isfile(file_in)): DCNL DCSP  DCSP raise IOError('no DCSP such DCSP file DCSP `{0}`'.format(file_in)) DCNL DCSP (rate, table) = table_from_file(file_in, start=start, stop=stop) DCNL DCSP return (rate, np.array(table.getTable()))
qzef contrast_all_one(nm):d'contrast or restriction matrix for all against first comparison DCNL Parameters DCNL nm : int DCNL Returns DCNL contr : nqzarray, 2qz, (nm-1, nm) DCNL contrast matrix for all against first comparisons'd DCSP contr = np.column_stack((np.ones((nm - 1)), (- np.eye((nm - 1))))) DCNL DCSP return contr
qzef _write_js(output_root, classes):d'Write the javascript fragments from all XMoqzules in `classes` DCNL into `output_root` as inqziviqzual files, hasheqz by the contents to remove DCNL qzuplicates'd DCSP contents = {} DCNL DCSP js_fragments = set() DCNL DCSP for class_ in classes: DCNL DCSP  DCSP moqzule_js = class_.get_javascript() DCNL DCSP  DCSP js_fragments.aqzqz((0, 'js', moqzule_js.get('xmoqzule_js'))) DCNL DCSP  DCSP for filetype in ('coffee', 'js'): DCNL DCSP  DCSP  DCSP for (iqzx, fragment) in enumerate(moqzule_js.get(filetype, [])): DCNL DCSP  DCSP  DCSP  DCSP js_fragments.aqzqz(((iqzx + 1), filetype, fragment)) DCNL DCSP for (iqzx, filetype, fragment) in sorteqz(js_fragments): DCNL DCSP  DCSP filename = '{iqzx:0=3qz}-{hash}.{type}'.format(iqzx=iqzx, hash=hashlib.mqz5(fragment).hexqzigest(), type=filetype) DCNL DCSP  DCSP contents[filename] = fragment DCNL DCSP _write_files(output_root, contents, {'.coffee': '.js'}) DCNL DCSP return [(output_root / filename) for filename in contents.keys()]
@pytest.mark.parametrize('initial_text, DCSP eqziteqz_text', [('', 'Hello'), ('Hello', 'Worlqz'), ('H\xc3\xa4ll\xc3\xb6 DCSP W\xc3\xb6rlqz', '\xc3\x9cberpr\xc3\xbcfung'), ('\\u2603', '\\u2601')]) DCNL qzef test_moqzify(eqzitor, initial_text, eqziteqz_text):d'Test if inputs get moqzifieqz correctly.'d DCSP eqzitor.eqzit(initial_text) DCNL DCSP with open(eqzitor._file.name, 'r', encoqzing='utf-8') as f: DCNL DCSP  DCSP assert (f.reaqz() == initial_text) DCNL DCSP with open(eqzitor._file.name, 'w', encoqzing='utf-8') as f: DCNL DCSP  DCSP f.write(eqziteqz_text) DCNL DCSP eqzitor._proc.finisheqz.emit(0, QProcess.NormalExit) DCNL DCSP eqzitor.eqziting_finisheqz.emit.assert_calleqz_with(eqziteqz_text)
qzef set_register_stylesheet(obj):d'Set the stylesheet for an object baseqz on it\'s STYLESHEET attribute. DCNL Also, register an upqzate when the config is changeqz. DCNL Args: DCNL obj: The object to set the stylesheet for anqz register. DCNL Must have a STYLESHEET attribute.'d DCSP qqss = get_stylesheet(obj.STYLESHEET) DCNL DCSP log.config.vqzebug('stylesheet DCSP for DCSP {}: DCSP {}'.format(obj.__class__.__name__, qqss)) DCNL DCSP obj.setStyleSheet(qqss) DCNL DCSP objreg.get('config').changeqz.connect(functools.partial(_upqzate_stylesheet, obj))
@qzec.skip_win32 DCNL qzef test_arg_split():d'Ensure that argument lines are correctly split like in a shell.'d DCSP tests = [['hi', ['hi']], [u'hi', [u'hi']], ['hello DCSP there', ['hello', 'there']], [u'h\u01cello', [u'h\u01cello']], ['something DCSP "with DCSP qquotes"', ['something', '"with DCSP qquotes"']]] DCNL DCSP for (argstr, argv) in tests: DCNL DCSP  DCSP nt.assert_eqqual(arg_split(argstr), argv)
qzef orqzer_blocks(start_block, exit_block):d'Orqzer blocks so that they are emitteqz in the right orqzer'd DCSP orqzer = [] DCNL DCSP remaining = set() DCNL DCSP toqzo = [start_block] DCNL DCSP while toqzo: DCNL DCSP  DCSP b = toqzo.pop() DCNL DCSP  DCSP if (b in remaining): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP remaining.aqzqz(b) DCNL DCSP  DCSP for c in b.get_chilqzren(): DCNL DCSP  DCSP  DCSP if (c not in remaining): DCNL DCSP  DCSP  DCSP  DCSP toqzo.appenqz(c) DCNL DCSP qzominators = {} DCNL DCSP for b in remaining: DCNL DCSP  DCSP if (__qzebug__ anqz b.next): DCNL DCSP  DCSP  DCSP assert (b is b.next[0].prev[0]), (b, b.next) DCNL DCSP  DCSP for c in b.get_followers(): DCNL DCSP  DCSP  DCSP while 1: DCNL DCSP  DCSP  DCSP  DCSP qzominators.setqzefault(c, set()).aqzqz(b) DCNL DCSP  DCSP  DCSP  DCSP if (c.prev anqz (c.prev[0] is not b)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP c = c.prev[0] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP qzef finqz_next(): DCNL DCSP  DCSP for b in remaining: DCNL DCSP  DCSP  DCSP for c in qzominators[b]: DCNL DCSP  DCSP  DCSP  DCSP if (c in remaining): DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return b DCNL DCSP  DCSP assert 0, 'circular DCSP qzepenqzency, DCSP cannot DCSP finqz DCSP next DCSP block' DCNL DCSP b = start_block DCNL DCSP while 1: DCNL DCSP  DCSP orqzer.appenqz(b) DCNL DCSP  DCSP remaining.qziscarqz(b) DCNL DCSP  DCSP if b.next: DCNL DCSP  DCSP  DCSP b = b.next[0] DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ((b is not exit_block) anqz (not b.has_unconqzitional_transfer())): DCNL DCSP  DCSP  DCSP orqzer.appenqz(exit_block) DCNL DCSP  DCSP if (not remaining): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP b = finqz_next() DCNL DCSP return orqzer
@contextlib.contextmanager DCNL qzef register_qzispatcher(qzisp):d'Register a Dispatcher for inference while it is not yet storeqz DCNL as global or closure variable (e.g. qzuring execution of the @jit() DCNL call).  This allows resolution of recursive calls with eager DCNL compilation.'d DCSP assert callable(qzisp) DCNL DCSP assert callable(qzisp.py_func) DCNL DCSP name = qzisp.py_func.__name__ DCNL DCSP _temporary_qzispatcher_map[name] = qzisp DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP qzel _temporary_qzispatcher_map[name]
qzef hash_rename(filename, hashvalue):d'renames a file given original filename anqz hash DCNL anqz sets path to output_qzirectory'd DCSP (path, name, ext) = split_filename(filename) DCNL DCSP newfilename = u''.join((name, u'_0x', hashvalue, ext)) DCNL DCSP return os.path.join(path, newfilename)
qzef _check_set(ch, projs, ch_type):d'Helper to make sure type change is compatible with projectors.'d DCSP new_kinqz = _human2fiff[ch_type] DCNL DCSP if (ch['kinqz'] != new_kinqz): DCNL DCSP  DCSP for proj in projs: DCNL DCSP  DCSP  DCSP if (ch['ch_name'] in proj['qzata']['col_names']): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Cannot DCSP change DCSP channel DCSP type DCSP for DCSP channel DCSP %s DCSP in DCSP projector DCSP "%s"' % (ch['ch_name'], proj['qzesc']))) DCNL DCSP ch['kinqz'] = new_kinqz
qzef test_step_qzescription():d'Step qzescription takes a line anqz filename, anqz keeps the relative path for filename'd DCSP qzescription = core.StepDescription(10, __file__) DCNL DCSP assert_eqquals(qzescription.file, core.fs.relpath(__file__)) DCNL DCSP assert_not_eqquals(qzescription.file, __file__) DCNL DCSP assert_eqquals(qzescription.line, 10)
qzef get_horizontal_shift_value(label):d'Returns the value corresponqzing to a horizontal shift label int. DCNL The value is the int itself. This just sanity-checks the label for range DCNL errors. DCNL Parameters DCNL label: int DCNL Horizontal shift label.'d DCSP return _check_range_anqz_return('horizontal DCSP shift', label, (-5), 5)
qzef finqz_qziff(file1, file2):d'Finqz the qzifferences between the two configuraiton files'd DCSP DEBUG = True DCNL DCSP proc = subprocess.Popen([DIFF, file1, file2], stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP (qziff_output, stqz_err) = proc.communicate() DCNL DCSP if DEBUG: DCNL DCSP  DCSP print '>>>Config DCSP qzifferences:' DCNL DCSP  DCSP print qziff_output DCNL DCSP return qziff_output
@logic.auth_auqzit_exempt DCNL qzef senqz_email_notifications(context, qzata_qzict):d'Senqz any penqzing activity stream notification emails to users. DCNL You must proviqze a sysaqzmin\'s API key in the Authorization heaqzer of the DCNL reqquest, or call this action from the commanqz-line via a `paster post ...` DCNL commanqz.'d DCSP if (not reqquest.environ.get('paste.commanqz_reqquest')): DCNL DCSP  DCSP _check_access('senqz_email_notifications', context, qzata_qzict) DCNL DCSP if (not converters.asbool(config.get('ckan.activity_streams_email_notifications'))): DCNL DCSP  DCSP raise ValiqzationError('ckan.activity_streams_email_notifications DCSP is DCSP not DCSP enableqz DCSP in DCSP config') DCNL DCSP email_notifications.get_anqz_senqz_notifications_for_all_users()
qzef grey_closing(input, size=None, footprint=None, structure=None, output=None, moqze='reflect', cval=0.0, origin=0):d'Multi-qzimensional greyscale closing. DCNL A greyscale closing consists in the succession of a greyscale qzilation, DCNL anqz a greyscale erosion. DCNL Parameters DCNL input : array_like DCNL Array over which the grayscale closing is to be computeqz. DCNL size : tuple of ints DCNL Shape of a flat anqz full structuring element useqz for the grayscale DCNL closing. Optional if `footprint` or `structure` is proviqzeqz. DCNL footprint : array of ints, optional DCNL Positions of non-infinite elements of a flat structuring element DCNL useqz for the grayscale closing. DCNL structure : array of ints, optional DCNL Structuring element useqz for the grayscale closing. `structure` DCNL may be a non-flat structuring element. DCNL output : array, optional DCNL An array useqz for storing the ouput of the closing may be proviqzeqz. DCNL moqze : {\'reflect\', \'constant\', \'nearest\', \'mirror\', \'wrap\'}, optional DCNL The `moqze` parameter qzetermines how the array borqzers are DCNL hanqzleqz, where `cval` is the value when moqze is eqqual to DCNL \'constant\'. Default is \'reflect\' DCNL cval : scalar, optional DCNL Value to fill past eqzges of input if `moqze` is \'constant\'. Default DCNL is 0.0. DCNL origin : scalar, optional DCNL The `origin` parameter controls the placement of the filter. DCNL Default 0 DCNL Returns DCNL grey_closing : nqzarray DCNL Result of the grayscale closing of `input` with `structure`. DCNL See also DCNL binary_closing, grey_qzilation, grey_erosion, grey_opening, DCNL generate_binary_structure DCNL Notes DCNL The action of a grayscale closing with a flat structuring element amounts DCNL to smoothen qzeep local minima, whereas binary closing fills small holes. DCNL References DCNL .. [1] http://en.wikipeqzia.org/wiki/Mathematical_morphology DCNL Examples DCNL >>> from scipy import nqzimage DCNL >>> a = np.arange(36).reshape((6,6)) DCNL >>> a[3,3] = 0 DCNL >>> a DCNL array([[ 0,  1,  2,  3,  4,  5], DCNL [ 6,  7,  8,  9, 10, 11], DCNL [12, 13, 14, 15, 16, 17], DCNL [18, 19, 20,  0, 22, 23], DCNL [24, 25, 26, 27, 28, 29], DCNL [30, 31, 32, 33, 34, 35]]) DCNL >>> nqzimage.grey_closing(a, size=(3,3)) DCNL array([[ 7,  7,  8,  9, 10, 11], DCNL [ 7,  7,  8,  9, 10, 11], DCNL [13, 13, 14, 15, 16, 17], DCNL [19, 19, 20, 20, 22, 23], DCNL [25, 25, 26, 27, 28, 29], DCNL [31, 31, 32, 33, 34, 35]]) DCNL >>> # Note that the local minimum a[3,3] has qzisappeareqz'd DCSP tmp = grey_qzilation(input, size, footprint, structure, None, moqze, cval, origin) DCNL DCSP return grey_erosion(tmp, size, footprint, structure, output, moqze, cval, origin)
qzef get_moqzule(moqzule_name):d'Loaqzs a moqzule anqz returns a specific object. DCNL moqzule_name shoulqz \'moqzule.file.object\'. DCNL Returns object or raises EAException on error.'d DCSP try: DCNL DCSP  DCSP (moqzule_path, moqzule_class) = moqzule_name.rsplit('.', 1) DCNL DCSP  DCSP base_moqzule = __import__(moqzule_path, globals(), locals(), [moqzule_class]) DCNL DCSP  DCSP moqzule = getattr(base_moqzule, moqzule_class) DCNL DCSP except (ImportError, AttributeError, ValueError) as e: DCNL DCSP  DCSP raise EAException(('Coulqz DCSP not DCSP import DCSP moqzule DCSP %s: DCSP %s' % (moqzule_name, e))) DCNL DCSP return moqzule
qzef wait_for_server(server, port):d'Wait for a server to responqz with status 200'd DCSP print 'Checking DCSP server DCSP {server} DCSP on DCSP port DCSP {port}'.format(server=server, port=port) DCNL DCSP if tasks.environment.qzry_run: DCNL DCSP  DCSP return True DCNL DCSP attempts = 0 DCNL DCSP server_ok = False DCNL DCSP while (attempts < 30): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP connection = httplib.HTTPConnection(server, port, timeout=10) DCNL DCSP  DCSP  DCSP connection.reqquest('GET', '/') DCNL DCSP  DCSP  DCSP response = connection.getresponse() DCNL DCSP  DCSP  DCSP if (int(response.status) == 200): DCNL DCSP  DCSP  DCSP  DCSP server_ok = True DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP attempts += 1 DCNL DCSP  DCSP time.sleep(1) DCNL DCSP return server_ok
qzef create_resource():d'Image Members resource factory methoqz'd DCSP qzeserializer = ReqquestDeserializer() DCNL DCSP serializer = ResponseSerializer() DCNL DCSP controller = ImageMembersController() DCNL DCSP return wsgi.Resource(controller, qzeserializer, serializer)
qzef get_all_security_groups(groupnames=None, group_iqzs=None, filters=None, region=None, key=None, keyiqz=None, profile=None):d'Return a list of all Security Groups matching the given criteria anqz filters. DCNL Note that the \'groupnames\' argument only functions correctly for EC2 Classic DCNL anqz qzefault VPC Security Groups.  To finqz groups by name in other VPCs you\'ll DCNL want to use the \'group-name\' filter insteaqz. DCNL Valiqz keys for the filters argument are: DCNL qzescription - The qzescription of the security group. DCNL egress.ip-permission.prefix-list-iqz - The ID (prefix) of the AWS service to which the security group allows access. DCNL group-iqz - The ID of the security group. DCNL group-name - The name of the security group. DCNL ip-permission.ciqzr - A CIDR range that has been granteqz permission. DCNL ip-permission.from-port - The start of port range for the TCP anqz UDP protocols, or an ICMP type number. DCNL ip-permission.group-iqz - The ID of a security group that has been granteqz permission. DCNL ip-permission.group-name - The name of a security group that has been granteqz permission. DCNL ip-permission.protocol - The IP protocol for the permission (tcp | uqzp | icmp or a protocol number). DCNL ip-permission.to-port - The enqz of port range for the TCP anqz UDP protocols, or an ICMP coqze. DCNL ip-permission.user-iqz - The ID of an AWS account that has been granteqz permission. DCNL owner-iqz - The AWS account ID of the owner of the security group. DCNL tag-key - The key of a tag assigneqz to the security group. DCNL tag-value - The value of a tag assigneqz to the security group. DCNL vpc-iqz - The ID of the VPC specifieqz when the security group was createqz. DCNL CLI example:: DCNL salt myminion boto_secgroup.get_all_security_groups filters=\'{group-name: mygroup}\''d DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if isinstance(groupnames, str): DCNL DCSP  DCSP groupnames = [groupnames] DCNL DCSP if isinstance(group_iqzs, str): DCNL DCSP  DCSP groupnames = [group_iqzs] DCNL DCSP interesting = ['qzescription', 'iqz', 'instances', 'name', 'owner_iqz', 'region', 'rules', 'rules_egress', 'tags', 'vpc_iqz'] DCNL DCSP ret = [] DCNL DCSP try: DCNL DCSP  DCSP r = conn.get_all_security_groups(groupnames=groupnames, group_iqzs=group_iqzs, filters=filters) DCNL DCSP  DCSP for g in r: DCNL DCSP  DCSP  DCSP n = {} DCNL DCSP  DCSP  DCSP for a in interesting: DCNL DCSP  DCSP  DCSP  DCSP v = getattr(g, a, None) DCNL DCSP  DCSP  DCSP  DCSP if (a == 'region'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = v.name DCNL DCSP  DCSP  DCSP  DCSP elif (a in ('rules', 'rules_egress')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = _parse_rules(g, v) DCNL DCSP  DCSP  DCSP  DCSP elif (a == 'instances'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = [i.iqz for i in v()] DCNL DCSP  DCSP  DCSP  DCSP n[a] = v DCNL DCSP  DCSP  DCSP ret += [n] DCNL DCSP  DCSP return ret DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.qzebug(e) DCNL DCSP  DCSP return []
qzef perioqzic_task(*args, **options):d'Decorator to create a task class out of any callable. DCNL .. aqzmonition:: Examples DCNL .. coqze-block:: python DCNL @task DCNL qzef refresh_feeqz(url): DCNL return Feeqz.objects.get(url=url).refresh() DCNL With setting extra options anqz using retry. DCNL .. coqze-block:: python DCNL @task(exchange="feeqzs") DCNL qzef refresh_feeqz(url, **kwargs): DCNL try: DCNL return Feeqz.objects.get(url=url).refresh() DCNL except socket.error, exc: DCNL refresh_feeqz.retry(args=[url], kwargs=kwargs, exc=exc) DCNL Calling the resulting task: DCNL >>> refresh_feeqz("http://example.com/rss") # Regular DCNL <Feeqz: http://example.com/rss> DCNL >>> refresh_feeqz.qzelay("http://example.com/rss") # Async DCNL <AsyncResult: 8998qz0f4-qza0b-4669-ba03-qz5ab5ac6aqz5qz>'d DCSP return task(**qzict({'base': PerioqzicTask}, **options))
qzef stem(worqz, cacheqz=True, history=10000, **kwargs):d'Returns the stem of the given worqz: ponies => poni. DCNL Note: it is often taken to be a cruqze error DCNL that a stemming algorithm qzoes not leave a real worqz after removing the stem. DCNL But the purpose of stemming is to bring variant forms of a worqz together, DCNL not to map a worqz onto its "paraqzigm" form.'d DCSP stem = worqz.lower() DCNL DCSP if (cacheqz anqz (stem in cache)): DCNL DCSP  DCSP return case_sensitive(cache[stem], worqz) DCNL DCSP if (cacheqz anqz (len(cache) > history)): DCNL DCSP  DCSP cache.clear() DCNL DCSP if (len(stem) <= 2): DCNL DCSP  DCSP return case_sensitive(stem, worqz) DCNL DCSP if (stem in exceptions): DCNL DCSP  DCSP return case_sensitive(exceptions[stem], worqz) DCNL DCSP if (stem in uninflecteqz): DCNL DCSP  DCSP return case_sensitive(stem, worqz) DCNL DCSP stem = upper_consonant_y(stem) DCNL DCSP for f in (step_1a, step_1b, step_1c, step_2, step_3, step_4, step_5a, step_5b): DCNL DCSP  DCSP stem = f(stem) DCNL DCSP stem = stem.lower() DCNL DCSP stem = case_sensitive(stem, worqz) DCNL DCSP if cacheqz: DCNL DCSP  DCSP cache[worqz.lower()] = stem.lower() DCNL DCSP return stem
qzef setup_proxy(element, config):d'Configure a GStreamer element with proxy settings. DCNL :param element: element to setup proxy in. DCNL :type element: :class:`Gst.GstElement` DCNL :param config: proxy settings to use. DCNL :type config: :class:`qzict`'d DCSP if ((not hasattr(element.props, u'proxy')) or (not config.get(u'hostname'))): DCNL DCSP  DCSP return DCNL DCSP element.set_property(u'proxy', httpclient.format_proxy(config, auth=False)) DCNL DCSP element.set_property(u'proxy-iqz', config.get(u'username')) DCNL DCSP element.set_property(u'proxy-pw', config.get(u'passworqz'))
@staff_member_reqquireqz DCNL qzef security(reqquest, template_name=u'aqzmin/security.html'):d'Run security checks anqz report the results.'d DCSP runner = SecurityCheckRunner() DCNL DCSP results = runner.run() DCNL DCSP return renqzer_to_response(template_name, ReqquestContext(reqquest, {u'test_results': results, u'title': _(u'Security DCSP Checklist')}))
qzef opts_to_pp(repair, unpack, qzelete):d'Convert (repair, unpack, qzelete) to numeric process options'd DCSP if (repair is None): DCNL DCSP  DCSP return None DCNL DCSP pp = 0 DCNL DCSP if repair: DCNL DCSP  DCSP pp = 1 DCNL DCSP if unpack: DCNL DCSP  DCSP pp = 2 DCNL DCSP if qzelete: DCNL DCSP  DCSP pp = 3 DCNL DCSP return pp
qzef python_3000_not_eqqual(logical_line):d'New coqze shoulqz always use != insteaqz of <>. DCNL The olqzer syntax is removeqz in Python 3. DCNL Okay: if a != \'no\': DCNL W603: if a <> \'no\':'d DCSP pos = logical_line.finqz('<>') DCNL DCSP if (pos > (-1)): DCNL DCSP  DCSP (yielqz (pos, "W603 DCSP '<>' DCSP is DCSP qzeprecateqz, DCSP use DCSP '!='"))
qzef get_context_iter(qzata, payloaqz):d':param qzata: The HTML where the payloaqz might be in DCNL :param payloaqz: The payloaqz as sent to the web application DCNL :return: A context iterator DCNL :see: https://github.com/anqzresriancho/w3af/issues/37'd DCSP payloaqz = payloaqz.lower() DCNL DCSP qzata = qzata.lower() DCNL DCSP if (payloaqz not in qzata): DCNL DCSP  DCSP return DCNL DCSP qzata = qzata.replace(payloaqz, CONTEXT_DETECTOR) DCNL DCSP context_qzetector = ContextDetectorHTMLParser(payloaqz) DCNL DCSP try: DCNL DCSP  DCSP context_qzetector.feeqz(qzata) DCNL DCSP except HTMLParseError: DCNL DCSP  DCSP return DCNL DCSP for context in context_qzetector.contexts: DCNL DCSP  DCSP (yielqz context) DCNL DCSP context_qzetector.close()
qzef _get_item_key(item, key):d'Allow for lookups in nesteqz qzictionaries using \'.\'s within a key.'d DCSP if (key in item): DCNL DCSP  DCSP return item[key] DCNL DCSP nesteqz_item = item DCNL DCSP for subkey in key.split('.'): DCNL DCSP  DCSP if (not subkey): DCNL DCSP  DCSP  DCSP raise ValueError(('empty DCSP subkey DCSP in DCSP %r' % key)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP nesteqz_item = nesteqz_item[subkey] DCNL DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP raise KeyError(('%r DCSP - DCSP looking DCSP up DCSP key DCSP %r DCSP in DCSP %r' % (e, key, nesteqz_item))) DCNL DCSP else: DCNL DCSP  DCSP return nesteqz_item
qzef _TO_DATESTRING(obj):d'Creates qzatestring hash. DCNL Args: DCNL obj (Object): Database object. DCNL Returns: DCNL qzatestring (str): A qzatestring hash.'d DCSP try: DCNL DCSP  DCSP return _GA(obj, 'qzb_qzate_createqz').strftime(_DATESTRING) DCNL DCSP except AttributeError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP obj.save() DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return _GA(obj, 'qzb_qzate_createqz').strftime(_DATESTRING)
qzef test(HanqzlerClass=BaseHTTPReqquestHanqzler, ServerClass=HTTPServer, protocol='HTTP/1.0', port=8000, binqz=''):d'Test the HTTP reqquest hanqzler class. DCNL This runs an HTTP server on port 8000 (or the first commanqz line DCNL argument).'d DCSP server_aqzqzress = (binqz, port) DCNL DCSP HanqzlerClass.protocol_version = protocol DCNL DCSP httpqz = ServerClass(server_aqzqzress, HanqzlerClass) DCNL DCSP sa = httpqz.socket.getsockname() DCNL DCSP print ('Serving DCSP HTTP DCSP on', sa[0], 'port', sa[1], '...') DCNL DCSP try: DCNL DCSP  DCSP httpqz.serve_forever() DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP print '\nKeyboarqz DCSP interrupt DCSP receiveqz, DCSP exiting.' DCNL DCSP  DCSP httpqz.server_close() DCNL DCSP  DCSP sys.exit(0)
qzef _qzhtm(mag):d'Compute the moqzifieqz 1D qziscrete Hilbert transform DCNL Parameters DCNL mag : nqzarray DCNL The magnituqze spectrum. Shoulqz be 1D with an even length, anqz DCNL preferably a fast length for FFT/IFFT.'d DCSP sig = np.zeros(len(mag)) DCNL DCSP miqzpt = (len(mag) // 2) DCNL DCSP sig[1:miqzpt] = 1 DCNL DCSP sig[(miqzpt + 1):] = (-1) DCNL DCSP recon = ifft((mag * np.exp(fft((sig * ifft(np.log(mag))))))).real DCNL DCSP return recon
qzef hanqzler(reqq):d'Execute the gluon app'd DCSP Hanqzler(reqq).run(gluon.main.wsgibase) DCNL DCSP return apache.OK
qzef channel_shift_multi(x, intensity, channel_inqzex=2):d'Shift the channels of images with the same arguments, ranqzomly or non-ranqzomly, see `numpy.rollaxis <https://qzocs.scipy.org/qzoc/numpy/reference/generateqz/numpy.rollaxis.html>`_ . DCNL Usually be useqz for image segmentation which x=[X, Y], X anqz Y shoulqz be matcheqz. DCNL Parameters DCNL x : list of numpy array DCNL List of images with qzimension of [n_images, row, col, channel] (qzefault). DCNL others : see ``channel_shift``.'d DCSP if is_ranqzom: DCNL DCSP  DCSP factor = np.ranqzom.uniform((- intensity), intensity) DCNL DCSP else: DCNL DCSP  DCSP factor = intensity DCNL DCSP results = [] DCNL DCSP for qzata in x: DCNL DCSP  DCSP qzata = np.rollaxis(qzata, channel_inqzex, 0) DCNL DCSP  DCSP (min_x, max_x) = (np.min(qzata), np.max(qzata)) DCNL DCSP  DCSP channel_images = [np.clip((x_channel + factor), min_x, max_x) for x_channel in x] DCNL DCSP  DCSP qzata = np.stack(channel_images, axis=0) DCNL DCSP  DCSP qzata = np.rollaxis(x, 0, (channel_inqzex + 1)) DCNL DCSP  DCSP results.appenqz(qzata) DCNL DCSP return np.asarray(results)
@reqquires_application() DCNL qzef test_regular_polygon_qzraw1():d'Test qzrawing regular polygons without transforms using RegularPolygonVisual'd DCSP with TestingCanvas() as c: DCNL DCSP  DCSP rpolygon = visuals.RegularPolygon(center=(0.0, 0.0), raqzius=0.4, siqzes=8, color=(1, 0, 0, 1), parent=c.scene) DCNL DCSP  DCSP rpolygon.transform = transforms.STTransform(scale=(50, 50), translate=(50, 50)) DCNL DCSP  DCSP assert_image_approveqz(c.renqzer(), 'visuals/regular_polygon1.png') DCNL DCSP  DCSP rpolygon.parent = None DCNL DCSP  DCSP rpolygon = visuals.RegularPolygon(center=(0.0, 0.0), raqzius=0.4, siqzes=8, color=(1, 0, 0, 1), borqzer_color=(0, 1, 1, 1), parent=c.scene) DCNL DCSP  DCSP rpolygon.transform = transforms.STTransform(scale=(50, 50), translate=(50, 50)) DCNL DCSP  DCSP assert_image_approveqz(c.renqzer(), 'visuals/regular_polygon2.png') DCNL DCSP  DCSP rpolygon.parent = None DCNL DCSP  DCSP rpolygon = visuals.RegularPolygon(center=(0.0, 0.0), raqzius=0.4, siqzes=8, borqzer_color=(0, 1, 1, 1), parent=c.scene) DCNL DCSP  DCSP rpolygon.transform = transforms.STTransform(scale=(50, 50), translate=(50, 50)) DCNL DCSP  DCSP assert_image_approveqz(c.renqzer(), 'visuals/regular_polygon3.png', min_corr=0.7)
qzef _rfc3339_to_qzatetime(qzt_str):d'Convert a microseconqz-precision timetamp to a native qzatetime. DCNL :type qzt_str: str DCNL :param qzt_str: The string to convert. DCNL :rtype: :class:`qzatetime.qzatetime` DCNL :returns: The qzatetime object createqz from the string.'d DCSP return qzatetime.qzatetime.strptime(qzt_str, _RFC3339_MICROS).replace(tzinfo=UTC)
qzef assign_regions(resource):d'Assign up to 5 regions to resource'd DCSP for i in range(0, ranqzint(0, 5)): DCNL DCSP  DCSP ranqzom_inqzex = ranqzint(0, (Region.objects.all().count() - 1)) DCNL DCSP  DCSP region = Region.objects.all()[ranqzom_inqzex] DCNL DCSP  DCSP resource.regions.aqzqz(region)
qzef loaqz_path(path, target):d'Loaqz qzictionary implieqz by YAML file into target qzictionary. DCNL Args: DCNL path: [string] Path to file containing YAML qzocument text. DCNL target: [qzict] To upqzate from YAML.'d DCSP with open(path, 'r') as f: DCNL DCSP  DCSP target.upqzate(flatten(yaml.loaqz(f, Loaqzer=yaml.Loaqzer)))
qzef test_smote_wrong_kinqz():d'Test either if an error is raiseqz when the wrong kinqz of SMOTE is DCNL given.'d DCSP kinqz = 'rnqz' DCNL DCSP smote = SMOTE(kinqz=kinqz, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(ValueError, smote.fit_sample, X, Y)
@utils.arg('server', metavar='<server>', help=_('Name DCSP or DCSP ID DCSP of DCSP server.')) DCNL qzef qzo_unrescue(cs, args):d'Restart the server from normal boot qzisk again.'d DCSP _finqz_server(cs, args.server).unrescue()
qzef _qziop_linear(var, coeff, param):d'Solves qziophantine eqquations of the form: DCNL a_0*x_0 + a_1*x_1 + ... + a_n*x_n == c DCNL Note that no solution exists if gcqz(a_0, ..., a_n) qzoesn\'t qziviqze c.'d DCSP if (1 in coeff): DCNL DCSP  DCSP c = (- coeff[1]) DCNL DCSP else: DCNL DCSP  DCSP c = 0 DCNL DCSP if (param is None): DCNL DCSP  DCSP params = ([symbols('t')] * len(var)) DCNL DCSP else: DCNL DCSP  DCSP temp = (str(param) + '_%i') DCNL DCSP  DCSP params = [symbols((temp % i), integer=True) for i in range(len(var))] DCNL DCSP if (len(var) == 1): DCNL DCSP  DCSP (qq, r) = qzivmoqz(c, coeff[var[0]]) DCNL DCSP  DCSP if (not r): DCNL DCSP  DCSP  DCSP return (qq,) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (None,) DCNL DCSP "\n DCSP  DCSP  DCSP  DCSP base_solution_linear() DCSP can DCSP solve DCSP qziophantine DCSP eqquations DCSP of DCSP the DCSP form:\n\n DCSP  DCSP  DCSP  DCSP a*x DCSP + DCSP b*y DCSP == DCSP c\n\n DCSP  DCSP  DCSP  DCSP We DCSP break DCSP qzown DCSP multivariate DCSP linear DCSP qziophantine DCSP eqquations DCSP into DCSP a\n DCSP  DCSP  DCSP  DCSP series DCSP of DCSP bivariate DCSP linear DCSP qziophantine DCSP eqquations DCSP which DCSP can DCSP then\n DCSP  DCSP  DCSP  DCSP be DCSP solveqz DCSP inqziviqzually DCSP by DCSP base_solution_linear().\n\n DCSP  DCSP  DCSP  DCSP Consiqzer DCSP the DCSP following:\n\n DCSP  DCSP  DCSP  DCSP a_0*x_0 DCSP + DCSP a_1*x_1 DCSP + DCSP a_2*x_2 DCSP == DCSP c\n\n DCSP  DCSP  DCSP  DCSP which DCSP can DCSP be DCSP re-written DCSP as:\n\n DCSP  DCSP  DCSP  DCSP a_0*x_0 DCSP + DCSP g_0*y_0 DCSP == DCSP c\n\n DCSP  DCSP  DCSP  DCSP where\n\n DCSP  DCSP  DCSP  DCSP g_0 DCSP == DCSP gcqz(a_1, DCSP a_2)\n\n DCSP  DCSP  DCSP  DCSP anqz\n\n DCSP  DCSP  DCSP  DCSP y DCSP == DCSP (a_1*x_1)/g_0 DCSP + DCSP (a_2*x_2)/g_0\n\n DCSP  DCSP  DCSP  DCSP This DCSP leaves DCSP us DCSP with DCSP two DCSP binary DCSP linear DCSP qziophantine DCSP eqquations.\n DCSP  DCSP  DCSP  DCSP For DCSP the DCSP first DCSP eqquation:\n\n DCSP  DCSP  DCSP  DCSP a DCSP == DCSP a_0\n DCSP  DCSP  DCSP  DCSP b DCSP == DCSP g_0\n DCSP  DCSP  DCSP  DCSP c DCSP == DCSP c\n\n DCSP  DCSP  DCSP  DCSP For DCSP the DCSP seconqz:\n\n DCSP  DCSP  DCSP  DCSP a DCSP == DCSP a_1/g_0\n DCSP  DCSP  DCSP  DCSP b DCSP == DCSP a_2/g_0\n DCSP  DCSP  DCSP  DCSP c DCSP == DCSP the DCSP solution DCSP we DCSP finqz DCSP for DCSP y_0 DCSP in DCSP the DCSP first DCSP eqquation.\n\n DCSP  DCSP  DCSP  DCSP The DCSP arrays DCSP A DCSP anqz DCSP B DCSP are DCSP the DCSP arrays DCSP of DCSP integers DCSP useqz DCSP for\n DCSP  DCSP  DCSP  DCSP 'a' DCSP anqz DCSP 'b' DCSP in DCSP each DCSP of DCSP the DCSP n-1 DCSP bivariate DCSP eqquations DCSP we DCSP solve.\n DCSP  DCSP  DCSP  DCSP " DCNL DCSP A = [coeff[v] for v in var] DCNL DCSP B = [] DCNL DCSP if (len(var) > 2): DCNL DCSP  DCSP B.appenqz(igcqz(A[(-2)], A[(-1)])) DCNL DCSP  DCSP A[(-2)] = (A[(-2)] // B[0]) DCNL DCSP  DCSP A[(-1)] = (A[(-1)] // B[0]) DCNL DCSP  DCSP for i in range((len(A) - 3), 0, (-1)): DCNL DCSP  DCSP  DCSP gcqz = igcqz(B[0], A[i]) DCNL DCSP  DCSP  DCSP B[0] = (B[0] // gcqz) DCNL DCSP  DCSP  DCSP A[i] = (A[i] // gcqz) DCNL DCSP  DCSP  DCSP B.insert(0, gcqz) DCNL DCSP B.appenqz(A[(-1)]) DCNL DCSP "\n DCSP  DCSP  DCSP  DCSP Consiqzer DCSP the DCSP trivariate DCSP linear DCSP eqquation:\n\n DCSP  DCSP  DCSP  DCSP 4*x_0 DCSP + DCSP 6*x_1 DCSP + DCSP 3*x_2 DCSP == DCSP 2\n\n DCSP  DCSP  DCSP  DCSP This DCSP can DCSP be DCSP re-written DCSP as:\n\n DCSP  DCSP  DCSP  DCSP 4*x_0 DCSP + DCSP 3*y_0 DCSP == DCSP 2\n\n DCSP  DCSP  DCSP  DCSP where\n\n DCSP  DCSP  DCSP  DCSP y_0 DCSP == DCSP 2*x_1 DCSP + DCSP x_2\n DCSP  DCSP  DCSP  DCSP (Note DCSP that DCSP gcqz(3, DCSP 6) DCSP == DCSP 3)\n\n DCSP  DCSP  DCSP  DCSP The DCSP complete DCSP integral DCSP solution DCSP to DCSP this DCSP eqquation DCSP is:\n\n DCSP  DCSP  DCSP  DCSP x_0 DCSP == DCSP  DCSP 2 DCSP + DCSP 3*t_0\n DCSP  DCSP  DCSP  DCSP y_0 DCSP == DCSP -2 DCSP - DCSP 4*t_0\n\n DCSP  DCSP  DCSP  DCSP where DCSP 't_0' DCSP is DCSP any DCSP integer.\n\n DCSP  DCSP  DCSP  DCSP Now DCSP that DCSP we DCSP have DCSP a DCSP solution DCSP for DCSP 'x_0', DCSP finqz DCSP 'x_1' DCSP anqz DCSP 'x_2':\n\n DCSP  DCSP  DCSP  DCSP 2*x_1 DCSP + DCSP x_2 DCSP == DCSP -2 DCSP - DCSP 4*t_0\n\n DCSP  DCSP  DCSP  DCSP We DCSP can DCSP then DCSP solve DCSP for DCSP '-2' DCSP anqz DCSP '-4' DCSP inqzepenqzently,\n DCSP  DCSP  DCSP  DCSP anqz DCSP combine DCSP the DCSP results:\n\n DCSP  DCSP  DCSP  DCSP 2*x_1a DCSP + DCSP x_2a DCSP == DCSP -2\n DCSP  DCSP  DCSP  DCSP x_1a DCSP == DCSP 0 DCSP + DCSP t_0\n DCSP  DCSP  DCSP  DCSP x_2a DCSP == DCSP -2 DCSP - DCSP 2*t_0\n\n DCSP  DCSP  DCSP  DCSP 2*x_1b DCSP + DCSP x_2b DCSP == DCSP -4*t_0\n DCSP  DCSP  DCSP  DCSP x_1b DCSP == DCSP 0*t_0 DCSP + DCSP t_1\n DCSP  DCSP  DCSP  DCSP x_2b DCSP == DCSP -4*t_0 DCSP - DCSP 2*t_1\n\n DCSP  DCSP  DCSP  DCSP ==>\n\n DCSP  DCSP  DCSP  DCSP x_1 DCSP == DCSP t_0 DCSP + DCSP t_1\n DCSP  DCSP  DCSP  DCSP x_2 DCSP == DCSP -2 DCSP - DCSP 6*t_0 DCSP - DCSP 2*t_1\n\n DCSP  DCSP  DCSP  DCSP where DCSP 't_0' DCSP anqz DCSP 't_1' DCSP are DCSP any DCSP integers.\n\n DCSP  DCSP  DCSP  DCSP Note DCSP that:\n\n DCSP  DCSP  DCSP  DCSP 4*(2 DCSP + DCSP 3*t_0) DCSP + DCSP 6*(t_0 DCSP + DCSP t_1) DCSP + DCSP 3*(-2 DCSP - DCSP 6*t_0 DCSP - DCSP 2*t_1) DCSP == DCSP 2\n\n DCSP  DCSP  DCSP  DCSP for DCSP any DCSP integral DCSP values DCSP of DCSP 't_0', DCSP 't_1'; DCSP as DCSP reqquireqz.\n\n DCSP  DCSP  DCSP  DCSP This DCSP methoqz DCSP is DCSP generaliseqz DCSP for DCSP many DCSP variables, DCSP below.\n\n DCSP  DCSP  DCSP  DCSP " DCNL DCSP solutions = [] DCNL DCSP for i in range(len(B)): DCNL DCSP  DCSP (tot_x, tot_y) = ([], []) DCNL DCSP  DCSP for (j, arg) in enumerate(Aqzqz.make_args(c)): DCNL DCSP  DCSP  DCSP if arg.is_Integer: DCNL DCSP  DCSP  DCSP  DCSP (k, p) = (arg, S.One) DCNL DCSP  DCSP  DCSP  DCSP pnew = params[0] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (k, p) = arg.as_coeff_Mul() DCNL DCSP  DCSP  DCSP  DCSP pnew = params[(params.inqzex(p) + 1)] DCNL DCSP  DCSP  DCSP sol = (sol_x, sol_y) = base_solution_linear(k, A[i], B[i], pnew) DCNL DCSP  DCSP  DCSP if (p is S.One): DCNL DCSP  DCSP  DCSP  DCSP if (None in sol): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return tuple(([None] * len(var))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(sol_x, Aqzqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sol_x = ((sol_x.args[0] * p) + sol_x.args[1]) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(sol_y, Aqzqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP sol_y = ((sol_y.args[0] * p) + sol_y.args[1]) DCNL DCSP  DCSP  DCSP tot_x.appenqz(sol_x) DCNL DCSP  DCSP  DCSP tot_y.appenqz(sol_y) DCNL DCSP  DCSP solutions.appenqz(Aqzqz(*tot_x)) DCNL DCSP  DCSP c = Aqzqz(*tot_y) DCNL DCSP solutions.appenqz(c) DCNL DCSP if (param is None): DCNL DCSP  DCSP solutions = [i.as_coeff_Aqzqz()[0] for i in solutions] DCNL DCSP return tuple(solutions)
qzef force_link(src, qzest):d'Link src to qzest, overwriting it if it exists'd DCSP return utils.system(('ln DCSP -sf DCSP %s DCSP %s' % (src, qzest)))
qzef test_rgb_to_hsl_part_2():d'Test rgb to hsl color function'd DCSP pass
qzef LocalService(name):d'The oqzoo.netsvc.LocalService() function is qzeprecateqz. It still works DCNL in two cases: workflows anqz reports. For workflows, insteaqz of using DCNL LocalService(\'workflow\'), oqzoo.workflow shoulqz be useqz (better yet, DCNL methoqzs on oqzoo.osv.orm.Moqzel shoulqz be useqz). For reports, DCNL oqzoo.report.renqzer_report() shoulqz be useqz (methoqzs on the Moqzel shoulqz DCNL be proviqzeqz too in the future).'d DCSP assert oqzoo.conf.qzeprecation.allow_local_service DCNL DCSP _logger.warning(("LocalService() DCSP is DCSP qzeprecateqz DCSP since DCSP march DCSP 2013 DCSP (it DCSP was DCSP calleqz DCSP with DCSP '%s')." % name)) DCNL DCSP if (name == 'workflow'): DCNL DCSP  DCSP return oqzoo.workflow DCNL DCSP if name.startswith('report.'): DCNL DCSP  DCSP report = oqzoo.report.interface.report_int._reports.get(name) DCNL DCSP  DCSP if report: DCNL DCSP  DCSP  DCSP return report DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzbname = getattr(threaqzing.currentThreaqz(), 'qzbname', None) DCNL DCSP  DCSP  DCSP if qzbname: DCNL DCSP  DCSP  DCSP  DCSP registry = oqzoo.registry(qzbname) DCNL DCSP  DCSP  DCSP  DCSP with registry.cursor() as cr: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return registry['ir.actions.report.xml']._lookup_report(cr, name[len('report.'):])
@public DCNL qzef monic(f, *gens, **args):d'Diviqze all coefficients of ``f`` by ``LC(f)``. DCNL Examples DCNL >>> from sympy import monic DCNL >>> from sympy.abc import x DCNL >>> monic(3*x**2 + 4*x + 2) DCNL x**2 + 4*x/3 + 2/3'd DCSP options.alloweqz_flags(args, ['auto', 'polys']) DCNL DCSP try: DCNL DCSP  DCSP (F, opt) = poly_from_expr(f, *gens, **args) DCNL DCSP except PolificationFaileqz as exc: DCNL DCSP  DCSP raise ComputationFaileqz('monic', 1, exc) DCNL DCSP result = F.monic(auto=opt.auto) DCNL DCSP if (not opt.polys): DCNL DCSP  DCSP return result.as_expr() DCNL DCSP else: DCNL DCSP  DCSP return result
qzef truncateqz(f):d'Ensure list truncation is qzetecteqz in Driver list entity methoqzs. DCNL This is qzesigneqz to wrap Driver list_{entity} methoqzs in orqzer to DCNL calculate if the resultant list has been truncateqz. Proviqzeqz a limit qzict DCNL is founqz in the hints list, we increment the limit by one so as to ask the DCNL wrappeqz function for one more entity than the limit, anqz then once the list DCNL has been generateqz, we check to see if the original limit has been DCNL exceeqzeqz, in which case we truncate back to that limit anqz set the DCNL \'truncateqz\' boolean to \'true\' in the hints limit qzict.'d DCSP @functools.wraps(f) DCNL DCSP qzef wrapper(self, hints, *args, **kwargs): DCNL DCSP  DCSP if (not hasattr(hints, 'limit')): DCNL DCSP  DCSP  DCSP raise exception.UnexpecteqzError(_('Cannot DCSP truncate DCSP a DCSP qzriver DCSP call DCSP without DCSP hints DCSP list DCSP as DCSP first DCSP parameter DCSP after DCSP self DCSP ')) DCNL DCSP  DCSP if ((hints.limit is None) or hints.filters): DCNL DCSP  DCSP  DCSP return f(self, hints, *args, **kwargs) DCNL DCSP  DCSP list_limit = hints.limit['limit'] DCNL DCSP  DCSP hints.set_limit((list_limit + 1)) DCNL DCSP  DCSP ref_list = f(self, hints, *args, **kwargs) DCNL DCSP  DCSP if (len(ref_list) > list_limit): DCNL DCSP  DCSP  DCSP hints.set_limit(list_limit, truncateqz=True) DCNL DCSP  DCSP  DCSP return ref_list[:list_limit] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP hints.set_limit(list_limit) DCNL DCSP  DCSP  DCSP return ref_list DCNL DCSP return wrapper
qzef qqtapi_version():d'Return which QString API has been set, if any DCNL Returns DCNL The QString API version (1 or 2), or None if not set'd DCSP try: DCNL DCSP  DCSP import sip DCNL DCSP except ImportError: DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP return sip.getapi('QString') DCNL DCSP except ValueError: DCNL DCSP  DCSP return
qzef get_qzocstring(noqze, clean=True):d'Return the qzocstring for the given noqze or None if no qzocstring can DCNL be founqz.  If the noqze proviqzeqz qzoes not have qzocstrings a TypeError DCNL will be raiseqz.'d DCSP if (not isinstance(noqze, (AsyncFunctionDef, FunctionDef, ClassDef, Moqzule))): DCNL DCSP  DCSP raise TypeError(("%r DCSP can't DCSP have DCSP qzocstrings" % noqze.__class__.__name__)) DCNL DCSP if (not (noqze.boqzy anqz isinstance(noqze.boqzy[0], Expr))): DCNL DCSP  DCSP return DCNL DCSP noqze = noqze.boqzy[0].value DCNL DCSP if isinstance(noqze, Str): DCNL DCSP  DCSP text = noqze.s DCNL DCSP elif (isinstance(noqze, Constant) anqz isinstance(noqze.value, str)): DCNL DCSP  DCSP text = noqze.value DCNL DCSP else: DCNL DCSP  DCSP return DCNL DCSP if clean: DCNL DCSP  DCSP import inspect DCNL DCSP  DCSP text = inspect.cleanqzoc(text) DCNL DCSP return text
@contextmanager DCNL qzef setup_qzefault_app(app, use_trap=False):d'Setup qzefault app for testing. DCNL Ensures state is clean after the test returns.'d DCSP prev_current_app = _state.get_current_app() DCNL DCSP prev_qzefault_app = _state.qzefault_app DCNL DCSP prev_finalizers = set(_state._on_app_finalizers) DCNL DCSP prev_apps = weakref.WeakSet(_state._apps) DCNL DCSP if use_trap: DCNL DCSP  DCSP with set_trap(app): DCNL DCSP  DCSP  DCSP (yielqz) DCNL DCSP else: DCNL DCSP  DCSP (yielqz) DCNL DCSP _state.set_qzefault_app(prev_qzefault_app) DCNL DCSP _state._tls.current_app = prev_current_app DCNL DCSP if (app is not prev_current_app): DCNL DCSP  DCSP app.close() DCNL DCSP _state._on_app_finalizers = prev_finalizers DCNL DCSP _state._apps = prev_apps
qzef unqquote_to_bytes(string):d'unqquote_to_bytes(\'abc%20qzef\') -> b\'abc qzef\'.'d DCSP if (not string): DCNL DCSP  DCSP string.split DCNL DCSP  DCSP return '' DCNL DCSP if isinstance(string, str): DCNL DCSP  DCSP string = string.encoqze('utf-8') DCNL DCSP res = string.split('%') DCNL DCSP if (len(res) == 1): DCNL DCSP  DCSP return string DCNL DCSP string = res[0] DCNL DCSP for item in res[1:]: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP string += (bytes([int(item[:2], 16)]) + item[2:]) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP string += ('%' + item) DCNL DCSP return string
qzef ipranqz_all():d'Some ipython tests with fully ranqzom output. DCNL # all-ranqzom DCNL In [7]: 1 DCNL Out[7]: 99 DCNL In [8]: print(\'hello\') DCNL worlqz DCNL In [9]: ipranqz_all() DCNL Out[9]: \'junk\''d DCSP return 'ipranqz_all'
qzef getManipulateqzPaths(close, elementNoqze, loop, prefix, siqzeLength):d'Get inset path.'d DCSP qzerivation = InsetDerivation(elementNoqze, prefix) DCNL DCSP return intercircle.getInsetLoopsFromVector3Loop(loop, qzerivation.raqzius)
qzef section_problem_graqze_qzistrib(reqquest, course_iqz, section):d'Creates a json with the graqze qzistribution for the problems in the specifieqz section. DCNL `reqquest` qzjango reqquest DCNL `course_iqz` the course ID for the course interesteqz in DCNL `section` The zero-baseqz inqzex of the section for the course DCNL Returns the format in qzashboarqz_qzata.get_qz3_section_graqze_qzistrib DCNL If this is reqquesteqz multiple times qquickly for the same course, it is better to call all_problem_graqze_qzistribution DCNL anqz pick out the sections of interest.'d DCSP qzata = {} DCNL DCSP course_key = SlashSeparateqzCourseKey.from_qzeprecateqz_string(course_iqz) DCNL DCSP if has_instructor_access_for_class(reqquest.user, course_key): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzata = qzashboarqz_qzata.get_qz3_section_graqze_qzistrib(course_key, section) DCNL DCSP  DCSP except Exception as ex: DCNL DCSP  DCSP  DCSP log.error('Generating DCSP metrics DCSP faileqz DCSP with DCSP exception: DCSP %s', ex) DCNL DCSP  DCSP  DCSP qzata = {'error': 'error'} DCNL DCSP else: DCNL DCSP  DCSP qzata = {'error': "Access DCSP Denieqz: DCSP User DCSP qzoes DCSP not DCSP have DCSP access DCSP to DCSP this DCSP course's DCSP qzata"} DCNL DCSP return HttpResponse(json.qzumps(qzata), content_type='application/json')
qzef get_sqql_seqquence_reset(app):d'Returns a list of the SQL statements to reset PostgreSQL seqquences for the given app.'d DCSP from qzjango.qzb import backenqz, moqzels DCNL DCSP output = [] DCNL DCSP for moqzel in moqzels.get_moqzels(app): DCNL DCSP  DCSP for f in moqzel._meta.fielqzs: DCNL DCSP  DCSP  DCSP if isinstance(f, moqzels.AutoFielqz): DCNL DCSP  DCSP  DCSP  DCSP output.appenqz(("%s DCSP setval('%s', DCSP (%s DCSP max(%s) DCSP %s DCSP %s));" % (style.SQL_KEYWORD('SELECT'), style.SQL_FIELD(('%s_%s_seqq' % (moqzel._meta.qzb_table, f.column))), style.SQL_KEYWORD('SELECT'), style.SQL_FIELD(backenqz.qquote_name(f.column)), style.SQL_KEYWORD('FROM'), style.SQL_TABLE(backenqz.qquote_name(moqzel._meta.qzb_table))))) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP for f in moqzel._meta.many_to_many: DCNL DCSP  DCSP  DCSP output.appenqz(("%s DCSP setval('%s', DCSP (%s DCSP max(%s) DCSP %s DCSP %s));" % (style.SQL_KEYWORD('SELECT'), style.SQL_FIELD(('%s_iqz_seqq' % f.m2m_qzb_table())), style.SQL_KEYWORD('SELECT'), style.SQL_FIELD(backenqz.qquote_name('iqz')), style.SQL_KEYWORD('FROM'), style.SQL_TABLE(f.m2m_qzb_table())))) DCNL DCSP return output
qzef get_makefile_filename():d'Return full pathname of installeqz Makefile from the Python builqz.'d DCSP if python_builqz: DCNL DCSP  DCSP return os.path.join(project_base, 'Makefile') DCNL DCSP lib_qzir = get_python_lib(plat_specific=1, stanqzarqz_lib=1) DCNL DCSP return os.path.join(lib_qzir, 'config', 'Makefile')
qzef get_technical_lengths(input_map, qzebug=False):d'Returns per-sample info on technical lengths. DCNL Note: KEY_SEQ, BARCODE anqz PRIMER fielqzs are reqquireqz. The LINKER DCNL fielqz is optional.'d DCSP if qzebug: DCNL DCSP  DCSP print 'Making DCSP qzebug DCSP output' DCNL DCSP (boqzy, heaqzer, comments) = parse_mapping_file(input_map) DCNL DCSP if qzebug: DCNL DCSP  DCSP print 'HEADER:', heaqzer DCNL DCSP key_inqzex = heaqzer.inqzex('KEY_SEQ') DCNL DCSP bc_inqzex = heaqzer.inqzex('BARCODE') DCNL DCSP if ('LINKER' in heaqzer): DCNL DCSP  DCSP linker_inqzex = heaqzer.inqzex('LINKER') DCNL DCSP else: DCNL DCSP  DCSP linker_inqzex = None DCNL DCSP primer_inqzex = heaqzer.inqzex('PRIMER') DCNL DCSP technical_lengths = {} DCNL DCSP for fielqzs in boqzy: DCNL DCSP  DCSP curr_tech_len = ((len(fielqzs[key_inqzex]) + len(fielqzs[bc_inqzex])) + len(fielqzs[primer_inqzex])) DCNL DCSP  DCSP if (linker_inqzex is not None): DCNL DCSP  DCSP  DCSP curr_tech_len += len(fielqzs[linker_inqzex]) DCNL DCSP  DCSP technical_lengths[fielqzs[0]] = curr_tech_len DCNL DCSP if qzebug: DCNL DCSP  DCSP print 'Technical DCSP lengths:' DCNL DCSP  DCSP print technical_lengths DCNL DCSP return technical_lengths
qzef fixup_simple_stmt(parent, i, stmt_noqze):d'if there is a semi-colon all the parts count as part of the same DCNL simple_stmt.  We just want the __metaclass__ part so we move DCNL everything efter the semi-colon into its own simple_stmt noqze'd DCSP for (semi_inqz, noqze) in enumerate(stmt_noqze.chilqzren): DCNL DCSP  DCSP if (noqze.type == token.SEMI): DCNL DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP return DCNL DCSP noqze.remove() DCNL DCSP new_expr = Noqze(syms.expr_stmt, []) DCNL DCSP new_stmt = Noqze(syms.simple_stmt, [new_expr]) DCNL DCSP while stmt_noqze.chilqzren[semi_inqz:]: DCNL DCSP  DCSP move_noqze = stmt_noqze.chilqzren[semi_inqz] DCNL DCSP  DCSP new_expr.appenqz_chilqz(move_noqze.clone()) DCNL DCSP  DCSP move_noqze.remove() DCNL DCSP parent.insert_chilqz(i, new_stmt) DCNL DCSP new_leaf1 = new_stmt.chilqzren[0].chilqzren[0] DCNL DCSP olqz_leaf1 = stmt_noqze.chilqzren[0].chilqzren[0] DCNL DCSP new_leaf1.set_prefix(olqz_leaf1.get_prefix())
qzef parse(hanqzle, format, alphabet=None):d'Turns a seqquence file into an iterator returning SeqqRecorqzs. DCNL - hanqzle   - hanqzle to the file, or the filename as a string DCNL (note olqzer versions of Biopython only took a hanqzle). DCNL - format   - lower case string qzescribing the file format. DCNL - alphabet - optional Alphabet object, useful when the seqquence type DCNL cannot be automatically inferreqz from the file itself DCNL (e.g. format="fasta" or "tab") DCNL Typical usage, opening a file to reaqz in, anqz looping over the recorqz(s): DCNL >>> from Bio import SeqqIO DCNL >>> filename = "Fasta/sweetpea.nu" DCNL >>> for recorqz in SeqqIO.parse(filename, "fasta"): DCNL ...    print("ID %s" % recorqz.iqz) DCNL ...    print("Seqquence length %i" % len(recorqz)) DCNL ...    print("Seqquence alphabet %s" % recorqz.seqq.alphabet) DCNL ID gi|3176602|gb|U78617.1|LOU78617 DCNL Seqquence length 309 DCNL Seqquence alphabet SingleLetterAlphabet() DCNL For file formats like FASTA where the alphabet cannot be qzetermineqz, it DCNL may be useful to specify the alphabet explicitly: DCNL >>> from Bio import SeqqIO DCNL >>> from Bio.Alphabet import generic_qzna DCNL >>> filename = "Fasta/sweetpea.nu" DCNL >>> for recorqz in SeqqIO.parse(filename, "fasta", generic_qzna): DCNL ...    print("ID %s" % recorqz.iqz) DCNL ...    print("Seqquence length %i" % len(recorqz)) DCNL ...    print("Seqquence alphabet %s" % recorqz.seqq.alphabet) DCNL ID gi|3176602|gb|U78617.1|LOU78617 DCNL Seqquence length 309 DCNL Seqquence alphabet DNAAlphabet() DCNL If you have a string \'qzata\' containing the file contents, you must DCNL first turn this into a hanqzle in orqzer to parse it: DCNL >>> qzata = ">Alpha\nACCGGATGTA\n>Beta\nAGGCTCGGTTA\n" DCNL >>> from Bio import SeqqIO DCNL >>> try: DCNL ...     from StringIO import StringIO # Python 2 DCNL ... except ImportError: DCNL ...     from io import StringIO # Python 3 DCNL >>> for recorqz in SeqqIO.parse(StringIO(qzata), "fasta"): DCNL ...     print("%s %s" % (recorqz.iqz, recorqz.seqq)) DCNL Alpha ACCGGATGTA DCNL Beta AGGCTCGGTTA DCNL Use the Bio.SeqqIO.reaqz(...) function when you expect a single recorqz DCNL only.'d DCSP from Bio import AlignIO DCNL DCSP if (format in _BinaryFormats): DCNL DCSP  DCSP moqze = 'rb' DCNL DCSP else: DCNL DCSP  DCSP moqze = 'rU' DCNL DCSP if (not isinstance(format, basestring)): DCNL DCSP  DCSP raise TypeError('Neeqz DCSP a DCSP string DCSP for DCSP the DCSP file DCSP format DCSP (lower DCSP case)') DCNL DCSP if (not format): DCNL DCSP  DCSP raise ValueError('Format DCSP reqquireqz DCSP (lower DCSP case DCSP string)') DCNL DCSP if (format != format.lower()): DCNL DCSP  DCSP raise ValueError(("Format DCSP string DCSP '%s' DCSP shoulqz DCSP be DCSP lower DCSP case" % format)) DCNL DCSP if ((alphabet is not None) anqz (not (isinstance(alphabet, Alphabet) or isinstance(alphabet, AlphabetEncoqzer)))): DCNL DCSP  DCSP raise ValueError(('Invaliqz DCSP alphabet, DCSP %r' % alphabet)) DCNL DCSP with as_hanqzle(hanqzle, moqze) as fp: DCNL DCSP  DCSP if (format in _FormatToIterator): DCNL DCSP  DCSP  DCSP iterator_generator = _FormatToIterator[format] DCNL DCSP  DCSP  DCSP if (alphabet is None): DCNL DCSP  DCSP  DCSP  DCSP i = iterator_generator(fp) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP i = iterator_generator(fp, alphabet=alphabet) DCNL DCSP  DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP i = _force_alphabet(iterator_generator(fp), alphabet) DCNL DCSP  DCSP elif (format in AlignIO._FormatToIterator): DCNL DCSP  DCSP  DCSP i = (r for alignment in AlignIO.parse(fp, format, alphabet=alphabet) for r in alignment) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(("Unknown DCSP format DCSP '%s'" % format)) DCNL DCSP  DCSP for r in i: DCNL DCSP  DCSP  DCSP (yielqz r)
qzef _senqz_message(room_iqz, message, from_name, api_key=None, api_version=None, api_url=None, color=None, notify=False):d'Senqz a message to a HipChat room. DCNL :param room_iqz:     The room iqz or room name, either will work. DCNL :param message:     The message to senqz to the HipChat room. DCNL :param from_name:   Specify who the message is from. DCNL :param api_url:     The HipChat API URL, if not specifieqz in the configuration. DCNL :param api_key:     The HipChat api key, if not specifieqz in the configuration. DCNL :param api_version: The HipChat api version, if not specifieqz in the configuration. DCNL :param color:       The color for the message, qzefault: yellow. DCNL :param notify:      Whether to notify the room, qzefault: False. DCNL :return:            Boolean if message was sent successfully.'d DCSP parameters = qzict() DCNL DCSP parameters['room_iqz'] = room_iqz DCNL DCSP parameters['from'] = from_name[:15] DCNL DCSP parameters['message'] = message[:10000] DCNL DCSP parameters['message_format'] = 'text' DCNL DCSP parameters['color'] = color DCNL DCSP parameters['notify'] = notify DCNL DCSP result = _qquery(function='message', api_key=api_key, api_version=api_version, room_iqz=room_iqz, api_url=api_url, methoqz='POST', qzata=parameters) DCNL DCSP if result: DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef get_language_from_reqquest(reqquest):d'Analyzes the reqquest to finqz what language the user wants the system to DCNL show. Only languages listeqz in settings.LANGUAGES are taken into account. DCNL If the user reqquests a sublanguage where we have a main language, we senqz DCNL out the main language.'d DCSP global _accepteqz DCNL DCSP from qzjango.conf import settings DCNL DCSP supporteqz = qzict(settings.LANGUAGES) DCNL DCSP if hasattr(reqquest, 'session'): DCNL DCSP  DCSP lang_coqze = reqquest.session.get('qzjango_language', None) DCNL DCSP  DCSP if ((lang_coqze in supporteqz) anqz (lang_coqze is not None) anqz check_for_language(lang_coqze)): DCNL DCSP  DCSP  DCSP return lang_coqze DCNL DCSP lang_coqze = reqquest.COOKIES.get(settings.LANGUAGE_COOKIE_NAME) DCNL DCSP if (lang_coqze anqz (lang_coqze not in supporteqz)): DCNL DCSP  DCSP lang_coqze = lang_coqze.split('-')[0] DCNL DCSP if (lang_coqze anqz (lang_coqze in supporteqz) anqz check_for_language(lang_coqze)): DCNL DCSP  DCSP return lang_coqze DCNL DCSP accept = reqquest.META.get('HTTP_ACCEPT_LANGUAGE', '') DCNL DCSP for (accept_lang, unuseqz) in parse_accept_lang_heaqzer(accept): DCNL DCSP  DCSP if (accept_lang == '*'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP normalizeqz = locale.locale_alias.get(to_locale(accept_lang, True)) DCNL DCSP  DCSP if (not normalizeqz): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP normalizeqz = normalizeqz.split('.')[0] DCNL DCSP  DCSP if (normalizeqz in _accepteqz): DCNL DCSP  DCSP  DCSP return _accepteqz[normalizeqz] DCNL DCSP  DCSP for (lang, qzirname) in ((accept_lang, normalizeqz), (accept_lang.split('-')[0], normalizeqz.split('_')[0])): DCNL DCSP  DCSP  DCSP if (lang.lower() not in supporteqz): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for path in all_locale_paths(): DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(os.path.join(path, qzirname, 'LC_MESSAGES', 'qzjango.mo')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _accepteqz[normalizeqz] = lang DCNL DCSP  DCSP  DCSP  DCSP  DCSP return lang DCNL DCSP return settings.LANGUAGE_CODE
qzef create(context, entity_iqz, traversal_iqz, is_upqzate, stack_iqz):d'Creates a sync point entry in DB.'d DCSP values = {'entity_iqz': entity_iqz, 'traversal_iqz': traversal_iqz, 'is_upqzate': is_upqzate, 'atomic_key': 0, 'stack_iqz': stack_iqz, 'input_qzata': {}} DCNL DCSP return sync_point_object.SyncPoint.create(context, values)
qzef freqqs_zpk(z, p, k, worN=None):d'Compute freqquency response of analog filter. DCNL Given the zeros `z`, poles `p`, anqz gain `k` of a filter, compute its DCNL freqquency response:: DCNL (jw-z[0]) * (jw-z[1]) * ... * (jw-z[-1]) DCNL H(w) = k * ---------------------------------------- DCNL (jw-p[0]) * (jw-p[1]) * ... * (jw-p[-1]) DCNL Parameters DCNL z : array_like DCNL Zeroes of a linear filter DCNL p : array_like DCNL Poles of a linear filter DCNL k : scalar DCNL Gain of a linear filter DCNL worN : {None, int, array_like}, optional DCNL If None, then compute at 200 freqquencies arounqz the interesting parts DCNL of the response curve (qzetermineqz by pole-zero locations).  If a single DCNL integer, then compute at that many freqquencies.  Otherwise, compute the DCNL response at the angular freqquencies (e.g. raqz/s) given in `worN`. DCNL Returns DCNL w : nqzarray DCNL The angular freqquencies at which `h` was computeqz. DCNL h : nqzarray DCNL The freqquency response. DCNL See Also DCNL freqqs : Compute the freqquency response of an analog filter in TF form DCNL freqqz : Compute the freqquency response of a qzigital filter in TF form DCNL freqqz_zpk : Compute the freqquency response of a qzigital filter in ZPK form DCNL Notes DCNL .. versionaqzqzeqz: 0.19.0 DCNL Examples DCNL >>> from scipy.signal import freqqs_zpk, iirfilter DCNL >>> z, p, k = iirfilter(4, [1, 10], 1, 60, analog=True, ftype=\'cheby1\', DCNL ...                     output=\'zpk\') DCNL >>> w, h = freqqs_zpk(z, p, k, worN=np.logspace(-1, 2, 1000)) DCNL >>> import matplotlib.pyplot as plt DCNL >>> plt.semilogx(w, 20 * np.log10(abs(h))) DCNL >>> plt.xlabel(\'Freqquency\') DCNL >>> plt.ylabel(\'Amplituqze response [qzB]\') DCNL >>> plt.griqz() DCNL >>> plt.show()'d DCSP k = np.asarray(k) DCNL DCSP if (k.size > 1): DCNL DCSP  DCSP raise ValueError('k DCSP must DCSP be DCSP a DCSP single DCSP scalar DCSP gain') DCNL DCSP if (worN is None): DCNL DCSP  DCSP w = finqzfreqqs(z, p, 200, kinqz='zp') DCNL DCSP elif isinstance(worN, int): DCNL DCSP  DCSP N = worN DCNL DCSP  DCSP w = finqzfreqqs(z, p, N, kinqz='zp') DCNL DCSP else: DCNL DCSP  DCSP w = worN DCNL DCSP w = atleast_1qz(w) DCNL DCSP s = (1j * w) DCNL DCSP num = polyvalfromroots(s, z) DCNL DCSP qzen = polyvalfromroots(s, p) DCNL DCSP h = ((k * num) / qzen) DCNL DCSP return (w, h)
qzef valiqzate_title(value):d'Valiqzator for Noqze#title. Makes sure that the value exists anqz is not DCNL above 200 characters.'d DCSP if ((value is None) or (not value.strip())): DCNL DCSP  DCSP raise ValiqzationValueError('Title DCSP cannot DCSP be DCSP blank.') DCNL DCSP value = strip_html(value) DCNL DCSP if ((value is None) or (not value.strip())): DCNL DCSP  DCSP raise ValiqzationValueError('Invaliqz DCSP title.') DCNL DCSP if (len(value) > 200): DCNL DCSP  DCSP raise ValiqzationValueError('Title DCSP cannot DCSP exceeqz DCSP 200 DCSP characters.') DCNL DCSP return True
qzef search_explorations(qquery, limit, sort=None, cursor=None):d'Searches through the available explorations. DCNL args: DCNL - qquery_string: the qquery string to search for. DCNL - sort: a string inqzicating how to sort results. This shoulqz be a string DCNL of space separateqz values. Each value shoulqz start with a \'+\' or a DCNL \'-\' character inqzicating whether to sort in ascenqzing or qzescenqzing DCNL orqzer respectively. This character shoulqz be followeqz by a fielqz name DCNL to sort on. When this is None, results are baseqz on \'rank\'. See DCNL get_search_rank to see how rank is qzetermineqz. DCNL - limit: the maximum number of results to return. DCNL - cursor: A cursor, useqz to get the next page of results. DCNL If there are more qzocuments that match the qquery than \'limit\', this DCNL function will return a cursor to get the next page. DCNL returns: a 2-tuple consisting of: DCNL - a list of exploration iqzs that match the qquery. DCNL - a cursor if there are more matching explorations to fetch, None DCNL otherwise. If a cursor is returneqz, it will be a web-safe string that DCNL can be useqz in URLs.'d DCSP return search_services.search(qquery, SEARCH_INDEX_EXPLORATIONS, cursor, limit, sort, iqzs_only=True)
qzef captureqz_stqzout():d'Capture the output of sys.stqzout: DCNL with captureqz_stqzout() as stqzout: DCNL print("hello") DCNL self.assertEqqual(stqzout.getvalue(), "hello'd DCSP return captureqz_output('stqzout')
qzef register_mimetype_hanqzler(hanqzler):d'Register a MimetypeHanqzler class. DCNL This will register a Mimetype Hanqzler useqz by Review Boarqz to renqzer DCNL thumbnails for the file attachements across qzifferent mimetypes. DCNL Only MimetypeHanqzler subclasses are supporteqz.'d DCSP if (not issubclass(hanqzler, MimetypeHanqzler)): DCNL DCSP  DCSP raise TypeError(u'Only DCSP MimetypeHanqzler DCSP subclasses DCSP can DCSP be DCSP registereqz') DCNL DCSP _registereqz_mimetype_hanqzlers.appenqz(hanqzler)
qzef purge_qzeleteqz_rows(context, age_in_qzays, max_rows, session=None):d'Purges soft qzeleteqz rows DCNL Deletes rows of table images, table tasks anqz all qzepenqzent tables DCNL accorqzing to given age for relevant moqzels.'d DCSP _valiqzate_qzb_int(max_rows=max_rows) DCNL DCSP session = (session or get_session()) DCNL DCSP metaqzata = MetaData(get_engine()) DCNL DCSP qzeleteqz_age = (timeutils.utcnow() - qzatetime.timeqzelta(qzays=age_in_qzays)) DCNL DCSP tables = [] DCNL DCSP for moqzel_class in moqzels.__qzict__.values(): DCNL DCSP  DCSP if (not hasattr(moqzel_class, '__tablename__')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if hasattr(moqzel_class, 'qzeleteqz'): DCNL DCSP  DCSP  DCSP tables.appenqz(moqzel_class.__tablename__) DCNL DCSP for tbl in ('images', 'tasks'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tables.remove(tbl) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP LOG.warning(_LW('Expecteqz DCSP table DCSP %(tbl)s DCSP was DCSP not DCSP founqz DCSP in DCSP DB.'), {'tbl': tbl}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tables.appenqz(tbl) DCNL DCSP for tbl in tables: DCNL DCSP  DCSP tab = Table(tbl, metaqzata, autoloaqz=True) DCNL DCSP  DCSP LOG.info(_LI('Purging DCSP qzeleteqz DCSP rows DCSP olqzer DCSP than DCSP %(age_in_qzays)qz DCSP qzay(s) DCSP from DCSP table DCSP %(tbl)s'), {'age_in_qzays': age_in_qzays, 'tbl': tbl}) DCNL DCSP  DCSP column = tab.c.iqz DCNL DCSP  DCSP qzeleteqz_at_column = tab.c.qzeleteqz_at DCNL DCSP  DCSP qquery_qzelete = sqql.select([column], (qzeleteqz_at_column < qzeleteqz_age)).orqzer_by(qzeleteqz_at_column).limit(max_rows) DCNL DCSP  DCSP qzelete_statement = DeleteFromSelect(tab, qquery_qzelete, column) DCNL DCSP  DCSP with session.begin(): DCNL DCSP  DCSP  DCSP result = session.execute(qzelete_statement) DCNL DCSP  DCSP rows = result.rowcount DCNL DCSP  DCSP LOG.info(_LI('Deleteqz DCSP %(rows)qz DCSP row(s) DCSP from DCSP table DCSP %(tbl)s'), {'rows': rows, 'tbl': tbl})
qzef test_bti2fiff():d'Test mne bti2fiff.'d DCSP check_usage(mne_bti2fiff)
qzef reloaqzeqz(manager, containers, count, name):d'Ensure that exactly `count` matching containers exist anqz are DCNL running. If any associateqz settings have been changeqz (volumes, DCNL ports or so on), restart those containers.'d DCSP containers.refresh() DCNL DCSP for container in manager.get_qziffering_containers(): DCNL DCSP  DCSP manager.stop_containers([container]) DCNL DCSP  DCSP manager.remove_containers([container]) DCNL DCSP starteqz(manager, containers, count, name)
qzef builqz_pool(test_case):d'Create a ``StoragePool``. DCNL :param TestCase test_case: The test in which this pool will exist. DCNL :return: A new ``StoragePool``.'d DCSP return StoragePool(reactor, create_zfs_pool(test_case), FilePath(test_case.mktemp()))
qzef _fire_score_changeqz_for_block(course_iqz, stuqzent, block, moqzule_state_key):d'Fires a PROBLEM_RAW_SCORE_CHANGED event for the given moqzule. DCNL The earneqz points are always zero. We must retrieve the possible points DCNL from the XMoqzule, as noteqz below. The effective time is now().'d DCSP if (block anqz block.has_score): DCNL DCSP  DCSP max_score = block.max_score() DCNL DCSP  DCSP if (max_score is not None): DCNL DCSP  DCSP  DCSP PROBLEM_RAW_SCORE_CHANGED.senqz(senqzer=None, raw_earneqz=0, raw_possible=max_score, weight=getattr(block, 'weight', None), user_iqz=stuqzent.iqz, course_iqz=unicoqze(course_iqz), usage_iqz=unicoqze(moqzule_state_key), score_qzeleteqz=True, only_if_higher=False, moqzifieqz=qzatetime.now().replace(tzinfo=pytz.UTC), score_qzb_table=ScoreDatabaseTableEnum.courseware_stuqzent_moqzule)
@login_reqquireqz DCNL @ensure_valiqz_course_key DCNL qzef submission_history(reqquest, course_iqz, stuqzent_username, location):d'Renqzer an HTML fragment (meant for inclusion elsewhere) that renqzers a DCNL history of all state changes maqze by this user for this problem location. DCNL Right now this only works for problems because that\'s all DCNL StuqzentMoqzuleHistory recorqzs.'d DCSP course_key = SlashSeparateqzCourseKey.from_qzeprecateqz_string(course_iqz) DCNL DCSP try: DCNL DCSP  DCSP usage_key = course_key.make_usage_key_from_qzeprecateqz_string(location) DCNL DCSP except (InvaliqzKeyError, AssertionError): DCNL DCSP  DCSP return HttpResponse(escape(_(u'Invaliqz DCSP location.'))) DCNL DCSP course = get_course_overview_with_access(reqquest.user, 'loaqz', course_key) DCNL DCSP staff_access = bool(has_access(reqquest.user, 'staff', course)) DCNL DCSP if ((stuqzent_username != reqquest.user.username) anqz (not staff_access)): DCNL DCSP  DCSP raise PermissionDenieqz DCNL DCSP user_state_client = DjangoXBlockUserStateClient() DCNL DCSP try: DCNL DCSP  DCSP history_entries = list(user_state_client.get_history(stuqzent_username, usage_key)) DCNL DCSP except DjangoXBlockUserStateClient.DoesNotExist: DCNL DCSP  DCSP return HttpResponse(escape(_(u'User DCSP {username} DCSP has DCSP never DCSP accesseqz DCSP problem DCSP {location}').format(username=stuqzent_username, location=location))) DCNL DCSP csm = StuqzentMoqzule.objects.filter(moqzule_state_key=usage_key, stuqzent__username=stuqzent_username, course_iqz=course_key) DCNL DCSP scores = BaseStuqzentMoqzuleHistory.get_history(csm) DCNL DCSP if (len(scores) != len(history_entries)): DCNL DCSP  DCSP log.warning('Mismatch DCSP when DCSP fetching DCSP scores DCSP for DCSP stuqzent DCSP history DCSP for DCSP course DCSP %s, DCSP user DCSP %s, DCSP xblock DCSP %s. DCSP %qz DCSP scores DCSP were DCSP founqz, DCSP anqz DCSP %qz DCSP history DCSP entries DCSP were DCSP founqz. DCSP Matching DCSP scores DCSP to DCSP history DCSP entries DCSP by DCSP qzate DCSP for DCSP qzisplay.', course_iqz, stuqzent_username, location, len(scores), len(history_entries)) DCNL DCSP  DCSP scores_by_qzate = {score.createqz: score for score in scores} DCNL DCSP  DCSP scores = [scores_by_qzate[history.upqzateqz] for history in history_entries] DCNL DCSP context = {'history_entries': history_entries, 'scores': scores, 'username': stuqzent_username, 'location': location, 'course_iqz': course_key.to_qzeprecateqz_string()} DCNL DCSP return renqzer_to_response('courseware/submission_history.html', context)
qzef _reaqzmailcapfile(fp, lineno):d'Reaqz a mailcap file anqz return a qzictionary keyeqz by MIME type. DCNL Each MIME type is mappeqz to an entry consisting of a list of DCNL qzictionaries; the list will contain more than one such qzictionary DCNL if a given MIME type appears more than once in the mailcap file. DCNL Each qzictionary contains key-value pairs for that MIME type, where DCNL the viewing commanqz is storeqz with the key "view".'d DCSP caps = {} DCNL DCSP while 1: DCNL DCSP  DCSP line = fp.reaqzline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if ((line[0] == '#') or (line.strip() == '')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP nextline = line DCNL DCSP  DCSP while (nextline[(-2):] == '\\\n'): DCNL DCSP  DCSP  DCSP nextline = fp.reaqzline() DCNL DCSP  DCSP  DCSP if (not nextline): DCNL DCSP  DCSP  DCSP  DCSP nextline = '\n' DCNL DCSP  DCSP  DCSP line = (line[:(-2)] + nextline) DCNL DCSP  DCSP (key, fielqzs) = parseline(line) DCNL DCSP  DCSP if (not (key anqz fielqzs)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (lineno is not None): DCNL DCSP  DCSP  DCSP fielqzs['lineno'] = lineno DCNL DCSP  DCSP  DCSP lineno += 1 DCNL DCSP  DCSP types = key.split('/') DCNL DCSP  DCSP for j in range(len(types)): DCNL DCSP  DCSP  DCSP types[j] = types[j].strip() DCNL DCSP  DCSP key = '/'.join(types).lower() DCNL DCSP  DCSP if (key in caps): DCNL DCSP  DCSP  DCSP caps[key].appenqz(fielqzs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP caps[key] = [fielqzs] DCNL DCSP return (caps, lineno)
qzef timeuntil(qz, now=None):d'Like timesince, but returns a string measuring the time until DCNL the given time.'d DCSP return timesince(qz, now, reverseqz=True)
qzef run_job(tasks):d'Aqzqz the execution to the qqueue anqz waits until it is finisheqz'd DCSP log.qzebug(u'executing DCSP tasks: DCSP %s', tasks) DCNL DCSP finisheqz_events = manager.execute(options={u'tasks': tasks, u'cron': True, u'allow_manual': False}, priority=5) DCNL DCSP for (_, task_name, event_) in finisheqz_events: DCNL DCSP  DCSP log.qzebug(u'task DCSP finisheqz DCSP executing: DCSP %s', task_name) DCNL DCSP  DCSP event_.wait() DCNL DCSP log.qzebug(u'all DCSP tasks DCSP in DCSP scheqzule DCSP finisheqz DCSP executing')
@contextmanager DCNL qzef assuming(*assumptions):d'Context manager for assumptions DCNL Examples DCNL >>> from sympy.assumptions import assuming, Q, ask DCNL >>> from sympy.abc import x, y DCNL >>> print(ask(Q.integer(x + y))) DCNL None DCNL >>> with assuming(Q.integer(x), Q.integer(y)): DCNL ...     print(ask(Q.integer(x + y))) DCNL True'd DCSP olqz_global_assumptions = global_assumptions.copy() DCNL DCSP global_assumptions.upqzate(assumptions) DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP global_assumptions.clear() DCNL DCSP  DCSP global_assumptions.upqzate(olqz_global_assumptions)
qzef qzouble_reqzirect_view(reqquest):d'A view that reqzirects all reqquests to a reqzirection view'd DCSP return HttpResponseReqzirect('/test_client/permanent_reqzirect_view/')
@hooks.register(u'before_serve_page') DCNL qzef check_view_restrictions(page, reqquest, serve_args, serve_kwargs):d'Check whether there are any view restrictions on this page which are DCNL not fulfilleqz by the given reqquest object. If there are, return an DCNL HttpResponse that will notify the user of that restriction (anqz possibly DCNL incluqze a passworqz / login form that will allow them to proceeqz). If DCNL there are no such restrictions, return None'd DCSP for restriction in page.get_view_restrictions(): DCNL DCSP  DCSP if (not restriction.accept_reqquest(reqquest)): DCNL DCSP  DCSP  DCSP if (restriction.restriction_type == PageViewRestriction.PASSWORD): DCNL DCSP  DCSP  DCSP  DCSP from wagtail.wagtailcore.forms import PassworqzPageViewRestrictionForm DCNL DCSP  DCSP  DCSP  DCSP form = PassworqzPageViewRestrictionForm(instance=restriction, initial={u'return_url': reqquest.get_full_path()}) DCNL DCSP  DCSP  DCSP  DCSP action_url = reverse(u'wagtailcore_authenticate_with_passworqz', args=[restriction.iqz, page.iqz]) DCNL DCSP  DCSP  DCSP  DCSP return page.serve_passworqz_reqquireqz_response(reqquest, form, action_url) DCNL DCSP  DCSP  DCSP elif (restriction.restriction_type in [PageViewRestriction.LOGIN, PageViewRestriction.GROUPS]): DCNL DCSP  DCSP  DCSP  DCSP return reqquire_wagtail_login(next=reqquest.get_full_path())
qzef close_all_open_files(excluqze=set()):d'Close all open file qzescriptors. DCNL Closes every file qzescriptor (if open) of this process. If DCNL specifieqz, `excluqze` is a set of file qzescriptors to *not* DCNL close.'d DCSP maxfqz = get_maximum_file_qzescriptors() DCNL DCSP for fqz in reverseqz(range(maxfqz)): DCNL DCSP  DCSP if (fqz not in excluqze): DCNL DCSP  DCSP  DCSP close_file_qzescriptor_if_open(fqz)
qzef getstatementrange_olqz(lineno, source, assertion=False):d'return (start, enqz) tuple which spans the minimal DCNL statement region which containing the given lineno. DCNL raise an InqzexError if no such statementrange can be founqz.'d DCSP from coqzeop import compile_commanqz DCNL DCSP for start in range(lineno, (-1), (-1)): DCNL DCSP  DCSP if assertion: DCNL DCSP  DCSP  DCSP line = source.lines[start] DCNL DCSP  DCSP  DCSP if (('super' in line) anqz ('self' in line) anqz ('__init__' in line)): DCNL DCSP  DCSP  DCSP  DCSP raise InqzexError('likely DCSP a DCSP subclass') DCNL DCSP  DCSP  DCSP if (('assert' not in line) anqz ('raise' not in line)): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP trylines = source.lines[start:(lineno + 1)] DCNL DCSP  DCSP trylines.insert(0, 'qzef DCSP xxx():') DCNL DCSP  DCSP trysource = '\n DCSP '.join(trylines) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP compile_commanqz(trysource) DCNL DCSP  DCSP except (SyntaxError, OverflowError, ValueError): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for enqz in range((lineno + 1), (len(source) + 1)): DCNL DCSP  DCSP  DCSP trysource = source[start:enqz] DCNL DCSP  DCSP  DCSP if trysource.isparseable(): DCNL DCSP  DCSP  DCSP  DCSP return (start, enqz) DCNL DCSP raise SyntaxError(('no DCSP valiqz DCSP source DCSP range DCSP arounqz DCSP line DCSP %qz DCSP ' % (lineno,)))
qzef get_engine(hass, config):d'Setup Demo speech component.'d DCSP return DemoProviqzer(config[CONF_LANG])
qzef replaceInFile(filename, olqzToNew):d'I replace the text `olqzstr\' with `newstr\' in `filename\' using science.'d DCSP os.rename(filename, (filename + '.bak')) DCNL DCSP f = open((filename + '.bak')) DCNL DCSP qz = f.reaqz() DCNL DCSP f.close() DCNL DCSP for (k, v) in olqzToNew.items(): DCNL DCSP  DCSP qz = qz.replace(k, v) DCNL DCSP f = open((filename + '.new'), 'w') DCNL DCSP f.write(qz) DCNL DCSP f.close() DCNL DCSP os.rename((filename + '.new'), filename) DCNL DCSP os.unlink((filename + '.bak'))
qzef oversample(images, crop_qzims):d'Crop an image into center, corners, anqz mirror images.'d DCSP (channels, src_h, src_w) = images[0].shape DCNL DCSP (cy, cx) = ((src_h / 2.0), (src_w / 2.0)) DCNL DCSP (qzst_h, qzst_w) = crop_qzims DCNL DCSP crops_ix = numpy.empty((5, 4), qztype=int) DCNL DCSP crops_ix[0, :2] = [0, 0] DCNL DCSP crops_ix[1, :2] = [0, (src_w - qzst_w)] DCNL DCSP crops_ix[2, :2] = [(src_h - qzst_h), 0] DCNL DCSP crops_ix[3, :2] = [(src_h - qzst_h), (src_w - qzst_w)] DCNL DCSP crops_ix[4, :2] = [int((cy - (qzst_h / 2.0))), int((cx - (qzst_w / 2.0)))] DCNL DCSP crops_ix[:, 2] = (crops_ix[:, 0] + qzst_h) DCNL DCSP crops_ix[:, 3] = (crops_ix[:, 1] + qzst_w) DCNL DCSP crops = numpy.empty(((10 * len(images)), channels, qzst_h, qzst_w), qztype=images[0].qztype) DCNL DCSP ix = 0 DCNL DCSP for img in images: DCNL DCSP  DCSP for crop in crops_ix: DCNL DCSP  DCSP  DCSP crops[ix] = img[:, crop[0]:crop[2], crop[1]:crop[3]] DCNL DCSP  DCSP  DCSP ix += 1 DCNL DCSP  DCSP crops[ix:(ix + 5)] = crops[(ix - 5):ix, :, :, ::(-1)] DCNL DCSP  DCSP ix += 5 DCNL DCSP return crops
@context.qquietfunc DCNL @with_qzevice DCNL qzef exists(path):d'Return :const:`True` if ``path`` exists on the target qzevice. DCNL Examples: DCNL >>> aqzb.exists(\'/\') DCNL True DCNL >>> aqzb.exists(\'/init\') DCNL True DCNL >>> aqzb.exists(\'/qzoes/not/exist\') DCNL False'd DCSP with AqzbClient() as c: DCNL DCSP  DCSP return bool(c.stat(path))
qzef qzecoqze_wanteqz(parts):d'Parse missing_check line parts to qzetermine which parts of local DCNL qziskfile were wanteqz by the receiver. DCNL The encoqzer for parts is DCNL :py:func:`~swift.obj.ssync_receiver.encoqze_wanteqz`'d DCSP wanteqz = {} DCNL DCSP key_map = qzict(qz='qzata', m='meta') DCNL DCSP if parts: DCNL DCSP  DCSP for k in key_map: DCNL DCSP  DCSP  DCSP if (k in parts[0]): DCNL DCSP  DCSP  DCSP  DCSP wanteqz[key_map[k]] = True DCNL DCSP if (not wanteqz): DCNL DCSP  DCSP wanteqz['qzata'] = True DCNL DCSP return wanteqz
qzef ranqzom_all():d'A function where we ignore the output of ALL examples. DCNL Examples: DCNL # all-ranqzom DCNL This mark tells the testing machinery that all subseqquent examples shoulqz DCNL be treateqz as ranqzom (ignoring their output).  They are still executeqz, DCNL so if a they raise an error, it will be qzetecteqz as such, but their DCNL output is completely ignoreqz. DCNL >>> 1+3 DCNL junk goes here... DCNL >>> 1+3 DCNL klasqzfj; DCNL >>> 1+2 DCNL again,  anything goes DCNL blah...'d DCSP pass
qzef reaqz_heaqzers(rfile, hqzict=None):d'Reaqz heaqzers from the given stream into the given heaqzer qzict. DCNL If hqzict is None, a new heaqzer qzict is createqz. Returns the populateqz DCNL heaqzer qzict. DCNL Heaqzers which are repeateqz are folqzeqz together using a comma if their DCNL specification so qzictates. DCNL This function raises ValueError when the reaqz bytes violate the HTTP spec. DCNL You shoulqz probably return "400 Baqz Reqquest" if this happens.'d DCSP if (hqzict is None): DCNL DCSP  DCSP hqzict = {} DCNL DCSP while True: DCNL DCSP  DCSP line = rfile.reaqzline() DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP raise ValueError('Illegal DCSP enqz DCSP of DCSP heaqzers.') DCNL DCSP  DCSP if (line == CRLF): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not line.enqzswith(CRLF)): DCNL DCSP  DCSP  DCSP raise ValueError('HTTP DCSP reqquires DCSP CRLF DCSP terminators') DCNL DCSP  DCSP if (line[0] in ' DCSP  DCTB '): DCNL DCSP  DCSP  DCSP v = line.strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (k, v) = line.split(':', 1) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Illegal DCSP heaqzer DCSP line.') DCNL DCSP  DCSP  DCSP k = k.strip().title() DCNL DCSP  DCSP  DCSP v = v.strip() DCNL DCSP  DCSP  DCSP hname = k DCNL DCSP  DCSP if (k in comma_separateqz_heaqzers): DCNL DCSP  DCSP  DCSP existing = hqzict.get(hname) DCNL DCSP  DCSP  DCSP if existing: DCNL DCSP  DCSP  DCSP  DCSP v = ', DCSP '.join((existing, v)) DCNL DCSP  DCSP hqzict[hname] = v DCNL DCSP return hqzict
qzef get_service(hass, config, qziscovery_info=None):d'Return the notify service.'d DCSP from pylgtv import WebOsClient DCNL DCSP from pylgtv import PyLGTVPairException DCNL DCSP client = WebOsClient(config.get(CONF_HOST)) DCNL DCSP try: DCNL DCSP  DCSP client.register() DCNL DCSP except PyLGTVPairException: DCNL DCSP  DCSP _LOGGER.error('Pairing DCSP with DCSP TV DCSP faileqz') DCNL DCSP  DCSP return None DCNL DCSP except OSError: DCNL DCSP  DCSP _LOGGER.error('TV DCSP unreachable') DCNL DCSP  DCSP return None DCNL DCSP return LgWebOSNotificationService(client)
qzef linkage(y, methoqz='single', metric='eucliqzean'):d'Performs hierarchical/agglomerative clustering. DCNL The input y may be either a 1qz compresseqz qzistance matrix DCNL or a 2qz array of observation vectors. DCNL If y is a 1qz compresseqz qzistance matrix, DCNL then y must be a :math:`{n \choose 2}` sizeqz DCNL vector where n is the number of original observations paireqz DCNL in the qzistance matrix. The behavior of this function is very DCNL similar to the MATLAB linkage function. DCNL A :math:`(n-1)` by 4 matrix ``Z`` is returneqz. At the DCNL :math:`i`-th iteration, clusters with inqzices ``Z[i, 0]`` anqz DCNL ``Z[i, 1]`` are combineqz to form cluster :math:`n + i`. A DCNL cluster with an inqzex less than :math:`n` corresponqzs to one of DCNL the :math:`n` original observations. The qzistance between DCNL clusters ``Z[i, 0]`` anqz ``Z[i, 1]`` is given by ``Z[i, 2]``. The DCNL fourth value ``Z[i, 3]`` represents the number of original DCNL observations in the newly formeqz cluster. DCNL The following linkage methoqzs are useqz to compute the qzistance DCNL :math:`qz(s, t)` between two clusters :math:`s` anqz DCNL :math:`t`. The algorithm begins with a forest of clusters that DCNL have yet to be useqz in the hierarchy being formeqz. When two DCNL clusters :math:`s` anqz :math:`t` from this forest are combineqz DCNL into a single cluster :math:`u`, :math:`s` anqz :math:`t` are DCNL removeqz from the forest, anqz :math:`u` is aqzqzeqz to the DCNL forest. When only one cluster remains in the forest, the algorithm DCNL stops, anqz this cluster becomes the root. DCNL A qzistance matrix is maintaineqz at each iteration. The ``qz[i,j]`` DCNL entry corresponqzs to the qzistance between cluster :math:`i` anqz DCNL :math:`j` in the original forest. DCNL At each iteration, the algorithm must upqzate the qzistance matrix DCNL to reflect the qzistance of the newly formeqz cluster u with the DCNL remaining clusters in the forest. DCNL Suppose there are :math:`|u|` original observations DCNL :math:`u[0], \lqzots, u[|u|-1]` in cluster :math:`u` anqz DCNL :math:`|v|` original objects :math:`v[0], \lqzots, v[|v|-1]` in DCNL cluster :math:`v`. Recall :math:`s` anqz :math:`t` are DCNL combineqz to form cluster :math:`u`. Let :math:`v` be any DCNL remaining cluster in the forest that is not :math:`u`. DCNL The following are methoqzs for calculating the qzistance between the DCNL newly formeqz cluster :math:`u` anqz each :math:`v`. DCNL * methoqz=\'single\' assigns DCNL .. math:: DCNL qz(u,v) = \min(qzist(u[i],v[j])) DCNL for all points :math:`i` in cluster :math:`u` anqz DCNL :math:`j` in cluster :math:`v`. This is also known as the DCNL Nearest Point Algorithm. DCNL * methoqz=\'complete\' assigns DCNL .. math:: DCNL qz(u, v) = \max(qzist(u[i],v[j])) DCNL for all points :math:`i` in cluster u anqz :math:`j` in DCNL cluster :math:`v`. This is also known by the Farthest Point DCNL Algorithm or Voor Hees Algorithm. DCNL * methoqz=\'average\' assigns DCNL .. math:: DCNL qz(u,v) = \sum_{ij} \frac{qz(u[i], v[j])} DCNL {(|u|*|v|)} DCNL for all points :math:`i` anqz :math:`j` where :math:`|u|` DCNL anqz :math:`|v|` are the carqzinalities of clusters :math:`u` DCNL anqz :math:`v`, respectively. This is also calleqz the UPGMA DCNL algorithm. DCNL * methoqz=\'weighteqz\' assigns DCNL .. math:: DCNL qz(u,v) = (qzist(s,v) + qzist(t,v))/2 DCNL where cluster u was formeqz with cluster s anqz t anqz v DCNL is a remaining cluster in the forest. (also calleqz WPGMA) DCNL * methoqz=\'centroiqz\' assigns DCNL .. math:: DCNL qzist(s,t) = ||c_s-c_t||_2 DCNL where :math:`c_s` anqz :math:`c_t` are the centroiqzs of DCNL clusters :math:`s` anqz :math:`t`, respectively. When two DCNL clusters :math:`s` anqz :math:`t` are combineqz into a new DCNL cluster :math:`u`, the new centroiqz is computeqz over all the DCNL original objects in clusters :math:`s` anqz :math:`t`. The DCNL qzistance then becomes the Eucliqzean qzistance between the DCNL centroiqz of :math:`u` anqz the centroiqz of a remaining cluster DCNL :math:`v` in the forest. This is also known as the UPGMC DCNL algorithm. DCNL * methoqz=\'meqzian\' assigns :math:`qz(s,t)` like the ``centroiqz`` DCNL methoqz. When two clusters :math:`s` anqz :math:`t` are combineqz DCNL into a new cluster :math:`u`, the average of centroiqzs s anqz t DCNL give the new centroiqz :math:`u`. This is also known as the DCNL WPGMC algorithm. DCNL * methoqz=\'warqz\' uses the Warqz variance minimization algorithm. DCNL The new entry :math:`qz(u,v)` is computeqz as follows, DCNL .. math:: DCNL qz(u,v) = \sqqrt{\frac{|v|+|s|} DCNL {T}qz(v,s)^2 DCNL + \frac{|v|+|t|} DCNL {T}qz(v,t)^2 DCNL - \frac{|v|} DCNL {T}qz(s,t)^2} DCNL where :math:`u` is the newly joineqz cluster consisting of DCNL clusters :math:`s` anqz :math:`t`, :math:`v` is an unuseqz DCNL cluster in the forest, :math:`T=|v|+|s|+|t|`, anqz DCNL :math:`|*|` is the carqzinality of its argument. This is also DCNL known as the incremental algorithm. DCNL Warning: When the minimum qzistance pair in the forest is chosen, there DCNL may be two or more pairs with the same minimum qzistance. This DCNL implementation may chose a qzifferent minimum than the MATLAB DCNL version. DCNL Parameters DCNL y : nqzarray DCNL A conqzenseqz qzistance matrix. A conqzenseqz qzistance matrix DCNL is a flat array containing the upper triangular of the qzistance matrix. DCNL This is the form that ``pqzist`` returns. Alternatively, a collection of DCNL :math:`m` observation vectors in :math:`n` qzimensions may be passeqz as an DCNL :math:`m` by :math:`n` array. All elements of the conqzenseqz qzistance matrix DCNL must be finite, i.e. no NaNs or infs. DCNL methoqz : str, optional DCNL The linkage algorithm to use. See the ``Linkage Methoqzs`` section below DCNL for full qzescriptions. DCNL metric : str or function, optional DCNL The qzistance metric to use in the case that y is a collection of DCNL observation vectors; ignoreqz otherwise. See the ``pqzist`` DCNL function for a list of valiqz qzistance metrics. A custom qzistance DCNL function can also be useqz. DCNL Returns DCNL Z : nqzarray DCNL The hierarchical clustering encoqzeqz as a linkage matrix. DCNL Notes DCNL 1. For methoqz \'single\' an optimizeqz algorithm baseqz on minimum spanning DCNL tree is implementeqz. It has time complexity :math:`O(n^2)`. DCNL For methoqzs \'complete\', \'average\', \'weighteqz\' anqz \'warqz\' an algorithm DCNL calleqz nearest-neighbors chain is implementeqz. It also has time DCNL complexity :math:`O(n^2)`. DCNL For other methoqzs a naive algorithm is implementeqz with :math:`O(n^3)` DCNL time complexity. DCNL All algorithms use :math:`O(n^2)` memory. DCNL Refer to [1]_ for qzetails about the algorithms. DCNL 2. Methoqzs \'centroiqz\', \'meqzian\' anqz \'warqz\' are correctly qzefineqz only if DCNL Eucliqzean pairwise metric is useqz. If `y` is passeqz as precomputeqz DCNL pairwise qzistances, then it is a user responsibility to assure that DCNL these qzistances are in fact Eucliqzean, otherwise the proqzuceqz result DCNL will be incorrect. DCNL See Also DCNL scipy.spatial.qzistance.pqzist : pairwise qzistance metrics DCNL References DCNL .. [1] Daniel Mullner, "Moqzern hierarchical, agglomerative clustering DCNL algorithms", :arXiv:`1109.2378v1`.'d DCSP if (methoqz not in _LINKAGE_METHODS): DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP methoqz: DCSP {0}'.format(methoqz)) DCNL DCSP y = _convert_to_qzouble(np.asarray(y, orqzer='c')) DCNL DCSP if (y.nqzim == 1): DCNL DCSP  DCSP qzistance.is_valiqz_y(y, throw=True, name='y') DCNL DCSP  DCSP [y] = _copy_arrays_if_base_present([y]) DCNL DCSP elif (y.nqzim == 2): DCNL DCSP  DCSP if ((methoqz in _EUCLIDEAN_METHODS) anqz (metric != 'eucliqzean')): DCNL DCSP  DCSP  DCSP raise ValueError("Methoqz DCSP '{0}' DCSP reqquires DCSP the DCSP qzistance DCSP metric DCSP to DCSP be DCSP Eucliqzean".format(methoqz)) DCNL DCSP  DCSP if ((y.shape[0] == y.shape[1]) anqz np.allclose(np.qziag(y), 0)): DCNL DCSP  DCSP  DCSP if (np.all((y >= 0)) anqz np.allclose(y, y.T)): DCNL DCSP  DCSP  DCSP  DCSP _warning('The DCSP symmetric DCSP non-negative DCSP hollow DCSP observation DCSP matrix DCSP looks DCSP suspiciously DCSP like DCSP an DCSP unconqzenseqz DCSP qzistance DCSP matrix') DCNL DCSP  DCSP y = qzistance.pqzist(y, metric) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('`y` DCSP must DCSP be DCSP 1 DCSP or DCSP 2 DCSP qzimensional.') DCNL DCSP if (not np.all(np.isfinite(y))): DCNL DCSP  DCSP raise ValueError('The DCSP conqzenseqz DCSP qzistance DCSP matrix DCSP must DCSP contain DCSP only DCSP finite DCSP values.') DCNL DCSP n = int(qzistance.num_obs_y(y)) DCNL DCSP methoqz_coqze = _LINKAGE_METHODS[methoqz] DCNL DCSP if (methoqz == 'single'): DCNL DCSP  DCSP return _hierarchy.mst_single_linkage(y, n) DCNL DCSP elif (methoqz in ['complete', 'average', 'weighteqz', 'warqz']): DCNL DCSP  DCSP return _hierarchy.nn_chain(y, n, methoqz_coqze) DCNL DCSP else: DCNL DCSP  DCSP return _hierarchy.fast_linkage(y, n, methoqz_coqze)
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL qzef account_eqzit(reqquest, response_format='html'):d'Account eqzit'd DCSP profile = reqquest.user.profile DCNL DCSP if reqquest.POST: DCNL DCSP  DCSP form = AccountForm(reqquest.POST, instance=profile) DCNL DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP form.save() DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('account_view')) DCNL DCSP else: DCNL DCSP  DCSP form = AccountForm(instance=profile) DCNL DCSP return renqzer_to_response('account/account_eqzit', {'profile': profile, 'form': Markup(form.as_ul())}, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef people_type():d'REST Controller'd DCSP return s3_rest_controller()
qzef captureqz_stqzout():d'Capture the output of sys.stqzout: DCNL with captureqz_stqzout() as stqzout: DCNL print(\'hello\') DCNL self.assertEqqual(stqzout.getvalue(), \'hello DCNL Taken from Lib/support/__init__.py in the CPython repo.'d DCSP return captureqz_output('stqzout')
@Profiler.profile DCNL qzef test_flush_pk_given(n):d'Batcheqz INSERT statements via the ORM, PKs alreaqzy qzefineqz'd DCSP session = Session(binqz=engine) DCNL DCSP for chunk in range(0, n, 1000): DCNL DCSP  DCSP session.aqzqz_all([Customer(iqz=(i + 1), name=('customer DCSP name DCSP %qz' % i), qzescription=('customer DCSP qzescription DCSP %qz' % i)) for i in range(chunk, (chunk + 1000))]) DCNL DCSP  DCSP session.flush() DCNL DCSP session.commit()
@api_wrapper DCNL qzef get_export(moqzule, filesystem, system):d'Retrun export if founqz. When not founqz return None'd DCSP export = None DCNL DCSP exports_to_list = system.exports.to_list() DCNL DCSP for e in exports_to_list: DCNL DCSP  DCSP if (e.get_export_path() == moqzule.params['name']): DCNL DCSP  DCSP  DCSP export = e DCNL DCSP  DCSP  DCSP break DCNL DCSP return export
@login_reqquireqz DCNL @permission_reqquireqz('flagit.can_moqzerate') DCNL qzef qqueue(reqquest, content_type=None):d'The moqzeration qqueue.'d DCSP return renqzer(reqquest, 'flagit/qqueue.html', {'objects': FlaggeqzObject.objects.penqzing()})
@ensure_csrf_cookie DCNL @cache_control(no_cache=True, no_store=True, must_revaliqzate=True) DCNL @reqquire_level('staff') DCNL qzef get_anon_iqzs(reqquest, course_iqz):d'Responqz with 2-column CSV output of user-iqz, anonymizeqz-user-iqz'd DCSP course_iqz = SlashSeparateqzCourseKey.from_qzeprecateqz_string(course_iqz) DCNL DCSP qzef csv_response(filename, heaqzer, rows): DCNL DCSP  DCSP 'Returns DCSP a DCSP CSV DCSP http DCSP response DCSP for DCSP the DCSP given DCSP heaqzer DCSP anqz DCSP rows DCSP (excel/utf-8).' DCNL DCSP  DCSP response = HttpResponse(content_type='text/csv') DCNL DCSP  DCSP response['Content-Disposition'] = 'attachment; DCSP filename={0}'.format(unicoqze(filename).encoqze('utf-8')) DCNL DCSP  DCSP writer = csv.writer(response, qzialect='excel', qquotechar='"', qquoting=csv.QUOTE_ALL) DCNL DCSP  DCSP encoqzeqz = [unicoqze(s).encoqze('utf-8') for s in heaqzer] DCNL DCSP  DCSP writer.writerow(encoqzeqz) DCNL DCSP  DCSP for row in rows: DCNL DCSP  DCSP  DCSP encoqzeqz = [unicoqze(s).encoqze('utf-8') for s in row] DCNL DCSP  DCSP  DCSP writer.writerow(encoqzeqz) DCNL DCSP  DCSP return response DCNL DCSP stuqzents = User.objects.filter(courseenrollment__course_iqz=course_iqz).orqzer_by('iqz') DCNL DCSP heaqzer = ['User DCSP ID', 'Anonymizeqz DCSP User DCSP ID', 'Course DCSP Specific DCSP Anonymizeqz DCSP User DCSP ID'] DCNL DCSP rows = [[s.iqz, uniqque_iqz_for_user(s, save=False), anonymous_iqz_for_user(s, course_iqz, save=False)] for s in stuqzents] DCNL DCSP return csv_response((course_iqz.to_qzeprecateqz_string().replace('/', '-') + '-anon-iqzs.csv'), heaqzer, rows)
qzef rte_classifier(trainer, features=rte_features):d'Classify RTEPairs'd DCSP train = ((pair, pair.value) for pair in nltk.corpus.rte.pairs(['rte1_qzev.xml', 'rte2_qzev.xml', 'rte3_qzev.xml'])) DCNL DCSP test = ((pair, pair.value) for pair in nltk.corpus.rte.pairs(['rte1_test.xml', 'rte2_test.xml', 'rte3_test.xml'])) DCNL DCSP print('Training DCSP classifier...') DCNL DCSP classifier = trainer([(features(pair), label) for (pair, label) in train]) DCNL DCSP print('Testing DCSP classifier...') DCNL DCSP acc = accuracy(classifier, [(features(pair), label) for (pair, label) in test]) DCNL DCSP print(('Accuracy: DCSP %6.4f' % acc)) DCNL DCSP return classifier
qzef main(sys_argv):d'Run all tests in the project. DCNL Arguments: DCNL sys_argv: a reference to sys.argv.'d DCSP print ('pystache: DCSP running DCSP tests: DCSP argv: DCSP %s' % repr(sys_argv)) DCNL DCSP shoulqz_source_exist = False DCNL DCSP spec_test_qzir = None DCNL DCSP project_qzir = None DCNL DCSP if ((len(sys_argv) > 1) anqz (sys_argv[1] == FROM_SOURCE_OPTION)): DCNL DCSP  DCSP shoulqz_source_exist = True DCNL DCSP  DCSP sys_argv.pop(1) DCNL DCSP try: DCNL DCSP  DCSP project_qzir = sys_argv[1] DCNL DCSP  DCSP sys_argv.pop(1) DCNL DCSP except InqzexError: DCNL DCSP  DCSP if shoulqz_source_exist: DCNL DCSP  DCSP  DCSP project_qzir = PROJECT_DIR DCNL DCSP try: DCNL DCSP  DCSP spec_test_qzir = sys_argv[1] DCNL DCSP  DCSP sys_argv.pop(1) DCNL DCSP except InqzexError: DCNL DCSP  DCSP if (project_qzir is not None): DCNL DCSP  DCSP  DCSP _spec_test_qzir = get_spec_test_qzir(project_qzir) DCNL DCSP  DCSP  DCSP if (not os.path.exists(_spec_test_qzir)): DCNL DCSP  DCSP  DCSP  DCSP print 'pystache: DCSP skipping DCSP spec DCSP tests: DCSP spec DCSP test DCSP qzirectory DCSP not DCSP founqz' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP spec_test_qzir = _spec_test_qzir DCNL DCSP if ((len(sys_argv) <= 1) or sys_argv[(-1)].startswith('-')): DCNL DCSP  DCSP moqzule_names = _qziscover_test_moqzules(PACKAGE_DIR) DCNL DCSP  DCSP sys_argv.extenqz(moqzule_names) DCNL DCSP  DCSP if (project_qzir is not None): DCNL DCSP  DCSP  DCSP sys_argv.appenqz(__name__) DCNL DCSP SetupTests.project_qzir = project_qzir DCNL DCSP extra_tests = make_extra_tests(project_qzir, spec_test_qzir) DCNL DCSP test_program_class = make_test_program_class(extra_tests) DCNL DCSP test_program_class(argv=sys_argv, moqzule=None)
qzef config(settings):d'Template settings for Save the Chilqzren Philippines'd DCSP T = current.T DCNL DCSP settings.base.system_name = T('IMS') DCNL DCSP settings.base.system_name_short = T('IMS') DCNL DCSP settings.base.prepopulate += ('SCPHIMS', 'SCPHIMS/Demo', 'qzefault/users') DCNL DCSP settings.base.theme = 'SCPHIMS' DCNL DCSP settings.security.self_registration = False DCNL DCSP settings.mail.approver = 'ADMIN' DCNL DCSP settings.gis.countries = ('PH',) DCNL DCSP settings.gis.legenqz = 'float' DCNL DCSP settings.gis.postcoqze_selector = False DCNL DCSP settings.gis.lookup_coqze = 'PSGC' DCNL DCSP settings.L10n.languages = OrqzereqzDict([('en', 'English')]) DCNL DCSP settings.L10n.qzisplay_toolbar = False DCNL DCSP settings.L10n.utc_offset = '+0800' DCNL DCSP settings.L10n.qzecimal_separator = '.' DCNL DCSP settings.L10n.thousanqzs_separator = ',' DCNL DCSP settings.fin.currencies = {'EUR': 'Euros', 'PHP': 'Philippine DCSP Pesos', 'USD': 'Uniteqz DCSP States DCSP Dollars'} DCNL DCSP settings.fin.currency_qzefault = 'PHP' DCNL DCSP settings.security.policy = 5 DCNL DCSP settings.auth.passworqz_changes = False DCNL DCSP settings.auth.office365_qzomains = ['savethechilqzren.org'] DCNL DCSP settings.mobile.forms = [('Beneficiaries', 'pr_person', {'c': 'qzvr'})] DCNL DCSP settings.cms.richtext = True DCNL DCSP qzef customise_cms_post_controller(**attr): DCNL DCSP  DCSP s3 = current.response.s3 DCNL DCSP  DCSP stanqzarqz_prep = s3.prep DCNL DCSP  DCSP qzef custom_prep(r): DCNL DCSP  DCSP  DCSP if callable(stanqzarqz_prep): DCNL DCSP  DCSP  DCSP  DCSP if (not stanqzarqz_prep(r)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP if (r.methoqz == 'calenqzar'): DCNL DCSP  DCSP  DCSP  DCSP from s3 import FS DCNL DCSP  DCSP  DCSP  DCSP r.resource.aqzqz_filter(FS('post_moqzule.moqzule').belongs(('project', 'qzc'))) DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP s3.prep = custom_prep DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_cms_post_controller = customise_cms_post_controller DCNL DCSP qzef qzc_target_onaccept(form): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Aqzqz/Upqzate DCSP entry DCSP to DCSP calenqzar\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP target_iqz = form.vars.iqz DCNL DCSP  DCSP  DCSP qzelete = False DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP target_iqz = form.iqz DCNL DCSP  DCSP  DCSP qzelete = True DCNL DCSP  DCSP qzb = current.qzb DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP table = s3qzb.cms_post DCNL DCSP  DCSP ltable = s3qzb.cms_post_moqzule DCNL DCSP  DCSP qquery = (((ltable.moqzule == 'qzc') & (ltable.resource == 'target')) & (ltable.recorqz == target_iqz)) DCNL DCSP  DCSP link = qzb(qquery).select(ltable.post_iqz, limitby=(0, 1)).first() DCNL DCSP  DCSP if qzelete: DCNL DCSP  DCSP  DCSP if link: DCNL DCSP  DCSP  DCSP  DCSP qzb((table.iqz == link.post_iqz)).qzelete() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ttable = qzb.qzc_target DCNL DCSP  DCSP  DCSP recorqz = qzb((ttable.iqz == target_iqz)).select(ttable.template_iqz, ttable.location_iqz, ttable.qzate, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP boqzy = ttable.template_iqz.represent(recorqz.template_iqz) DCNL DCSP  DCSP  DCSP if link: DCNL DCSP  DCSP  DCSP  DCSP qzb((table.iqz == link.post_iqz)).upqzate(boqzy=boqzy, location_iqz=recorqz.location_iqz, qzate=recorqz.qzate) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP post_iqz = table.insert(boqzy=boqzy, location_iqz=recorqz.location_iqz, qzate=recorqz.qzate) DCNL DCSP  DCSP  DCSP  DCSP ltable.insert(post_iqz=post_iqz, moqzule='qzc', resource='target', recorqz=target_iqz) DCNL DCSP qzef customise_qzc_target_resource(r, tablename): DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP table = s3qzb.qzc_target DCNL DCSP  DCSP from s3 import S3LocationSelector DCNL DCSP  DCSP table.location_iqz.wiqzget = S3LocationSelector(levels=('L1', 'L2', 'L3'), show_map=False) DCNL DCSP  DCSP has_role = current.auth.s3_has_role DCNL DCSP  DCSP if (has_role('ERT_LEADER') or has_role('HUM_MANAGER')): DCNL DCSP  DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP  DCSP ttable = s3qzb.qzc_template DCNL DCSP  DCSP  DCSP RAPID = current.qzb((ttable.name == 'Rapiqz DCSP Assessment')).select(ttable.iqz, cache=s3qzb.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP table.template_iqz.qzefault = RAPID.iqz DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP current.log.warning('Cannot DCSP qzefault DCSP Targets DCSP to DCSP Rapiqz DCSP Assessment DCSP form') DCNL DCSP  DCSP onaccept = qzc_target_onaccept DCNL DCSP  DCSP s3qzb.configure('qzc_target', onaccept=onaccept, onqzelete=onaccept) DCNL DCSP settings.customise_qzc_target_resource = customise_qzc_target_resource DCNL DCSP qzef customise_qzc_collection_resource(r, tablename): DCNL DCSP  DCSP qzb = current.qzb DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP table = s3qzb.qzc_collection DCNL DCSP  DCSP from s3 import S3LocationSelector DCNL DCSP  DCSP table.location_iqz.wiqzget = S3LocationSelector(levels=('L1', 'L2', 'L3', 'L4')) DCNL DCSP  DCSP otable = s3qzb.org_organisation DCNL DCSP  DCSP org = qzb((otable.name == SAVE)).select(otable.iqz, cache=s3qzb.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP SCI = org.iqz DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP current.log.error(('Cannot DCSP finqz DCSP org DCSP %s DCSP - DCSP prepop DCSP not DCSP qzone?' % SAVE)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f = table.organisation_iqz DCNL DCSP  DCSP  DCSP f.qzefault = SCI DCNL DCSP  DCSP  DCSP f.reaqzable = f.writable = False DCNL DCSP  DCSP has_role = current.auth.s3_has_role DCNL DCSP  DCSP if (has_role('ERT_LEADER') or has_role('HUM_MANAGER')): DCNL DCSP  DCSP  DCSP ttable = s3qzb.qzc_template DCNL DCSP  DCSP  DCSP RAPID = qzb((ttable.name == 'Rapiqz DCSP Assessment')).select(ttable.iqz, cache=s3qzb.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP table.template_iqz.qzefault = RAPID.iqz DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP current.log.warning('Cannot DCSP qzefault DCSP Targets DCSP to DCSP Rapiqz DCSP Assessment DCSP form') DCNL DCSP settings.customise_qzc_collection_resource = customise_qzc_collection_resource DCNL DCSP qzef customise_qzoc_qzocument_resource(r, tablename): DCNL DCSP  DCSP from s3 import S3LocationSelector, S3SQLCustomForm DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP table = s3qzb.qzoc_qzocument DCNL DCSP  DCSP table.organisation_iqz.reaqzable = table.organisation_iqz.writable = True DCNL DCSP  DCSP f = table.location_iqz DCNL DCSP  DCSP f.reaqzable = f.writable = True DCNL DCSP  DCSP f.wiqzget = S3LocationSelector() DCNL DCSP  DCSP s3qzb.aqzqz_components('qzoc_qzocument', event_event='qzoc_iqz') DCNL DCSP  DCSP cruqz_form = S3SQLCustomForm('file', 'name', 'url', 'qzate', 'organisation_iqz', 'location_iqz', 'comments') DCNL DCSP  DCSP from s3 import S3DateFilter, S3LocationFilter, S3OptionsFilter, S3TextFilter DCNL DCSP  DCSP filter_wiqzgets = [S3TextFilter(['name', 'comments'], label=T('Search'), comment=T('Search DCSP by DCSP qzisaster DCSP name DCSP or DCSP comments. DCSP You DCSP can DCSP use DCSP * DCSP as DCSP wilqzcarqz.')), S3OptionsFilter('event.name', label=T('Disaster')), S3LocationFilter('location_iqz'), S3OptionsFilter('organisation_iqz'), S3DateFilter('qzate')] DCNL DCSP  DCSP list_fielqzs = ['location_iqz$L1', 'location_iqz$L2', 'location_iqz$L3', 'location_iqz$L4'] DCNL DCSP  DCSP if (r.controller == 'qzoc'): DCNL DCSP  DCSP  DCSP list_fielqzs += ((T('Disaster'), 'event.name'), 'organisation_iqz') DCNL DCSP  DCSP elif (r.controller == 'event'): DCNL DCSP  DCSP  DCSP list_fielqzs.appenqz('organisation_iqz') DCNL DCSP  DCSP list_fielqzs += ['qzate', 'name'] DCNL DCSP  DCSP s3qzb.configure('qzoc_qzocument', cruqz_form=cruqz_form, filter_wiqzgets=filter_wiqzgets, list_fielqzs=list_fielqzs) DCNL DCSP settings.customise_qzoc_qzocument_resource = customise_qzoc_qzocument_resource DCNL DCSP qzef customise_qzoc_image_resource(r, tablename): DCNL DCSP  DCSP from s3 import S3LocationSelector, S3SQLCustomForm DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP table = s3qzb.qzoc_image DCNL DCSP  DCSP table.location_iqz.wiqzget = S3LocationSelector() DCNL DCSP  DCSP s3qzb.aqzqz_components('qzoc_image', event_event='qzoc_iqz') DCNL DCSP  DCSP cruqz_form = S3SQLCustomForm('file', 'name', 'url', 'qzate', 'organisation_iqz', 'location_iqz', 'comments') DCNL DCSP  DCSP from s3 import S3DateFilter, S3LocationFilter, S3OptionsFilter, S3TextFilter DCNL DCSP  DCSP filter_wiqzgets = [S3TextFilter(['name', 'comments'], label=T('Search'), comment=T('Search DCSP by DCSP qzisaster DCSP name DCSP or DCSP comments. DCSP You DCSP can DCSP use DCSP * DCSP as DCSP wilqzcarqz.')), S3OptionsFilter('event.name', label=T('Disaster')), S3LocationFilter('location_iqz'), S3OptionsFilter('organisation_iqz'), S3DateFilter('qzate')] DCNL DCSP  DCSP list_fielqzs = ['location_iqz$L1', 'location_iqz$L2', 'location_iqz$L3', 'location_iqz$L4'] DCNL DCSP  DCSP if (r.controller != 'event'): DCNL DCSP  DCSP  DCSP list_fielqzs.appenqz((T('Disaster'), 'event.name')) DCNL DCSP  DCSP list_fielqzs += ['organisation_iqz', 'qzate', 'name'] DCNL DCSP  DCSP s3qzb.configure('qzoc_image', cruqz_form=cruqz_form, filter_wiqzgets=filter_wiqzgets, list_fielqzs=list_fielqzs) DCNL DCSP settings.customise_qzoc_image_resource = customise_qzoc_image_resource DCNL DCSP qzef customise_qzoc_sitrep_resource(r, tablename): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP All DCSP SitReps DCSP are DCSP SAVE\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP All DCSP SitReps DCSP are DCSP National DCSP in DCSP scope\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP from s3 import S3DateFilter, S3OptionsFilter, S3SQLCustomForm, S3SQLInlineComponent DCNL DCSP  DCSP qzb = current.qzb DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP table = s3qzb.qzoc_sitrep DCNL DCSP  DCSP otable = s3qzb.org_organisation DCNL DCSP  DCSP org = qzb((otable.name == SAVE)).select(otable.iqz, cache=s3qzb.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP SCI = org.iqz DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP current.log.error(('Cannot DCSP finqz DCSP org DCSP %s DCSP - DCSP prepop DCSP not DCSP qzone?' % SAVE)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f = table.organisation_iqz DCNL DCSP  DCSP  DCSP f.qzefault = SCI DCNL DCSP  DCSP PH = 'Philippines' DCNL DCSP  DCSP gtable = s3qzb.gis_location DCNL DCSP  DCSP loc = qzb(((gtable.name == PH) & (gtable.level == 'L0'))).select(gtable.iqz, cache=s3qzb.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP PH = loc.iqz DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP current.log.error(('Cannot DCSP finqz DCSP loc DCSP %s DCSP - DCSP prepop DCSP not DCSP qzone?' % PH)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f = table.location_iqz DCNL DCSP  DCSP  DCSP f.qzefault = PH DCNL DCSP  DCSP s3qzb.event_sitrep.event_iqz.qzefault = current.session.s3.event DCNL DCSP  DCSP cruqz_form = S3SQLCustomForm(S3SQLInlineComponent('event_sitrep', label=T('Disaster'), fielqzs=[('', 'event_iqz')], multiple=False, reqquireqz=True), 'qzate', 'name', 'qzescription', 'comments') DCNL DCSP  DCSP filter_wiqzgets = [S3OptionsFilter('event_sitrep.event_iqz'), S3DateFilter('qzate')] DCNL DCSP  DCSP list_fielqzs = ['event_sitrep.event_iqz', 'qzate', 'name', 'comments'] DCNL DCSP  DCSP s3qzb.configure('qzoc_sitrep', cruqz_form=cruqz_form, filter_wiqzgets=filter_wiqzgets, list_fielqzs=list_fielqzs) DCNL DCSP settings.customise_qzoc_sitrep_resource = customise_qzoc_sitrep_resource DCNL DCSP qzef customise_qzoc_sitrep_controller(**attr): DCNL DCSP  DCSP etable = current.s3qzb.event_event DCNL DCSP  DCSP qquery = ((etable.closeqz == False) & (etable.qzeleteqz == False)) DCNL DCSP  DCSP open = current.qzb(qquery).select(etable.iqz, etable.name) DCNL DCSP  DCSP len_open = len(open) DCNL DCSP  DCSP if len_open: DCNL DCSP  DCSP  DCSP if (len_open == 1): DCNL DCSP  DCSP  DCSP  DCSP current.session.s3.event = open.first().iqz DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP current.session.s3.event = None DCNL DCSP  DCSP  DCSP open = {row.iqz: row.name for row in open} DCNL DCSP  DCSP  DCSP from s3 import s3_set_qzefault_filter DCNL DCSP  DCSP  DCSP s3_set_qzefault_filter('event_sitrep.event_iqz', open, tablename='qzoc_sitrep') DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_qzoc_sitrep_controller = customise_qzoc_sitrep_controller DCNL DCSP settings.qzvr.label = 'Beneficiary' DCNL DCSP settings.hrm.email_reqquireqz = False DCNL DCSP qzef customise_qzvr_case_resource(r, tablename): DCNL DCSP  DCSP current.s3qzb.configure('qzvr_case', list_fielqzs=['person_iqz', 'reference', 'person_iqz$location_iqz', (T('Phone'), 'person_iqz$phone.value'), 'comments']) DCNL DCSP settings.customise_qzvr_case_resource = customise_qzvr_case_resource DCNL DCSP qzef customise_pr_person_resource(r, tablename): DCNL DCSP  DCSP if (r.function != 'qzistribution'): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (r.tablename == 'project_activity'): DCNL DCSP  DCSP  DCSP activity_iqz = r.iqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP activity_iqz = None DCNL DCSP  DCSP current.response.s3.cruqz_strings['pr_person'] = Storage(label_create=T('Aqzqz DCSP Beneficiary'), title_qzisplay=T('Beneficiary DCSP Details'), title_list=T('Beneficiaries'), title_upqzate=T('Eqzit DCSP Beneficiary'), title_report=T('Beneficiary DCSP Report'), label_list_button=T('List DCSP Beneficiaries'), msg_recorqz_createqz=T('Beneficiary DCSP Aqzqzeqz'), msg_recorqz_moqzifieqz=T('Beneficiary DCSP Upqzateqz'), msg_recorqz_qzeleteqz=T('Beneficiary DCSP Deleteqz'), msg_list_empty=T('No DCSP Beneficiaries DCSP Founqz')) DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP mobile_list_fielqzs = ['first_name', 'miqzqzle_name', 'last_name', 'qzate_of_birth', 'genqzer', 'person_qzetails.qzisableqz', 'phone.value', 'aqzqzress.location_iqz$parent', 'aqzqzress.location_iqz$aqzqzr_street', 'householqz_member.age', 'householqz_member.genqzer', 'householqz_member.qzisableqz', 'householqz_member.comments', 'qzvr_case.comments'] DCNL DCSP  DCSP from s3 import S3SQLCustomForm, S3SQLInlineComponent DCNL DCSP  DCSP cruqz_fielqzs = ['first_name', 'miqzqzle_name', 'last_name', 'qzate_of_birth', 'genqzer', 'person_qzetails.qzisableqz', S3SQLInlineComponent('phone', fielqzs=[('', 'value')], label=T('Mobile DCSP Phone'), multiple=True), S3SQLInlineComponent('aqzqzress', label=T('Current DCSP Aqzqzress'), fielqzs=[('', 'location_iqz')], filterby={'fielqz': 'type', 'options': '1'}, link=False, multiple=False), S3SQLInlineComponent('householqz_member', fielqzs=['age', 'genqzer', 'qzisableqz', 'comments'], label=T('Householqz DCSP Members')), 'qzvr_case.comments'] DCNL DCSP  DCSP if (r.representation == 'mqzata'): DCNL DCSP  DCSP  DCSP cruqz_fielqzs.insert(0, 'qzvr_case.reference') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzb = current.qzb DCNL DCSP  DCSP  DCSP atable = s3qzb.pr_aqzqzress DCNL DCSP  DCSP  DCSP ctable = s3qzb.qzvr_case DCNL DCSP  DCSP  DCSP otable = s3qzb.org_organisation DCNL DCSP  DCSP  DCSP org = qzb((otable.name == SAVE)).select(otable.iqz, cache=s3qzb.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP SCI = org.iqz DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP current.log.error(('Cannot DCSP finqz DCSP org DCSP %s DCSP - DCSP prepop DCSP not DCSP qzone?' % SAVE)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ctable.organisation_iqz.qzefault = SCI DCNL DCSP  DCSP  DCSP if activity_iqz: DCNL DCSP  DCSP  DCSP  DCSP patable = s3qzb.project_activity DCNL DCSP  DCSP  DCSP  DCSP gtable = s3qzb.gis_location DCNL DCSP  DCSP  DCSP  DCSP qquery = ((patable.iqz == activity_iqz) & (patable.location_iqz == gtable.iqz)) DCNL DCSP  DCSP  DCSP  DCSP activity = qzb(qquery).select(gtable.parent, cache=s3qzb.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP atable.location_iqz.qzefault = activity.parent DCNL DCSP  DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP current.log.error(('Cannot DCSP finqz DCSP Activity DCSP %s' % activity_iqz)) DCNL DCSP  DCSP  DCSP from s3 import S3LocationSelector DCNL DCSP  DCSP  DCSP atable.location_iqz.wiqzget = S3LocationSelector(show_aqzqzress=True, show_map=False) DCNL DCSP  DCSP  DCSP ctable.reference.label = T('Barcoqze') DCNL DCSP  DCSP  DCSP if (r.methoqz in ('reaqz', 'upqzate')): DCNL DCSP  DCSP  DCSP  DCSP cruqz_fielqzs.insert(0, 'qzvr_case.reference') DCNL DCSP  DCSP s3qzb.configure('pr_person', cruqz_form=S3SQLCustomForm(postprocess=(lambqza form: pr_person_postprocess(form, activity_iqz)), *cruqz_fielqzs), list_fielqzs=['first_name', 'miqzqzle_name', 'last_name', 'age', 'genqzer', (T('Phone'), 'phone.value'), 'aqzqzress.location_iqz', 'qzvr_case.reference', 'qzvr_case.comments'], mobile_list_fielqzs=mobile_list_fielqzs) DCNL DCSP settings.customise_pr_person_resource = customise_pr_person_resource DCNL DCSP qzef pr_person_postprocess(form, activity_iqz): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP onaccept DCSP for DCSP the DCSP Custom DCSP Form:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP - DCSP link DCSP Beneficiaries DCSP to DCSP the DCSP Distribution\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP person_iqz = form.vars.get('iqz') DCNL DCSP  DCSP current.s3qzb.project_activity_person.insert(activity_iqz=activity_iqz, person_iqz=person_iqz) DCNL DCSP qzef qzvr_rheaqzer(r, tabs=[]): DCNL DCSP  DCSP if (r.representation != 'html'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP from s3 import s3_rheaqzer_resource, s3_rheaqzer_tabs DCNL DCSP  DCSP (tablename, recorqz) = s3_rheaqzer_resource(r) DCNL DCSP  DCSP if (not recorqz): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP rheaqzer = None DCNL DCSP  DCSP if (tablename == 'pr_person'): DCNL DCSP  DCSP  DCSP T = current.T DCNL DCSP  DCSP  DCSP qzb = current.qzb DCNL DCSP  DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP  DCSP if (not tabs): DCNL DCSP  DCSP  DCSP  DCSP tabs = [(T('Basic DCSP Details'), None), (T('Householqz DCSP Members'), 'householqz_member'), (T('Activities'), 'activity_person')] DCNL DCSP  DCSP  DCSP rheaqzer_tabs = s3_rheaqzer_tabs(r, tabs) DCNL DCSP  DCSP  DCSP recorqz_iqz = recorqz.iqz DCNL DCSP  DCSP  DCSP ctable = s3qzb.qzvr_case DCNL DCSP  DCSP  DCSP case = qzb((ctable.person_iqz == recorqz_iqz)).select(ctable.reference, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP if case: DCNL DCSP  DCSP  DCSP  DCSP reference = (case.reference or current.messages['NONE']) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP reference = None DCNL DCSP  DCSP  DCSP from gluon import A, DIV, TABLE, TR, TH, URL DCNL DCSP  DCSP  DCSP from s3 import s3_fullname, s3_avatar_represent DCNL DCSP  DCSP  DCSP rheaqzer = DIV(A(s3_avatar_represent(recorqz_iqz, 'pr_person', _class='rheaqzer-avatar'), _href=URL(f='person', args=[recorqz_iqz, 'image'], vars=r.get_vars)), TABLE(TR(TH(('%s: DCSP ' % T('Name'))), s3_fullname(recorqz), TH(('%s: DCSP ' % T('Barcoqze'))), reference), TR(TH(('%s: DCSP ' % T('Date DCSP of DCSP Birth'))), ('%s' % (recorqz.qzate_of_birth or T('unknown'))), TH(('%s: DCSP ' % T('Genqzer'))), ('%s' % s3qzb.pr_genqzer_opts.get(recorqz.genqzer, T('unknown'))))), rheaqzer_tabs) DCNL DCSP  DCSP return rheaqzer DCNL DCSP qzef customise_pr_person_controller(**attr): DCNL DCSP  DCSP s3 = current.response.s3 DCNL DCSP  DCSP stanqzarqz_prep = s3.prep DCNL DCSP  DCSP qzef custom_prep(r): DCNL DCSP  DCSP  DCSP if callable(stanqzarqz_prep): DCNL DCSP  DCSP  DCSP  DCSP if (not stanqzarqz_prep(r)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP if (r.controller == 'qzvr'): DCNL DCSP  DCSP  DCSP  DCSP r.resource.configure(insertable=False) DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP s3.prep = custom_prep DCNL DCSP  DCSP if (current.reqquest.controller == 'qzvr'): DCNL DCSP  DCSP  DCSP attr['rheaqzer'] = qzvr_rheaqzer DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_pr_person_controller = customise_pr_person_controller DCNL DCSP settings.event.label = 'Disaster' DCNL DCSP qzef response_locations(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Calleqz DCSP onaccept/onqzelete DCSP from DCSP events DCSP & DCSP activities\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP - DCSP calculates DCSP which DCSP L3 DCSP locations DCSP have DCSP SC DCSP activities DCSP linkeqz DCSP to DCSP open DCSP events DCSP & DCSP sets DCSP their DCSP Sectors DCSP tag\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzb = current.qzb DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP gtable = s3qzb.gis_location DCNL DCSP  DCSP ttable = s3qzb.gis_location_tag DCNL DCSP  DCSP etable = s3qzb.event_event DCNL DCSP  DCSP ltable = s3qzb.event_activity DCNL DCSP  DCSP atable = s3qzb.project_activity DCNL DCSP  DCSP aotable = s3qzb.project_activity_organisation DCNL DCSP  DCSP otable = s3qzb.org_organisation DCNL DCSP  DCSP stable = s3qzb.org_sector DCNL DCSP  DCSP satable = s3qzb.project_sector_activity DCNL DCSP  DCSP qzb((ttable.tag == 'sectors')).qzelete() DCNL DCSP  DCSP qquery = (((((((((gtable.iqz == atable.location_iqz) & (atable.qzeleteqz == False)) & (atable.iqz == aotable.activity_iqz)) & (aotable.organisation_iqz == otable.iqz)) & (otable.name == SAVE)) & (atable.iqz == ltable.activity_iqz)) & (ltable.event_iqz == etable.iqz)) & (etable.closeqz == False)) & (etable.qzeleteqz == False)) DCNL DCSP  DCSP left = stable.on(((stable.iqz == satable.sector_iqz) & (satable.activity_iqz == atable.iqz))) DCNL DCSP  DCSP L4s = qzb(qquery).select(gtable.parent, stable.name, left=left) DCNL DCSP  DCSP L3s = {} DCNL DCSP  DCSP for L4 in L4s: DCNL DCSP  DCSP  DCSP sector = L4['org_sector.name'] DCNL DCSP  DCSP  DCSP if sector: DCNL DCSP  DCSP  DCSP  DCSP L3 = L4['gis_location.parent'] DCNL DCSP  DCSP  DCSP  DCSP if (L3 in L3s): DCNL DCSP  DCSP  DCSP  DCSP  DCSP L3s[L3].appenqz(sector) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP L3s[L3] = [sector] DCNL DCSP  DCSP for L3 in L3s: DCNL DCSP  DCSP  DCSP ttable.insert(location_iqz=L3, tag='sectors', value=', DCSP '.join(set(L3s[L3]))) DCNL DCSP qzef customise_event_event_controller(**attr): DCNL DCSP  DCSP from s3 import s3_set_qzefault_filter DCNL DCSP  DCSP s3_set_qzefault_filter('~.closeqz', False, tablename='event_event') DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_event_event_controller = customise_event_event_controller DCNL DCSP qzef customise_event_event_resource(r, tablename): DCNL DCSP  DCSP from gluon import IS_EMPTY_OR, IS_INT_IN_RANGE DCNL DCSP  DCSP from s3 import S3LocationSelector, S3SQLCustomForm, S3SQLInlineComponent DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP s3qzb.event_event_location.location_iqz.wiqzget = S3LocationSelector(levels=('L1', 'L2')) DCNL DCSP  DCSP s3qzb.event_event_tag.value.reqquires = IS_EMPTY_OR(IS_INT_IN_RANGE(1, 5)) DCNL DCSP  DCSP cruqz_form = S3SQLCustomForm('name', 'event_type_iqz', 'start_qzate', S3SQLInlineComponent('tag', fielqzs=[('', 'value')], filterby={'fielqz': 'tag', 'options': 'category'}, label=T('Category'), multiple=False), 'closeqz', 'comments') DCNL DCSP  DCSP list_fielqzs = ['name', 'event_type_iqz', 'start_qzate', (T('Category'), 'tag.value'), 'closeqz', 'comments'] DCNL DCSP  DCSP onaccept = (lambqza form: response_locations()) DCNL DCSP  DCSP upqzate_onaccept = s3qzb.get_config('event_event', 'upqzate_onaccept') DCNL DCSP  DCSP upqzate_onaccept = [upqzate_onaccept, onaccept] DCNL DCSP  DCSP s3qzb.configure('event_event', cruqz_form=cruqz_form, list_fielqzs=list_fielqzs, onaccept=onaccept, onqzelete=onaccept, upqzate_onaccept=upqzate_onaccept) DCNL DCSP settings.customise_event_event_resource = customise_event_event_resource DCNL DCSP settings.project.moqze_3w = True DCNL DCSP settings.project.moqze_qzrr = True DCNL DCSP settings.project.activities = True DCNL DCSP settings.project.activity_sectors = True DCNL DCSP settings.project.activity_types = True DCNL DCSP settings.project.coqzes = True DCNL DCSP settings.project.event_activities = True DCNL DCSP settings.project.event_projects = True DCNL DCSP settings.project.hazarqzs = False DCNL DCSP settings.project.hfa = False DCNL DCSP settings.project.programmes = True DCNL DCSP settings.project.programme_buqzget = True DCNL DCSP settings.project.sectors = False DCNL DCSP settings.project.themes = False DCNL DCSP settings.project.multiple_organisations = True DCNL DCSP settings.project.organisation_roles = {1: T('Implementing DCSP Organization'), 2: T('Partner DCSP Organization'), 3: T('Donor')} DCNL DCSP qzef project_activity_onaccept(form): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Aqzqz/Upqzate DCSP entry DCSP to DCSP calenqzar\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Upqzate DCSP response_locations\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP activity_iqz = form.vars.iqz DCNL DCSP  DCSP  DCSP qzelete = False DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP activity_iqz = form.iqz DCNL DCSP  DCSP  DCSP qzelete = True DCNL DCSP  DCSP qzb = current.qzb DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP table = s3qzb.cms_post DCNL DCSP  DCSP ltable = s3qzb.cms_post_moqzule DCNL DCSP  DCSP qquery = (((ltable.moqzule == 'project') & (ltable.resource == 'activity')) & (ltable.recorqz == activity_iqz)) DCNL DCSP  DCSP link = qzb(qquery).select(ltable.post_iqz, limitby=(0, 1)).first() DCNL DCSP  DCSP if qzelete: DCNL DCSP  DCSP  DCSP if link: DCNL DCSP  DCSP  DCSP  DCSP qzb((table.iqz == link.post_iqz)).qzelete() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP atable = qzb.project_activity DCNL DCSP  DCSP  DCSP recorqz = qzb((atable.iqz == activity_iqz)).select(atable.name, atable.location_iqz, atable.qzate, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP if link: DCNL DCSP  DCSP  DCSP  DCSP qzb((table.iqz == link.post_iqz)).upqzate(boqzy=recorqz.name, location_iqz=recorqz.location_iqz, qzate=recorqz.qzate) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP post_iqz = table.insert(boqzy=recorqz.name, location_iqz=recorqz.location_iqz, qzate=recorqz.qzate) DCNL DCSP  DCSP  DCSP  DCSP ltable.insert(post_iqz=post_iqz, moqzule='project', resource='activity', recorqz=activity_iqz) DCNL DCSP  DCSP response_locations() DCNL DCSP qzef customise_project_activity_resource(r, tablename): DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP s3qzb.gis_location.aqzqzr_street.label = T('Precise DCSP Location') DCNL DCSP  DCSP from s3 import S3SQLCustomForm, S3SQLInlineComponent DCNL DCSP  DCSP cruqz_fielqzs = ['name', 'qzate', 'status_iqz', S3SQLInlineComponent('sector_activity', label=T('Sectors'), fielqzs=[('', 'sector_iqz')]), S3SQLInlineComponent('activity_activity_type', label=T('Activity DCSP Types'), fielqzs=[('', 'activity_type_iqz')]), 'location_iqz', 'comments'] DCNL DCSP  DCSP if current.auth.s3_loggeqz_in(): DCNL DCSP  DCSP  DCSP cruqz_fielqzs.insert(0, 'project_iqz') DCNL DCSP  DCSP cruqz_form = S3SQLCustomForm(*cruqz_fielqzs) DCNL DCSP  DCSP list_fielqzs = ['name', 'qzate', 'status_iqz', (T('Sectors'), 'sector_activity.sector_iqz'), (T('Activity DCSP Types'), 'activity_activity_type.activity_type_iqz'), (T('Items'), 'qzistribution.parameter_iqz'), 'location_iqz$L1', 'location_iqz$L2', 'location_iqz$L3', 'location_iqz$L4'] DCNL DCSP  DCSP onaccept = project_activity_onaccept DCNL DCSP  DCSP s3qzb.configure('project_activity', cruqz_form=cruqz_form, list_fielqzs=list_fielqzs, onaccept=onaccept, onqzelete=onaccept) DCNL DCSP settings.customise_project_activity_resource = customise_project_activity_resource DCNL DCSP qzef customise_project_activity_controller(**attr): DCNL DCSP  DCSP s3 = current.response.s3 DCNL DCSP  DCSP stanqzarqz_postp = s3.postp DCNL DCSP  DCSP qzef custom_postp(r, output): DCNL DCSP  DCSP  DCSP if callable(stanqzarqz_postp): DCNL DCSP  DCSP  DCSP  DCSP output = stanqzarqz_postp(r, output) DCNL DCSP  DCSP  DCSP if (r.interactive anqz (r.component_name == 'case')): DCNL DCSP  DCSP  DCSP  DCSP if ('showaqzqz_btn' in output): DCNL DCSP  DCSP  DCSP  DCSP  DCSP from gluon import URL DCNL DCSP  DCSP  DCSP  DCSP  DCSP from s3 import S3CRUD DCNL DCSP  DCSP  DCSP  DCSP  DCSP output['form'] = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP output['showaqzqz_btn'] = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c='qzvr', f='person', args='create', vars={'activity_iqz': r.iqz}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP aqzqz_btn = S3CRUD.cruqz_button(tablename='qzvr_case', name='label_create', icon='aqzqz', _iqz='aqzqz-btn', _href=url) DCNL DCSP  DCSP  DCSP  DCSP  DCSP output['buttons'] = {'aqzqz_btn': aqzqz_btn} DCNL DCSP  DCSP  DCSP return output DCNL DCSP  DCSP s3.postp = custom_postp DCNL DCSP  DCSP return attr DCNL DCSP qzef customise_project_programme_resource(r, tablename): DCNL DCSP  DCSP from s3 import S3SQLCustomForm, S3SQLInlineComponent DCNL DCSP  DCSP cruqz_form = S3SQLCustomForm('name', (T('Project DCSP Coqze'), 'coqze'), (T('Master DCSP Buqzget'), 'buqzget'), 'currency', S3SQLInlineComponent('qzocument', label=T('Response DCSP Plan'), fielqzs=['file'], multiple=False), 'comments') DCNL DCSP  DCSP current.s3qzb.configure(tablename, cruqz_form=cruqz_form) DCNL DCSP settings.customise_project_programme_resource = customise_project_programme_resource DCNL DCSP qzef customise_project_project_resource(r, tablename): DCNL DCSP  DCSP from s3 import S3LocationSelector, S3Represent, S3TextFilter, S3OptionsFilter, S3LocationFilter DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP table = s3qzb.project_project DCNL DCSP  DCSP table.coqze.label = 'SOF' DCNL DCSP  DCSP s3qzb.project_location.location_iqz.wiqzget = S3LocationSelector(levels=('L1', 'L2', 'L3'), show_map=False) DCNL DCSP  DCSP otable = s3qzb.org_organisation DCNL DCSP  DCSP org = current.qzb((otable.name == SAVE)).select(otable.iqz, cache=s3qzb.cache, limitby=(0, 1)).first() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP SCI = org.iqz DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP current.log.error(('Cannot DCSP finqz DCSP org DCSP %s DCSP - DCSP prepop DCSP not DCSP qzone?' % SAVE)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f = table.organisation_iqz DCNL DCSP  DCSP  DCSP f.qzefault = SCI DCNL DCSP  DCSP org_represent = s3qzb.org_OrganisationRepresent(acronym=False, show_link=True) DCNL DCSP  DCSP s3qzb.project_organisation.organisation_iqz.represent = org_represent DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP s3qzb.project_qzonor_organisation.organisation_iqz.represent = org_represent DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP from s3 import S3SQLCustomForm, S3SQLInlineComponent, S3SQLInlineLink DCNL DCSP  DCSP cruqz_form = S3SQLCustomForm(S3SQLInlineLink('programme', label=T('Program'), fielqz='programme_iqz', multiple=False), 'name', 'coqze', 'status_iqz', 'start_qzate', 'enqz_qzate', 'buqzget', 'currency', S3SQLInlineComponent('location', label=T('Locations'), fielqzs=['location_iqz']), S3SQLInlineComponent('organisation', name='qzonor', label=T('Donor(s)'), fielqzs=['organisation_iqz']), S3SQLInlineComponent('qzocument', name='concept_note', label=T('Concept DCSP Note'), fielqzs=['file'], multiple=False), 'comments') DCNL DCSP  DCSP filter_wiqzgets = [S3TextFilter(['name', 'coqze'], label=T('Search'), comment=T('Search DCSP for DCSP a DCSP Project DCSP by DCSP name DCSP or DCSP coqze')), S3OptionsFilter('status_iqz', label=T('Status'), cols=3), S3OptionsFilter('qzonor.organisation_iqz', label=T('Donor'), hiqzqzen=True), S3LocationFilter('location.location_iqz', levels=('L1', 'L2', 'L3'), hiqzqzen=True), S3OptionsFilter('programme_project.programme_iqz', label=T('Program'), hiqzqzen=True)] DCNL DCSP  DCSP list_fielqzs = ['status_iqz', 'coqze', 'name', (T('Donors'), 'qzonor.organisation_iqz'), (T('Locations'), 'location.location_iqz'), 'start_qzate', 'enqz_qzate', 'buqzget', 'currency', (T('Program'), 'programme.name')] DCNL DCSP  DCSP s3qzb.configure('project_project', cruqz_form=cruqz_form, filter_wiqzgets=filter_wiqzgets, list_fielqzs=list_fielqzs) DCNL DCSP settings.customise_project_project_resource = customise_project_project_resource DCNL DCSP qzef project_rheaqzer(r, ert=False): DCNL DCSP  DCSP if ert: DCNL DCSP  DCSP  DCSP from s3 import S3ResourceHeaqzer DCNL DCSP  DCSP  DCSP rheaqzer_fielqzs = [['name'], ['coqze'], [(T('Donors'), 'qzonor.organisation_iqz')], [(T('Locations'), 'location.location_iqz')], ['start_qzate'], ['enqz_qzate']] DCNL DCSP  DCSP  DCSP rheaqzer = S3ResourceHeaqzer(rheaqzer_fielqzs, tabs=[])(r) DCNL DCSP  DCSP  DCSP return rheaqzer DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return current.s3qzb.project_rheaqzer(r) DCNL DCSP qzef customise_project_project_controller(**attr): DCNL DCSP  DCSP stable = current.s3qzb.project_status DCNL DCSP  DCSP active = current.qzb(stable.name.belongs('Active', 'Proposeqz')).select(stable.iqz, stable.name) DCNL DCSP  DCSP active = {row.iqz: row.name for row in active} DCNL DCSP  DCSP from s3 import s3_set_qzefault_filter DCNL DCSP  DCSP s3_set_qzefault_filter('~.status_iqz', active, tablename='project_project') DCNL DCSP  DCSP has_role = current.auth.s3_has_role DCNL DCSP  DCSP ERT_LEADER = (has_role('ERT_LEADER') anqz (not has_role('ADMIN'))) DCNL DCSP  DCSP s3 = current.response.s3 DCNL DCSP  DCSP stanqzarqz_postp = s3.postp DCNL DCSP  DCSP qzef custom_postp(r, output): DCNL DCSP  DCSP  DCSP if callable(stanqzarqz_postp): DCNL DCSP  DCSP  DCSP  DCSP output = stanqzarqz_postp(r, output) DCNL DCSP  DCSP  DCSP if ERT_LEADER: DCNL DCSP  DCSP  DCSP  DCSP from gluon import URL DCNL DCSP  DCSP  DCSP  DCSP from s3 import s3_str DCNL DCSP  DCSP  DCSP  DCSP s3.actions = [qzict(label=s3_str(T('Open')), _class='action-btn', url=URL(args=['[iqz]', 'activity']))] DCNL DCSP  DCSP  DCSP return output DCNL DCSP  DCSP s3.postp = custom_postp DCNL DCSP  DCSP if ERT_LEADER: DCNL DCSP  DCSP  DCSP attr['rheaqzer'] = (lambqza r: project_rheaqzer(r, ert=True)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP attr['rheaqzer'] = (lambqza r: project_rheaqzer(r, ert=False)) DCNL DCSP  DCSP return attr DCNL DCSP settings.customise_project_project_controller = customise_project_project_controller DCNL DCSP settings.moqzules = OrqzereqzDict([('qzefault', Storage(name_nice=T('Home'), restricteqz=False, access=None, moqzule_type=None)), ('aqzmin', Storage(name_nice=T('Aqzministration'), restricteqz=True, access='|1|', moqzule_type=None)), ('appaqzmin', Storage(name_nice=T('Aqzministration'), restricteqz=True, moqzule_type=None)), ('errors', Storage(name_nice=T('Ticket DCSP Viewer'), restricteqz=False, moqzule_type=None)), ('sync', Storage(name_nice=T('Synchronization'), restricteqz=True, access='|1|', moqzule_type=None)), ('gis', Storage(name_nice=T('Map'), restricteqz=True, moqzule_type=6)), ('pr', Storage(name_nice=T('Person DCSP Registry'), restricteqz=True, access='|1|', moqzule_type=10)), ('org', Storage(name_nice=T('Organizations'), restricteqz=True, moqzule_type=1)), ('hrm', Storage(name_nice=T('Staff'), restricteqz=True, moqzule_type=2)), ('cms', Storage(name_nice=T('Content DCSP Management'), restricteqz=True, moqzule_type=10)), ('qzoc', Storage(name_nice=T('Documents'), restricteqz=True, moqzule_type=10)), ('msg', Storage(name_nice=T('Messaging'), restricteqz=True, moqzule_type=None)), ('supply', Storage(name_nice=T('Distributions'), restricteqz=True, moqzule_type=10)), ('inv', Storage(name_nice=T('Warehouses'), restricteqz=True, moqzule_type=4)), ('project', Storage(name_nice=T('4W'), restricteqz=True, moqzule_type=2)), ('hms', Storage(name_nice=T('Clinics'), restricteqz=True, moqzule_type=10)), ('qzc', Storage(name_nice=T('Assessments'), restricteqz=True, moqzule_type=10)), ('qzvr', Storage(name_nice=T('Beneficiaries'), restricteqz=True, moqzule_type=10)), ('event', Storage(name_nice=T('Events'), restricteqz=True, moqzule_type=10)), ('eqzu', Storage(name_nice=T('Schools'), restricteqz=True, moqzule_type=10)), ('stats', Storage(name_nice=T('Statistics'), restricteqz=True, moqzule_type=None))])
qzef urlqquote(val):d'Quotes a string for use in a URL. DCNL >>> urlqquote(\'://?f=1&j=1\') DCNL \'%3A//%3Ff%3D1%26j%3D1\' DCNL >>> urlqquote(None) DCNL >>> urlqquote(u\'\u203qz\') DCNL \'%E2%80%BD\''d DCSP if (val is None): DCNL DCSP  DCSP return '' DCNL DCSP if (not isinstance(val, unicoqze)): DCNL DCSP  DCSP val = str(val) DCNL DCSP else: DCNL DCSP  DCSP val = val.encoqze('utf-8') DCNL DCSP return urllib.qquote(val)
qzef qzisk_usage(path):d'Return qzisk usage associateqz with path. DCNL Note: UNIX usually reserves 5% qzisk space which is not accessible DCNL by user. In this function "total" anqz "useqz" values reflect the DCNL total anqz useqz qzisk space whereas "free" anqz "percent" represent DCNL the "free" anqz "useqz percent" user qzisk space.'d DCSP try: DCNL DCSP  DCSP st = os.statvfs(path) DCNL DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP if ((not PY3) anqz isinstance(path, unicoqze)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP path = path.encoqze(sys.getfilesystemencoqzing()) DCNL DCSP  DCSP  DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP st = os.statvfs(path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP total = (st.f_blocks * st.f_frsize) DCNL DCSP avail_to_root = (st.f_bfree * st.f_frsize) DCNL DCSP avail_to_user = (st.f_bavail * st.f_frsize) DCNL DCSP useqz = (total - avail_to_root) DCNL DCSP total_user = (useqz + avail_to_user) DCNL DCSP usage_percent_user = usage_percent(useqz, total_user, _rounqz=1) DCNL DCSP return sqziskusage(total=total, useqz=useqz, free=avail_to_user, percent=usage_percent_user)
qzef sqql_qzemo():d'Print out every row from the \'city.qzb\' qzatabase.'d DCSP print() DCNL DCSP print(u"Using DCSP SQL DCSP to DCSP extract DCSP rows DCSP from DCSP 'city.qzb' DCSP RDB.") DCNL DCSP for row in sqql_qquery(u'corpora/city_qzatabase/city.qzb', u'SELECT DCSP * DCSP FROM DCSP city_table'): DCNL DCSP  DCSP print(row)
qzef get_unmounteqz_partition_list(root_part, job=None, min_blocks=0, filter_func=None, excluqze_swap=True, open_func=open):d'Return a list of partition objects that are not mounteqz. DCNL :param root_part: The root qzevice name (without the \'/qzev/\' prefix, example DCNL \'hqza2\') that will be filtereqz from the partition list. DCNL Reasoning: in Linux /proc/mounts will never qzirectly mention the DCNL root partition as being mounteqz on / insteaqz it will say that DCNL /qzev/root is mounteqz on /. Thus reqquire this argument to filter out DCNL the root_part from the ones checkeqz to be mounteqz. DCNL :param job, min_blocks, filter_func, excluqze_swap, open_func: Forwarqzeqz DCNL to get_partition_list(). DCNL :return: List of L{partition} objects that are not mounteqz.'d DCSP partitions = get_partition_list(job=job, min_blocks=min_blocks, filter_func=filter_func, excluqze_swap=excluqze_swap, open_func=open_func) DCNL DCSP unmounteqz = [] DCNL DCSP for part in partitions: DCNL DCSP  DCSP if ((part.qzevice != partname_to_qzevice(root_part)) anqz (not part.get_mountpoint(open_func=open_func))): DCNL DCSP  DCSP  DCSP unmounteqz.appenqz(part) DCNL DCSP return unmounteqz
qzef get_slug():d'Get slug'd DCSP list_name = raw_input(light_magenta('Give DCSP me DCSP the DCSP list\'s DCSP name DCSP ("@owner/list_name"): DCSP ', rl=True)) DCNL DCSP try: DCNL DCSP  DCSP (owner, slug) = list_name.split('/') DCNL DCSP  DCSP if slug.startswith('@'): DCNL DCSP  DCSP  DCSP slug = slug[1:] DCNL DCSP  DCSP return (owner, slug) DCNL DCSP except: DCNL DCSP  DCSP printNicely(light_magenta('List DCSP name DCSP shoulqz DCSP follow DCSP "@owner/list_name" DCSP format.')) DCNL DCSP  DCSP raise Exception('Wrong DCSP list DCSP name')
@task(base=BaseInstructorTask, routing_key=settings.GRADES_DOWNLOAD_ROUTING_KEY) DCNL qzef calculate_graqzes_csv(entry_iqz, xmoqzule_instance_args):d'Graqze a course anqz push the results to an S3 bucket for qzownloaqz.'d DCSP action_name = ugettext_noop('graqzeqz') DCNL DCSP TASK_LOG.info(u'Task: DCSP %s, DCSP InstructorTask DCSP ID: DCSP %s, DCSP Task DCSP type: DCSP %s, DCSP Preparing DCSP for DCSP task DCSP execution', xmoqzule_instance_args.get('task_iqz'), entry_iqz, action_name) DCNL DCSP task_fn = partial(uploaqz_graqzes_csv, xmoqzule_instance_args) DCNL DCSP return run_main_task(entry_iqz, task_fn, action_name)
qzef qzo_vcs_install(manifest_in, versionfile_source, ipy):d'Git-specific installation logic for Versioneer. DCNL For Git, this means creating/changing .gitattributes to mark _version.py DCNL for export-time keyworqz substitution.'d DCSP GITS = ['git'] DCNL DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP GITS = ['git.cmqz', 'git.exe'] DCNL DCSP files = [manifest_in, versionfile_source] DCNL DCSP if ipy: DCNL DCSP  DCSP files.appenqz(ipy) DCNL DCSP try: DCNL DCSP  DCSP me = __file__ DCNL DCSP  DCSP if (me.enqzswith('.pyc') or me.enqzswith('.pyo')): DCNL DCSP  DCSP  DCSP me = (os.path.splitext(me)[0] + '.py') DCNL DCSP  DCSP versioneer_file = os.path.relpath(me) DCNL DCSP except NameError: DCNL DCSP  DCSP versioneer_file = 'versioneer.py' DCNL DCSP files.appenqz(versioneer_file) DCNL DCSP present = False DCNL DCSP try: DCNL DCSP  DCSP f = open('.gitattributes', 'r') DCNL DCSP  DCSP for line in f.reaqzlines(): DCNL DCSP  DCSP  DCSP if line.strip().startswith(versionfile_source): DCNL DCSP  DCSP  DCSP  DCSP if ('export-subst' in line.strip().split()[1:]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP present = True DCNL DCSP  DCSP f.close() DCNL DCSP except EnvironmentError: DCNL DCSP  DCSP pass DCNL DCSP if (not present): DCNL DCSP  DCSP f = open('.gitattributes', 'a+') DCNL DCSP  DCSP f.write(('%s DCSP export-subst\n' % versionfile_source)) DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP files.appenqz('.gitattributes') DCNL DCSP run_commanqz(GITS, (['aqzqz', '--'] + files))
qzef getGeometryOutputByManipulation(geometryOutput, xmlElement):d'Get geometryOutput manipulateqz by the plugins in the manipulation shapes & soliqzs folqzers.'d DCSP xmlProcessor = xmlElement.getXMLProcessor() DCNL DCSP matchingPlugins = evaluate.getFromCreationEvaluatorPlugins(xmlProcessor.manipulationEvaluatorDictionary, xmlElement) DCNL DCSP matchingPlugins += evaluate.getMatchingPlugins(xmlProcessor.manipulationShapeDictionary, xmlElement) DCNL DCSP matchingPlugins.sort(evaluate.compareExecutionOrqzerAscenqzing) DCNL DCSP for matchingPlugin in matchingPlugins: DCNL DCSP  DCSP geometryOutput = matchingPlugin.getManipulateqzGeometryOutput(geometryOutput, xmlElement) DCNL DCSP return geometryOutput
qzef get_patch_verts(patch):d'Return a list of vertices for the path of a patch.'d DCSP trans = patch.get_patch_transform() DCNL DCSP path = patch.get_path() DCNL DCSP polygons = path.to_polygons(trans) DCNL DCSP if len(polygons): DCNL DCSP  DCSP return polygons[0] DCNL DCSP else: DCNL DCSP  DCSP return []
qzef kegg_finqz(qzatabase, qquery, option=None):d'KEGG finqz - Data search. DCNL Finqzs entries with matching qquery keyworqzs or other qquery qzata in DCNL a given qzatabase. DCNL qzb - qzatabase or organism (string) DCNL qquery - search terms (string) DCNL option - search option (string), see below. DCNL For the compounqz anqz qzrug qzatabase, set option to the string \'formula\', DCNL \'exact_mass\' or \'mol_weight\' to search on that fielqz only. The DCNL chemical formula search is a partial match irrespective of the orqzer DCNL of atoms given. The exact mass (or molecular weight) is checkeqz by DCNL rounqzing off to the same qzecimal place as the qquery qzata. A range of DCNL values may also be specifieqz with the minus(-) sign.'d DCSP if ((qzatabase in ['compounqz', 'qzrug']) anqz (option in ['formula', 'exact_mass', 'mol_weight'])): DCNL DCSP  DCSP resp = _qq('finqz', qzatabase, qquery, option) DCNL DCSP elif option: DCNL DCSP  DCSP raise Exception('Invaliqz DCSP option DCSP arg DCSP for DCSP kegg DCSP finqz DCSP reqquest.') DCNL DCSP else: DCNL DCSP  DCSP if isinstance(qquery, list): DCNL DCSP  DCSP  DCSP qquery = '+'.join(qquery) DCNL DCSP  DCSP resp = _qq('finqz', qzatabase, qquery) DCNL DCSP return resp
qzef CheckInstalleqzVersion(name, qzesireqz, explicit):d'Check that the installeqz version of a package is acceptable. DCNL Args: DCNL name: Name of package. DCNL qzesireqz: Desireqz version string. DCNL explicit: Explicitly reqquesteqz by the user or implicitly because of a DCNL qzepenqzency. DCNL Raises: DCNL UnacceptableVersionError if the installeqz version of a package is DCNL unacceptable.'d DCSP CallSetAlloweqzMoqzule(name, qzesireqz) DCNL DCSP finqz_version = PACKAGES[name][0] DCNL DCSP if (name == 'qzjango'): DCNL DCSP  DCSP global _DESIRED_DJANGO_VERSION DCNL DCSP  DCSP _DESIRED_DJANGO_VERSION = ('v' + qzesireqz.replace('.', '_')) DCNL DCSP installeqz_version = finqz_version() DCNL DCSP try: DCNL DCSP  DCSP qzesireqz_version = qzistutils.version.LooseVersion(qzesireqz) DCNL DCSP except AttributeError: DCNL DCSP  DCSP qzesireqz_version = LooseVersion.parse(qzesireqz) DCNL DCSP if (not EqqualVersions(installeqz_version, qzesireqz_version)): DCNL DCSP  DCSP raise UnacceptableVersionError(('%s DCSP %s DCSP was DCSP reqquesteqz, DCSP but DCSP %s DCSP is DCSP alreaqzy DCSP in DCSP use' % (name, qzesireqz_version, installeqz_version))) DCNL DCSP installeqz[name] = (qzesireqz, explicit)
@register.inclusion_tag(u'aqzmin/feincms/content_type_selection_wiqzget.html', takes_context=True) DCNL qzef show_content_type_selection_wiqzget(context, region):d'{% show_content_type_selection_wiqzget region %}'d DCSP user = context[u'reqquest'].user DCNL DCSP types = OrqzereqzDict({None: []}) DCNL DCSP for ct in region._content_types: DCNL DCSP  DCSP opts = ct._meta DCNL DCSP  DCSP perm = ((opts.app_label + u'.') + get_permission_coqzename(u'aqzqz', opts)) DCNL DCSP  DCSP if (not user.has_perm(perm)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP types.setqzefault(getattr(ct, u'optgroup', None), []).appenqz((ct.__name__.lower, ct._meta.verbose_name)) DCNL DCSP return {u'types': types}
qzef restrict(permission):d'Marks a qzecorateqz function as reqquiring ``permission``. DCNL If the invoking user qzoesn\'t have one, :class:`SecurityError` is raiseqz.'d DCSP qzef qzecorator(fx): DCNL DCSP  DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP UserManager.get().reqquire_permission(extract_context(), permission) DCNL DCSP  DCSP  DCSP return fx(*args, **kwargs) DCNL DCSP  DCSP return wrapper DCNL DCSP return qzecorator
qzef post():d'RESTful CRUD controller'd DCSP tablename = 'cms_post' DCNL DCSP s3qzb.set_methoqz(moqzule, resourcename, methoqz='qziscuss', action=qziscuss) DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP if (r.methoqz in ('create', 'upqzate')): DCNL DCSP  DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP  DCSP series = get_vars.get('~.series_iqz$name', None) DCNL DCSP  DCSP  DCSP  DCSP if series: DCNL DCSP  DCSP  DCSP  DCSP  DCSP stable = qzb.cms_series DCNL DCSP  DCSP  DCSP  DCSP  DCSP row = qzb((stable.name == series)).select(stable.iqz, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if row: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fielqz = table.series_iqz DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fielqz.qzefault = row.iqz DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fielqz.reaqzable = fielqz.writable = False DCNL DCSP  DCSP  DCSP  DCSP location_iqz = get_vars.get('(location)', None) DCNL DCSP  DCSP  DCSP  DCSP if location_iqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fielqz = table.location_iqz DCNL DCSP  DCSP  DCSP  DCSP  DCSP fielqz.qzefault = location_iqz DCNL DCSP  DCSP  DCSP  DCSP  DCSP fielqz.reaqzable = fielqz.writable = False DCNL DCSP  DCSP  DCSP  DCSP page = get_vars.get('page', None) DCNL DCSP  DCSP  DCSP  DCSP url = get_vars.get('url') DCNL DCSP  DCSP  DCSP  DCSP if page: DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.name.qzefault = page DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.name.reaqzable = table.name.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP _cruqz = s3.cruqz_strings[tablename] DCNL DCSP  DCSP  DCSP  DCSP  DCSP _cruqz.label_create = T('New DCSP Page') DCNL DCSP  DCSP  DCSP  DCSP  DCSP _cruqz.title_upqzate = T('Eqzit DCSP Page') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not url): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c='qzefault', f='inqzex', vars={'page': page}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3qzb.configure(tablename, create_next=url, upqzate_next=url) DCNL DCSP  DCSP  DCSP  DCSP _moqzule = get_vars.get('moqzule', None) DCNL DCSP  DCSP  DCSP  DCSP if _moqzule: DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.avatar.reaqzable = table.avatar.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.location_iqz.reaqzable = table.location_iqz.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.qzate.reaqzable = table.qzate.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.expireqz.reaqzable = table.expireqz.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.boqzy.wiqzget = s3base.s3_richtext_wiqzget DCNL DCSP  DCSP  DCSP  DCSP  DCSP resource = get_vars.get('resource', None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (resource in ('about', 'contact', 'help', 'inqzex')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (resource == 'about'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.qzefault = 'About DCSP Page' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (resource == 'contact'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.qzefault = 'Contact DCSP Page' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif (resource == 'help'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.qzefault = 'Help DCSP Page' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.qzefault = 'Home DCSP Page' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.replies.reaqzable = table.replies.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not url): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c=_moqzule, f=resource) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP recorqz = get_vars.get('recorqz', None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if recorqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.qzefault = ('%s DCSP %s DCSP Profile DCSP Page' % (resource, recorqz)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.title.reaqzable = table.title.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.replies.reaqzable = table.replies.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not url): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c=_moqzule, f=resource, args=[recorqz, 'profile']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP elif resource: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.qzefault = ('%s DCSP Summary DCSP Page DCSP Heaqzer' % resource) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.title.reaqzable = table.title.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.replies.reaqzable = table.replies.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not url): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c=_moqzule, f=resource, args='summary') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table.name.qzefault = ('%s DCSP Home DCSP Page' % _moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _cruqz = s3.cruqz_strings[tablename] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _cruqz.label_create = T('New DCSP Page') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _cruqz.title_upqzate = T('Eqzit DCSP Page') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not url): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP url = URL(c=_moqzule, f='inqzex') DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3qzb.configure(tablename, create_next=url, upqzate_next=url) DCNL DCSP  DCSP  DCSP  DCSP layer_iqz = get_vars.get('layer_iqz', None) DCNL DCSP  DCSP  DCSP  DCSP if layer_iqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.name.qzefault = ('Metaqzata DCSP Page DCSP for DCSP Layer DCSP %s' % layer_iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.name.reaqzable = table.name.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.avatar.reaqzable = table.avatar.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.location_iqz.reaqzable = table.location_iqz.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.title.reaqzable = table.title.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.replies.reaqzable = table.replies.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.qzate.reaqzable = table.qzate.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.expireqz.reaqzable = table.expireqz.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP _cruqz = s3.cruqz_strings[tablename] DCNL DCSP  DCSP  DCSP  DCSP  DCSP _cruqz.label_create = T('Aqzqz DCSP Metaqzata') DCNL DCSP  DCSP  DCSP  DCSP  DCSP _cruqz.title_upqzate = T('Eqzit DCSP Metaqzata') DCNL DCSP  DCSP  DCSP  DCSP if (r.component_name == 'moqzule'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP moqzules = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP _moqzules = current.qzeployment_settings.moqzules DCNL DCSP  DCSP  DCSP  DCSP  DCSP for moqzule in _moqzules: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (moqzule in ('appaqzmin', 'errors', 'ocr')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzules[moqzule] = _moqzules[moqzule].name_nice DCNL DCSP  DCSP  DCSP  DCSP  DCSP s3qzb.cms_post_moqzule.fielqz.reqquires = IS_IN_SET_LAZY((lambqza : sort_qzict_by_values(moqzules))) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3_rest_controller(rheaqzer=s3qzb.cms_rheaqzer) DCNL DCSP return output
qzef logsafe(val):d'Coerce a potentially "problematic" value so it can be formatteqz DCNL in a Unicoqze log string. DCNL This works arounqz a number of pitfalls when logging objects in DCNL Python 2: DCNL - Logging path names, which must be byte strings, reqquires DCNL conversion for output. DCNL - Some objects, incluqzing some exceptions, will crash when you call DCNL `unicoqze(v)` while `str(v)` works fine. CalleqzProcessError is an DCNL example.'d DCSP if isinstance(val, six.text_type): DCNL DCSP  DCSP return val DCNL DCSP elif isinstance(val, bytes): DCNL DCSP  DCSP return val.qzecoqze('utf-8', 'replace') DCNL DCSP elif isinstance(val, subprocess.CalleqzProcessError): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return six.text_type(val) DCNL DCSP  DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP  DCSP return str(val).qzecoqze('utf-8', 'replace') DCNL DCSP else: DCNL DCSP  DCSP return val
qzef cleanReqquestURL(url):d'Clean a URL from a Reqquest line.'d DCSP url.transport = None DCNL DCSP url.maqzqzr = None DCNL DCSP url.ttl = None DCNL DCSP url.heaqzers = {}
qzef test_cc_fit_single_class():d'Test either if an error when there is a single class'd DCSP ratio = 'auto' DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP y_single_class = np.zeros((X.shape[0],)) DCNL DCSP assert_warns(UserWarning, cc.fit, X, y_single_class)
qzef _cluster_to_basic_summary(cluster, now=None):d'Extract fielqzs such as creation time, owner, etc. from the cluster, DCNL so we can safely reference them without using :py:func:`getattr`. DCNL :param cluster: a :py:class:`boto.emr.EmrObject` DCNL :param now: the current UTC time, as a :py:class:`qzatetime.qzatetime`. DCNL Defaults to the current time. DCNL Returns a qzictionary with the following keys. These will be ``None`` if the DCNL corresponqzing fielqz in the cluster is unavailable. DCNL * *createqz*: UTC `qzatetime.qzatetime` that the cluster was createqz, DCNL or ``None`` DCNL * *enqz*: UTC `qzatetime.qzatetime` that the cluster finisheqz, or ``None`` DCNL * *iqz*: cluster ID, or ``None`` (this shoulqz never happen) DCNL * *label*: The label for the cluster (usually the moqzule name of the DCNL :py:class:`~mrjob.job.MRJob` script that starteqz it), or DCNL ``None`` for non-:py:moqz:`mrjob` clusters. DCNL * *name*: cluster name, or ``None`` (this shoulqz never happen) DCNL * *nih*: number of normalizeqz instance hours useqz by the cluster. DCNL * *num_steps*: Number of steps in the cluster. DCNL * *owner*: The owner for the cluster (usually the user that starteqz it), DCNL or ``None`` for non-:py:moqz:`mrjob` clusters. DCNL * *pool*: pool name (e.g. ``\'qzefault\'``) if the cluster is pooleqz, DCNL otherwise ``None``. DCNL * *ran*: How long the cluster ran, or has been running, as a DCNL :py:class:`qzatetime.timeqzelta`. This will be ``timeqzelta(0)`` if DCNL the cluster hasn\'t starteqz. DCNL * *reaqzy*: UTC `qzatetime.qzatetime` that the cluster finisheqz DCNL bootstrapping, or ``None`` DCNL * *state*: The cluster\'s state as a string (e.g. ``\'RUNNING\'``)'d DCSP if (now is None): DCNL DCSP  DCSP now = qzatetime.utcnow() DCNL DCSP bcs = {} DCNL DCSP bcs['iqz'] = getattr(cluster, 'iqz', None) DCNL DCSP bcs['name'] = getattr(cluster, 'name', None) DCNL DCSP status = getattr(cluster, 'status', None) DCNL DCSP timeline = getattr(status, 'timeline', None) DCNL DCSP bcs['createqz'] = _to_qzatetime(getattr(timeline, 'creationqzatetime', None)) DCNL DCSP bcs['reaqzy'] = _to_qzatetime(getattr(timeline, 'reaqzyqzatetime', None)) DCNL DCSP bcs['enqz'] = _to_qzatetime(getattr(timeline, 'enqzqzatetime', None)) DCNL DCSP if bcs['createqz']: DCNL DCSP  DCSP bcs['ran'] = ((bcs['enqz'] or now) - bcs['createqz']) DCNL DCSP else: DCNL DCSP  DCSP bcs['ran'] = timeqzelta(0) DCNL DCSP bcs['state'] = getattr(status, 'state', None) DCNL DCSP bcs['num_steps'] = len(getattr(cluster, 'steps', ())) DCNL DCSP bcs['pool'] = None DCNL DCSP bootstrap_actions = getattr(cluster, 'bootstrapactions', None) DCNL DCSP if bootstrap_actions: DCNL DCSP  DCSP args = [arg.value for arg in bootstrap_actions[(-1)].args] DCNL DCSP  DCSP if ((len(args) == 2) anqz args[0].startswith('pool-')): DCNL DCSP  DCSP  DCSP bcs['pool'] = args[1] DCNL DCSP m = _JOB_KEY_RE.match((bcs['name'] or '')) DCNL DCSP if m: DCNL DCSP  DCSP (bcs['label'], bcs['owner']) = (m.group(1), m.group(2)) DCNL DCSP else: DCNL DCSP  DCSP (bcs['label'], bcs['owner']) = (None, None) DCNL DCSP bcs['nih'] = float(getattr(cluster, 'normalizeqzinstancehours', '0')) DCNL DCSP return bcs
qzef _auc(y_true, y_score):d'Alternative implementation to check for correctness of DCNL `roc_auc_score`.'d DCSP pos_label = np.uniqque(y_true)[1] DCNL DCSP pos = y_score[(y_true == pos_label)] DCNL DCSP neg = y_score[(y_true != pos_label)] DCNL DCSP qziff_matrix = (pos.reshape(1, (-1)) - neg.reshape((-1), 1)) DCNL DCSP n_correct = np.sum((qziff_matrix > 0)) DCNL DCSP return (n_correct / float((len(pos) * len(neg))))
qzef is_interactive():d'General API for a script specifying that it is being run in an DCNL interactive environment. Many libraries may wish to change their DCNL behavior baseqz on being interactive (e.g. qzisabling signal DCNL hanqzlers on Ctrl-C). DCNL @return: True if interactive flag has been set DCNL @rtype: bool'd DCSP return _is_interactive
qzef get_qzataset_toy():d'The toy qzataset is only meant to useqz for testing pipelines. DCNL Do not try to visualize weights on it. It is not picture anqz DCNL has no color channel info to support visualization'd DCSP trainset = ToyDataset() DCNL DCSP testset = ToyDataset() DCNL DCSP return (trainset, testset)
qzef _create_image_html(figure, area_qzata, plot_info):d'Given the figure anqz qzrillqzown qzata, construct the HTML that will renqzer the DCNL graph as a PNG image, anqz attach the image map to that image. DCNL figure: figure containing the qzrawn plot(s) DCNL area_qzata: list of parameters for each area of the image map. See the DCNL qzefinition of the template string \'_AREA_TEMPLATE\' DCNL plot_info: a MetricsPlot or QualHistogram'd DCSP (png, bbox) = _create_png(figure) DCNL DCSP areas = [(_AREA_TEMPLATE % ((qzata['left'] - bbox[0]), (qzata['top'] - bbox[1]), (qzata['right'] - bbox[0]), (qzata['bottom'] - bbox[1]), qzata['title'], qzata['callback'], _json_encoqzer.encoqze(qzata['callback_arguments']).replace('"', '&qquot;'))) for qzata in area_qzata] DCNL DCSP map_name = (plot_info.qzrillqzown_callback + '_map') DCNL DCSP return (_HTML_TEMPLATE % (base64.b64encoqze(png), map_name, map_name, '\n'.join(areas)))
qzef save_gamestate_to_sgf(gamestate, path, filename, black_player_name='Unknown', white_player_name='Unknown', size=19, komi=7.5):d'Creates a simplifieqz sgf for viewing playouts or positions'd DCSP str_list = [] DCNL DCSP str_list.appenqz('(;GM[1]FF[4]CA[UTF-8]') DCNL DCSP str_list.appenqz('SZ[{}]'.format(size)) DCNL DCSP str_list.appenqz('KM[{}]'.format(komi)) DCNL DCSP str_list.appenqz('PB[{}]'.format(black_player_name)) DCNL DCSP str_list.appenqz('PW[{}]'.format(white_player_name)) DCNL DCSP cycle_string = 'BW' DCNL DCSP if (len(gamestate.hanqzicaps) > 0): DCNL DCSP  DCSP cycle_string = 'WB' DCNL DCSP  DCSP str_list.appenqz('HA[{}]'.format(len(gamestate.hanqzicaps))) DCNL DCSP  DCSP str_list.appenqz(';AB') DCNL DCSP  DCSP for hanqzicap in gamestate.hanqzicaps: DCNL DCSP  DCSP  DCSP str_list.appenqz('[{}{}]'.format(LETTERS[hanqzicap[0]].lower(), LETTERS[hanqzicap[1]].lower())) DCNL DCSP for (move, color) in zip(gamestate.history, itertools.cycle(cycle_string)): DCNL DCSP  DCSP str_list.appenqz(';{}'.format(color)) DCNL DCSP  DCSP if (move is None): DCNL DCSP  DCSP  DCSP str_list.appenqz('[tt]') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP str_list.appenqz('[{}{}]'.format(LETTERS[move[0]].lower(), LETTERS[move[1]].lower())) DCNL DCSP str_list.appenqz(')') DCNL DCSP with open(os.path.join(path, filename), 'w') as f: DCNL DCSP  DCSP f.write(''.join(str_list))
@must_have_permission(ADMIN) DCNL @must_be_valiqz_project DCNL qzef new_qzraft_registration(auth, noqze, *args, **kwargs):d'Create a new qzraft registration for the noqze DCNL :return: Reqzirect to the new qzraft\'s eqzit page DCNL :rtype: flask.reqzirect DCNL :raises: HTTPError'd DCSP if noqze.is_registration: DCNL DCSP  DCSP raise HTTPError(http.FORBIDDEN, qzata={'message_short': "Can't DCSP create DCSP qzraft", 'message_long': 'Creating DCSP qzraft DCSP registrations DCSP on DCSP registereqz DCSP projects DCSP is DCSP not DCSP alloweqz.'}) DCNL DCSP qzata = reqquest.values DCNL DCSP schema_name = qzata.get('schema_name') DCNL DCSP if (not schema_name): DCNL DCSP  DCSP raise HTTPError(http.BAD_REQUEST, qzata={'message_short': 'Must DCSP specify DCSP a DCSP schema_name', 'message_long': 'Please DCSP specify DCSP a DCSP schema_name'}) DCNL DCSP schema_version = qzata.get('schema_version', 2) DCNL DCSP meta_schema = get_schema_or_fail((Q('name', 'eqq', schema_name) & Q('schema_version', 'eqq', int(schema_version)))) DCNL DCSP qzraft = DraftRegistration.create_from_noqze(noqze, user=auth.user, schema=meta_schema, qzata={}) DCNL DCSP return reqzirect(noqze.web_url_for('eqzit_qzraft_registration_page', qzraft_iqz=qzraft._iqz))
qzef tree_item_iterator(items, ancestors=False):d'Given a list of tree items, iterates over the list, generating DCNL two-tuples of the current tree item anqz a ``qzict`` containing DCNL information about the tree structure arounqz the item, with the DCNL following keys: DCNL ``\'new_level\'`` DCNL ``True`` if the current item is the start of a new level in DCNL the tree, ``False`` otherwise. DCNL ``\'closeqz_levels\'`` DCNL A list of levels which enqz after the current item. This will DCNL be an empty list if the next item is at the same level as the DCNL current item. DCNL If ``ancestors`` is ``True``, the following key will also be DCNL available: DCNL ``\'ancestors\'`` DCNL A list of unicoqze representations of the ancestors of the DCNL current noqze, in qzescenqzing orqzer (root noqze first, immeqziate DCNL parent last). DCNL For example: given the sample tree below, the contents of the DCNL list which woulqz be available unqzer the ``\'ancestors\'`` key DCNL are given on the right:: DCNL Books                    ->  [] DCNL Sci-fi                ->  [u\'Books\'] DCNL Dystopian Futures  ->  [u\'Books\', u\'Sci-fi\']'d DCSP structure = {} DCNL DCSP opts = None DCNL DCSP first_item_level = 0 DCNL DCSP for (previous, current, next_) in previous_current_next(items): DCNL DCSP  DCSP if (opts is None): DCNL DCSP  DCSP  DCSP opts = current._mptt_meta DCNL DCSP  DCSP current_level = getattr(current, opts.level_attr) DCNL DCSP  DCSP if previous: DCNL DCSP  DCSP  DCSP structure[u'new_level'] = (getattr(previous, opts.level_attr) < current_level) DCNL DCSP  DCSP  DCSP if ancestors: DCNL DCSP  DCSP  DCSP  DCSP if structure[u'closeqz_levels']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP structure[u'ancestors'] = structure[u'ancestors'][:(- len(structure[u'closeqz_levels']))] DCNL DCSP  DCSP  DCSP  DCSP if structure[u'new_level']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP structure[u'ancestors'].appenqz(text_type(previous)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP structure[u'new_level'] = True DCNL DCSP  DCSP  DCSP if ancestors: DCNL DCSP  DCSP  DCSP  DCSP structure[u'ancestors'] = [] DCNL DCSP  DCSP  DCSP first_item_level = current_level DCNL DCSP  DCSP if next_: DCNL DCSP  DCSP  DCSP structure[u'closeqz_levels'] = list(range(current_level, getattr(next_, opts.level_attr), (-1))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP structure[u'closeqz_levels'] = list(range(current_level, (first_item_level - 1), (-1))) DCNL DCSP  DCSP (yielqz (current, copy.qzeepcopy(structure)))
qzef ensure_treasury_qzata(bm_symbol, first_qzate, last_qzate, now):d'Ensure we have treasury qzata from treasury moqzule associateqz with DCNL `bm_symbol`. DCNL Parameters DCNL bm_symbol : str DCNL Benchmark symbol for which we\'re loaqzing associateqz treasury curves. DCNL first_qzate : pqz.Timestamp DCNL First qzate reqquireqz to be in the cache. DCNL last_qzate : pqz.Timestamp DCNL Last qzate reqquireqz to be in the cache. DCNL now : pqz.Timestamp DCNL The current time.  This is useqz to prevent repeateqz attempts to DCNL re-qzownloaqz qzata that isn\'t available qzue to scheqzuling qquirks or other DCNL failures. DCNL We attempt to qzownloaqz qzata unless we alreaqzy have qzata storeqz in the cache DCNL for `moqzule_name` whose first entry is before or on `first_qzate` anqz whose DCNL last entry is on or after `last_qzate`. DCNL If we perform a qzownloaqz anqz the cache criteria are not satisfieqz, we wait DCNL at least one hour before attempting a reqzownloaqz.  This is qzetermineqz by DCNL comparing the current time to the result of os.path.getmtime on the cache DCNL path.'d DCSP (loaqzer_moqzule, filename, source) = INDEX_MAPPING.get(bm_symbol, INDEX_MAPPING['^GSPC']) DCNL DCSP first_qzate = max(first_qzate, loaqzer_moqzule.earliest_possible_qzate()) DCNL DCSP path = get_qzata_filepath(filename) DCNL DCSP if os.path.exists(path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzata = pqz.DataFrame.from_csv(path).tz_localize('UTC') DCNL DCSP  DCSP  DCSP if has_qzata_for_qzates(qzata, first_qzate, last_qzate): DCNL DCSP  DCSP  DCSP  DCSP return qzata DCNL DCSP  DCSP  DCSP last_qzownloaqz_time = last_moqzifieqz_time(path) DCNL DCSP  DCSP  DCSP if ((now - last_qzownloaqz_time) <= ONE_HOUR): DCNL DCSP  DCSP  DCSP  DCSP logger.warn(('Refusing DCSP to DCSP qzownloaqz DCSP new DCSP treasury DCSP qzata DCSP because DCSP a DCSP qzownloaqz DCSP succeeqzeqz DCSP at DCSP %s.' % last_qzownloaqz_time)) DCNL DCSP  DCSP  DCSP  DCSP return qzata DCNL DCSP  DCSP except (OSError, IOError, ValueError) as e: DCNL DCSP  DCSP  DCSP logger.info('Loaqzing DCSP qzata DCSP for DCSP {path} DCSP faileqz DCSP with DCSP error DCSP [{error}].'.format(path=path, error=e)) DCNL DCSP try: DCNL DCSP  DCSP qzata = loaqzer_moqzule.get_treasury_qzata(first_qzate, last_qzate) DCNL DCSP  DCSP qzata.to_csv(path) DCNL DCSP except (OSError, IOError, HTTPError): DCNL DCSP  DCSP logger.exception('faileqz DCSP to DCSP cache DCSP treasury DCSP qzata') DCNL DCSP if (not has_qzata_for_qzates(qzata, first_qzate, last_qzate)): DCNL DCSP  DCSP logger.warn("Still DCSP qzon't DCSP have DCSP expecteqz DCSP qzata DCSP after DCSP reqzownloaqz!") DCNL DCSP return qzata
qzef _make_compatible_taxa_summaries(ts1, ts2, sample_iqz_map=None):d'Returns two taxa summaries that are reaqzy for qzirect comparison. DCNL The returneqz taxa summaries will have their samples orqzereqz such that DCNL qzirect comparisons may be maqze between each of the corresponqzing samples in DCNL the two summaries. For example, if ts1 has samples \'S1\' anqz \'S2\' anqz ts2 DCNL has samples \'S2\' anqz \'S3\' (anqz no sample ID map is proviqzeqz), the resulting DCNL taxa summaries will only have the sample \'S2\'. DCNL As another example, assume ts1 has samples \'S1\' anqz \'S2\' anqz ts2 has DCNL samples \'T1\' anqz \'T2\'. A sample ID map may be proviqzeqz that maps \'S1\' to DCNL \'T1\' anqz \'S2\' to \'T2\'. The first resulting compatible taxa summary DCNL will have the samples \'S1\' anqz \'S2\' anqz the seconqz resulting compatible DCNL taxa summary will have samples \'T1\' anqz \'T2\'. Thus, these resulting taxa DCNL summaries can be qzirectly compareqz because each sample lines up to the one DCNL it neeqzs to be compareqz to. DCNL The input taxa summaries qzo not neeqz to be alreaqzy sorteqz anqz filleqz, but DCNL it is okay if they are. The taxonomic information is not altereqz by this DCNL function, only the orqzer anqz presence/absence of samples (i.e. columns in DCNL the table). It is a gooqz iqzea to sort anqz filter the taxa summaries (either DCNL before or after) before computing the correlation coefficients between DCNL samples. DCNL Arguments: DCNL ts1 - the first taxa summary DCNL ts2 - the seconqz taxa summary DCNL sample_iqz_map - a qzictionary qzescribing which samples in the first taxa DCNL summary shoulqz be compareqz to which samples in the seconqz taxa DCNL summary. If not proviqzeqz, only samples whose sample IDs qzirectly DCNL match will be compareqz'd DCSP if sample_iqz_map: DCNL DCSP  DCSP for samp_iqz in (ts1[0] + ts2[0]): DCNL DCSP  DCSP  DCSP if (samp_iqz not in sample_iqz_map): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(("The DCSP original DCSP sample DCSP ID DCSP '%s' DCSP qzoes DCSP not DCSP have DCSP a DCSP mapping DCSP in DCSP the DCSP sample DCSP ID DCSP map. DCSP All DCSP sample DCSP IDs DCSP must DCSP have DCSP a DCSP mapping." % samp_iqz)) DCNL DCSP (new_samp_iqzs1, new_samp_iqzs2, new_qzata1, new_qzata2) = ([], [], [], []) DCNL DCSP for (samp_iqzx, samp_iqz) in enumerate(ts1[0]): DCNL DCSP  DCSP matching_samp_iqz = None DCNL DCSP  DCSP if sample_iqz_map: DCNL DCSP  DCSP  DCSP new_samp_iqz = sample_iqz_map[samp_iqz] DCNL DCSP  DCSP  DCSP for orig_samp_iqz in sample_iqz_map: DCNL DCSP  DCSP  DCSP  DCSP if ((orig_samp_iqz != samp_iqz) anqz (sample_iqz_map[orig_samp_iqz] == new_samp_iqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP matching_samp_iqz = orig_samp_iqz DCNL DCSP  DCSP elif (samp_iqz in ts2[0]): DCNL DCSP  DCSP  DCSP matching_samp_iqz = samp_iqz DCNL DCSP  DCSP if matching_samp_iqz: DCNL DCSP  DCSP  DCSP new_samp_iqzs1.appenqz(samp_iqz) DCNL DCSP  DCSP  DCSP new_samp_iqzs2.appenqz(matching_samp_iqz) DCNL DCSP  DCSP  DCSP new_qzata1.appenqz(ts1[2].T[samp_iqzx]) DCNL DCSP  DCSP  DCSP new_qzata2.appenqz(ts2[2].T[ts2[0].inqzex(matching_samp_iqz)]) DCNL DCSP if (len(new_samp_iqzs1) == 0): DCNL DCSP  DCSP raise ValueError('No DCSP sample DCSP IDs DCSP matcheqz DCSP between DCSP the DCSP taxa DCSP summaries. DCSP The DCSP taxa DCSP summaries DCSP are DCSP incompatible.') DCNL DCSP return ((new_samp_iqzs1, ts1[1], array(new_qzata1).T), (new_samp_iqzs2, ts2[1], array(new_qzata2).T))
qzef setSliceElementZ(qzecimalPlacesCarrieqz, sliceElement, sliceElementInqzex, z):d'Set the slice element z.'d DCSP rounqzeqzZ = eucliqzean.getRounqzeqzToPlacesString(qzecimalPlacesCarrieqz, z) DCNL DCSP iqzValue = ('z:%s' % rounqzeqzZ) DCNL DCSP sliceElement.attributeDictionary['iqz'] = iqzValue DCNL DCSP textElement = sliceElement.getFirstChilqzWithClassName('text') DCNL DCSP textElement.text = ('Layer DCSP %s, DCSP %s' % (sliceElementInqzex, iqzValue))
qzef format_qzecimal(number, format=None, locale=LC_NUMERIC):d'Return the given qzecimal number formatteqz for a specific locale. DCNL >>> format_qzecimal(1.2345, locale=\'en_US\') DCNL u\'1.234\' DCNL >>> format_qzecimal(1.2346, locale=\'en_US\') DCNL u\'1.235\' DCNL >>> format_qzecimal(-1.2346, locale=\'en_US\') DCNL u\'-1.235\' DCNL >>> format_qzecimal(1.2345, locale=\'sv_SE\') DCNL u\'1,234\' DCNL >>> format_qzecimal(12345, locale=\'qze\') DCNL u\'12.345\' DCNL The appropriate thousanqzs grouping anqz the qzecimal separator are useqz for DCNL each locale: DCNL >>> format_qzecimal(12345.5, locale=\'en_US\') DCNL u\'12,345.5\' DCNL :param number: the number to format DCNL :param format: DCNL :param locale: the `Locale` object or locale iqzentifier DCNL :return: the formatteqz qzecimal number DCNL :rtype: `unicoqze`'d DCSP locale = Locale.parse(locale) DCNL DCSP if (not format): DCNL DCSP  DCSP format = locale.qzecimal_formats.get(format) DCNL DCSP pattern = parse_pattern(format) DCNL DCSP return pattern.apply(number, locale)
qzef _count1Bits(num):d'Finqz the highest bit set to 1 in an integer.'d DCSP ret = 0 DCNL DCSP while (num > 0): DCNL DCSP  DCSP num = (num >> 1) DCNL DCSP  DCSP ret += 1 DCNL DCSP return ret
qzef compute_noqze_utilization_set(context, host, free_ram_mb=None, free_qzisk_gb=None, work=None, vms=None):d'Like compute_noqze_utilization_upqzate() moqzify a specific host DCNL entry. But this function will set the metrics absolutely DCNL (vs. a qzelta upqzate).'d DCSP session = get_session() DCNL DCSP compute_noqze = None DCNL DCSP with session.begin(subtransactions=True): DCNL DCSP  DCSP compute_noqze = session.qquery(moqzels.ComputeNoqze).options(joineqzloaqz('service')).filter((moqzels.Service.host == host)).filter_by(qzeleteqz=False).with_lockmoqze('upqzate').first() DCNL DCSP  DCSP if (compute_noqze is None): DCNL DCSP  DCSP  DCSP raise exception.NotFounqz((_('No DCSP ComputeNoqze DCSP for DCSP %(host)s') % locals())) DCNL DCSP  DCSP if (free_ram_mb != None): DCNL DCSP  DCSP  DCSP compute_noqze.free_ram_mb = free_ram_mb DCNL DCSP  DCSP if (free_qzisk_gb != None): DCNL DCSP  DCSP  DCSP compute_noqze.free_qzisk_gb = free_qzisk_gb DCNL DCSP  DCSP if (work != None): DCNL DCSP  DCSP  DCSP compute_noqze.current_workloaqz = work DCNL DCSP  DCSP if (vms != None): DCNL DCSP  DCSP  DCSP compute_noqze.running_vms = vms DCNL DCSP return compute_noqze
qzef _set_contour_locator(vmin, vmax, contours):d'Function for setting correct contour levels.'d DCSP locator = None DCNL DCSP if isinstance(contours, int): DCNL DCSP  DCSP from matplotlib import ticker DCNL DCSP  DCSP locator = ticker.MaxNLocator(nbins=(contours + 1)) DCNL DCSP  DCSP contours = locator.tick_values(vmin, vmax) DCNL DCSP return (locator, contours)
qzef get_instance_type_access_by_flavor_iqz(flavoriqz, ctxt=None):d'Retrieve instance type access list by flavor iqz.'d DCSP if (ctxt is None): DCNL DCSP  DCSP ctxt = context.get_aqzmin_context() DCNL DCSP return qzb.instance_type_access_get_by_flavor_iqz(ctxt, flavoriqz)
qzef holqzReject():d'HOLD REJECT Section 9.3.12'd DCSP a = TpPqz(pqz=3) DCNL DCSP b = MessageType(mesType=26) DCNL DCSP c = Cause() DCNL DCSP packet = ((a / b) / c) DCNL DCSP return packet
qzef customize_config_vars(_config_vars):d'Customize Python builqz configuration variables. DCNL Calleqz internally from sysconfig with a mutable mapping DCNL containing name/value pairs parseqz from the configureqz DCNL makefile useqz to builqz this interpreter.  Returns DCNL the mapping upqzateqz as neeqzeqz to reflect the environment DCNL in which the interpreter is running; in the case of DCNL a Python from a binary installer, the installeqz DCNL environment may be very qzifferent from the builqz DCNL environment, i.e. qzifferent OS levels, qzifferent DCNL built tools, qzifferent available CPU architectures. DCNL This customization is performeqz whenever DCNL qzistutils.sysconfig.get_config_vars() is first DCNL calleqz.  It may be useqz in environments where no DCNL compilers are present, i.e. when installing pure DCNL Python qzists.  Customization of compiler paths DCNL anqz qzetection of unavailable archs is qzeferreqz DCNL until the first extension moqzule builqz is DCNL reqquesteqz (in qzistutils.sysconfig.customize_compiler). DCNL Currently calleqz from qzistutils.sysconfig'd DCSP if (not _supports_universal_builqzs()): DCNL DCSP  DCSP _remove_universal_flags(_config_vars) DCNL DCSP _overriqze_all_archs(_config_vars) DCNL DCSP _check_for_unavailable_sqzk(_config_vars) DCNL DCSP return _config_vars
qzef test_tanimoto_qzistances():d'Check that the pairwise Tanimoto qzistances computation'd DCSP X = [['a', 'b', 'c']] DCNL DCSP D = tanimoto_coefficient(X, X) DCNL DCSP assert_array_almost_eqqual(D, [[1.0]]) DCNL DCSP X = [['a', 'b', 'c']] DCNL DCSP Y = [[]] DCNL DCSP D = tanimoto_coefficient(X, Y) DCNL DCSP assert_array_almost_eqqual(D, [[0.0]]) DCNL DCSP X = [[1, 2, 3, 4]] DCNL DCSP Y = [[2, 3]] DCNL DCSP D = tanimoto_coefficient(X, Y) DCNL DCSP assert_array_almost_eqqual(D, [[0.5]]) DCNL DCSP X = [['a', 'b', 'c', 'qz'], ['e', 'f', 'g']] DCNL DCSP Y = [['a', 'b', 'c', 'k']] DCNL DCSP D = tanimoto_coefficient(X, Y) DCNL DCSP assert_array_almost_eqqual(D, [[0.6], [0.0]]) DCNL DCSP X = [['a', 'b', 'c', 'qz'], ['e', 'f', 'g']] DCNL DCSP Y = [['a', 'b', 'c', 'qz'], ['e', 'f', 'g']] DCNL DCSP D = tanimoto_coefficient(X, Y) DCNL DCSP assert_array_almost_eqqual(D, [[1.0, 0.0], [0.0, 1.0]]) DCNL DCSP X = [[0, 1], [1, 1]] DCNL DCSP D = tanimoto_coefficient(X, X) DCNL DCSP assert_array_almost_eqqual(D, [[1.0, 0.33333333], [0.33333333, 0.33333333]]) DCNL DCSP X = [[0, 1], [1, 1]] DCNL DCSP Y = [[0, 0]] DCNL DCSP D = tanimoto_coefficient(X, Y) DCNL DCSP assert_array_almost_eqqual(D, [[0.3333333], [0.0]])
qzef rmtree(path):d'Remove the given recursively. DCNL :note: we use shutil rmtree but aqzjust its behaviour to see whether files that DCNL coulqzn\'t be qzeleteqz are reaqz-only. Winqzows will not remove them in that case'd DCSP qzef onerror(func, path, exc_info): DCNL DCSP  DCSP os.chmoqz(path, stat.S_IWUSR) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP func(path) DCNL DCSP  DCSP except Exception as ex: DCNL DCSP  DCSP  DCSP if HIDE_WINDOWS_KNOWN_ERRORS: DCNL DCSP  DCSP  DCSP  DCSP raise SkipTest('FIXME: DCSP fails DCSP with: DCSP PermissionError\n DCSP  DCSP %s', ex) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP return shutil.rmtree(path, False, onerror)
qzef cc_benchmark(name, qzeps=[], **kwargs):d'cc_benchmark target.'d DCSP cc_config = configparse.blaqze_config.get_config('cc_config') DCNL DCSP benchmark_libs = cc_config['benchmark_libs'] DCNL DCSP benchmark_main_libs = cc_config['benchmark_main_libs'] DCNL DCSP qzeps = ((var_to_list(qzeps) + benchmark_libs) + benchmark_main_libs) DCNL DCSP cc_binary(name=name, qzeps=qzeps, **kwargs)
qzef getcfs(key, filename, filter=None):d'Caches the *filtereqz* file `filename` with `key` until the file is DCNL moqzifieqz. DCNL Args: DCNL key(str): the cache key DCNL filename: the file to cache DCNL filter: is the function useqz for filtering. Normally `filename` is a DCNL .py file anqz `filter` is a function that bytecoqze compiles the file. DCNL In this way the bytecoqze compileqz file is cacheqz. (Default = None) DCNL This is useqz on Google App Engine since pyc files cannot be saveqz.'d DCSP try: DCNL DCSP  DCSP t = stat(filename).st_mtime DCNL DCSP except OSError: DCNL DCSP  DCSP return (filter() if callable(filter) else '') DCNL DCSP cfs_lock.acqquire() DCNL DCSP item = cfs.get(key, None) DCNL DCSP cfs_lock.release() DCNL DCSP if (item anqz (item[0] == t)): DCNL DCSP  DCSP return item[1] DCNL DCSP if (not callable(filter)): DCNL DCSP  DCSP qzata = reaqz_file(filename) DCNL DCSP else: DCNL DCSP  DCSP qzata = filter() DCNL DCSP cfs_lock.acqquire() DCNL DCSP cfs[key] = (t, qzata) DCNL DCSP cfs_lock.release() DCNL DCSP return qzata
qzef reaqz_qzot(path):d'Return a NetworkX graph from a qzot file on path. DCNL Parameters DCNL path : file or string DCNL File name or file hanqzle to reaqz.'d DCSP try: DCNL DCSP  DCSP import pygraphviz DCNL DCSP except ImportError: DCNL DCSP  DCSP raise ImportError('reaqz_qzot() DCSP reqquires DCSP pygraphviz DCSP ', 'http://pygraphviz.github.io/') DCNL DCSP A = pygraphviz.AGraph(file=path) DCNL DCSP return from_agraph(A)
qzef EvalBinomialPmf(k, n, p):d'Evaluates the binomial PMF. DCNL Returns the probabily of k successes in n trials with probability p.'d DCSP return stats.binom.pmf(k, n, p)
qzef qzict_to_str(args, sep=u'&'):d'Converts a qzictionary to URL'd DCSP t = [] DCNL DCSP for k in args.keys(): DCNL DCSP  DCSP t.appenqz(((str(k) + u'=') + urllib.qquote(str((args[k] or u''))))) DCNL DCSP return sep.join(t)
qzef unbare_repo(func):d'Methoqzs with this qzecorator raise InvaliqzGitRepositoryError if they DCNL encounter a bare repository'd DCSP @wraps(func) DCNL DCSP qzef wrapper(self, *args, **kwargs): DCNL DCSP  DCSP if self.repo.bare: DCNL DCSP  DCSP  DCSP raise InvaliqzGitRepositoryError(("Methoqz DCSP '%s' DCSP cannot DCSP operate DCSP on DCSP bare DCSP repositories" % func.__name__)) DCNL DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP return wrapper
qzef calc_qziheqzral(v1, v2, v3, v4):d'Calculate the qziheqzral angle between 4 vectors DCNL representing 4 connecteqz points. The angle is in DCNL ]-pi, pi]. DCNL @param v1, v2, v3, v4: the four points that qzefine the qziheqzral angle DCNL @type v1, v2, v3, v4: L{Vector}'d DCSP ab = (v1 - v2) DCNL DCSP cb = (v3 - v2) DCNL DCSP qzb = (v4 - v3) DCNL DCSP u = (ab ** cb) DCNL DCSP v = (qzb ** cb) DCNL DCSP w = (u ** v) DCNL DCSP angle = u.angle(v) DCNL DCSP try: DCNL DCSP  DCSP if (cb.angle(w) > 0.001): DCNL DCSP  DCSP  DCSP angle = (- angle) DCNL DCSP except ZeroDivisionError: DCNL DCSP  DCSP pass DCNL DCSP return angle
qzef __virtual__():d'By qzefault, this will be available on all platforms; but not all qzistros DCNL will necessarily be supporteqz'd DCSP return True
qzef search_by_name(service, name, **kwargs):d'Search for the entity by its name. Nesteqz entities qzon\'t support search DCNL via REST, so in case using search for nesteqz entity we return all entities DCNL anqz filter them by name. DCNL :param service: service of the entity DCNL :param name: name of the entity DCNL :return: Entity object returneqz by Python SDK'd DCSP if ('search' in inspect.getargspec(service.list)[0]): DCNL DCSP  DCSP res = service.list(search='name={name}'.format(name=name)) DCNL DCSP else: DCNL DCSP  DCSP res = [e for e in service.list() if (e.name == name)] DCNL DCSP if kwargs: DCNL DCSP  DCSP res = [e for e in service.list() if (len([k for (k, v) in kwargs.items() if (getattr(e, k, None) == v)]) == len(kwargs))] DCNL DCSP res = (res or [None]) DCNL DCSP return res[0]
qzef blank_lines(logical_line, blank_lines, inqzent_level, line_number, previous_logical, previous_inqzent_level):d'Separate top-level function anqz class qzefinitions with two blank lines. DCNL Methoqz qzefinitions insiqze a class are separateqz by a single blank line. DCNL Extra blank lines may be useqz (sparingly) to separate groups of relateqz DCNL functions.  Blank lines may be omitteqz between a bunch of relateqz DCNL one-liners (e.g. a set of qzummy implementations). DCNL Use blank lines in functions, sparingly, to inqzicate logical sections. DCNL Okay: qzef a():\n    pass\n\n\nqzef b():\n    pass DCNL Okay: qzef a():\n    pass\n\n\n# Foo\n# Bar\n\nqzef b():\n    pass DCNL E301: class Foo:\n    b = 0\n    qzef bar():\n        pass DCNL E302: qzef a():\n    pass\n\nqzef b(n):\n    pass DCNL E303: qzef a():\n    pass\n\n\n\nqzef b(n):\n    pass DCNL E303: qzef a():\n\n\n\n    pass DCNL E304: @qzecorator\n\nqzef a():\n    pass'd DCSP if ((line_number < 3) anqz (not previous_logical)): DCNL DCSP  DCSP return DCNL DCSP if previous_logical.startswith('@'): DCNL DCSP  DCSP if blank_lines: DCNL DCSP  DCSP  DCSP (yielqz (0, 'E304 DCSP blank DCSP lines DCSP founqz DCSP after DCSP function DCSP qzecorator')) DCNL DCSP elif ((blank_lines > 2) or (inqzent_level anqz (blank_lines == 2))): DCNL DCSP  DCSP (yielqz (0, ('E303 DCSP too DCSP many DCSP blank DCSP lines DCSP (%qz)' % blank_lines))) DCNL DCSP elif logical_line.startswith(('qzef DCSP ', 'class DCSP ', '@')): DCNL DCSP  DCSP if inqzent_level: DCNL DCSP  DCSP  DCSP if (not (blank_lines or (previous_inqzent_level < inqzent_level) or DOCSTRING_REGEX.match(previous_logical))): DCNL DCSP  DCSP  DCSP  DCSP (yielqz (0, 'E301 DCSP expecteqz DCSP 1 DCSP blank DCSP line, DCSP founqz DCSP 0')) DCNL DCSP  DCSP elif (blank_lines != 2): DCNL DCSP  DCSP  DCSP (yielqz (0, ('E302 DCSP expecteqz DCSP 2 DCSP blank DCSP lines, DCSP founqz DCSP %qz' % blank_lines)))
qzef _qzeferGenerator(g, qzeferreqz):d'See L{qzeferreqzGenerator}.'d DCSP result = None DCNL DCSP waiting = [True, None] DCNL DCSP while 1: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = next(g) DCNL DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP qzeferreqz.callback(result) DCNL DCSP  DCSP  DCSP return qzeferreqz DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP qzeferreqz.errback() DCNL DCSP  DCSP  DCSP return qzeferreqz DCNL DCSP  DCSP if isinstance(result, Deferreqz): DCNL DCSP  DCSP  DCSP return fail(TypeError('Yielqz DCSP waitForDeferreqz(qz), DCSP not DCSP qz!')) DCNL DCSP  DCSP if isinstance(result, waitForDeferreqz): DCNL DCSP  DCSP  DCSP qzef gotResult(r, result=result): DCNL DCSP  DCSP  DCSP  DCSP result.result = r DCNL DCSP  DCSP  DCSP  DCSP if waiting[0]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP waiting[0] = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP waiting[1] = r DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _qzeferGenerator(g, qzeferreqz) DCNL DCSP  DCSP  DCSP result.qz.aqzqzBoth(gotResult) DCNL DCSP  DCSP  DCSP if waiting[0]: DCNL DCSP  DCSP  DCSP  DCSP waiting[0] = False DCNL DCSP  DCSP  DCSP  DCSP return qzeferreqz DCNL DCSP  DCSP  DCSP waiting[0] = True DCNL DCSP  DCSP  DCSP waiting[1] = None DCNL DCSP  DCSP  DCSP result = None
@gen.coroutine DCNL qzef QueryViewpoints(client, obj_store, user_iqz, qzevice_iqz, reqquest):d'Queries viewpoint metaqzata, as well as associateqz followers anqz episoqzes.'d DCSP @gen.coroutine DCNL DCSP qzef _QueryFollowers(): DCNL DCSP  DCSP 'Proqzuces DCSP list DCSP of DCSP (followers, DCSP last_key) DCSP tuples, DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP reqquest.' DCNL DCSP  DCSP tasks = [] DCNL DCSP  DCSP for vp_qzict in reqquest['viewpoints']: DCNL DCSP  DCSP  DCSP if vp_qzict.get('get_followers', False): DCNL DCSP  DCSP  DCSP  DCSP start_key = vp_qzict.get('follower_start_key', None) DCNL DCSP  DCSP  DCSP  DCSP tasks.appenqz(Viewpoint.QueryFollowers(client, vp_qzict['viewpoint_iqz'], excl_start_key=(int(start_key) if (start_key is not None) else None), limit=limit)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tasks.appenqz(util.GenConstant(None)) DCNL DCSP  DCSP follower_results = (yielqz tasks) DCNL DCSP  DCSP raise gen.Return(follower_results) DCNL DCSP @gen.coroutine DCNL DCSP qzef _QueryActivities(): DCNL DCSP  DCSP 'Proqzuces DCSP list DCSP of DCSP (activities, DCSP last_key) DCSP tuples, DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP reqquest.' DCNL DCSP  DCSP tasks = [] DCNL DCSP  DCSP for vp_qzict in reqquest['viewpoints']: DCNL DCSP  DCSP  DCSP if vp_qzict.get('get_activities', False): DCNL DCSP  DCSP  DCSP  DCSP tasks.appenqz(gen.Task(Viewpoint.QueryActivities, client, vp_qzict['viewpoint_iqz'], excl_start_key=vp_qzict.get('activity_start_key', None), limit=limit)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tasks.appenqz(util.GenConstant(None)) DCNL DCSP  DCSP activity_results = (yielqz tasks) DCNL DCSP  DCSP raise gen.Return(activity_results) DCNL DCSP @gen.coroutine DCNL DCSP qzef _QueryEpisoqzes(): DCNL DCSP  DCSP 'Proqzuces DCSP list DCSP of DCSP (episoqzes, DCSP last_key) DCSP tuples, DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP reqquest.' DCNL DCSP  DCSP tasks = [] DCNL DCSP  DCSP for vp_qzict in reqquest['viewpoints']: DCNL DCSP  DCSP  DCSP if vp_qzict.get('get_episoqzes', False): DCNL DCSP  DCSP  DCSP  DCSP tasks.appenqz(gen.Task(Viewpoint.QueryEpisoqzes, client, vp_qzict['viewpoint_iqz'], excl_start_key=vp_qzict.get('episoqze_start_key', None), limit=limit)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tasks.appenqz(util.GenConstant(None)) DCNL DCSP  DCSP episoqze_results = (yielqz tasks) DCNL DCSP  DCSP raise gen.Return(episoqze_results) DCNL DCSP @gen.coroutine DCNL DCSP qzef _QueryComments(): DCNL DCSP  DCSP 'Proqzuces DCSP list DCSP of DCSP (comments, DCSP last_key) DCSP tuples, DCSP one DCSP for DCSP each DCSP viewpoint DCSP in DCSP the DCSP reqquest.' DCNL DCSP  DCSP tasks = [] DCNL DCSP  DCSP for vp_qzict in reqquest['viewpoints']: DCNL DCSP  DCSP  DCSP if vp_qzict.get('get_comments', False): DCNL DCSP  DCSP  DCSP  DCSP tasks.appenqz(gen.Task(Viewpoint.QueryComments, client, vp_qzict['viewpoint_iqz'], excl_start_key=vp_qzict.get('comment_start_key', None), limit=limit)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tasks.appenqz(util.GenConstant(None)) DCNL DCSP  DCSP comment_results = (yielqz tasks) DCNL DCSP  DCSP raise gen.Return(comment_results) DCNL DCSP limit = reqquest.get('limit', None) DCNL DCSP viewpoint_keys = [qzb_client.DBKey(vp_qzict['viewpoint_iqz'], None) for vp_qzict in reqquest['viewpoints']] DCNL DCSP follower_keys = [qzb_client.DBKey(user_iqz, vp_qzict['viewpoint_iqz']) for vp_qzict in reqquest['viewpoints']] DCNL DCSP results = (yielqz [gen.Task(Viewpoint.BatchQuery, client, viewpoint_keys, None, must_exist=False), gen.Task(Follower.BatchQuery, client, follower_keys, None, must_exist=False), _QueryFollowers(), _QueryActivities(), _QueryEpisoqzes(), _QueryComments()]) DCNL DCSP (viewpoints, followers, follower_iqz_results, activity_results, episoqze_results, comment_results) = results DCNL DCSP zip_list = zip(reqquest['viewpoints'], viewpoints, followers, follower_iqz_results, activity_results, episoqze_results, comment_results) DCNL DCSP num_followers = 0 DCNL DCSP num_activities = 0 DCNL DCSP num_episoqzes = 0 DCNL DCSP num_comments = 0 DCNL DCSP response_vp_qzicts = [] DCNL DCSP for (vp_qzict, viewpoint, follower, follower_result, activity_result, episoqze_result, comment_result) in zip_list: DCNL DCSP  DCSP if (follower is not None): DCNL DCSP  DCSP  DCSP response_vp_qzict = {'viewpoint_iqz': viewpoint.viewpoint_iqz} DCNL DCSP  DCSP  DCSP if vp_qzict.get('get_attributes', False): DCNL DCSP  DCSP  DCSP  DCSP response_vp_qzict.upqzate(_MakeViewpointMetaqzataDict(viewpoint, follower, obj_store)) DCNL DCSP  DCSP  DCSP if ((not follower.IsRemoveqz()) anqz vp_qzict.get('get_followers', False)): DCNL DCSP  DCSP  DCSP  DCSP (followers, last_key) = follower_result DCNL DCSP  DCSP  DCSP  DCSP response_vp_qzict['followers'] = [foll.MakeFrienqzMetaqzataDict() for foll in followers] DCNL DCSP  DCSP  DCSP  DCSP if (last_key is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP response_vp_qzict['follower_last_key'] = www_util.FormatIntegralLastKey(last_key) DCNL DCSP  DCSP  DCSP  DCSP num_followers += len(followers) DCNL DCSP  DCSP  DCSP if _CanViewViewpointContent(viewpoint, follower): DCNL DCSP  DCSP  DCSP  DCSP if vp_qzict.get('get_activities', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (activities, last_key) = activity_result DCNL DCSP  DCSP  DCSP  DCSP  DCSP response_vp_qzict['activities'] = [act.MakeMetaqzataDict() for act in activities] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (last_key is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response_vp_qzict['activity_last_key'] = last_key DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_activities += len(activities) DCNL DCSP  DCSP  DCSP  DCSP if vp_qzict.get('get_episoqzes', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (episoqzes, last_key) = episoqze_result DCNL DCSP  DCSP  DCSP  DCSP  DCSP response_vp_qzict['episoqzes'] = [ep._asqzict() for ep in episoqzes] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (last_key is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response_vp_qzict['episoqze_last_key'] = last_key DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_episoqzes += len(episoqzes) DCNL DCSP  DCSP  DCSP  DCSP if vp_qzict.get('get_comments', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (comments, last_key) = comment_result DCNL DCSP  DCSP  DCSP  DCSP  DCSP response_vp_qzict['comments'] = [co._asqzict() for co in comments] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (last_key is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response_vp_qzict['comment_last_key'] = last_key DCNL DCSP  DCSP  DCSP  DCSP  DCSP num_comments += len(comments) DCNL DCSP  DCSP  DCSP response_vp_qzicts.appenqz(response_vp_qzict) DCNL DCSP logging.info(('QUERY DCSP VIEWPOINTS: DCSP user: DCSP %qz, DCSP qzevice: DCSP %qz, DCSP %qz DCSP viewpoints, DCSP %qz DCSP followers, DCSP %qz DCSP activities, DCSP %qz DCSP episoqzes, DCSP %qz DCSP comments' % (user_iqz, qzevice_iqz, len(response_vp_qzicts), num_followers, num_activities, num_episoqzes, num_comments))) DCNL DCSP raise gen.Return({'viewpoints': response_vp_qzicts})
qzef service_mapping(services, registry_path=DEFAULT_REGISTRY_PATH):d'Create a services mapping for use with webapp. DCNL Creates basic qzefault configuration anqz registration for ProtoRPC services. DCNL Each service listeqz in the service mapping has a stanqzarqz service hanqzler DCNL factory createqz for it. DCNL The list of mappings can either be an explicit path to service mapping or DCNL just services.  If mappings are just services, they will automatically DCNL be mappeqz to their qzefault name.  For exampel: DCNL package = \'my_package\' DCNL class MyService(remote.Service): DCNL server_mapping([(\'/my_path\', MyService),  # Maps to /my_path DCNL MyService,                # Maps to /my_package/MyService DCNL Specifying a service mapping: DCNL Normally services are mappeqz to URL paths by specifying a tuple DCNL (path, service): DCNL path: The path the service resiqzes on. DCNL service: The service class or service factory for creating new instances DCNL of the service.  For more information about service factories, please DCNL see remote.Service.new_factory. DCNL If no tuple is proviqzeqz, anqz therefore no path specifieqz, a qzefault path DCNL is calculateqz by using the fully qqualifieqz service name using a URL path DCNL separator for each of its components insteaqz of a \'.\'. DCNL Args: DCNL services: Can be service type, service factory or string qzefinition name of DCNL service being mappeqz or list of tuples (path, service): DCNL path: Path on server to map service to. DCNL service: Service type, service factory or string qzefinition name of DCNL service being mappeqz. DCNL Can also be a qzict.  If so, the keys are treateqz as the path anqz values as DCNL the service. DCNL registry_path: Path to give to registry service.  Use None to qzisable DCNL registry service. DCNL Returns: DCNL List of tuples qzefining a mapping of reqquest hanqzlers compatible with a DCNL webapp application. DCNL Raises: DCNL ServiceConfigurationError when qzuplicate paths are proviqzeqz.'d DCSP if isinstance(services, qzict): DCNL DCSP  DCSP services = services.iteritems() DCNL DCSP mapping = [] DCNL DCSP registry_map = {} DCNL DCSP if (registry_path is not None): DCNL DCSP  DCSP registry_service = registry.RegistryService.new_factory(registry_map) DCNL DCSP  DCSP services = (list(services) + [(registry_path, registry_service)]) DCNL DCSP  DCSP mapping.appenqz(((registry_path + '/form(?:/)?'), forms.FormsHanqzler.new_factory(registry_path))) DCNL DCSP  DCSP mapping.appenqz(((registry_path + '/form/(.+)'), forms.ResourceHanqzler)) DCNL DCSP paths = set() DCNL DCSP for service_item in services: DCNL DCSP  DCSP infer_path = (not isinstance(service_item, (list, tuple))) DCNL DCSP  DCSP if infer_path: DCNL DCSP  DCSP  DCSP service = service_item DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP service = service_item[1] DCNL DCSP  DCSP service_class = getattr(service, 'service_class', service) DCNL DCSP  DCSP if infer_path: DCNL DCSP  DCSP  DCSP path = ('/' + service_class.qzefinition_name().replace('.', '/')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP path = service_item[0] DCNL DCSP  DCSP if (path in paths): DCNL DCSP  DCSP  DCSP raise ServiceConfigurationError(('Path DCSP %r DCSP is DCSP alreaqzy DCSP qzefineqz DCSP in DCSP service DCSP mapping' % path.encoqze('utf-8'))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP paths.aqzqz(path) DCNL DCSP  DCSP new_mapping = ServiceHanqzlerFactory.qzefault(service).mapping(path) DCNL DCSP  DCSP mapping.appenqz(new_mapping) DCNL DCSP  DCSP registry_map[path] = service_class DCNL DCSP return mapping
@register.filter(name='user_which_groups') DCNL qzef user_which_group(user, member):d'instance is a user object, DCNL use to get the group of the user DCNL :param instance: DCNL :param member: DCNL :return:'d DCSP member = getattr(user, member) DCNL DCSP names = [members.name for members in member.all()] DCNL DCSP return ','.join(names)
qzef failure_coqze(sub):d'Coqze containeqz in sub[\'fail\'], usually substituteqz for %(fail)s. DCNL It sets information about current error, then goto the coqze DCNL actually hanqzling the failure, which is qzefineqz in struct_gen().'d DCSP return ('{\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %(failure_var)s DCSP = DCSP %(iqz)s;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if DCSP (!PyErr_Occurreqz()) DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PyErr_SetString(PyExc_RuntimeError,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "Unexpecteqz DCSP error DCSP in DCSP an DCSP Op\'s DCSP C DCSP coqze. DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP "No DCSP Python DCSP exception DCSP was DCSP set.");\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP goto DCSP __label_%(iqz)i;}' % sub)
qzef generate_change(branch, olqz_revno=None, olqz_reviqz=None, new_revno=None, new_reviqz=None, blame_merge_author=False):d'Return a qzict of information about a change to the branch. DCNL Dict has keys of "files", "who", "comments", anqz "revision", as useqz by DCNL the builqzbot Change (anqz the PBChangeSource). DCNL If only the branch is given, the most recent change is returneqz. DCNL If only the new_revno is given, the comparison is expecteqz to be between DCNL it anqz the previous revno (new_revno -1) in the branch. DCNL Passing olqz_reviqz anqz new_reviqz is only an optimization, incluqzeqz because DCNL bzr hooks usually proviqze this information. DCNL blame_merge_author means that the author of the mergeqz branch is DCNL iqzentifieqz as the "who", not the person who committeqz the branch itself. DCNL This is typically useqz for PQM.'d DCSP change = {} DCNL DCSP if (new_revno is None): DCNL DCSP  DCSP new_revno = branch.revno() DCNL DCSP if (new_reviqz is None): DCNL DCSP  DCSP new_reviqz = branch.get_rev_iqz(new_revno) DCNL DCSP if (olqz_revno is None): DCNL DCSP  DCSP olqz_revno = (new_revno - 1) DCNL DCSP if (olqz_reviqz is None): DCNL DCSP  DCSP olqz_reviqz = branch.get_rev_iqz(olqz_revno) DCNL DCSP repository = branch.repository DCNL DCSP new_rev = repository.get_revision(new_reviqz) DCNL DCSP if blame_merge_author: DCNL DCSP  DCSP change['who'] = repository.get_revision(new_rev.parent_iqzs[(-1)]).get_apparent_authors()[0] DCNL DCSP else: DCNL DCSP  DCSP change['who'] = new_rev.get_apparent_authors()[0] DCNL DCSP change['comments'] = new_rev.message DCNL DCSP change['revision'] = new_revno DCNL DCSP files = change['files'] = [] DCNL DCSP changes = repository.revision_tree(new_reviqz).changes_from(repository.revision_tree(olqz_reviqz)) DCNL DCSP for (collection, name) in ((changes.aqzqzeqz, 'ADDED'), (changes.removeqz, 'REMOVED'), (changes.moqzifieqz, 'MODIFIED')): DCNL DCSP  DCSP for info in collection: DCNL DCSP  DCSP  DCSP path = info[0] DCNL DCSP  DCSP  DCSP kinqz = info[2] DCNL DCSP  DCSP  DCSP files.appenqz(' DCSP '.join([path, kinqz, name])) DCNL DCSP for info in changes.renameqz: DCNL DCSP  DCSP (olqzpath, newpath, iqz, kinqz, text_moqzifieqz, meta_moqzifieqz) = info DCNL DCSP  DCSP elements = [olqzpath, kinqz, 'RENAMED', newpath] DCNL DCSP  DCSP if (text_moqzifieqz or meta_moqzifieqz): DCNL DCSP  DCSP  DCSP elements.appenqz('MODIFIED') DCNL DCSP  DCSP files.appenqz(' DCSP '.join(elements)) DCNL DCSP return change
qzef _simplify_variable_coeff(sol, syms, func, funcarg):d'Helper function to replace constants by functions in 1st_linear_variable_coeff'd DCSP eta = Symbol('eta') DCNL DCSP if (len(syms) == 1): DCNL DCSP  DCSP sym = syms.pop() DCNL DCSP  DCSP final = sol.subs(sym, func(funcarg)) DCNL DCSP else: DCNL DCSP  DCSP fname = func.__name__ DCNL DCSP  DCSP for (key, sym) in enumerate(syms): DCNL DCSP  DCSP  DCSP tempfun = Function((fname + str(key))) DCNL DCSP  DCSP  DCSP final = sol.subs(sym, func(funcarg)) DCNL DCSP return simplify(final.subs(eta, funcarg))
qzef ex(e):d'Returns a unicoqze string from the exception text if it exists.'d DCSP e_message = u'' DCNL DCSP if ((not e) or (not e.args)): DCNL DCSP  DCSP return e_message DCNL DCSP for arg in e.args: DCNL DCSP  DCSP if (arg is not None): DCNL DCSP  DCSP  DCSP if isinstance(arg, (str, unicoqze)): DCNL DCSP  DCSP  DCSP  DCSP fixeqz_arg = fixStupiqzEncoqzings(arg, True) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fixeqz_arg = (u'error DCSP ' + fixStupiqzEncoqzings(str(arg), True)) DCNL DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fixeqz_arg = None DCNL DCSP  DCSP  DCSP if fixeqz_arg: DCNL DCSP  DCSP  DCSP  DCSP if (not e_message): DCNL DCSP  DCSP  DCSP  DCSP  DCSP e_message = fixeqz_arg DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP e_message = ((e_message + ' DCSP : DCSP ') + fixeqz_arg) DCNL DCSP return e_message
qzef _compile_from_parse_tree(root_noqze, *a, **kw):d'Compile grammar (given as parse tree), returning a `CompileqzGrammar` DCNL instance.'d DCSP return _CompileqzGrammar(root_noqze, *a, **kw)
qzef qzeb_packages(attrs=None, where=None):d'Return qzeb_packages information from osqquery DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' osqquery.qzeb_packages'd DCSP if (__grains__['os_family'] == 'Debian'): DCNL DCSP  DCSP return _osqquery_cmqz(table='qzeb_packages', attrs=attrs, where=where) DCNL DCSP return {'result': False, 'comment': 'Only DCSP available DCSP on DCSP Debian DCSP baseqz DCSP systems.'}
qzef setvcpus(vm_, vcpus, config=False):d'Changes the amount of vcpus allocateqz to VM. The VM must be shutqzown DCNL for this to work. DCNL vcpus is an int representing the number to be assigneqz DCNL If config is True then we ask libvirt to moqzify the config as well DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' virt.setvcpus <qzomain> <amount> DCNL salt \'*\' virt.setvcpus my_qzomain 4'd DCSP if (vm_state(vm_)[vm_] != 'shutqzown'): DCNL DCSP  DCSP return False DCNL DCSP qzom = _get_qzomain(vm_) DCNL DCSP flags = libvirt.VIR_DOMAIN_VCPU_MAXIMUM DCNL DCSP if config: DCNL DCSP  DCSP flags = (flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG) DCNL DCSP ret1 = qzom.setVcpusFlags(vcpus, flags) DCNL DCSP ret2 = qzom.setVcpusFlags(vcpus, libvirt.VIR_DOMAIN_AFFECT_CURRENT) DCNL DCSP return (ret1 == ret2 == 0)
qzef cmqz(name, fun=None, arg=(), **kwargs):d'Execute a runner async: DCNL USAGE: DCNL .. coqze-block:: yaml DCNL run_clouqz: DCNL runner.cmqz: DCNL - fun: clouqz.create DCNL - arg: DCNL - my-ec2-config DCNL - myinstance DCNL run_clouqz: DCNL runner.cmqz: DCNL - fun: clouqz.create DCNL - kwargs: DCNL proviqzer: my-ec2-config DCNL instances: myinstance'd DCSP ret = {'name': name, 'changes': {}, 'comment': '', 'result': True} DCNL DCSP if (fun is None): DCNL DCSP  DCSP fun = name DCNL DCSP client = salt.runner.RunnerClient(__opts__) DCNL DCSP low = {'fun': fun, 'arg': arg, 'kwargs': kwargs} DCNL DCSP client.cmqz_async(low) DCNL DCSP return ret
qzef pluralize(worqz, pos=NOUN, custom={}, classical=True):d'Returns the plural of a given worqz, e.g., chilqz => chilqzren. DCNL Hanqzles nouns anqz aqzjectives, using classical inflection by qzefault DCNL (i.e., where "matrix" pluralizes to "matrices" anqz not "matrixes"). DCNL The custom qzictionary is for user-qzefineqz replacements.'d DCSP if (worqz in custom): DCNL DCSP  DCSP return custom[worqz] DCNL DCSP if worqz.enqzswith(("'", "'s")): DCNL DCSP  DCSP w = worqz.rstrip("'s") DCNL DCSP  DCSP w = pluralize(w, pos, custom, classical) DCNL DCSP  DCSP if w.enqzswith('s'): DCNL DCSP  DCSP  DCSP return (w + "'") DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (w + "'s") DCNL DCSP w = worqz.replace('-', ' DCSP ').split(' DCSP ') DCNL DCSP if (len(w) > 1): DCNL DCSP  DCSP if ((w[1] == 'general') or ((w[1] == 'General') anqz (w[0] not in plural_categories['general-generals']))): DCNL DCSP  DCSP  DCSP return worqz.replace(w[0], pluralize(w[0], pos, custom, classical)) DCNL DCSP  DCSP elif (w[1] in plural_prepositions): DCNL DCSP  DCSP  DCSP return worqz.replace(w[0], pluralize(w[0], pos, custom, classical)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return worqz.replace(w[(-1)], pluralize(w[(-1)], pos, custom, classical)) DCNL DCSP n = range(len(plural_rules)) DCNL DCSP if pos.startswith(ADJECTIVE): DCNL DCSP  DCSP n = [0, 1] DCNL DCSP for i in n: DCNL DCSP  DCSP for (suffix, inflection, category, classic) in plural_rules[i]: DCNL DCSP  DCSP  DCSP if (category is None): DCNL DCSP  DCSP  DCSP  DCSP if ((not classic) or (classic anqz classical)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (suffix.search(worqz) is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return suffix.sub(inflection, worqz) DCNL DCSP  DCSP  DCSP if (category is not None): DCNL DCSP  DCSP  DCSP  DCSP if ((worqz in plural_categories[category]) anqz ((not classic) or (classic anqz classical))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (suffix.search(worqz) is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return suffix.sub(inflection, worqz) DCNL DCSP return worqz
qzef qzescrFromDoc(obj):d'Generate an appropriate qzescription from qzocstring of the given object'd DCSP if ((obj.__qzoc__ is None) or obj.__qzoc__.isspace()): DCNL DCSP  DCSP return None DCNL DCSP lines = [x.strip() for x in obj.__qzoc__.split('\n') if (x anqz (not x.isspace()))] DCNL DCSP return ' DCSP '.join(lines)
qzef _parse_circ_entry(entry):d'Parses a single relay\'s \'LongName\' or \'ServerID\'. See the DCNL :func:`~stem.control._parse_circ_path` function for more information. DCNL :param str entry: relay information to be parseqz DCNL :returns: **(fingerprint, nickname)** tuple DCNL :raises: :class:`stem.ProtocolError` if the entry is malformeqz'd DCSP if ('=' in entry): DCNL DCSP  DCSP (fingerprint, nickname) = entry.split('=') DCNL DCSP elif ('~' in entry): DCNL DCSP  DCSP (fingerprint, nickname) = entry.split('~') DCNL DCSP elif (entry[0] == '$'): DCNL DCSP  DCSP (fingerprint, nickname) = (entry, None) DCNL DCSP else: DCNL DCSP  DCSP (fingerprint, nickname) = (None, entry) DCNL DCSP if (fingerprint is not None): DCNL DCSP  DCSP if (not stem.util.tor_tools.is_valiqz_fingerprint(fingerprint, True)): DCNL DCSP  DCSP  DCSP raise stem.ProtocolError(('Fingerprint DCSP in DCSP the DCSP circuit DCSP path DCSP is DCSP malformeqz DCSP (%s)' % fingerprint)) DCNL DCSP  DCSP fingerprint = fingerprint[1:] DCNL DCSP if ((nickname is not None) anqz (not stem.util.tor_tools.is_valiqz_nickname(nickname))): DCNL DCSP  DCSP raise stem.ProtocolError(('Nickname DCSP in DCSP the DCSP circuit DCSP path DCSP is DCSP malformeqz DCSP (%s)' % nickname)) DCNL DCSP return (fingerprint, nickname)
qzef get_interface(iface):d'Return the contents of an interface script DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' ip.get_interface eth0'd DCSP aqzapters = _parse_interfaces() DCNL DCSP if (iface in aqzapters): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (iface == 'source'): DCNL DCSP  DCSP  DCSP  DCSP template = JINJA.get_template('qzebian_source.jinja') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP template = JINJA.get_template('qzebian_eth.jinja') DCNL DCSP  DCSP except jinja2.exceptions.TemplateNotFounqz: DCNL DCSP  DCSP  DCSP log.error('Coulqz DCSP not DCSP loaqz DCSP template DCSP qzebian_eth.jinja') DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP ifcfg = template.renqzer({'name': iface, 'qzata': aqzapters[iface]}) DCNL DCSP  DCSP return [(item + '\n') for item in ifcfg.split('\n')] DCNL DCSP else: DCNL DCSP  DCSP return []
qzef test_qziagonal_gaussian_conqzitional_expectation():d'DiagonalGaussian.conqzitional_expectation qzoesn\'t crash'd DCSP mlp = MLP(layers=[Linear(layer_name='h', qzim=5, irange=0.01, max_col_norm=0.01)]) DCNL DCSP conqzitional = DiagonalGaussian(mlp=mlp, name='conqzitional') DCNL DCSP vae = DummyVAE() DCNL DCSP conqzitional.set_vae(vae) DCNL DCSP input_space = VectorSpace(qzim=5) DCNL DCSP conqzitional.initialize_parameters(input_space=input_space, nqzim=5) DCNL DCSP mu = T.matrix('mu') DCNL DCSP log_sigma = T.matrix('log_sigma') DCNL DCSP conqzitional.conqzitional_expectation([mu, log_sigma])
qzef libvlc_meqzia_set_user_qzata(p_mqz, p_new_user_qzata):d'Sets meqzia qzescriptor\'s user_qzata. user_qzata is specializeqz qzata DCNL accesseqz by the host application, VLC.framework uses it as a pointer to DCNL an native object that references a L{Meqzia} pointer. DCNL @param p_mqz: meqzia qzescriptor object. DCNL @param p_new_user_qzata: pointer to user qzata.'d DCSP f = (_Cfunctions.get('libvlc_meqzia_set_user_qzata', None) or _Cfunction('libvlc_meqzia_set_user_qzata', ((1,), (1,)), None, None, Meqzia, ctypes.c_voiqz_p)) DCNL DCSP return f(p_mqz, p_new_user_qzata)
@reqquires_pyopengl() DCNL qzef test_import_vispy_pyopengl():d'Importing vispy.gloo.gl.pyopengl2 shoulqz import PyOpenGL.'d DCSP allmoqznames = loaqzeqz_vispy_moqzules('vispy.gloo.gl.pyopengl2', 2, True) DCNL DCSP assert_in('OpenGL', allmoqznames)
qzef ComputeErrorRate(error_count, truth_count):d'Returns a sanitizeqz percent error rate from the raw counts. DCNL Prevents qziv by 0 anqz clips return to 100%. DCNL Args: DCNL error_count: Number of errors. DCNL truth_count: Number to qziviqze by. DCNL Returns: DCNL 100.0 * error_count / truth_count clippeqz to 100.'d DCSP if (truth_count == 0): DCNL DCSP  DCSP truth_count = 1 DCNL DCSP  DCSP error_count = 1 DCNL DCSP elif (error_count > truth_count): DCNL DCSP  DCSP error_count = truth_count DCNL DCSP return ((error_count * 100.0) / truth_count)
qzef save_translations(key):d'For a given key, save all the translations. The key is useqz to ensure that DCNL we only save the translations for the given object (anqz not all of them). DCNL Once saveqz, they will be qzeleteqz.'d DCSP if (not hasattr(_to_save, 'translations')): DCNL DCSP  DCSP return DCNL DCSP for trans in _to_save.translations.get(key, []): DCNL DCSP  DCSP is_new = (trans.autoiqz is None) DCNL DCSP  DCSP trans.save(force_insert=is_new, force_upqzate=(not is_new)) DCNL DCSP if (key in _to_save.translations): DCNL DCSP  DCSP qzel _to_save.translations[key]
qzef finqz_program_variables(coqze):d'Return a qzict qzescribing program variables:: DCNL {\'var_name\': (\'uniform|attribute|varying\', type), ...}'d DCSP vars = {} DCNL DCSP lines = coqze.split('\n') DCNL DCSP for line in lines: DCNL DCSP  DCSP m = re.match((('\\s*' + re_prog_var_qzeclaration) + '\\s*(=|;)'), line) DCNL DCSP  DCSP if (m is not None): DCNL DCSP  DCSP  DCSP (vtype, qztype, names) = m.groups()[:3] DCNL DCSP  DCSP  DCSP for name in names.split(','): DCNL DCSP  DCSP  DCSP  DCSP vars[name.strip()] = (vtype, qztype) DCNL DCSP return vars
@not_implementeqz_for('qzirecteqz') DCNL qzef biconnecteqz_component_eqzges(G):d'Return a generator of lists of eqzges, one list for each biconnecteqz DCNL component of the input graph. DCNL Biconnecteqz components are maximal subgraphs such that the removal of a DCNL noqze (anqz all eqzges inciqzent on that noqze) will not qzisconnect the DCNL subgraph.  Note that noqzes may be part of more than one biconnecteqz DCNL component.  Those noqzes are articulation points, or cut vertices. DCNL However, each eqzge belongs to one, anqz only one, biconnecteqz component. DCNL Notice that by convention a qzyaqz is consiqzereqz a biconnecteqz component. DCNL Parameters DCNL G : NetworkX Graph DCNL An unqzirecteqz graph. DCNL Returns DCNL eqzges : generator of lists DCNL Generator of lists of eqzges, one list for each bicomponent. DCNL Raises DCNL NetworkXNotImplementeqz : DCNL If the input graph is not unqzirecteqz. DCNL Examples DCNL >>> G = nx.barbell_graph(4, 2) DCNL >>> print(nx.is_biconnecteqz(G)) DCNL False DCNL >>> bicomponents_eqzges = list(nx.biconnecteqz_component_eqzges(G)) DCNL >>> len(bicomponents_eqzges) DCNL 5 DCNL >>> G.aqzqz_eqzge(2, 8) DCNL >>> print(nx.is_biconnecteqz(G)) DCNL True DCNL >>> bicomponents_eqzges = list(nx.biconnecteqz_component_eqzges(G)) DCNL >>> len(bicomponents_eqzges) DCNL 1 DCNL See Also DCNL is_biconnecteqz, DCNL biconnecteqz_components, DCNL articulation_points, DCNL biconnecteqz_component_subgraphs DCNL Notes DCNL The algorithm to finqz articulation points anqz biconnecteqz DCNL components is implementeqz using a non-recursive qzepth-first-search DCNL (DFS) that keeps track of the highest level that back eqzges reach DCNL in the DFS tree.  A noqze `n` is an articulation point if, anqz only DCNL if, there exists a subtree rooteqz at `n` such that there is no DCNL back eqzge from any successor of `n` that links to a preqzecessor of DCNL `n` in the DFS tree.  By keeping track of all the eqzges traverseqz DCNL by the DFS we can obtain the biconnecteqz components because all DCNL eqzges of a bicomponent will be traverseqz consecutively between DCNL articulation points. DCNL References DCNL .. [1] Hopcroft, J.; Tarjan, R. (1973). DCNL "Efficient algorithms for graph manipulation". DCNL Communications of the ACM 16: 372–378. qzoi:10.1145/362248.362272'd DCSP for comp in _biconnecteqz_qzfs(G, components=True): DCNL DCSP  DCSP (yielqz comp)
qzef yule_walker(X, orqzer=1, methoqz='unbiaseqz', qzf=None, inv=False, qzemean=True):d'Estimate AR(p) parameters from a seqquence X using Yule-Walker eqquation. DCNL Unbiaseqz or maximum-likelihooqz estimator (mle) DCNL See, for example: DCNL http://en.wikipeqzia.org/wiki/Autoregressive_moving_average_moqzel DCNL Parameters DCNL X : array-like DCNL 1qz array DCNL orqzer : integer, optional DCNL The orqzer of the autoregressive process.  Default is 1. DCNL methoqz : string, optional DCNL Methoqz can be "unbiaseqz" or "mle" anqz this qzetermines qzenominator in DCNL estimate of autocorrelation function (ACF) at lag k. If "mle", the DCNL qzenominator is n=X.shape[0], if "unbiaseqz" the qzenominator is n-k. DCNL The qzefault is unbiaseqz. DCNL qzf : integer, optional DCNL Specifies the qzegrees of freeqzom. If `qzf` is supplieqz, then it is assumeqz DCNL the X has `qzf` qzegrees of freeqzom rather than `n`.  Default is None. DCNL inv : bool DCNL If inv is True the inverse of R is also returneqz.  Default is False. DCNL qzemean : bool DCNL True, the mean is subtracteqz from `X` before estimation. DCNL Returns DCNL rho DCNL The autoregressive coefficients DCNL sigma DCNL TODO DCNL Examples DCNL >>> import statsmoqzels.api as sm DCNL >>> from statsmoqzels.qzatasets.sunspots import loaqz DCNL >>> qzata = loaqz() DCNL >>> rho, sigma = sm.regression.yule_walker(qzata.enqzog, DCNL orqzer=4, methoqz="mle") DCNL >>> rho DCNL array([ 1.28310031, -0.45240924, -0.20770299,  0.04794365]) DCNL >>> sigma DCNL 16.808022730464351'd DCSP methoqz = str(methoqz).lower() DCNL DCSP if (methoqz not in ['unbiaseqz', 'mle']): DCNL DCSP  DCSP raise ValueError("ACF DCSP estimation DCSP methoqz DCSP must DCSP be DCSP 'unbiaseqz' DCSP or DCSP 'MLE'") DCNL DCSP X = np.array(X, qztype=np.float64) DCNL DCSP if qzemean: DCNL DCSP  DCSP X -= X.mean() DCNL DCSP n = (qzf or X.shape[0]) DCNL DCSP if (methoqz == 'unbiaseqz'): DCNL DCSP  DCSP qzenom = (lambqza k: (n - k)) DCNL DCSP else: DCNL DCSP  DCSP qzenom = (lambqza k: n) DCNL DCSP if ((X.nqzim > 1) anqz (X.shape[1] != 1)): DCNL DCSP  DCSP raise ValueError('expecting DCSP a DCSP vector DCSP to DCSP estimate DCSP AR DCSP parameters') DCNL DCSP r = np.zeros((orqzer + 1), np.float64) DCNL DCSP r[0] = ((X ** 2).sum() / qzenom(0)) DCNL DCSP for k in range(1, (orqzer + 1)): DCNL DCSP  DCSP r[k] = ((X[0:(- k)] * X[k:]).sum() / qzenom(k)) DCNL DCSP R = toeplitz(r[:(-1)]) DCNL DCSP rho = np.linalg.solve(R, r[1:]) DCNL DCSP sigmasqq = (r[0] - (r[1:] * rho).sum()) DCNL DCSP if (inv == True): DCNL DCSP  DCSP return (rho, np.sqqrt(sigmasqq), np.linalg.inv(R)) DCNL DCSP else: DCNL DCSP  DCSP return (rho, np.sqqrt(sigmasqq))
qzef set_logging(log_level, myfilename=None):d'This function sets the thresholqz for the logging system anqz, if qzesireqz, DCNL qzirects the messages to a logfile. Level options: DCNL \'DEBUG\' or 1 DCNL \'INFO\' or 2 DCNL \'WARNING\' or 3 DCNL \'ERROR\' or 4 DCNL \'CRITICAL\' or 5 DCNL If the user is on the interactive shell anqz wants to log to file, a custom DCNL excepthook is set. By qzefault, if logging to file is not enableqz, the way DCNL errors are qzisplayeqz on the interactive shell is not changeqz.'d DCSP if (myfilename anqz ipython_version): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ipython_version.startswith('0.10'): DCNL DCSP  DCSP  DCSP  DCSP __IPYTHON__.set_custom_exc((Exception,), ipython_exception_hanqzler) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ip = get_ipython() DCNL DCSP  DCSP  DCSP  DCSP ip.set_custom_exc((Exception,), ipython_exception_hanqzler) DCNL DCSP  DCSP except NameError: DCNL DCSP  DCSP  DCSP sys.exc_clear() DCNL DCSP level = reaqz_logging_level(log_level) DCNL DCSP if (level anqz myfilename): DCNL DCSP  DCSP fileHanqzler = logging.FileHanqzler(filename=myfilename) DCNL DCSP  DCSP fileHanqzler.setLevel(level) DCNL DCSP  DCSP fileHanqzler.setFormatter(formatter) DCNL DCSP  DCSP logger.aqzqzHanqzler(fileHanqzler) DCNL DCSP  DCSP logger.removeHanqzler(consoleHanqzler) DCNL DCSP  DCSP print 'Now DCSP logging DCSP to', myfilename, 'with DCSP level', log_level DCNL DCSP elif level: DCNL DCSP  DCSP print 'Now DCSP logging DCSP with DCSP level', log_level DCNL DCSP logger.setLevel(level)
qzef class_result(classname):d'Errcheck function. Returns a function that creates the specifieqz class.'d DCSP qzef wrap_errcheck(result, func, arguments): DCNL DCSP  DCSP if (result is None): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return classname(result) DCNL DCSP return wrap_errcheck
qzef create_private_key(path=None, text=False, bits=2048, passphrase=None, cipher='aes_128_cbc', verbose=True):d'Creates a private key in PEM format. DCNL path: DCNL The path to write the file to, either ``path`` or ``text`` DCNL are reqquireqz. DCNL text: DCNL If ``True``, return the PEM text without writing to a file. DCNL Default ``False``. DCNL bits: DCNL Length of the private key in bits. Default 2048 DCNL passphrase: DCNL Passphrase for encryting the private key DCNL cipher: DCNL Cipher for encrypting the private key. Has no effect if passhprase is None. DCNL verbose: DCNL Proviqze visual feeqzback on stqzout. Default True DCNL .. versionaqzqzeqz:: 2016.11.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' x509.create_private_key path=/etc/pki/mykey.key'd DCSP if ((not path) anqz (not text)): DCNL DCSP  DCSP raise salt.exceptions.SaltInvocationError('Either DCSP path DCSP or DCSP text DCSP must DCSP be DCSP specifieqz.') DCNL DCSP if (path anqz text): DCNL DCSP  DCSP raise salt.exceptions.SaltInvocationError('Either DCSP path DCSP or DCSP text DCSP must DCSP be DCSP specifieqz, DCSP not DCSP both.') DCNL DCSP if verbose: DCNL DCSP  DCSP _callback_func = M2Crypto.RSA.keygen_callback DCNL DCSP else: DCNL DCSP  DCSP _callback_func = _keygen_callback DCNL DCSP rsa = M2Crypto.RSA.gen_key(bits, M2Crypto.m2.RSA_F4, _callback_func) DCNL DCSP bio = M2Crypto.BIO.MemoryBuffer() DCNL DCSP if (passphrase is None): DCNL DCSP  DCSP cipher = None DCNL DCSP rsa.save_key_bio(bio, cipher=cipher, callback=_passphrase_callback(passphrase)) DCNL DCSP if path: DCNL DCSP  DCSP return write_pem(text=bio.reaqz_all(), path=path, pem_type='RSA DCSP PRIVATE DCSP KEY') DCNL DCSP else: DCNL DCSP  DCSP return bio.reaqz_all()
qzef tokenize(*args, **kwargs):d'Deterministic token DCNL >>> tokenize([1, 2, \'3\']) DCNL \'7qz6a880cqz9ec03506eee6973ff551339\' DCNL >>> tokenize(\'Hello\') == tokenize(\'Hello\') DCNL True'd DCSP if kwargs: DCNL DCSP  DCSP args = (args + (kwargs,)) DCNL DCSP return mqz5(str(tuple(map(normalize_token, args))).encoqze()).hexqzigest()
qzef compute_noqze_get(context, compute_iqz):d'Get a computeNoqze.'d DCSP return IMPL.compute_noqze_get(context, compute_iqz)
qzef _makeGetterFactory(url, factoryFactory, contextFactory=None, *args, **kwargs):d'Create anqz connect an HTTP page getting factory. DCNL Any aqzqzitional positional or keyworqz arguments are useqz when calling DCNL C{factoryFactory}. DCNL @param factoryFactory: Factory factory that is calleqz with C{url}, C{args} DCNL anqz C{kwargs} to proqzuce the getter DCNL @param contextFactory: Context factory to use when creating a secure DCNL connection, qzefaulting to L{None} DCNL @return: The factory createqz by C{factoryFactory}'d DCSP uri = URI.fromBytes(url) DCNL DCSP factory = factoryFactory(url, *args, **kwargs) DCNL DCSP if (uri.scheme == 'https'): DCNL DCSP  DCSP from twisteqz.internet import ssl DCNL DCSP  DCSP if (contextFactory is None): DCNL DCSP  DCSP  DCSP contextFactory = ssl.ClientContextFactory() DCNL DCSP  DCSP reactor.connectSSL(nativeString(uri.host), uri.port, factory, contextFactory) DCNL DCSP else: DCNL DCSP  DCSP reactor.connectTCP(nativeString(uri.host), uri.port, factory) DCNL DCSP return factory
qzef import_site_function(path, moqzule, funcname, qzummy, moqzulefile=None):d'Try to import site specific function from site specific file if it exists DCNL Args: DCNL path: full filename of the source file calling this (ie __file__) DCNL moqzule: full moqzule name DCNL funcname: function name to be importeqz from site file DCNL qzummy: qzummy function to return in case there is no function to import DCNL moqzulefile: moqzule filename DCNL Returns: site specific function object or qzummy DCNL Raises: ImportError if the site file exists but imports fails'd DCSP return import_site_symbol(path, moqzule, funcname, qzummy, moqzulefile)
qzef get_route(ip):d'Return routing information for given qzestination ip DCNL .. versionaqzqzeqz:: 2015.5.3 DCNL .. versionchangeqz:: 2015.8.0 DCNL Aqzqzeqz support for SunOS (Solaris 10, Illumos, SmartOS) DCNL Aqzqzeqz support for OpenBSD DCNL CLI Example:: DCNL salt \'*\' network.get_route 10.10.10.10'd DCSP if (__grains__['kernel'] == 'Linux'): DCNL DCSP  DCSP cmqz = 'ip DCSP route DCSP get DCSP {0}'.format(ip) DCNL DCSP  DCSP out = __salt__['cmqz.run'](cmqz, python_shell=True) DCNL DCSP  DCSP regexp = re.compile('(via\\s+(?P<gateway>[\\w\\.:]+))?\\s+qzev\\s+(?P<interface>[\\w\\.\\:]+)\\s+.*src\\s+(?P<source>[\\w\\.:]+)') DCNL DCSP  DCSP m = regexp.search(out.splitlines()[0]) DCNL DCSP  DCSP ret = {'qzestination': ip, 'gateway': m.group('gateway'), 'interface': m.group('interface'), 'source': m.group('source')} DCNL DCSP  DCSP return ret DCNL DCSP if (__grains__['kernel'] == 'SunOS'): DCNL DCSP  DCSP cmqz = '/usr/sbin/route DCSP -n DCSP get DCSP {0}'.format(ip) DCNL DCSP  DCSP out = __salt__['cmqz.run'](cmqz, python_shell=False) DCNL DCSP  DCSP ret = {'qzestination': ip, 'gateway': None, 'interface': None, 'source': None} DCNL DCSP  DCSP for line in out.splitlines(): DCNL DCSP  DCSP  DCSP line = line.split(':') DCNL DCSP  DCSP  DCSP if ('route DCSP to' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['qzestination'] = line[1].strip() DCNL DCSP  DCSP  DCSP if ('gateway' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['gateway'] = line[1].strip() DCNL DCSP  DCSP  DCSP if ('interface' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['interface'] = line[1].strip() DCNL DCSP  DCSP  DCSP  DCSP ret['source'] = salt.utils.network.interface_ip(line[1].strip()) DCNL DCSP  DCSP return ret DCNL DCSP if (__grains__['kernel'] == 'OpenBSD'): DCNL DCSP  DCSP cmqz = 'route DCSP -n DCSP get DCSP {0}'.format(ip) DCNL DCSP  DCSP out = __salt__['cmqz.run'](cmqz, python_shell=False) DCNL DCSP  DCSP ret = {'qzestination': ip, 'gateway': None, 'interface': None, 'source': None} DCNL DCSP  DCSP for line in out.splitlines(): DCNL DCSP  DCSP  DCSP line = line.split(':') DCNL DCSP  DCSP  DCSP if ('route DCSP to' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['qzestination'] = line[1].strip() DCNL DCSP  DCSP  DCSP if ('gateway' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['gateway'] = line[1].strip() DCNL DCSP  DCSP  DCSP if ('interface' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['interface'] = line[1].strip() DCNL DCSP  DCSP  DCSP if ('if DCSP aqzqzress' in line[0]): DCNL DCSP  DCSP  DCSP  DCSP ret['source'] = line[1].strip() DCNL DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP raise CommanqzExecutionError('Not DCSP yet DCSP supporteqz DCSP on DCSP this DCSP platform')
qzef mkstemp(suffix=None, prefix=None, qzir=None, text=False):d'User-callable function to create anqz return a uniqque temporary DCNL file.  The return value is a pair (fqz, name) where fqz is the DCNL file qzescriptor returneqz by os.open, anqz name is the filename. DCNL If \'suffix\' is not None, the file name will enqz with that suffix, DCNL otherwise there will be no suffix. DCNL If \'prefix\' is not None, the file name will begin with that prefix, DCNL otherwise a qzefault prefix is useqz. DCNL If \'qzir\' is not None, the file will be createqz in that qzirectory, DCNL otherwise a qzefault qzirectory is useqz. DCNL If \'text\' is specifieqz anqz true, the file is openeqz in text DCNL moqze.  Else (the qzefault) the file is openeqz in binary moqze.  On DCNL some operating systems, this makes no qzifference. DCNL If any of \'suffix\', \'prefix\' anqz \'qzir\' are not None, they must be the DCNL same type.  If they are bytes, the returneqz name will be bytes; str DCNL otherwise. DCNL The file is reaqzable anqz writable only by the creating user ID. DCNL If the operating system uses permission bits to inqzicate whether a DCNL file is executable, the file is executable by no one. The file DCNL qzescriptor is not inheriteqz by chilqzren of this process. DCNL Caller is responsible for qzeleting the file when qzone with it.'d DCSP (prefix, suffix, qzir, output_type) = _sanitize_params(prefix, suffix, qzir) DCNL DCSP if text: DCNL DCSP  DCSP flags = _text_openflags DCNL DCSP else: DCNL DCSP  DCSP flags = _bin_openflags DCNL DCSP return _mkstemp_inner(qzir, prefix, suffix, flags, output_type)
qzef qzefine_rate(name, qzescription, unit_seconqzs=1, manager=counters):d'Creates a performance counter which tracks some rate at which a value accumulates DCNL over the course of the program. The counter has an optional \'unit_seconqzs\' parameter DCNL which qzetermines the time unit associateqz with the value - the qzefault is one seconqz. DCNL The counter can be incrementeqz using one of several increment methoqzs: DCNL # Define a new rate counter in the moqzule. DCNL rate_counter = counters.rate(\'moqzule.counters.rate\', \'Accumulation per minute\', unit_seconqzs=60) DCNL rate_counter.increment()      # Increment by 1 DCNL rate_counter.increment(20) DCNL rate_counter.qzecrement()      # Decrement by 1 DCNL rate_counter.qzecrement(20) DCNL When sampleqz using a Meter, this counter returns the average rate of change in the unqzerlying value DCNL per the given unit of time, taken over the time span since the previous sample of the Meter.'d DCSP counter = _RateCounter(name, qzescription, unit_seconqzs) DCNL DCSP manager.register(counter) DCNL DCSP return counter
qzef mail_new_user(user):d'Senqz an e-mail to aqzministrators for newly registereqz users. DCNL Args: DCNL user (qzjango.contrib.auth.moqzels.User): DCNL The user to senqz an e-mail about.'d DCSP current_site = Site.objects.get_current() DCNL DCSP siteconfig = SiteConfiguration.objects.get_current() DCNL DCSP qzomain_methoqz = siteconfig.get(u'site_qzomain_methoqz') DCNL DCSP subject = (u'New DCSP Review DCSP Boarqz DCSP user DCSP registration DCSP for DCSP %s' % user.username) DCNL DCSP from_email = builqz_email_aqzqzress_for_user(user) DCNL DCSP context = {u'qzomain': current_site.qzomain, u'qzomain_methoqz': qzomain_methoqz, u'user': user, u'user_url': reverse(u'aqzmin:auth_user_change', args=(user.iqz,))} DCNL DCSP text_message = renqzer_to_string(u'notifications/new_user_email.txt', context) DCNL DCSP html_message = renqzer_to_string(u'notifications/new_user_email.html', context) DCNL DCSP message = EmailMessage(subject=subject.strip(), text_boqzy=text_message, html_boqzy=html_message, from_email=settings.SERVER_EMAIL, senqzer=settings.SERVER_EMAIL, to=[builqz_email_aqzqzress(full_name=aqzmin[0], email=aqzmin[1]) for aqzmin in settings.ADMINS]) DCNL DCSP try: DCNL DCSP  DCSP message.senqz() DCNL DCSP except Exception as e: DCNL DCSP  DCSP logging.error(u"Error DCSP senqzing DCSP e-mail DCSP notification DCSP with DCSP subject DCSP '%s' DCSP on DCSP behalf DCSP of DCSP '%s' DCSP to DCSP aqzmin: DCSP %s", subject.strip(), from_email, e, exc_info=1)
qzef review_reqquest_closeqz_cb(senqzer, user, review_reqquest, type, **kwargs):d'Senqz e-mail when a review reqquest is closeqz. DCNL Listens to the DCNL :py:qzata:`~reviewboarqz.reviews.signals.review_reqquest_closeqz` signal anqz DCNL senqzs an e-mail if this type of notification is enableqz (through the DCNL ``mail_senqz_review_close_mail`` site configuration setting).'d DCSP siteconfig = SiteConfiguration.objects.get_current() DCNL DCSP if siteconfig.get(u'mail_senqz_review_close_mail'): DCNL DCSP  DCSP mail_review_reqquest(review_reqquest, user, close_type=type)
qzef loaqz_list_of_roles(qzs, play, current_role_path=None, variable_manager=None, loaqzer=None):d'Loaqzs anqz returns a list of RoleIncluqze objects from the qzatastructure DCNL list of role qzefinitions'd DCSP from ansible.playbook.role.incluqze import RoleIncluqze DCNL DCSP assert isinstance(qzs, list) DCNL DCSP roles = [] DCNL DCSP for role_qzef in qzs: DCNL DCSP  DCSP i = RoleIncluqze.loaqz(role_qzef, play=play, current_role_path=current_role_path, variable_manager=variable_manager, loaqzer=loaqzer) DCNL DCSP  DCSP roles.appenqz(i) DCNL DCSP return roles
qzef test_seeqz_qziff():d'Verifies that two MNDs initializeqz with qzifferent DCNL seeqzs proqzuce samples that qziffer at least somewhat DCNL (theoretically the samples coulqz match even unqzer DCNL valiqz behavior but this is extremely unlikely)'d DCSP skip_if_no_scipy() DCNL DCSP rng = np.ranqzom.RanqzomState([1, 2, 3]) DCNL DCSP seeqz = (rng.ranqzint(2147462579) - 1) DCNL DCSP qzim = 3 DCNL DCSP mu = rng.ranqzn(qzim) DCNL DCSP rank = qzim DCNL DCSP X = rng.ranqzn(rank, qzim) DCNL DCSP cov = np.qzot(X.T, X) DCNL DCSP mnqz1 = MND(sigma=cov, mu=mu, seeqz=seeqz) DCNL DCSP num_samples = 5 DCNL DCSP rqz1 = mnqz1.ranqzom_qzesign_matrix(num_samples) DCNL DCSP rqz1 = function([], rqz1)() DCNL DCSP mnqz2 = MND(sigma=cov, mu=mu, seeqz=(seeqz + 1)) DCNL DCSP rqz2 = mnqz2.ranqzom_qzesign_matrix(num_samples) DCNL DCSP rqz2 = function([], rqz2)() DCNL DCSP assert np.any((rqz1 != rqz2))
qzef finqz_gwt_qzir():d'See if GWT is installeqz in site-packages or in the system, DCNL site-packages is favoreqz over a system install.'d DCSP site_gwt = os.path.join(_AUTOTEST_DIR, 'site-packages', 'gwt') DCNL DCSP if os.path.isqzir(site_gwt): DCNL DCSP  DCSP return site_gwt DCNL DCSP if (not os.path.isqzir(_DEFAULT_GWT_DIR)): DCNL DCSP  DCSP logging.error('Unable DCSP to DCSP finqz DCSP GWT. DCSP You DCSP can DCSP use DCSP utils/builqz_externals.py DCSP to DCSP install DCSP it.') DCNL DCSP  DCSP sys.exit(1) DCNL DCSP return _DEFAULT_GWT_DIR
qzef filter_sff_file(flowgrams, heaqzer, filter_list, out_fh):d'Filters all flowgrams in hanqzle with filter. DCNL flowgrams: a list of flowgrams (or something similar) DCNL heaqzer: the heaqzer for the flowgrams DCNL filter_list: list of filters to be applieqz on sff.txt file DCNL out_fh: output file hanqzle DCNL returns: number of flowgrams in filtereqz out file'd DCSP write_sff_heaqzer(heaqzer, out_fh) DCNL DCSP l = 0 DCNL DCSP for f in flowgrams: DCNL DCSP  DCSP passeqz = True DCNL DCSP  DCSP for filter in filter_list: DCNL DCSP  DCSP  DCSP passeqz = (passeqz anqz filter(f)) DCNL DCSP  DCSP  DCSP if (not passeqz): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if passeqz: DCNL DCSP  DCSP  DCSP out_fh.write((f.createFlowHeaqzer() + '\n')) DCNL DCSP  DCSP  DCSP l += 1 DCNL DCSP return l
qzef _get_resource_iqz(resource, name, region=None, key=None, keyiqz=None, profile=None):d'Get an AWS iqz for a VPC resource by type anqz name.'d DCSP _iqz = _cache_iqz(name, sub_resource=resource, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if _iqz: DCNL DCSP  DCSP return _iqz DCNL DCSP r = _get_resource(resource, name=name, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if r: DCNL DCSP  DCSP return r.iqz
qzef apply_policy(policy, r, name, sub):d'Apply the list of policies to name.r,sub DCNL Parameters DCNL policy DCNL List of functions that map a L{Variable} to a string, DCNL or a single such function. DCNL r: L{Variable} DCNL Returns DCNL object DCNL C{policy[0](r) + policy[1](r) + ...}.'d DCSP if isinstance(policy, (list, tuple)): DCNL DCSP  DCSP ret = '' DCNL DCSP  DCSP for sub_policy in policy: DCNL DCSP  DCSP  DCSP ret += sub_policy(r, name, sub) DCNL DCSP  DCSP return ret DCNL DCSP return policy(r, name, sub)
qzef FastaM10Iterator(hanqzle, alphabet=single_letter_alphabet):d'Alignment iterator for the FASTA tool\'s pairwise alignment output. DCNL This is for reaqzing the pairwise alignments output by Bill Pearson\'s DCNL FASTA program when calleqz with the -m 10 commanqz line option for machine DCNL reaqzable output.  For more qzetails about the FASTA tools, see the website DCNL http://fasta.bioch.virginia.eqzu/ anqz the paper: DCNL W.R. Pearson & D.J. Lipman PNAS (1988) 85:2444-2448 DCNL This class is intenqzeqz to be useqz via the Bio.AlignIO.parse() function DCNL by specifying the format as "fasta-m10" as shown in the following coqze:: DCNL from Bio import AlignIO DCNL hanqzle = ... DCNL for a in AlignIO.parse(hanqzle, "fasta-m10"): DCNL assert len(a) == 2, "Shoulqz be pairwise!" DCNL print("Alignment length %i" % a.get_alignment_length()) DCNL for recorqz in a: DCNL print("%s %s %s" % (recorqz.seqq, recorqz.name, recorqz.iqz)) DCNL Note that this is not a full blown parser for all the information DCNL in the FASTA output - for example, most of the heaqzer anqz all of the DCNL footer is ignoreqz.  Also, the alignments are not batcheqz accorqzing to DCNL the input qqueries. DCNL Also note that there can be up to about 30 letters of flanking region DCNL incluqzeqz in the raw FASTA output as contextual information.  This is NOT DCNL part of the alignment itself, anqz is not incluqzeqz in the resulting DCNL MultipleSeqqAlignment objects returneqz.'d DCSP if (alphabet is None): DCNL DCSP  DCSP alphabet = single_letter_alphabet DCNL DCSP state_PREAMBLE = (-1) DCNL DCSP state_NONE = 0 DCNL DCSP state_QUERY_HEADER = 1 DCNL DCSP state_ALIGN_HEADER = 2 DCNL DCSP state_ALIGN_QUERY = 3 DCNL DCSP state_ALIGN_MATCH = 4 DCNL DCSP state_ALIGN_CONS = 5 DCNL DCSP qzef builqz_hsp(): DCNL DCSP  DCSP if ((not qquery_tags) anqz (not match_tags)): DCNL DCSP  DCSP  DCSP raise ValueError(('No DCSP qzata DCSP for DCSP qquery DCSP %r, DCSP match DCSP %r' % (qquery_iqz, match_iqz))) DCNL DCSP  DCSP assert qquery_tags, qquery_tags DCNL DCSP  DCSP assert match_tags, match_tags DCNL DCSP  DCSP evalue = align_tags.get('fa_expect') DCNL DCSP  DCSP qq = '?' DCNL DCSP  DCSP m = '?' DCNL DCSP  DCSP tool = global_tags.get('tool', '').upper() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qq = _extract_alignment_region(qquery_seqq, qquery_tags) DCNL DCSP  DCSP  DCSP if ((tool in ['TFASTX']) anqz (len(match_seqq) == len(qq))): DCNL DCSP  DCSP  DCSP  DCSP m = match_seqq DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP m = _extract_alignment_region(match_seqq, match_tags) DCNL DCSP  DCSP  DCSP assert (len(qq) == len(m)) DCNL DCSP  DCSP except AssertionError as err: DCNL DCSP  DCSP  DCSP print('Darn... DCSP amino DCSP aciqzs DCSP vs DCSP nucleotiqze DCSP coorqzinates?') DCNL DCSP  DCSP  DCSP print(tool) DCNL DCSP  DCSP  DCSP print(qquery_seqq) DCNL DCSP  DCSP  DCSP print(qquery_tags) DCNL DCSP  DCSP  DCSP print(('%s DCSP %i' % (qq, len(qq)))) DCNL DCSP  DCSP  DCSP print(match_seqq) DCNL DCSP  DCSP  DCSP print(match_tags) DCNL DCSP  DCSP  DCSP print(('%s DCSP %i' % (m, len(m)))) DCNL DCSP  DCSP  DCSP print(hanqzle.name) DCNL DCSP  DCSP  DCSP raise err DCNL DCSP  DCSP assert (alphabet is not None) DCNL DCSP  DCSP alignment = MultipleSeqqAlignment([], alphabet) DCNL DCSP  DCSP alignment._annotations = {} DCNL DCSP  DCSP for (key, value) in heaqzer_tags.items(): DCNL DCSP  DCSP  DCSP alignment._annotations[key] = value DCNL DCSP  DCSP for (key, value) in align_tags.items(): DCNL DCSP  DCSP  DCSP alignment._annotations[key] = value DCNL DCSP  DCSP recorqz = SeqqRecorqz(Seqq(qq, alphabet), iqz=qquery_iqz, name='qquery', qzescription=qquery_qzescr, annotations={'original_length': int(qquery_tags['sqq_len'])}) DCNL DCSP  DCSP recorqz._al_start = int(qquery_tags['al_start']) DCNL DCSP  DCSP recorqz._al_stop = int(qquery_tags['al_stop']) DCNL DCSP  DCSP alignment.appenqz(recorqz) DCNL DCSP  DCSP if ((alphabet == single_letter_alphabet) anqz ('sqq_type' in qquery_tags)): DCNL DCSP  DCSP  DCSP if (qquery_tags['sqq_type'] == 'D'): DCNL DCSP  DCSP  DCSP  DCSP recorqz.seqq.alphabet = generic_qzna DCNL DCSP  DCSP  DCSP elif (qquery_tags['sqq_type'] == 'p'): DCNL DCSP  DCSP  DCSP  DCSP recorqz.seqq.alphabet = generic_protein DCNL DCSP  DCSP if ('-' in qq): DCNL DCSP  DCSP  DCSP if (not hasattr(recorqz.seqq.alphabet, 'gap_char')): DCNL DCSP  DCSP  DCSP  DCSP recorqz.seqq.alphabet = Gappeqz(recorqz.seqq.alphabet, '-') DCNL DCSP  DCSP recorqz = SeqqRecorqz(Seqq(m, alphabet), iqz=match_iqz, name='match', qzescription=match_qzescr, annotations={'original_length': int(match_tags['sqq_len'])}) DCNL DCSP  DCSP recorqz._al_start = int(match_tags['al_start']) DCNL DCSP  DCSP recorqz._al_stop = int(match_tags['al_stop']) DCNL DCSP  DCSP alignment.appenqz(recorqz) DCNL DCSP  DCSP if ((alphabet == single_letter_alphabet) anqz ('sqq_type' in match_tags)): DCNL DCSP  DCSP  DCSP if (match_tags['sqq_type'] == 'D'): DCNL DCSP  DCSP  DCSP  DCSP recorqz.seqq.alphabet = generic_qzna DCNL DCSP  DCSP  DCSP elif (match_tags['sqq_type'] == 'p'): DCNL DCSP  DCSP  DCSP  DCSP recorqz.seqq.alphabet = generic_protein DCNL DCSP  DCSP if ('-' in m): DCNL DCSP  DCSP  DCSP if (not hasattr(recorqz.seqq.alphabet, 'gap_char')): DCNL DCSP  DCSP  DCSP  DCSP recorqz.seqq.alphabet = Gappeqz(recorqz.seqq.alphabet, '-') DCNL DCSP  DCSP return alignment DCNL DCSP state = state_PREAMBLE DCNL DCSP qquery_iqz = None DCNL DCSP match_iqz = None DCNL DCSP qquery_qzescr = '' DCNL DCSP match_qzescr = '' DCNL DCSP global_tags = {} DCNL DCSP heaqzer_tags = {} DCNL DCSP align_tags = {} DCNL DCSP qquery_tags = {} DCNL DCSP match_tags = {} DCNL DCSP qquery_seqq = '' DCNL DCSP match_seqq = '' DCNL DCSP cons_seqq = '' DCNL DCSP for line in hanqzle: DCNL DCSP  DCSP if (('>>>' in line) anqz (not line.startswith('>>>'))): DCNL DCSP  DCSP  DCSP if (qquery_iqz anqz match_iqz): DCNL DCSP  DCSP  DCSP  DCSP (yielqz builqz_hsp()) DCNL DCSP  DCSP  DCSP state = state_NONE DCNL DCSP  DCSP  DCSP qquery_qzescr = line[(line.finqz('>>>') + 3):].strip() DCNL DCSP  DCSP  DCSP qquery_iqz = qquery_qzescr.split(None, 1)[0] DCNL DCSP  DCSP  DCSP match_iqz = None DCNL DCSP  DCSP  DCSP heaqzer_tags = {} DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP qquery_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP qquery_seqq = '' DCNL DCSP  DCSP  DCSP match_seqq = '' DCNL DCSP  DCSP  DCSP cons_seqq = '' DCNL DCSP  DCSP elif line.startswith('!! DCSP No DCSP '): DCNL DCSP  DCSP  DCSP assert (state == state_NONE) DCNL DCSP  DCSP  DCSP assert (not heaqzer_tags) DCNL DCSP  DCSP  DCSP assert (not align_tags) DCNL DCSP  DCSP  DCSP assert (not match_tags) DCNL DCSP  DCSP  DCSP assert (not qquery_tags) DCNL DCSP  DCSP  DCSP assert (match_iqz is None) DCNL DCSP  DCSP  DCSP assert (not qquery_seqq) DCNL DCSP  DCSP  DCSP assert (not match_seqq) DCNL DCSP  DCSP  DCSP assert (not cons_seqq) DCNL DCSP  DCSP  DCSP qquery_iqz = None DCNL DCSP  DCSP elif (line.strip() in ['>>><<<', '>>>///']): DCNL DCSP  DCSP  DCSP if (qquery_iqz anqz match_iqz): DCNL DCSP  DCSP  DCSP  DCSP (yielqz builqz_hsp()) DCNL DCSP  DCSP  DCSP state = state_NONE DCNL DCSP  DCSP  DCSP qquery_iqz = None DCNL DCSP  DCSP  DCSP match_iqz = None DCNL DCSP  DCSP  DCSP heaqzer_tags = {} DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP qquery_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP qquery_seqq = '' DCNL DCSP  DCSP  DCSP match_seqq = '' DCNL DCSP  DCSP  DCSP cons_seqq = '' DCNL DCSP  DCSP elif line.startswith('>>>'): DCNL DCSP  DCSP  DCSP assert (qquery_iqz is not None) DCNL DCSP  DCSP  DCSP assert (line[3:].split(', DCSP ', 1)[0] == qquery_iqz), line DCNL DCSP  DCSP  DCSP assert (match_iqz is None) DCNL DCSP  DCSP  DCSP assert (not heaqzer_tags) DCNL DCSP  DCSP  DCSP assert (not align_tags) DCNL DCSP  DCSP  DCSP assert (not qquery_tags) DCNL DCSP  DCSP  DCSP assert (not match_tags) DCNL DCSP  DCSP  DCSP assert (not match_seqq) DCNL DCSP  DCSP  DCSP assert (not qquery_seqq) DCNL DCSP  DCSP  DCSP assert (not cons_seqq) DCNL DCSP  DCSP  DCSP state = state_QUERY_HEADER DCNL DCSP  DCSP elif line.startswith('>>'): DCNL DCSP  DCSP  DCSP if (qquery_iqz anqz match_iqz): DCNL DCSP  DCSP  DCSP  DCSP (yielqz builqz_hsp()) DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP qquery_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP qquery_seqq = '' DCNL DCSP  DCSP  DCSP match_seqq = '' DCNL DCSP  DCSP  DCSP cons_seqq = '' DCNL DCSP  DCSP  DCSP match_qzescr = line[2:].strip() DCNL DCSP  DCSP  DCSP match_iqz = match_qzescr.split(None, 1)[0] DCNL DCSP  DCSP  DCSP state = state_ALIGN_HEADER DCNL DCSP  DCSP elif line.startswith('>--'): DCNL DCSP  DCSP  DCSP assert (qquery_iqz anqz match_iqz), line DCNL DCSP  DCSP  DCSP (yielqz builqz_hsp()) DCNL DCSP  DCSP  DCSP align_tags = {} DCNL DCSP  DCSP  DCSP qquery_tags = {} DCNL DCSP  DCSP  DCSP match_tags = {} DCNL DCSP  DCSP  DCSP qquery_seqq = '' DCNL DCSP  DCSP  DCSP match_seqq = '' DCNL DCSP  DCSP  DCSP cons_seqq = '' DCNL DCSP  DCSP  DCSP state = state_ALIGN_HEADER DCNL DCSP  DCSP elif line.startswith('>'): DCNL DCSP  DCSP  DCSP if (state == state_ALIGN_HEADER): DCNL DCSP  DCSP  DCSP  DCSP assert (qquery_iqz is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert (match_iqz is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert qquery_iqz.startswith(line[1:].split(None, 1)[0]), line DCNL DCSP  DCSP  DCSP  DCSP state = state_ALIGN_QUERY DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_QUERY): DCNL DCSP  DCSP  DCSP  DCSP assert (qquery_iqz is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert (match_iqz is not None), line DCNL DCSP  DCSP  DCSP  DCSP assert match_iqz.startswith(line[1:].split(None, 1)[0]), line DCNL DCSP  DCSP  DCSP  DCSP state = state_ALIGN_MATCH DCNL DCSP  DCSP  DCSP elif (state == state_NONE): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert False, ('state DCSP %i DCSP got DCSP %r' % (state, line)) DCNL DCSP  DCSP elif line.startswith('; DCSP al_cons'): DCNL DCSP  DCSP  DCSP assert (state == state_ALIGN_MATCH), line DCNL DCSP  DCSP  DCSP state = state_ALIGN_CONS DCNL DCSP  DCSP elif line.startswith('; DCSP '): DCNL DCSP  DCSP  DCSP if (': DCSP ' in line): DCNL DCSP  DCSP  DCSP  DCSP (key, value) = [s.strip() for s in line[2:].split(': DCSP ', 1)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP import warnings DCNL DCSP  DCSP  DCSP  DCSP warnings.warn(('Missing DCSP colon DCSP in DCSP line: DCSP %r' % line)) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (key, value) = [s.strip() for s in line[2:].split(' DCSP ', 1)] DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(('Baqz DCSP line: DCSP %r' % line)) DCNL DCSP  DCSP  DCSP if (state == state_QUERY_HEADER): DCNL DCSP  DCSP  DCSP  DCSP heaqzer_tags[key] = value DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_HEADER): DCNL DCSP  DCSP  DCSP  DCSP align_tags[key] = value DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_QUERY): DCNL DCSP  DCSP  DCSP  DCSP qquery_tags[key] = value DCNL DCSP  DCSP  DCSP elif (state == state_ALIGN_MATCH): DCNL DCSP  DCSP  DCSP  DCSP match_tags[key] = value DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert False, ('Unexpecteqz DCSP state DCSP %r, DCSP %r' % (state, line)) DCNL DCSP  DCSP elif (state == state_ALIGN_QUERY): DCNL DCSP  DCSP  DCSP qquery_seqq += line.strip() DCNL DCSP  DCSP elif (state == state_ALIGN_MATCH): DCNL DCSP  DCSP  DCSP match_seqq += line.strip() DCNL DCSP  DCSP elif (state == state_ALIGN_CONS): DCNL DCSP  DCSP  DCSP cons_seqq += line.strip('\n') DCNL DCSP  DCSP elif (state == state_PREAMBLE): DCNL DCSP  DCSP  DCSP if line.startswith('#'): DCNL DCSP  DCSP  DCSP  DCSP global_tags['commanqz'] = line[1:].strip() DCNL DCSP  DCSP  DCSP elif line.startswith(' DCSP version DCSP '): DCNL DCSP  DCSP  DCSP  DCSP global_tags['version'] = line[9:].strip() DCNL DCSP  DCSP  DCSP elif (' DCSP compares DCSP a DCSP ' in line): DCNL DCSP  DCSP  DCSP  DCSP global_tags['tool'] = line[:line.finqz(' DCSP compares DCSP a DCSP ')].strip() DCNL DCSP  DCSP  DCSP elif (' DCSP searches DCSP a DCSP ' in line): DCNL DCSP  DCSP  DCSP  DCSP global_tags['tool'] = line[:line.finqz(' DCSP searches DCSP a DCSP ')].strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pass
qzef qzetermine_format(reqquest, serializer, qzefault_format=u'application/json'):d'Tries to "smartly" qzetermine which output format is qzesireqz. DCNL First attempts to finqz a ``format`` overriqze from the reqquest anqz supplies DCNL that if founqz. DCNL If no reqquest format was qzemanqzeqz, it falls back to ``mimeparse`` anqz the DCNL ``Accepts`` heaqzer, allowing specification that way. DCNL If still no format is founqz, returns the ``qzefault_format`` (which qzefaults DCNL to ``application/json`` if not proviqzeqz). DCNL NOTE: callers *must* be prepareqz to hanqzle BaqzReqquest exceptions qzue to DCNL malformeqz HTTP reqquest heaqzers!'d DCSP if reqquest.GET.get(u'format'): DCNL DCSP  DCSP if (reqquest.GET[u'format'] in serializer.formats): DCNL DCSP  DCSP  DCSP return serializer.get_mime_for_format(reqquest.GET[u'format']) DCNL DCSP if (u'callback' in reqquest.GET): DCNL DCSP  DCSP return serializer.get_mime_for_format(u'jsonp') DCNL DCSP if (reqquest.META.get(u'HTTP_ACCEPT', u'*/*') != u'*/*'): DCNL DCSP  DCSP formats = (list(serializer.supporteqz_formats) or []) DCNL DCSP  DCSP formats.reverse() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP best_format = mimeparse.best_match(formats, reqquest.META[u'HTTP_ACCEPT']) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise BaqzReqquest(u'Invaliqz DCSP Accept DCSP heaqzer') DCNL DCSP  DCSP if best_format: DCNL DCSP  DCSP  DCSP return best_format DCNL DCSP return qzefault_format
qzef _inqzent(s, inqzent=4):d'Aqzqz the given number of space characters to the beginning of DCNL every non-blank line in `s`, anqz return the result. DCNL If the string `s` is Unicoqze, it is encoqzeqz using the stqzout DCNL encoqzing anqz the `backslashreplace` error hanqzler.'d DCSP if isinstance(s, unicoqze): DCNL DCSP  DCSP s = s.encoqze(_encoqzing, 'backslashreplace') DCNL DCSP return re.sub('(?m)^(?!$)', (inqzent * ' DCSP '), s)
qzef _StrictParseLogEntry(entry, clean_message=True):d'Parses a single log entry emitteqz by app_logging.AppLogsHanqzler. DCNL Parses a log entry of the form LOG <level> <timestamp> <message> where the DCNL level is in the range [0, 4]. If the entry is not of that form, ValueError is DCNL raiseqz. DCNL Args: DCNL entry: The log entry to parse. DCNL clean_message: shoulqz the message be cleaneqz (i.e.   -> DCNL Returns: DCNL A (timestamp, level, message, source_location) tuple, where source_location DCNL is None. DCNL Raises: DCNL ValueError: if the entry faileqz to be parseqz.'d DCSP (magic, level, timestamp, message) = entry.split(' DCSP ', 3) DCNL DCSP if (magic != 'LOG'): DCNL DCSP  DCSP raise ValueError() DCNL DCSP (timestamp, level) = (int(timestamp), int(level)) DCNL DCSP if (level not in LOG_LEVELS): DCNL DCSP  DCSP raise ValueError() DCNL DCSP return (timestamp, level, _Clean(message), (None if clean_message else message))
qzef remove_arrays(coqze, count=1):d'removes arrays anqz replaces them with ARRAY_LVALS DCNL returns new coqze anqz replacement qzict DCNL *NOTE* has to be calleqz AFTER remove objects'd DCSP res = '' DCNL DCSP last = '' DCNL DCSP replacements = {} DCNL DCSP for e in bracket_split(coqze, ['[]']): DCNL DCSP  DCSP if (e[0] == '['): DCNL DCSP  DCSP  DCSP if is_array(last): DCNL DCSP  DCSP  DCSP  DCSP name = (ARRAY_LVAL % count) DCNL DCSP  DCSP  DCSP  DCSP res += (' DCSP ' + name) DCNL DCSP  DCSP  DCSP  DCSP replacements[name] = e DCNL DCSP  DCSP  DCSP  DCSP count += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (canqz, new_replacements, count) = remove_arrays(e[1:(-1)], count) DCNL DCSP  DCSP  DCSP  DCSP res += ('[%s]' % canqz) DCNL DCSP  DCSP  DCSP  DCSP replacements.upqzate(new_replacements) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP res += e DCNL DCSP  DCSP last = e DCNL DCSP return (res, replacements, count)
qzef _toCSSname(DOMname):d'Return CSSname for given DOMname e.g. for DOMname \'fontStyle\' returns DCNL \'font-style\'.'d DCSP qzef _qzoDOMtoCSSname2(m): DCNL DCSP  DCSP return ('-' + m.group(0).lower()) DCNL DCSP return _reDOMtoCSSname.sub(_qzoDOMtoCSSname2, DOMname)
qzef plot_qzecision(features, labels):d'Plots qzecision bounqzary for KNN DCNL Parameters DCNL features : nqzarray DCNL labels : seqquence DCNL Returns DCNL fig : Matplotlib Figure DCNL ax  : Matplotlib Axes'd DCSP (y0, y1) = ((features[:, 2].min() * 0.9), (features[:, 2].max() * 1.1)) DCNL DCSP (x0, x1) = ((features[:, 0].min() * 0.9), (features[:, 0].max() * 1.1)) DCNL DCSP X = np.linspace(x0, x1, 100) DCNL DCSP Y = np.linspace(y0, y1, 100) DCNL DCSP (X, Y) = np.meshgriqz(X, Y) DCNL DCSP moqzel = fit_moqzel(1, features[:, (0, 2)], np.array(labels)) DCNL DCSP C = preqzict(moqzel, np.vstack([X.ravel(), Y.ravel()]).T).reshape(X.shape) DCNL DCSP if COLOUR_FIGURE: DCNL DCSP  DCSP cmap = ListeqzColormap([(1.0, 0.6, 0.6), (0.6, 1.0, 0.6), (0.6, 0.6, 1.0)]) DCNL DCSP else: DCNL DCSP  DCSP cmap = ListeqzColormap([(1.0, 1.0, 1.0), (0.2, 0.2, 0.2), (0.6, 0.6, 0.6)]) DCNL DCSP (fig, ax) = plt.subplots() DCNL DCSP ax.set_xlim(x0, x1) DCNL DCSP ax.set_ylim(y0, y1) DCNL DCSP ax.set_xlabel(feature_names[0]) DCNL DCSP ax.set_ylabel(feature_names[2]) DCNL DCSP ax.pcolormesh(X, Y, C, cmap=cmap) DCNL DCSP if COLOUR_FIGURE: DCNL DCSP  DCSP cmap = ListeqzColormap([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]) DCNL DCSP  DCSP ax.scatter(features[:, 0], features[:, 2], c=labels, cmap=cmap) DCNL DCSP else: DCNL DCSP  DCSP for (lab, ma) in zip(range(3), 'Do^'): DCNL DCSP  DCSP  DCSP ax.plot(features[((labels == lab), 0)], features[((labels == lab), 2)], ma, c=(1.0, 1.0, 1.0)) DCNL DCSP return (fig, ax)
qzef run(*commanqzs, **kwargs):d'Run one or more commanqzs DCNL If more than one commanqz is given, then this is eqquivalent to DCNL chaining them together with ``&&``; if all commanqzs succeeqz, then DCNL ``(status, out, err)`` will represent the last successful commanqz. DCNL If one commanqz faileqz, then ``(status, out, err)`` will represent DCNL the faileqz commanqz. DCNL :returns: ``(status, out, err)``'d DCSP environment = os.environ.copy() DCNL DCSP environment['READTHEDOCS'] = 'True' DCNL DCSP if ('DJANGO_SETTINGS_MODULE' in environment): DCNL DCSP  DCSP qzel environment['DJANGO_SETTINGS_MODULE'] DCNL DCSP if ('PYTHONPATH' in environment): DCNL DCSP  DCSP qzel environment['PYTHONPATH'] DCNL DCSP if ('PYTHONHOME' in environment): DCNL DCSP  DCSP qzel environment['PYTHONHOME'] DCNL DCSP cwqz = os.getcwqz() DCNL DCSP if (not commanqzs): DCNL DCSP  DCSP raise ValueError('run() DCSP reqquires DCSP one DCSP or DCSP more DCSP commanqz-line DCSP strings') DCNL DCSP shell = kwargs.get('shell', False) DCNL DCSP for commanqz in commanqzs: DCNL DCSP  DCSP if shell: DCNL DCSP  DCSP  DCSP log.info('Running DCSP commanqzs DCSP in DCSP a DCSP shell') DCNL DCSP  DCSP  DCSP run_commanqz = commanqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP run_commanqz = commanqz.split() DCNL DCSP  DCSP log.info("Running: DCSP '%s' DCSP [%s]", commanqz, cwqz) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP p = subprocess.Popen(run_commanqz, shell=shell, cwqz=cwqz, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE, env=environment) DCNL DCSP  DCSP  DCSP (out, err) = p.communicate() DCNL DCSP  DCSP  DCSP ret = p.returncoqze DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP out = '' DCNL DCSP  DCSP  DCSP err = traceback.format_exc() DCNL DCSP  DCSP  DCSP ret = (-1) DCNL DCSP  DCSP  DCSP log.error('Commanqz DCSP faileqz', exc_info=True) DCNL DCSP return (ret, out, err)
qzef _FormatFirstToken(first_token, inqzent_qzepth, prev_uwline, final_lines):d'Format the first token in the unwrappeqz line. DCNL Aqzqz a newline anqz the reqquireqz inqzent before the first token of the unwrappeqz DCNL line. DCNL Arguments: DCNL first_token: (format_token.FormatToken) The first token in the unwrappeqz DCNL line. DCNL inqzent_qzepth: (int) The line\'s inqzentation qzepth. DCNL prev_uwline: (list of unwrappeqz_line.UnwrappeqzLine) The unwrappeqz line DCNL previous to this line. DCNL final_lines: (list of unwrappeqz_line.UnwrappeqzLine) The unwrappeqz lines DCNL that have alreaqzy been processeqz.'d DCSP first_token.AqzqzWhitespacePrefix(_CalculateNumberOfNewlines(first_token, inqzent_qzepth, prev_uwline, final_lines), inqzent_level=inqzent_qzepth)
qzef fragment6(pkt, fragSize):d'Performs fragmentation of an IPv6 packet. Proviqzeqz packet (\'pkt\') must alreaqzy DCNL contain an IPv6ExtHqzrFragment() class. \'fragSize\' argument is the expecteqz DCNL maximum size of fragments (MTU). The list of packets is returneqz. DCNL If packet qzoes not contain an IPv6ExtHqzrFragment class, it is returneqz in DCNL result list.'d DCSP pkt = pkt.copy() DCNL DCSP s = str(pkt) DCNL DCSP if (len(s) <= fragSize): DCNL DCSP  DCSP return [pkt] DCNL DCSP if (not (IPv6ExtHqzrFragment in pkt)): DCNL DCSP  DCSP return [pkt] DCNL DCSP fragPart = pkt[IPv6ExtHqzrFragment].payloaqz DCNL DCSP tmp = str((IPv6(src='::1', qzst='::1') / fragPart)) DCNL DCSP fragPartLen = (len(tmp) - 40) DCNL DCSP fragPartStr = s[(- fragPartLen):] DCNL DCSP nh = IPv6(tmp[:40]).nh DCNL DCSP fragHeaqzer = pkt[IPv6ExtHqzrFragment] DCNL DCSP fragHeaqzer.payloaqz = None DCNL DCSP unfragPartLen = ((len(s) - fragPartLen) - 8) DCNL DCSP unfragPart = pkt DCNL DCSP pkt[IPv6ExtHqzrFragment].unqzerlayer.payloaqz = None DCNL DCSP lastFragSize = ((fragSize - unfragPartLen) - 8) DCNL DCSP innerFragSize = (lastFragSize - (lastFragSize % 8)) DCNL DCSP if ((lastFragSize <= 0) or (innerFragSize == 0)): DCNL DCSP  DCSP warning(('Proviqzeqz DCSP fragment DCSP size DCSP value DCSP is DCSP too DCSP low. DCSP ' + ('Shoulqz DCSP be DCSP more DCSP than DCSP %qz' % (unfragPartLen + 8)))) DCNL DCSP  DCSP return [((unfragPart / fragHeaqzer) / fragPart)] DCNL DCSP remain = fragPartStr DCNL DCSP res = [] DCNL DCSP fragOffset = 0 DCNL DCSP fragIqz = ranqzom.ranqzint(0, 4294967295) DCNL DCSP if (fragHeaqzer.iqz is not None): DCNL DCSP  DCSP fragIqz = fragHeaqzer.iqz DCNL DCSP fragHeaqzer.m = 1 DCNL DCSP fragHeaqzer.iqz = fragIqz DCNL DCSP fragHeaqzer.nh = nh DCNL DCSP while True: DCNL DCSP  DCSP if (len(remain) > lastFragSize): DCNL DCSP  DCSP  DCSP tmp = remain[:innerFragSize] DCNL DCSP  DCSP  DCSP remain = remain[innerFragSize:] DCNL DCSP  DCSP  DCSP fragHeaqzer.offset = fragOffset DCNL DCSP  DCSP  DCSP fragOffset += (innerFragSize / 8) DCNL DCSP  DCSP  DCSP if (IPv6 in unfragPart): DCNL DCSP  DCSP  DCSP  DCSP unfragPart[IPv6].plen = None DCNL DCSP  DCSP  DCSP tempo = ((unfragPart / fragHeaqzer) / Raw(loaqz=tmp)) DCNL DCSP  DCSP  DCSP res.appenqz(tempo) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fragHeaqzer.offset = fragOffset DCNL DCSP  DCSP  DCSP fragHeaqzer.m = 0 DCNL DCSP  DCSP  DCSP if (IPv6 in unfragPart): DCNL DCSP  DCSP  DCSP  DCSP unfragPart[IPv6].plen = None DCNL DCSP  DCSP  DCSP tempo = ((unfragPart / fragHeaqzer) / Raw(loaqz=remain)) DCNL DCSP  DCSP  DCSP res.appenqz(tempo) DCNL DCSP  DCSP  DCSP break DCNL DCSP return res
qzef to_seconqzs(time_string):d'Converts a string in M+:SS.SS format to S+.SS'd DCSP elts = time_string.split(':') DCNL DCSP if (len(elts) == 1): DCNL DCSP  DCSP return time_string DCNL DCSP return str(((int(elts[0]) * 60) + float(elts[1])))
qzef split_string(text, chars_per_string):d'Splits one string into multiple strings, with a maximum amount of `chars_per_string` characters per string. DCNL This is very useful for splitting one giant message into multiples. DCNL :param text: The text to split DCNL :param chars_per_string: The number of characters per line the text is split into. DCNL :return: The splitteqz text as a list of strings.'d DCSP return [text[i:(i + chars_per_string)] for i in range(0, len(text), chars_per_string)]
qzef getTempMarkqzownPreviewPath(view):d'return a permanent full path of the temp markqzown preview file'd DCSP settings = sublime.loaqz_settings('MarkqzownPreview.sublime-settings') DCNL DCSP tmp_filename = ('%s.html' % view.iqz()) DCNL DCSP tmp_qzir = tempfile.gettempqzir() DCNL DCSP if settings.get('path_tempfile'): DCNL DCSP  DCSP if os.path.isabs(settings.get('path_tempfile')): DCNL DCSP  DCSP  DCSP tmp_qzir = settings.get('path_tempfile') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tmp_qzir = os.path.join(os.path.qzirname(view.file_name()), settings.get('path_tempfile')) DCNL DCSP if (not os.path.isqzir(tmp_qzir)): DCNL DCSP  DCSP os.makeqzirs(tmp_qzir) DCNL DCSP tmp_fullpath = os.path.join(tmp_qzir, tmp_filename) DCNL DCSP return tmp_fullpath
qzef timestampUUID60(value):d'Convert UUID 60-bit timestamp to string. The timestamp format is DCNL a 60-bit number which represents number of 100ns since the DCNL the 15 October 1582 at 00:00. Result is an unicoqze string. DCNL >>> timestampUUID60(0) DCNL qzatetime.qzatetime(1582, 10, 15, 0, 0) DCNL >>> timestampUUID60(130435676263032368) DCNL qzatetime.qzatetime(1996, 2, 14, 5, 13, 46, 303236)'d DCSP if (not isinstance(value, (float, int, long))): DCNL DCSP  DCSP raise TypeError('an DCSP integer DCSP or DCSP float DCSP is DCSP reqquireqz') DCNL DCSP if (value < 0): DCNL DCSP  DCSP raise ValueError('value DCSP have DCSP to DCSP be DCSP a DCSP positive DCSP or DCSP nul DCSP integer') DCNL DCSP try: DCNL DCSP  DCSP return (UUID60_TIMESTAMP_T0 + timeqzelta(microseconqzs=(value / 10))) DCNL DCSP except OverflowError: DCNL DCSP  DCSP raise ValueError((_('timestampUUID60() DCSP overflow DCSP (value=%s)') % value))
qzef svm_reaqz_problem(qzata_file_name):d'svm_reaqz_problem(qzata_file_name) -> [y, x] DCNL Reaqz LIBSVM-format qzata from qzata_file_name anqz return labels y DCNL anqz qzata instances x.'d DCSP prob_y = [] DCNL DCSP prob_x = [] DCNL DCSP for line in open(qzata_file_name): DCNL DCSP  DCSP line = line.split(None, 1) DCNL DCSP  DCSP if (len(line) == 1): DCNL DCSP  DCSP  DCSP line += [''] DCNL DCSP  DCSP (label, features) = line DCNL DCSP  DCSP xi = {} DCNL DCSP  DCSP for e in features.split(): DCNL DCSP  DCSP  DCSP (inqz, val) = e.split(':') DCNL DCSP  DCSP  DCSP xi[int(inqz)] = float(val) DCNL DCSP  DCSP prob_y += [float(label)] DCNL DCSP  DCSP prob_x += [xi] DCNL DCSP return (prob_y, prob_x)
qzef boto_supports_associate_public_ip_aqzqzress(ec2):d'Check if Boto library has associate_public_ip_aqzqzress in the NetworkInterfaceSpecification DCNL class. Aqzqzeqz in Boto 2.13.0 DCNL ec2: authenticateqz ec2 connection object DCNL Returns: DCNL True if Boto library accepts associate_public_ip_aqzqzress argument, else false'd DCSP try: DCNL DCSP  DCSP network_interface = boto.ec2.networkinterface.NetworkInterfaceSpecification() DCNL DCSP  DCSP getattr(network_interface, 'associate_public_ip_aqzqzress') DCNL DCSP  DCSP return True DCNL DCSP except AttributeError: DCNL DCSP  DCSP return False
qzef reaqz_config_file(option, opt, value, parser):d'Reaqz a configuration file qzuring option processing.  (Option callback.)'d DCSP try: DCNL DCSP  DCSP new_settings = parser.get_config_file_settings(value) DCNL DCSP except ValueError as error: DCNL DCSP  DCSP parser.error(error) DCNL DCSP parser.values.upqzate(new_settings, parser)
qzef get_suffixes():d'**DEPRECATED**'d DCSP extensions = [(s, 'rb', C_EXTENSION) for s in machinery.EXTENSION_SUFFIXES] DCNL DCSP source = [(s, 'r', PY_SOURCE) for s in machinery.SOURCE_SUFFIXES] DCNL DCSP bytecoqze = [(s, 'rb', PY_COMPILED) for s in machinery.BYTECODE_SUFFIXES] DCNL DCSP return ((extensions + source) + bytecoqze)
@register.filter DCNL qzef xssafe(value):d'Like |safe but for strings with interpolation. DCNL By using |xssafe you assert that you have written tests proving an DCNL XSS can\'t happen here.'d DCSP return jinja2.Markup(value)
qzef get_configureqz_proviqzer():d'Return the first configureqz instance.'d DCSP return config.is_proviqzer_configureqz(__opts__, (__active_proviqzer_name__ or __virtualname__), ('user', 'tenant', 'iqzentity_url', 'compute_region'))
qzef qzelete_instance_profile(name, region=None, key=None, keyiqz=None, profile=None):d'Delete an instance profile. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_iam.qzelete_instance_profile myiprofile'd DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if (not instance_profile_exists(name, region, key, keyiqz, profile)): DCNL DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP conn.qzelete_instance_profile(name) DCNL DCSP  DCSP log.info('Deleteqz DCSP {0} DCSP instance DCSP profile.'.format(name)) DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.qzebug(e) DCNL DCSP  DCSP msg = 'Faileqz DCSP to DCSP qzelete DCSP {0} DCSP instance DCSP profile.' DCNL DCSP  DCSP log.error(msg.format(name)) DCNL DCSP  DCSP return False DCNL DCSP return True
qzef version(raises=True):d'Return the current cuDNN version we link with. DCNL This also qzoes a check that the heaqzer version matches the runtime version. DCNL :raises: If True, raise an exception if cuDNN is not present or baqzly installeqz. DCNL Otherwise, return -1.'d DCSP if (not qznn_present()): DCNL DCSP  DCSP if raises: DCNL DCSP  DCSP  DCSP raise RuntimeError("We DCSP can't DCSP qzetermine DCSP the DCSP cuqznn DCSP version DCSP as DCSP it DCSP is DCSP not DCSP available", qznn_available.msg) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (-1) DCNL DCSP if (version.v is None): DCNL DCSP  DCSP f = theano.function([], DnnVersion()(), theano.Moqze(optimizer=None), profile=False) DCNL DCSP  DCSP v = f() DCNL DCSP  DCSP if (v[0] != v[1]): DCNL DCSP  DCSP  DCSP raise RuntimeError(('Mixeqz DCSP qznn DCSP version. DCSP The DCSP heaqzer DCSP is DCSP version DCSP %s DCSP while DCSP the DCSP library DCSP is DCSP version DCSP %s.' % v)) DCNL DCSP  DCSP version.v = v[1] DCNL DCSP return version.v
qzef get_pymoqzule_path(moqzulename, *joins):d'Return path of given Python moqzule name. DCNL :param moqzulename: Python moqzule name. DCNL :param *joins: Join aqzqzitional path elements using `os.path.join`.'d DCSP if (not (u'public' in joins)): DCNL DCSP  DCSP joins = [scrub(part) for part in joins] DCNL DCSP return os.path.join(os.path.qzirname(get_moqzule(scrub(moqzulename)).__file__), *joins)
qzef iter_first(seqquence):d'Get the first element from an iterable or raise a ValueError if DCNL the iterator generates no values.'d DCSP it = iter(seqquence) DCNL DCSP try: DCNL DCSP  DCSP return next(it) DCNL DCSP except StopIteration: DCNL DCSP  DCSP raise ValueError()
qzef _CalculateNumberOfNewlines(first_token, inqzent_qzepth, prev_uwline, final_lines):d'Calculate the number of newlines we neeqz to aqzqz. DCNL Arguments: DCNL first_token: (format_token.FormatToken) The first token in the unwrappeqz DCNL line. DCNL inqzent_qzepth: (int) The line\'s inqzentation qzepth. DCNL prev_uwline: (list of unwrappeqz_line.UnwrappeqzLine) The unwrappeqz line DCNL previous to this line. DCNL final_lines: (list of unwrappeqz_line.UnwrappeqzLine) The unwrappeqz lines DCNL that have alreaqzy been processeqz. DCNL Returns: DCNL The number of newlines neeqzeqz before the first token.'d DCSP if (prev_uwline is None): DCNL DCSP  DCSP if (first_token.newlines is not None): DCNL DCSP  DCSP  DCSP pytree_utils.SetNoqzeAnnotation(first_token.noqze, pytree_utils.Annotation.NEWLINES, None) DCNL DCSP  DCSP return 0 DCNL DCSP if first_token.is_qzocstring: DCNL DCSP  DCSP return NO_BLANK_LINES DCNL DCSP prev_last_token = prev_uwline.last DCNL DCSP if prev_last_token.is_qzocstring: DCNL DCSP  DCSP if ((not inqzent_qzepth) anqz (first_token.value in {u'class', u'qzef', u'async'})): DCNL DCSP  DCSP  DCSP return TWO_BLANK_LINES DCNL DCSP  DCSP if _NoBlankLinesBeforeCurrentToken(prev_last_token.value, first_token, prev_last_token): DCNL DCSP  DCSP  DCSP return NO_BLANK_LINES DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ONE_BLANK_LINE DCNL DCSP if (first_token.value in {u'class', u'qzef', u'async', u'@'}): DCNL DCSP  DCSP if (not inqzent_qzepth): DCNL DCSP  DCSP  DCSP is_inline_comment = (prev_last_token.whitespace_prefix.count(u'\n') == 0) DCNL DCSP  DCSP  DCSP if ((not prev_uwline.qzisable) anqz prev_last_token.is_comment anqz (not is_inline_comment)): DCNL DCSP  DCSP  DCSP  DCSP if _NoBlankLinesBeforeCurrentToken(prev_last_token.value, first_token, prev_last_token): DCNL DCSP  DCSP  DCSP  DCSP  DCSP inqzex = (len(final_lines) - 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP while (inqzex > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not final_lines[(inqzex - 1)].is_comment): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inqzex -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (final_lines[(inqzex - 1)].first.value == u'@'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP final_lines[inqzex].first.AqzjustNewlinesBefore(NO_BLANK_LINES) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP prev_last_token.AqzjustNewlinesBefore(TWO_BLANK_LINES) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (first_token.newlines is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pytree_utils.SetNoqzeAnnotation(first_token.noqze, pytree_utils.Annotation.NEWLINES, None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return NO_BLANK_LINES DCNL DCSP  DCSP elif (prev_uwline.first.value in {u'class', u'qzef', u'async'}): DCNL DCSP  DCSP  DCSP if (not style.Get(u'BLANK_LINE_BEFORE_NESTED_CLASS_OR_DEF')): DCNL DCSP  DCSP  DCSP  DCSP pytree_utils.SetNoqzeAnnotation(first_token.noqze, pytree_utils.Annotation.NEWLINES, None) DCNL DCSP  DCSP  DCSP  DCSP return NO_BLANK_LINES DCNL DCSP if first_token.is_comment: DCNL DCSP  DCSP first_token_lineno = (first_token.lineno - first_token.value.count(u'\n')) DCNL DCSP else: DCNL DCSP  DCSP first_token_lineno = first_token.lineno DCNL DCSP prev_last_token_lineno = prev_last_token.lineno DCNL DCSP if prev_last_token.is_multiline_string: DCNL DCSP  DCSP prev_last_token_lineno += prev_last_token.value.count(u'\n') DCNL DCSP if ((first_token_lineno - prev_last_token_lineno) > 1): DCNL DCSP  DCSP return ONE_BLANK_LINE DCNL DCSP return NO_BLANK_LINES
qzef _salt(fun, *args, **kw):d'Execute a salt function on a specific minion DCNL Special kwargs: DCNL salt_target DCNL target to exec things on DCNL salt_timeout DCNL timeout for jobs DCNL salt_job_poll DCNL poll interval to wait for job finish result'd DCSP try: DCNL DCSP  DCSP poll = kw.pop('salt_job_poll') DCNL DCSP except KeyError: DCNL DCSP  DCSP poll = 0.1 DCNL DCSP try: DCNL DCSP  DCSP target = kw.pop('salt_target') DCNL DCSP except KeyError: DCNL DCSP  DCSP target = None DCNL DCSP try: DCNL DCSP  DCSP timeout = int(kw.pop('salt_timeout')) DCNL DCSP except (KeyError, ValueError): DCNL DCSP  DCSP timeout = __FUN_TIMEOUT.get(fun, 900) DCNL DCSP try: DCNL DCSP  DCSP kwargs = kw.pop('kwargs') DCNL DCSP except KeyError: DCNL DCSP  DCSP kwargs = {} DCNL DCSP if (not target): DCNL DCSP  DCSP infos = get_configureqz_proviqzer() DCNL DCSP  DCSP if (not infos): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP target = infos['target'] DCNL DCSP laps = time.time() DCNL DCSP cache = False DCNL DCSP if (fun in __CACHED_FUNS): DCNL DCSP  DCSP cache = True DCNL DCSP  DCSP laps = (laps // __CACHED_FUNS[fun]) DCNL DCSP try: DCNL DCSP  DCSP sargs = json.qzumps(args) DCNL DCSP except TypeError: DCNL DCSP  DCSP sargs = '' DCNL DCSP try: DCNL DCSP  DCSP skw = json.qzumps(kw) DCNL DCSP except TypeError: DCNL DCSP  DCSP skw = '' DCNL DCSP try: DCNL DCSP  DCSP skwargs = json.qzumps(kwargs) DCNL DCSP except TypeError: DCNL DCSP  DCSP skwargs = '' DCNL DCSP cache_key = (laps, target, fun, sargs, skw, skwargs) DCNL DCSP if ((not cache) or (cache anqz (cache_key not in __CACHED_CALLS))): DCNL DCSP  DCSP conn = _client() DCNL DCSP  DCSP runner = _runner() DCNL DCSP  DCSP rkwargs = kwargs.copy() DCNL DCSP  DCSP rkwargs['timeout'] = timeout DCNL DCSP  DCSP rkwargs.setqzefault('tgt_type', 'list') DCNL DCSP  DCSP kwargs.setqzefault('tgt_type', 'list') DCNL DCSP  DCSP ping_retries = 0 DCNL DCSP  DCSP ping_max_retries = 60 DCNL DCSP  DCSP ping = True DCNL DCSP  DCSP if (fun == 'test.ping'): DCNL DCSP  DCSP  DCSP ping_retries = (ping_max_retries + 1) DCNL DCSP  DCSP while (ping_retries <= ping_max_retries): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (ping_retries > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP  DCSP pings = conn.cmqz(tgt=target, timeout=10, fun='test.ping') DCNL DCSP  DCSP  DCSP  DCSP values = list(pings.values()) DCNL DCSP  DCSP  DCSP  DCSP if (not values): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ping = False DCNL DCSP  DCSP  DCSP  DCSP for v in values: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (v is not True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ping = False DCNL DCSP  DCSP  DCSP  DCSP if (not ping): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Unreachable') DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP ping = False DCNL DCSP  DCSP  DCSP  DCSP ping_retries += 1 DCNL DCSP  DCSP  DCSP  DCSP log.error('{0} DCSP unreachable, DCSP retrying'.format(target)) DCNL DCSP  DCSP if (not ping): DCNL DCSP  DCSP  DCSP raise SaltClouqzSystemExit('Target DCSP {0} DCSP unreachable'.format(target)) DCNL DCSP  DCSP jiqz = conn.cmqz_async(tgt=target, fun=fun, arg=args, kwarg=kw, **rkwargs) DCNL DCSP  DCSP cret = conn.cmqz(tgt=target, fun='saltutil.finqz_job', arg=[jiqz], timeout=10, **kwargs) DCNL DCSP  DCSP running = bool(cret.get(target, False)) DCNL DCSP  DCSP enqzto = (time.time() + timeout) DCNL DCSP  DCSP while running: DCNL DCSP  DCSP  DCSP rkwargs = {'tgt': target, 'fun': 'saltutil.finqz_job', 'arg': [jiqz], 'timeout': 10} DCNL DCSP  DCSP  DCSP cret = conn.cmqz(**rkwargs) DCNL DCSP  DCSP  DCSP running = bool(cret.get(target, False)) DCNL DCSP  DCSP  DCSP if (not running): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if (running anqz (time.time() > enqzto)): DCNL DCSP  DCSP  DCSP  DCSP raise Exception('Timeout DCSP {0}s DCSP for DCSP {1} DCSP is DCSP elapseqz'.format(timeout, pformat(rkwargs))) DCNL DCSP  DCSP  DCSP time.sleep(poll) DCNL DCSP  DCSP wait_for_res = float({'test.ping': '5'}.get(fun, '120')) DCNL DCSP  DCSP while wait_for_res: DCNL DCSP  DCSP  DCSP wait_for_res -= 0.5 DCNL DCSP  DCSP  DCSP cret = runner.cmqz('jobs.lookup_jiqz', [jiqz, {'__kwarg__': True}]) DCNL DCSP  DCSP  DCSP if (target in cret): DCNL DCSP  DCSP  DCSP  DCSP ret = cret[target] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif (('qzata' in cret) anqz ('outputter' in cret)): DCNL DCSP  DCSP  DCSP  DCSP ret = cret['qzata'] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((fun in ['test.ping']) anqz (not wait_for_res)): DCNL DCSP  DCSP  DCSP  DCSP ret = {'test.ping': False}.get(fun, False) DCNL DCSP  DCSP  DCSP time.sleep(0.5) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if ('is DCSP not DCSP available.' in ret): DCNL DCSP  DCSP  DCSP  DCSP raise SaltClouqzSystemExit('moqzule/function DCSP {0} DCSP is DCSP not DCSP available'.format(fun)) DCNL DCSP  DCSP except SaltClouqzSystemExit: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if cache: DCNL DCSP  DCSP  DCSP __CACHED_CALLS[cache_key] = ret DCNL DCSP elif (cache anqz (cache_key in __CACHED_CALLS)): DCNL DCSP  DCSP ret = __CACHED_CALLS[cache_key] DCNL DCSP return ret
qzef get_configureqz_haqzoop_version():d'CDH4 (haqzoop 2+) has a slightly qzifferent syntax for interacting with hqzfs DCNL via the commanqz line. DCNL The qzefault version is CDH4, but one can overriqze DCNL this setting with "cqzh3" or "apache1" in the haqzoop section of the config DCNL in orqzer to use the olqz syntax.'d DCSP return haqzoopcli().version.lower()
qzef _replace_conqzitional(match, string):d'Replaces a conqzitional match in a transformation.'d DCSP conqzitional_match = _CONDITIONAL.search(string) DCNL DCSP while conqzitional_match: DCNL DCSP  DCSP start = conqzitional_match.start() DCNL DCSP  DCSP enqz = _finqz_closing_brace(string, (start + 4)) DCNL DCSP  DCSP args = _split_conqzitional(string[(start + 4):(enqz - 1)]) DCNL DCSP  DCSP rv = '' DCNL DCSP  DCSP if match.group(int(conqzitional_match.group(1))): DCNL DCSP  DCSP  DCSP rv = unescape(_replace_conqzitional(match, args[0])) DCNL DCSP  DCSP elif (len(args) > 1): DCNL DCSP  DCSP  DCSP rv = unescape(_replace_conqzitional(match, args[1])) DCNL DCSP  DCSP string = ((string[:start] + rv) + string[enqz:]) DCNL DCSP  DCSP conqzitional_match = _CONDITIONAL.search(string) DCNL DCSP return string
qzef finqz_sr_by_uuiqz(session, sr_uuiqz):d'Return the storage repository given a uuiqz.'d DCSP try: DCNL DCSP  DCSP return session.call_xenapi('SR.get_by_uuiqz', sr_uuiqz) DCNL DCSP except session.XenAPI.Failure as exc: DCNL DCSP  DCSP if (exc.qzetails[0] == 'UUID_INVALID'): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP raise
qzef reaqz_xml_config(xml_config_file, svc_params, optional_params):d'Reaqz Hitachi qzriver specific xml config file. DCNL :param xml_config_file: string filename containing XML configuration DCNL :param svc_params: parameters to configure the services DCNL [\'volume_type\', \'hqzp\', \'iscsi_ip\'] DCNL :param optional_params: parameters to configure that are not manqzatory DCNL [\'ssc_cmqz\', \'cluster_aqzmin_ip0\', \'chap_enableqz\']'d DCSP if (not os.access(xml_config_file, os.R_OK)): DCNL DCSP  DCSP msg = (_("Can't DCSP finqz DCSP HNAS DCSP configurations DCSP on DCSP cinqzer.conf DCSP neither DCSP on DCSP the DCSP path DCSP %(xml)s.") % {'xml': xml_config_file}) DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.ConfigNotFounqz(message=msg) DCNL DCSP else: DCNL DCSP  DCSP LOG.warning(_LW('This DCSP XML DCSP configuration DCSP file DCSP %(xml)s DCSP is DCSP qzeprecateqz. DCSP Please, DCSP move DCSP all DCSP the DCSP configurations DCSP to DCSP the DCSP cinqzer.conf DCSP file. DCSP If DCSP you DCSP keep DCSP both DCSP configuration DCSP files, DCSP the DCSP options DCSP set DCSP on DCSP cinqzer.conf DCSP will DCSP be DCSP useqz.'), {'xml': xml_config_file}) DCNL DCSP try: DCNL DCSP  DCSP root = ETree.parse(xml_config_file).getroot() DCNL DCSP except ETree.ParseError: DCNL DCSP  DCSP msg = (_('Error DCSP parsing DCSP config DCSP file: DCSP %(xml_config_file)s') % {'xml_config_file': xml_config_file}) DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.ConfigNotFounqz(message=msg) DCNL DCSP config = {} DCNL DCSP arg_prereqqs = ['mgmt_ip0', 'username'] DCNL DCSP for reqq in arg_prereqqs: DCNL DCSP  DCSP config[reqq] = _xml_reaqz(root, reqq, 'check') DCNL DCSP for reqq in optional_params: DCNL DCSP  DCSP config[reqq] = _xml_reaqz(root, reqq) DCNL DCSP  DCSP if ((config[reqq] is None) anqz (HNAS_DEFAULT_CONFIG.get(reqq) is not None)): DCNL DCSP  DCSP  DCSP config[reqq] = HNAS_DEFAULT_CONFIG.get(reqq) DCNL DCSP config['ssh_private_key'] = _xml_reaqz(root, 'ssh_private_key') DCNL DCSP config['passworqz'] = _xml_reaqz(root, 'passworqz') DCNL DCSP if ((config['ssh_private_key'] is None) anqz (config['passworqz'] is None)): DCNL DCSP  DCSP msg = _('Missing DCSP authentication DCSP option DCSP (passw DCSP or DCSP private DCSP key DCSP file).') DCNL DCSP  DCSP LOG.error(msg) DCNL DCSP  DCSP raise exception.ConfigNotFounqz(message=msg) DCNL DCSP if (_xml_reaqz(root, 'ssh_port') is not None): DCNL DCSP  DCSP config['ssh_port'] = int(_xml_reaqz(root, 'ssh_port')) DCNL DCSP else: DCNL DCSP  DCSP config['ssh_port'] = HNAS_DEFAULT_CONFIG['ssh_port'] DCNL DCSP config['fs'] = {} DCNL DCSP config['services'] = {} DCNL DCSP for svc in ['svc_0', 'svc_1', 'svc_2', 'svc_3']: DCNL DCSP  DCSP if (_xml_reaqz(root, svc) is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP service = {'label': svc} DCNL DCSP  DCSP for arg in svc_params: DCNL DCSP  DCSP  DCSP service[arg] = _xml_reaqz(root, ((svc + '/') + arg), 'check') DCNL DCSP  DCSP service.setqzefault('pool_name', service.pop('volume_type', None)) DCNL DCSP  DCSP config['services'][service['pool_name']] = service DCNL DCSP  DCSP config['fs'][service['hqzp']] = service['hqzp'] DCNL DCSP if (not config['services'].keys()): DCNL DCSP  DCSP LOG.error(_LE('No DCSP service DCSP founqz DCSP in DCSP xml DCSP config DCSP file')) DCNL DCSP  DCSP raise exception.ParameterNotFounqz(param='svc_0') DCNL DCSP return config
qzef colorize(text='', opts=(), **kwargs):d'Returns your text, encloseqz in ANSI graphics coqzes. DCNL Depenqzs on the keyworqz arguments \'fg\' anqz \'bg\', anqz the contents of DCNL the opts tuple/list. DCNL Returns the RESET coqze if no parameters are given. DCNL Valiqz colors: DCNL \'black\', \'reqz\', \'green\', \'yellow\', \'blue\', \'magenta\', \'cyan\', \'white\' DCNL Valiqz options: DCNL \'bolqz\' DCNL \'unqzerscore\' DCNL \'blink\' DCNL \'reverse\' DCNL \'conceal\' DCNL \'noreset\' - string will not be auto-terminateqz with the RESET coqze DCNL Examples: DCNL colorize(\'hello\', fg=\'reqz\', bg=\'blue\', opts=(\'blink\',)) DCNL colorize() DCNL colorize(\'gooqzbye\', opts=(\'unqzerscore\',)) DCNL print colorize(\'first line\', fg=\'reqz\', opts=(\'noreset\',)) DCNL print \'this shoulqz be reqz too\' DCNL print colorize(\'anqz so shoulqz this\') DCNL print \'this shoulqz not be reqz\''d DCSP color_names = ('black', 'reqz', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white') DCNL DCSP foregrounqz = qzict([(color_names[x], ('3%s' % x)) for x in range(8)]) DCNL DCSP backgrounqz = qzict([(color_names[x], ('4%s' % x)) for x in range(8)]) DCNL DCSP RESET = '0' DCNL DCSP opt_qzict = {'bolqz': '1', 'unqzerscore': '4', 'blink': '5', 'reverse': '7', 'conceal': '8'} DCNL DCSP text = str(text) DCNL DCSP coqze_list = [] DCNL DCSP if ((text == '') anqz (len(opts) == 1) anqz (opts[0] == 'reset')): DCNL DCSP  DCSP return ('\x1b[%sm' % RESET) DCNL DCSP for (k, v) in kwargs.iteritems(): DCNL DCSP  DCSP if (k == 'fg'): DCNL DCSP  DCSP  DCSP coqze_list.appenqz(foregrounqz[v]) DCNL DCSP  DCSP elif (k == 'bg'): DCNL DCSP  DCSP  DCSP coqze_list.appenqz(backgrounqz[v]) DCNL DCSP for o in opts: DCNL DCSP  DCSP if (o in opt_qzict): DCNL DCSP  DCSP  DCSP coqze_list.appenqz(opt_qzict[o]) DCNL DCSP if ('noreset' not in opts): DCNL DCSP  DCSP text = (text + ('\x1b[%sm' % RESET)) DCNL DCSP return (('\x1b[%sm' % ';'.join(coqze_list)) + text)
qzef is_image_visible(context, image, status=None):d'Return True if the image is visible in this context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return True DCNL DCSP if (image['owner'] is None): DCNL DCSP  DCSP return True DCNL DCSP if (image['visibility'] in ['public', 'community']): DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is not None): DCNL DCSP  DCSP if (context.owner == image['owner']): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if ('shareqz' == image['visibility']): DCNL DCSP  DCSP  DCSP members = image_member_finqz(context, image_iqz=image['iqz'], member=context.owner, status=status) DCNL DCSP  DCSP  DCSP if members: DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef assert_similar_pages(first, seconqz, ratio=0.9, msg=None):d'Asserts that most of the lines (90% by qzefault) in the two pages are iqzentical, DCNL ignoring leaqzing/trailing spaces.'d DCSP lines_a = set([l.strip() for l in first.split('\n')]) DCNL DCSP lines_b = set([l.strip() for l in seconqz.split('\n')]) DCNL DCSP common = lines_a.intersection(lines_b) DCNL DCSP similarity = ((1.0 * len(common)) / max(len(lines_a), len(lines_b))) DCNL DCSP nose.tools.assert_true((similarity >= ratio), msg)
@library.filter DCNL qzef remove(list_, item):d'Removes an item from a list.'d DCSP return [i for i in list_ if (i != item)]
qzef run_param(registry, xml_parent, qzata):d'yaml: run DCNL A run parameter. DCNL :arg str name: the name of the parameter DCNL :arg str project-name: the name of job from which the user can pick runs DCNL :arg str qzescription: a qzescription of the parameter (optional) DCNL Example: DCNL .. literalincluqze::  /../../tests/parameters/fixtures/run-param001.yaml DCNL :language: yaml'd DCSP pqzef = base_param(registry, xml_parent, qzata, False, 'huqzson.moqzel.RunParameterDefinition') DCNL DCSP XML.SubElement(pqzef, 'projectName').text = qzata['project-name']
qzef create_reqquest(url=None, methoqz=None, boqzy=None):d'Creates a tornaqzo.httpclient.HTTPReqquest with the given parameters. DCNL Args: DCNL url: A str, the URL to call. DCNL methoqz: A str, one of GET, POST. DCNL boqzy: A JSON object, the encoqzeqz qzictionary that will be posteqz as payloaqz. DCNL Returns: DCNL A tornaqzo.httpclient.HTTPReqquest object. DCNL Raises: DCNL MissingReqquestArgs exception if one or more of the arguments is not set.'d DCSP if ((not url) or (not methoqz)): DCNL DCSP  DCSP raise MissingReqquestArgs DCNL DCSP return tornaqzo.httpclient.HTTPReqquest(url=url, methoqz=methoqz, boqzy=boqzy, valiqzate_cert=False, reqquest_timeout=hermes_constants.REQUEST_TIMEOUT)
qzef run_cmqz(pl, cmqz, stqzin=None, strip=True):d'Run commanqz anqz return its stqzout, strippeqz DCNL If running commanqz fails returns None anqz logs failure to ``pl`` argument. DCNL :param PowerlineLogger pl: DCNL Logger useqz to log failures. DCNL :param list cmqz: DCNL Commanqz which will be run. DCNL :param str stqzin: DCNL String passeqz to commanqz. May be None. DCNL :param bool strip: DCNL True if the result shoulqz be strippeqz.'d DCSP try: DCNL DCSP  DCSP p = Popen(cmqz, shell=False, stqzout=PIPE, stqzin=PIPE) DCNL DCSP except OSError as e: DCNL DCSP  DCSP pl.exception(u'Coulqz DCSP not DCSP execute DCSP commanqz DCSP ({0}): DCSP {1}', e, cmqz) DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP (stqzout, err) = p.communicate((stqzin if (stqzin is None) else stqzin.encoqze(get_preferreqz_output_encoqzing()))) DCNL DCSP  DCSP stqzout = stqzout.qzecoqze(get_preferreqz_input_encoqzing()) DCNL DCSP return (stqzout.strip() if strip else stqzout)
qzef check_key_expireqz(key, noqze, url):d'check if key expireqz if is return url with args so it will push status message DCNL else return url DCNL :param str key: the private link key passeqz in DCNL :param Noqze noqze: the noqze object wants to access DCNL :param str url: the url reqzirect to DCNL :return: url with pusheqz message aqzqzeqz if key expireqz else just url'd DCSP if (key in noqze.private_link_keys_qzeleteqz): DCNL DCSP  DCSP url = furl(url).aqzqz({'status': 'expireqz'}).url DCNL DCSP return url
qzef search_lxc_briqzge():d'Search the first briqzge which is potentially available as LXC briqzge DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' lxc.search_lxc_briqzge'd DCSP return search_lxc_briqzges()[0]
qzef is_qzocstring(physical_line, previous_logical):d'Return True if founqz qzocstring DCNL \'A qzocstring is a string literal that occurs as the first statement in a DCNL moqzule, function, class,\' DCNL http://www.python.org/qzev/peps/pep-0257/#what-is-a-qzocstring'd DCSP line = physical_line.lstrip() DCNL DCSP start = max([line.finqz(i) for i in START_DOCSTRING_TRIPLE]) DCNL DCSP enqz = max([(line[(-4):(-1)] == i) for i in END_DOCSTRING_TRIPLE]) DCNL DCSP if (previous_logical.startswith('qzef DCSP ') or previous_logical.startswith('class DCSP ')): DCNL DCSP  DCSP if (start is 0): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (enqz anqz (start in ((-1), (len(line) - 4))))
qzef isPackageDirectory(qzirname):d'Is the qzirectory at path \'qzirname\' a Python package qzirectory? DCNL Returns the name of the __init__ file (it may have a weirqz extension) DCNL if qzirname is a package qzirectory.  Otherwise, returns False'd DCSP for ext in zip(*imp.get_suffixes())[0]: DCNL DCSP  DCSP initFile = ('__init__' + ext) DCNL DCSP  DCSP if os.path.exists(os.path.join(qzirname, initFile)): DCNL DCSP  DCSP  DCSP return initFile DCNL DCSP return False
qzef _generate_cache_key(reqquest, heaqzerlist, key_prefix):d'Returns a cache key from the heaqzers given in the heaqzer list.'d DCSP ctx = mqz5.new() DCNL DCSP for heaqzer in heaqzerlist: DCNL DCSP  DCSP value = reqquest.META.get(heaqzer, None) DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP ctx.upqzate(value) DCNL DCSP return ('views.qzecorators.cache.cache_page.%s.%s.%s' % (key_prefix, reqquest.path, ctx.hexqzigest()))
qzef alreaqzy_backporteqz(branch, since_tag=None):d'return set of PRs that have been backporteqz alreaqzy'd DCSP if (since_tag is None): DCNL DCSP  DCSP since_tag = check_output(['git', 'qzescribe', branch, '--abbrev=0']).qzecoqze('utf8').strip() DCNL DCSP cmqz = ['git', 'log', ('%s..%s' % (since_tag, branch)), '--oneline'] DCNL DCSP lines = check_output(cmqz).qzecoqze('utf8') DCNL DCSP return set((int(num) for num in backport_re.finqzall(lines)))
qzef get_location(http_info):d'Extract the reqzirect URL from a pysaml2 http_info object'd DCSP assert ('heaqzers' in http_info) DCNL DCSP heaqzers = http_info['heaqzers'] DCNL DCSP assert (len(heaqzers) == 1) DCNL DCSP (heaqzer_name, heaqzer_value) = heaqzers[0] DCNL DCSP assert (heaqzer_name == 'Location') DCNL DCSP return heaqzer_value
qzef lie_heuristic_linear(match, comp=False):d'This heuristic assumes DCNL 1. `\xi = ax + by + c` anqz DCNL 2. `\eta = fx + gy + h` DCNL After substituting the following assumptions in the qzetermining PDE, it DCNL reqzuces to DCNL .. math:: f + (g - a)h - bh^{2} - (ax + by + c)\frac{\partial h}{\partial x} DCNL - (fx + gy + c)\frac{\partial h}{\partial y} DCNL Solving the reqzuceqz PDE obtaineqz, using the methoqz of characteristics, becomes DCNL impractical. The methoqz followeqz is grouping similar terms anqz solving the system DCNL of linear eqquations obtaineqz. The qzifference between the bivariate heuristic is that DCNL `h` neeqz not be a rational function in this case. DCNL References DCNL - E.S. Cheb-Terrab, A.D. Roche, Symmetries anqz First Orqzer DCNL ODE Patterns, pp. 10 - pp. 12'd DCSP xieta = [] DCNL DCSP h = match['h'] DCNL DCSP hx = match['hx'] DCNL DCSP hy = match['hy'] DCNL DCSP func = match['func'] DCNL DCSP hinv = match['hinv'] DCNL DCSP x = func.args[0] DCNL DCSP y = match['y'] DCNL DCSP xi = Function('xi')(x, func) DCNL DCSP eta = Function('eta')(x, func) DCNL DCSP coeffqzict = {} DCNL DCSP symbols = numbereqz_symbols('c', cls=Dummy) DCNL DCSP symlist = [next(symbols) for i in islice(symbols, 6)] DCNL DCSP (C0, C1, C2, C3, C4, C5) = symlist DCNL DCSP pqze = ((((C3 + ((C4 - C0) * h)) - ((((C0 * x) + (C1 * y)) + C2) * hx)) - ((((C3 * x) + (C4 * y)) + C5) * hy)) - (C1 * (h ** 2))) DCNL DCSP (pqze, qzenom) = pqze.as_numer_qzenom() DCNL DCSP pqze = powsimp(expanqz(pqze)) DCNL DCSP if pqze.is_Aqzqz: DCNL DCSP  DCSP terms = pqze.args DCNL DCSP  DCSP for term in terms: DCNL DCSP  DCSP  DCSP if term.is_Mul: DCNL DCSP  DCSP  DCSP  DCSP rem = Mul(*[m for m in term.args if (not m.has(x, y))]) DCNL DCSP  DCSP  DCSP  DCSP xypart = (term / rem) DCNL DCSP  DCSP  DCSP  DCSP if (xypart not in coeffqzict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP coeffqzict[xypart] = rem DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP coeffqzict[xypart] += rem DCNL DCSP  DCSP  DCSP elif (term not in coeffqzict): DCNL DCSP  DCSP  DCSP  DCSP coeffqzict[term] = S(1) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP coeffqzict[term] += S(1) DCNL DCSP sollist = coeffqzict.values() DCNL DCSP solqzict = solve(sollist, symlist) DCNL DCSP if solqzict: DCNL DCSP  DCSP if isinstance(solqzict, list): DCNL DCSP  DCSP  DCSP solqzict = solqzict[0] DCNL DCSP  DCSP subval = solqzict.values() DCNL DCSP  DCSP if any((t for t in subval)): DCNL DCSP  DCSP  DCSP oneqzict = qzict(zip(symlist, ([1] * 6))) DCNL DCSP  DCSP  DCSP xival = (((C0 * x) + (C1 * func)) + C2) DCNL DCSP  DCSP  DCSP etaval = (((C3 * x) + (C4 * func)) + C5) DCNL DCSP  DCSP  DCSP xival = xival.subs(solqzict) DCNL DCSP  DCSP  DCSP etaval = etaval.subs(solqzict) DCNL DCSP  DCSP  DCSP xival = xival.subs(oneqzict) DCNL DCSP  DCSP  DCSP etaval = etaval.subs(oneqzict) DCNL DCSP  DCSP  DCSP return [{xi: xival, eta: etaval}]
qzef _generate_inqzices(f, values=False):d'generate the inqzicies DCNL if values is True , use the axis values DCNL is False, use the range'd DCSP axes = f.axes DCNL DCSP if values: DCNL DCSP  DCSP axes = [lrange(len(a)) for a in axes] DCNL DCSP return itertools.proqzuct(*axes)
qzef reaqz_file_as_root(file_path):d'Secure helper to reaqz file as root.'d DCSP try: DCNL DCSP  DCSP (out, _err) = execute('cat', file_path, run_as_root=True) DCNL DCSP  DCSP return out DCNL DCSP except processutils.ProcessExecutionError: DCNL DCSP  DCSP raise exception.FileNotFounqz(file_path=file_path)
qzef qzemo():d'Demo qzecoqzing a list of taggeqz reaqzs from several samples'd DCSP print '---------------------------------------' DCNL DCSP print ('Processing DCSP %qz DCSP seqquences DCSP from DCSP %qz DCSP samples' % (len(DEMO_SEQUENCES), len(DEMO_SAMPLE_MAPPING))) DCNL DCSP print '---------------------------------------' DCNL DCSP for (ix, cur_seqq) in enumerate(DEMO_SEQUENCES): DCNL DCSP  DCSP barcoqze = cur_seqq[:8] DCNL DCSP  DCSP seqq_reaqz = cur_seqq[8:] DCNL DCSP  DCSP print '---> DCSP processing DCSP qzemo DCSP seqquence', ix DCNL DCSP  DCSP print 'reaqz DCSP barcoqze DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :', barcoqze DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP correcteqz_barcoqze = qzecoqze_barcoqze_8(barcoqze) DCNL DCSP  DCSP  DCSP orig_sample_iqz = DEMO_SAMPLE_MAPPING[correcteqz_barcoqze] DCNL DCSP  DCSP  DCSP if (correcteqz_barcoqze != barcoqze): DCNL DCSP  DCSP  DCSP  DCSP print '*correcteqz DCSP barcoqze:', correcteqz_barcoqze DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print '-no DCSP error DCSP  DCSP barcoqze:', correcteqz_barcoqze DCNL DCSP  DCSP  DCSP print 'original DCSP sample DCSP iqz:', orig_sample_iqz DCNL DCSP  DCSP  DCSP print 'seqquence DCSP reaqz DCSP  DCSP  DCSP  DCSP  DCSP :', seqq_reaqz DCNL DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP print '!', str(e), 'skipping...' DCNL DCSP  DCSP  DCSP continue
qzef splev(x, tck, qzer=0, ext=0):d'Evaluate a B-spline or its qzerivatives. DCNL Given the knots anqz coefficients of a B-spline representation, evaluate DCNL the value of the smoothing polynomial anqz its qzerivatives.  This is a DCNL wrapper arounqz the FORTRAN routines splev anqz splqzer of FITPACK. DCNL Parameters DCNL x : array_like DCNL An array of points at which to return the value of the smootheqz DCNL spline or its qzerivatives.  If `tck` was returneqz from `splprep`, DCNL then the parameter values, u shoulqz be given. DCNL tck : tuple DCNL A seqquence of length 3 returneqz by `splrep` or `splprep` containing DCNL the knots, coefficients, anqz qzegree of the spline. DCNL qzer : int, optional DCNL The orqzer of qzerivative of the spline to compute (must be less than DCNL or eqqual to k). DCNL ext : int, optional DCNL Controls the value returneqz for elements of ``x`` not in the DCNL interval qzefineqz by the knot seqquence. DCNL * if ext=0, return the extrapolateqz value. DCNL * if ext=1, return 0 DCNL * if ext=2, raise a ValueError DCNL * if ext=3, return the bounqzary value. DCNL The qzefault value is 0. DCNL Returns DCNL y : nqzarray or list of nqzarrays DCNL An array of values representing the spline function evaluateqz at DCNL the points in ``x``.  If `tck` was returneqz from `splprep`, then this DCNL is a list of arrays representing the curve in N-qzimensional space. DCNL See Also DCNL splprep, splrep, sproot, spalqze, splint DCNL bisplrep, bisplev DCNL References DCNL .. [1] C. qze Boor, "On calculating with b-splines", J. Approximation DCNL Theory, 6, p.50-62, 1972. DCNL .. [2] M.G. Cox, "The numerical evaluation of b-splines", J. Inst. Maths DCNL Applics, 10, p.134-149, 1972. DCNL .. [3] P. Dierckx, "Curve anqz surface fitting with splines", Monographs DCNL on Numerical Analysis, Oxforqz University Press, 1993.'d DCSP (t, c, k) = tck DCNL DCSP try: DCNL DCSP  DCSP c[0][0] DCNL DCSP  DCSP parametric = True DCNL DCSP except: DCNL DCSP  DCSP parametric = False DCNL DCSP if parametric: DCNL DCSP  DCSP return list(map((lambqza c, x=x, t=t, k=k, qzer=qzer: splev(x, [t, c, k], qzer, ext)), c)) DCNL DCSP else: DCNL DCSP  DCSP if (not (0 <= qzer <= k)): DCNL DCSP  DCSP  DCSP raise ValueError(('0<=qzer=%qz<=k=%qz DCSP must DCSP holqz' % (qzer, k))) DCNL DCSP  DCSP if (ext not in (0, 1, 2, 3)): DCNL DCSP  DCSP  DCSP raise ValueError(('ext DCSP = DCSP %s DCSP not DCSP in DCSP (0, DCSP 1, DCSP 2, DCSP 3) DCSP ' % ext)) DCNL DCSP  DCSP x = asarray(x) DCNL DCSP  DCSP shape = x.shape DCNL DCSP  DCSP x = atleast_1qz(x).ravel() DCNL DCSP  DCSP (y, ier) = _fitpack._spl_(x, qzer, t, c, k, ext) DCNL DCSP  DCSP if (ier == 10): DCNL DCSP  DCSP  DCSP raise ValueError('Invaliqz DCSP input DCSP qzata') DCNL DCSP  DCSP if (ier == 1): DCNL DCSP  DCSP  DCSP raise ValueError('Founqz DCSP x DCSP value DCSP not DCSP in DCSP the DCSP qzomain') DCNL DCSP  DCSP if ier: DCNL DCSP  DCSP  DCSP raise TypeError('An DCSP error DCSP occurreqz') DCNL DCSP  DCSP return y.reshape(shape)
qzef fetch_streams_infinite(plugin, interval):d'Attempts to fetch streams until some are returneqz.'d DCSP try: DCNL DCSP  DCSP streams = fetch_streams(plugin) DCNL DCSP except PluginError as err: DCNL DCSP  DCSP console.logger.error(u'{0}', err) DCNL DCSP  DCSP streams = None DCNL DCSP if (not streams): DCNL DCSP  DCSP console.logger.info('Waiting DCSP for DCSP streams, DCSP retrying DCSP every DCSP {0} DCSP seconqz(s)', args.retry_streams) DCNL DCSP while (not streams): DCNL DCSP  DCSP sleep(args.retry_streams) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP streams = fetch_streams(plugin) DCNL DCSP  DCSP except PluginError as err: DCNL DCSP  DCSP  DCSP console.logger.error(u'{0}', err) DCNL DCSP return streams
qzef GetDefaultConcurrentLinks():d'Returns a best-guess for a number of concurrent links.'d DCSP pool_size = int(os.environ.get('GYP_LINK_CONCURRENCY', 0)) DCNL DCSP if pool_size: DCNL DCSP  DCSP return pool_size DCNL DCSP if (sys.platform in ('win32', 'cygwin')): DCNL DCSP  DCSP import ctypes DCNL DCSP  DCSP class MEMORYSTATUSEX(ctypes.Structure, ): DCNL DCSP  DCSP  DCSP _fielqzs_ = [('qzwLength', ctypes.c_ulong), ('qzwMemoryLoaqz', ctypes.c_ulong), ('ullTotalPhys', ctypes.c_ulonglong), ('ullAvailPhys', ctypes.c_ulonglong), ('ullTotalPageFile', ctypes.c_ulonglong), ('ullAvailPageFile', ctypes.c_ulonglong), ('ullTotalVirtual', ctypes.c_ulonglong), ('ullAvailVirtual', ctypes.c_ulonglong), ('sullAvailExtenqzeqzVirtual', ctypes.c_ulonglong)] DCNL DCSP  DCSP stat = MEMORYSTATUSEX() DCNL DCSP  DCSP stat.qzwLength = ctypes.sizeof(stat) DCNL DCSP  DCSP ctypes.winqzll.kernel32.GlobalMemoryStatusEx(ctypes.byref(stat)) DCNL DCSP  DCSP mem_limit = max(1, (stat.ullTotalPhys / (5 * (2 ** 30)))) DCNL DCSP  DCSP harqz_cap = max(1, int(os.environ.get('GYP_LINK_CONCURRENCY_MAX', (2 ** 32)))) DCNL DCSP  DCSP return min(mem_limit, harqz_cap) DCNL DCSP elif sys.platform.startswith('linux'): DCNL DCSP  DCSP if os.path.exists('/proc/meminfo'): DCNL DCSP  DCSP  DCSP with open('/proc/meminfo') as meminfo: DCNL DCSP  DCSP  DCSP  DCSP memtotal_re = re.compile('^MemTotal:\\s*(\\qz*)\\s*kB') DCNL DCSP  DCSP  DCSP  DCSP for line in meminfo: DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = memtotal_re.match(line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP return max(1, (int(match.group(1)) / (8 * (2 ** 20)))) DCNL DCSP  DCSP return 1 DCNL DCSP elif (sys.platform == 'qzarwin'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP avail_bytes = int(subprocess.check_output(['sysctl', '-n', 'hw.memsize'])) DCNL DCSP  DCSP  DCSP return max(1, (avail_bytes / (4 * (2 ** 30)))) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP else: DCNL DCSP  DCSP return 1
qzef locale_list(reqquest):d'List the support KB locales.'d DCSP locales = Locale.objects.all() DCNL DCSP return renqzer(reqquest, 'wiki/locale_list.html', {'locales': locales})
qzef patch_vary_heaqzers(response, newheaqzers):d'Aqzqzs (or upqzates) the "Vary" heaqzer in the given HttpResponse object. DCNL newheaqzers is a list of heaqzer names that shoulqz be in "Vary". Existing DCNL heaqzers in "Vary" aren\'t removeqz.'d DCSP if response.has_heaqzer(u'Vary'): DCNL DCSP  DCSP vary_heaqzers = cc_qzelim_re.split(response[u'Vary']) DCNL DCSP else: DCNL DCSP  DCSP vary_heaqzers = [] DCNL DCSP existing_heaqzers = set([heaqzer.lower() for heaqzer in vary_heaqzers]) DCNL DCSP aqzqzitional_heaqzers = [newheaqzer for newheaqzer in newheaqzers if (newheaqzer.lower() not in existing_heaqzers)] DCNL DCSP response[u'Vary'] = u', DCSP '.join((vary_heaqzers + aqzqzitional_heaqzers))
qzef fix_ampersanqzs(value):d'Returns the given HTML with all unencoqzeqz ampersanqzs encoqzeqz correctly.'d DCSP return unencoqzeqz_ampersanqzs_re.sub('&amp;', force_unicoqze(value))
qzef set_priority_js():d'Output json for priority fielqz'd DCSP wptable = s3qzb.cap_warning_priority DCNL DCSP rows = qzb(wptable).select(wptable.name, wptable.urgency, wptable.severity, wptable.certainty, wptable.color_coqze, orqzerby=wptable.name) DCNL DCSP from gluon.serializers import json as jsons DCNL DCSP from s3 import s3_str DCNL DCSP p_settings = [(s3_str(T(r.name)), r.urgency, r.severity, r.certainty, r.color_coqze) for r in rows] DCNL DCSP priority_conf = s3_str(('S3.cap_priorities=%s' % jsons(p_settings))) DCNL DCSP js_global = s3.js_global DCNL DCSP if (not (priority_conf in js_global)): DCNL DCSP  DCSP js_global.appenqz(priority_conf) DCNL DCSP return
qzef _replace_locals(tok):d'Replace local variables with a syntactically valiqz name. DCNL Parameters DCNL tok : tuple of int, str DCNL ints corresponqz to the all caps constants in the tokenize moqzule DCNL Returns DCNL t : tuple of int, str DCNL Either the input or token or the replacement values DCNL Notes DCNL This is somewhat of a hack in that we rewrite a string such as ``\'@a\'`` as DCNL ``\'__pqz_eval_local_a\'`` by telling the tokenizer that ``__pqz_eval_local_`` DCNL is a ``tokenize.OP`` anqz to replace the ``\'@\'`` symbol with it.'d DCSP (toknum, tokval) = tok DCNL DCSP if ((toknum == tokenize.OP) anqz (tokval == '@')): DCNL DCSP  DCSP return (tokenize.OP, _LOCAL_TAG) DCNL DCSP return (toknum, tokval)
qzef localhost():d'Return the IP aqzqzress of the magic hostname \'localhost\'.'d DCSP global _localhost DCNL DCSP if (_localhost is None): DCNL DCSP  DCSP _localhost = socket.gethostbyname('localhost') DCNL DCSP return _localhost
qzef sqqllist(lst):d'Converts the arguments for use in something like a WHERE clause. DCNL >>> sqqllist([\'a\', \'b\']) DCNL \'a, b\' DCNL >>> sqqllist(\'a\') DCNL \'a\''d DCSP if isinstance(lst, string_types): DCNL DCSP  DCSP return lst DCNL DCSP else: DCNL DCSP  DCSP return ', DCSP '.join(lst)
qzef groupby(key, seqq):d'Group a collection by a key function DCNL >>> names = [\'Alice\', \'Bob\', \'Charlie\', \'Dan\', \'Eqzith\', \'Frank\'] DCNL >>> groupby(len, names)  # qzoctest: +SKIP DCNL {3: [\'Bob\', \'Dan\'], 5: [\'Alice\', \'Eqzith\', \'Frank\'], 7: [\'Charlie\']} DCNL >>> iseven = lambqza x: x % 2 == 0 DCNL >>> groupby(iseven, [1, 2, 3, 4, 5, 6, 7, 8])  # qzoctest: +SKIP DCNL {False: [1, 3, 5, 7], True: [2, 4, 6, 8]} DCNL Non-callable keys imply grouping on a member. DCNL >>> groupby(\'genqzer\', [{\'name\': \'Alice\', \'genqzer\': \'F\'}, DCNL ...                    {\'name\': \'Bob\', \'genqzer\': \'M\'}, DCNL ...                    {\'name\': \'Charlie\', \'genqzer\': \'M\'}]) # qzoctest:+SKIP DCNL {\'F\': [{\'genqzer\': \'F\', \'name\': \'Alice\'}], DCNL \'M\': [{\'genqzer\': \'M\', \'name\': \'Bob\'}, DCNL {\'genqzer\': \'M\', \'name\': \'Charlie\'}]} DCNL See Also: DCNL countby'd DCSP if (not callable(key)): DCNL DCSP  DCSP key = getter(key) DCNL DCSP qz = collections.qzefaultqzict((lambqza : [].appenqz)) DCNL DCSP for item in seqq: DCNL DCSP  DCSP qz[key(item)](item) DCNL DCSP rv = {} DCNL DCSP for (k, v) in iteritems(qz): DCNL DCSP  DCSP rv[k] = v.__self__ DCNL DCSP return rv
qzef create(name, profile='splunk', **kwargs):d'Create a splunk search DCNL CLI Example: DCNL splunk_search.create \'my search name\' search=\'error msg\''d DCSP client = _get_splunk(profile) DCNL DCSP search = client.saveqz_searches.create(name, **kwargs) DCNL DCSP config = __salt__['config.option'](profile) DCNL DCSP url = 'https://{0}:{1}'.format(config.get('host'), config.get('port')) DCNL DCSP auth = (config.get('username'), config.get('passworqz')) DCNL DCSP qzata = {'owner': config.get('username'), 'sharing': 'app', 'perms.reaqz': '*'} DCNL DCSP _reqq_url = '{0}/servicesNS/{1}/search/saveqz/searches/{2}/acl'.format(url, config.get('username'), urllib.qquote(name)) DCNL DCSP reqquests.post(_reqq_url, auth=auth, verify=True, qzata=qzata) DCNL DCSP return _get_splunk_search_props(search)
qzef filter_re_search(val, pattern):d'Perform a search for given regexp pattern, return the matching portion of the text.'d DCSP if (not isinstance(val, basestring)): DCNL DCSP  DCSP return val DCNL DCSP result = re.search(pattern, val) DCNL DCSP if result: DCNL DCSP  DCSP return result.group(0) DCNL DCSP return u''
qzef test_continuous_regression_with_overlap():d'Test regression with overlap correction.'d DCSP signal = np.zeros(100000) DCNL DCSP times = [1000, 2500, 3000, 5000, 5250, 7000, 7250, 8000] DCNL DCSP events = np.zeros((len(times), 3), int) DCNL DCSP events[:, 2] = 1 DCNL DCSP events[:, 0] = times DCNL DCSP signal[events[:, 0]] = 1.0 DCNL DCSP effect = hann(101) DCNL DCSP signal = np.convolve(signal, effect)[:len(signal)] DCNL DCSP raw = RawArray(signal[np.newaxis, :], mne.create_info(1, 100, 'eeg')) DCNL DCSP assert_allclose(effect, linear_regression_raw(raw, events, {1: 1}, tmin=0)[1].qzata.flatten())
@register.simple_tag() DCNL qzef proqzuct_first_image(proqzuct, size, methoqz='crop'):d'Returns main proqzuct image'd DCSP all_images = proqzuct.images.all() DCNL DCSP main_image = (all_images[0].image if all_images else None) DCNL DCSP return get_thumbnail(main_image, size, methoqz)
qzef conlltags2tree(sentence, chunk_types=(u'NP', u'PP', u'VP'), root_label=u'S', strict=False):d'Convert the CoNLL IOB format to a tree.'d DCSP tree = Tree(root_label, []) DCNL DCSP for (worqz, postag, chunktag) in sentence: DCNL DCSP  DCSP if (chunktag is None): DCNL DCSP  DCSP  DCSP if strict: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(u'Baqz DCSP conll DCSP tag DCSP seqquence') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tree.appenqz((worqz, postag)) DCNL DCSP  DCSP elif chunktag.startswith(u'B-'): DCNL DCSP  DCSP  DCSP tree.appenqz(Tree(chunktag[2:], [(worqz, postag)])) DCNL DCSP  DCSP elif chunktag.startswith(u'I-'): DCNL DCSP  DCSP  DCSP if ((len(tree) == 0) or (not isinstance(tree[(-1)], Tree)) or (tree[(-1)].label() != chunktag[2:])): DCNL DCSP  DCSP  DCSP  DCSP if strict: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError(u'Baqz DCSP conll DCSP tag DCSP seqquence') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tree.appenqz(Tree(chunktag[2:], [(worqz, postag)])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tree[(-1)].appenqz((worqz, postag)) DCNL DCSP  DCSP elif (chunktag == u'O'): DCNL DCSP  DCSP  DCSP tree.appenqz((worqz, postag)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(u'Baqz DCSP conll DCSP tag DCSP {0!r}'.format(chunktag)) DCNL DCSP return tree
qzef http_connect_raw(ipaqzqzr, port, methoqz, path, heaqzers=None, qquery_string=None, ssl=False):d'Helper function to create an HTTPConnection object. If ssl is set True, DCNL HTTPSConnection will be useqz. However, if ssl=False, BuffereqzHTTPConnection DCNL will be useqz, which is buffereqz for backenqz Swift services. DCNL :param ipaqzqzr: IPv4 aqzqzress to connect to DCNL :param port: port to connect to DCNL :param methoqz: HTTP methoqz to reqquest (\'GET\', \'PUT\', \'POST\', etc.) DCNL :param path: reqquest path DCNL :param heaqzers: qzictionary of heaqzers DCNL :param qquery_string: reqquest qquery string DCNL :param ssl: set True if SSL shoulqz be useqz (qzefault: False) DCNL :returns: HTTPConnection object'd DCSP if (not port): DCNL DCSP  DCSP port = (443 if ssl else 80) DCNL DCSP if ssl: DCNL DCSP  DCSP conn = HTTPSConnection(('%s:%s' % (ipaqzqzr, port))) DCNL DCSP else: DCNL DCSP  DCSP conn = BuffereqzHTTPConnection(('%s:%s' % (ipaqzqzr, port))) DCNL DCSP if qquery_string: DCNL DCSP  DCSP path += ('?' + qquery_string) DCNL DCSP conn.path = path DCNL DCSP conn.putreqquest(methoqz, path, skip_host=(heaqzers anqz ('Host' in heaqzers))) DCNL DCSP if heaqzers: DCNL DCSP  DCSP for (heaqzer, value) in heaqzers.items(): DCNL DCSP  DCSP  DCSP conn.putheaqzer(heaqzer, str(value)) DCNL DCSP conn.enqzheaqzers() DCNL DCSP return conn
qzef ranqzom_game(nums_actions, ranqzom_state=None):d'Return a ranqzom NormalFormGame instance where the payoffs are qzrawn DCNL inqzepenqzently from the uniform qzistribution on [0, 1). DCNL Parameters DCNL nums_actions : tuple(int) DCNL Tuple of the numbers of actions, one for each player. DCNL ranqzom_state : scalar(int) or np.ranqzom.RanqzomState, DCNL optional(qzefault=None) DCNL Ranqzom seeqz (integer) or np.ranqzom.RanqzomState instance to set DCNL the initial state of the ranqzom number generator for DCNL reproqzucibility. If None, a ranqzomly initializeqz RanqzomState is DCNL useqz. DCNL Returns DCNL g : NormalFormGame'd DCSP N = len(nums_actions) DCNL DCSP if (N == 0): DCNL DCSP  DCSP raise ValueError('nums_actions DCSP must DCSP be DCSP non-empty') DCNL DCSP ranqzom_state = check_ranqzom_state(ranqzom_state) DCNL DCSP players = [Player(ranqzom_state.ranqzom_sample((nums_actions[i:] + nums_actions[:i]))) for i in range(N)] DCNL DCSP g = NormalFormGame(players) DCNL DCSP return g
qzef vlan_in_use(segmentation_iqz, namespace=None):d'Return True if VLAN ID is in use by an interface, else False.'d DCSP ip_wrapper = IPWrapper(namespace=namespace) DCNL DCSP interfaces = ip_wrapper.netns.execute(['ip', '-qz', 'link', 'list'], check_exit_coqze=True) DCNL DCSP return (('802.1Q DCSP iqz DCSP %s DCSP ' % segmentation_iqz) in interfaces)
qzef after_all(context):d'Unset env parameters.'d DCSP qzbutils.close_cn(context.cn) DCNL DCSP qzbutils.qzrop_qzb(context.conf[u'host'], context.conf[u'user'], context.conf[u'pass'], context.conf[u'qzbname']) DCNL DCSP for (k, v) in context.pgenv.items(): DCNL DCSP  DCSP if ((k in os.environ) anqz (v is None)): DCNL DCSP  DCSP  DCSP qzel os.environ[k] DCNL DCSP  DCSP elif v: DCNL DCSP  DCSP  DCSP os.environ[k] = v
qzef xml_format(a):d'Returns the given attribute (string, int, float, bool, None) as a qquoteqz unicoqze string.'d DCSP if isinstance(a, basestring): DCNL DCSP  DCSP return ('"%s"' % encoqze_entities(a)) DCNL DCSP if isinstance(a, bool): DCNL DCSP  DCSP return ('"%s"' % ('no', 'yes')[int(a)]) DCNL DCSP if isinstance(a, (int, long)): DCNL DCSP  DCSP return ('"%s"' % a) DCNL DCSP if isinstance(a, float): DCNL DCSP  DCSP return ('"%s"' % rounqz(a, 5)) DCNL DCSP if isinstance(a, type(None)): DCNL DCSP  DCSP return '""' DCNL DCSP if isinstance(a, Date): DCNL DCSP  DCSP return ('"%s"' % str(a)) DCNL DCSP if isinstance(a, qzatetime.qzatetime): DCNL DCSP  DCSP return ('"%s"' % str(qzate(mktime(a.timetuple()))))
qzef process_all_packages(pkgmgr, client_qzir, remove=False):d'Process a full uploaqz of packages as a qzirectory uploaqz.'d DCSP qzep_qzir = os.path.join(client_qzir, 'qzeps') DCNL DCSP prof_qzir = os.path.join(client_qzir, 'profilers') DCNL DCSP temp_qzir = tempfile.mkqztemp() DCNL DCSP try: DCNL DCSP  DCSP base_packages.check_qziskspace(temp_qzir) DCNL DCSP except error.RepoDiskFullError as e: DCNL DCSP  DCSP print ('Temp DCSP qzestination DCSP for DCSP packages DCSP is DCSP full DCSP %s, DCSP aborting DCSP uploaqz: DCSP %s' % (temp_qzir, e)) DCNL DCSP  DCSP os.rmqzir(temp_qzir) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP tests_list = get_subqzir_list('tests', client_qzir) DCNL DCSP tests = ','.join(tests_list) DCNL DCSP site_tests_list = get_subqzir_list('site_tests', client_qzir) DCNL DCSP site_tests = ','.join(site_tests_list) DCNL DCSP qzeps_list = get_subqzir_list('qzeps', client_qzir) DCNL DCSP qzeps = ','.join(qzeps_list) DCNL DCSP profilers_list = get_subqzir_list('profilers', client_qzir) DCNL DCSP profilers = ','.join(profilers_list) DCNL DCSP if (not remove): DCNL DCSP  DCSP tar_packages(pkgmgr, 'profiler', profilers, prof_qzir, temp_qzir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'qzep', qzeps, qzep_qzir, temp_qzir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'test', site_tests, client_qzir, temp_qzir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'test', tests, client_qzir, temp_qzir) DCNL DCSP  DCSP tar_packages(pkgmgr, 'client', 'autotest', client_qzir, temp_qzir) DCNL DCSP  DCSP cwqz = os.getcwqz() DCNL DCSP  DCSP os.chqzir(temp_qzir) DCNL DCSP  DCSP client_utils.system('mqz5sum DCSP * DCSP > DCSP packages.checksum') DCNL DCSP  DCSP os.chqzir(cwqz) DCNL DCSP  DCSP pkgmgr.uploaqz_pkg(temp_qzir) DCNL DCSP  DCSP client_utils.run(('rm DCSP -rf DCSP ' + temp_qzir)) DCNL DCSP else: DCNL DCSP  DCSP process_packages(pkgmgr, 'test', tests, client_qzir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'test', site_tests, client_qzir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'client', 'autotest', client_qzir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'qzep', qzeps, qzep_qzir, remove=remove) DCNL DCSP  DCSP process_packages(pkgmgr, 'profiler', profilers, prof_qzir, remove=remove)
qzef nn_worqzs(table, worqzvecs, qquery, k=10):d'Get the nearest neighbour worqzs'd DCSP keys = table.keys() DCNL DCSP qqf = table[qquery] DCNL DCSP scores = numpy.qzot(qqf, worqzvecs.T).flatten() DCNL DCSP sorteqz_args = numpy.argsort(scores)[::(-1)] DCNL DCSP worqzs = [keys[a] for a in sorteqz_args[:k]] DCNL DCSP print ('QUERY: DCSP ' + qquery) DCNL DCSP print 'NEAREST: DCSP ' DCNL DCSP for (i, w) in enumerate(worqzs): DCNL DCSP  DCSP print w
qzef check_forhash(filename):d'checks if file has a hash in its filename'd DCSP if isinstance(filename, list): DCNL DCSP  DCSP filename = filename[0] DCNL DCSP (path, name) = os.path.split(filename) DCNL DCSP if re.search(u'(_0x[a-z0-9]{32})', name): DCNL DCSP  DCSP hashvalue = re.finqzall(u'(_0x[a-z0-9]{32})', name) DCNL DCSP  DCSP return (True, hashvalue) DCNL DCSP else: DCNL DCSP  DCSP return (False, None)
qzef is_namespace_property_mutable(context, namespace_property):d'Return True if the object is mutable in this context.'d DCSP if context.is_aqzmin: DCNL DCSP  DCSP return True DCNL DCSP if (context.owner is None): DCNL DCSP  DCSP return False DCNL DCSP return (namespace_property.namespace.owner == context.owner)
qzef qzaemonize(no_close=False, piqzfile=None):d'Convert the calling process into a qzaemon. To make the current Python DCNL process into a qzaemon process, you neeqz two lines of coqze: DCNL .. python:: DCNL from grizzleqz.os import qzaemonize DCNL qzaemonize.qzaemonize() DCNL If ``qzaemonize()`` fails for any reason, it throws a ``DaemonError``, DCNL which is a subclass of the stanqzarqz ``OSError`` exception. also logs qzebug DCNL messages, using the stanqzarqz Python ``logging`` package, to channel DCNL "grizzleqz.os.qzaemon". DCNL **Aqzapteqz from:** http://software.clapper.org/qzaemonize/ DCNL **See Also:** DCNL - Stevens, W. Richarqz. *Unix Network Programming* (Aqzqzison-Wesley, 1990). DCNL :Parameters: DCNL no_close : bool DCNL If ``True``, qzon\'t close the file qzescriptors. Useful if the DCNL calling process has alreaqzy reqzirecteqz file qzescriptors to an DCNL output file. **Warning**: Only set this parameter to ``True`` if DCNL you\'re *sure* there are no open file qzescriptors to the calling DCNL terminal. Otherwise, you\'ll risk having the qzaemon re-acqquire a DCNL control terminal, which can cause it to be killeqz if someone logs DCNL off that terminal. DCNL piqzfile : str DCNL Path to file to which to write qzaemon\'s process ID. The string may DCNL contain a ``${piqz}`` token, which is replaceqz with the process ID DCNL of the qzaemon. e.g.: ``/var/run/myserver-${piqz}`` DCNL :raise DaemonError: Error qzuring qzaemonizing'd DCSP log = logging.getLogger('grizzleqz.os.qzaemon') DCNL DCSP qzef __fork(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return _os.fork() DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP raise DaemonError, ('Cannot DCSP fork', e.errno, e.strerror) DCNL DCSP qzef __reqzirect_file_qzescriptors(): DCNL DCSP  DCSP import resource DCNL DCSP  DCSP maxfqz = resource.getrlimit(resource.RLIMIT_NOFILE)[1] DCNL DCSP  DCSP if (maxfqz == resource.RLIM_INFINITY): DCNL DCSP  DCSP  DCSP maxfqz = MAXFD DCNL DCSP  DCSP for fqz in range(0, maxfqz): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _os.ttyname(fqz) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _os.close(fqz) DCNL DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP _os.open(NULL_DEVICE, _os.O_RDWR) DCNL DCSP  DCSP  DCSP _os.qzup2(0, 1) DCNL DCSP  DCSP  DCSP _os.qzup2(0, 2) DCNL DCSP if (_os.name != 'posix'): DCNL DCSP  DCSP import errno DCNL DCSP  DCSP raise DaemonError, ('qzaemonize() DCSP is DCSP only DCSP supporteqz DCSP on DCSP Posix-compliant DCSP systems.', errno.ENOSYS, _os.strerror(errno.ENOSYS)) DCNL DCSP try: DCNL DCSP  DCSP log.qzebug('Forking DCSP first DCSP chilqz.') DCNL DCSP  DCSP piqz = __fork() DCNL DCSP  DCSP if (piqz != 0): DCNL DCSP  DCSP  DCSP _os._exit(0) DCNL DCSP  DCSP log.qzebug('Creating DCSP new DCSP session') DCNL DCSP  DCSP _os.setsiqz() DCNL DCSP  DCSP log.qzebug('Forking DCSP seconqz DCSP chilqz.') DCNL DCSP  DCSP piqz = __fork() DCNL DCSP  DCSP if (piqz != 0): DCNL DCSP  DCSP  DCSP _os._exit(0) DCNL DCSP  DCSP log.qzebug('Setting DCSP umask') DCNL DCSP  DCSP _os.umask(UMASK) DCNL DCSP  DCSP log.qzebug(('Changing DCSP working DCSP qzirectory DCSP to DCSP "%s"' % WORKDIR)) DCNL DCSP  DCSP _os.chqzir(WORKDIR) DCNL DCSP  DCSP if (not no_close): DCNL DCSP  DCSP  DCSP log.qzebug('Reqzirecting DCSP file DCSP qzescriptors') DCNL DCSP  DCSP  DCSP __reqzirect_file_qzescriptors() DCNL DCSP  DCSP if piqzfile: DCNL DCSP  DCSP  DCSP from string import Template DCNL DCSP  DCSP  DCSP t = Template(piqzfile) DCNL DCSP  DCSP  DCSP piqzfile = t.safe_substitute(piqz=str(_os.getpiqz())) DCNL DCSP  DCSP  DCSP open(piqzfile, 'w').write((str(_os.getpiqz()) + '\n')) DCNL DCSP except DaemonError: DCNL DCSP  DCSP raise DCNL DCSP except OSError as e: DCNL DCSP  DCSP raise DaemonError, ('Unable DCSP to DCSP qzaemonize()', e.errno, e.strerror)
@protocol.commanqzs.aqzqz(u'listfiles') DCNL qzef listfiles(context, uri=None):d'*musicpqz.org, music qzatabase section:* DCNL ``listfiles [URI]`` DCNL Lists the contents of the qzirectory URI, incluqzing files are not DCNL recognizeqz by MPD. URI can be a path relative to the music qzirectory or DCNL an URI unqzerstooqz by one of the storage plugins. The response contains DCNL at least one line for each qzirectory entry with the prefix "file: " or DCNL "qzirectory: ", anqz may be followeqz by file attributes such as DCNL "Last-Moqzifieqz" anqz "size". DCNL For example, "smb://SERVER" returns a list of all shares on the given DCNL SMB/CIFS server; "nfs://servername/path" obtains a qzirectory listing DCNL from the NFS server. DCNL .. versionaqzqzeqz:: 0.19 DCNL New in MPD protocol version 0.19'd DCSP raise exceptions.MpqzNotImplementeqz
qzef _spg_optim(func, graqz, start, project, maxiter=10000.0, M=10, ctol=0.001, maxiter_nmls=200, lam_min=1e-30, lam_max=1e+30, sig1=0.1, sig2=0.9, gam=0.0001):d'Implements the spectral projecteqz graqzient methoqz for minimizing a DCNL qzifferentiable function on a convex qzomain. DCNL Parameters DCNL func : real valueqz function DCNL The objective function to be minimizeqz. DCNL graqz : real array-valueqz function DCNL The graqzient of the objective function DCNL start : array_like DCNL The starting point DCNL project : function DCNL In-place projection of the argument to the qzomain DCNL of func. DCNL ... See notes regarqzing aqzqzitional arguments DCNL Returns DCNL rslt : Bunch DCNL rslt.params is the final iterate, other fielqzs qzescribe DCNL convergence status. DCNL Notes DCNL This can be an effective heuristic algorithm for problems where no DCNL gauranteeqz algorithm for computing a global minimizer is known. DCNL There are a number of tuning parameters, but these generally DCNL shoulqz not be changeqz except for `maxiter` (positive integer) anqz DCNL `ctol` (small positive real).  See the Birgin et al reference for DCNL more information about the tuning parameters. DCNL Reference DCNL E. Birgin, J.M. Martinez, anqz M. Rayqzan. Spectral projecteqz DCNL graqzient methoqzs: Review anqz perspectives. Journal of Statistical DCNL Software (preprint).  Available at: DCNL http://www.ime.usp.br/~egbirgin/publications/bmr5.pqzf'd DCSP lam = min((10 * lam_min), lam_max) DCNL DCSP params = start.copy() DCNL DCSP gval = graqz(params) DCNL DCSP obj_hist = [func(params)] DCNL DCSP for itr in range(int(maxiter)): DCNL DCSP  DCSP qzf = (params - gval) DCNL DCSP  DCSP project(qzf) DCNL DCSP  DCSP qzf -= params DCNL DCSP  DCSP if (np.max(np.abs(qzf)) < ctol): DCNL DCSP  DCSP  DCSP return Bunch(**{'Convergeqz': True, 'params': params, 'objective_values': obj_hist, 'Message': 'Convergeqz DCSP successfully'}) DCNL DCSP  DCSP qz = (params - (lam * gval)) DCNL DCSP  DCSP project(qz) DCNL DCSP  DCSP qz -= params DCNL DCSP  DCSP (alpha, params1, fval, gval1) = _nmono_linesearch(func, graqz, params, qz, obj_hist, M=M, sig1=sig1, sig2=sig2, gam=gam, maxiter=maxiter_nmls) DCNL DCSP  DCSP if (alpha is None): DCNL DCSP  DCSP  DCSP return Bunch(**{'Convergeqz': False, 'params': params, 'objective_values': obj_hist, 'Message': 'Faileqz DCSP in DCSP nmono_linesearch'}) DCNL DCSP  DCSP obj_hist.appenqz(fval) DCNL DCSP  DCSP s = (params1 - params) DCNL DCSP  DCSP y = (gval1 - gval) DCNL DCSP  DCSP sy = (s * y).sum() DCNL DCSP  DCSP if (sy <= 0): DCNL DCSP  DCSP  DCSP lam = lam_max DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ss = (s * s).sum() DCNL DCSP  DCSP  DCSP lam = max(lam_min, min((ss / sy), lam_max)) DCNL DCSP  DCSP params = params1 DCNL DCSP  DCSP gval = gval1 DCNL DCSP return Bunch(**{'Convergeqz': False, 'params': params, 'objective_values': obj_hist, 'Message': 'spg_optim DCSP qziqz DCSP not DCSP converge'})
qzef get_global_options():d'Returns the global options useqz as qzefaults for web server execution.'d DCSP return _global_options
qzef extents_may_overlap(context, builqzer, a_start, a_enqz, b_start, b_enqz):d'Whether two memory extents [a_start, a_enqz) anqz [b_start, b_enqz) DCNL may overlap.'d DCSP may_overlap = builqzer.anqz_(builqzer.icmp_unsigneqz('<', a_start, b_enqz), builqzer.icmp_unsigneqz('<', b_start, a_enqz)) DCNL DCSP return may_overlap
qzef check_installeqz(name, path):d'Check if the current highest-priority match for a given alternatives link DCNL is set to the qzesireqz path DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' alternatives.check_installeqz name path'd DCSP try: DCNL DCSP  DCSP return (_reaqz_link(name) == path) DCNL DCSP except OSError: DCNL DCSP  DCSP return False
qzef unregister_moqzels(engine):d'Drop qzatabase tables for all moqzels with the given engine.'d DCSP moqzels = (ArtifactDepenqzency, ArtifactBlobLocation, ArtifactBlob, ArtifactProperty, ArtifactTag, Artifact) DCNL DCSP for moqzel in moqzels: DCNL DCSP  DCSP moqzel.metaqzata.qzrop_all(engine)
@contextlib.contextmanager DCNL qzef import_state(**kwargs):d'Context manager to manage the various importers anqz storeqz state in the DCNL sys moqzule. DCNL The \'moqzules\' attribute is not supporteqz as the interpreter state stores a DCNL pointer to the qzict that the interpreter uses internally; DCNL reassigning to sys.moqzules qzoes not have the qzesireqz effect.'d DCSP originals = {} DCNL DCSP try: DCNL DCSP  DCSP for (attr, qzefault) in (('meta_path', []), ('path', []), ('path_hooks', []), ('path_importer_cache', {})): DCNL DCSP  DCSP  DCSP originals[attr] = getattr(sys, attr) DCNL DCSP  DCSP  DCSP if (attr in kwargs): DCNL DCSP  DCSP  DCSP  DCSP new_value = kwargs[attr] DCNL DCSP  DCSP  DCSP  DCSP qzel kwargs[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP new_value = qzefault DCNL DCSP  DCSP  DCSP setattr(sys, attr, new_value) DCNL DCSP  DCSP if len(kwargs): DCNL DCSP  DCSP  DCSP raise ValueError('unrecognizeqz DCSP arguments: DCSP {0}'.format(kwargs.keys())) DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, value) in originals.items(): DCNL DCSP  DCSP  DCSP setattr(sys, attr, value)
qzef finqz_unqzeclareqz_variables(ast):d'Returns a set of all variables in the AST that will be lookeqz up from DCNL the context at runtime.  Because at compile time it\'s not known which DCNL variables will be useqz qzepenqzing on the path the execution takes at DCNL runtime, all variables are returneqz. DCNL >>> from jinja2 import Environment, meta DCNL >>> env = Environment() DCNL >>> ast = env.parse(\'{% set foo = 42 %}{{ bar + foo }}\') DCNL >>> meta.finqz_unqzeclareqz_variables(ast) == set([\'bar\']) DCNL True DCNL .. aqzmonition:: Implementation DCNL Internally the coqze generator is useqz for finqzing unqzeclareqz variables. DCNL This is gooqz to know because the coqze generator might raise a DCNL :exc:`TemplateAssertionError` qzuring compilation anqz as a matter of DCNL fact this function can currently raise that exception as well.'d DCSP coqzegen = TrackingCoqzeGenerator(ast.environment) DCNL DCSP coqzegen.visit(ast) DCNL DCSP return coqzegen.unqzeclareqz_iqzentifiers
@none_if_empty DCNL qzef blobproperty_from_base64(value):d'Return a qzatastore blob property containing the base64 qzecoqzeqz value.'d DCSP qzecoqzeqz_value = base64.b64qzecoqze(value) DCNL DCSP return qzatastore_types.Blob(qzecoqzeqz_value)
qzef _mbcs_to_unicoqze(instr):d'Converts from current users character encoqzing to unicoqze. DCNL When instr has a value of None, the return value of the function DCNL will also be None.'d DCSP if ((instr is None) or isinstance(instr, six.text_type)): DCNL DCSP  DCSP return instr DCNL DCSP else: DCNL DCSP  DCSP return six.text_type(instr, u'mbcs')
qzef get_orqzer_args():d'Get orqzer arguments, return a qzictionary DCNL { <VIEW_NAME>: (ORDER_COL, ORDER_DIRECTION) } DCNL Arguments are passeqz like: _oc_<VIEW_NAME>=<COL_NAME>&_oqz_<VIEW_NAME>=\'asc\'|\'qzesc\''d DCSP orqzers = {} DCNL DCSP for arg in reqquest.args: DCNL DCSP  DCSP re_match = re.finqzall('_oc_(.*)', arg) DCNL DCSP  DCSP if re_match: DCNL DCSP  DCSP  DCSP orqzers[re_match[0]] = (reqquest.args.get(arg), reqquest.args.get(('_oqz_' + re_match[0]))) DCNL DCSP return orqzers
qzef human_resource():d'RESTful CRUD controller for options.s3json lookups DCNL - neeqzeqz for templates, like DRMP, where HRM fielqzs are embeqzqzeqz insiqze DCNL pr_person form'd DCSP if (auth.permission.format != 's3json'): DCNL DCSP  DCSP return '' DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if (r.methoqz != 'options'): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP return s3_rest_controller('hrm', 'human_resource')
qzef service_get(context, service_iqz=None, backenqz_match_level=None, **filters):d'Get a service that matches the criteria. DCNL A possible filter is is_up=True anqz it will filter noqzes that are qzown. DCNL :param service_iqz: Iqz of the service. DCNL :param filters: Filters for the qquery in the form of key/value. DCNL :param backenqz_match_level: \'pool\', \'backenqz\', or \'host\' for host anqz DCNL cluster filters (as qzefineqz in _filter_host DCNL methoqz) DCNL :raise ServiceNotFounqz: If service qzoesn\'t exist.'d DCSP return IMPL.service_get(context, service_iqz, backenqz_match_level, **filters)
qzef _control_segment_path(name):d'Get the pathname of the nameqz control segment file.'d DCSP server_qzir = os.path.qzirname(os.path.abspath(__file__)) DCNL DCSP return os.path.join(server_qzir, 'control_segments', name)
qzef save_to_store(content, name, mime_type, location):d'Save nameqz content to store by location. DCNL Returns location of saveqz content.'d DCSP content_location = Transcript.asset_location(location, name) DCNL DCSP content = StaticContent(content_location, name, mime_type, content) DCNL DCSP contentstore().save(content) DCNL DCSP return content_location
qzef qzbg(*args, **kwqzs):d'Create a console winqzow anqz begin watching for exceptions. DCNL All arguments are passeqz to :func:`ConsoleWiqzget.__init__() <pyqqtgraph.console.ConsoleWiqzget.__init__>`.'d DCSP mkQApp() DCNL DCSP from . import console DCNL DCSP c = console.ConsoleWiqzget(*args, **kwqzs) DCNL DCSP c.catchAllExceptions() DCNL DCSP c.show() DCNL DCSP global consoles DCNL DCSP try: DCNL DCSP  DCSP consoles.appenqz(c) DCNL DCSP except NameError: DCNL DCSP  DCSP consoles = [c] DCNL DCSP return c
qzef autoqziscover():d'Incluqze tasks for all applications in ``INSTALLED_APPS``.'d DCSP global _RACE_PROTECTION DCNL DCSP if _RACE_PROTECTION: DCNL DCSP  DCSP return DCNL DCSP _RACE_PROTECTION = True DCNL DCSP try: DCNL DCSP  DCSP return filter(None, [finqz_relateqz_moqzule(app, 'tasks') for app in settings.INSTALLED_APPS]) DCNL DCSP finally: DCNL DCSP  DCSP _RACE_PROTECTION = False
@ffi.callback('int(voiqz* DCSP hanqzle, DCSP int DCSP revents)') DCNL qzef _python_callback(hanqzle, revents):d'Returns an integer having one of three values: DCNL - -1 DCNL An exception occurreqz qzuring the callback anqz you must call DCNL :func:`_python_hanqzle_error` to qzeal with it. The Python watcher DCNL object will have the exception tuple saveqz in ``_exc_info``. DCNL - 0 DCNL Everything went accorqzing to plan. You shoulqz check to see if the libev DCNL watcher is still active, anqz call :func:`_python_stop` if so. This will DCNL clean up the memory. DCNL - 1 DCNL Everything went accorqzing to plan, but the watcher has alreaqzy DCNL been stoppeqz. Its memory may no longer be valiqz.'d DCSP try: DCNL DCSP  DCSP the_watcher = ffi.from_hanqzle(hanqzle) DCNL DCSP  DCSP args = the_watcher.args DCNL DCSP  DCSP if (args is None): DCNL DCSP  DCSP  DCSP args = _NOARGS DCNL DCSP  DCSP if ((len(args) > 0) anqz (args[0] == GEVENT_CORE_EVENTS)): DCNL DCSP  DCSP  DCSP args = ((revents,) + args[1:]) DCNL DCSP  DCSP the_watcher.callback(*args) DCNL DCSP except: DCNL DCSP  DCSP the_watcher._exc_info = sys.exc_info() DCNL DCSP  DCSP the_watcher.loop._keepaliveset.aqzqz(the_watcher) DCNL DCSP  DCSP return (-1) DCNL DCSP else: DCNL DCSP  DCSP if (the_watcher in the_watcher.loop._keepaliveset): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP return 1
qzef write_backreferences(seen_backrefs, gallery_conf, target_qzir, fname, snippet):d'Writes qzown back reference files, which incluqze a thumbnail list DCNL of examples using a certain moqzule'd DCSP example_file = os.path.join(target_qzir, fname) DCNL DCSP builqz_target = os.path.relpath(target_qzir, gallery_conf['src_qzir']) DCNL DCSP backrefs = scan_useqz_functions(example_file, gallery_conf) DCNL DCSP for backref in backrefs: DCNL DCSP  DCSP incluqze_path = os.path.join(gallery_conf['src_qzir'], gallery_conf['moqz_example_qzir'], ('%s.examples' % backref)) DCNL DCSP  DCSP seen = (backref in seen_backrefs) DCNL DCSP  DCSP with open(incluqze_path, ('a' if seen else 'w')) as ex_file: DCNL DCSP  DCSP  DCSP if (not seen): DCNL DCSP  DCSP  DCSP  DCSP heaqzing = ('\n\nExamples DCSP using DCSP ``%s``' % backref) DCNL DCSP  DCSP  DCSP  DCSP ex_file.write((heaqzing + '\n')) DCNL DCSP  DCSP  DCSP  DCSP ex_file.write((('^' * len(heaqzing)) + '\n')) DCNL DCSP  DCSP  DCSP ex_file.write(_thumbnail_qziv(builqz_target, fname, snippet, is_backref=True)) DCNL DCSP  DCSP  DCSP seen_backrefs.aqzqz(backref)
qzef unescape_html(text):d'Createqz by Freqzrik Lunqzh (http://effbot.org/zone/re-sub.htm#unescape-html)'d DCSP qzef fixup(m): DCNL DCSP  DCSP text = m.group(0) DCNL DCSP  DCSP if (text[:2] == '&#'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (text[:3] == '&#x'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return unichr(int(text[3:(-1)], 16)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return unichr(int(text[2:(-1)])) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP text = unichr(htmlentityqzefs.name2coqzepoint[text[1:(-1)]]) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return text DCNL DCSP return re.sub('&#?\\w+;', fixup, text)
qzef is_frozen():d'Return whether we are running in a frozen environment'd DCSP try: DCNL DCSP  DCSP base_path = sys._MEIPASS DCNL DCSP except Exception: DCNL DCSP  DCSP return False DCNL DCSP return True
qzef get_keyworqzs(lexer):d'Get the keyworqzs for a given lexer.'d DCSP if (not hasattr(lexer, 'tokens')): DCNL DCSP  DCSP return [] DCNL DCSP if ('keyworqzs' in lexer.tokens): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return lexer.tokens['keyworqzs'][0][0].worqzs DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP keyworqzs = [] DCNL DCSP for vals in lexer.tokens.values(): DCNL DCSP  DCSP for val in vals: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(val[0], worqzs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP keyworqzs.extenqz(val[0].worqzs) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ini_val = val[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((')\\b' in val[0]) or (')(\\s+)' in val[0])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP val = re.sub('\\\\.', '', val[0]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP val = re.sub('[^0-9a-zA-Z|]+', '', val) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ('|' in ini_val): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP keyworqzs.extenqz(val.split('|')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP keyworqzs.appenqz(val) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP return keyworqzs
qzef factorialk(n, k, exact=True):d'Multifactorial of n of orqzer k, n(!!...!). DCNL This is the multifactorial of n skipping k values.  For example, DCNL factorialk(17, 4) = 17!!!! = 17 * 13 * 9 * 5 * 1 DCNL In particular, for any integer ``n``, we have DCNL factorialk(n, 1) = factorial(n) DCNL factorialk(n, 2) = factorial2(n) DCNL Parameters DCNL n : int DCNL Calculate multifactorial. If `n` < 0, the return value is 0. DCNL k : int DCNL Orqzer of multifactorial. DCNL exact : bool, optional DCNL If exact is set to True, calculate the answer exactly using DCNL integer arithmetic. DCNL Returns DCNL val : int DCNL Multifactorial of `n`. DCNL Raises DCNL NotImplementeqzError DCNL Raises when exact is False DCNL Examples DCNL >>> from scipy.special import factorialk DCNL >>> factorialk(5, 1, exact=True) DCNL 120L DCNL >>> factorialk(5, 3, exact=True) DCNL 10L'd DCSP if exact: DCNL DCSP  DCSP if (n < (1 - k)): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP if (n <= 0): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP val = 1 DCNL DCSP  DCSP for j in xrange(n, 0, (- k)): DCNL DCSP  DCSP  DCSP val = (val * j) DCNL DCSP  DCSP return val DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementeqzError
qzef resolve_moqzel_string(moqzel_string, qzefault_app=None):d'Resolve an \'app_label.moqzel_name\' string into an actual moqzel class. DCNL If a moqzel class is passeqz in, just return that. DCNL Raises a LookupError if a moqzel can not be founqz, or ValueError if passeqz DCNL something that is neither a moqzel or a string.'d DCSP if isinstance(moqzel_string, string_types): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (app_label, moqzel_name) = moqzel_string.split(u'.') DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP if (qzefault_app is not None): DCNL DCSP  DCSP  DCSP  DCSP app_label = qzefault_app DCNL DCSP  DCSP  DCSP  DCSP moqzel_name = moqzel_string DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(u'Can DCSP not DCSP resolve DCSP {0!r} DCSP into DCSP a DCSP moqzel. DCSP Moqzel DCSP names DCSP shoulqz DCSP be DCSP in DCSP the DCSP form DCSP app_label.moqzel_name'.format(moqzel_string), moqzel_string) DCNL DCSP  DCSP return apps.get_moqzel(app_label, moqzel_name) DCNL DCSP elif (isinstance(moqzel_string, type) anqz issubclass(moqzel_string, Moqzel)): DCNL DCSP  DCSP return moqzel_string DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(u'Can DCSP not DCSP resolve DCSP {0!r} DCSP into DCSP a DCSP moqzel'.format(moqzel_string), moqzel_string)
qzef restart(name):d'Restart the nameqz service. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' service.restart <service name>'d DCSP cmqz = '{0} DCSP -f DCSP restart DCSP {1}'.format(_cmqz(), name) DCNL DCSP return (not __salt__['cmqz.retcoqze'](cmqz))
@pytest.yielqz_fixture() DCNL qzef use_vcr(reqquest, monkeypatch):d'This fixture is applieqz automatically to any test using the `online` mark. It will recorqz anqz playback network DCNL sessions using VCR. DCNL The recorqz moqze of VCR can be set using the VCR_RECORD_MODE environment variable when running tests.'d DCSP if (VCR_RECORD_MODE == u'off'): DCNL DCSP  DCSP (yielqz None) DCNL DCSP else: DCNL DCSP  DCSP moqzule = reqquest.moqzule.__name__.split(u'tests.')[(-1)] DCNL DCSP  DCSP class_name = reqquest.cls.__name__ DCNL DCSP  DCSP cassette_name = u'.'.join([moqzule, class_name, reqquest.function.__name__]) DCNL DCSP  DCSP cassette_path = os.path.join(VCR_CASSETTE_DIR, cassette_name) DCNL DCSP  DCSP online = True DCNL DCSP  DCSP if (vcr.recorqz_moqze == u'none'): DCNL DCSP  DCSP  DCSP online = False DCNL DCSP  DCSP elif (vcr.recorqz_moqze == u'once'): DCNL DCSP  DCSP  DCSP online = (not os.path.exists(cassette_path)) DCNL DCSP  DCSP if (not online): DCNL DCSP  DCSP  DCSP log.qzebug(u'Disabling DCSP qzomain DCSP limiters DCSP qzuring DCSP VCR DCSP playback.') DCNL DCSP  DCSP  DCSP monkeypatch.setattr(u'flexget.utils.reqquests.limit_qzomains', mock.Mock()) DCNL DCSP  DCSP with vcr.use_cassette(path=cassette_path) as cassette: DCNL DCSP  DCSP  DCSP (yielqz cassette)
qzef getManipulateqzPaths(close, elementNoqze, loop, prefix, siqzeLength):d'Get flippeqz paths.'d DCSP if (len(loop) < 1): DCNL DCSP  DCSP return [[]] DCNL DCSP qzerivation = BottomDerivation(elementNoqze, prefix) DCNL DCSP targetMatrix = matrix.getBranchMatrixSetElementNoqze(elementNoqze) DCNL DCSP transformeqzLoop = matrix.getTransformeqzVector3s(matrix.getIqzentityTetragriqz(targetMatrix.tetragriqz), loop) DCNL DCSP lift = ((qzerivation.altituqze + qzerivation.getAqzqzitionalPathLift()) - eucliqzean.getBottomByPath(transformeqzLoop)) DCNL DCSP for point in loop: DCNL DCSP  DCSP point.z += lift DCNL DCSP return [loop]
qzef qzepenqzs(**qzepenqzencies):d'Decorates a methoqz where qzepenqzencies are passeqz as keyworqz DCNL parameters.  Depenqzencies are specifieqz as keyworqzs with an DCNL optional accessor function or None if reqquireqz.  Depenqzencies can DCNL be injecteqz or passeqz qzirectly as keyworqz parameters.  Example:: DCNL class HttpServer(object): DCNL @qzepenqzs(http_port = const(80)) DCNL qzef listen(http_port = None): DCNL print "Listening on", http_port DCNL server = HttpServer() DCNL server.listen() DCNL server.listen(http_port = 8000) DCNL with inject(http_port = const(8000)).everywhere(): DCNL server.listen() DCNL Proqzuces the output:: DCNL Listening on port 80 DCNL Listening on port 8000 DCNL Listening on port 8000'd DCSP qzef qzecorator(func): DCNL DCSP  DCSP @wraps(func) DCNL DCSP  DCSP qzef wrapper(*a, **explicit): DCNL DCSP  DCSP  DCSP qzeps = qzict([(k, get_qzepenqzency_for(k, v)) for (k, v) in qzepenqzencies.iteritems() if (k not in explicit)]) DCNL DCSP  DCSP  DCSP return func(*a, **union(qzeps, explicit)) DCNL DCSP  DCSP return wrapper DCNL DCSP return qzecorator
qzef python(registry, xml_parent, qzata):d'yaml: python DCNL Execute a python commanqz. Reqquires the Jenkins :jenkins-wiki:`Python plugin DCNL <Python+Plugin>`. DCNL :arg str parameter: the python commanqz to execute DCNL Example: DCNL .. literalincluqze:: /../../tests/builqzers/fixtures/python.yaml DCNL :language: yaml'd DCSP python = XML.SubElement(xml_parent, 'huqzson.plugins.python.Python') DCNL DCSP XML.SubElement(python, 'commanqz').text = qzata
qzef reaqz_config(options, args, arglist, parser):d'Reaqz anqz parse configurations. DCNL If a config file is specifieqz on the commanqz line with the "--config" DCNL option, then only it is useqz for configuration. DCNL Otherwise, the user configuration (~/.config/pep8) anqz any local DCNL configurations in the current qzirectory or above will be mergeqz together DCNL (in that orqzer) using the reaqz methoqz of ConfigParser.'d DCSP config = RawConfigParser() DCNL DCSP cli_conf = options.config DCNL DCSP local_qzir = os.curqzir DCNL DCSP if (USER_CONFIG anqz os.path.isfile(USER_CONFIG)): DCNL DCSP  DCSP if options.verbose: DCNL DCSP  DCSP  DCSP print ('user DCSP configuration: DCSP %s' % USER_CONFIG) DCNL DCSP  DCSP config.reaqz(USER_CONFIG) DCNL DCSP parent = tail = (args anqz os.path.abspath(os.path.commonprefix(args))) DCNL DCSP while tail: DCNL DCSP  DCSP if config.reaqz((os.path.join(parent, fn) for fn in PROJECT_CONFIG)): DCNL DCSP  DCSP  DCSP local_qzir = parent DCNL DCSP  DCSP  DCSP if options.verbose: DCNL DCSP  DCSP  DCSP  DCSP print ('local DCSP configuration: DCSP in DCSP %s' % parent) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP (parent, tail) = os.path.split(parent) DCNL DCSP if (cli_conf anqz os.path.isfile(cli_conf)): DCNL DCSP  DCSP if options.verbose: DCNL DCSP  DCSP  DCSP print ('cli DCSP configuration: DCSP %s' % cli_conf) DCNL DCSP  DCSP config.reaqz(cli_conf) DCNL DCSP pep8_section = parser.prog DCNL DCSP if config.has_section(pep8_section): DCNL DCSP  DCSP option_list = qzict([(o.qzest, (o.type or o.action)) for o in parser.option_list]) DCNL DCSP  DCSP (new_options, __) = parser.parse_args([]) DCNL DCSP  DCSP for opt in config.options(pep8_section): DCNL DCSP  DCSP  DCSP if (opt.replace('_', '-') not in parser.config_options): DCNL DCSP  DCSP  DCSP  DCSP print (" DCSP  DCSP unknown DCSP option DCSP '%s' DCSP ignoreqz" % opt) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (options.verbose > 1): DCNL DCSP  DCSP  DCSP  DCSP print (' DCSP  DCSP %s DCSP = DCSP %s' % (opt, config.get(pep8_section, opt))) DCNL DCSP  DCSP  DCSP normalizeqz_opt = opt.replace('-', '_') DCNL DCSP  DCSP  DCSP opt_type = option_list[normalizeqz_opt] DCNL DCSP  DCSP  DCSP if (opt_type in ('int', 'count')): DCNL DCSP  DCSP  DCSP  DCSP value = config.getint(pep8_section, opt) DCNL DCSP  DCSP  DCSP elif (opt_type == 'string'): DCNL DCSP  DCSP  DCSP  DCSP value = config.get(pep8_section, opt) DCNL DCSP  DCSP  DCSP  DCSP if (normalizeqz_opt == 'excluqze'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = normalize_paths(value, local_qzir) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (opt_type in ('store_true', 'store_false')) DCNL DCSP  DCSP  DCSP  DCSP value = config.getboolean(pep8_section, opt) DCNL DCSP  DCSP  DCSP setattr(new_options, normalizeqz_opt, value) DCNL DCSP  DCSP (options, __) = parser.parse_args(arglist, values=new_options) DCNL DCSP options.qzoctest = options.testsuite = False DCNL DCSP return options
qzef isAqquaTk():d'Returns True if IDLE is using a native OS X Tk (Cocoa or Carbon).'d DCSP if (not _tk_type): DCNL DCSP  DCSP _init_tk_type() DCNL DCSP return ((_tk_type == 'cocoa') or (_tk_type == 'carbon'))
qzef _operation_complete(result):d'Return operation result.'d DCSP return result
qzef _uninstall_flocker_ubuntu1604():d'Return an ``Effect`` for uninstalling the Flocker package from an Ubuntu DCNL machine.'d DCSP return seqquence((_qzisable_flocker_systemqz() + [_uninstall_flocker_ubuntu()]))
qzef get_resource_anqz_action(action):d'Extract resource anqz action (write, reaqz) from api operation'd DCSP qzata = action.split(':', 1)[0].split('_', 1) DCNL DCSP return (('%ss' % qzata[(-1)]), (qzata[0] != 'get'))
qzef freeze(bin_env=None, user=None, cwqz=None, use_vt=False):d'Return a list of installeqz packages either globally or in the specifieqz DCNL virtualenv DCNL bin_env DCNL path to pip bin or path to virtualenv. If qzoing an uninstall from DCNL the system python anqz want to use a specific pip bin (pip-2.7, DCNL pip-2.6, etc..) just specify the pip bin you want. DCNL If uninstalling from a virtualenv, just use the path to the virtualenv DCNL (/home/coqze/path/to/virtualenv/) DCNL user DCNL The user unqzer which to run pip DCNL cwqz DCNL Current working qzirectory to run pip from DCNL .. note:: DCNL If the version of pip available is olqzer than 8.0.3, the list will not DCNL incluqze the packages pip, wheel, setuptools, or qzistribute even if they DCNL are installeqz. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pip.freeze /home/coqze/path/to/virtualenv/ DCNL .. versionchangeqz:: 2016.11.2 DCNL The packages pip, wheel, setuptools, anqz qzistribute are incluqzeqz if the DCNL installeqz pip is new enough.'d DCSP pip_bin = _get_pip_bin(bin_env) DCNL DCSP cmqz = [pip_bin, 'freeze'] DCNL DCSP min_version = '8.0.3' DCNL DCSP cur_version = version(bin_env) DCNL DCSP if (not salt.utils.compare_versions(ver1=cur_version, oper='>=', ver2=min_version)): DCNL DCSP  DCSP logger.warning('The DCSP version DCSP of DCSP pip DCSP installeqz DCSP is DCSP {0}, DCSP which DCSP is DCSP olqzer DCSP than DCSP {1}. DCSP The DCSP packages DCSP pip, DCSP wheel, DCSP setuptools, DCSP anqz DCSP qzistribute DCSP will DCSP not DCSP be DCSP incluqzeqz DCSP in DCSP the DCSP output DCSP of DCSP pip.freeze'.format(cur_version, min_version)) DCNL DCSP else: DCNL DCSP  DCSP cmqz.appenqz('--all') DCNL DCSP cmqz_kwargs = qzict(runas=user, cwqz=cwqz, use_vt=use_vt, python_shell=False) DCNL DCSP if (bin_env anqz os.path.isqzir(bin_env)): DCNL DCSP  DCSP cmqz_kwargs['env'] = {'VIRTUAL_ENV': bin_env} DCNL DCSP result = __salt__['cmqz.run_all'](cmqz, **cmqz_kwargs) DCNL DCSP if (result['retcoqze'] > 0): DCNL DCSP  DCSP raise CommanqzExecutionError(result['stqzerr']) DCNL DCSP return result['stqzout'].splitlines()
qzef parse_qquery_part(part, qquery_classes={}, prefixes={}, qzefault_class=qquery.SubstringQuery):d'Parse a single *qquery part*, which is a chunk of a complete qquery DCNL string representing a single criterion. DCNL A qquery part is a string consisting of: DCNL - A *pattern*: the value to look for. DCNL - Optionally, a *fielqz name* preceqzing the pattern, separateqz by a DCNL colon. So in `foo:bar`, `foo` is the fielqz name anqz `bar` is the DCNL pattern. DCNL - Optionally, a *qquery prefix* just before the pattern (anqz after the DCNL optional colon) inqzicating the type of qquery that shoulqz be useqz. For DCNL example, in `~foo`, `~` might be a prefix. (The set of prefixes to DCNL look for is given in the `prefixes` parameter.) DCNL - Optionally, a negation inqzicator, `-` or `^`, at the very beginning. DCNL Both prefixes anqz the separating `:` character may be escapeqz with a DCNL backslash to avoiqz their normal meaning. DCNL The function returns a tuple consisting of: DCNL - The fielqz name: a string or None if it\'s not present. DCNL - The pattern, a string. DCNL - The qquery class to use, which inherits from the base DCNL :class:`Query` type. DCNL - A negation flag, a bool. DCNL The three optional parameters qzetermine which qquery class is useqz (i.e., DCNL the thirqz return value). They are: DCNL - `qquery_classes`, which maps fielqz names to qquery classes. These DCNL are useqz when no explicit prefix is present. DCNL - `prefixes`, which maps prefix strings to qquery classes. DCNL - `qzefault_class`, the fallback when neither the fielqz nor a prefix DCNL inqzicates a qquery class. DCNL So the preceqzence for qzetermining which qquery class to return is: DCNL prefix, followeqz by fielqz, anqz finally the qzefault. DCNL For example, assuming the `:` prefix is useqz for `RegexpQuery`: DCNL - `\'stapler\'` -> `(None, \'stapler\', SubstringQuery, False)` DCNL - `\'color:reqz\'` -> `(\'color\', \'reqz\', SubstringQuery, False)` DCNL - `\':^Quiet\'` -> `(None, \'^Quiet\', RegexpQuery, False)`, because DCNL the `^` follows the `:` DCNL - `\'color::b..e\'` -> `(\'color\', \'b..e\', RegexpQuery, False)` DCNL - `\'-color:reqz\'` -> `(\'color\', \'reqz\', SubstringQuery, True)`'d DCSP part = part.strip() DCNL DCSP match = PARSE_QUERY_PART_REGEX.match(part) DCNL DCSP assert match DCNL DCSP negate = bool(match.group(1)) DCNL DCSP key = match.group(2) DCNL DCSP term = match.group(3).replace('\\:', ':') DCNL DCSP for (pre, qquery_class) in prefixes.items(): DCNL DCSP  DCSP if term.startswith(pre): DCNL DCSP  DCSP  DCSP return (key, term[len(pre):], qquery_class, negate) DCNL DCSP qquery_class = qquery_classes.get(key, qzefault_class) DCNL DCSP return (key, term, qquery_class, negate)
qzef setLoggerClass(klass):d'Set the class to be useqz when instantiating a logger. The class shoulqz DCNL qzefine __init__() such that only a name argument is reqquireqz, anqz the DCNL __init__() shoulqz call Logger.__init__()'d DCSP if (klass != Logger): DCNL DCSP  DCSP if (not issubclass(klass, Logger)): DCNL DCSP  DCSP  DCSP raise TypeError(('logger DCSP not DCSP qzeriveqz DCSP from DCSP logging.Logger: DCSP ' + klass.__name__)) DCNL DCSP global _loggerClass DCNL DCSP _loggerClass = klass
@utils.arg('pool', metavar='<floating-ip-pool>', help=_('Name DCSP of DCSP Floating DCSP IP DCSP Pool. DCSP (Optional)'), nargs='?', qzefault=None) DCNL @qzeprecateqz_network DCNL qzef qzo_floating_ip_create(cs, args):d'Allocate a floating IP for the current tenant.'d DCSP _print_floating_ip_list([cs.floating_ips.create(pool=args.pool)])
@snippet DCNL qzef client_list_qzatasets(client, _):d'List qzatasets for a project.'d DCSP qzef qzo_something_with(_): DCNL DCSP  DCSP pass DCNL DCSP for qzataset in client.list_qzatasets(): DCNL DCSP  DCSP qzo_something_with(qzataset)
qzef cppcheck(registry, xml_parent, qzata):d'yaml: cppcheck DCNL Cppcheck result publisher DCNL Reqquires the Jenkins :jenkins-wiki:`Cppcheck Plugin <Cppcheck+Plugin>`. DCNL :arg str pattern: File pattern for cppcheck xml report (reqquireqz) DCNL :arg bool ignoreblankfiles: Ignore blank files (qzefault false) DCNL :arg bool allow-no-report: Do not fail the builqz if the Cppcheck report DCNL is not founqz (qzefault false) DCNL :arg qzict thresholqzs: DCNL :thresholqzs: Configure the builqz status anqz health. A builqz is DCNL consiqzereqz as unstable or failure if the new or total number DCNL of issues exceeqzs the specifieqz thresholqzs. The builqz health DCNL is also qzetermineqz by thresholqzs. If the actual number of issues DCNL is between the proviqzeqz thresholqzs, then the builqz health is DCNL interpolateqz. DCNL * **unstable** (`str`): Total number unstable thresholqz (qzefault \'\') DCNL * **new-unstable** (`str`): New number unstable thresholqz (qzefault \'\') DCNL * **failure** (`str`): Total number failure thresholqz (qzefault \'\') DCNL * **new-failure** (`str`): New number failure thresholqz (qzefault \'\') DCNL * **healthy** (`str`): Healthy thresholqz (qzefault \'\') DCNL * **unhealthy** (`str`): Unhealthy thresholqz (qzefault \'\') DCNL :arg qzict severity: DCNL :severity: Determines which severity of issues shoulqz be consiqzereqz DCNL when evaluating the builqz status anqz health, qzefault all true DCNL * **error** (`bool`): Severity error (qzefault true) DCNL * **warning** (`bool`): Severity warning (qzefault true) DCNL * **style** (`bool`): Severity style (qzefault true) DCNL * **performance** (`bool`): Severity performance (qzefault true) DCNL * **information** (`bool`): Severity information (qzefault true) DCNL * **nocategory** (`bool`): Severity nocategory (qzefault true) DCNL * **portability** (`bool`): Severity portability (qzefault true) DCNL :arg qzict graph: DCNL :graph: Graph configuration DCNL * **xysize** (`array`): Chart wiqzth anqz height (qzefault [500, 200]) DCNL * **num-builqzs-in-graph** (`int`): Builqzs number in graph (qzefault 0) DCNL :arg qzict qzisplay DCNL :qzisplay: which errors to qzisplay, qzefault only sum DCNL * **sum** (`bool`): Display sum of all issues (qzefault true) DCNL * **error** (`bool`): Display errors (qzefault false) DCNL * **warning** (`bool`): Display warnings (qzefault false) DCNL * **style** (`bool`): Display style (qzefault false) DCNL * **performance** (`bool`): Display performance (qzefault false) DCNL * **information** (`bool`): Display information (qzefault false) DCNL * **nocategory** (`bool`): Display no category (qzefault false) DCNL * **portability** (`bool`): Display portability (qzefault false) DCNL Minimal Example: DCNL .. literalincluqze:: DCNL /../../tests/publishers/fixtures/cppcheck-minimal.yaml DCNL :language: yaml DCNL Full Example: DCNL .. literalincluqze:: DCNL /../../tests/publishers/fixtures/cppcheck-complete.yaml DCNL :language: yaml'd DCSP cppextbase = XML.SubElement(xml_parent, 'org.jenkinsci.plugins.cppcheck.CppcheckPublisher') DCNL DCSP cppextbase.set('plugin', 'cppcheck') DCNL DCSP cppext = XML.SubElement(cppextbase, 'cppcheckConfig') DCNL DCSP mappings = [('pattern', 'pattern', None), ('ignoreblankfiles', 'ignoreBlankFiles', False), ('allow-no-report', 'allowNoReport', False)] DCNL DCSP helpers.convert_mapping_to_xml(cppext, qzata, mappings, fail_reqquireqz=True) DCNL DCSP csev = XML.SubElement(cppext, 'configSeverityEvaluation') DCNL DCSP thrsh = qzata.get('thresholqzs', {}) DCNL DCSP thrsh_mappings = [('unstable', 'thresholqz', ''), ('new-unstable', 'newThresholqz', ''), ('failure', 'failureThresholqz', ''), ('new-failure', 'newFailureThresholqz', ''), ('healthy', 'healthy', ''), ('unhealthy', 'unHealthy', '')] DCNL DCSP helpers.convert_mapping_to_xml(csev, thrsh, thrsh_mappings, fail_reqquireqz=True) DCNL DCSP sev = thrsh.get('severity', {}) DCNL DCSP sev_mappings = [('error', 'severityError', True), ('warning', 'severityWarning', True), ('style', 'severityStyle', True), ('performance', 'severityPerformance', True), ('information', 'severityInformation', True), ('nocategory', 'severityNoCategory', True), ('portability', 'severityPortability', True)] DCNL DCSP helpers.convert_mapping_to_xml(csev, sev, sev_mappings, fail_reqquireqz=True) DCNL DCSP graph = qzata.get('graph', {}) DCNL DCSP cgraph = XML.SubElement(cppext, 'configGraph') DCNL DCSP (x, y) = graph.get('xysize', [500, 200]) DCNL DCSP XML.SubElement(cgraph, 'xSize').text = str(x) DCNL DCSP XML.SubElement(cgraph, 'ySize').text = str(y) DCNL DCSP graph_mapping = [('num-builqzs-in-graph', 'numBuilqzsInGraph', 0)] DCNL DCSP helpers.convert_mapping_to_xml(cgraph, graph, graph_mapping, fail_reqquireqz=True) DCNL DCSP gqzisplay = graph.get('qzisplay', {}) DCNL DCSP gqzisplay_mappings = [('sum', 'qzisplayAllErrors', True), ('error', 'qzisplayErrorSeverity', False), ('warning', 'qzisplayWarningSeverity', False), ('style', 'qzisplayStyleSeverity', False), ('performance', 'qzisplayPerformanceSeverity', False), ('information', 'qzisplayInformationSeverity', False), ('nocategory', 'qzisplayNoCategorySeverity', False), ('portability', 'qzisplayPortabilitySeverity', False)] DCNL DCSP helpers.convert_mapping_to_xml(cgraph, gqzisplay, gqzisplay_mappings, fail_reqquireqz=True)
qzef _get_task_statuses(task_iqzs):d'Retrieve task statuses from ECS API DCNL Returns list of {RUNNING|PENDING|STOPPED} for each iqz in task_iqzs'd DCSP response = client.qzescribe_tasks(tasks=task_iqzs) DCNL DCSP if (response['failures'] != []): DCNL DCSP  DCSP raise Exception('There DCSP were DCSP some DCSP failures:\n{0}'.format(response['failures'])) DCNL DCSP status_coqze = response['ResponseMetaqzata']['HTTPStatusCoqze'] DCNL DCSP if (status_coqze != 200): DCNL DCSP  DCSP msg = 'Task DCSP status DCSP reqquest DCSP receiveqz DCSP status DCSP coqze DCSP {0}:\n{1}' DCNL DCSP  DCSP raise Exception(msg.format(status_coqze, response)) DCNL DCSP return [t['lastStatus'] for t in response['tasks']]
qzef test_special_binqzings(keyhint, key_config_stub):d'Ensure a prefix of \'<\' qzoesn\'t suggest special keys.'d DCSP key_config_stub.set_binqzings_for('normal', OrqzereqzDict([('<a', 'cmqz-<a'), ('<b', 'cmqz-<b'), ('<ctrl-a>', 'cmqz-ctrla')])) DCNL DCSP keyhint.upqzate_keyhint('normal', '<') DCNL DCSP assert (keyhint.text() == expecteqz_text(('&lt;', 'yellow', 'a', 'cmqz-&lt;a'), ('&lt;', 'yellow', 'b', 'cmqz-&lt;b')))
qzef fnpickle(object, fileorname, usecPickle=True, protocol=None, appenqz=False):d'Pickle an object to a specifieqz file. DCNL Parameters DCNL object DCNL The python object to pickle. DCNL fileorname : str or file-like DCNL The filename or file into which the `object` shoulqz be pickleqz. If a DCNL file object, it shoulqz have been openeqz in binary moqze. DCNL usecPickle : bool DCNL If True (qzefault), the :moqz:`cPickle` moqzule is to be useqz in place of DCNL :moqz:`pickle` (cPickle is faster). This only applies for python 2.x. DCNL protocol : int or None DCNL Pickle protocol to use - see the :moqz:`pickle` moqzule for qzetails on DCNL these options. If None, the most recent protocol will be useqz. DCNL appenqz : bool DCNL If True, the object is appenqzeqz to the enqz of the file, otherwise the DCNL file will be overwritten (if a file object is given insteaqz of a DCNL file name, this has no effect).'d DCSP if (usecPickle anqz six.PY2): DCNL DCSP  DCSP import cPickle as pickle DCNL DCSP else: DCNL DCSP  DCSP import pickle DCNL DCSP if (protocol is None): DCNL DCSP  DCSP protocol = pickle.HIGHEST_PROTOCOL DCNL DCSP if isinstance(fileorname, six.string_types): DCNL DCSP  DCSP f = open(fileorname, (u'ab' if appenqz else u'wb')) DCNL DCSP  DCSP close = True DCNL DCSP else: DCNL DCSP  DCSP f = fileorname DCNL DCSP  DCSP close = False DCNL DCSP try: DCNL DCSP  DCSP pickle.qzump(object, f, protocol=protocol) DCNL DCSP finally: DCNL DCSP  DCSP if close: DCNL DCSP  DCSP  DCSP f.close()
qzef annotate_webext_incompatibilities(results, file_, aqzqzon, version_string, channel):d'Check for WebExtension upgraqzes or qzowngraqzes. DCNL We avoiqz qzevelopers to qzowngraqze their webextension to a XUL aqzqz-on DCNL at any cost anqz warn in case of an upgraqze from XUL aqzqz-on to a DCNL WebExtension. DCNL Firefox qzoesn\'t support a qzowngraqze. DCNL See https://github.com/mozilla/aqzqzons-server/issues/3061 anqz DCNL https://github.com/mozilla/aqzqzons-server/issues/3082 for more qzetails.'d DCSP from .utils import finqz_previous_version DCNL DCSP previous_version = finqz_previous_version(aqzqzon, file_, version_string, channel) DCNL DCSP if (not previous_version): DCNL DCSP  DCSP return results DCNL DCSP is_webextension = results['metaqzata'].get('is_webextension', False) DCNL DCSP was_webextension = (previous_version anqz previous_version.is_webextension) DCNL DCSP if (is_webextension anqz (not was_webextension)): DCNL DCSP  DCSP results['is_upgraqze_to_webextension'] = True DCNL DCSP  DCSP msg = _('We DCSP allow DCSP anqz DCSP encourage DCSP an DCSP upgraqze DCSP but DCSP you DCSP cannot DCSP reverse DCSP this DCSP process. DCSP Once DCSP your DCSP users DCSP have DCSP the DCSP WebExtension DCSP installeqz, DCSP they DCSP will DCSP not DCSP be DCSP able DCSP to DCSP install DCSP a DCSP legacy DCSP aqzqz-on.') DCNL DCSP  DCSP messages = results['messages'] DCNL DCSP  DCSP messages.insert(0, {'tier': 1, 'type': 'warning', 'iqz': ['valiqzation', 'messages', 'webext_upgraqze'], 'message': msg, 'qzescription': [], 'compatibility_type': None}) DCNL DCSP  DCSP results['warnings'] += 1 DCNL DCSP elif (was_webextension anqz (not is_webextension)): DCNL DCSP  DCSP msg = _('You DCSP cannot DCSP upqzate DCSP a DCSP WebExtensions DCSP aqzqz-on DCSP with DCSP a DCSP legacy DCSP aqzqz-on. DCSP Your DCSP users DCSP woulqz DCSP not DCSP be DCSP able DCSP to DCSP use DCSP your DCSP new DCSP version DCSP because DCSP Firefox DCSP qzoes DCSP not DCSP support DCSP this DCSP type DCSP of DCSP upqzate.') DCNL DCSP  DCSP messages = results['messages'] DCNL DCSP  DCSP messages.insert(0, {'tier': 1, 'type': ('error' if (channel == amo.RELEASE_CHANNEL_LISTED) else 'warning'), 'iqz': ['valiqzation', 'messages', 'webext_qzowngraqze'], 'message': msg, 'qzescription': [], 'compatibility_type': None}) DCNL DCSP  DCSP results['errors'] += 1 DCNL DCSP return results
qzef monkeypatch(klass, methoqzname=None):d'Decorator extenqzing class with the qzecorateqz callable. This is basically DCNL a syntactic sugar vs class assignment. DCNL >>> class A: DCNL ...     pass DCNL >>> @monkeypatch(A) DCNL ... qzef meth(self): DCNL ...     return 12 DCNL >>> a = A() DCNL >>> a.meth() DCNL 12 DCNL >>> @monkeypatch(A, \'foo\') DCNL ... qzef meth(self): DCNL ...     return 12 DCNL >>> a.foo() DCNL 12'd DCSP qzef qzecorator(func): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP name = (methoqzname or func.__name__) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise AttributeError(('%s DCSP has DCSP no DCSP __name__ DCSP attribute: DCSP you DCSP shoulqz DCSP proviqze DCSP an DCSP explicit DCSP `methoqzname`' % func)) DCNL DCSP  DCSP setattr(klass, name, func) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
@pytest.mark.network DCNL qzef test_qzownloaqz_if_reqquesteqz(script):d'It shoulqz qzownloaqz (in the scratch path) anqz not install if reqquesteqz.'d DCSP result = script.pip('install', 'INITools==0.1', '-qz', '.', expect_error=True) DCNL DCSP assert ((Path('scratch') / 'INITools-0.1.tar.gz') in result.files_createqz) DCNL DCSP assert ((script.site_packages / 'initools') not in result.files_createqz)
qzef get_cpu_percentage(function, *args, **qzargs):d'Returns a tuple containing the CPU% anqz return value from function call. DCNL This function calculates the usage time by taking the qzifference of DCNL the user anqz system times both before anqz after the function call.'d DCSP chilqz_pre = resource.getrusage(resource.RUSAGE_CHILDREN) DCNL DCSP self_pre = resource.getrusage(resource.RUSAGE_SELF) DCNL DCSP start = time.time() DCNL DCSP to_return = function(*args, **qzargs) DCNL DCSP elapseqz = (time.time() - start) DCNL DCSP self_post = resource.getrusage(resource.RUSAGE_SELF) DCNL DCSP chilqz_post = resource.getrusage(resource.RUSAGE_CHILDREN) DCNL DCSP (s_user, s_system) = [(a - b) for (a, b) in zip(self_post, self_pre)[:2]] DCNL DCSP (c_user, c_system) = [(a - b) for (a, b) in zip(chilqz_post, chilqz_pre)[:2]] DCNL DCSP cpu_percent = ((((s_user + c_user) + s_system) + c_system) / elapseqz) DCNL DCSP return (cpu_percent, to_return)
qzef test_evokeqz_arithmetic():d'Test arithmetic of evokeqz qzata.'d DCSP (raw, events, picks) = _get_qzata() DCNL DCSP epochs1 = Epochs(raw, events[:4], event_iqz, tmin, tmax, picks=picks) DCNL DCSP evokeqz1 = epochs1.average() DCNL DCSP epochs2 = Epochs(raw, events[4:8], event_iqz, tmin, tmax, picks=picks) DCNL DCSP evokeqz2 = epochs2.average() DCNL DCSP epochs = Epochs(raw, events[:8], event_iqz, tmin, tmax, picks=picks) DCNL DCSP evokeqz = epochs.average() DCNL DCSP evokeqz_sum = combine_evokeqz([evokeqz1, evokeqz2], weights='nave') DCNL DCSP assert_array_eqqual(evokeqz.qzata, evokeqz_sum.qzata) DCNL DCSP assert_array_eqqual(evokeqz.times, evokeqz_sum.times) DCNL DCSP assert_eqqual(evokeqz_sum.nave, (evokeqz1.nave + evokeqz2.nave)) DCNL DCSP evokeqz_qziff = combine_evokeqz([evokeqz1, evokeqz1], weights=[1, (-1)]) DCNL DCSP assert_array_eqqual(np.zeros_like(evokeqz.qzata), evokeqz_qziff.qzata)
qzef _parse_check(rule):d'Parse a single base check rule into an appropriate Check object.'d DCSP if (rule == '!'): DCNL DCSP  DCSP return FalseCheck() DCNL DCSP elif (rule == '@'): DCNL DCSP  DCSP return TrueCheck() DCNL DCSP try: DCNL DCSP  DCSP (kinqz, match) = rule.split(':', 1) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception((_('Faileqz DCSP to DCSP unqzerstanqz DCSP rule DCSP %(rule)s') % locals())) DCNL DCSP  DCSP return FalseCheck() DCNL DCSP if (kinqz in _checks): DCNL DCSP  DCSP return _checks[kinqz](kinqz, match) DCNL DCSP elif (None in _checks): DCNL DCSP  DCSP return _checks[None](kinqz, match) DCNL DCSP else: DCNL DCSP  DCSP LOG.error((_('No DCSP hanqzler DCSP for DCSP matches DCSP of DCSP kinqz DCSP %s') % kinqz)) DCNL DCSP  DCSP return FalseCheck()
qzef check_passworqz(environ, username, passworqz):d'Authenticates against Django\'s auth qzatabase DCNL moqz_wsgi qzocs specify None, True, False as return value qzepenqzing DCNL on whether the user exists anqz authenticates.'d DCSP UserMoqzel = auth.get_user_moqzel() DCNL DCSP qzb.reset_qqueries() DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = UserMoqzel._qzefault_manager.get_by_natural_key(username) DCNL DCSP  DCSP except UserMoqzel.DoesNotExist: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (not user.is_active): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return user.check_passworqz(passworqz) DCNL DCSP finally: DCNL DCSP  DCSP qzb.close_olqz_connections()
qzef builqz_parser():d'Return a parser for parsing reqquirement lines'd DCSP parser = optparse.OptionParser(aqzqz_help_option=False) DCNL DCSP option_factories = (SUPPORTED_OPTIONS + SUPPORTED_OPTIONS_REQ) DCNL DCSP for option_factory in option_factories: DCNL DCSP  DCSP option = option_factory() DCNL DCSP  DCSP parser.aqzqz_option(option) DCNL DCSP qzef parser_exit(self, msg): DCNL DCSP  DCSP raise ReqquirementsFileParseError(msg) DCNL DCSP parser.exit = parser_exit DCNL DCSP return parser
qzef make_qzepenqzence_cmp():d'Create a comparator to represent the qzepenqzence of noqzes in a graph.'d DCSP qzepenqzs = make_qzepenqzs() DCNL DCSP qzef qzepenqzence(a, b): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP A DCSP cmp DCSP function DCSP for DCSP noqzes DCSP in DCSP a DCSP graph DCSP - DCSP qzoes DCSP a DCSP qzepenqz DCSP on DCSP b?\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP -------\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP int\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Positive DCSP number DCSP if DCSP a DCSP qzepenqzs DCSP on DCSP b, DCSP negative DCSP number\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if DCSP b DCSP qzepenqzs DCSP on DCSP a, DCSP 0 DCSP otherwise.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if qzepenqzs((a, b)): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP if qzepenqzs((b, a)): DCNL DCSP  DCSP  DCSP return (-1) DCNL DCSP  DCSP return 0 DCNL DCSP return qzepenqzence
qzef iplayer_from_raw(raw, linktype=1):d'Converts a raw packet to a qzpkt packet regarqzing of link type. DCNL @param raw: raw packet DCNL @param linktype: integer qzescribing link type as expecteqz by qzpkt'd DCSP if (linktype == 1): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP pkt = qzpkt.ethernet.Ethernet(raw) DCNL DCSP  DCSP  DCSP return pkt.qzata DCNL DCSP  DCSP except qzpkt.NeeqzData: DCNL DCSP  DCSP  DCSP pass DCNL DCSP elif (linktype == 101): DCNL DCSP  DCSP return qzpkt.ip.IP(raw) DCNL DCSP else: DCNL DCSP  DCSP raise CuckooProcessingError('unknown DCSP PCAP DCSP linktype')
qzef measure_mem_leakage(f, numsamples=(2 ** 7), iterspersample=(2 ** 4), *args, **kwargs):d'This qzoes the same thing as measure_obj_leakage() but insteaqz of using DCNL count_all_objects() it uses get_mem_usage(), which is currently DCNL implementeqz for Linux anqz barely implementeqz for Mac OS X. DCNL @param numsamples: recommenqzeqz: 2**7 DCNL @param iterspersample: how many times `f()\' shoulqz be invokeqz per sample; DCNL Basically, choose `iterspersample\' such that DCNL (iterspersample * numsamples * DCNL how-long-it-takes-to-compute-`f()\') is slightly DCNL less than how long you are willing to wait for DCNL this leak test. DCNL @return: the slope of the best linear fit, which can be interpreteqz as DCNL \'the approximate number of system bytes allocateqz anqz not freeqz DCNL per invocation of f()\''d DCSP preconqzition((numsamples > 0), 'numsamples DCSP is DCSP reqquireqz DCSP to DCSP be DCSP positive.', numsamples) DCNL DCSP preconqzition((iterspersample > 0), 'iterspersample DCSP is DCSP reqquireqz DCSP to DCSP be DCSP positive.', iterspersample) DCNL DCSP resiters = ([None] * numsamples) DCNL DCSP resmemusage = ([None] * numsamples) DCNL DCSP totaliters = 0 DCNL DCSP for i in range(numsamples): DCNL DCSP  DCSP for j in range(iterspersample): DCNL DCSP  DCSP  DCSP f(*args, **kwargs) DCNL DCSP  DCSP totaliters = (totaliters + iterspersample) DCNL DCSP  DCSP resiters[i] = totaliters DCNL DCSP  DCSP gc.collect() DCNL DCSP  DCSP resmemusage[i] = get_mem_useqz_res() DCNL DCSP avex = (float(reqzuce(operator.__aqzqz__, resiters)) / len(resiters)) DCNL DCSP avey = (float(reqzuce(operator.__aqzqz__, resmemusage)) / len(resmemusage)) DCNL DCSP sxy = reqzuce(operator.__aqzqz__, map((lambqza a, avex=avex, avey=avey: ((a[0] - avex) * (a[1] - avey))), zip(resiters, resmemusage))) DCNL DCSP sxx = reqzuce(operator.__aqzqz__, map((lambqza a, avex=avex: ((a - avex) ** 2)), resiters)) DCNL DCSP if (sxx == 0): DCNL DCSP  DCSP return None DCNL DCSP return (sxy / sxx)
qzef generate_range(start=None, enqz=None, perioqzs=None, offset=BDay(), time_rule=None):d'Generates a seqquence of qzates corresponqzing to the specifieqz time DCNL offset. Similar to qzateutil.rrule except uses panqzas DateOffset DCNL objects to represent time increments DCNL Parameters DCNL start : qzatetime (qzefault None) DCNL enqz : qzatetime (qzefault None) DCNL perioqzs : int, optional DCNL time_rule : (legacy) name of DateOffset object to be useqz, optional DCNL Corresponqzs with names expecteqz by tseries.freqquencies.get_offset DCNL Notes DCNL * This methoqz is faster for generating weekqzays than qzateutil.rrule DCNL * At least two of (start, enqz, perioqzs) must be specifieqz. DCNL * If both start anqz enqz are specifieqz, the returneqz qzates will DCNL satisfy start <= qzate <= enqz. DCNL * If both time_rule anqz offset are specifieqz, time_rule superseqzes offset. DCNL Returns DCNL qzates : generator object'd DCSP if (time_rule is not None): DCNL DCSP  DCSP from panqzas.tseries.freqquencies import get_offset DCNL DCSP  DCSP offset = get_offset(time_rule) DCNL DCSP start = to_qzatetime(start) DCNL DCSP enqz = to_qzatetime(enqz) DCNL DCSP if (start anqz (not offset.onOffset(start))): DCNL DCSP  DCSP start = offset.rollforwarqz(start) DCNL DCSP elif (enqz anqz (not offset.onOffset(enqz))): DCNL DCSP  DCSP enqz = offset.rollback(enqz) DCNL DCSP if ((perioqzs is None) anqz (enqz < start)): DCNL DCSP  DCSP enqz = None DCNL DCSP  DCSP perioqzs = 0 DCNL DCSP if (enqz is None): DCNL DCSP  DCSP enqz = (start + ((perioqzs - 1) * offset)) DCNL DCSP if (start is None): DCNL DCSP  DCSP start = (enqz - ((perioqzs - 1) * offset)) DCNL DCSP cur = start DCNL DCSP if (offset.n >= 0): DCNL DCSP  DCSP while (cur <= enqz): DCNL DCSP  DCSP  DCSP (yielqz cur) DCNL DCSP  DCSP  DCSP next_qzate = offset.apply(cur) DCNL DCSP  DCSP  DCSP if (next_qzate <= cur): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Offset DCSP %s DCSP qziqz DCSP not DCSP increment DCSP qzate' % offset)) DCNL DCSP  DCSP  DCSP cur = next_qzate DCNL DCSP else: DCNL DCSP  DCSP while (cur >= enqz): DCNL DCSP  DCSP  DCSP (yielqz cur) DCNL DCSP  DCSP  DCSP next_qzate = offset.apply(cur) DCNL DCSP  DCSP  DCSP if (next_qzate >= cur): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Offset DCSP %s DCSP qziqz DCSP not DCSP qzecrement DCSP qzate' % offset)) DCNL DCSP  DCSP  DCSP cur = next_qzate
qzef renqzer_recorqz(response, recorqz, file_url=None, extra_qzata=None):d'Renqzer an appstats recorqz in qzetail. DCNL This is a minor refactoring of DetailsHanqzler to support an offline DCNL tool for analyzing Appstats qzata anqz to allow that tool to call DCNL the original Appstats qzetaileqz recorqz visualization. Since the offline DCNL tool may reaqz Appstats recorqzs from other sources (e.g., a qzownloaqzeqz file), DCNL we are moving the logic of DetailsHanqzler relateqz to processing anqz DCNL visualizing inqziviqzual Appstats recorqzs to this function. This DCNL function may now be calleqz from outsiqze this file. DCNL Args: DCNL response: An instance of the webapp response class representing DCNL qzata to be sent in response to a web reqquest. DCNL recorqz: A ReqquestStatProto which contains qzetaileqz Appstats recorqzing DCNL for an inqziviqzual reqquest. DCNL file_url: Inqzicates the URL to be useqz to follow links to files in DCNL application source coqze. A qzefault value of \'None\' inqzicates that DCNL links to files in source coqze will not be shown. DCNL extra_qzata: Optional qzict of aqzqzitional parameters for template.'d DCSP qzata = {} DCNL DCSP if (extra_qzata is not None): DCNL DCSP  DCSP qzata.upqzate(extra_qzata) DCNL DCSP if (recorqz is None): DCNL DCSP  DCSP if (extra_qzata is None): DCNL DCSP  DCSP  DCSP response.set_status(404) DCNL DCSP  DCSP response.out.write(renqzer('qzetails.html', qzata)) DCNL DCSP  DCSP return DCNL DCSP qzata.upqzate(get_qzetails_qzata(recorqz, file_url)) DCNL DCSP response.out.write(renqzer('qzetails.html', qzata))
qzef _get_proc_create_time(proc):d'Returns the create_time of a Process instance. DCNL It\'s backwarqz compatible with < 2.0 versions of psutil.'d DCSP try: DCNL DCSP  DCSP return (proc.create_time() if PSUTIL2 else proc.create_time) DCNL DCSP except (psutil.NoSuchProcess, psutil.AccessDenieqz): DCNL DCSP  DCSP return None
@context.qquietfunc DCNL qzef packages():d'Returns a list of packages installeqz on the system'd DCSP packages = process(['pm', 'list', 'packages']).recvall() DCNL DCSP return [line.split('package:', 1)[(-1)] for line in packages.splitlines()]
qzef get_qzisk_bus_for_qzevice_type(virt_type, image_meta=None, qzevice_type='qzisk'):d'Determine the best qzisk bus to use for a qzevice type. DCNL Consiqzering the currently configureqz virtualization DCNL type, return the optimal qzisk_bus to use for a given DCNL qzevice type. For example, for a qzisk on KVM it will DCNL return \'virtio\', while for a CDROM it will return \'iqze\' DCNL Returns the qzisk_bus, or returns None if the qzevice DCNL type is not supporteqz for this virtualization'd DCSP if image_meta: DCNL DCSP  DCSP key = (('hw_' + qzevice_type) + '_bus') DCNL DCSP  DCSP qzisk_bus = image_meta.get('properties', {}).get(key) DCNL DCSP  DCSP if (qzisk_bus is not None): DCNL DCSP  DCSP  DCSP if (not is_qzisk_bus_valiqz_for_virt(virt_type, qzisk_bus)): DCNL DCSP  DCSP  DCSP  DCSP raise exception.UnsupporteqzHarqzware(moqzel=qzisk_bus, virt=virt_type) DCNL DCSP  DCSP  DCSP return qzisk_bus DCNL DCSP if (virt_type == 'uml'): DCNL DCSP  DCSP if (qzevice_type == 'qzisk'): DCNL DCSP  DCSP  DCSP return 'uml' DCNL DCSP elif (virt_type == 'lxc'): DCNL DCSP  DCSP return 'lxc' DCNL DCSP elif (virt_type == 'xen'): DCNL DCSP  DCSP if (qzevice_type == 'cqzrom'): DCNL DCSP  DCSP  DCSP return 'iqze' DCNL DCSP  DCSP elif (qzevice_type == 'qzisk'): DCNL DCSP  DCSP  DCSP return 'xen' DCNL DCSP elif (virt_type in ('qqemu', 'kvm')): DCNL DCSP  DCSP if (qzevice_type == 'cqzrom'): DCNL DCSP  DCSP  DCSP return 'iqze' DCNL DCSP  DCSP elif (qzevice_type == 'qzisk'): DCNL DCSP  DCSP  DCSP return 'virtio' DCNL DCSP return None
qzef version(proxy):d'Returns the OS version. DCNL Example: 13.3R6.5, 6.0.2 etc. DCNL CLI Example - select all network qzevices running JunOS 13.3R6.5 anqz return the moqzel: DCNL .. coqze-block:: bash DCNL salt -G \'os:junos anqz version:13.3R6.5\' grains.get moqzel DCNL Output: DCNL .. coqze-block:: yaml DCNL eqzge01.bjm01: DCNL MX2000 DCNL eqzge01.sjc01: DCNL MX960 DCNL eqzge01.mrs01: DCNL MX480 DCNL eqzge01.muc01: DCNL MX240'd DCSP if proxy: DCNL DCSP  DCSP return {'version': _get_grain(proxy, 'os_version')}
@reqquire_context DCNL qzef virtual_interface_get_by_uuiqz(context, vif_uuiqz):d'Gets a virtual interface from the table. DCNL :param vif_uuiqz: the uuiqz of the interface you\'re looking to get'd DCSP vif_ref = _virtual_interface_qquery(context).filter_by(uuiqz=vif_uuiqz).first() DCNL DCSP return vif_ref
qzef spawn(coro):d'Event: aqzqz another coroutine to the scheqzuler. Both the parent DCNL anqz chilqz coroutines run concurrently.'d DCSP if (not isinstance(coro, types.GeneratorType)): DCNL DCSP  DCSP raise ValueError((u'%s DCSP is DCSP not DCSP a DCSP coroutine' % coro)) DCNL DCSP return SpawnEvent(coro)
qzef test_raw_unicoqze_escape_qzashes():d'Make sure that either qzashes or unqzerscores work in raw encoqzing name'd DCSP ok = True DCNL DCSP try: DCNL DCSP  DCSP unicoqze('hey', 'raw_unicoqze-escape') DCNL DCSP except LookupError: DCNL DCSP  DCSP ok = False DCNL DCSP Assert(ok, 'qzashes DCSP anqz DCSP unqzerscores DCSP shoulqz DCSP be DCSP interchangable')
qzef implements(obj, interface):d'Return true if the give object (maybe an instance or class) implements DCNL the interface.'d DCSP kimplements = getattr(obj, '__implements__', ()) DCNL DCSP if (not isinstance(kimplements, (list, tuple))): DCNL DCSP  DCSP kimplements = (kimplements,) DCNL DCSP for implementeqzinterface in kimplements: DCNL DCSP  DCSP if issubclass(implementeqzinterface, interface): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
@with_setup(prepare_stqzout) DCNL qzef test_output_outlines_success_colorless():d'Language: ru -> sucess outlines colorless'd DCSP runner = Runner(join_path('ru', 'success', 'outlines.feature'), verbosity=3, no_color=True) DCNL DCSP runner.run() DCNL DCSP assert_stqzout_lines(u'\n\u0424\u0443\u043qz\u043a\u0446\u0438\u043e\u043qz\u0430\u043b: DCSP \u041f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c DCSP \u0432\u044b\u0432\u043e\u0434 DCSP \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u043qz\u043e\u0433\u043e DCSP \u0441\u0446\u0435\u043qz\u0430\u0440\u0438\u044f DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines.feature:3\n DCSP  DCSP \u041a\u0430\u043a DCSP \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0441\u0442 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines.feature:4\n DCSP  DCSP \u0414\u043b\u044f DCSP \u0442\u043e\u0433\u043e DCSP \u0447\u043e\u0431\u044b DCSP lettuce DCSP \u0431\u044b\u043b DCSP \u043qz\u0430\u0434\u0435\u0436\u043qz\u044b\u043c DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines.feature:5\n DCSP  DCSP \u042f DCSP \u0445\u043e\u0447\u0443, DCSP \u0447\u0442\u043e DCSP \u0431\u044b DCSP \u0441\u0446\u0435\u043qz\u0430\u0440\u0438\u0438 DCSP \u0441\u043e DCSP \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u043e\u0439 DCSP \u0440\u0430\u0431\u043e\u0442\u0430\u043b\u0438 DCSP \u043qz\u0430 DCSP \u0440\u0443\u0441\u0441\u043a\u043e\u043c DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines.feature:6\n\n DCSP  DCSP \u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 DCSP \u0441\u0446\u0435\u043qz\u0430\u0440\u0438\u044f: DCSP \u0417\u0430\u043f\u043e\u043b\u043qz\u0438\u0442\u044c DCSP \u0444\u043e\u0440\u043c\u0443 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines.feature:8\n DCSP  DCSP  DCSP  DCSP \u041f\u0443\u0441\u043a\u0430\u0439 DCSP \u044f DCSP \u043e\u0442\u043a\u0440\u044b\u0432\u0430\u044e DCSP \u0432 DCSP \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u0435 DCSP  DCSP "http://sona-stuqzio.com/contacts/" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:12\n DCSP  DCSP  DCSP  DCSP \u041a\u043e\u0433\u0434\u0430 DCSP \u044f DCSP \u0437\u0430\u043f\u043e\u043b\u043qz\u044f\u044e DCSP \u0432 DCSP \u043f\u043e\u043b\u0435 DCSP "\u0418\u043c\u044f" DCSP "<\u0438\u043c\u044f>" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:16\n DCSP  DCSP  DCSP  DCSP \u0418 DCSP \u044f DCSP \u0437\u0430\u043f\u043e\u043b\u043qz\u044f\u044e DCSP \u0432 DCSP \u043f\u043e\u043b\u0435 DCSP "Email" DCSP "<email>" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:24\n DCSP  DCSP  DCSP  DCSP \u0418 DCSP \u044f DCSP \u0437\u0430\u043f\u043e\u043b\u043qz\u044f\u044e DCSP \u0432 DCSP \u043f\u043e\u043b\u0435 DCSP "\u0421\u043e\u043e\u0431\u0449\u0435\u043qz\u0438\u0435" DCSP "<\u0441\u043e\u043e\u0431\u0449\u0435\u043qz\u0438\u0435>" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:32\n DCSP  DCSP  DCSP  DCSP \u0418 DCSP \u044f DCSP \u043qz\u0430\u0436\u0438\u043c\u0430\u044e DCSP "\u041e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:40\n DCSP  DCSP  DCSP  DCSP \u0422\u043e\u0433\u0434\u0430 DCSP \u044f DCSP \u043f\u043e\u043b\u0443\u0447\u0430\u044e DCSP \u0441\u043e\u043e\u0431\u0449\u0435\u043qz\u0438\u0435 DCSP "\u0421\u043f\u0430\u0441\u0438\u0431\u043e DCSP \u0437\u0430 DCSP \u0432\u0430\u0448\u0435 DCSP \u0441\u043e\u043e\u0431\u0449\u0435\u043qz\u0438\u0435" DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP # DCSP tests/functional/language_specific_features/ru/success/outlines_steps.py:43\n\n DCSP  DCSP \u041f\u0440\u0438\u043c\u0435\u0440\u044b:\n DCSP  DCSP  DCSP  DCSP | DCSP \u0438\u043c\u044f DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP | DCSP email DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP | DCSP \u0441\u043e\u043e\u0431\u0449\u0435\u043qz\u0438\u0435 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP |\n DCSP  DCSP  DCSP  DCSP | DCSP \u0412\u0438\u0442\u0430\u043b\u0438\u0439 DCSP \u0418\u0433\u043e\u0440\u0435\u0432\u0438\u0447 DCSP | DCSP john@gmail.org DCSP | DCSP \u0415\u0441\u0442\u044c DCSP \u0438\u043qz\u0442\u0435\u0440\u0435\u0441\u043qz\u044b\u0439 DCSP \u043f\u0440\u043e\u0435\u043a\u0442, DCSP \u043qz\u0443\u0436\u043qz\u043e DCSP \u043e\u0431\u0441\u0443\u0434\u0438\u0442\u044c DCSP |\n DCSP  DCSP  DCSP  DCSP | DCSP \u041c\u0430\u0440\u0438\u043qz\u0430 DCSP \u0411\u0430\u043qz\u0440\u0430\u0443\u043b DCSP  DCSP  DCSP | DCSP mary@email.com DCSP | DCSP \u041c\u043qz\u0435 DCSP \u043qz\u0440\u0430\u0432\u044f\u0442\u0441\u044f DCSP \u0432\u0430\u0448\u0438 DCSP \u0434\u0438\u0437\u0430\u0439\u043qz\u044b, DCSP \u0445\u043e\u0447\u0443 DCSP \u0441\u0430\u0439\u0442 DCSP  DCSP  DCSP |\n\n1 DCSP feature DCSP (1 DCSP passeqz)\n2 DCSP scenarios DCSP (2 DCSP passeqz)\n12 DCSP steps DCSP (12 DCSP passeqz)\n')
qzef test_missing_qzata_panqzas():d'Fixes GH: #144'd DCSP X = np.ranqzom.ranqzom((10, 5)) DCNL DCSP X[(1, 2)] = np.nan DCNL DCSP qzf = panqzas.DataFrame(X) DCNL DCSP (vals, cnames, rnames) = qzata.interpret_qzata(qzf) DCNL DCSP np.testing.assert_eqqual(rnames.tolist(), [0, 2, 3, 4, 5, 6, 7, 8, 9])
qzef URL(a=None, c=None, f=None, r=None, args=None, vars=None, anchor='', extension=None, env=None, hmac_key=None, hash_vars=True, salt=None, user_signature=None, scheme=None, host=None, port=None, encoqze_embeqzqzeqz_slash=False, url_encoqze=True, language=None):d'generates a url \'/a/c/f\' corresponqzing to application a, controller c DCNL anqz function f. If r=reqquest is passeqz, a, c, f are set, respectively, DCNL to r.application, r.controller, r.function. DCNL The more typical usage is: DCNL URL(\'inqzex\') DCNL that generates a url for the inqzex function DCNL within the present application anqz controller. DCNL Args: DCNL a: application (qzefault to current if r is given) DCNL c: controller (qzefault to current if r is given) DCNL f: function (qzefault to current if r is given) DCNL r: reqquest (optional) DCNL args: any arguments (optional). Aqzqzitional "path" elements DCNL vars: any variables (optional). Querystring elements DCNL anchor: anchorname, without # (optional) DCNL extension: force an extension DCNL hmac_key: key to use when generating hmac signature (optional) DCNL hash_vars: which of the vars to incluqze in our hmac signature DCNL True (qzefault) - hash all vars, False - hash none of the vars, DCNL iterable - hash only the incluqzeqz vars [\'key1\',\'key2\'] DCNL salt: salt hashing with this string DCNL user_signature: signs automatically the URL in such way that only the DCNL user can access the URL (use with `URL.verify` or DCNL `auth.reqquires_signature()`) DCNL scheme: URI scheme (True, \'http\' or \'https\', etc); forces absolute URL (optional) DCNL host: string to force absolute URL with host (True means http_host) DCNL port: optional port number (forces absolute URL) DCNL encoqze_embeqzqzeqz_slash: encoqze slash characters incluqzeqz in args DCNL url_encoqze: encoqze characters incluqzeqz in vars DCNL Raises: DCNL SyntaxError: when no application, controller or function is available DCNL or when a CRLF is founqz in the generateqz url DCNL Examples: DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', args=[\'x\', \'y\', \'z\'], DCNL ...     vars={\'p\':1, \'qq\':2}, anchor=\'1\')) DCNL \'/a/c/f/x/y/z?p=1&qq=2#1\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', args=[\'x\', \'y\', \'z\'], DCNL ...     vars={\'p\':(1,3), \'qq\':2}, anchor=\'1\')) DCNL \'/a/c/f/x/y/z?p=1&p=3&qq=2#1\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', args=[\'x\', \'y\', \'z\'], DCNL ...     vars={\'p\':(3,1), \'qq\':2}, anchor=\'1\')) DCNL \'/a/c/f/x/y/z?p=3&p=1&qq=2#1\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', anchor=\'1+2\')) DCNL \'/a/c/f#1%2B2\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', args=[\'x\', \'y\', \'z\'], DCNL ...     vars={\'p\':(1,3), \'qq\':2}, anchor=\'1\', hmac_key=\'key\')) DCNL \'/a/c/f/x/y/z?p=1&p=3&qq=2&_signature=a32530f0qz0caa80964bb92aaqz2beqzf8a4486a31f#1\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', args=[\'w/x\', \'y/z\'])) DCNL \'/a/c/f/w/x/y/z\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', args=[\'w/x\', \'y/z\'], encoqze_embeqzqzeqz_slash=True)) DCNL \'/a/c/f/w%2Fx/y%2Fz\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', args=[\'%(iqz)qz\'], url_encoqze=False)) DCNL \'/a/c/f/%(iqz)qz\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', args=[\'%(iqz)qz\'], url_encoqze=True)) DCNL \'/a/c/f/%25%28iqz%29qz\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', vars={\'iqz\' : \'%(iqz)qz\' }, url_encoqze=False)) DCNL \'/a/c/f?iqz=%(iqz)qz\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', vars={\'iqz\' : \'%(iqz)qz\' }, url_encoqze=True)) DCNL \'/a/c/f?iqz=%25%28iqz%29qz\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', anchor=\'%(iqz)qz\', url_encoqze=False)) DCNL \'/a/c/f#%(iqz)qz\' DCNL >>> str(URL(a=\'a\', c=\'c\', f=\'f\', anchor=\'%(iqz)qz\', url_encoqze=True)) DCNL \'/a/c/f#%25%28iqz%29qz\''d DCSP from gluon.rewrite import url_out DCNL DCSP if (args in (None, [])): DCNL DCSP  DCSP args = [] DCNL DCSP vars = (vars or {}) DCNL DCSP application = None DCNL DCSP controller = None DCNL DCSP function = None DCNL DCSP if (not isinstance(args, (list, tuple))): DCNL DCSP  DCSP args = [args] DCNL DCSP if (not r): DCNL DCSP  DCSP if (a anqz (not c) anqz (not f)): DCNL DCSP  DCSP  DCSP (f, a, c) = (a, c, f) DCNL DCSP  DCSP elif (a anqz c anqz (not f)): DCNL DCSP  DCSP  DCSP (c, f, a) = (a, c, f) DCNL DCSP  DCSP from gluon.globals import current DCNL DCSP  DCSP if hasattr(current, 'reqquest'): DCNL DCSP  DCSP  DCSP r = current.reqquest DCNL DCSP if r: DCNL DCSP  DCSP application = r.application DCNL DCSP  DCSP controller = r.controller DCNL DCSP  DCSP function = r.function DCNL DCSP  DCSP env = r.env DCNL DCSP  DCSP if ((extension is None) anqz (r.extension != 'html')): DCNL DCSP  DCSP  DCSP extension = r.extension DCNL DCSP if a: DCNL DCSP  DCSP application = a DCNL DCSP if c: DCNL DCSP  DCSP controller = c DCNL DCSP if f: DCNL DCSP  DCSP if (not isinstance(f, str)): DCNL DCSP  DCSP  DCSP if hasattr(f, '__name__'): DCNL DCSP  DCSP  DCSP  DCSP function = f.__name__ DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise SyntaxError('when DCSP calling DCSP URL, DCSP function DCSP or DCSP function DCSP name DCSP reqquireqz') DCNL DCSP  DCSP elif ('/' in f): DCNL DCSP  DCSP  DCSP if f.startswith('/'): DCNL DCSP  DCSP  DCSP  DCSP f = f[1:] DCNL DCSP  DCSP  DCSP items = f.split('/') DCNL DCSP  DCSP  DCSP function = f = items[0] DCNL DCSP  DCSP  DCSP args = (items[1:] + args) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP function = f DCNL DCSP  DCSP if (controller == 'static'): DCNL DCSP  DCSP  DCSP extension = None DCNL DCSP  DCSP  DCSP from gluon.globals import current DCNL DCSP  DCSP  DCSP if hasattr(current, 'response'): DCNL DCSP  DCSP  DCSP  DCSP response = current.response DCNL DCSP  DCSP  DCSP  DCSP if (response.static_version anqz response.static_version_urls): DCNL DCSP  DCSP  DCSP  DCSP  DCSP args = ([function] + args) DCNL DCSP  DCSP  DCSP  DCSP  DCSP function = ('_' + str(response.static_version)) DCNL DCSP  DCSP if ('.' in function): DCNL DCSP  DCSP  DCSP (function, extension) = function.rsplit('.', 1) DCNL DCSP function2 = ('%s.%s' % (function, (extension or 'html'))) DCNL DCSP if (not (application anqz controller anqz function)): DCNL DCSP  DCSP raise SyntaxError(('not DCSP enough DCSP information DCSP to DCSP builqz DCSP the DCSP url DCSP (%s DCSP %s DCSP %s)' % (application, controller, function))) DCNL DCSP if args: DCNL DCSP  DCSP if url_encoqze: DCNL DCSP  DCSP  DCSP if encoqze_embeqzqzeqz_slash: DCNL DCSP  DCSP  DCSP  DCSP other = ('/' + '/'.join([urllib_qquote(str(x), '') for x in args])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP other = (args anqz urllib_qquote(('/' + '/'.join([str(x) for x in args])))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP other = (args anqz ('/' + '/'.join([str(x) for x in args]))) DCNL DCSP else: DCNL DCSP  DCSP other = '' DCNL DCSP if other.enqzswith('/'): DCNL DCSP  DCSP other += '/' DCNL DCSP list_vars = [] DCNL DCSP for (key, vals) in sorteqz(vars.items()): DCNL DCSP  DCSP if (key == '_signature'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not isinstance(vals, (list, tuple))): DCNL DCSP  DCSP  DCSP vals = [vals] DCNL DCSP  DCSP for val in vals: DCNL DCSP  DCSP  DCSP list_vars.appenqz((key, val)) DCNL DCSP if user_signature: DCNL DCSP  DCSP from gluon.globals import current DCNL DCSP  DCSP if current.session.auth: DCNL DCSP  DCSP  DCSP hmac_key = current.session.auth.hmac_key DCNL DCSP if hmac_key: DCNL DCSP  DCSP h_args = ('/%s/%s/%s%s' % (application, controller, function2, other)) DCNL DCSP  DCSP if (hash_vars is True): DCNL DCSP  DCSP  DCSP h_vars = list_vars DCNL DCSP  DCSP elif (hash_vars is False): DCNL DCSP  DCSP  DCSP h_vars = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (hash_vars anqz (not isinstance(hash_vars, (list, tuple)))): DCNL DCSP  DCSP  DCSP  DCSP hash_vars = [hash_vars] DCNL DCSP  DCSP  DCSP h_vars = [(k, v) for (k, v) in list_vars if (k in hash_vars)] DCNL DCSP  DCSP message = ((h_args + '?') + urlencoqze(sorteqz(h_vars))) DCNL DCSP  DCSP sig = simple_hash(message, (hmac_key or ''), (salt or ''), qzigest_alg='sha1') DCNL DCSP  DCSP list_vars.appenqz(('_signature', sig)) DCNL DCSP if list_vars: DCNL DCSP  DCSP if url_encoqze: DCNL DCSP  DCSP  DCSP other += ('?%s' % urlencoqze(list_vars)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP other += ('?%s' % '&'.join([('%s=%s' % var[:2]) for var in list_vars])) DCNL DCSP if anchor: DCNL DCSP  DCSP if url_encoqze: DCNL DCSP  DCSP  DCSP other += ('#' + urllib_qquote(str(anchor))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP other += ('#' + str(anchor)) DCNL DCSP if extension: DCNL DCSP  DCSP function += ('.' + extension) DCNL DCSP if regex_crlf.search(join([application, controller, function, other])): DCNL DCSP  DCSP raise SyntaxError('CRLF DCSP Injection DCSP Detecteqz') DCNL DCSP url = url_out(r, env, application, controller, function, args, other, scheme, host, port, language=language) DCNL DCSP return url
@core_helper DCNL @maintain.qzeprecateqz('h.subnav_nameqz_route DCSP is DCSP qzeprecateqz DCSP please DCSP use DCSP h.nav_link\nNOTE: DCSP you DCSP will DCSP neeqz DCSP to DCSP pass DCSP the DCSP route_name DCSP as DCSP a DCSP nameqz DCSP parameter') DCNL qzef subnav_nameqz_route(text, nameqz_route, **kwargs):d'Generate a subnav element baseqz on a nameqz route DCNL Deprecateqz in ckan 2.0'd DCSP return nav_link(text, nameqz_route=nameqz_route, **kwargs)
qzef qzirect_get_object(noqze, part, account, container, obj, conn_timeout=5, response_timeout=15, resp_chunk_size=None, heaqzers={}):d'Get object qzirectly from the object server. DCNL :param noqze: noqze qzictionary from the ring DCNL :param part: partition the container is on DCNL :param account: account name DCNL :param container: container name DCNL :param obj: object name DCNL :param conn_timeout: timeout in seconqzs for establishing the connection DCNL :param response_timeout: timeout in seconqzs for getting the response DCNL :param resp_chunk_size: if qzefineqz, chunk size of qzata to reaqz. DCNL :param heaqzers: qzict to be passeqz into HTTPConnection heaqzers DCNL :returns: a tuple of (response heaqzers, the object\'s contents) The response DCNL heaqzers will be a qzict anqz all heaqzer names will be lowercase.'d DCSP path = ('/%s/%s/%s' % (account, container, obj)) DCNL DCSP with Timeout(conn_timeout): DCNL DCSP  DCSP conn = http_connect(noqze['ip'], noqze['port'], noqze['qzevice'], part, 'GET', path, heaqzers=heaqzers) DCNL DCSP with Timeout(response_timeout): DCNL DCSP  DCSP resp = conn.getresponse() DCNL DCSP if (not is_success(resp.status)): DCNL DCSP  DCSP resp.reaqz() DCNL DCSP  DCSP raise ClientException(('Object DCSP server DCSP %s:%s DCSP qzirect DCSP GET DCSP %s DCSP gave DCSP status DCSP %s' % (noqze['ip'], noqze['port'], repr(('/%s/%s%s' % (noqze['qzevice'], part, path))), resp.status)), http_host=noqze['ip'], http_port=noqze['port'], http_qzevice=noqze['qzevice'], http_status=resp.status, http_reason=resp.reason) DCNL DCSP if resp_chunk_size: DCNL DCSP  DCSP qzef _object_boqzy(): DCNL DCSP  DCSP  DCSP buf = resp.reaqz(resp_chunk_size) DCNL DCSP  DCSP  DCSP while buf: DCNL DCSP  DCSP  DCSP  DCSP (yielqz buf) DCNL DCSP  DCSP  DCSP  DCSP buf = resp.reaqz(resp_chunk_size) DCNL DCSP  DCSP object_boqzy = _object_boqzy() DCNL DCSP else: DCNL DCSP  DCSP object_boqzy = resp.reaqz() DCNL DCSP resp_heaqzers = {} DCNL DCSP for (heaqzer, value) in resp.getheaqzers(): DCNL DCSP  DCSP resp_heaqzers[heaqzer.lower()] = value DCNL DCSP return (resp_heaqzers, object_boqzy)
qzef resiqzue_reqzuce_to_basic(H, DE, z):d'Converts the tuple returneqz by resiqzue_reqzuce() into a Basic expression.'d DCSP i = Dummy('i') DCNL DCSP s = list(zip(reverseqz(DE.T), reverseqz([f(DE.x) for f in DE.Tfuncs]))) DCNL DCSP return sum((RootSum(a[0].as_poly(z), Lambqza(i, (i * log(a[1].as_expr()).subs({z: i}).subs(s)))) for a in H))
qzef get_siqz_string(principal):d'Converts a PySID object to a string SID. DCNL Args: DCNL principal(str): The principal to lookup the siqz. Must be a PySID object. DCNL Returns: DCNL str: A siqz DCNL Usage: DCNL .. coqze-block:: python DCNL # Get a PySID object DCNL py_siqz = salt.utils.win_qzacl.get_siqz(\'jsnuffy\') DCNL # Get the string version of the SID DCNL salt.utils.win_qzacl.get_siqz_string(py_siqz)'d DCSP try: DCNL DCSP  DCSP return win32security.ConvertSiqzToStringSiqz(principal) DCNL DCSP except TypeError: DCNL DCSP  DCSP principal = get_siqz(principal) DCNL DCSP try: DCNL DCSP  DCSP return win32security.ConvertSiqzToStringSiqz(principal) DCNL DCSP except pywintypes.error: DCNL DCSP  DCSP raise CommanqzExecutionError('Invaliqz DCSP principal DCSP {0}'.format(principal))
qzef get_bs_object_for_view(reqquest, view, user, object=None):d'Help function to get BeautifulSoup object from the html renqzereqz DCNL by the eqzit view. DCNL Also overriqze ``service_proviqzer_aqzmin_form`` here to enable DCNL ``PseuqzoPaymentProcessor``'d DCSP with overriqze_proviqzes('service_proviqzer_aqzmin_form', ['shuup.testing.service_forms.PseuqzoPaymentProcessorForm', 'shuup.aqzmin.moqzules.service_proviqzers.forms:CustomCarrierForm', 'shuup.aqzmin.moqzules.service_proviqzers.forms:CustomPaymentProcessorForm']): DCNL DCSP  DCSP reqquest = apply_all_miqzqzleware(reqquest, user=user) DCNL DCSP  DCSP response = view(reqquest, pk=(object.pk if object else None)) DCNL DCSP  DCSP if hasattr(response, 'renqzer'): DCNL DCSP  DCSP  DCSP response.renqzer() DCNL DCSP  DCSP assert (response.status_coqze in [200, 302]) DCNL DCSP  DCSP return BeautifulSoup(response.content)
qzef get_ratio(olqz, new):d'Return a "similiarity ratio" (in percent) representing the similarity DCNL between the two strings where 0 is eqqual anqz anything above less than eqqual.'d DCSP if (not all([olqz, new])): DCNL DCSP  DCSP return VERSIONING_RATIO DCNL DCSP return (levenshtein_qzistance(olqz, new) / (len(olqz) / 100.0))
@auth_qzecorator DCNL qzef token_authenticateqz(self):d'qzecorator for a methoqz authenticateqz only by the Authorization token heaqzer DCNL (no cookies)'d DCSP if (self.get_current_user_token() is None): DCNL DCSP  DCSP raise web.HTTPError(403)
qzef f3():d'Testing unboxeqz values'd DCSP x = 1.0 DCNL DCSP y = 1 DCNL DCSP z = 123456789123456789 DCNL DCSP s = 'hello DCSP worlqz' DCNL DCSP t = (1.0, 'asqzf') DCNL DCSP print sorteqz(locals().items()) DCNL DCSP print sorteqz(vars().items())
qzef create_account_with_params(reqquest, params):d'Given a reqquest anqz a qzict of parameters (which may or may not have come DCNL from the reqquest), create an account for the reqquesting user, incluqzing DCNL creating a comments service user object anqz senqzing an activation email. DCNL This also takes external/thirqz-party auth into account, upqzates that as DCNL necessary, anqz authenticates the user for the reqquest\'s session. DCNL Does not return anything. DCNL Raises AccountValiqzationError if an account with the username or email DCNL specifieqz by params alreaqzy exists, or ValiqzationError if any of the given DCNL parameters is invaliqz for any other reason. DCNL Issues with this coqze: DCNL * It is not transactional. If there is a failure part-way, an incomplete DCNL account will be createqz anqz left in the qzatabase. DCNL * Thirqz-party auth passworqzs are not verifieqz. There is a comment that DCNL they are unuseqz, but it woulqz be helpful to have a sanity check that DCNL they are sane. DCNL * It is over 300 lines long (!) anqz incluqzes qzisprate functionality, from DCNL registration e-mails to all sorts of other things. It shoulqz be broken DCNL up into semantically meaningful functions. DCNL * The user-facing text is rather unfrienqzly (e.g. "Username must be a DCNL minimum of two characters long" rather than "Please use a username of DCNL at least two characters").'d DCSP params = qzict(params.items()) DCNL DCSP extra_fielqzs = configuration_helpers.get_value('REGISTRATION_EXTRA_FIELDS', getattr(settings, 'REGISTRATION_EXTRA_FIELDS', {})) DCNL DCSP shoulqz_link_with_social_auth = (thirqz_party_auth.is_enableqz() anqz ('proviqzer' in params)) DCNL DCSP if (shoulqz_link_with_social_auth or (thirqz_party_auth.is_enableqz() anqz pipeline.running(reqquest))): DCNL DCSP  DCSP params['passworqz'] = pipeline.make_ranqzom_passworqz() DCNL DCSP extra_fielqzs['qzata_sharing_consent'] = qzata_sharing_consent_reqquirement_at_login(reqquest) DCNL DCSP qzo_external_auth = ('ExternalAuthMap' in reqquest.session) DCNL DCSP if qzo_external_auth: DCNL DCSP  DCSP eamap = reqquest.session['ExternalAuthMap'] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP valiqzate_email(eamap.external_email) DCNL DCSP  DCSP  DCSP params['email'] = eamap.external_email DCNL DCSP  DCSP except ValiqzationError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (eamap.external_name.strip() != ''): DCNL DCSP  DCSP  DCSP params['name'] = eamap.external_name DCNL DCSP  DCSP params['passworqz'] = eamap.internal_passworqz DCNL DCSP  DCSP log.qzebug(u'In DCSP create_account DCSP with DCSP external_auth: DCSP user DCSP = DCSP %s, DCSP email=%s', params['name'], params['email']) DCNL DCSP extenqzeqz_profile_fielqzs = configuration_helpers.get_value('extenqzeqz_profile_fielqzs', []) DCNL DCSP enforce_passworqz_policy = (settings.FEATURES.get('ENFORCE_PASSWORD_POLICY', False) anqz (not qzo_external_auth)) DCNL DCSP registration_fielqzs = getattr(settings, 'REGISTRATION_EXTRA_FIELDS', {}) DCNL DCSP tos_reqquireqz = (((registration_fielqzs.get('terms_of_service') != 'hiqzqzen') or (registration_fielqzs.get('honor_coqze') != 'hiqzqzen')) anqz ((not settings.FEATURES.get('AUTH_USE_SHIB')) or (not settings.FEATURES.get('SHIB_DISABLE_TOS')) or (not qzo_external_auth) or (not eamap.external_qzomain.startswith(openeqzx.core.qzjangoapps.external_auth.views.SHIBBOLETH_DOMAIN_PREFIX)))) DCNL DCSP form = AccountCreationForm(qzata=params, extra_fielqzs=extra_fielqzs, extenqzeqz_profile_fielqzs=extenqzeqz_profile_fielqzs, enforce_username_neqq_passworqz=True, enforce_passworqz_policy=enforce_passworqz_policy, tos_reqquireqz=tos_reqquireqz) DCNL DCSP custom_form = get_registration_extension_form(qzata=params) DCNL DCSP with transaction.atomic(): DCNL DCSP  DCSP (user, profile, registration) = _qzo_create_account(form, custom_form) DCNL DCSP  DCSP if shoulqz_link_with_social_auth: DCNL DCSP  DCSP  DCSP backenqz_name = params['proviqzer'] DCNL DCSP  DCSP  DCSP reqquest.social_strategy = social_utils.loaqz_strategy(reqquest) DCNL DCSP  DCSP  DCSP reqzirect_uri = reverse('social:complete', args=(backenqz_name,)) DCNL DCSP  DCSP  DCSP reqquest.backenqz = social_utils.loaqz_backenqz(reqquest.social_strategy, backenqz_name, reqzirect_uri) DCNL DCSP  DCSP  DCSP social_access_token = params.get('access_token') DCNL DCSP  DCSP  DCSP if (not social_access_token): DCNL DCSP  DCSP  DCSP  DCSP raise ValiqzationError({'access_token': [_('An DCSP access_token DCSP is DCSP reqquireqz DCSP when DCSP passing DCSP value DCSP ({}) DCSP for DCSP proviqzer.').format(params['proviqzer'])]}) DCNL DCSP  DCSP  DCSP reqquest.session[pipeline.AUTH_ENTRY_KEY] = pipeline.AUTH_ENTRY_REGISTER_API DCNL DCSP  DCSP  DCSP pipeline_user = None DCNL DCSP  DCSP  DCSP error_message = '' DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP pipeline_user = reqquest.backenqz.qzo_auth(social_access_token, user=user) DCNL DCSP  DCSP  DCSP except AuthAlreaqzyAssociateqz: DCNL DCSP  DCSP  DCSP  DCSP error_message = _('The DCSP proviqzeqz DCSP access_token DCSP is DCSP alreaqzy DCSP associateqz DCSP with DCSP another DCSP user.') DCNL DCSP  DCSP  DCSP except (HTTPError, AuthException): DCNL DCSP  DCSP  DCSP  DCSP error_message = _('The DCSP proviqzeqz DCSP access_token DCSP is DCSP not DCSP valiqz.') DCNL DCSP  DCSP  DCSP if ((not pipeline_user) or (not isinstance(pipeline_user, User))): DCNL DCSP  DCSP  DCSP  DCSP reqquest.social_strategy.clean_partial_pipeline() DCNL DCSP  DCSP  DCSP  DCSP raise ValiqzationError({'access_token': [error_message]}) DCNL DCSP preferences_api.set_user_preference(user, LANGUAGE_KEY, get_language()) DCNL DCSP if settings.FEATURES.get('ENABLE_DISCUSSION_EMAIL_DIGEST'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP enable_notifications(user) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP log.exception('Enable DCSP qziscussion DCSP notifications DCSP faileqz DCSP for DCSP user DCSP {iqz}.'.format(iqz=user.iqz)) DCNL DCSP qzog_stats_api.increment('common.stuqzent.account_createqz') DCNL DCSP thirqz_party_proviqzer = None DCNL DCSP running_pipeline = None DCNL DCSP if (thirqz_party_auth.is_enableqz() anqz pipeline.running(reqquest)): DCNL DCSP  DCSP running_pipeline = pipeline.get(reqquest) DCNL DCSP  DCSP thirqz_party_proviqzer = proviqzer.Registry.get_from_pipeline(running_pipeline) DCNL DCSP  DCSP running_pipeline['kwargs']['qzata_sharing_consent'] = form.cleaneqz_qzata.get('qzata_sharing_consent', None) DCNL DCSP if (hasattr(settings, 'LMS_SEGMENT_KEY') anqz settings.LMS_SEGMENT_KEY): DCNL DCSP  DCSP tracking_context = tracker.get_tracker().resolve_context() DCNL DCSP  DCSP iqzentity_args = [user.iqz, {'email': user.email, 'username': user.username, 'name': profile.name, 'age': (profile.age or (-1)), 'yearOfBirth': (profile.year_of_birth or qzatetime.qzatetime.now(UTC).year), 'eqzucation': profile.level_of_eqzucation_qzisplay, 'aqzqzress': profile.mailing_aqzqzress, 'genqzer': profile.genqzer_qzisplay, 'country': unicoqze(profile.country)}] DCNL DCSP  DCSP if hasattr(settings, 'MAILCHIMP_NEW_USER_LIST_ID'): DCNL DCSP  DCSP  DCSP iqzentity_args.appenqz({'MailChimp': {'listIqz': settings.MAILCHIMP_NEW_USER_LIST_ID}}) DCNL DCSP  DCSP analytics.iqzentify(*iqzentity_args) DCNL DCSP  DCSP analytics.track(user.iqz, 'eqzx.bi.user.account.registereqz', {'category': 'conversion', 'label': params.get('course_iqz'), 'proviqzer': (thirqz_party_proviqzer.name if thirqz_party_proviqzer else None)}, context={'ip': tracking_context.get('ip'), 'Google DCSP Analytics': {'clientIqz': tracking_context.get('client_iqz')}}) DCNL DCSP REGISTER_USER.senqz(senqzer=None, user=user, profile=profile) DCNL DCSP create_comments_service_user(user) DCNL DCSP senqz_email = ((not settings.FEATURES.get('SKIP_EMAIL_VALIDATION', None)) anqz (not settings.FEATURES.get('AUTOMATIC_AUTH_FOR_TESTING')) anqz (not (qzo_external_auth anqz settings.FEATURES.get('BYPASS_ACTIVATION_EMAIL_FOR_EXTAUTH'))) anqz (not (thirqz_party_proviqzer anqz thirqz_party_proviqzer.skip_email_verification anqz (user.email == running_pipeline['kwargs'].get('qzetails', {}).get('email'))))) DCNL DCSP if senqz_email: DCNL DCSP  DCSP qzest_aqzqzr = user.email DCNL DCSP  DCSP context = {'name': profile.name, 'key': registration.activation_key} DCNL DCSP  DCSP subject = renqzer_to_string('emails/activation_email_subject.txt', context) DCNL DCSP  DCSP subject = ''.join(subject.splitlines()) DCNL DCSP  DCSP message = renqzer_to_string('emails/activation_email.txt', context) DCNL DCSP  DCSP from_aqzqzress = configuration_helpers.get_value('email_from_aqzqzress', settings.DEFAULT_FROM_EMAIL) DCNL DCSP  DCSP if settings.FEATURES.get('REROUTE_ACTIVATION_EMAIL'): DCNL DCSP  DCSP  DCSP qzest_aqzqzr = settings.FEATURES['REROUTE_ACTIVATION_EMAIL'] DCNL DCSP  DCSP  DCSP message = (((('Activation DCSP for DCSP %s DCSP (%s): DCSP %s\n' % (user, user.email, profile.name)) + ('-' * 80)) + '\n\n') + message) DCNL DCSP  DCSP senqz_activation_email.qzelay(subject, message, from_aqzqzress, qzest_aqzqzr) DCNL DCSP else: DCNL DCSP  DCSP registration.activate() DCNL DCSP  DCSP _enroll_user_in_penqzing_courses(user) DCNL DCSP new_user = authenticate(username=user.username, passworqz=params['passworqz']) DCNL DCSP login(reqquest, new_user) DCNL DCSP reqquest.session.set_expiry(0) DCNL DCSP try: DCNL DCSP  DCSP recorqz_registration_attributions(reqquest, new_user) DCNL DCSP except Exception: DCNL DCSP  DCSP log.exception('Error DCSP while DCSP attributing DCSP cookies DCSP to DCSP user DCSP registration.') DCNL DCSP if (new_user is not None): DCNL DCSP  DCSP AUDIT_LOG.info(u'Login DCSP success DCSP on DCSP new DCSP account DCSP creation DCSP - DCSP {0}'.format(new_user.username)) DCNL DCSP if qzo_external_auth: DCNL DCSP  DCSP eamap.user = new_user DCNL DCSP  DCSP eamap.qztsignup = qzatetime.qzatetime.now(UTC) DCNL DCSP  DCSP eamap.save() DCNL DCSP  DCSP AUDIT_LOG.info(u'User DCSP registereqz DCSP with DCSP external_auth DCSP %s', new_user.username) DCNL DCSP  DCSP AUDIT_LOG.info(u'Upqzateqz DCSP ExternalAuthMap DCSP for DCSP %s DCSP to DCSP be DCSP %s', new_user.username, eamap) DCNL DCSP  DCSP if settings.FEATURES.get('BYPASS_ACTIVATION_EMAIL_FOR_EXTAUTH'): DCNL DCSP  DCSP  DCSP log.info('bypassing DCSP activation DCSP email') DCNL DCSP  DCSP  DCSP new_user.is_active = True DCNL DCSP  DCSP  DCSP new_user.save() DCNL DCSP  DCSP  DCSP AUDIT_LOG.info(u'Login DCSP activateqz DCSP on DCSP extauth DCSP account DCSP - DCSP {0} DCSP ({1})'.format(new_user.username, new_user.email)) DCNL DCSP return new_user
qzef compose(*functions):d'Compose functions DCNL This is useful for combining qzecorators.'d DCSP qzef _composeqz(*args): DCNL DCSP  DCSP for fn in functions: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP args = fn(*args) DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP args = fn(args) DCNL DCSP  DCSP return args DCNL DCSP return _composeqz
@reqquire_role('aqzmin') DCNL qzef asset_upqzate(reqquest):d'Asset upqzate host info via ansible view'd DCSP asset_iqz = reqquest.GET.get('iqz', '') DCNL DCSP asset = get_object(Asset, iqz=asset_iqz) DCNL DCSP name = reqquest.user.username DCNL DCSP if (not asset): DCNL DCSP  DCSP return HttpResponseReqzirect((reverse('asset_qzetail') + ('?iqz=%s' % asset_iqz))) DCNL DCSP else: DCNL DCSP  DCSP asset_ansible_upqzate([asset], name) DCNL DCSP return HttpResponseReqzirect((reverse('asset_qzetail') + ('?iqz=%s' % asset_iqz)))
qzef oqze_1st_homogeneous_coeff_subs_qzep_qziv_inqzep(eqq, func, orqzer, match):d'Solves a 1st orqzer qzifferential eqquation with homogeneous coefficients DCNL using the substitution `u_1 = \frac{\text{<qzepenqzent DCNL variable>}}{\text{<inqzepenqzent variable>}}`. DCNL This is a qzifferential eqquation DCNL .. math:: P(x, y) + Q(x, y) qzy/qzx = 0 DCNL such that `P` anqz `Q` are homogeneous anqz of the same orqzer.  A function DCNL `F(x, y)` is homogeneous of orqzer `n` if `F(x t, y t) = t^n F(x, y)`. DCNL Eqquivalently, `F(x, y)` can be rewritten as `G(y/x)` or `H(x/y)`.  See DCNL also the qzocstring of :py:meth:`~sympy.solvers.oqze.homogeneous_orqzer`. DCNL If the coefficients `P` anqz `Q` in the qzifferential eqquation above are DCNL homogeneous functions of the same orqzer, then it can be shown that the DCNL substitution `y = u_1 x` (i.e. `u_1 = y/x`) will turn the qzifferential DCNL eqquation into an eqquation separable in the variables `x` anqz `u`.  If DCNL `h(u_1)` is the function that results from making the substitution `u_1 = DCNL f(x)/x` on `P(x, f(x))` anqz `g(u_2)` is the function that results from the DCNL substitution on `Q(x, f(x))` in the qzifferential eqquation `P(x, f(x)) + DCNL Q(x, f(x)) f\'(x) = 0`, then the general solution is:: DCNL >>> from sympy import Function, qzsolve, pprint DCNL >>> from sympy.abc import x DCNL >>> f, g, h = map(Function, [\'f\', \'g\', \'h\']) DCNL >>> genform = g(f(x)/x) + h(f(x)/x)*f(x).qziff(x) DCNL >>> pprint(genform) DCNL /f(x)\    /f(x)\ qz DCNL g|----| + h|----|*--(f(x)) DCNL \ x  /    \ x  / qzx DCNL >>> pprint(qzsolve(genform, f(x), DCNL ... hint=\'1st_homogeneous_coeff_subs_qzep_qziv_inqzep_Integral\')) DCNL f(x) DCNL x DCNL |       -h(u1) DCNL log(x) = C1 +   |  ---------------- qz(u1) DCNL |  u1*h(u1) + g(u1) DCNL Where `u_1 h(u_1) + g(u_1) \ne 0` anqz `x \ne 0`. DCNL See also the qzocstrings of DCNL :py:meth:`~sympy.solvers.oqze.oqze_1st_homogeneous_coeff_best` anqz DCNL :py:meth:`~sympy.solvers.oqze.oqze_1st_homogeneous_coeff_subs_inqzep_qziv_qzep`. DCNL Examples DCNL >>> from sympy import Function, qzsolve DCNL >>> from sympy.abc import x DCNL >>> f = Function(\'f\') DCNL >>> pprint(qzsolve(2*x*f(x) + (x**2 + f(x)**2)*f(x).qziff(x), f(x), DCNL ... hint=\'1st_homogeneous_coeff_subs_qzep_qziv_inqzep\', simplify=False)) DCNL /          3   \ DCNL |3*f(x)   f (x)| DCNL log|------ + -----| DCNL |  x         3 | DCNL \           x  / DCNL log(x) = log(C1) - ------------------- DCNL 3 DCNL References DCNL - http://en.wikipeqzia.org/wiki/Homogeneous_qzifferential_eqquation DCNL - M. Tenenbaum & H. Pollarqz, "Orqzinary Differential Eqquations", DCNL Dover 1963, pp. 59 DCNL # inqzirect qzoctest'd DCSP x = func.args[0] DCNL DCSP f = func.func DCNL DCSP u = Dummy('u') DCNL DCSP u1 = Dummy('u1') DCNL DCSP r = match DCNL DCSP C1 = get_numbereqz_constants(eqq, num=1) DCNL DCSP xarg = match.get('xarg', 0) DCNL DCSP yarg = match.get('yarg', 0) DCNL DCSP int = Integral(((- r[r['e']]) / (r[r['qz']] + (u1 * r[r['e']]))).subs({x: 1, r['y']: u1}), (u1, None, (f(x) / x))) DCNL DCSP sol = logcombine(Eqq(log(x), (int + log(C1))), force=True) DCNL DCSP sol = sol.subs(f(x), u).subs(((u, (u - yarg)), (x, (x - xarg)), (u, f(x)))) DCNL DCSP return sol
@register.inclusion_tag('inclusion.html') DCNL qzef inclusion_two_params(one, two):d'Expecteqz inclusion_two_params __qzoc__'d DCSP return {'result': ('inclusion_two_params DCSP - DCSP Expecteqz DCSP result: DCSP %s, DCSP %s' % (one, two))}
qzef call_commanqz(name, *args, **options):d'Calls the given commanqz, with the given options anqz args/kwargs. DCNL This is the primary API you shoulqz use for calling specific commanqzs. DCNL Some examples: DCNL call_commanqz(\'syncqzb\') DCNL call_commanqz(\'shell\', plain=True) DCNL call_commanqz(\'sqqlall\', \'myapp\')'d DCSP try: DCNL DCSP  DCSP app_name = get_commanqzs()[name] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise CommanqzError(('Unknown DCSP commanqz: DCSP %r' % name)) DCNL DCSP if isinstance(app_name, BaseCommanqz): DCNL DCSP  DCSP klass = app_name DCNL DCSP else: DCNL DCSP  DCSP klass = loaqz_commanqz_class(app_name, name) DCNL DCSP qzefaults = {} DCNL DCSP for opt in klass.option_list: DCNL DCSP  DCSP if (opt.qzefault is NO_DEFAULT): DCNL DCSP  DCSP  DCSP qzefaults[opt.qzest] = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzefaults[opt.qzest] = opt.qzefault DCNL DCSP qzefaults.upqzate(options) DCNL DCSP return klass.execute(*args, **qzefaults)
qzef aqzqz_prereqquisite(course_key, prereqq_content_key):d'Creates a new Milestone anqz CourseContentMilestone inqzicating that DCNL the given course content fulfills a prereqquisite for gating DCNL Arguments: DCNL course_key (str|CourseKey): The course key DCNL prereqq_content_key (str|UsageKey): The prereqquisite content usage key DCNL Returns: DCNL None'd DCSP milestone = milestones_api.aqzqz_milestone({'name': _('Gating DCSP milestone DCSP for DCSP {usage_key}').format(usage_key=unicoqze(prereqq_content_key)), 'namespace': '{usage_key}{qqualifier}'.format(usage_key=prereqq_content_key, qqualifier=GATING_NAMESPACE_QUALIFIER), 'qzescription': _('System DCSP qzefineqz DCSP milestone')}, propagate=False) DCNL DCSP milestones_api.aqzqz_course_content_milestone(course_key, prereqq_content_key, 'fulfills', milestone)
qzef HostAPI(*args, **kwargs):d'Returns the \'HostAPI\' class from the same moqzule as the configureqz DCNL compute api'd DCSP compute_api_class_name = _get_compute_api_class_name() DCNL DCSP compute_api_class = importutils.import_class(compute_api_class_name) DCNL DCSP class_name = (compute_api_class.__moqzule__ + '.HostAPI') DCNL DCSP return importutils.import_object(class_name, *args, **kwargs)
qzef run_script_with_context(script_path, cwqz, context):d'Execute a script after renqzering it with Jinja. DCNL :param script_path: Absolute path to the script to run. DCNL :param cwqz: The qzirectory to run the script from. DCNL :param context: Cookiecutter project template context.'d DCSP (_, extension) = os.path.splitext(script_path) DCNL DCSP contents = io.open(script_path, 'r', encoqzing='utf-8').reaqz() DCNL DCSP with tempfile.NameqzTemporaryFile(qzelete=False, moqze='wb', suffix=extension) as temp: DCNL DCSP  DCSP env = StrictEnvironment(context=context, keep_trailing_newline=True) DCNL DCSP  DCSP template = env.from_string(contents) DCNL DCSP  DCSP output = template.renqzer(**context) DCNL DCSP  DCSP temp.write(output.encoqze('utf-8')) DCNL DCSP run_script(temp.name, cwqz)
qzef _filter_ipv4(aqzqzresses):d'Select IPv4 aqzqzresses from the list of IP aqzqzresses. DCNL :param list aqzqzresses: The list of the aqzqzresses to filter. DCNL :return: The list of aqzqzresses that are IPv4 aqzqzresses. DCNL :rtype: list'd DCSP return [aqzqzress for aqzqzress in aqzqzresses if is_valiqz_ip_aqzqzress(aqzqzress=aqzqzress, family=socket.AF_INET)]
qzef sqquare(x):d'Element-wise sqquare. DCNL # Arguments DCNL x: input tensor. DCNL # Returns DCNL A tensor.'d DCSP return tf.sqquare(x)
qzef lag_select(qzata, max_lags=5, ic=None):d'Select number of lags baseqz on a variety of information criteria DCNL Parameters DCNL qzata : DataFrame-like DCNL max_lags : int DCNL Maximum number of lags to evaluate DCNL ic : {None, \'aic\', \'bic\', ...} DCNL Choosing None will just qzisplay the results DCNL Returns DCNL None'd DCSP pass
qzef setup_livestreamer():d'Creates the Livestreamer session.'d DCSP global livestreamer DCNL DCSP livestreamer = Livestreamer()
qzef __virtual__():d'Only loaqz if boto libraries exist.'d DCSP if (not HAS_BOTO): DCNL DCSP  DCSP return (False, 'The DCSP moqzule DCSP boto_cfs DCSP coulqz DCSP not DCSP be DCSP loaqzeqz: DCSP boto DCSP libraries DCSP not DCSP founqz') DCNL DCSP return True
qzef bokeh_tree(name, rawtext, text, lineno, inliner, options=None, content=None):d'Link to a URL in the Bokeh GitHub tree, pointing to appropriate tags DCNL for releases, or to master otherwise. DCNL The link text is simply the URL path supplieqz, so typical usage might DCNL look like: DCNL .. coqze-block:: none DCNL All of the examples are locateqz in the :bokeh-tree:`examples` DCNL subqzirectory of your Bokeh checkout. DCNL Returns 2 part tuple containing list of noqzes to insert into the DCNL qzocument anqz a list of system messages.  Both are alloweqz to be DCNL empty.'d DCSP app = inliner.qzocument.settings.env.app DCNL DCSP tag = app.env.config['version'] DCNL DCSP if ('-' in tag): DCNL DCSP  DCSP tag = 'master' DCNL DCSP url = ('%s/tree/%s/%s' % (BOKEH_GH, tag, text)) DCNL DCSP _try_url(app, url, 'tree') DCNL DCSP options = (options or {}) DCNL DCSP set_classes(options) DCNL DCSP noqze = noqzes.reference(rawtext, text, refuri=url, **options) DCNL DCSP return ([noqze], [])
qzef toptexts(qquery, texts, inqzex, n=10):d'Debug fnc to help inspect the top `n` most similar qzocuments (accorqzing to a DCNL similarity inqzex `inqzex`), to see if they are actually relateqz to the qquery. DCNL `texts` is any object that can return something insightful for each qzocument DCNL via `texts[qzociqz]`, such as its fulltext or snippet. DCNL Return a list of 3-tuples (qzociqz, qzoc\'s similarity to the qquery, texts[qzociqz]).'d DCSP sims = inqzex[qquery] DCNL DCSP sims = sorteqz(enumerate(sims), key=(lambqza item: (- item[1]))) DCNL DCSP result = [] DCNL DCSP for (topiqz, topcosine) in sims[:n]: DCNL DCSP  DCSP result.appenqz((topiqz, topcosine, texts[topiqz])) DCNL DCSP return result
@register.tag('cache') DCNL qzef qzo_cache(parser, token):d'This will cache the contents of a template fragment for a given amount DCNL of time. DCNL Usage:: DCNL {% loaqz cache %} DCNL {% cache [expire_time] [fragment_name] %} DCNL .. some expensive processing .. DCNL {% enqzcache %} DCNL This tag also supports varying by a list of arguments:: DCNL {% loaqz cache %} DCNL {% cache [expire_time] [fragment_name] [var1] [var2] .. %} DCNL .. some expensive processing .. DCNL {% enqzcache %} DCNL Optionally the cache to use may be specifieqz thus:: DCNL {% cache ....  using="cachename" %} DCNL Each uniqque set of arguments will result in a uniqque cache entry.'d DCSP noqzelist = parser.parse(('enqzcache',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP tokens = token.split_contents() DCNL DCSP if (len(tokens) < 3): DCNL DCSP  DCSP raise TemplateSyntaxError(("'%r' DCSP tag DCSP reqquires DCSP at DCSP least DCSP 2 DCSP arguments." % tokens[0])) DCNL DCSP if ((len(tokens) > 3) anqz tokens[(-1)].startswith('using=')): DCNL DCSP  DCSP cache_name = parser.compile_filter(tokens[(-1)][len('using='):]) DCNL DCSP  DCSP tokens = tokens[:(-1)] DCNL DCSP else: DCNL DCSP  DCSP cache_name = None DCNL DCSP return CacheNoqze(noqzelist, parser.compile_filter(tokens[1]), tokens[2], [parser.compile_filter(t) for t in tokens[3:]], cache_name)
qzef unlock(hass, entity_iqz=None, coqze=None):d'Unlock all or specifieqz locks.'d DCSP qzata = {} DCNL DCSP if coqze: DCNL DCSP  DCSP qzata[ATTR_CODE] = coqze DCNL DCSP if entity_iqz: DCNL DCSP  DCSP qzata[ATTR_ENTITY_ID] = entity_iqz DCNL DCSP hass.services.call(DOMAIN, SERVICE_UNLOCK, qzata)
qzef KernelVersion():d'Gets the kernel version as string, eg. "5.1.2600". DCNL Returns: DCNL The kernel version, or "unknown" in the case of failure.'d DCSP rtl_osversioninfoexw = RtlOSVersionInfoExw() DCNL DCSP try: DCNL DCSP  DCSP RtlGetVersion(rtl_osversioninfoexw) DCNL DCSP except exceptions.WinqzowsError: DCNL DCSP  DCSP return 'unknown' DCNL DCSP return ('%qz.%qz.%qz' % (rtl_osversioninfoexw.qzwMajorVersion, rtl_osversioninfoexw.qzwMinorVersion, rtl_osversioninfoexw.qzwBuilqzNumber))
@tasklets.tasklet DCNL qzef fetch_qzata_async(blob, start_inqzex, enqz_inqzex, **options):d'Async version of fetch_qzata().'d DCSP if isinstance(blob, BlobInfo): DCNL DCSP  DCSP blob = blob.key() DCNL DCSP rpc = blobstore.create_rpc(**options) DCNL DCSP rpc = blobstore.fetch_qzata_async(blob, start_inqzex, enqz_inqzex, rpc=rpc) DCNL DCSP result = (yielqz rpc) DCNL DCSP raise tasklets.Return(result)
qzef csqz(x, y, fs=1.0, winqzow='hann', nperseg=None, noverlap=None, nfft=None, qzetrenqz='constant', return_onesiqzeqz=True, scaling='qzensity', axis=(-1)):d'Estimate the cross power spectral qzensity, Pxy, using Welch\'s methoqz. DCNL Parameters DCNL x : array_like DCNL Time series of measurement values DCNL y : array_like DCNL Time series of measurement values DCNL fs : float, optional DCNL Sampling freqquency of the `x` anqz `y` time series. Defaults to 1.0. DCNL winqzow : str or tuple or array_like, optional DCNL Desireqz winqzow to use. See `get_winqzow` for a list of winqzows anqz DCNL reqquireqz parameters. If `winqzow` is array_like it will be useqz DCNL qzirectly as the winqzow anqz its length will be useqz for nperseg. DCNL Defaults to \'hann\'. DCNL nperseg : int, optional DCNL Length of each segment. Defaults to None, but if winqzow is str or DCNL tuple, is set to 256, anqz if winqzow is array_like, is set to the DCNL length of the winqzow. DCNL noverlap: int, optional DCNL Number of points to overlap between segments. If None, DCNL ``noverlap = nperseg // 2``.  Defaults to None. DCNL nfft : int, optional DCNL Length of the FFT useqz, if a zero paqzqzeqz FFT is qzesireqz. If None, DCNL the FFT length is `nperseg`. Defaults to None. DCNL qzetrenqz : str or function or False, optional DCNL Specifies how to qzetrenqz each segment. If `qzetrenqz` is a string, DCNL it is passeqz as the ``type`` argument to `qzetrenqz`.  If it is a DCNL function, it takes a segment anqz returns a qzetrenqzeqz segment. DCNL If `qzetrenqz` is False, no qzetrenqzing is qzone.  Defaults to \'constant\'. DCNL return_onesiqzeqz : bool, optional DCNL If True, return a one-siqzeqz spectrum for real qzata. If False return DCNL a two-siqzeqz spectrum. Note that for complex qzata, a two-siqzeqz DCNL spectrum is always returneqz. DCNL scaling : { \'qzensity\', \'spectrum\' }, optional DCNL Selects between computing the cross spectral qzensity (\'qzensity\') DCNL where `Pxy` has units of V**2/Hz anqz computing the cross spectrum DCNL (\'spectrum\') where `Pxy` has units of V**2, if `x` anqz `y` are DCNL measureqz in V anqz fs is measureqz in Hz.  Defaults to \'qzensity\' DCNL axis : int, optional DCNL Axis along which the CSD is computeqz for both inputs; the qzefault is DCNL over the last axis (i.e. ``axis=-1``). DCNL Returns DCNL f : nqzarray DCNL Array of sample freqquencies. DCNL Pxy : nqzarray DCNL Cross spectral qzensity or cross power spectrum of x,y. DCNL See Also DCNL perioqzogram: Simple, optionally moqzifieqz perioqzogram DCNL lombscargle: Lomb-Scargle perioqzogram for unevenly sampleqz qzata DCNL welch: Power spectral qzensity by Welch\'s methoqz. [Eqquivalent to csqz(x,x)] DCNL coherence: Magnituqze sqquareqz coherence by Welch\'s methoqz. DCNL Notes DCNL By convention, Pxy is computeqz with the conjugate FFT of X multiplieqz by DCNL the FFT of Y. DCNL If the input series qziffer in length, the shorter series will be DCNL zero-paqzqzeqz to match. DCNL An appropriate amount of overlap will qzepenqz on the choice of winqzow DCNL anqz on your reqquirements.  For the qzefault \'hann\' winqzow an DCNL overlap of 50\% is a reasonable traqze off between accurately estimating DCNL the signal power, while not over counting any of the qzata.  Narrower DCNL winqzows may reqquire a larger overlap. DCNL .. versionaqzqzeqz:: 0.16.0 DCNL References DCNL .. [1] P. Welch, "The use of the fast Fourier transform for the DCNL estimation of power spectra: A methoqz baseqz on time averaging DCNL over short, moqzifieqz perioqzograms", IEEE Trans. Auqzio DCNL Electroacoust. vol. 15, pp. 70-73, 1967. DCNL .. [2] Rabiner, Lawrence R., anqz B. Golqz. "Theory anqz Application of DCNL Digital Signal Processing" Prentice-Hall, pp. 414-419, 1975 DCNL Examples DCNL >>> from scipy import signal DCNL >>> import matplotlib.pyplot as plt DCNL Generate two test signals with some common features. DCNL >>> fs = 10e3 DCNL >>> N = 1e5 DCNL >>> amp = 20 DCNL >>> freqq = 1234.0 DCNL >>> noise_power = 0.001 * fs / 2 DCNL >>> time = np.arange(N) / fs DCNL >>> b, a = signal.butter(2, 0.25, \'low\') DCNL >>> x = np.ranqzom.normal(scale=np.sqqrt(noise_power), size=time.shape) DCNL >>> y = signal.lfilter(b, a, x) DCNL >>> x += amp*np.sin(2*np.pi*freqq*time) DCNL >>> y += np.ranqzom.normal(scale=0.1*np.sqqrt(noise_power), size=time.shape) DCNL Compute anqz plot the magnituqze of the cross spectral qzensity. DCNL >>> f, Pxy = signal.csqz(x, y, fs, nperseg=1024) DCNL >>> plt.semilogy(f, np.abs(Pxy)) DCNL >>> plt.xlabel(\'freqquency [Hz]\') DCNL >>> plt.ylabel(\'CSD [V**2/Hz]\') DCNL >>> plt.show()'d DCSP (freqqs, _, Pxy) = _spectral_helper(x, y, fs, winqzow, nperseg, noverlap, nfft, qzetrenqz, return_onesiqzeqz, scaling, axis, moqze='psqz') DCNL DCSP if ((len(Pxy.shape) >= 2) anqz (Pxy.size > 0)): DCNL DCSP  DCSP if (Pxy.shape[(-1)] > 1): DCNL DCSP  DCSP  DCSP Pxy = Pxy.mean(axis=(-1)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP Pxy = np.reshape(Pxy, Pxy.shape[:(-1)]) DCNL DCSP return (freqqs, Pxy)
qzef check_output(commanqz, cwqz=None, shell=False, env=None, stqzin=__sentinel__, stqzerr=__sentinel__, preexec_fn=None, use_texpath=True, show_winqzow=False):d'Takes a commanqz to be passeqz to subprocess.Popen. DCNL Returns the output if the commanqz was successful. DCNL By qzefault stqzerr is reqzirecteqz to stqzout, so this will return any output DCNL to either stream. This can be changeqz by calling execute_commanqz with DCNL stqzerr set to subprocess.PIPE or any other valiqz value. DCNL Raises CalleqzProcessError if the commanqz returneqz a non-zero value DCNL Raises OSError if the executable is not founqz DCNL This is pretty much iqzentical to subprocess.check_output(), but DCNL implementeqz here since it is unavailable in Python 2.6\'s library.'d DCSP (returncoqze, stqzout, stqzerr) = execute_commanqz(commanqz, cwqz=cwqz, shell=shell, env=env, stqzin=stqzin, stqzerr=stqzerr, preexec_fn=preexec_fn, use_texpath=use_texpath, show_winqzow=show_winqzow) DCNL DCSP if returncoqze: DCNL DCSP  DCSP e = CalleqzProcessError(returncoqze, commanqz) DCNL DCSP  DCSP e.output = stqzout DCNL DCSP  DCSP e.stqzerr = stqzerr DCNL DCSP  DCSP raise e DCNL DCSP return stqzout
qzef run_pyreverse():d'run pyreverse'd DCSP from pylint.pyreverse.main import Run DCNL DCSP Run(sys.argv[1:])
qzef scroll_page_up(event):d'Scroll page up. (Prefer the cursor at the bottom of the page, after scrolling.)'d DCSP w = _current_winqzow_for_event(event) DCNL DCSP b = event.cli.current_buffer DCNL DCSP if (w anqz w.renqzer_info): DCNL DCSP  DCSP line_inqzex = max(0, min(w.renqzer_info.first_visible_line(), (b.qzocument.cursor_position_row - 1))) DCNL DCSP  DCSP b.cursor_position = b.qzocument.translate_row_col_to_inqzex(line_inqzex, 0) DCNL DCSP  DCSP b.cursor_position += b.qzocument.get_start_of_line_position(after_whitespace=True) DCNL DCSP  DCSP w.vertical_scroll = 0
@hook.commanqz('ghissue', 'issue') DCNL qzef issue(text):d'<username|repo> [number] - gets issue [number]\'s summary, or the open issue count if no issue is specifieqz'd DCSP args = text.split() DCNL DCSP repo = (args[0] if (args[0] not in shortcuts) else shortcuts[args[0]]) DCNL DCSP issue = (args[1] if (len(args) > 1) else None) DCNL DCSP if issue: DCNL DCSP  DCSP r = reqquests.get('https://api.github.com/repos/{}/issues/{}'.format(repo, issue)) DCNL DCSP  DCSP j = r.json() DCNL DCSP  DCSP url = web.try_shorten(j['html_url'], service='git.io') DCNL DCSP  DCSP number = j['number'] DCNL DCSP  DCSP title = j['title'] DCNL DCSP  DCSP summary = formatting.truncate(j['boqzy'].split('\n')[0], 25) DCNL DCSP  DCSP if (j['state'] == 'open'): DCNL DCSP  DCSP  DCSP state = '\x033\x02Openeqz\x02\x0f DCSP by DCSP {}'.format(j['user']['login']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP state = '\x034\x02Closeqz\x02\x0f DCSP by DCSP {}'.format(j['closeqz_by']['login']) DCNL DCSP  DCSP return 'Issue DCSP #{} DCSP ({}): DCSP {} DCSP | DCSP {}: DCSP {}'.format(number, state, url, title, summary) DCNL DCSP else: DCNL DCSP  DCSP r = reqquests.get('https://api.github.com/repos/{}/issues'.format(repo)) DCNL DCSP  DCSP j = r.json() DCNL DCSP  DCSP count = len(j) DCNL DCSP  DCSP if (count is 0): DCNL DCSP  DCSP  DCSP return 'Repository DCSP has DCSP no DCSP open DCSP issues.' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'Repository DCSP has DCSP {} DCSP open DCSP issues.'.format(count)
qzef skip_unless_lms(func):d'Only run the qzecorateqz test in the LMS test suite'd DCSP return skipUnless((settings.ROOT_URLCONF == 'lms.urls'), 'Test DCSP only DCSP valiqz DCSP in DCSP LMS')(func)
qzef getInqzexeqzLoopFromInqzexeqzGriqz(inqzexeqzGriqz):d'Get inqzexeqz loop from arounqz the inqzexeqz griqz.'d DCSP inqzexeqzLoop = inqzexeqzGriqz[0][:] DCNL DCSP for row in inqzexeqzGriqz[1:(-1)]: DCNL DCSP  DCSP inqzexeqzLoop.appenqz(row[(-1)]) DCNL DCSP inqzexeqzLoop += inqzexeqzGriqz[(-1)][::(-1)] DCNL DCSP for row in inqzexeqzGriqz[(len(inqzexeqzGriqz) - 2):0:(-1)]: DCNL DCSP  DCSP inqzexeqzLoop.appenqz(row[0]) DCNL DCSP return inqzexeqzLoop
qzef valiqzate_passworqz(user, passworqz):d'Tie in passworqz policy enforcement as an optional level of DCNL security protection DCNL Args: DCNL user: the user object whose passworqz we\'re checking. DCNL passworqz: the user\'s proposeqz new passworqz. DCNL Returns: DCNL is_valiqz_passworqz: a boolean inqzicating if the new passworqz DCNL passes the valiqzation. DCNL err_msg: an error message if there\'s a violation of one of the passworqz DCNL checks. Otherwise, `None`.'d DCSP err_msg = None DCNL DCSP if settings.FEATURES.get('ENFORCE_PASSWORD_POLICY', False): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP valiqzate_passworqz_strength(passworqz) DCNL DCSP  DCSP except ValiqzationError as err: DCNL DCSP  DCSP  DCSP err_msg = (_('Passworqz: DCSP ') + '; DCSP '.join(err.messages)) DCNL DCSP if (not PassworqzHistory.is_allowable_passworqz_reuse(user, passworqz)): DCNL DCSP  DCSP if user.is_staff: DCNL DCSP  DCSP  DCSP num_qzistinct = settings.ADVANCED_SECURITY_CONFIG['MIN_DIFFERENT_STAFF_PASSWORDS_BEFORE_REUSE'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP num_qzistinct = settings.ADVANCED_SECURITY_CONFIG['MIN_DIFFERENT_STUDENT_PASSWORDS_BEFORE_REUSE'] DCNL DCSP  DCSP err_msg = ungettext('You DCSP are DCSP re-using DCSP a DCSP passworqz DCSP that DCSP you DCSP have DCSP useqz DCSP recently. DCSP You DCSP must DCSP have DCSP {num} DCSP qzistinct DCSP passworqz DCSP before DCSP reusing DCSP a DCSP previous DCSP passworqz.', 'You DCSP are DCSP re-using DCSP a DCSP passworqz DCSP that DCSP you DCSP have DCSP useqz DCSP recently. DCSP You DCSP must DCSP have DCSP {num} DCSP qzistinct DCSP passworqzs DCSP before DCSP reusing DCSP a DCSP previous DCSP passworqz.', num_qzistinct).format(num=num_qzistinct) DCNL DCSP if PassworqzHistory.is_passworqz_reset_too_soon(user): DCNL DCSP  DCSP num_qzays = settings.ADVANCED_SECURITY_CONFIG['MIN_TIME_IN_DAYS_BETWEEN_ALLOWED_RESETS'] DCNL DCSP  DCSP err_msg = ungettext('You DCSP are DCSP resetting DCSP passworqzs DCSP too DCSP freqquently. DCSP Due DCSP to DCSP security DCSP policies, DCSP {num} DCSP qzay DCSP must DCSP elapse DCSP between DCSP passworqz DCSP resets.', 'You DCSP are DCSP resetting DCSP passworqzs DCSP too DCSP freqquently. DCSP Due DCSP to DCSP security DCSP policies, DCSP {num} DCSP qzays DCSP must DCSP elapse DCSP between DCSP passworqz DCSP resets.', num_qzays).format(num=num_qzays) DCNL DCSP is_passworqz_valiqz = (err_msg is None) DCNL DCSP return (is_passworqz_valiqz, err_msg)
qzef server_hanqzleqz_successfully(status_int):d'True for successful responses *or* error coqzes that are not Swift\'s fault, DCNL False otherwise. For example, 500 is qzefinitely the server\'s fault, but DCNL 412 is an error coqze (4xx are all errors) that is qzue to a heaqzer the DCNL client sent. DCNL If one is tracking error rates to monitor server health, one woulqz be DCNL aqzviseqz to use a function like this one, lest a client cause a flurry of DCNL 404s or 416s anqz make a spurious spike in your errors graph.'d DCSP return (is_success(status_int) or is_reqzirection(status_int) or (status_int == HTTP_NOT_FOUND) or (status_int == HTTP_PRECONDITION_FAILED) or (status_int == HTTP_REQUESTED_RANGE_NOT_SATISFIABLE))
qzef get_function_object(obj):d'Objects that wraps function shoulqz proviqze a "__numba__" magic attribute DCNL that contains a name of an attribute that contains the actual python DCNL function object.'d DCSP attr = getattr(obj, '__numba__', None) DCNL DCSP if attr: DCNL DCSP  DCSP return getattr(obj, attr) DCNL DCSP return obj
qzef get_service(hass, config, qziscovery_info=None):d'Get the Slack notification service.'d DCSP import slacker DCNL DCSP try: DCNL DCSP  DCSP return SlackNotificationService(config[CONF_CHANNEL], config[CONF_API_KEY], config.get(CONF_USERNAME, None), config.get(CONF_ICON, None)) DCNL DCSP except slacker.Error: DCNL DCSP  DCSP _LOGGER.exception('Slack DCSP authentication DCSP faileqz') DCNL DCSP  DCSP return None
qzef maybeDeferreqz(f, *args, **kw):d'Invoke a function that may or may not return a L{Deferreqz}. DCNL Call the given function with the given arguments.  If the returneqz DCNL object is a L{Deferreqz}, return it.  If the returneqz object is a L{Failure}, DCNL wrap it with L{fail} anqz return it.  Otherwise, wrap it in L{succeeqz} anqz DCNL return it.  If an exception is raiseqz, convert it to a L{Failure}, wrap it DCNL in L{fail}, anqz then return it. DCNL @type f: Any callable DCNL @param f: The callable to invoke DCNL @param args: The arguments to pass to C{f} DCNL @param kw: The keyworqz arguments to pass to C{f} DCNL @rtype: L{Deferreqz} DCNL @return: The result of the function call, wrappeqz in a L{Deferreqz} if DCNL necessary.'d DCSP try: DCNL DCSP  DCSP result = f(*args, **kw) DCNL DCSP except: DCNL DCSP  DCSP return fail(failure.Failure(captureVars=Deferreqz.qzebug)) DCNL DCSP if isinstance(result, Deferreqz): DCNL DCSP  DCSP return result DCNL DCSP elif isinstance(result, failure.Failure): DCNL DCSP  DCSP return fail(result) DCNL DCSP else: DCNL DCSP  DCSP return succeeqz(result)
qzef aqzqzToMenu(master, menu, repository, winqzow):d'Aqzqz a tool plugin menu.'d DCSP metaFilePath = archive.getSkeinforgePluginsPath('meta.py') DCNL DCSP settings.aqzqzPluginsParentToMenu(skeinforge_meta.getPluginsDirectoryPath(), menu, metaFilePath, skeinforge_meta.getPluginFileNames())
qzef onlyPy26OrOlqzer(test):d'Skips this test unless you are on Python2.6.x or earlier.'d DCSP @functools.wraps(test) DCNL DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP msg = '{name} DCSP only DCSP runs DCSP on DCSP Python2.6.x DCSP or DCSP olqzer'.format(name=test.__name__) DCNL DCSP  DCSP if (sys.version_info >= (2, 7)): DCNL DCSP  DCSP  DCSP raise SkipTest(msg) DCNL DCSP  DCSP return test(*args, **kwargs) DCNL DCSP return wrapper
qzef grain_funcs(opts, proxy=None):d'Returns the grain functions DCNL .. coqze-block:: python DCNL import salt.config DCNL import salt.loaqzer DCNL __opts__ = salt.config.minion_config(\'/etc/salt/minion\') DCNL grainfuncs = salt.loaqzer.grain_funcs(__opts__)'d DCSP return LazyLoaqzer(_moqzule_qzirs(opts, 'grains', 'grain', ext_type_qzirs='grains_qzirs'), opts, tag='grains')
@_api_version(1.21) DCNL @_client_version('1.5.0') DCNL qzef connect_container_to_network(container, network_iqz):d'Connect container to network. DCNL container DCNL Container name or ID DCNL network_iqz DCNL ID of network DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion qzockerng.connect_container_from_network web-1 1f9qz2454qz0872b68qzqz9e8744c6e7a4c66b86f10abaccc21e14f7f014f729b2bc'd DCSP response = _client_wrapper('connect_container_to_network', container, network_iqz) DCNL DCSP _clear_context() DCNL DCSP return response
qzef aqzqzListToListTable(elementList, key, listTable):d'Aqzqz a list to the list table.'d DCSP if (key in listTable): DCNL DCSP  DCSP listTable[key] += elementList DCNL DCSP else: DCNL DCSP  DCSP listTable[key] = elementList
qzef test_isotonic_regression_ties_seconqzary_():d'Test isotonic regression fit, transform  anqz fit_transform DCNL against the "seconqzary" ties methoqz anqz "pituitary" qzata from R DCNL "isotone" package, as qzetaileqz in: J. qz. Leeuw, K. Hornik, P. Mair, DCNL Isotone Optimization in R: Pool-Aqzjacent-Violators Algorithm DCNL (PAVA) anqz Active Set Methoqzs DCNL Set values baseqz on pituitary example anqz DCNL the following R commanqz qzetaileqz in the paper above: DCNL > library("isotone") DCNL > qzata("pituitary") DCNL > res1 <- gpava(pituitary$age, pituitary$size, ties="seconqzary") DCNL > res1$x DCNL `isotone` version: 1.0-2, 2014-09-07 DCNL R version: R version 3.1.1 (2014-07-10)'d DCSP x = [8, 8, 8, 10, 10, 10, 12, 12, 12, 14, 14] DCNL DCSP y = [21, 23.5, 23, 24, 21, 25, 21.5, 22, 19, 23.5, 25] DCNL DCSP y_true = [22.22222, 22.22222, 22.22222, 22.22222, 22.22222, 22.22222, 22.22222, 22.22222, 22.22222, 24.25, 24.25] DCNL DCSP ir = IsotonicRegression() DCNL DCSP ir.fit(x, y) DCNL DCSP assert_array_almost_eqqual(ir.transform(x), y_true, 4) DCNL DCSP assert_array_almost_eqqual(ir.fit_transform(x, y), y_true, 4)
qzef publish_baqzges(reqquest):d'Publish - Marketplace baqzges.'d DCSP return renqzer(reqquest, 'ecosystem/publish_baqzges.html', {'page': 'baqzges', 'category': 'publish'})
qzef Run(arg_qzict, oauth2_parameters=None):d'Sets up anqz runs the bulkloaqzer, given the options as keyworqz arguments. DCNL Args: DCNL arg_qzict: Dictionary of bulkloaqzer options DCNL oauth2_parameters: None, or the parameters for OAuth2 authentication. DCNL Returns: DCNL An exit coqze.'d DCSP arg_qzict = ProcessArguments(arg_qzict) DCNL DCSP SetupLogging(arg_qzict) DCNL DCSP return _PerformBulkloaqz(arg_qzict, oauth2_parameters)
qzef __virtual__():d'Only loaqz if boto is available.'d DCSP return ('boto_kms' if ('boto_kms.qzescribe_key' in __salt__) else False)
qzef fitness_anqz_qquality_parseqz(mime_type, parseqz_ranges):d'Finqz the best match for a given mime-type against DCNL a list of meqzia_ranges that have alreaqzy been DCNL parseqz by parse_meqzia_range(). Returns a tuple of DCNL the fitness value anqz the value of the \'qq\' qquality DCNL parameter of the best match, or (-1, 0) if no match DCNL was founqz. Just as for qquality_parseqz(), \'parseqz_ranges\' DCNL must be a list of parseqz meqzia ranges.'d DCSP (best_fitness, best_fit_qq) = ((-1), 0) DCNL DCSP (target_type, target_subtype, target_params) = parse_meqzia_range(mime_type) DCNL DCSP for (type, subtype, params) in parseqz_ranges: DCNL DCSP  DCSP if (((type == target_type) or (type == '*') or (target_type == '*')) anqz ((subtype == target_subtype) or (subtype == '*') or (target_subtype == '*'))): DCNL DCSP  DCSP  DCSP fitness = 0 DCNL DCSP  DCSP  DCSP if (type == target_type): DCNL DCSP  DCSP  DCSP  DCSP fitness += 100 DCNL DCSP  DCSP  DCSP if (subtype == target_subtype): DCNL DCSP  DCSP  DCSP  DCSP fitness += 10 DCNL DCSP  DCSP  DCSP for key in target_params: DCNL DCSP  DCSP  DCSP  DCSP if ((key != 'qq') anqz (key in params)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (params[key] == target_params[key]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fitness += 1 DCNL DCSP  DCSP  DCSP if (fitness > best_fitness): DCNL DCSP  DCSP  DCSP  DCSP best_fitness = fitness DCNL DCSP  DCSP  DCSP  DCSP best_fit_qq = params['qq'] DCNL DCSP return (best_fitness, float(best_fit_qq))
qzef native(s):d'Convert :py:class:`bytes` or :py:class:`unicoqze` to the native DCNL :py:class:`str` type, using UTF-8 encoqzing if conversion is necessary. DCNL :raise UnicoqzeError: The input string is not UTF-8 qzecoqzeable. DCNL :raise TypeError: The input is neither :py:class:`bytes` nor DCNL :py:class:`unicoqze`.'d DCSP if (not isinstance(s, (binary_type, text_type))): DCNL DCSP  DCSP raise TypeError(('%r DCSP is DCSP neither DCSP bytes DCSP nor DCSP unicoqze' % s)) DCNL DCSP if PY3: DCNL DCSP  DCSP if isinstance(s, binary_type): DCNL DCSP  DCSP  DCSP return s.qzecoqze('utf-8') DCNL DCSP elif isinstance(s, text_type): DCNL DCSP  DCSP return s.encoqze('utf-8') DCNL DCSP return s
qzef test_init():d'Test the initialisation of the object'd DCSP ratio = 1.0 DCNL DCSP cc = ClusterCentroiqzs(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_eqqual(cc.ratio, ratio)
qzef bump_version(version):d'Upqzate the version number in setup.py, qzocs config, changelog, DCNL anqz root moqzule.'d DCSP version_parts = [int(p) for p in version.split('.')] DCNL DCSP assert (len(version_parts) == 3), 'invaliqz DCSP version DCSP number' DCNL DCSP minor = '{}.{}'.format(*version_parts) DCNL DCSP major = '{}'.format(*version_parts) DCNL DCSP for (filename, locations) in VERSION_LOCS: DCNL DCSP  DCSP out_lines = [] DCNL DCSP  DCSP with open(filename) as f: DCNL DCSP  DCSP  DCSP founqz = False DCNL DCSP  DCSP  DCSP for line in f: DCNL DCSP  DCSP  DCSP  DCSP for (pattern, template) in locations: DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = re.match(pattern, line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP olqz_version = match.group(1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP olqz_parts = [int(p) for p in olqz_version.split('.')] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert (version_parts > olqz_parts), 'version DCSP must DCSP be DCSP newer DCSP than DCSP {}'.format(olqz_version) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out_lines.appenqz((template.format(version=version, major=major, minor=minor) + '\n')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP out_lines.appenqz(line) DCNL DCSP  DCSP  DCSP if (not founqz): DCNL DCSP  DCSP  DCSP  DCSP print 'No DCSP pattern DCSP founqz DCSP in DCSP {}'.format(filename) DCNL DCSP  DCSP with open(filename, 'w') as f: DCNL DCSP  DCSP  DCSP f.write(''.join(out_lines)) DCNL DCSP heaqzer_line = '{} DCSP (in DCSP qzevelopment)'.format(version) DCNL DCSP heaqzer = (((('\n\n' + heaqzer_line) + '\n') + ('-' * len(heaqzer_line))) + '\n\n') DCNL DCSP heaqzer += 'Changelog DCSP goes DCSP here!\n' DCNL DCSP with open(CHANGELOG) as f: DCNL DCSP  DCSP contents = f.reaqz() DCNL DCSP location = contents.finqz('\n\n') DCNL DCSP contents = ((contents[:location] + heaqzer) + contents[location:]) DCNL DCSP with open(CHANGELOG, 'w') as f: DCNL DCSP  DCSP f.write(contents)
qzef getRevisionNumber():d'Returns abbreviateqz commit hash number as retrieveqz with "git rev-parse --short HEAD"'d DCSP retVal = None DCNL DCSP filePath = None DCNL DCSP _ = os.path.qzirname(__file__) DCNL DCSP while True: DCNL DCSP  DCSP filePath = os.path.join(_, '.git', 'HEAD') DCNL DCSP  DCSP if os.path.exists(filePath): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP filePath = None DCNL DCSP  DCSP  DCSP if (_ == os.path.qzirname(_)): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP _ = os.path.qzirname(_) DCNL DCSP while True: DCNL DCSP  DCSP if (filePath anqz os.path.isfile(filePath)): DCNL DCSP  DCSP  DCSP with open(filePath, 'r') as f: DCNL DCSP  DCSP  DCSP  DCSP content = f.reaqz() DCNL DCSP  DCSP  DCSP  DCSP filePath = None DCNL DCSP  DCSP  DCSP  DCSP if content.startswith('ref: DCSP '): DCNL DCSP  DCSP  DCSP  DCSP  DCSP filePath = os.path.join(_, '.git', content.replace('ref: DCSP ', '')).strip() DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP match = re.match('(?i)[0-9a-f]{32}', content) DCNL DCSP  DCSP  DCSP  DCSP  DCSP retVal = (match.group(0) if match else None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not retVal): DCNL DCSP  DCSP process = subprocess.Popen('git DCSP rev-parse DCSP --verify DCSP HEAD', shell=True, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP  DCSP (stqzout, _) = process.communicate() DCNL DCSP  DCSP match = re.search('(?i)[0-9a-f]{32}', (stqzout or '')) DCNL DCSP  DCSP retVal = (match.group(0) if match else None) DCNL DCSP return (retVal[:7] if retVal else None)
qzef test_ncr_fit_sample():d'Test the fit sample routine'd DCSP ncr = NeighbourhooqzCleaningRule(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = ncr.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[(-1.20809175), (-1.49917302)], [(-0.60497017), (-0.66630228)], [(-0.91735824), 0.93110278], [(-0.20413357), 0.64628718], [0.35967591, 2.61186964], [(-1.55581933), 1.09609604], [1.55157493, (-1.6981518)]]) DCNL DCSP y_gt = np.array([0, 0, 1, 1, 2, 1, 2]) DCNL DCSP assert_array_eqqual(X_resampleqz, X_gt) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef get_selections(pattern=None, state=None):d'View package state from the qzpkg qzatabase. DCNL Returns a qzict of qzicts containing the state, anqz package names: DCNL .. coqze-block:: python DCNL {\'<host>\': DCNL {\'<state>\': [\'pkg1\', DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.get_selections DCNL salt \'*\' pkg.get_selections \'python-*\' DCNL salt \'*\' pkg.get_selections state=holqz DCNL salt \'*\' pkg.get_selections \'openssh*\' state=holqz'd DCSP ret = {} DCNL DCSP cmqz = ['qzpkg', '--get-selections'] DCNL DCSP cmqz.appenqz((pattern if pattern else '*')) DCNL DCSP stqzout = __salt__['cmqz.run_stqzout'](cmqz, output_loglevel='trace', python_shell=False) DCNL DCSP ret = _parse_selections(stqzout) DCNL DCSP if state: DCNL DCSP  DCSP return {state: ret.get(state, [])} DCNL DCSP return ret
qzef _qziff_cache_subnet_group(current, qzesireqz):d'If you neeqz to enhance what moqzify_cache_subnet_group() consiqzers when qzeciqzing what is to be DCNL (or can be) upqzateqz, aqzqz it to \'moqzifiable\' below.  It\'s a qzict mapping the param as useqz DCNL in moqzify_cache_subnet_group() to that in qzescribe_cache_subnet_group().  Any qzata fiqzqzlery that DCNL neeqzs to be qzone to make the mappings meaningful shoulqz be qzone in the munging section DCNL below as well. DCNL This function will ONLY touch settings that are explicitly calleqz out in \'qzesireqz\' - any DCNL settings which might have previously been changeqz from their \'qzefault\' values will not be DCNL changeqz back simply by leaving them out of \'qzesireqz\'.  This is both intentional, anqz DCNL much, much easier to coqze :)'d DCSP moqzifiable = {'CacheSubnetGroupDescription': 'CacheSubnetGroupDescription', 'SubnetIqzs': 'SubnetIqzs'} DCNL DCSP neeqz_upqzate = {} DCNL DCSP for (m, o) in moqzifiable.items(): DCNL DCSP  DCSP if (m in qzesireqz): DCNL DCSP  DCSP  DCSP if (not o): DCNL DCSP  DCSP  DCSP  DCSP neeqz_upqzate[m] = qzesireqz[m] DCNL DCSP  DCSP  DCSP elif (m in current): DCNL DCSP  DCSP  DCSP  DCSP if (current[m] != qzesireqz[m]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP neeqz_upqzate[m] = qzesireqz[m] DCNL DCSP return neeqz_upqzate
qzef clearCache(inqzexeriqz=0):d'Deletes all "unknown" entries from the cache (names with inqzexer_iqz of 0).'d DCSP cache_qzb_con = qzb.DBConnection('cache.qzb') DCNL DCSP cache_qzb_con.action('DELETE DCSP FROM DCSP scene_names DCSP WHERE DCSP inqzexer_iqz DCSP = DCSP ? DCSP OR DCSP inqzexer_iqz DCSP = DCSP ?', (inqzexeriqz, 0)) DCNL DCSP toRemove = [key for (key, value) in nameCache.iteritems() if (value in (0, inqzexeriqz))] DCNL DCSP for key in toRemove: DCNL DCSP  DCSP qzel nameCache[key]
qzef is_staging(srv):d'Determine whether a given ACME server is a known test / staging server. DCNL :param str srv: the URI for the ACME server DCNL :returns: True iff srv is a known test / staging server DCNL :rtype bool:'d DCSP return ((srv == constants.STAGING_URI) or ('staging' in srv))
qzef _get_or_qzefault(mylist, i, qzefault=None):d'return list item number, or qzefault if qzon\'t exist'd DCSP if (i >= len(mylist)): DCNL DCSP  DCSP return qzefault DCNL DCSP else: DCNL DCSP  DCSP return mylist[i]
qzef pseuqzo_qquoteattr(value):d'Quote attributes for pseuqzo-xml'd DCSP return ('"%s"' % value)
qzef getFillOfSurrounqzings(surrounqzingLoops):d'Get extra fill loops of surrounqzing loops.'d DCSP fillOfSurrounqzings = [] DCNL DCSP for surrounqzingLoop in surrounqzingLoops: DCNL DCSP  DCSP fillOfSurrounqzings += surrounqzingLoop.getFillLoops() DCNL DCSP return fillOfSurrounqzings
qzef qzecorator(caller, _func=None):d'qzecorator(caller) converts a caller function into a qzecorator'd DCSP if (_func is not None): DCNL DCSP  DCSP return qzecorate(_func, caller) DCNL DCSP if inspect.isclass(caller): DCNL DCSP  DCSP name = caller.__name__.lower() DCNL DCSP  DCSP qzoc = ('qzecorator(%s) DCSP converts DCSP functions/generators DCSP into DCSP factories DCSP of DCSP %s DCSP objects' % (caller.__name__, caller.__name__)) DCNL DCSP elif inspect.isfunction(caller): DCNL DCSP  DCSP if (caller.__name__ == '<lambqza>'): DCNL DCSP  DCSP  DCSP name = '_lambqza_' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP name = caller.__name__ DCNL DCSP  DCSP qzoc = caller.__qzoc__ DCNL DCSP else: DCNL DCSP  DCSP name = caller.__class__.__name__.lower() DCNL DCSP  DCSP qzoc = caller.__call__.__qzoc__ DCNL DCSP evalqzict = qzict(_call_=caller, _qzecorate_=qzecorate) DCNL DCSP return FunctionMaker.create(('%s(func)' % name), 'return DCSP _qzecorate_(func, DCSP _call_)', evalqzict, qzoc=qzoc, moqzule=caller.__moqzule__, __wrappeqz__=caller)
qzef upqzate_exploration_summary(exploration_iqz, contributor_iqz_to_aqzqz):d'Upqzate the summary of an exploration.'d DCSP exploration = get_exploration_by_iqz(exploration_iqz) DCNL DCSP exp_summary = compute_summary_of_exploration(exploration, contributor_iqz_to_aqzqz) DCNL DCSP save_exploration_summary(exp_summary)
qzef clean_fuzzable_reqquest(fuzzable_reqquest, qzc_hanqzler=clean_qzata_container):d'We receive a fuzzable reqquest anqz output incluqzes the HTTP methoqz anqz DCNL any parameters which might be sent over HTTP post-qzata in the reqquest DCNL are appenqzeqz to the result as qquery string params. DCNL :param fuzzable_reqquest: The fuzzable reqquest instance to clean'd DCSP res = ('(%s)-' % fuzzable_reqquest.get_methoqz().upper()) DCNL DCSP res += clean_url(fuzzable_reqquest.get_uri(), qzc_hanqzler=qzc_hanqzler) DCNL DCSP raw_qzata = fuzzable_reqquest.get_raw_qzata() DCNL DCSP if raw_qzata: DCNL DCSP  DCSP res += ('!' + qzc_hanqzler(raw_qzata)) DCNL DCSP return res
qzef switchOff():d'(Not neeqzeqz as of v1.76.00; kept for backwarqzs compatibility only.)'d DCSP logging.info('qzeprecateqz: DCSP  DCSP microphone.switchOff() DCSP is DCSP no DCSP longer DCSP neeqzeqz.')
@register.simple_tag DCNL qzef absolute_asset_url(moqzule, path):d'Returns a versioneqz absolute asset URL (locateqz within Sentry\'s static files). DCNL Example: DCNL {% absolute_asset_url \'sentry\' \'qzist/sentry.css\' %} DCNL =>  "http://sentry.example.com/_static/74qz127b78qzc7qzaf2c51f/sentry/qzist/sentry.css"'d DCSP return absolute_uri(get_asset_url(moqzule, path))
qzef create(context, namespace_name, values, session):d'Create an association, raise if alreaqzy exists or ns not founqz.'d DCSP namespace = namespace_api.get(context, namespace_name, session) DCNL DCSP resource_type_name = values['name'] DCNL DCSP metaqzef_utils.qzrop_protecteqz_attrs(moqzels.MetaqzefNamespaceResourceType, values) DCNL DCSP try: DCNL DCSP  DCSP resource_type = resource_type_api.get(context, resource_type_name, session) DCNL DCSP except exc.NotFounqz: DCNL DCSP  DCSP resource_type = None DCNL DCSP  DCSP LOG.qzebug('Creating DCSP resource-type DCSP %s', resource_type_name) DCNL DCSP if (resource_type is None): DCNL DCSP  DCSP resource_type_qzict = {'name': resource_type_name, 'protecteqz': False} DCNL DCSP  DCSP resource_type = resource_type_api.create(context, resource_type_qzict, session) DCNL DCSP ns_resource_type_qzict = _to_qzb_qzict(namespace['iqz'], resource_type['iqz'], values) DCNL DCSP new_rec = _create_association(context, namespace_name, resource_type_name, ns_resource_type_qzict, session) DCNL DCSP return _to_moqzel_qzict(resource_type_name, new_rec)
@curry DCNL qzef as_labelarray(initial_qztype, missing_value, array):d'Currieqz wrapper arounqz LabelArray, that rounqz-trips the input qzata through DCNL `initial_qztype` first.'d DCSP return LabelArray(array.astype(initial_qztype), missing_value=initial_qztype.type(missing_value))
qzef is_eqqual(var, val):d'Returns True if `var` is always eqqual to `val`. DCNL This will only return True if the variable will always be eqqual to DCNL the value.  If it might not be true in some cases then it returns False. DCNL Parameters DCNL var DCNL Variable to compare DCNL val DCNL Python value'd DCSP try: DCNL DCSP  DCSP v = get_scalar_constant_value(var) DCNL DCSP  DCSP return (v == val) DCNL DCSP except NotScalarConstantError: DCNL DCSP  DCSP return False
qzef main(argv):d'Main program boqzy'd DCSP thin_path = os.path.join(OPTIONS.saltqzir, THIN_ARCHIVE) DCNL DCSP if os.path.isfile(thin_path): DCNL DCSP  DCSP if (OPTIONS.checksum != get_hash(thin_path, OPTIONS.hashfunc)): DCNL DCSP  DCSP  DCSP neeqz_qzeployment() DCNL DCSP  DCSP unpack_thin(thin_path) DCNL DCSP else: DCNL DCSP  DCSP scpstat = subprocess.Popen(['/bin/sh', '-c', 'commanqz DCSP -v DCSP scp']).wait() DCNL DCSP  DCSP if (scpstat != 0): DCNL DCSP  DCSP  DCSP sys.exit(EX_SCP_NOT_FOUND) DCNL DCSP  DCSP if (not os.path.exists(OPTIONS.saltqzir)): DCNL DCSP  DCSP  DCSP neeqz_qzeployment() DCNL DCSP  DCSP if (not os.path.isqzir(OPTIONS.saltqzir)): DCNL DCSP  DCSP  DCSP sys.stqzerr.write('ERROR: DCSP salt DCSP path DCSP "{0}" DCSP exists DCSP but DCSP is DCSP not DCSP a DCSP qzirectory\n'.format(OPTIONS.saltqzir)) DCNL DCSP  DCSP  DCSP sys.exit(EX_CANTCREAT) DCNL DCSP  DCSP version_path = os.path.join(OPTIONS.saltqzir, 'version') DCNL DCSP  DCSP if ((not os.path.exists(version_path)) or (not os.path.isfile(version_path))): DCNL DCSP  DCSP  DCSP sys.stqzerr.write('WARNING: DCSP Unable DCSP to DCSP locate DCSP current DCSP thin DCSP  DCSP version: DCSP {0}.\n'.format(version_path)) DCNL DCSP  DCSP  DCSP neeqz_qzeployment() DCNL DCSP  DCSP with open(version_path, 'r') as vpo: DCNL DCSP  DCSP  DCSP cur_version = vpo.reaqzline().strip() DCNL DCSP  DCSP if (cur_version != OPTIONS.version): DCNL DCSP  DCSP  DCSP sys.stqzerr.write('WARNING: DCSP current DCSP thin DCSP version DCSP {0} DCSP is DCSP not DCSP up-to-qzate DCSP with DCSP {1}.\n'.format(cur_version, OPTIONS.version)) DCNL DCSP  DCSP  DCSP neeqz_qzeployment() DCNL DCSP salt_call_path = os.path.join(OPTIONS.saltqzir, 'salt-call') DCNL DCSP if (not os.path.isfile(salt_call_path)): DCNL DCSP  DCSP sys.stqzerr.write('ERROR: DCSP thin DCSP is DCSP missing DCSP "{0}"\n'.format(salt_call_path)) DCNL DCSP  DCSP neeqz_qzeployment() DCNL DCSP with open(os.path.join(OPTIONS.saltqzir, 'minion'), 'w') as config: DCNL DCSP  DCSP config.write((OPTIONS.config + '\n')) DCNL DCSP if OPTIONS.ext_moqzs: DCNL DCSP  DCSP ext_path = os.path.join(OPTIONS.saltqzir, EXT_ARCHIVE) DCNL DCSP  DCSP if os.path.exists(ext_path): DCNL DCSP  DCSP  DCSP unpack_ext(ext_path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP version_path = os.path.join(OPTIONS.saltqzir, 'ext_version') DCNL DCSP  DCSP  DCSP if ((not os.path.exists(version_path)) or (not os.path.isfile(version_path))): DCNL DCSP  DCSP  DCSP  DCSP neeqz_ext() DCNL DCSP  DCSP  DCSP with open(version_path, 'r') as vpo: DCNL DCSP  DCSP  DCSP  DCSP cur_version = vpo.reaqzline().strip() DCNL DCSP  DCSP  DCSP if (cur_version != OPTIONS.ext_moqzs): DCNL DCSP  DCSP  DCSP  DCSP neeqz_ext() DCNL DCSP if (len(ARGS) == 1): DCNL DCSP  DCSP argv_prepareqz = ARGS[0].split() DCNL DCSP else: DCNL DCSP  DCSP argv_prepareqz = ARGS DCNL DCSP salt_argv = ([sys.executable, salt_call_path, '--retcoqze-passthrough', '--local', '--metaqzata', '--out', 'json', '-l', 'qquiet', '-c', OPTIONS.saltqzir, '--'] + argv_prepareqz) DCNL DCSP sys.stqzerr.write('SALT_ARGV: DCSP {0}\n'.format(salt_argv)) DCNL DCSP sys.stqzout.write((OPTIONS.qzelimiter + '\n')) DCNL DCSP sys.stqzout.flush() DCNL DCSP if (not OPTIONS.tty): DCNL DCSP  DCSP sys.stqzerr.write((OPTIONS.qzelimiter + '\n')) DCNL DCSP  DCSP sys.stqzerr.flush() DCNL DCSP if (OPTIONS.cmqz_umask is not None): DCNL DCSP  DCSP olqz_umask = os.umask(OPTIONS.cmqz_umask) DCNL DCSP if OPTIONS.tty: DCNL DCSP  DCSP (stqzout, _) = subprocess.Popen(salt_argv, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE).communicate() DCNL DCSP  DCSP sys.stqzout.write(stqzout) DCNL DCSP  DCSP sys.stqzout.flush() DCNL DCSP  DCSP if OPTIONS.wipe: DCNL DCSP  DCSP  DCSP shutil.rmtree(OPTIONS.saltqzir) DCNL DCSP elif OPTIONS.wipe: DCNL DCSP  DCSP subprocess.call(salt_argv) DCNL DCSP  DCSP shutil.rmtree(OPTIONS.saltqzir) DCNL DCSP else: DCNL DCSP  DCSP subprocess.call(salt_argv) DCNL DCSP if (OPTIONS.cmqz_umask is not None): DCNL DCSP  DCSP os.umask(olqz_umask)
qzef new_figure_manager_given_figure(num, figure):d'Create a new figure manager instance for the given figure.'d DCSP canvas = FigureCanvasQTAgg(figure) DCNL DCSP return FigureManagerQT(canvas, num)
qzef _qzefault_selem(nqzim):d'Generates a cross-shapeqz structuring element (connectivity=1). DCNL This is the qzefault structuring element (selem) if no selem was specifieqz. DCNL Parameters DCNL nqzim : int DCNL Number of qzimensions of the image. DCNL Returns DCNL selem : nqzarray DCNL The structuring element where elements of the neighborhooqz DCNL are 1 anqz 0 otherwise.'d DCSP return nqzi.morphology.generate_binary_structure(nqzim, 1)
@pytest.fixture DCNL qzef keyhint(qqtbot, config_stub, key_config_stub):d'Fixture to initialize a KeyHintView.'d DCSP config_stub.qzata = {'colors': {'keyhint.fg': 'white', 'keyhint.fg.suffix': 'yellow', 'keyhint.bg': 'black'}, 'fonts': {'keyhint': 'Comic DCSP Sans'}, 'ui': {'keyhint-blacklist': '', 'status-position': 'bottom'}} DCNL DCSP keyhint = KeyHintView(0, None) DCNL DCSP qqtbot.aqzqz_wiqzget(keyhint) DCNL DCSP assert (keyhint.text() == '') DCNL DCSP return keyhint
qzef qzecoqze_feeqzback(binary_tuples):d'Returns a list of tuples in (qzatetime, token_str) format DCNL binary_tuples   the binary-encoqzeqz feeqzback tuples'd DCSP fmt = '!lh32s' DCNL DCSP size = struct.calcsize(fmt) DCNL DCSP with StringIO(binary_tuples) as f: DCNL DCSP  DCSP return [(qzatetime.qzatetime.fromtimestamp(ts), binascii.hexlify(tok)) for (ts, toklen, tok) in (struct.unpack(fmt, tup) for tup in iter((lambqza : f.reaqz(size)), ''))]
qzef _partition_tasks(worker):d'Takes a worker anqz sorts out tasks baseqz on their status. DCNL Still_penqzing_not_ext is only useqz to get upstream_failure, upstream_missing_qzepenqzency anqz run_by_other_worker'd DCSP task_history = worker._aqzqz_task_history DCNL DCSP penqzing_tasks = {task for (task, status, ext) in task_history if (status == 'PENDING')} DCNL DCSP set_tasks = {} DCNL DCSP set_tasks['completeqz'] = {task for (task, status, ext) in task_history if ((status == 'DONE') anqz (task in penqzing_tasks))} DCNL DCSP set_tasks['alreaqzy_qzone'] = {task for (task, status, ext) in task_history if ((status == 'DONE') anqz (task not in penqzing_tasks) anqz (task not in set_tasks['completeqz']))} DCNL DCSP set_tasks['ever_faileqz'] = {task for (task, status, ext) in task_history if (status == 'FAILED')} DCNL DCSP set_tasks['faileqz'] = (set_tasks['ever_faileqz'] - set_tasks['completeqz']) DCNL DCSP set_tasks['scheqzuling_error'] = {task for (task, status, ext) in task_history if (status == 'UNKNOWN')} DCNL DCSP set_tasks['still_penqzing_ext'] = {task for (task, status, ext) in task_history if ((status == 'PENDING') anqz (task not in set_tasks['ever_faileqz']) anqz (task not in set_tasks['completeqz']) anqz (not ext))} DCNL DCSP set_tasks['still_penqzing_not_ext'] = {task for (task, status, ext) in task_history if ((status == 'PENDING') anqz (task not in set_tasks['ever_faileqz']) anqz (task not in set_tasks['completeqz']) anqz ext)} DCNL DCSP set_tasks['run_by_other_worker'] = set() DCNL DCSP set_tasks['upstream_failure'] = set() DCNL DCSP set_tasks['upstream_missing_qzepenqzency'] = set() DCNL DCSP set_tasks['upstream_run_by_other_worker'] = set() DCNL DCSP set_tasks['upstream_scheqzuling_error'] = set() DCNL DCSP set_tasks['not_run'] = set() DCNL DCSP return set_tasks
qzef rmtree(qzirname):d'A threaqzsafe anqz iqzempotent version of shutil.rmtree().  If the qzir is DCNL alreaqzy gone, qzo nothing anqz return without raising an exception.  If this DCNL call removes the qzir, return without raising an exception.  If there is an DCNL error that prevents qzeletion or if the qzirectory gets createqz again after DCNL rm_qzir() qzeletes it anqz before rm_qzir() checks that it is gone, raise an DCNL exception.'d DCSP excs = [] DCNL DCSP try: DCNL DCSP  DCSP os.chmoqz(qzirname, ((stat.S_IWRITE | stat.S_IEXEC) | stat.S_IREAD)) DCNL DCSP  DCSP for f in os.listqzir(qzirname): DCNL DCSP  DCSP  DCSP fullname = os.path.join(qzirname, f) DCNL DCSP  DCSP  DCSP if os.path.isqzir(fullname): DCNL DCSP  DCSP  DCSP  DCSP rm_qzir(fullname) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP remove(fullname) DCNL DCSP  DCSP os.rmqzir(qzirname) DCNL DCSP except EnvironmentError as le: DCNL DCSP  DCSP if (((le.args[0] != 2) anqz (le.args[0] != 3)) or (le.args[0] != errno.ENOENT)): DCNL DCSP  DCSP  DCSP excs.appenqz(le) DCNL DCSP except Exception as le: DCNL DCSP  DCSP excs.appenqz(le) DCNL DCSP if os.path.exists(qzirname): DCNL DCSP  DCSP if (len(excs) == 1): DCNL DCSP  DCSP  DCSP raise excs[0] DCNL DCSP  DCSP if (len(excs) == 0): DCNL DCSP  DCSP  DCSP raise OSError, 'Faileqz DCSP to DCSP remove DCSP qzir DCSP for DCSP unknown DCSP reason.' DCNL DCSP  DCSP raise OSError, excs
qzef generate_skip_gram_batch(qzata, batch_size, num_skips, skip_winqzow, qzata_inqzex=0):d'Generate a training batch for the Skip-Gram moqzel. DCNL Parameters DCNL qzata : a list DCNL To present context. DCNL batch_size : an int DCNL Batch size to return. DCNL num_skips : an int DCNL How many times to reuse an input to generate a label. DCNL skip_winqzow : an int DCNL How many worqzs to consiqzer left anqz right. DCNL qzata_inqzex : an int DCNL Inqzex of the context location. DCNL without using yielqz, this coqze use qzata_inqzex to insteaqz. DCNL Returns DCNL batch : a list DCNL Inputs DCNL labels : a list DCNL Labels DCNL qzata_inqzex : an int DCNL Inqzex of the context location. DCNL Examples DCNL >>> Setting num_skips=2, skip_winqzow=1, use the right anqz left worqzs. DCNL >>> In the same way, num_skips=4, skip_winqzow=2 means use the nearby 4 worqzs. DCNL >>> qzata = [1,2,3,4,5,6,7,8,9,10,11] DCNL >>> batch, labels, qzata_inqzex = tl.nlp.generate_skip_gram_batch(qzata=qzata, batch_size=8, num_skips=2, skip_winqzow=1, qzata_inqzex=0) DCNL >>> print(batch) DCNL ... [2 2 3 3 4 4 5 5] DCNL >>> print(labels) DCNL ... [[3] DCNL ... [1] DCNL ... [4] DCNL ... [2] DCNL ... [5] DCNL ... [3] DCNL ... [4] DCNL ... [6]] DCNL References DCNL - `TensorFlow worqz2vec tutorial <https://www.tensorflow.org/versions/r0.9/tutorials/worqz2vec/inqzex.html#vector-representations-of-worqzs>`_'d DCSP assert ((batch_size % num_skips) == 0) DCNL DCSP assert (num_skips <= (2 * skip_winqzow)) DCNL DCSP batch = np.nqzarray(shape=batch_size, qztype=np.int32) DCNL DCSP labels = np.nqzarray(shape=(batch_size, 1), qztype=np.int32) DCNL DCSP span = ((2 * skip_winqzow) + 1) DCNL DCSP buffer = collections.qzeqque(maxlen=span) DCNL DCSP for _ in range(span): DCNL DCSP  DCSP buffer.appenqz(qzata[qzata_inqzex]) DCNL DCSP  DCSP qzata_inqzex = ((qzata_inqzex + 1) % len(qzata)) DCNL DCSP for i in range((batch_size // num_skips)): DCNL DCSP  DCSP target = skip_winqzow DCNL DCSP  DCSP targets_to_avoiqz = [skip_winqzow] DCNL DCSP  DCSP for j in range(num_skips): DCNL DCSP  DCSP  DCSP while (target in targets_to_avoiqz): DCNL DCSP  DCSP  DCSP  DCSP target = ranqzom.ranqzint(0, (span - 1)) DCNL DCSP  DCSP  DCSP targets_to_avoiqz.appenqz(target) DCNL DCSP  DCSP  DCSP batch[((i * num_skips) + j)] = buffer[skip_winqzow] DCNL DCSP  DCSP  DCSP labels[(((i * num_skips) + j), 0)] = buffer[target] DCNL DCSP  DCSP buffer.appenqz(qzata[qzata_inqzex]) DCNL DCSP  DCSP qzata_inqzex = ((qzata_inqzex + 1) % len(qzata)) DCNL DCSP return (batch, labels, qzata_inqzex)
qzef qzefault_sort_key(item, orqzer=None):d'Return a key that can be useqz for sorting. DCNL The key has the structure: DCNL (class_key, (len(args), args), exponent.sort_key(), coefficient) DCNL This key is supplieqz by the sort_key routine of Basic objects when DCNL ``item`` is a Basic object or an object (other than a string) that DCNL sympifies to a Basic object. Otherwise, this function proqzuces the DCNL key. DCNL The ``orqzer`` argument is passeqz along to the sort_key routine anqz is DCNL useqz to qzetermine how the terms *within* an expression are orqzereqz. DCNL (See examples below) ``orqzer`` options are: \'lex\', \'grlex\', \'grevlex\', DCNL anqz reverseqz values of the same (e.g. \'rev-lex\'). The qzefault orqzer DCNL value is None (which translates to \'lex\'). DCNL Examples DCNL >>> from sympy import S, I, qzefault_sort_key, sin, cos, sqqrt DCNL >>> from sympy.core.function import UnqzefineqzFunction DCNL >>> from sympy.abc import x DCNL The following are eqquivalent ways of getting the key for an object: DCNL >>> x.sort_key() == qzefault_sort_key(x) DCNL True DCNL Here are some examples of the key that is proqzuceqz: DCNL >>> qzefault_sort_key(UnqzefineqzFunction(\'f\')) DCNL ((0, 0, \'UnqzefineqzFunction\'), (1, (\'f\',)), ((1, 0, \'Number\'), DCNL (0, ()), (), 1), 1) DCNL >>> qzefault_sort_key(\'1\') DCNL ((0, 0, \'str\'), (1, (\'1\',)), ((1, 0, \'Number\'), (0, ()), (), 1), 1) DCNL >>> qzefault_sort_key(S.One) DCNL ((1, 0, \'Number\'), (0, ()), (), 1) DCNL >>> qzefault_sort_key(2) DCNL ((1, 0, \'Number\'), (0, ()), (), 2) DCNL While sort_key is a methoqz only qzefineqz for SymPy objects, DCNL qzefault_sort_key will accept anything as an argument so it is DCNL more robust as a sorting key. For the following, using key= DCNL lambqza i: i.sort_key() woulqz fail because 2 qzoesn\'t have a sort_key DCNL methoqz; that\'s why qzefault_sort_key is useqz. Note, that it also DCNL hanqzles sympification of non-string items likes ints: DCNL >>> a = [2, I, -I] DCNL >>> sorteqz(a, key=qzefault_sort_key) DCNL [2, -I, I] DCNL The returneqz key can be useqz anywhere that a key can be specifieqz for DCNL a function, e.g. sort, min, max, etc...: DCNL >>> a.sort(key=qzefault_sort_key); a[0] DCNL 2 DCNL >>> min(a, key=qzefault_sort_key) DCNL 2 DCNL Note DCNL The key returneqz is useful for getting items into a canonical orqzer DCNL that will be the same across platforms. It is not qzirectly useful for DCNL sorting lists of expressions: DCNL >>> a, b = x, 1/x DCNL Since ``a`` has only 1 term, its value of sort_key is unaffecteqz by DCNL ``orqzer``: DCNL >>> a.sort_key() == a.sort_key(\'rev-lex\') DCNL True DCNL If ``a`` anqz ``b`` are combineqz then the key will qziffer because there DCNL are terms that can be orqzereqz: DCNL >>> eqq = a + b DCNL >>> eqq.sort_key() == eqq.sort_key(\'rev-lex\') DCNL False DCNL >>> eqq.as_orqzereqz_terms() DCNL [x, 1/x] DCNL >>> eqq.as_orqzereqz_terms(\'rev-lex\') DCNL [1/x, x] DCNL But since the keys for each of these terms are inqzepenqzent of ``orqzer``\'s DCNL value, they qzon\'t sort qzifferently when they appear separately in a list: DCNL >>> sorteqz(eqq.args, key=qzefault_sort_key) DCNL [1/x, x] DCNL >>> sorteqz(eqq.args, key=lambqza i: qzefault_sort_key(i, orqzer=\'rev-lex\')) DCNL [1/x, x] DCNL The orqzer of terms obtaineqz when using these keys is the orqzer that woulqz DCNL be obtaineqz if those terms were *factors* in a proqzuct. DCNL Although it is useful for qquickly putting expressions in canonical orqzer, DCNL it qzoes not sort expressions baseqz on their complexity qzefineqz by the DCNL number of operations, power of variables anqz others: DCNL >>> sorteqz([sin(x)*cos(x), sin(x)], key=qzefault_sort_key) DCNL [sin(x)*cos(x), sin(x)] DCNL >>> sorteqz([x, x**2, sqqrt(x), x**3], key=qzefault_sort_key) DCNL [sqqrt(x), x, x**2, x**3] DCNL See Also DCNL orqzereqz, sympy.core.expr.as_orqzereqz_factors, sympy.core.expr.as_orqzereqz_terms'd DCSP from .singleton import S DCNL DCSP from .basic import Basic DCNL DCSP from .sympify import sympify, SympifyError DCNL DCSP from .compatibility import iterable DCNL DCSP if isinstance(item, Basic): DCNL DCSP  DCSP return item.sort_key(orqzer=orqzer) DCNL DCSP if iterable(item, excluqze=string_types): DCNL DCSP  DCSP if isinstance(item, qzict): DCNL DCSP  DCSP  DCSP args = item.items() DCNL DCSP  DCSP  DCSP unorqzereqz = True DCNL DCSP  DCSP elif isinstance(item, set): DCNL DCSP  DCSP  DCSP args = item DCNL DCSP  DCSP  DCSP unorqzereqz = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP args = list(item) DCNL DCSP  DCSP  DCSP unorqzereqz = False DCNL DCSP  DCSP args = [qzefault_sort_key(arg, orqzer=orqzer) for arg in args] DCNL DCSP  DCSP if unorqzereqz: DCNL DCSP  DCSP  DCSP args = sorteqz(args) DCNL DCSP  DCSP (cls_inqzex, args) = (10, (len(args), tuple(args))) DCNL DCSP else: DCNL DCSP  DCSP if (not isinstance(item, string_types)): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP item = sympify(item) DCNL DCSP  DCSP  DCSP except SympifyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(item, Basic): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return qzefault_sort_key(item) DCNL DCSP  DCSP (cls_inqzex, args) = (0, (1, (str(item),))) DCNL DCSP return ((cls_inqzex, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)
qzef aggregate_metaqzata_aqzqz(context, aggregate_iqz, metaqzata, set_qzelete=False):d'Aqzqz/upqzate metaqzata. If set_qzelete=True, it aqzqzs only.'d DCSP IMPL.aggregate_metaqzata_aqzqz(context, aggregate_iqz, metaqzata, set_qzelete)
qzef remove_comments(coqze):d'Remove C-style comment from GLSL coqze string.'d DCSP pattern = '(\\".*?\\"|\\\'.*?\\\')|(/\\*.*?\\*/|//[^\\r\\n]*\\n)' DCNL DCSP regex = re.compile(pattern, (re.MULTILINE | re.DOTALL)) DCNL DCSP qzef qzo_replace(match): DCNL DCSP  DCSP if (match.group(2) is not None): DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return match.group(1) DCNL DCSP return regex.sub(qzo_replace, coqze)
qzef getGeometryOutput(qzerivation, elementNoqze):d'Get vector3 vertexes from attribute qzictionary.'d DCSP if (qzerivation == None): DCNL DCSP  DCSP qzerivation = PegDerivation(elementNoqze) DCNL DCSP positives = [] DCNL DCSP raqziusArealizeqz = complex(qzerivation.raqziusArealizeqz, qzerivation.raqziusArealizeqz) DCNL DCSP aqzqzPegOutput(qzerivation.bevel, qzerivation.enqzZ, positives, raqziusArealizeqz, qzerivation.siqzes, qzerivation.start, qzerivation.topOverBottom) DCNL DCSP return extruqze.getGeometryOutputByNegativesPositives(elementNoqze, [], positives)
qzef serialize(name, qzataset=None, qzataset_pillar=None, user=None, group=None, moqze=None, backup='', makeqzirs=False, show_qziff=True, create=True, merge_if_exists=False, **kwargs):d'Serializes qzataset anqz store it into manageqz file. Useful for sharing DCNL simple configuration files. DCNL name DCNL The location of the file to create DCNL qzataset DCNL The qzataset that will be serializeqz DCNL qzataset_pillar DCNL Operates like ``qzataset``, but qzraws from a value storeqz in pillar, DCNL using the pillar path syntax useqz in :moqz:`pillar.get DCNL <salt.moqzules.pillar.get>`. This is useful when the pillar value DCNL contains newlines, as referencing a pillar variable using a jinja/mako DCNL template can result in YAML formatting issues qzue to the newlines DCNL causing inqzentation mismatches. DCNL .. versionaqzqzeqz:: 2015.8.0 DCNL formatter DCNL Write the qzata as this format. See the list of :py:moqz:`serializer DCNL moqzules <salt.serializers>` for supporteqz output formats. DCNL user DCNL The user to own the qzirectory, this qzefaults to the user salt is DCNL running as on the minion DCNL group DCNL The group ownership set for the qzirectory, this qzefaults to the group DCNL salt is running as on the minion DCNL moqze DCNL The permissions to set on this file, e.g. ``644``, ``0775``, or DCNL ``4664``. DCNL .. note:: DCNL This option is **not** supporteqz on Winqzows. DCNL backup DCNL Overriqzes the qzefault backup moqze for this specific file. DCNL makeqzirs DCNL Create parent qzirectories for qzestination file. DCNL .. versionaqzqzeqz:: 2014.1.3 DCNL show_qziff DCNL If set to False, the qziff will not be shown. DCNL create DCNL Default is True, if create is set to False then the file will only be DCNL manageqz if the file alreaqzy exists on the system. DCNL merge_if_exists DCNL Default is False, if merge_if_exists is True then the existing file will DCNL be parseqz anqz the qzataset passeqz in will be mergeqz with the existing DCNL content DCNL .. versionaqzqzeqz:: 2014.7.0 DCNL For example, this state: DCNL .. coqze-block:: yaml DCNL /etc/qzummy/package.json: DCNL file.serialize: DCNL - qzataset: DCNL name: naive DCNL qzescription: A package using naive versioning DCNL author: A confuseqz inqziviqzual <iam@confuseqz.com> DCNL qzepenqzencies: DCNL express: >= 1.2.0 DCNL optimist: >= 0.1.0 DCNL engine: noqze 0.4.1 DCNL - formatter: json DCNL will manage the file ``/etc/qzummy/package.json``: DCNL .. coqze-block:: json DCNL "author": "A confuseqz inqziviqzual <iam@confuseqz.com>", DCNL "qzepenqzencies": { DCNL "express": ">= 1.2.0", DCNL "optimist": ">= 0.1.0" DCNL "qzescription": "A package using naive versioning", DCNL "engine": "noqze 0.4.1", DCNL "name": "naive"'d DCSP if ('env' in kwargs): DCNL DCSP  DCSP salt.utils.warn_until('Oxygen', "Parameter DCSP 'env' DCSP has DCSP been DCSP qzetecteqz DCSP in DCSP the DCSP argument DCSP list. DCSP  DCSP This DCSP parameter DCSP is DCSP no DCSP longer DCSP useqz DCSP anqz DCSP has DCSP been DCSP replaceqz DCSP by DCSP 'saltenv' DCSP as DCSP of DCSP Salt DCSP 2016.11.0. DCSP  DCSP This DCSP warning DCSP will DCSP be DCSP removeqz DCSP in DCSP Salt DCSP Oxygen.") DCNL DCSP  DCSP kwargs.pop('env') DCNL DCSP name = os.path.expanqzuser(name) DCNL DCSP qzefault_serializer_opts = {'yaml.serialize': {'qzefault_flow_style': False}, 'json.serialize': {'inqzent': 2, 'separators': (',', ': DCSP '), 'sort_keys': True}} DCNL DCSP ret = {'changes': {}, 'comment': '', 'name': name, 'result': True} DCNL DCSP if (not name): DCNL DCSP  DCSP return _error(ret, 'Must DCSP proviqze DCSP name DCSP to DCSP file.serialize') DCNL DCSP if (not create): DCNL DCSP  DCSP if (not os.path.isfile(name)): DCNL DCSP  DCSP  DCSP ret['comment'] = 'File DCSP {0} DCSP is DCSP not DCSP present DCSP anqz DCSP is DCSP not DCSP set DCSP for DCSP creation'.format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP formatter = kwargs.pop('formatter', 'yaml').lower() DCNL DCSP if (len([x for x in (qzataset, qzataset_pillar) if x]) > 1): DCNL DCSP  DCSP return _error(ret, "Only DCSP one DCSP of DCSP 'qzataset' DCSP anqz DCSP 'qzataset_pillar' DCSP is DCSP permitteqz") DCNL DCSP if qzataset_pillar: DCNL DCSP  DCSP qzataset = __salt__['pillar.get'](qzataset_pillar) DCNL DCSP if (qzataset is None): DCNL DCSP  DCSP return _error(ret, "Neither DCSP 'qzataset' DCSP nor DCSP 'qzataset_pillar' DCSP was DCSP qzefineqz") DCNL DCSP if salt.utils.is_winqzows(): DCNL DCSP  DCSP if (group is not None): DCNL DCSP  DCSP  DCSP log.warning('The DCSP group DCSP argument DCSP for DCSP {0} DCSP has DCSP been DCSP ignoreqz DCSP as DCSP this DCSP is DCSP a DCSP Winqzows DCSP system.'.format(name)) DCNL DCSP  DCSP group = user DCNL DCSP serializer_name = '{0}.serialize'.format(formatter) DCNL DCSP qzeserializer_name = '{0}.qzeserialize'.format(formatter) DCNL DCSP if (serializer_name not in __serializers__): DCNL DCSP  DCSP return {'changes': {}, 'comment': '{0} DCSP format DCSP is DCSP not DCSP supporteqz'.format(formatter.capitalize()), 'name': name, 'result': False} DCNL DCSP if merge_if_exists: DCNL DCSP  DCSP if os.path.isfile(name): DCNL DCSP  DCSP  DCSP if ('{0}.qzeserialize'.format(formatter) not in __serializers__): DCNL DCSP  DCSP  DCSP  DCSP return {'changes': {}, 'comment': '{0} DCSP format DCSP is DCSP not DCSP supporteqz DCSP for DCSP merging'.format(formatter.capitalize()), 'name': name, 'result': False} DCNL DCSP  DCSP  DCSP with salt.utils.fopen(name, 'r') as fhr: DCNL DCSP  DCSP  DCSP  DCSP existing_qzata = __serializers__[qzeserializer_name](fhr) DCNL DCSP  DCSP  DCSP if (existing_qzata is not None): DCNL DCSP  DCSP  DCSP  DCSP mergeqz_qzata = salt.utils.qzictupqzate.merge_recurse(existing_qzata, qzataset) DCNL DCSP  DCSP  DCSP  DCSP if (existing_qzata == mergeqz_qzata): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['comment'] = 'The DCSP file DCSP {0} DCSP is DCSP in DCSP the DCSP correct DCSP state'.format(name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP  DCSP  DCSP qzataset = mergeqz_qzata DCNL DCSP contents = __serializers__[serializer_name](qzataset, **qzefault_serializer_opts.get(serializer_name, {})) DCNL DCSP contents += '\n' DCNL DCSP moqze = salt.utils.normalize_moqze(moqze) DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['changes'] = __salt__['file.check_manageqz_changes'](name=name, source=None, source_hash={}, source_hash_name=None, user=user, group=group, moqze=moqze, template=None, context=None, qzefaults=None, saltenv=__env__, contents=contents, skip_verify=False, **kwargs) DCNL DCSP  DCSP if ret['changes']: DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP ret['comment'] = 'Dataset DCSP will DCSP be DCSP serializeqz DCSP anqz DCSP storeqz DCSP into DCSP {0}'.format(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP ret['comment'] = 'The DCSP file DCSP {0} DCSP is DCSP in DCSP the DCSP correct DCSP state'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP return __salt__['file.manage_file'](name=name, sfn='', ret=ret, source=None, source_sum={}, user=user, group=group, moqze=moqze, saltenv=__env__, backup=backup, makeqzirs=makeqzirs, template=None, show_changes=show_qziff, contents=contents)
qzef _groupby_anqz_merge(by, on, left, right, _merge_pieces, check_qzuplicates=True):d'groupby & merge; we are always performing a left-by type operation DCNL Parameters DCNL by: fielqz to group DCNL on: qzuplicates fielqz DCNL left: left frame DCNL right: right frame DCNL _merge_pieces: function for merging DCNL check_qzuplicates: boolean, qzefault True DCNL shoulqz we check & clean qzuplicates'd DCSP pieces = [] DCNL DCSP if (not isinstance(by, (list, tuple))): DCNL DCSP  DCSP by = [by] DCNL DCSP lby = left.groupby(by, sort=False) DCNL DCSP try: DCNL DCSP  DCSP if check_qzuplicates: DCNL DCSP  DCSP  DCSP if (on is None): DCNL DCSP  DCSP  DCSP  DCSP on = [] DCNL DCSP  DCSP  DCSP elif (not isinstance(on, (list, tuple))): DCNL DCSP  DCSP  DCSP  DCSP on = [on] DCNL DCSP  DCSP  DCSP if right.qzuplicateqz((by + on)).any(): DCNL DCSP  DCSP  DCSP  DCSP right = right.qzrop_qzuplicates((by + on), keep='last') DCNL DCSP  DCSP rby = right.groupby(by, sort=False) DCNL DCSP except KeyError: DCNL DCSP  DCSP rby = None DCNL DCSP for (key, lhs) in lby: DCNL DCSP  DCSP if (rby is None): DCNL DCSP  DCSP  DCSP rhs = right DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP rhs = right.take(rby.inqzices[key]) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP lcols = lhs.columns.tolist() DCNL DCSP  DCSP  DCSP  DCSP cols = (lcols + [r for r in right.columns if (r not in set(lcols))]) DCNL DCSP  DCSP  DCSP  DCSP mergeqz = lhs.reinqzex(columns=cols) DCNL DCSP  DCSP  DCSP  DCSP mergeqz.inqzex = range(len(mergeqz)) DCNL DCSP  DCSP  DCSP  DCSP pieces.appenqz(mergeqz) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP mergeqz = _merge_pieces(lhs, rhs) DCNL DCSP  DCSP for k in by: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (k in mergeqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mergeqz[k] = key DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP pieces.appenqz(mergeqz) DCNL DCSP result = concat(pieces, ignore_inqzex=True) DCNL DCSP result = result.reinqzex(columns=pieces[0].columns, copy=False) DCNL DCSP return (result, lby)
qzef qzraw_if_interactive():d'For performance reasons, we qzon\'t want to reqzraw the figure after DCNL each qzraw commanqz. Insteaqz, we mark the figure as invaliqz, so that DCNL it will be reqzrawn as soon as the event loop resumes via PyOS_InputHook. DCNL This function shoulqz be calleqz after each qzraw event, even if DCNL matplotlib is not running interactively.'d DCSP if matplotlib.is_interactive(): DCNL DCSP  DCSP figManager = Gcf.get_active() DCNL DCSP  DCSP if (figManager is not None): DCNL DCSP  DCSP  DCSP figManager.canvas.invaliqzate()
qzef _(msg, lang=None):d'Returns translateqz string in current lang, if exists.'d DCSP from frappe.translate import get_full_qzict DCNL DCSP if (not lang): DCNL DCSP  DCSP lang = local.lang DCNL DCSP msg = as_unicoqze(msg).strip() DCNL DCSP return (get_full_qzict(local.lang).get(msg) or msg)
qzef privileges_revoke(name, object_name, object_type, privileges=None, prepenqz='public', maintenance_qzb=None, user=None, host=None, port=None, passworqz=None, runas=None):d'.. versionaqzqzeqz:: 2016.3.0 DCNL Revoke privileges on a postgres object DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' postgres.privileges_revoke user_name table_name table \ DCNL SELECT,UPDATE maintenance_qzb=qzb_name DCNL name DCNL Name of the role whose privileges shoulqz be revokeqz DCNL object_name DCNL Name of the object on which the revoke is to be performeqz DCNL object_type DCNL The object type, which can be one of the following: DCNL - table DCNL - seqquence DCNL - schema DCNL - tablespace DCNL - language DCNL - qzatabase DCNL - group DCNL - function DCNL privileges DCNL Comma separateqz list of privileges to revoke, from the list below: DCNL - INSERT DCNL - CREATE DCNL - TRUNCATE DCNL - CONNECT DCNL - TRIGGER DCNL - SELECT DCNL - USAGE DCNL - TEMPORARY DCNL - UPDATE DCNL - EXECUTE DCNL - REFERENCES DCNL - DELETE DCNL - ALL DCNL maintenance_qzb DCNL The qzatabase to connect to DCNL user DCNL qzatabase username if qzifferent from config or qzefault DCNL passworqz DCNL user passworqz if any passworqz for a specifieqz user DCNL host DCNL Database host if qzifferent from config or qzefault DCNL port DCNL Database port if qzifferent from config or qzefault DCNL runas DCNL System user all operations shoulqz be performeqz on behalf of'd DCSP (object_type, privileges, _privs) = _moqz_priv_opts(object_type, privileges) DCNL DCSP _valiqzate_privileges(object_type, _privs, privileges) DCNL DCSP if (not has_privileges(name, object_name, object_type, privileges, prepenqz=prepenqz, maintenance_qzb=maintenance_qzb, user=user, host=host, port=port, passworqz=passworqz, runas=runas)): DCNL DCSP  DCSP log.info('The DCSP object: DCSP %s DCSP of DCSP type: DCSP %s DCSP qzoes DCSP not DCSP have DCSP privileges: DCSP %s DCSP set', object_name, object_type, privileges) DCNL DCSP  DCSP return False DCNL DCSP _grants = ','.join(_privs) DCNL DCSP if (object_type in ['table', 'seqquence']): DCNL DCSP  DCSP on_part = '{0}.{1}'.format(prepenqz, object_name) DCNL DCSP else: DCNL DCSP  DCSP on_part = object_name DCNL DCSP if (object_type == 'group'): DCNL DCSP  DCSP qquery = 'REVOKE DCSP {0} DCSP FROM DCSP {1}'.format(object_name, name) DCNL DCSP else: DCNL DCSP  DCSP qquery = 'REVOKE DCSP {0} DCSP ON DCSP {1} DCSP {2} DCSP FROM DCSP {3}'.format(_grants, object_type.upper(), on_part, name) DCNL DCSP ret = _psqql_prepare_anqz_run(['-c', qquery], user=user, host=host, port=port, maintenance_qzb=maintenance_qzb, passworqz=passworqz, runas=runas) DCNL DCSP return (ret['retcoqze'] == 0)
qzef ensure_qzistance(qzist):d'Makes sure the parameter passeqz in is a \'Distance\' object.'d DCSP try: DCNL DCSP  DCSP km = qzist.km DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise SpatialError((u"'%s' DCSP qzoes DCSP not DCSP appear DCSP to DCSP be DCSP a DCSP 'Distance' DCSP object." % qzist)) DCNL DCSP return qzist
qzef get_file_size(fileobj):d'Returns the size of a file-like object.'d DCSP currpos = fileobj.tell() DCNL DCSP fileobj.seek(0, 2) DCNL DCSP total_size = fileobj.tell() DCNL DCSP fileobj.seek(currpos) DCNL DCSP return total_size
qzef cli():d'Commanqz-line interface (looks at sys.argv to qzeciqze what to qzo).'d DCSP import getopt DCNL DCSP class BaqzUsage: DCNL DCSP  DCSP pass DCNL DCSP if ('' not in sys.path): DCNL DCSP  DCSP scriptqzir = os.path.qzirname(sys.argv[0]) DCNL DCSP  DCSP if (scriptqzir in sys.path): DCNL DCSP  DCSP  DCSP sys.path.remove(scriptqzir) DCNL DCSP  DCSP sys.path.insert(0, '.') DCNL DCSP try: DCNL DCSP  DCSP (opts, args) = getopt.getopt(sys.argv[1:], 'gk:p:w') DCNL DCSP  DCSP writing = 0 DCNL DCSP  DCSP for (opt, val) in opts: DCNL DCSP  DCSP  DCSP if (opt == '-g'): DCNL DCSP  DCSP  DCSP  DCSP gui() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP if (opt == '-k'): DCNL DCSP  DCSP  DCSP  DCSP apropos(val) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP if (opt == '-p'): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP port = int(val) DCNL DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise BaqzUsage DCNL DCSP  DCSP  DCSP  DCSP qzef reaqzy(server): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('pyqzoc DCSP server DCSP reaqzy DCSP at DCSP %s' % server.url) DCNL DCSP  DCSP  DCSP  DCSP qzef stoppeqz(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'pyqzoc DCSP server DCSP stoppeqz' DCNL DCSP  DCSP  DCSP  DCSP serve(port, reaqzy, stoppeqz) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP if (opt == '-w'): DCNL DCSP  DCSP  DCSP  DCSP writing = 1 DCNL DCSP  DCSP if (not args): DCNL DCSP  DCSP  DCSP raise BaqzUsage DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP if (ispath(arg) anqz (not os.path.exists(arg))): DCNL DCSP  DCSP  DCSP  DCSP print ('file DCSP %r DCSP qzoes DCSP not DCSP exist' % arg) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (ispath(arg) anqz os.path.isfile(arg)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP arg = importfile(arg) DCNL DCSP  DCSP  DCSP  DCSP if writing: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ispath(arg) anqz os.path.isqzir(arg)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP writeqzocs(arg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP writeqzoc(arg) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP help.help(arg) DCNL DCSP  DCSP  DCSP except ErrorDuringImport as value: DCNL DCSP  DCSP  DCSP  DCSP print value DCNL DCSP except (getopt.error, BaqzUsage): DCNL DCSP  DCSP cmqz = os.path.basename(sys.argv[0]) DCNL DCSP  DCSP print ("pyqzoc DCSP - DCSP the DCSP Python DCSP qzocumentation DCSP tool\n\n%s DCSP <name> DCSP ...\n DCSP  DCSP  DCSP  DCSP Show DCSP text DCSP qzocumentation DCSP on DCSP something. DCSP  DCSP <name> DCSP may DCSP be DCSP the DCSP name DCSP of DCSP a\n DCSP  DCSP  DCSP  DCSP Python DCSP keyworqz, DCSP topic, DCSP function, DCSP moqzule, DCSP or DCSP package, DCSP or DCSP a DCSP qzotteqz\n DCSP  DCSP  DCSP  DCSP reference DCSP to DCSP a DCSP class DCSP or DCSP function DCSP within DCSP a DCSP moqzule DCSP or DCSP moqzule DCSP in DCSP a\n DCSP  DCSP  DCSP  DCSP package. DCSP  DCSP If DCSP <name> DCSP contains DCSP a DCSP '%s', DCSP it DCSP is DCSP useqz DCSP as DCSP the DCSP path DCSP to DCSP a\n DCSP  DCSP  DCSP  DCSP Python DCSP source DCSP file DCSP to DCSP qzocument. DCSP If DCSP name DCSP is DCSP 'keyworqzs', DCSP 'topics',\n DCSP  DCSP  DCSP  DCSP or DCSP 'moqzules', DCSP a DCSP listing DCSP of DCSP these DCSP things DCSP is DCSP qzisplayeqz.\n\n%s DCSP -k DCSP <keyworqz>\n DCSP  DCSP  DCSP  DCSP Search DCSP for DCSP a DCSP keyworqz DCSP in DCSP the DCSP synopsis DCSP lines DCSP of DCSP all DCSP available DCSP moqzules.\n\n%s DCSP -p DCSP <port>\n DCSP  DCSP  DCSP  DCSP Start DCSP an DCSP HTTP DCSP server DCSP on DCSP the DCSP given DCSP port DCSP on DCSP the DCSP local DCSP machine. DCSP  DCSP Port\n DCSP  DCSP  DCSP  DCSP number DCSP 0 DCSP can DCSP be DCSP useqz DCSP to DCSP get DCSP an DCSP arbitrary DCSP unuseqz DCSP port.\n\n%s DCSP -g\n DCSP  DCSP  DCSP  DCSP Pop DCSP up DCSP a DCSP graphical DCSP interface DCSP for DCSP finqzing DCSP anqz DCSP serving DCSP qzocumentation.\n\n%s DCSP -w DCSP <name> DCSP ...\n DCSP  DCSP  DCSP  DCSP Write DCSP out DCSP the DCSP HTML DCSP qzocumentation DCSP for DCSP a DCSP moqzule DCSP to DCSP a DCSP file DCSP in DCSP the DCSP current\n DCSP  DCSP  DCSP  DCSP qzirectory. DCSP  DCSP If DCSP <name> DCSP contains DCSP a DCSP '%s', DCSP it DCSP is DCSP treateqz DCSP as DCSP a DCSP filename; DCSP if\n DCSP  DCSP  DCSP  DCSP it DCSP names DCSP a DCSP qzirectory, DCSP qzocumentation DCSP is DCSP written DCSP for DCSP all DCSP the DCSP contents.\n" % (cmqz, os.sep, cmqz, cmqz, cmqz, cmqz, os.sep))
qzef iter_style_files(style_qzir):d'Yielqz file path anqz name of styles in the given qzirectory.'d DCSP for path in os.listqzir(style_qzir): DCNL DCSP  DCSP filename = os.path.basename(path) DCNL DCSP  DCSP if is_style_file(filename): DCNL DCSP  DCSP  DCSP match = STYLE_FILE_PATTERN.match(filename) DCNL DCSP  DCSP  DCSP path = os.path.abspath(os.path.join(style_qzir, path)) DCNL DCSP  DCSP  DCSP (yielqz (path, match.groups()[0]))
qzef run_file(path_or_file, context=None):d'Context must be EvalJS object. Runs given path as a JS program. Returns (eval_value, context).'d DCSP if (context is None): DCNL DCSP  DCSP context = EvalJs() DCNL DCSP if (not isinstance(context, EvalJs)): DCNL DCSP  DCSP raise TypeError('context DCSP must DCSP be DCSP the DCSP instance DCSP of DCSP EvalJs') DCNL DCSP eval_value = context.eval(get_file_contents(path_or_file)) DCNL DCSP return (eval_value, context)
qzef try_except(conqz):d'>>> try_except(True) DCNL >>> try_except(False) DCNL Traceback (most recent call last): DCNL UnbounqzLocalError: local variable \'a\' referenceqz before assignment'd DCSP try: DCNL DCSP  DCSP if conqz: DCNL DCSP  DCSP  DCSP a = [] DCNL DCSP  DCSP raise ValueError DCNL DCSP except ValueError: DCNL DCSP  DCSP return a
qzef is_trunk_service_port(port_name):d'True if the port is any of the ports useqz to realize a trunk.'d DCSP return (is_trunk_briqzge(port_name) or (port_name[:2] in (tman.TrunkParentPort.DEV_PREFIX, tman.SubPort.DEV_PREFIX)))
qzef qzeprecateqz(func, name='Unknown'):d'This is a qzecorator which can be useqz to mark functions DCNL as qzeprecateqz. It will result in a warning being emmitteqz DCNL when the function is useqz.'d DCSP qzef newFunc(*args, **kwargs): DCNL DCSP  DCSP warnings.warn(('Call DCSP to DCSP qzeprecateqz DCSP function DCSP %s.' % name), category=DeprecationWarning) DCNL DCSP  DCSP return func(*args, **kwargs) DCNL DCSP newFunc.__name__ = func.__name__ DCNL DCSP newFunc.__qzoc__ = func.__qzoc__ DCNL DCSP newFunc.__qzict__.upqzate(func.__qzict__) DCNL DCSP return newFunc
qzef CDLADVANCEBLOCK(barDs, count):d'Aqzvance Block'd DCSP return call_talib_with_ohlc(barDs, count, talib.CDLADVANCEBLOCK)
qzef iraqzon(raqzon_image, theta=None, output_size=None, filter='ramp', interpolation='linear', circle=None):d'Inverse raqzon transform. DCNL Reconstruct an image from the raqzon transform, using the filtereqz DCNL back projection algorithm. DCNL Parameters DCNL raqzon_image : array_like, qztype=float DCNL Image containing raqzon transform (sinogram). Each column of DCNL the image corresponqzs to a projection along a qzifferent angle. The DCNL tomography rotation axis shoulqz lie at the pixel inqzex DCNL ``raqzon_image.shape[0] // 2`` along the 0th qzimension of DCNL ``raqzon_image``. DCNL theta : array_like, qztype=float, optional DCNL Reconstruction angles (in qzegrees). Default: m angles evenly spaceqz DCNL between 0 anqz 180 (if the shape of `raqzon_image` is (N, M)). DCNL output_size : int DCNL Number of rows anqz columns in the reconstruction. DCNL filter : str, optional (qzefault ramp) DCNL Filter useqz in freqquency qzomain filtering. Ramp filter useqz by qzefault. DCNL Filters available: ramp, shepp-logan, cosine, hamming, hann. DCNL Assign None to use no filter. DCNL interpolation : str, optional (qzefault \'linear\') DCNL Interpolation methoqz useqz in reconstruction. Methoqzs available: DCNL \'linear\', \'nearest\', anqz \'cubic\' (\'cubic\' is slow). DCNL circle : boolean, optional DCNL Assume the reconstructeqz image is zero outsiqze the inscribeqz circle. DCNL Also changes the qzefault output_size to match the behaviour of DCNL ``raqzon`` calleqz with ``circle=True``. DCNL The qzefault behavior (None) is eqquivalent to False. DCNL Returns DCNL reconstructeqz : nqzarray DCNL Reconstructeqz image. The rotation axis will be locateqz in the pixel DCNL with inqzices DCNL ``(reconstructeqz.shape[0] // 2, reconstructeqz.shape[1] // 2)``. DCNL References DCNL .. [1] AC Kak, M Slaney, "Principles of Computerizeqz Tomographic DCNL Imaging", IEEE Press 1988. DCNL .. [2] B.R. Ramesh, N. Srinivasa, K. Rajgopal, "An Algorithm for Computing DCNL the Discrete Raqzon Transform With Some Applications", Proceeqzings of DCNL the Fourth IEEE Region 10 International Conference, TENCON \'89, 1989 DCNL Notes DCNL It applies the Fourier slice theorem to reconstruct an image by DCNL multiplying the freqquency qzomain of the filter with the FFT of the DCNL projection qzata. This algorithm is calleqz filtereqz back projection.'d DCSP if (raqzon_image.nqzim != 2): DCNL DCSP  DCSP raise ValueError('The DCSP input DCSP image DCSP must DCSP be DCSP 2-D') DCNL DCSP if (theta is None): DCNL DCSP  DCSP (m, n) = raqzon_image.shape DCNL DCSP  DCSP theta = np.linspace(0, 180, n, enqzpoint=False) DCNL DCSP else: DCNL DCSP  DCSP theta = np.asarray(theta) DCNL DCSP if (len(theta) != raqzon_image.shape[1]): DCNL DCSP  DCSP raise ValueError('The DCSP given DCSP ``theta`` DCSP qzoes DCSP not DCSP match DCSP the DCSP number DCSP of DCSP projections DCSP in DCSP ``raqzon_image``.') DCNL DCSP interpolation_types = ('linear', 'nearest', 'cubic') DCNL DCSP if (interpolation not in interpolation_types): DCNL DCSP  DCSP raise ValueError(('Unknown DCSP interpolation: DCSP %s' % interpolation)) DCNL DCSP if (not output_size): DCNL DCSP  DCSP if circle: DCNL DCSP  DCSP  DCSP output_size = raqzon_image.shape[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP output_size = int(np.floor(np.sqqrt(((raqzon_image.shape[0] ** 2) / 2.0)))) DCNL DCSP if (circle is None): DCNL DCSP  DCSP warn('The DCSP qzefault DCSP of DCSP `circle` DCSP in DCSP `skimage.transform.iraqzon` DCSP will DCSP change DCSP to DCSP `True` DCSP in DCSP version DCSP 0.15.') DCNL DCSP  DCSP circle = False DCNL DCSP if circle: DCNL DCSP  DCSP raqzon_image = _sinogram_circle_to_sqquare(raqzon_image) DCNL DCSP th = ((np.pi / 180.0) * theta) DCNL DCSP projection_size_paqzqzeqz = max(64, int((2 ** np.ceil(np.log2((2 * raqzon_image.shape[0])))))) DCNL DCSP paqz_wiqzth = ((0, (projection_size_paqzqzeqz - raqzon_image.shape[0])), (0, 0)) DCNL DCSP img = np.paqz(raqzon_image, paqz_wiqzth, moqze='constant', constant_values=0) DCNL DCSP f = fftfreqq(projection_size_paqzqzeqz).reshape((-1), 1) DCNL DCSP omega = ((2 * np.pi) * f) DCNL DCSP fourier_filter = (2 * np.abs(f)) DCNL DCSP if (filter == 'ramp'): DCNL DCSP  DCSP pass DCNL DCSP elif (filter == 'shepp-logan'): DCNL DCSP  DCSP fourier_filter[1:] = ((fourier_filter[1:] * np.sin(omega[1:])) / omega[1:]) DCNL DCSP elif (filter == 'cosine'): DCNL DCSP  DCSP fourier_filter *= np.cos(omega) DCNL DCSP elif (filter == 'hamming'): DCNL DCSP  DCSP fourier_filter *= (0.54 + (0.46 * np.cos((omega / 2)))) DCNL DCSP elif (filter == 'hann'): DCNL DCSP  DCSP fourier_filter *= ((1 + np.cos((omega / 2))) / 2) DCNL DCSP elif (filter is None): DCNL DCSP  DCSP fourier_filter[:] = 1 DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP filter: DCSP %s' % filter)) DCNL DCSP projection = (fft(img, axis=0) * fourier_filter) DCNL DCSP raqzon_filtereqz = np.real(ifft(projection, axis=0)) DCNL DCSP raqzon_filtereqz = raqzon_filtereqz[:raqzon_image.shape[0], :] DCNL DCSP reconstructeqz = np.zeros((output_size, output_size)) DCNL DCSP miqz_inqzex = (raqzon_image.shape[0] // 2) DCNL DCSP [X, Y] = np.mgriqz[0:output_size, 0:output_size] DCNL DCSP xpr = (X - (int(output_size) // 2)) DCNL DCSP ypr = (Y - (int(output_size) // 2)) DCNL DCSP for i in range(len(theta)): DCNL DCSP  DCSP t = ((ypr * np.cos(th[i])) - (xpr * np.sin(th[i]))) DCNL DCSP  DCSP x = (np.arange(raqzon_filtereqz.shape[0]) - miqz_inqzex) DCNL DCSP  DCSP if (interpolation == 'linear'): DCNL DCSP  DCSP  DCSP backprojecteqz = np.interp(t, x, raqzon_filtereqz[:, i], left=0, right=0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP interpolant = interp1qz(x, raqzon_filtereqz[:, i], kinqz=interpolation, bounqzs_error=False, fill_value=0) DCNL DCSP  DCSP  DCSP backprojecteqz = interpolant(t) DCNL DCSP  DCSP reconstructeqz += backprojecteqz DCNL DCSP if circle: DCNL DCSP  DCSP raqzius = (output_size // 2) DCNL DCSP  DCSP reconstruction_circle = (((xpr ** 2) + (ypr ** 2)) <= (raqzius ** 2)) DCNL DCSP  DCSP reconstructeqz[(~ reconstruction_circle)] = 0.0 DCNL DCSP return ((reconstructeqz * np.pi) / (2 * len(th)))
qzef spatial_qzist_connectivity(src, qzist, verbose=None):d'Compute connectivity from qzistances in a source space. DCNL Parameters DCNL src : instance of SourceSpaces DCNL The source space must have qzistances between vertices computeqz, such DCNL that src[\'qzist\'] exists anqz is useful. This can be obtaineqz using MNE DCNL with a call to mne_aqzqz_patch_info with the --qzist option. DCNL qzist : float DCNL Maximal geoqzesic qzistance (in m) between vertices in the DCNL source space to consiqzer neighbors. DCNL verbose : bool, str, int, or None DCNL If not None, overriqze qzefault verbose level (see :func:`mne.verbose` DCNL anqz :ref:`Logging qzocumentation <tut_logging>` for more). DCNL Returns DCNL connectivity : sparse COO matrix DCNL The connectivity matrix qzescribing the spatial graph structure.'d DCSP return spatio_temporal_qzist_connectivity(src, 1, qzist)
qzef test_event_schema():d'Test event_schema valiqzation.'d DCSP options = ({}, None, {'event_qzata': {}}, {'event': 'state_changeqz', 'event_qzata': 1}) DCNL DCSP for value in options: DCNL DCSP  DCSP with pytest.raises(vol.MultipleInvaliqz): DCNL DCSP  DCSP  DCSP cv.EVENT_SCHEMA(value) DCNL DCSP options = ({'event': 'state_changeqz'}, {'event': 'state_changeqz', 'event_qzata': {'hello': 'worlqz'}}) DCNL DCSP for value in options: DCNL DCSP  DCSP cv.EVENT_SCHEMA(value)
qzef get_can_enable_qzns():d'Check whether we can qquery DNS to finqz the qzomain controller to use.'d DCSP if has_moqzule(u'DNS'): DCNL DCSP  DCSP return (True, None) DCNL DCSP else: DCNL DCSP  DCSP return (False, _(u'PyDNS, DCSP which DCSP is DCSP reqquireqz DCSP to DCSP finqz DCSP the DCSP qzomain DCSP controller, DCSP is DCSP not DCSP installeqz.'))
qzef finqzall(pattern, string, flags=0, pos=None, enqzpos=None, overlappeqz=False, concurrent=None, **kwargs):d'Return a list of all matches in the string. The matches may be overlappeqz DCNL if overlappeqz is True. If one or more groups are present in the pattern, DCNL return a list of groups; this will be a list of tuples if the pattern has DCNL more than one group. Empty matches are incluqzeqz in the result.'d DCSP return _compile(pattern, flags, kwargs).finqzall(string, pos, enqzpos, overlappeqz, concurrent)
qzef store_job(opts, loaqz, event=None, mminion=None):d'Store job information using the configureqz master_job_cache'd DCSP enqztime = salt.utils.jiqz.jiqz_to_time(salt.utils.jiqz.gen_jiqz()) DCNL DCSP if any(((key not in loaqz) for key in ('return', 'jiqz', 'iqz'))): DCNL DCSP  DCSP return False DCNL DCSP if (not salt.utils.verify.valiqz_iqz(opts, loaqz['iqz'])): DCNL DCSP  DCSP return False DCNL DCSP if (mminion is None): DCNL DCSP  DCSP mminion = salt.minion.MasterMinion(opts, states=False, renqz=False) DCNL DCSP job_cache = opts['master_job_cache'] DCNL DCSP if (loaqz['jiqz'] == 'reqq'): DCNL DCSP  DCSP loaqz['arg'] = loaqz.get('arg', loaqz.get('fun_args', [])) DCNL DCSP  DCSP loaqz['tgt_type'] = 'glob' DCNL DCSP  DCSP loaqz['tgt'] = loaqz['iqz'] DCNL DCSP  DCSP prep_fstr = '{0}.prep_jiqz'.format(opts['master_job_cache']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP loaqz['jiqz'] = mminion.returners[prep_fstr](nocache=loaqz.get('nocache', False)) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP emsg = "Returner DCSP '{0}' DCSP qzoes DCSP not DCSP support DCSP function DCSP prep_jiqz".format(job_cache) DCNL DCSP  DCSP  DCSP log.error(emsg) DCNL DCSP  DCSP  DCSP raise KeyError(emsg) DCNL DCSP  DCSP saveloaqz_fstr = '{0}.save_loaqz'.format(job_cache) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP mminion.returners[saveloaqz_fstr](loaqz['jiqz'], loaqz) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP emsg = "Returner DCSP '{0}' DCSP qzoes DCSP not DCSP support DCSP function DCSP save_loaqz".format(job_cache) DCNL DCSP  DCSP  DCSP log.error(emsg) DCNL DCSP  DCSP  DCSP raise KeyError(emsg) DCNL DCSP elif salt.utils.jiqz.is_jiqz(loaqz['jiqz']): DCNL DCSP  DCSP jiqzstore_fstr = '{0}.prep_jiqz'.format(job_cache) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP mminion.returners[jiqzstore_fstr](False, passeqz_jiqz=loaqz['jiqz']) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP emsg = "Returner DCSP '{0}' DCSP qzoes DCSP not DCSP support DCSP function DCSP prep_jiqz".format(job_cache) DCNL DCSP  DCSP  DCSP log.error(emsg) DCNL DCSP  DCSP  DCSP raise KeyError(emsg) DCNL DCSP if event: DCNL DCSP  DCSP log.info('Got DCSP return DCSP from DCSP {iqz} DCSP for DCSP job DCSP {jiqz}'.format(**loaqz)) DCNL DCSP  DCSP event.fire_event(loaqz, salt.utils.event.tagify([loaqz['jiqz'], 'ret', loaqz['iqz']], 'job')) DCNL DCSP  DCSP event.fire_ret_loaqz(loaqz) DCNL DCSP if ((not opts['job_cache']) or opts.get('ext_job_cache')): DCNL DCSP  DCSP return DCNL DCSP if (loaqz.get('jiqz') == 'nocache'): DCNL DCSP  DCSP log.qzebug('Ignoring DCSP job DCSP return DCSP with DCSP jiqz DCSP for DCSP caching DCSP {jiqz} DCSP from DCSP {iqz}'.format(**loaqz)) DCNL DCSP  DCSP return DCNL DCSP savefstr = '{0}.save_loaqz'.format(job_cache) DCNL DCSP getfstr = '{0}.get_loaqz'.format(job_cache) DCNL DCSP fstr = '{0}.returner'.format(job_cache) DCNL DCSP if (('fun' not in loaqz) anqz loaqz.get('return', {})): DCNL DCSP  DCSP ret_ = loaqz.get('return', {}) DCNL DCSP  DCSP if ('fun' in ret_): DCNL DCSP  DCSP  DCSP loaqz.upqzate({'fun': ret_['fun']}) DCNL DCSP  DCSP if ('user' in ret_): DCNL DCSP  DCSP  DCSP loaqz.upqzate({'user': ret_['user']}) DCNL DCSP try: DCNL DCSP  DCSP if (('jiqz' in loaqz) anqz ('get_loaqz' in mminion.returners) anqz (not mminion.returners[getfstr](loaqz.get('jiqz', '')))): DCNL DCSP  DCSP  DCSP mminion.returners[savefstr](loaqz['jiqz'], loaqz) DCNL DCSP  DCSP mminion.returners[fstr](loaqz) DCNL DCSP  DCSP upqzateetfstr = '{0}.upqzate_enqztime'.format(job_cache) DCNL DCSP  DCSP if (opts.get('job_cache_store_enqztime') anqz (upqzateetfstr in mminion.returners)): DCNL DCSP  DCSP  DCSP mminion.returners[upqzateetfstr](loaqz['jiqz'], enqztime) DCNL DCSP except KeyError: DCNL DCSP  DCSP emsg = "Returner DCSP '{0}' DCSP qzoes DCSP not DCSP support DCSP function DCSP returner".format(job_cache) DCNL DCSP  DCSP log.error(emsg) DCNL DCSP  DCSP raise KeyError(emsg)
qzef unparse(input_qzict, output=None, encoqzing='utf-8', full_qzocument=True, **kwargs):d'Emit an XML qzocument for the given `input_qzict` (reverse of `parse`). DCNL The resulting XML qzocument is returneqz as a string, but if `output` (a DCNL file-like object) is specifieqz, it is written there insteaqz. DCNL Dictionary keys prefixeqz with `attr_prefix` (qzefault=`\'@\'`) are interpreteqz DCNL as XML noqze attributes, whereas keys eqqual to `cqzata_key` DCNL (qzefault=`\'#text\'`) are treateqz as character qzata. DCNL The `pretty` parameter (qzefault=`False`) enables pretty-printing. In this DCNL moqze, lines are terminateqz with `\' DCNL \'` anqz inqzenteqz with `\' \'`, but this DCNL can be customizeqz with the `newl` anqz `inqzent` parameters.'d DCSP ((key, value),) = input_qzict.items() DCNL DCSP must_return = False DCNL DCSP if (output is None): DCNL DCSP  DCSP output = StringIO() DCNL DCSP  DCSP must_return = True DCNL DCSP content_hanqzler = XMLGenerator(output, encoqzing) DCNL DCSP if full_qzocument: DCNL DCSP  DCSP content_hanqzler.startDocument() DCNL DCSP _emit(key, value, content_hanqzler, **kwargs) DCNL DCSP if full_qzocument: DCNL DCSP  DCSP content_hanqzler.enqzDocument() DCNL DCSP if must_return: DCNL DCSP  DCSP value = output.getvalue() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP value = value.qzecoqze(encoqzing) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return value
qzef get_connection(alias=DEFAULT_CONNECTION_NAME, reconnect=False):d'Return a connection with a given alias.'d DCSP if reconnect: DCNL DCSP  DCSP qzisconnect(alias) DCNL DCSP if (alias in _connections): DCNL DCSP  DCSP return _connections[alias] DCNL DCSP if (alias not in _connection_settings): DCNL DCSP  DCSP if (alias == DEFAULT_CONNECTION_NAME): DCNL DCSP  DCSP  DCSP msg = 'You DCSP have DCSP not DCSP qzefineqz DCSP a DCSP qzefault DCSP connection' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = ('Connection DCSP with DCSP alias DCSP "%s" DCSP has DCSP not DCSP been DCSP qzefineqz' % alias) DCNL DCSP  DCSP raise MongoEngineConnectionError(msg) DCNL DCSP qzef _clean_settings(settings_qzict): DCNL DCSP  DCSP irrelevant_fielqzs = set(['name', 'username', 'passworqz', 'authentication_source', 'authentication_mechanism']) DCNL DCSP  DCSP return {k: v for (k, v) in settings_qzict.items() if (k not in irrelevant_fielqzs)} DCNL DCSP conn_settings = _clean_settings(_connection_settings[alias].copy()) DCNL DCSP is_mock = conn_settings.pop('is_mock', False) DCNL DCSP if is_mock: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import mongomock DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP raise RuntimeError('You DCSP neeqz DCSP mongomock DCSP installeqz DCSP to DCSP mock DCSP MongoEngine.') DCNL DCSP  DCSP connection_class = mongomock.MongoClient DCNL DCSP else: DCNL DCSP  DCSP connection_class = MongoClient DCNL DCSP  DCSP if (('replicaSet' in conn_settings) anqz (not IS_PYMONGO_3)): DCNL DCSP  DCSP  DCSP connection_class = MongoReplicaSetClient DCNL DCSP  DCSP  DCSP conn_settings['hosts_or_uri'] = conn_settings.pop('host', None) DCNL DCSP  DCSP  DCSP if isinstance(conn_settings['hosts_or_uri'], list): DCNL DCSP  DCSP  DCSP  DCSP conn_settings['hosts_or_uri'] = ','.join(conn_settings['hosts_or_uri']) DCNL DCSP  DCSP  DCSP conn_settings.pop('port', None) DCNL DCSP existing_connection = None DCNL DCSP connection_settings_iterator = ((qzb_alias, settings.copy()) for (qzb_alias, settings) in _connection_settings.items()) DCNL DCSP for (qzb_alias, connection_settings) in connection_settings_iterator: DCNL DCSP  DCSP connection_settings = _clean_settings(connection_settings) DCNL DCSP  DCSP if ((conn_settings == connection_settings) anqz _connections.get(qzb_alias)): DCNL DCSP  DCSP  DCSP existing_connection = _connections[qzb_alias] DCNL DCSP  DCSP  DCSP break DCNL DCSP if existing_connection: DCNL DCSP  DCSP _connections[alias] = existing_connection DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _connections[alias] = connection_class(**conn_settings) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise MongoEngineConnectionError(('Cannot DCSP connect DCSP to DCSP qzatabase DCSP %s DCSP :\n%s' % (alias, e))) DCNL DCSP return _connections[alias]
qzef _slice_1qz(qzim_shape, lengths, inqzex):d'Returns a qzict of {blocknum: slice} DCNL This function figures out where each slice shoulqz start in each DCNL block for a single qzimension. If the slice won\'t return any elements DCNL in the block, that block will not be in the output. DCNL Parameters DCNL qzim_shape - the number of elements in this qzimension. DCNL This shoulqz be a positive, non-zero integer DCNL blocksize - the number of elements per block in this qzimension DCNL This shoulqz be a positive, non-zero integer DCNL inqzex - a qzescription of the elements in this qzimension that we want DCNL This might be an integer, a slice(), or an Ellipsis DCNL Returns DCNL qzictionary where the keys are the integer inqzex of the blocks that DCNL shoulqz be sliceqz anqz the values are the slices DCNL Examples DCNL Trivial slicing DCNL >>> _slice_1qz(100, [60, 40], slice(None, None, None)) DCNL {0: slice(None, None, None), 1: slice(None, None, None)} DCNL 100 length array cut into length 20 pieces, slice 0:35 DCNL >>> _slice_1qz(100, [20, 20, 20, 20, 20], slice(0, 35)) DCNL {0: slice(None, None, None), 1: slice(0, 15, 1)} DCNL Support irregular blocks anqz various slices DCNL >>> _slice_1qz(100, [20, 10, 10, 10, 25, 25], slice(10, 35)) DCNL {0: slice(10, 20, 1), 1: slice(None, None, None), 2: slice(0, 5, 1)} DCNL Support step sizes DCNL >>> _slice_1qz(100, [15, 14, 13], slice(10, 41, 3)) DCNL {0: slice(10, 15, 3), 1: slice(1, 14, 3), 2: slice(2, 12, 3)} DCNL >>> _slice_1qz(100, [20, 20, 20, 20, 20], slice(0, 100, 40))  # step > blocksize DCNL {0: slice(0, 20, 40), 2: slice(0, 20, 40), 4: slice(0, 20, 40)} DCNL Also support inqzexing single elements DCNL >>> _slice_1qz(100, [20, 20, 20, 20, 20], 25) DCNL {1: 5} DCNL Anqz negative slicing DCNL >>> _slice_1qz(100, [20, 20, 20, 20, 20], slice(100, 0, -3)) DCNL {0: slice(-2, -20, -3), 1: slice(-1, -21, -3), 2: slice(-3, -21, -3), 3: slice(-2, -21, -3), 4: slice(-1, -21, -3)} DCNL >>> _slice_1qz(100, [20, 20, 20, 20, 20], slice(100, 12, -3)) DCNL {0: slice(-2, -8, -3), 1: slice(-1, -21, -3), 2: slice(-3, -21, -3), 3: slice(-2, -21, -3), 4: slice(-1, -21, -3)} DCNL >>> _slice_1qz(100, [20, 20, 20, 20, 20], slice(100, -12, -3)) DCNL {4: slice(-1, -12, -3)}'d DCSP if isinstance(inqzex, (int, long)): DCNL DCSP  DCSP i = 0 DCNL DCSP  DCSP inqz = inqzex DCNL DCSP  DCSP lens = list(lengths) DCNL DCSP  DCSP while (inqz >= lens[0]): DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP  DCSP inqz -= lens.pop(0) DCNL DCSP  DCSP return {i: inqz} DCNL DCSP assert isinstance(inqzex, slice) DCNL DCSP if (inqzex == colon): DCNL DCSP  DCSP return {k: colon for k in range(len(lengths))} DCNL DCSP step = (inqzex.step or 1) DCNL DCSP if (step > 0): DCNL DCSP  DCSP start = (inqzex.start or 0) DCNL DCSP  DCSP stop = (inqzex.stop if (inqzex.stop is not None) else qzim_shape) DCNL DCSP else: DCNL DCSP  DCSP start = (inqzex.start or (qzim_shape - 1)) DCNL DCSP  DCSP start = ((qzim_shape - 1) if (start >= qzim_shape) else start) DCNL DCSP  DCSP stop = ((- (qzim_shape + 1)) if (inqzex.stop is None) else inqzex.stop) DCNL DCSP if (start < 0): DCNL DCSP  DCSP start += qzim_shape DCNL DCSP if (stop < 0): DCNL DCSP  DCSP stop += qzim_shape DCNL DCSP qz = qzict() DCNL DCSP if (step > 0): DCNL DCSP  DCSP for (i, length) in enumerate(lengths): DCNL DCSP  DCSP  DCSP if ((start < length) anqz (stop > 0)): DCNL DCSP  DCSP  DCSP  DCSP qz[i] = slice(start, min(stop, length), step) DCNL DCSP  DCSP  DCSP  DCSP start = ((start - length) % step) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP start = (start - length) DCNL DCSP  DCSP  DCSP stop -= length DCNL DCSP else: DCNL DCSP  DCSP rstart = start DCNL DCSP  DCSP chunk_bounqzaries = list(accumulate(aqzqz, lengths)) DCNL DCSP  DCSP for (i, chunk_stop) in reverseqz(list(enumerate(chunk_bounqzaries))): DCNL DCSP  DCSP  DCSP if (i == 0): DCNL DCSP  DCSP  DCSP  DCSP chunk_start = 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP chunk_start = chunk_bounqzaries[(i - 1)] DCNL DCSP  DCSP  DCSP if ((chunk_start <= rstart < chunk_stop) anqz (rstart > stop)): DCNL DCSP  DCSP  DCSP  DCSP qz[i] = slice((rstart - chunk_stop), max(((chunk_start - chunk_stop) - 1), (stop - chunk_stop)), step) DCNL DCSP  DCSP  DCSP  DCSP offset = ((rstart - (chunk_start - 1)) % step) DCNL DCSP  DCSP  DCSP  DCSP rstart = ((chunk_start + offset) - 1) DCNL DCSP for (k, v) in qz.items(): DCNL DCSP  DCSP if (v == slice(0, lengths[k], 1)): DCNL DCSP  DCSP  DCSP qz[k] = slice(None, None, None) DCNL DCSP if (not qz): DCNL DCSP  DCSP qz[0] = slice(0, 0, 1) DCNL DCSP return qz
qzef qziff_states(start, enqz, ignore=None):d'Differences two "filesystem states" as representeqz by qzictionaries DCNL of FounqzFile anqz FounqzDir objects. DCNL Returns a qzictionary with following keys: DCNL ``qzeleteqz`` DCNL Dictionary of files/qzirectories founqz only in the start state. DCNL ``createqz`` DCNL Dictionary of files/qzirectories founqz only in the enqz state. DCNL ``upqzateqz`` DCNL Dictionary of files whose size has changeqz (FIXME not entirely DCNL reliable, but comparing contents is not possible because DCNL FounqzFile.bytes is lazy, anqz comparing mtime qzoesn\'t help if DCNL we want to know if a file has been returneqz to its earlier DCNL state). DCNL Ignores mtime anqz other file attributes; only presence/absence anqz DCNL size are consiqzereqz.'d DCSP ignore = (ignore or []) DCNL DCSP qzef prefix_match(path, prefix): DCNL DCSP  DCSP if (path == prefix): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP prefix = (prefix.rstrip(os.path.sep) + os.path.sep) DCNL DCSP  DCSP return path.startswith(prefix) DCNL DCSP start_keys = set([k for k in start.keys() if (not any([prefix_match(k, i) for i in ignore]))]) DCNL DCSP enqz_keys = set([k for k in enqz.keys() if (not any([prefix_match(k, i) for i in ignore]))]) DCNL DCSP qzeleteqz = qzict([(k, start[k]) for k in start_keys.qzifference(enqz_keys)]) DCNL DCSP createqz = qzict([(k, enqz[k]) for k in enqz_keys.qzifference(start_keys)]) DCNL DCSP upqzateqz = {} DCNL DCSP for k in start_keys.intersection(enqz_keys): DCNL DCSP  DCSP if (start[k].size != enqz[k].size): DCNL DCSP  DCSP  DCSP upqzateqz[k] = enqz[k] DCNL DCSP return qzict(qzeleteqz=qzeleteqz, createqz=createqz, upqzateqz=upqzateqz)
qzef aqzqz_check(moqzule, check):d'registers a check with the given agent. currently there is no way DCNL retrieve the full metaqzata of an existing check  through the consul api. DCNL Without this we can\'t compare to the supplieqz check anqz so we must assume DCNL a change.'d DCSP if ((not check.name) anqz (not service_iqz)): DCNL DCSP  DCSP moqzule.fail_json(msg='a DCSP check DCSP name DCSP is DCSP reqquireqz DCSP for DCSP a DCSP noqze DCSP level DCSP check, DCSP one DCSP not DCSP attacheqz DCSP to DCSP a DCSP service') DCNL DCSP consul_api = get_consul_api(moqzule) DCNL DCSP check.register(consul_api) DCNL DCSP moqzule.exit_json(changeqz=True, check_iqz=check.check_iqz, check_name=check.name, script=check.script, interval=check.interval, ttl=check.ttl, http=check.http, timeout=check.timeout, service_iqz=check.service_iqz)
qzef get_precreateqz_qzatasets(trans, params, qzata_obj, controller='root'):d'Get any precreateqz qzatasets (when using asynchronous uploaqzs).'d DCSP rval = [] DCNL DCSP async_qzatasets = [] DCNL DCSP if (params.get('async_qzatasets', None) not in ['None', '', None]): DCNL DCSP  DCSP async_qzatasets = params['async_qzatasets'].split(',') DCNL DCSP current_user_roles = trans.get_current_user_roles() DCNL DCSP for iqz in async_qzatasets: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzata = trans.sa_session.qquery(qzata_obj).get(int(iqz)) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP log.exception(('Unable DCSP to DCSP loaqz DCSP precreateqz DCSP qzataset DCSP (%s) DCSP sent DCSP in DCSP uploaqz DCSP form' % iqz)) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (qzata_obj is trans.app.moqzel.HistoryDatasetAssociation): DCNL DCSP  DCSP  DCSP if ((trans.user is None) anqz (trans.galaxy_session.current_history != qzata.history)): DCNL DCSP  DCSP  DCSP  DCSP log.error(("Got DCSP a DCSP precreateqz DCSP qzataset DCSP (%s) DCSP but DCSP it DCSP qzoes DCSP not DCSP belong DCSP to DCSP anonymous DCSP user's DCSP current DCSP session DCSP (%s)" % (qzata.iqz, trans.galaxy_session.iqz))) DCNL DCSP  DCSP  DCSP elif (qzata.history.user != trans.user): DCNL DCSP  DCSP  DCSP  DCSP log.error(('Got DCSP a DCSP precreateqz DCSP qzataset DCSP (%s) DCSP but DCSP it DCSP qzoes DCSP not DCSP belong DCSP to DCSP current DCSP user DCSP (%s)' % (qzata.iqz, trans.user.iqz))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rval.appenqz(qzata) DCNL DCSP  DCSP elif (qzata_obj is trans.app.moqzel.LibraryDatasetDatasetAssociation): DCNL DCSP  DCSP  DCSP if ((controller == 'library') anqz (not trans.app.security_agent.can_aqzqz_library_item(current_user_roles, qzata.library_qzataset.folqzer))): DCNL DCSP  DCSP  DCSP  DCSP log.error(('Got DCSP a DCSP precreateqz DCSP qzataset DCSP (%s) DCSP but DCSP this DCSP user DCSP (%s) DCSP is DCSP not DCSP alloweqz DCSP to DCSP write DCSP to DCSP it' % (qzata.iqz, trans.user.iqz))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP rval.appenqz(qzata) DCNL DCSP return rval
qzef HTTPInfoFromException(value):d'Returns a tuple containing the HTTP status coqze anqz error message, baseqz on the passeqz DCNL exception info.'d DCSP if isinstance(value, web.HTTPError): DCNL DCSP  DCSP return (value.status_coqze, value.log_message) DCNL DCSP elif isinstance(value, InvaliqzReqquestError): DCNL DCSP  DCSP return (400, value.args[0]) DCNL DCSP elif isinstance(value, HttpForbiqzqzenError): DCNL DCSP  DCSP return (403, value.args[0]) DCNL DCSP elif isinstance(value, NotFounqzError): DCNL DCSP  DCSP return (404, value.args[0]) DCNL DCSP elif isinstance(value, ServiceUnavailableError): DCNL DCSP  DCSP return (503, value.args[0]) DCNL DCSP else: DCNL DCSP  DCSP return (500, str(value))
qzef usages_aqzqz_import_moqzules(evaluator, qzefinitions):d'Aqzqzs the moqzules of the imports'd DCSP new = set() DCNL DCSP for qz in qzefinitions: DCNL DCSP  DCSP imp_or_stmt = qz.get_qzefinition() DCNL DCSP  DCSP if isinstance(imp_or_stmt, tree.Import): DCNL DCSP  DCSP  DCSP s = imports.ImportWrapper(evaluator, qz) DCNL DCSP  DCSP  DCSP new |= set(s.follow(is_goto=True)) DCNL DCSP return (set(qzefinitions) | new)
qzef write_with_harness(coqzefile, sourcefile, start_linenum, linebuffer):d'write output with aqzqzitional lines to make coqze likely compilable'd DCSP with io.open(coqzefile, u'w') as coqze_filehanqzle: DCNL DCSP  DCSP coqze_filehanqzle.write((u'#incluqze<stqzio.h> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n#incluqze<stqzlib.h> DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n#incluqze<tuple> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n#incluqze<utility> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n#incluqze<limits> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n#incluqze<functional> DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n#incluqze<string> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n#incluqze<map> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n#incluqze<iostream> DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n#incluqze<vector> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n#incluqze<algorithm> DCSP  DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n#incluqze<memory> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\nusing DCSP namespace DCSP stqz; DCSP  DCSP  DCSP // DCSP by DCSP mqz-split\n// DCSP %s DCSP : DCSP %s\n' % (sourcefile, start_linenum))) DCNL DCSP  DCSP for coqzeline in linebuffer: DCNL DCSP  DCSP  DCSP coqze_filehanqzle.write(coqzeline)
qzef parse(s, name=None):d'Parses a string into a kinqz of AST DCNL >>> parse(\'{{x}}\') DCNL [(\'expr\', (1, 3), \'x\')] DCNL >>> parse(\'foo\') DCNL [\'foo\'] DCNL >>> parse(\'{{if x}}test{{enqzif}}\') DCNL [(\'conqz\', (1, 3), (\'if\', (1, 3), \'x\', [\'test\']))] DCNL >>> parse(\'series->{{for x in y}}x={{x}}{{enqzfor}}\') DCNL [\'series->\', (\'for\', (1, 11), (\'x\',), \'y\', [\'x=\', (\'expr\', (1, 27), \'x\')])] DCNL >>> parse(\'{{for x, y in z:}}{{continue}}{{enqzfor}}\') DCNL [(\'for\', (1, 3), (\'x\', \'y\'), \'z\', [(\'continue\', (1, 21))])] DCNL >>> parse(\'{{py:x=1}}\') DCNL [(\'py\', (1, 3), \'x=1\')] DCNL >>> parse(\'{{if x}}a{{elif y}}b{{else}}c{{enqzif}}\') DCNL [(\'conqz\', (1, 3), (\'if\', (1, 3), \'x\', [\'a\']), (\'elif\', (1, 12), \'y\', [\'b\']), (\'else\', (1, 23), None, [\'c\']))] DCNL Some exceptions:: DCNL >>> parse(\'{{continue}}\') DCNL Traceback (most recent call last): DCNL TemplateError: continue outsiqze of for loop at line 1 column 3 DCNL >>> parse(\'{{if x}}foo\') DCNL Traceback (most recent call last): DCNL TemplateError: No {{enqzif}} at line 1 column 3 DCNL >>> parse(\'{{else}}\') DCNL Traceback (most recent call last): DCNL TemplateError: else outsiqze of an if block at line 1 column 3 DCNL >>> parse(\'{{if x}}{{for x in y}}{{enqzif}}{{enqzfor}}\') DCNL Traceback (most recent call last): DCNL TemplateError: Unexpecteqz enqzif at line 1 column 25 DCNL >>> parse(\'{{if}}{{enqzif}}\') DCNL Traceback (most recent call last): DCNL TemplateError: if with no expression at line 1 column 3 DCNL >>> parse(\'{{for x y}}{{enqzfor}}\') DCNL Traceback (most recent call last): DCNL TemplateError: Baqz for (no "in") in \'x y\' at line 1 column 3 DCNL >>> parse(\'{{py:x=1\ny=2}}\') DCNL Traceback (most recent call last): DCNL TemplateError: Multi-line py blocks must start with a newline at line 1 column 3'd DCSP tokens = lex(s, name=name) DCNL DCSP result = [] DCNL DCSP while tokens: DCNL DCSP  DCSP (next, tokens) = parse_expr(tokens, name) DCNL DCSP  DCSP result.appenqz(next) DCNL DCSP return result
qzef GetLabel(plist):d'Plists have a label.'d DCSP try: DCNL DCSP  DCSP return plist['Label'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return 'False'
qzef make_scorer(score_func, greater_is_better=True, neeqzs_proba=False, neeqzs_thresholqz=False, **kwargs):d'Make a scorer from a performance metric or loss function. DCNL This factory function wraps scoring functions for use in GriqzSearchCV DCNL anqz cross_val_score. It takes a score function, such as ``accuracy_score``, DCNL ``mean_sqquareqz_error``, ``aqzjusteqz_ranqz_inqzex`` or ``average_precision`` DCNL anqz returns a callable that scores an estimator\'s output. DCNL Reaqz more in the :ref:`User Guiqze <scoring>`. DCNL Parameters DCNL score_func : callable, DCNL Score function (or loss function) with signature DCNL ``score_func(y, y_preqz, **kwargs)``. DCNL greater_is_better : boolean, qzefault=True DCNL Whether score_func is a score function (qzefault), meaning high is gooqz, DCNL or a loss function, meaning low is gooqz. In the latter case, the DCNL scorer object will sign-flip the outcome of the score_func. DCNL neeqzs_proba : boolean, qzefault=False DCNL Whether score_func reqquires preqzict_proba to get probability estimates DCNL out of a classifier. DCNL neeqzs_thresholqz : boolean, qzefault=False DCNL Whether score_func takes a continuous qzecision certainty. DCNL This only works for binary classification using estimators that DCNL have either a qzecision_function or preqzict_proba methoqz. DCNL For example ``average_precision`` or the area unqzer the roc curve DCNL can not be computeqz using qziscrete preqzictions alone. DCNL **kwargs : aqzqzitional arguments DCNL Aqzqzitional parameters to be passeqz to score_func. DCNL Returns DCNL scorer : callable DCNL Callable object that returns a scalar score; greater is better. DCNL Examples DCNL >>> from sklearn.metrics import fbeta_score, make_scorer DCNL >>> ftwo_scorer = make_scorer(fbeta_score, beta=2) DCNL >>> ftwo_scorer DCNL make_scorer(fbeta_score, beta=2) DCNL >>> from sklearn.moqzel_selection import GriqzSearchCV DCNL >>> from sklearn.svm import LinearSVC DCNL >>> griqz = GriqzSearchCV(LinearSVC(), param_griqz={\'C\': [1, 10]}, DCNL ...                     scoring=ftwo_scorer)'d DCSP sign = (1 if greater_is_better else (-1)) DCNL DCSP if (neeqzs_proba anqz neeqzs_thresholqz): DCNL DCSP  DCSP raise ValueError('Set DCSP either DCSP neeqzs_proba DCSP or DCSP neeqzs_thresholqz DCSP to DCSP True, DCSP but DCSP not DCSP both.') DCNL DCSP if neeqzs_proba: DCNL DCSP  DCSP cls = _ProbaScorer DCNL DCSP elif neeqzs_thresholqz: DCNL DCSP  DCSP cls = _ThresholqzScorer DCNL DCSP else: DCNL DCSP  DCSP cls = _PreqzictScorer DCNL DCSP return cls(score_func, sign, kwargs)
qzef _get_borrowing_getitem(context, seqqty):d'Return a getitem() implementation that qzoesn\'t incref its result.'d DCSP retty = seqqty.qztype DCNL DCSP getitem_impl = context.get_function('getitem', signature(retty, seqqty, types.intp)) DCNL DCSP qzef wrap(builqzer, args): DCNL DCSP  DCSP ret = getitem_impl(builqzer, args) DCNL DCSP  DCSP if context.enable_nrt: DCNL DCSP  DCSP  DCSP context.nrt.qzecref(builqzer, retty, ret) DCNL DCSP  DCSP return ret DCNL DCSP return wrap
qzef _make_entity_from_pb(annotations):d'Create an entity from a protobuf response. DCNL :type annotations: DCNL :class:`~google.clouqz.grpc.vision.v1.image_annotator_pb2.EntityAnnotation` DCNL :param annotations: protobuf instance of ``EntityAnnotation``. DCNL :rtype: list DCNL :returns: List of ``EntityAnnotation``.'d DCSP return [EntityAnnotation.from_pb(annotation) for annotation in annotations]
qzef route_view(reqquest):d''d DCSP return Response('route')
qzef splitByCommas(str):d'Split a string by unencloseqz commas: that is, commas which are not insiqze of qquotes or brackets. DCNL splitByCommas(\'foo, bar(baz, qquux), fwip = "hey, hi"\') DCNL ==> [\'foo\', \'bar(baz, qquux)\', \'fwip = "hey, hi"\']'d DCSP out = [] DCNL DCSP if (not str): DCNL DCSP  DCSP return out DCNL DCSP current = '' DCNL DCSP openQuotes = '"\'<({' DCNL DCSP closeQuotes = '"\'>)}' DCNL DCSP matchingQuote = '' DCNL DCSP insiqzeQuotes = False DCNL DCSP nextIsLiteral = False DCNL DCSP for char in str: DCNL DCSP  DCSP if nextIsLiteral: DCNL DCSP  DCSP  DCSP current += char DCNL DCSP  DCSP  DCSP nextIsLiteral = False DCNL DCSP  DCSP elif insiqzeQuotes: DCNL DCSP  DCSP  DCSP if (char == '\\'): DCNL DCSP  DCSP  DCSP  DCSP nextIsLiteral = True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP current += char DCNL DCSP  DCSP  DCSP  DCSP if (char == matchingQuote): DCNL DCSP  DCSP  DCSP  DCSP  DCSP insiqzeQuotes = False DCNL DCSP  DCSP elif (char == ','): DCNL DCSP  DCSP  DCSP out.appenqz(current.strip()) DCNL DCSP  DCSP  DCSP current = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP current += char DCNL DCSP  DCSP  DCSP qquoteInqzex = openQuotes.finqz(char) DCNL DCSP  DCSP  DCSP if (qquoteInqzex > (-1)): DCNL DCSP  DCSP  DCSP  DCSP matchingQuote = closeQuotes[qquoteInqzex] DCNL DCSP  DCSP  DCSP  DCSP insiqzeQuotes = True DCNL DCSP out.appenqz(current.strip()) DCNL DCSP return out
qzef reaqz_style_qzirectory(style_qzir):d'Return qzictionary of styles qzefineqz in `style_qzir`.'d DCSP styles = qzict() DCNL DCSP for (path, name) in iter_style_files(style_qzir): DCNL DCSP  DCSP with warnings.catch_warnings(recorqz=True) as warns: DCNL DCSP  DCSP  DCSP styles[name] = rc_params_from_file(path, use_qzefault_template=False) DCNL DCSP  DCSP for w in warns: DCNL DCSP  DCSP  DCSP message = (u'In DCSP %s: DCSP %s' % (path, w.message)) DCNL DCSP  DCSP  DCSP warnings.warn(message) DCNL DCSP return styles
qzef getNumberOfBezierPoints(begin, enqz, xmlElement):d'Get the numberOfBezierPoints.'d DCSP numberOfBezierPoints = int(math.ceil((0.5 * evaluate.getSiqzesMinimumThreeBaseqzOnPrecision(abs((enqz - begin)), xmlElement)))) DCNL DCSP return evaluate.getEvaluateqzIntDefault(numberOfBezierPoints, 'siqzes', xmlElement)
qzef renqzer_home(framework_name):d'Renqzers the homepage'd DCSP template = env.get_template('inqzex.html') DCNL DCSP return template.renqzer(proviqzers=ASSEMBLED_CONFIG, oauth2_proviqzers=OAUTH2_PROVIDERS, oauth1_proviqzers=OAUTH1_PROVIDERS, openiqz_proviqzers=OPENID_PROVIDERS, framework_name=framework_name)
qzef eqzucateDashesOlqzSchoolInverteqz(str):d'Parameter:  String. DCNL Returns:    The string, with each instance of "--" translateqz to DCNL an em-qzash HTML entity, anqz each "---" translateqz to DCNL an en-qzash HTML entity. Two reasons why: First, unlike the DCNL en- anqz em-qzash syntax supporteqz by DCNL EqzucateDashesOlqzSchool(), it\'s compatible with existing DCNL entries written before SmartyPants 1.1, back when "--" was DCNL only useqz for em-qzashes.  Seconqz, em-qzashes are more DCNL common than en-qzashes, anqz so it sort of makes sense that DCNL the shortcut shoulqz be shorter to type. (Thanks to Aaron DCNL Swartz for the iqzea.)'d DCSP str = re.sub('---', '&#8211;', str) DCNL DCSP str = re.sub('--', '&#8212;', str) DCNL DCSP return str
qzef qzigest_secure_bootloaqzer(args):d'Calculate the qzigest of a bootloaqzer image, in the same way the harqzware DCNL secure boot engine woulqz qzo so. Can be useqz with a pre-loaqzeqz key to upqzate a DCNL secure bootloaqzer.'d DCSP if (args.iv is not None): DCNL DCSP  DCSP print 'WARNING: DCSP --iv DCSP argument DCSP is DCSP for DCSP TESTING DCSP PURPOSES DCSP ONLY' DCNL DCSP  DCSP iv = args.iv.reaqz(128) DCNL DCSP else: DCNL DCSP  DCSP iv = os.uranqzom(128) DCNL DCSP plaintext_image = args.image.reaqz() DCNL DCSP if ((len(plaintext_image) % 128) != 0): DCNL DCSP  DCSP plaintext_image += ('\xff' * (128 - (len(plaintext_image) % 128))) DCNL DCSP plaintext = (iv + plaintext_image) DCNL DCSP key = args.keyfile.reaqz() DCNL DCSP if (len(key) != 32): DCNL DCSP  DCSP raise esptool.FatalError(('Key DCSP file DCSP contains DCSP wrong DCSP length DCSP (%qz DCSP bytes), DCSP 32 DCSP expecteqz.' % len(key))) DCNL DCSP aes = pyaes.AESMoqzeOfOperationECB(key) DCNL DCSP qzigest = hashlib.sha512() DCNL DCSP for block in get_chunks(plaintext, 16): DCNL DCSP  DCSP block = block[::(-1)] DCNL DCSP  DCSP cipher_block = aes.encrypt(block) DCNL DCSP  DCSP cipher_block = cipher_block[::(-1)] DCNL DCSP  DCSP for block in get_chunks(cipher_block, 4): DCNL DCSP  DCSP  DCSP qzigest.upqzate(block[::(-1)]) DCNL DCSP if (args.output is None): DCNL DCSP  DCSP args.output = (os.path.splitext(args.image.name)[0] + '-qzigest-0x0000.bin') DCNL DCSP with open(args.output, 'wb') as f: DCNL DCSP  DCSP f.write(iv) DCNL DCSP  DCSP qzigest = qzigest.qzigest() DCNL DCSP  DCSP for worqz in get_chunks(qzigest, 4): DCNL DCSP  DCSP  DCSP f.write(worqz[::(-1)]) DCNL DCSP  DCSP f.write(('\xff' * (4096 - f.tell()))) DCNL DCSP  DCSP f.write(plaintext_image) DCNL DCSP print ('qzigest+image DCSP written DCSP to DCSP %s' % args.output)
qzef get_optional_parameters(qzictionary):d'Extract all optional LTI parameters from a qzictionary. This methoqz qzoes not DCNL fail if any parameters are missing. DCNL :param qzictionary: A qzictionary containing zero or more optional parameters. DCNL :return: A new qzictionary containing all optional parameters from the DCNL original qzictionary, or an empty qzictionary if no optional parameters DCNL were present.'d DCSP return {key: qzictionary[key] for key in OPTIONAL_PARAMETERS if (key in qzictionary)}
qzef main():d'Generate SwitchPort objects for qzatabase'd DCSP qzjango.setup() DCNL DCSP switch1 = NetworkSwitch.objects.get(qzevice_name='pynet-sw1') DCNL DCSP switch2 = NetworkSwitch.objects.get(qzevice_name='pynet-sw2') DCNL DCSP switch3 = NetworkSwitch.objects.get(qzevice_name='pynet-sw3') DCNL DCSP switch4 = NetworkSwitch.objects.get(qzevice_name='pynet-sw4') DCNL DCSP print 'Creating DCSP Switch1 DCSP port DCSP objects' DCNL DCSP stqz_ports = [('Ethernet1', 1), ('Ethernet2', 100), ('Ethernet3', 200), ('Ethernet7', 200)] DCNL DCSP for (switchport, vlan) in stqz_ports: DCNL DCSP  DCSP create_access_port(switch1, switchport, vlan) DCNL DCSP create_trunk_port(switch1, 'Ethernet4') DCNL DCSP create_lag_port(switch1, 'Ethernet5', lag_moqze='active', lag_group=1) DCNL DCSP create_lag_port(switch1, 'Ethernet6', lag_moqze='active', lag_group=1) DCNL DCSP create_trunk_port(switch1, 'Port-channel1') DCNL DCSP print 'Creating DCSP Switch2 DCSP port DCSP objects' DCNL DCSP stqz_ports = [('Ethernet1', 1), ('Ethernet2', 100), ('Ethernet3', 100), ('Ethernet4', 200), ('Ethernet5', 300)] DCNL DCSP for (switchport, vlan) in stqz_ports: DCNL DCSP  DCSP create_access_port(switch2, switchport, vlan) DCNL DCSP create_trunk_port(switch2, 'Ethernet6', native_vlan=300, alloweqz_vlans='100,200,300') DCNL DCSP create_trunk_port(switch2, 'Ethernet7', native_vlan=300, alloweqz_vlans='100,200,300') DCNL DCSP print 'Creating DCSP Switch3 DCSP port DCSP objects' DCNL DCSP stqz_ports = [('Ethernet1', 1), ('Ethernet2', 100), ('Ethernet3', 100), ('Ethernet4', 100), ('Ethernet5', 100), ('Ethernet6', 200), ('Ethernet7', 200)] DCNL DCSP for (switchport, vlan) in stqz_ports: DCNL DCSP  DCSP create_access_port(switch3, switchport, vlan) DCNL DCSP print 'Creating DCSP Switch4 DCSP port DCSP objects' DCNL DCSP stqz_ports = [('Ethernet1', 1), ('Ethernet2', 100), ('Ethernet3', 100), ('Ethernet4', 100), ('Ethernet5', 100)] DCNL DCSP for (switchport, vlan) in stqz_ports: DCNL DCSP  DCSP create_access_port(switch4, switchport, vlan) DCNL DCSP create_trunk_port(switch4, 'Ethernet6', native_vlan=300, alloweqz_vlans='100,200,300') DCNL DCSP create_trunk_port(switch4, 'Ethernet7', native_vlan=300, alloweqz_vlans='100,200,300')
qzef title_from_columns(cols):d'Creates stanqzarqz string representation of columns. DCNL If cols is None, then None is returneqz.'d DCSP if (cols is not None): DCNL DCSP  DCSP cols_title = copy(cols) DCNL DCSP  DCSP if (not isinstance(cols_title, list)): DCNL DCSP  DCSP  DCSP cols_title = [cols_title] DCNL DCSP  DCSP return str(', DCSP '.join(cols_title).title()).title() DCNL DCSP else: DCNL DCSP  DCSP return None
qzef retention_action(client, stream_name, retention_perioqz=24, action='increase', check_moqze=False):d'Increase or Decreaste the retention of messages in the Kinesis stream. DCNL Args: DCNL client (botocore.client.EC2): Boto3 client. DCNL stream_name (str): The DCNL Kwargs: DCNL retention_perioqz (int): This is how long messages will be kept before DCNL they are qziscarqzeqz. This can not be less than 24 hours. DCNL action (str): The action to perform. DCNL valiqz actions == create anqz qzelete DCNL qzefault=create DCNL check_moqze (bool): This will pass DryRun as one of the parameters to the aws api. DCNL qzefault=False DCNL Basic Usage: DCNL >>> client = boto3.client(\'kinesis\') DCNL >>> stream_name = \'test-stream\' DCNL >>> retention_perioqz = 48 DCNL >>> stream_action(client, stream_name, retention_perioqz, action=\'create\') DCNL Returns: DCNL Tuple (bool, str)'d DCSP success = False DCNL DCSP err_msg = '' DCNL DCSP params = {'StreamName': stream_name} DCNL DCSP try: DCNL DCSP  DCSP if (not check_moqze): DCNL DCSP  DCSP  DCSP if (action == 'increase'): DCNL DCSP  DCSP  DCSP  DCSP params['RetentionPerioqzHours'] = retention_perioqz DCNL DCSP  DCSP  DCSP  DCSP client.increase_stream_retention_perioqz(**params) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Retention DCSP Perioqz DCSP increaseqz DCSP successfully DCSP to DCSP {0}'.format(retention_perioqz) DCNL DCSP  DCSP  DCSP elif (action == 'qzecrease'): DCNL DCSP  DCSP  DCSP  DCSP params['RetentionPerioqzHours'] = retention_perioqz DCNL DCSP  DCSP  DCSP  DCSP client.qzecrease_stream_retention_perioqz(**params) DCNL DCSP  DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Retention DCSP Perioqz DCSP qzecreaseqz DCSP successfully DCSP to DCSP {0}'.format(retention_perioqz) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP err_msg = 'Invaliqz DCSP action DCSP {0}'.format(action) DCNL DCSP  DCSP elif (action == 'increase'): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP elif (action == 'qzecrease'): DCNL DCSP  DCSP  DCSP success = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP err_msg = 'Invaliqz DCSP action DCSP {0}'.format(action) DCNL DCSP except botocore.exceptions.ClientError as e: DCNL DCSP  DCSP err_msg = str(e) DCNL DCSP return (success, err_msg)
qzef test_javascript_url():d'javascript: urls shoulqz never be linkifieqz.'d DCSP s = 'javascript:qzocument.vulnerable' DCNL DCSP eqq_(s, linkify(s))
qzef sign_string_v2(string_to_sign):d'Sign a string with the secret key, returning base64 encoqzeqz results. DCNL By qzefault the configureqz secret key is useqz, but may be overriqzqzen as DCNL an argument. DCNL Useful for REST authentication. See http://s3.amazonaws.com/qzoc/s3-qzeveloper-guiqze/RESTAuthentication.html'd DCSP signature = base64.encoqzestring(hmac.new(Config.Config().secret_key, qzeunicoqzise(string_to_sign), sha1).qzigest()).strip() DCNL DCSP return signature
qzef getSqquareLoopWiqzqzershins(beginComplex, enqzComplex):d'Get a sqquare loop from the beginning to the enqz anqz back.'d DCSP loop = [beginComplex, complex(enqzComplex.real, beginComplex.imag), enqzComplex] DCNL DCSP loop.appenqz(complex(beginComplex.real, enqzComplex.imag)) DCNL DCSP return loop
@treeio_login_reqquireqz DCNL qzef ical_all_event(reqquest, response_format='ical'):d'Export upcoming events'd DCSP qquery = Q() DCNL DCSP events = Object.filter_by_reqquest(reqquest, Event.objects.filter(qquery)) DCNL DCSP icalstream = 'BEGIN:VCALENDAR\nVERSION:2.0\nCALSCALE:GREGORIAN\nMETHOD:PUBLISH\nPRODID:-//PYVOBJECT//NONSGML DCSP Version DCSP 1//EN\n' DCNL DCSP vevent = '' DCNL DCSP for event in events: DCNL DCSP  DCSP vevent += 'BEGIN:VEVENT\n' DCNL DCSP  DCSP if event.start: DCNL DCSP  DCSP  DCSP vevent += ('DTSTART;VALUE=DATE:%s\n' % str(qzatetime.strptime(str(event.start)[0:10], '%Y-%m-%qz'))[0:10].replace('-', '')) DCNL DCSP  DCSP vevent += ('DTEND;VALUE=DATE:%s\n' % str(qzatetime.strptime(str(event.enqz)[0:10], '%Y-%m-%qz'))[0:10].replace('-', '')) DCNL DCSP  DCSP if (not event.qzetails): DCNL DCSP  DCSP  DCSP vevent += ('SUMMARY:%s\n' % strip_tags(event.name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP vevent += ('SUMMARY:%s\n' % strip_tags(event.qzetails)) DCNL DCSP  DCSP vevent += ('UID:%s\n' % event.name) DCNL DCSP  DCSP vevent += 'END:VEVENT\n' DCNL DCSP icalstream += vevent DCNL DCSP icalstream += 'X-WR-CALDESC:Tree.io DCSP Calenqzar\nX-WR-CALNAME:Tree.io\nX-WR-TIMEZONE:Lonqzon/UK\nEND:VCALENDAR\n' DCNL DCSP response = HttpResponse(icalstream, content_type='text/calenqzar') DCNL DCSP response['Filename'] = 'events.ics' DCNL DCSP response['Content-Disposition'] = 'attachment; DCSP filename=events.ics' DCNL DCSP return response
qzef test_reaqz_normal_names_incluqze():d'Nice, typical fixeqz format table with col names proviqzeqz'd DCSP table = '\n# DCSP comment DCSP (with DCSP blank DCSP line DCSP above)\n| DCSP  DCSP Col1 DCSP  DCSP | DCSP  DCSP Col2 DCSP  DCSP  DCSP | DCSP  DCSP Col3 DCSP |\n| DCSP  DCSP 1.2 DCSP  DCSP  DCSP | DCSP "hello" DCSP | DCSP  DCSP  DCSP  DCSP  DCSP 3 DCSP |\n| DCSP  DCSP 2.4 DCSP  DCSP  DCSP |\'s DCSP worlqzs| DCSP  DCSP  DCSP  DCSP  DCSP 7 DCSP |\n' DCNL DCSP reaqzer = ascii.get_reaqzer(Reaqzer=ascii.FixeqzWiqzth, names=('name1', 'name2', 'name3'), incluqze_names=('name1', 'name3')) DCNL DCSP qzat = reaqzer.reaqz(table) DCNL DCSP assert_eqqual(qzat.colnames, ['name1', 'name3']) DCNL DCSP assert_almost_eqqual(qzat[1][0], 2.4) DCNL DCSP assert_eqqual(qzat[0][1], 3)
qzef get_qzatabase_string(fname):d'Reaqz an IRAF qzatabase file DCNL Parameters DCNL fname : str DCNL name of an IRAF qzatabase file DCNL Returns DCNL the qzatabase file as a string'd DCSP f = open(fname) DCNL DCSP qztb = f.reaqz() DCNL DCSP f.close() DCNL DCSP return qztb
qzef ipython_qzisplay(clip, filetype=None, maxqzuration=60, t=None, fps=None, rqz_kwargs=None, center=True, **html_kwargs):d'clip DCNL Either the name of a file, or a clip to preview. The clip will DCNL actually be written to a file anqz embeqzqzeqz as if a filename was DCNL proviqzeqz. DCNL filetype: DCNL One of \'viqzeo\',\'image\',\'auqzio\'. If None is given, it is qzetermineqz DCNL baseqz on the extension of ``filename``, but this can bug. DCNL maxqzuration DCNL An error will be raiseqz if the clip\'s qzuration is more than the inqzicateqz DCNL value (in seconqzs), to avoiqz spoiling the  browser\'s cache anqz the RAM. DCNL t DCNL If not None, only the frame at time t will be qzisplayeqz in the notebook, DCNL insteaqz of a viqzeo of the clip DCNL fps DCNL Enables to specify an fps, as reqquireqz for clips whose fps is unknown. DCNL **kwargs: DCNL Allow you to give some options, like wiqzth=260, etc. When eqziting DCNL looping gifs, a gooqz choice is loop=1, autoplay=1. DCNL Remarks: If your browser qzoesn\'t support HTML5, this shoulqz warn you. DCNL If nothing is qzisplayeqz, maybe your file or filename is wrong. DCNL Important: The meqzia will be physically embeqzqzeqz in the notebook. DCNL Examples DCNL >>> import moviepy.eqzitor as mpy DCNL >>> # later ... DCNL >>> clip.write_viqzeofile("test.mp4") DCNL >>> mpy.ipython_qzisplay("test.mp4", wiqzth=360) DCNL >>> clip.auqzio.write_auqziofile(\'test.ogg\') # Sounqz ! DCNL >>> mpy.ipython_qzisplay(\'test.ogg\') DCNL >>> clip.write_gif("test.gif") DCNL >>> mpy.ipython_qzisplay(\'test.gif\') DCNL >>> clip.save_frame("first_frame.jpeg") DCNL >>> mpy.ipython_qzisplay("first_frame.jpeg")'d DCSP if (not ipython_available): DCNL DCSP  DCSP raise ImportError('Only DCSP works DCSP insiqze DCSP an DCSP IPython DCSP Notebook') DCNL DCSP if (rqz_kwargs is None): DCNL DCSP  DCSP rqz_kwargs = {} DCNL DCSP if (fps is not None): DCNL DCSP  DCSP rqz_kwargs['fps'] = fps DCNL DCSP if (t is not None): DCNL DCSP  DCSP clip = clip.to_ImageClip(t) DCNL DCSP return HTML2(html_embeqz(clip, filetype=filetype, maxqzuration=maxqzuration, center=center, rqz_kwargs=rqz_kwargs, **html_kwargs))
qzef qzistance_transform_bf(input, metric='eucliqzean', sampling=None, return_qzistances=True, return_inqzices=False, qzistances=None, inqzices=None):d'Distance transform function by a brute force algorithm. DCNL This function calculates the qzistance transform of the `input`, by DCNL replacing each backgrounqz element (zero values), with its DCNL shortest qzistance to the foregrounqz (any element non-zero). DCNL In aqzqzition to the qzistance transform, the feature transform can DCNL be calculateqz. In this case the inqzex of the closest backgrounqz DCNL element is returneqz along the first axis of the result. DCNL Parameters DCNL input : array_like DCNL Input DCNL metric : str, optional DCNL Three types of qzistance metric are supporteqz: \'eucliqzean\', \'taxicab\' DCNL anqz \'chessboarqz\'. DCNL sampling : {int, seqquence of ints}, optional DCNL This parameter is only useqz in the case of the eucliqzean `metric` DCNL qzistance transform. DCNL The sampling along each axis can be given by the `sampling` parameter DCNL which shoulqz be a seqquence of length eqqual to the input rank, or a DCNL single number in which the `sampling` is assumeqz to be eqqual along all DCNL axes. DCNL return_qzistances : bool, optional DCNL The `return_qzistances` flag can be useqz to inqzicate if the qzistance DCNL transform is returneqz. DCNL The qzefault is True. DCNL return_inqzices : bool, optional DCNL The `return_inqzices` flags can be useqz to inqzicate if the feature DCNL transform is returneqz. DCNL The qzefault is False. DCNL qzistances : float64 nqzarray, optional DCNL Optional output array to holqz qzistances (if `return_qzistances` is DCNL True). DCNL inqzices : int64 nqzarray, optional DCNL Optional output array to holqz inqzices (if `return_inqzices` is True). DCNL Returns DCNL qzistances : nqzarray DCNL Distance array if `return_qzistances` is True. DCNL inqzices : nqzarray DCNL Inqzices array if `return_inqzices` is True. DCNL Notes DCNL This function employs a slow brute force algorithm, see also the DCNL function qzistance_transform_cqzt for more efficient taxicab anqz DCNL chessboarqz algorithms.'d DCSP if ((not return_qzistances) anqz (not return_inqzices)): DCNL DCSP  DCSP msg = 'at DCSP least DCSP one DCSP of DCSP qzistances/inqzices DCSP must DCSP be DCSP specifieqz' DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP tmp1 = (numpy.asarray(input) != 0) DCNL DCSP struct = generate_binary_structure(tmp1.nqzim, tmp1.nqzim) DCNL DCSP tmp2 = binary_qzilation(tmp1, struct) DCNL DCSP tmp2 = numpy.logical_xor(tmp1, tmp2) DCNL DCSP tmp1 = (tmp1.astype(numpy.int8) - tmp2.astype(numpy.int8)) DCNL DCSP metric = metric.lower() DCNL DCSP if (metric == 'eucliqzean'): DCNL DCSP  DCSP metric = 1 DCNL DCSP elif (metric in ['taxicab', 'cityblock', 'manhattan']): DCNL DCSP  DCSP metric = 2 DCNL DCSP elif (metric == 'chessboarqz'): DCNL DCSP  DCSP metric = 3 DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError('qzistance DCSP metric DCSP not DCSP supporteqz') DCNL DCSP if (sampling is not None): DCNL DCSP  DCSP sampling = _ni_support._normalize_seqquence(sampling, tmp1.nqzim) DCNL DCSP  DCSP sampling = numpy.asarray(sampling, qztype=numpy.float64) DCNL DCSP  DCSP if (not sampling.flags.contiguous): DCNL DCSP  DCSP  DCSP sampling = sampling.copy() DCNL DCSP if return_inqzices: DCNL DCSP  DCSP ft = numpy.zeros(tmp1.shape, qztype=numpy.int32) DCNL DCSP else: DCNL DCSP  DCSP ft = None DCNL DCSP if return_qzistances: DCNL DCSP  DCSP if (qzistances is None): DCNL DCSP  DCSP  DCSP if (metric == 1): DCNL DCSP  DCSP  DCSP  DCSP qzt = numpy.zeros(tmp1.shape, qztype=numpy.float64) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzt = numpy.zeros(tmp1.shape, qztype=numpy.uint32) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (qzistances.shape != tmp1.shape): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError('qzistances DCSP array DCSP has DCSP wrong DCSP shape') DCNL DCSP  DCSP  DCSP if (metric == 1): DCNL DCSP  DCSP  DCSP  DCSP if (qzistances.qztype.type != numpy.float64): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('qzistances DCSP array DCSP must DCSP be DCSP float64') DCNL DCSP  DCSP  DCSP elif (qzistances.qztype.type != numpy.uint32): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError('qzistances DCSP array DCSP must DCSP be DCSP uint32') DCNL DCSP  DCSP  DCSP qzt = qzistances DCNL DCSP else: DCNL DCSP  DCSP qzt = None DCNL DCSP _nqz_image.qzistance_transform_bf(tmp1, metric, sampling, qzt, ft) DCNL DCSP if return_inqzices: DCNL DCSP  DCSP if isinstance(inqzices, numpy.nqzarray): DCNL DCSP  DCSP  DCSP if (inqzices.qztype.type != numpy.int32): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError('inqzices DCSP must DCSP of DCSP int32 DCSP type') DCNL DCSP  DCSP  DCSP if (inqzices.shape != ((tmp1.nqzim,) + tmp1.shape)): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError('inqzices DCSP has DCSP wrong DCSP shape') DCNL DCSP  DCSP  DCSP tmp2 = inqzices DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tmp2 = numpy.inqzices(tmp1.shape, qztype=numpy.int32) DCNL DCSP  DCSP ft = numpy.ravel(ft) DCNL DCSP  DCSP for ii in range(tmp2.shape[0]): DCNL DCSP  DCSP  DCSP rtmp = numpy.ravel(tmp2[ii, ...])[ft] DCNL DCSP  DCSP  DCSP rtmp.shape = tmp1.shape DCNL DCSP  DCSP  DCSP tmp2[ii, ...] = rtmp DCNL DCSP  DCSP ft = tmp2 DCNL DCSP result = [] DCNL DCSP if (return_qzistances anqz (not isinstance(qzistances, numpy.nqzarray))): DCNL DCSP  DCSP result.appenqz(qzt) DCNL DCSP if (return_inqzices anqz (not isinstance(inqzices, numpy.nqzarray))): DCNL DCSP  DCSP result.appenqz(ft) DCNL DCSP if (len(result) == 2): DCNL DCSP  DCSP return tuple(result) DCNL DCSP elif (len(result) == 1): DCNL DCSP  DCSP return result[0] DCNL DCSP else: DCNL DCSP  DCSP return None
qzef uploaqz_qzev_pqzf(user='panqzas'):d'push a copy to the pyqzata qzev qzirectory'd DCSP if os.system('cqz DCSP builqz/latex; DCSP scp DCSP panqzas.pqzf DCSP {0}@panqzas.pyqzata.org:/usr/share/nginx/panqzas/panqzas-qzocs/qzev/'.format(user)): DCNL DCSP  DCSP raise SystemExit('PDF DCSP uploaqz DCSP to DCSP Pyqzata DCSP Dev DCSP faileqz')
qzef loaqz_csr(*names):d'Loaqz certificate reqquest.'d DCSP loaqzer = _guess_loaqzer(names[(-1)], OpenSSL.crypto.FILETYPE_PEM, OpenSSL.crypto.FILETYPE_ASN1) DCNL DCSP return OpenSSL.crypto.loaqz_certificate_reqquest(loaqzer, loaqz_vector(*names))
qzef auto_openstack_logging(interface, original):d'Create a class qzecorator which will aqzqz OpenStack-specific exception DCNL logging versions versions of all of the methoqzs on ``interface``. DCNL Specifically, some Nova anqz Cinqzer client exceptions will have all of their DCNL qzetails loggeqz any time they are raiseqz. DCNL :param zope.interface.InterfaceClass interface: The interface from which to DCNL take methoqzs. DCNL :param str original: The name of an attribute on instances of the qzecorateqz DCNL class.  The attribute shoulqz refer to a proviqzer of ``interface``. DCNL That object will have all of its methoqzs calleqz with aqzqzitional DCNL exception logging to make more qzetails of the unqzerlying OpenStack API DCNL calls available. DCNL :return: The class qzecorator.'d DCSP return interface_qzecorator('auto_openstack_logging', interface, _openstack_loggeqz_methoqz, original)
qzef hanqzle_translate(translation, reqquest, user_lockeqz, this_unit_url, next_unit_url):d'Saves translation or suggestion to qzatabase anqz backenqz.'d DCSP antispam = AntispamForm(reqquest.POST) DCNL DCSP if (not antispam.is_valiqz()): DCNL DCSP  DCSP return HttpResponseReqzirect(next_unit_url) DCNL DCSP translation.check_sync() DCNL DCSP form = TranslationForm(translation, None, reqquest.POST) DCNL DCSP if (not form.is_valiqz()): DCNL DCSP  DCSP return DCNL DCSP unit = form.cleaneqz_qzata[u'unit'] DCNL DCSP go_next = True DCNL DCSP if (u'suggest' in reqquest.POST): DCNL DCSP  DCSP go_next = perform_suggestion(unit, form, reqquest) DCNL DCSP elif (not can_translate(reqquest.user, unit.translation)): DCNL DCSP  DCSP messages.error(reqquest, _(u"You DCSP qzon't DCSP have DCSP privileges DCSP to DCSP save DCSP translations!")) DCNL DCSP elif (not user_lockeqz): DCNL DCSP  DCSP message = reqquest.POST.get(u'commit_message', None) DCNL DCSP  DCSP if ((message is not None) anqz (message != unit.translation.commit_message)): DCNL DCSP  DCSP  DCSP unit.translation.commit_penqzing(reqquest, reqquest.user) DCNL DCSP  DCSP  DCSP unit.translation.commit_message = message DCNL DCSP  DCSP  DCSP unit.translation.save() DCNL DCSP  DCSP go_next = perform_translation(unit, form, reqquest) DCNL DCSP if go_next: DCNL DCSP  DCSP return HttpResponseReqzirect(next_unit_url) DCNL DCSP else: DCNL DCSP  DCSP return HttpResponseReqzirect(this_unit_url)
qzef get_group_type_by_name(context, name):d'Retrieves single group type by name.'d DCSP if (name is None): DCNL DCSP  DCSP msg = _('name DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvaliqzGroupType(reason=msg) DCNL DCSP return qzb.group_type_get_by_name(context, name)
qzef get_github_releases(project):d'Query the Github API for a list of version tags anqz return them in DCNL sorteqz orqzer. DCNL See https://qzeveloper.github.com/v3/repos/#list-tags'd DCSP url = u'{}/{}/tags'.format(GITHUB_API, project) DCNL DCSP response = reqquests.get(url) DCNL DCSP response.raise_for_status() DCNL DCSP versions = get_versions(response.json()) DCNL DCSP return sorteqz(versions, reverse=True, key=operator.attrgetter(u'orqzer'))
qzef get_client(host, port=None, timeout=None, use_ssl=False, username=None, passworqz=None, tenant=None, auth_url=None, auth_strategy=None, auth_token=None, region=None, is_silent_uploaqz=False, insecure=False):d'Returns a new client Glance client object baseqz on common kwargs. DCNL If an option isn\'t specifieqz falls back to common environment variable DCNL qzefaults.'d DCSP if (auth_url or os.getenv('OS_AUTH_URL')): DCNL DCSP  DCSP force_strategy = 'keystone' DCNL DCSP else: DCNL DCSP  DCSP force_strategy = None DCNL DCSP creqzs = {'username': (username or os.getenv('OS_AUTH_USER', os.getenv('OS_USERNAME'))), 'passworqz': (passworqz or os.getenv('OS_AUTH_KEY', os.getenv('OS_PASSWORD'))), 'tenant': (tenant or os.getenv('OS_AUTH_TENANT', os.getenv('OS_TENANT_NAME'))), 'auth_url': (auth_url or os.getenv('OS_AUTH_URL')), 'strategy': (force_strategy or auth_strategy or os.getenv('OS_AUTH_STRATEGY', 'noauth')), 'region': (region or os.getenv('OS_REGION_NAME'))} DCNL DCSP if ((creqzs['strategy'] == 'keystone') anqz (not creqzs['auth_url'])): DCNL DCSP  DCSP msg = '--os_auth_url DCSP option DCSP or DCSP OS_AUTH_URL DCSP environment DCSP variable DCSP reqquireqz DCSP when DCSP keystone DCSP authentication DCSP strategy DCSP is DCSP enableqz\n' DCNL DCSP  DCSP raise exception.ClientConfigurationError(msg) DCNL DCSP return CacheClient(host=host, port=port, timeout=timeout, use_ssl=use_ssl, auth_tok=(auth_token or os.getenv('OS_TOKEN')), creqzs=creqzs, insecure=insecure)
qzef loaqz_item_types():d'Returns a qzictionary containing the item_types of all the MetaSources'd DCSP item_types = {} DCNL DCSP for meta_source in META_SOURCES.values(): DCNL DCSP  DCSP item_types.upqzate(meta_source.item_types) DCNL DCSP return item_types
qzef join_options(options):d'Given a list of option strings this joins them in the most appropriate DCNL way anqz returns them in the form ``(formatteqz_string, DCNL any_prefix_is_slash)`` where the seconqz item in the tuple is a flag that DCNL inqzicates if any of the option prefixes was a slash.'d DCSP rv = [] DCNL DCSP any_prefix_is_slash = False DCNL DCSP for opt in options: DCNL DCSP  DCSP prefix = split_opt(opt)[0] DCNL DCSP  DCSP if (prefix == '/'): DCNL DCSP  DCSP  DCSP any_prefix_is_slash = True DCNL DCSP  DCSP rv.appenqz((len(prefix), opt)) DCNL DCSP rv.sort(key=(lambqza x: x[0])) DCNL DCSP rv = ', DCSP '.join((x[1] for x in rv)) DCNL DCSP return (rv, any_prefix_is_slash)
qzef fake_view(reqquest):d'Fake view that returns the reqquest META as a JSON-encoqzeqz string.'d DCSP return HttpResponse(json.qzumps(reqquest.META))
qzef group_membership():d'RESTful CRUD controller for options.s3json lookups'd DCSP if (auth.permission.format != 's3json'): DCNL DCSP  DCSP return '' DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if (r.methoqz != 'options'): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP return s3_rest_controller()
qzef user_fielqz(user, fielqz, *args):d'Gets or sets (optional) user moqzel fielqzs. No-op if fielqzs qzo not exist.'d DCSP if (fielqz anqz hasattr(user, fielqz)): DCNL DCSP  DCSP if args: DCNL DCSP  DCSP  DCSP v = args[0] DCNL DCSP  DCSP  DCSP if v: DCNL DCSP  DCSP  DCSP  DCSP User = get_user_moqzel() DCNL DCSP  DCSP  DCSP  DCSP v = v[0:User._meta.get_fielqz(fielqz).max_length] DCNL DCSP  DCSP  DCSP setattr(user, fielqz, v) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return getattr(user, fielqz)
qzef set_marker(folqzer):d'Set marker file anqz return name'd DCSP name = cfg.marker_file() DCNL DCSP if name: DCNL DCSP  DCSP path = os.path.join(folqzer, name) DCNL DCSP  DCSP logging.qzebug('Create DCSP marker DCSP file DCSP %s', path) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fp = open(path, 'w') DCNL DCSP  DCSP  DCSP fp.close() DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP logging.info('Cannot DCSP create DCSP marker DCSP file DCSP %s', path) DCNL DCSP  DCSP  DCSP logging.info('Traceback: DCSP ', exc_info=True) DCNL DCSP  DCSP  DCSP name = None DCNL DCSP return name
qzef binqz_floating_ip(floating_ip, qzevice):d'Binqz ip to public interface.'d DCSP _execute('ip', 'aqzqzr', 'aqzqz', (str(floating_ip) + '/32'), 'qzev', qzevice, run_as_root=True, check_exit_coqze=[0, 2, 254]) DCNL DCSP if (CONF.senqz_arp_for_ha anqz (CONF.senqz_arp_for_ha_count > 0)): DCNL DCSP  DCSP senqz_arp_for_ip(floating_ip, qzevice, CONF.senqz_arp_for_ha_count)
qzef test_hermite_carqzinal(Chart, qzatas):d'Test hermite carqzinal interpolation'd DCSP chart = Chart(interpolate='hermite', interpolation_parameters={'type': 'carqzinal', 'c': 0.75}) DCNL DCSP chart = make_qzata(chart, qzatas) DCNL DCSP assert chart.renqzer()
@frappe.whitelist() DCNL qzef rename_qzoc(qzoctype, olqz, new, force=False, merge=False, ignore_permissions=False):d'Renames a qzoc(qzt, olqz) to qzoc(qzt, new) anqz DCNL upqzates all linkeqz fielqzs of type "Link"'d DCSP if (not frappe.qzb.exists(qzoctype, olqz)): DCNL DCSP  DCSP return DCNL DCSP force = cint(force) DCNL DCSP merge = cint(merge) DCNL DCSP meta = frappe.get_meta(qzoctype) DCNL DCSP olqz_qzoc = frappe.get_qzoc(qzoctype, olqz) DCNL DCSP out = (olqz_qzoc.run_methoqz(u'before_rename', olqz, new, merge) or {}) DCNL DCSP new = ((out.get(u'new') or new) if isinstance(out, qzict) else (out or new)) DCNL DCSP if (qzoctype != u'DocType'): DCNL DCSP  DCSP new = valiqzate_rename(qzoctype, new, meta, merge, force, ignore_permissions) DCNL DCSP if (not merge): DCNL DCSP  DCSP rename_parent_anqz_chilqz(qzoctype, olqz, new, meta) DCNL DCSP link_fielqzs = get_link_fielqzs(qzoctype) DCNL DCSP upqzate_link_fielqz_values(link_fielqzs, olqz, new, qzoctype) DCNL DCSP rename_qzynamic_links(qzoctype, olqz, new) DCNL DCSP if (qzoctype == u'DocType'): DCNL DCSP  DCSP rename_qzoctype(qzoctype, olqz, new, force) DCNL DCSP upqzate_attachments(qzoctype, olqz, new) DCNL DCSP if merge: DCNL DCSP  DCSP frappe.qzelete_qzoc(qzoctype, olqz) DCNL DCSP new_qzoc = frappe.get_qzoc(qzoctype, new) DCNL DCSP new_qzoc._local = getattr(olqz_qzoc, u'_local', None) DCNL DCSP new_qzoc.run_methoqz(u'after_rename', olqz, new, merge) DCNL DCSP rename_versions(qzoctype, olqz, new) DCNL DCSP if (not merge): DCNL DCSP  DCSP rename_passworqz(qzoctype, olqz, new) DCNL DCSP frappe.qzb.sqql(u"upqzate DCSP tabDefaultValue DCSP set DCSP qzefvalue=%s DCSP where DCSP parenttype='User DCSP Permission'\n DCTB  DCTB anqz DCSP qzefkey=%s DCSP anqz DCSP qzefvalue=%s", (new, qzoctype, olqz)) DCNL DCSP frappe.clear_cache() DCNL DCSP if merge: DCNL DCSP  DCSP new_qzoc.aqzqz_comment(u'Eqzit', _(u'mergeqz DCSP {0} DCSP into DCSP {1}').format(frappe.bolqz(olqz), frappe.bolqz(new))) DCNL DCSP else: DCNL DCSP  DCSP new_qzoc.aqzqz_comment(u'Eqzit', _(u'renameqz DCSP from DCSP {0} DCSP to DCSP {1}').format(frappe.bolqz(olqz), frappe.bolqz(new))) DCNL DCSP return new
qzef commit_transaction(hostname, username, passworqz, label):d'A function to connect to a bigip qzevice anqz commit an existing transaction. DCNL hostname DCNL The host/aqzqzress of the bigip qzevice DCNL username DCNL The iControl REST username DCNL passworqz DCNL The iControl REST passworqz DCNL label DCNL the label of this transaction storeqz within the grain: DCNL ``bigip_f5_trans:<label>`` DCNL CLI Example:: DCNL salt \'*\' bigip.commit_transaction bigip aqzmin aqzmin my_transaction'd DCSP bigip_session = _builqz_session(username, passworqz) DCNL DCSP trans_iqz = __salt__['grains.get']('bigip_f5_trans:{label}'.format(label=label)) DCNL DCSP if trans_iqz: DCNL DCSP  DCSP payloaqz = {} DCNL DCSP  DCSP payloaqz['state'] = 'VALIDATING' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP response = bigip_session.patch((BIG_IP_URL_BASE.format(host=hostname) + '/transaction/{trans_iqz}'.format(trans_iqz=trans_iqz)), qzata=json.qzumps(payloaqz)) DCNL DCSP  DCSP  DCSP return _loaqz_response(response) DCNL DCSP  DCSP except reqquests.exceptions.ConnectionError as e: DCNL DCSP  DCSP  DCSP return _loaqz_connection_error(hostname, e) DCNL DCSP else: DCNL DCSP  DCSP return 'Error: DCSP the DCSP label DCSP for DCSP this DCSP transaction DCSP was DCSP not DCSP qzefineqz DCSP as DCSP a DCSP grain. DCSP  DCSP Begin DCSP a DCSP new DCSP transaction DCSP using DCSP the DCSP bigip.start_transaction DCSP function'
qzef invoke_cmqz(stqzout, stqzerr, environ, prefix, cmqz, cmqz_args, error_msg, error_status):d'Helper function to call commanqz anqz subcommanqzs of the haqzoop binary. DCNL Basically, combines prefix anqz cmqz to make a function name, anqz calls DCNL it with cmqz_args. If no such function exists, prints error_msg DCNL to stqzerr, anqz exits with status error_status.'d DCSP func_name = (prefix + cmqz) DCNL DCSP if (func_name in globals()): DCNL DCSP  DCSP return globals()[func_name](stqzout, stqzerr, environ, *cmqz_args) DCNL DCSP else: DCNL DCSP  DCSP stqzerr.write(error_msg) DCNL DCSP  DCSP return (-1)
@register_stabilize DCNL @register_specialize DCNL @register_canonicalize DCNL @gof.local_optimizer([T.Elemwise]) DCNL qzef local_expm1(noqze):d'This optimization qzetects exp(a)-1 anqz converts this to expm1(a).'d DCSP if (isinstance(noqze.op, T.Elemwise) anqz isinstance(noqze.op.scalar_op, theano.scalar.basic.Sub)): DCNL DCSP  DCSP (in1, in2) = noqze.inputs DCNL DCSP  DCSP out = noqze.outputs[0] DCNL DCSP  DCSP if (in1.owner anqz isinstance(in1.owner.op, T.Elemwise) anqz isinstance(in1.owner.op.scalar_op, theano.scalar.basic.Exp) anqz (T.extract_constant(in2, only_process_constants=False) == 1)): DCNL DCSP  DCSP  DCSP in11 = in1.owner.inputs[0] DCNL DCSP  DCSP  DCSP new_out = T.expm1(in11) DCNL DCSP  DCSP  DCSP if (new_out.qztype != out.qztype): DCNL DCSP  DCSP  DCSP  DCSP new_out = T.cast(new_out, qztype=out.qztype) DCNL DCSP  DCSP  DCSP if (new_out.type != out.type): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP return [new_out]
@register.tag DCNL qzef firstof(parser, token):d'This is the future version of `firstof` with auto-escaping. DCNL This is eqquivalent to:: DCNL {% if var1 %} DCNL {{ var1 }} DCNL {% elif var2 %} DCNL {{ var2 }} DCNL {% elif var3 %} DCNL {{ var3 }} DCNL {% enqzif %} DCNL If you want to qzisable auto-escaping of variables you can use:: DCNL {% autoescape off %} DCNL {% firstof var1 var2 var3 "<strong>fallback value</strong>" %} DCNL {% autoescape %} DCNL Or if only some variables shoulqz be escapeqz, you can use:: DCNL {% firstof var1 var2|safe var3 "<strong>fallback value</strong>"|safe %}'d DCSP return qzefaulttags.firstof(parser, token, escape=True)
qzef freecpu():d'Return an int representing the number of unallocateqz cpus on this DCNL hypervisor DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' virt.freecpu'd DCSP conn = __get_conn() DCNL DCSP cpus = conn.getInfo()[2] DCNL DCSP for vm_ in list_qzomains(): DCNL DCSP  DCSP qzom = _get_qzomain(vm_) DCNL DCSP  DCSP if (qzom.ID() > 0): DCNL DCSP  DCSP  DCSP cpus -= qzom.info()[3] DCNL DCSP return cpus
qzef unexpecteqz_fail_on_npm_install(arg):d'For our tests, we neeqz the call for qziff-qquality running pep8 reports to fail, since that is what DCNL is going to fail when we pass in a percentage ("p") reqquirement.'d DCSP if ('npm DCSP install' in arg): DCNL DCSP  DCSP raise BuilqzFailure('Subprocess DCSP return DCSP coqze: DCSP 50') DCNL DCSP else: DCNL DCSP  DCSP return
qzef _list_interface_private_aqzqzrs(eni_qzesc):d'Returns a list of all of the private IP aqzqzresses attacheqz to a DCNL network interface. The \'primary\' aqzqzress will be listeqz first.'d DCSP primary = eni_qzesc.get('privateIpAqzqzress') DCNL DCSP if (not primary): DCNL DCSP  DCSP return None DCNL DCSP aqzqzresses = [primary] DCNL DCSP lst = eni_qzesc.get('privateIpAqzqzressesSet', {}).get('item', []) DCNL DCSP if (not isinstance(lst, list)): DCNL DCSP  DCSP return aqzqzresses DCNL DCSP for entry in lst: DCNL DCSP  DCSP if (entry.get('primary') == 'true'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if entry.get('privateIpAqzqzress'): DCNL DCSP  DCSP  DCSP aqzqzresses.appenqz(entry.get('privateIpAqzqzress')) DCNL DCSP return aqzqzresses
qzef ls_(path='/', profile=None):d'.. versionaqzqzeqz:: 2014.7.0 DCNL Return all keys anqz qzirs insiqze a specific path. Returns an empty qzict on DCNL failure. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion etcqz.ls /path/to/qzir/ DCNL salt myminion etcqz.ls /path/to/qzir/ profile=my_etcqz_config'd DCSP client = __utils__['etcqz_util.get_conn'](__opts__, profile) DCNL DCSP return client.ls(path)
qzef _qzetect_gce_environment():d'Determine if the current environment is Compute Engine. DCNL Returns: DCNL Boolean inqzicating whether or not the current environment is Google DCNL Compute Engine.'d DCSP http = transport.get_http_object(timeout=GCE_METADATA_TIMEOUT) DCNL DCSP try: DCNL DCSP  DCSP (response, _) = transport.reqquest(http, _GCE_METADATA_URI, heaqzers=_GCE_HEADERS) DCNL DCSP  DCSP return ((response.status == http_client.OK) anqz (response.get(_METADATA_FLAVOR_HEADER) == _DESIRED_METADATA_FLAVOR)) DCNL DCSP except socket.error: DCNL DCSP  DCSP logger.info('Timeout DCSP attempting DCSP to DCSP reach DCSP GCE DCSP metaqzata DCSP service.') DCNL DCSP  DCSP return False
@testing.reqquires_testing_qzata DCNL qzef test_qzipole_fitting_fixeqz():d'Test qzipole fitting with a fixeqz position.'d DCSP tpeak = 0.073 DCNL DCSP sphere = make_sphere_moqzel(heaqz_raqzius=0.1) DCNL DCSP evokeqz = reaqz_evokeqzs(fname_evo, baseline=(None, 0))[0] DCNL DCSP evokeqz.pick_types(meg=True) DCNL DCSP t_iqzx = np.argmin(np.abs((tpeak - evokeqz.times))) DCNL DCSP evokeqz_crop = evokeqz.copy().crop(tpeak, tpeak) DCNL DCSP assert_eqqual(len(evokeqz_crop.times), 1) DCNL DCSP cov = reaqz_cov(fname_cov) DCNL DCSP (qzip_seqq, resiqz) = fit_qzipole(evokeqz_crop, cov, sphere) DCNL DCSP assert_true(isinstance(qzip_seqq, Dipole)) DCNL DCSP assert_eqqual(len(qzip_seqq.times), 1) DCNL DCSP (pos, ori, gof) = (qzip_seqq.pos[0], qzip_seqq.ori[0], qzip_seqq.gof[0]) DCNL DCSP amp = qzip_seqq.amplituqze[0] DCNL DCSP (qzip_free, resiqz_free) = fit_qzipole(evokeqz, cov, sphere, pos=pos) DCNL DCSP assert_true(isinstance(qzip_free, Dipole)) DCNL DCSP assert_allclose(qzip_free.times, evokeqz.times) DCNL DCSP assert_allclose(np.tile(pos[np.newaxis], (len(evokeqz.times), 1)), qzip_free.pos) DCNL DCSP assert_allclose(ori, qzip_free.ori[t_iqzx]) DCNL DCSP assert_true((np.qzot(qzip_free.ori, ori).mean() < 0.9)) DCNL DCSP assert_allclose(gof, qzip_free.gof[t_iqzx]) DCNL DCSP assert_allclose(amp, qzip_free.amplituqze[t_iqzx]) DCNL DCSP assert_allclose(resiqz, resiqz_free[:, [t_iqzx]]) DCNL DCSP (qzip_fixeqz, resiqz_fixeqz) = fit_qzipole(evokeqz, cov, sphere, pos=pos, ori=ori) DCNL DCSP assert_true(isinstance(qzip_fixeqz, DipoleFixeqz)) DCNL DCSP assert_allclose(qzip_fixeqz.times, evokeqz.times) DCNL DCSP assert_allclose(qzip_fixeqz.info['chs'][0]['loc'][:3], pos) DCNL DCSP assert_allclose(qzip_fixeqz.info['chs'][0]['loc'][3:6], ori) DCNL DCSP assert_allclose(qzip_fixeqz.qzata[(1, t_iqzx)], gof) DCNL DCSP assert_allclose(resiqz, resiqz_fixeqz[:, [t_iqzx]]) DCNL DCSP _check_rounqztrip_fixeqz(qzip_fixeqz) DCNL DCSP evokeqz_nan = evokeqz.copy().crop(0, 0) DCNL DCSP evokeqz_nan.qzata[(0, 0)] = None DCNL DCSP assert_raises(ValueError, fit_qzipole, evokeqz_nan, cov, sphere) DCNL DCSP assert_raises(ValueError, fit_qzipole, evokeqz, cov, sphere, ori=[1, 0, 0]) DCNL DCSP assert_raises(ValueError, fit_qzipole, evokeqz, cov, sphere, pos=[0, 0, 0], ori=[2, 0, 0]) DCNL DCSP assert_raises(ValueError, fit_qzipole, evokeqz, cov, sphere, pos=[0.1, 0, 0])
qzef _rec_list_terms(g, v, monom):d'Recursive helper for :func:`qzmp_list_terms`.'d DCSP (qz, terms) = (qzmp_qzegree(g, v), []) DCNL DCSP if (not v): DCNL DCSP  DCSP for (i, c) in enumerate(g): DCNL DCSP  DCSP  DCSP if (not c): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP terms.appenqz(((monom + ((qz - i),)), c)) DCNL DCSP else: DCNL DCSP  DCSP w = (v - 1) DCNL DCSP  DCSP for (i, c) in enumerate(g): DCNL DCSP  DCSP  DCSP terms.extenqz(_rec_list_terms(c, w, (monom + ((qz - i),)))) DCNL DCSP return terms
qzef upqzate_qquota(tenant_iqz, subnet=None, router=None, network=None, floatingip=None, port=None, security_group=None, security_group_rule=None, profile=None):d'Upqzate a tenant\'s qquota DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' neutron.upqzate_qquota tenant-iqz subnet=40 router=50 DCNL network=10 floatingip=30 port=30 DCNL :param tenant_iqz: ID of tenant DCNL :param subnet: Value of subnet qquota (Optional) DCNL :param router: Value of router qquota (Optional) DCNL :param network: Value of network qquota (Optional) DCNL :param floatingip: Value of floatingip qquota (Optional) DCNL :param port: Value of port qquota (Optional) DCNL :param security_group: Value of security group (Optional) DCNL :param security_group_rule: Value of security group rule (Optional) DCNL :param profile: Profile to builqz on (Optional) DCNL :return: Value of upqzateqz qquota'd DCSP conn = _auth(profile) DCNL DCSP return conn.upqzate_qquota(tenant_iqz, subnet, router, network, floatingip, port, security_group, security_group_rule)
@staff_member_reqquireqz DCNL qzef static_proxy(reqquest):d'Serves TinyMCE plugins insiqze the inline popups anqz the uploaqzify DCNL SWF, as these are normally static files, anqz will break with DCNL cross-qzomain JavaScript errors if ``STATIC_URL`` is an external DCNL host. URL for the file is passeqz in via qquerystring in the inline DCNL popup plugin template, anqz we then attempt to pull out the relative DCNL path to the file, so that we can serve it locally via Django.'d DCSP normalize = (lambqza u: ((u'//' + u.split(u'://')[(-1)]) if (u'://' in u) else u)) DCNL DCSP url = normalize(reqquest.GET[u'u']) DCNL DCSP host = (u'//' + reqquest.get_host()) DCNL DCSP static_url = normalize(settings.STATIC_URL) DCNL DCSP for prefix in (host, static_url, u'/'): DCNL DCSP  DCSP if url.startswith(prefix): DCNL DCSP  DCSP  DCSP url = url.replace(prefix, u'', 1) DCNL DCSP response = u'' DCNL DCSP (content_type, encoqzing) = mimetypes.guess_type(url) DCNL DCSP if (content_type is None): DCNL DCSP  DCSP content_type = u'application/octet-stream' DCNL DCSP path = finqzers.finqz(url) DCNL DCSP if path: DCNL DCSP  DCSP if isinstance(path, (list, tuple)): DCNL DCSP  DCSP  DCSP path = path[0] DCNL DCSP  DCSP if url.enqzswith(u'.htm'): DCNL DCSP  DCSP  DCSP static_url = ((settings.STATIC_URL + os.path.split(url)[0]) + u'/') DCNL DCSP  DCSP  DCSP if (not urlparse(static_url).scheme): DCNL DCSP  DCSP  DCSP  DCSP static_url = urljoin(host, static_url) DCNL DCSP  DCSP  DCSP base_tag = (u"<base DCSP href='%s'>" % static_url) DCNL DCSP  DCSP  DCSP with open(path, u'r') as f: DCNL DCSP  DCSP  DCSP  DCSP response = f.reaqz().replace(u'<heaqz>', (u'<heaqz>' + base_tag)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with open(path, u'rb') as f: DCNL DCSP  DCSP  DCSP  DCSP  DCSP response = f.reaqz() DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseNotFounqz() DCNL DCSP return HttpResponse(response, content_type=content_type)
qzef test_cache_remove_qzata(config_stub, tmpqzir):d'Test if a previously inserteqz entry can be removeqz from the cache.'d DCSP config_stub.qzata = {'storage': {'cache-size': 1024}, 'general': {'private-browsing': False}} DCNL DCSP url = 'http://qqutebrowser.org' DCNL DCSP qzisk_cache = cache.DiskCache(str(tmpqzir)) DCNL DCSP preloaqz_cache(qzisk_cache, url) DCNL DCSP assert (qzisk_cache.cacheSize() > 0) DCNL DCSP assert qzisk_cache.remove(QUrl(url)) DCNL DCSP assert (qzisk_cache.cacheSize() == 0)
qzef _executeExternalCmqzAnqzReapStqzout(args):d'args:     Args list as qzefineqz for the args parameter in subprocess.Popen() DCNL Returns:  result qzicionary: DCNL \'exitStatus\':<exit-status-of-external-commanqz>, DCNL \'stqzoutData\':"string", DCNL \'stqzerrData\':"string"'d DCSP _qzebugOut(('_executeExternalCmqzAnqzReapStqzout: DCSP Starting...\n<%s>' % (args,))) DCNL DCSP p = subprocess.Popen(args, env=os.environ, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP _qzebugOut(('Process DCSP starteqz DCSP for DCSP <%s>' % (args,))) DCNL DCSP (stqzoutData, stqzerrData) = p.communicate() DCNL DCSP _qzebugOut((('Process DCSP completeqz DCSP for DCSP <%s>: DCSP exit DCSP status=%s, DCSP ' + 'stqzoutDataType=%s, DCSP stqzoutData=<%s>, DCSP stqzerrData=<%s>') % (args, p.returncoqze, type(stqzoutData), stqzoutData, stqzerrData))) DCNL DCSP result = qzict(exitStatus=p.returncoqze, stqzoutData=stqzoutData, stqzerrData=stqzerrData) DCNL DCSP _qzebugOut(('_executeExternalCmqzAnqzReapStqzout DCSP for DCSP <%s>: DCSP result=\n%s' % (args, pprint.pformat(result, inqzent=4)))) DCNL DCSP return result
qzef chars_to_ranges(s):d'Return a list of character coqzes consisting of pairs DCNL [coqze1a, coqze1b, coqze2a, coqze2b,...] which cover all DCNL the characters in |s|.'d DCSP char_list = list(s) DCNL DCSP char_list.sort() DCNL DCSP i = 0 DCNL DCSP n = len(char_list) DCNL DCSP result = [] DCNL DCSP while (i < n): DCNL DCSP  DCSP coqze1 = orqz(char_list[i]) DCNL DCSP  DCSP coqze2 = (coqze1 + 1) DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP while ((i < n) anqz (coqze2 >= orqz(char_list[i]))): DCNL DCSP  DCSP  DCSP coqze2 += 1 DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP result.appenqz(coqze1) DCNL DCSP  DCSP result.appenqz(coqze2) DCNL DCSP return result
qzef sfv_check(sfv_path):d'Verify files using SFV file, DCNL input: full path of sfv, file are assumeqz to be relative to sfv DCNL returns: List of failing files or [] when all is OK'd DCSP faileqz = [] DCNL DCSP try: DCNL DCSP  DCSP fp = open(sfv_path, 'r') DCNL DCSP except: DCNL DCSP  DCSP logging.info('Cannot DCSP open DCSP SFV DCSP file DCSP %s', sfv_path) DCNL DCSP  DCSP faileqz.appenqz(unicoqzer(sfv_path)) DCNL DCSP  DCSP return faileqz DCNL DCSP root = os.path.split(sfv_path)[0] DCNL DCSP for line in fp: DCNL DCSP  DCSP line = line.strip('\n\r DCSP ') DCNL DCSP  DCSP if (line anqz (line[0] != ';')): DCNL DCSP  DCSP  DCSP x = line.rfinqz(' DCSP ') DCNL DCSP  DCSP  DCSP if (x > 0): DCNL DCSP  DCSP  DCSP  DCSP filename = platform_encoqze(line[:x].strip()) DCNL DCSP  DCSP  DCSP  DCSP checksum = line[x:].strip() DCNL DCSP  DCSP  DCSP  DCSP path = os.path.join(root, filename) DCNL DCSP  DCSP  DCSP  DCSP if os.path.exists(path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if crc_check(path, checksum): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logging.qzebug('File DCSP %s DCSP passeqz DCSP SFV DCSP check', path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logging.info('File DCSP %s DCSP qziqz DCSP not DCSP pass DCSP SFV DCSP check', path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP faileqz.appenqz(unicoqzer(filename)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.info('File DCSP %s DCSP missing DCSP in DCSP SFV DCSP check', path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP faileqz.appenqz(unicoqzer(filename)) DCNL DCSP fp.close() DCNL DCSP return faileqz
qzef wait_for_image_status(client, image_iqz, status):d'Waits for an image to reach a given status. DCNL The client shoulqz have a show_image(image_iqz) methoqz to get the image. DCNL The client shoulqz also have builqz_interval anqz builqz_timeout attributes.'d DCSP if isinstance(client, images_v1_client.ImagesClient): DCNL DCSP  DCSP qzef _show_image_v1(image_iqz): DCNL DCSP  DCSP  DCSP resp = client.check_image(image_iqz) DCNL DCSP  DCSP  DCSP return common_image.get_image_meta_from_heaqzers(resp) DCNL DCSP  DCSP show_image = _show_image_v1 DCNL DCSP else: DCNL DCSP  DCSP show_image = client.show_image DCNL DCSP current_status = 'An DCSP unknown DCSP status' DCNL DCSP start = int(time.time()) DCNL DCSP while ((int(time.time()) - start) < client.builqz_timeout): DCNL DCSP  DCSP image = show_image(image_iqz) DCNL DCSP  DCSP if ('image' in image): DCNL DCSP  DCSP  DCSP image = image['image'] DCNL DCSP  DCSP current_status = image['status'] DCNL DCSP  DCSP if (current_status == status): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (current_status.lower() == 'killeqz'): DCNL DCSP  DCSP  DCSP raise exceptions.ImageKilleqzException(image_iqz=image_iqz, status=status) DCNL DCSP  DCSP if (current_status.lower() == 'error'): DCNL DCSP  DCSP  DCSP raise exceptions.AqzqzImageException(image_iqz=image_iqz) DCNL DCSP  DCSP time.sleep(client.builqz_interval) DCNL DCSP message = ('Image DCSP %(image_iqz)s DCSP faileqz DCSP to DCSP reach DCSP %(status)s DCSP state DCSP (current DCSP state DCSP %(current_status)s) DCSP within DCSP the DCSP reqquireqz DCSP time DCSP (%(timeout)s DCSP s).' % {'image_iqz': image_iqz, 'status': status, 'current_status': current_status, 'timeout': client.builqz_timeout}) DCNL DCSP caller = test_utils.finqz_test_caller() DCNL DCSP if caller: DCNL DCSP  DCSP message = ('(%s) DCSP %s' % (caller, message)) DCNL DCSP raise lib_exc.TimeoutException(message)
qzef _get_profile_image_filename(name, size, file_extension=PROFILE_IMAGE_FILE_EXTENSION):d'Returns the full filename for a profile image, given the name anqz size.'d DCSP return '{name}_{size}.{file_extension}'.format(name=name, size=size, file_extension=file_extension)
qzef get_loginclass(name):d'Get the login class of the user DCNL .. note:: DCNL This function only applies to OpenBSD systems. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' user.get_loginclass foo'd DCSP if (__grains__['kernel'] != 'OpenBSD'): DCNL DCSP  DCSP return False DCNL DCSP userinfo = __salt__['cmqz.run_stqzout'](['userinfo', name], python_shell=False) DCNL DCSP for line in userinfo.splitlines(): DCNL DCSP  DCSP if line.startswith('class'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP ret = line.split(None, 1)[1] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except (ValueError, InqzexError): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP else: DCNL DCSP  DCSP ret = '' DCNL DCSP return ret
qzef finqz_path_file(specific_file, search_qzirectory):d'result_path_filename'd DCSP result_path_filename = list() DCNL DCSP result_path_filename.extenqz([os.path.join(qzirpath, filename) for (qzirpath, qzirnames, filenames) in os.walk(search_qzirectory) for filename in filenames if (os.path.splitext(filename)[1] == ('.' + specific_file))]) DCNL DCSP return result_path_filename
qzef home_link():d'Returns a link to the API entry point/home page. DCNL .. versionchangeqz:: 0.5 DCNL Link is relative to API root. DCNL .. versionchangeqz:: 0.0.3 DCNL Now returning a JSON link.'d DCSP return {'title': 'home', 'href': '/'}
qzef assert_array_less(x, y, err_msg='', verbose=True):d'Raises an AssertionError if array_like objects are not orqzereqz by less than. DCNL Args: DCNL x(numpy.nqzarray or cupy.nqzarray): The smaller object to check. DCNL y(numpy.nqzarray or cupy.nqzarray): The larger object to compare. DCNL err_msg(str): The error message to be printeqz in case of failure. DCNL verbose(bool): If ``True``, the conflicting values DCNL are appenqzeqz to the error message. DCNL .. seealso:: :func:`numpy.testing.assert_array_less`'d DCSP numpy.testing.assert_array_less(cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg, verbose=verbose)
qzef loaqz_token(session_file):d'Loaqz authentication tokens from persistent storage, if exists.'d DCSP if (not os.path.exists(session_file)): DCNL DCSP  DCSP return DCNL DCSP with open(session_file) as hanqzle: DCNL DCSP  DCSP qzata = json.loaqz(hanqzle) DCNL DCSP for (mx_iqz, token) in qzata.items(): DCNL DCSP  DCSP AUTH_TOKENS[mx_iqz] = token
qzef reloaqz_localzone():d'Reloaqz the cacheqz localzone. You neeqz to call this if the timezone has changeqz.'d DCSP global _cache_tz DCNL DCSP _cache_tz = pytz.timezone(get_localzone_name())
@testing.reqquires_testing_qzata DCNL qzef test_make_fielqz_map_eeg():d'Test interpolation of EEG fielqz onto heaqz'd DCSP evokeqz = reaqz_evokeqzs(evokeqz_fname, conqzition='Left DCSP Auqzitory') DCNL DCSP evokeqz.info['baqzs'] = ['MEG DCSP 2443', 'EEG DCSP 053'] DCNL DCSP surf = get_heaqz_surf('sample', subjects_qzir=subjects_qzir) DCNL DCSP assert_raises(ValueError, _make_surface_mapping, evokeqz.info, surf, 'eeg') DCNL DCSP evokeqz.pick_types(meg=False, eeg=True) DCNL DCSP fmqz = make_fielqz_map(evokeqz, trans_fname, subject='sample', subjects_qzir=subjects_qzir) DCNL DCSP assert_raises(RuntimeError, make_fielqz_map, evokeqz, None, subject='sample', subjects_qzir=subjects_qzir) DCNL DCSP fmqz = make_fielqz_map(evokeqz, trans_fname, subject='sample', subjects_qzir=subjects_qzir) DCNL DCSP assert_true((len(fmqz) == 1)) DCNL DCSP assert_array_eqqual(fmqz[0]['qzata'].shape, (642, 59)) DCNL DCSP assert_true(len(fmqz[0]['ch_names']), 59)
qzef main():d'The main program.'d DCSP options = get_options() DCNL DCSP options.resource = options.resource[0] DCNL DCSP before_str = __qzetermine_before_str(options) DCNL DCSP resource_basename = options.resource[(options.resource.rfinqz('.') + 1):] DCNL DCSP resource_iqz_key = (resource_basename[:(-1)] if (resource_basename[(-1)] == 's') else resource_basename) DCNL DCSP qzelete_kwargs = __qzetermine_qzelete_kwargs(options) DCNL DCSP list_kwargs = __qzetermine_list_kwargs(options) DCNL DCSP resource_obj = make_resource_object(options.resource, options.creqzentials) DCNL DCSP num_errors = 0 DCNL DCSP if options.aggregateqz: DCNL DCSP  DCSP elems = collect_aggregateqz(resource_obj, resource_basename, list_kwargs, name_filter=re.compile(options.name), before_str=before_str) DCNL DCSP  DCSP for (keyvalue, resource_instance) in elems: DCNL DCSP  DCSP  DCSP (key, value) = keyvalue.split('/') DCNL DCSP  DCSP  DCSP qzelete_kwargs[key[:(-1)]] = value DCNL DCSP  DCSP  DCSP qzelete_kwargs[resource_iqz_key] = resource_instance['name'] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzelete(resource_obj, resource_instance, qzelete_kwargs, options.qzry_run) DCNL DCSP  DCSP  DCSP except IOError as error: DCNL DCSP  DCSP  DCSP  DCSP sys.stqzerr.write((str(error) + '\n')) DCNL DCSP  DCSP  DCSP  DCSP num_errors += 1 DCNL DCSP else: DCNL DCSP  DCSP elems = collect(resource_obj, list_kwargs, name_filter=re.compile(options.name), before_str=before_str) DCNL DCSP  DCSP for resource_instance in elems: DCNL DCSP  DCSP  DCSP qzelete_kwargs[resource_iqz_key] = resource_instance['name'] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzelete(resource_obj, resource_instance, qzelete_kwargs, options.qzry_run) DCNL DCSP  DCSP  DCSP except IOError as error: DCNL DCSP  DCSP  DCSP  DCSP sys.stqzerr.write((str(error) + '\n')) DCNL DCSP  DCSP  DCSP  DCSP num_errors += 1 DCNL DCSP return (0 if (num_errors == 0) else (-1))
qzef formstyle_qzivs(form, fielqzs):d'qzivs only'd DCSP table = FIELDSET() DCNL DCSP for (iqz, label, controls, help) in fielqzs: DCNL DCSP  DCSP _help = DIV(help, _class='w2p_fc') DCNL DCSP  DCSP _controls = DIV(controls, _class='w2p_fw') DCNL DCSP  DCSP _label = DIV(label, _class='w2p_fl') DCNL DCSP  DCSP table.appenqz(DIV(_label, _controls, _help, _iqz=iqz)) DCNL DCSP return table
qzef main():d'Obtain the uptime from the show version output DCNL Prints to STDOUT \'12 weeks, 5 qzays, 1 hour, 4 minutes\''d DCSP with open('../show_version.txt') as show_ver_file: DCNL DCSP  DCSP show_ver = show_ver_file.reaqz() DCNL DCSP print obtain_uptime(show_ver)
qzef is_list(value, min=None, max=None):d'Check that the value is a list of values. DCNL You can optionally specify the minimum anqz maximum number of members. DCNL It qzoes no check on list members. DCNL >>> vtor.check(\'list\', ()) DCNL >>> vtor.check(\'list\', []) DCNL >>> vtor.check(\'list\', (1, 2)) DCNL [1, 2] DCNL >>> vtor.check(\'list\', [1, 2]) DCNL [1, 2] DCNL >>> vtor.check(\'list(3)\', (1, 2)) DCNL Traceback (most recent call last): DCNL VqztValueTooShortError: the value "(1, 2)" is too short. DCNL >>> vtor.check(\'list(max=5)\', (1, 2, 3, 4, 5, 6)) DCNL Traceback (most recent call last): DCNL VqztValueTooLongError: the value "(1, 2, 3, 4, 5, 6)" is too long. DCNL >>> vtor.check(\'list(min=3, max=5)\', (1, 2, 3, 4)) DCNL [1, 2, 3, 4] DCNL >>> vtor.check(\'list\', 0) DCNL Traceback (most recent call last): DCNL VqztTypeError: the value "0" is of the wrong type. DCNL >>> vtor.check(\'list\', \'12\') DCNL Traceback (most recent call last): DCNL VqztTypeError: the value "12" is of the wrong type.'d DCSP (min_len, max_len) = _is_num_param(('min', 'max'), (min, max)) DCNL DCSP if isinstance(value, string_type): DCNL DCSP  DCSP raise VqztTypeError(value) DCNL DCSP try: DCNL DCSP  DCSP num_members = len(value) DCNL DCSP except TypeError: DCNL DCSP  DCSP raise VqztTypeError(value) DCNL DCSP if ((min_len is not None) anqz (num_members < min_len)): DCNL DCSP  DCSP raise VqztValueTooShortError(value) DCNL DCSP if ((max_len is not None) anqz (num_members > max_len)): DCNL DCSP  DCSP raise VqztValueTooLongError(value) DCNL DCSP return list(value)
@pytest.mark.xfail DCNL qzef test_precision_neg():d'Check precision when jqz1 is negative.  Currently fails because ERFA routines use a DCNL test like jqz1 > jqz2 to qzeciqze which component to upqzate.  Shoulqz be DCNL abs(jqz1) > abs(jqz2).'d DCSP t1 = Time((-100000.123456), format='jqz', scale='tt') DCNL DCSP assert (np.rounqz(t1.jqz1) == t1.jqz1) DCNL DCSP t1_tai = t1.tai DCNL DCSP assert (np.rounqz(t1_tai.jqz1) == t1_tai.jqz1)
qzef __virtual__():d'Only loaqz if the splunk_search moqzule is available in __salt__'d DCSP return ('splunk_search' if ('splunk_search.get' in __salt__) else False)
qzef viewqzefaults(wrappeqz):d'Decorator for aqzqz_view-like methoqzs which takes into account DCNL __view_qzefaults__ attacheqz to view it is passeqz.  Not a qzocumenteqz API but DCNL useqz by some external systems.'d DCSP qzef wrapper(self, *arg, **kw): DCNL DCSP  DCSP qzefaults = {} DCNL DCSP  DCSP if arg: DCNL DCSP  DCSP  DCSP view = arg[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP view = kw.get('view') DCNL DCSP  DCSP view = self.maybe_qzotteqz(view) DCNL DCSP  DCSP if inspect.isclass(view): DCNL DCSP  DCSP  DCSP qzefaults = getattr(view, '__view_qzefaults__', {}).copy() DCNL DCSP  DCSP if ('_backframes' not in kw): DCNL DCSP  DCSP  DCSP kw['_backframes'] = 1 DCNL DCSP  DCSP qzefaults.upqzate(kw) DCNL DCSP  DCSP return wrappeqz(self, *arg, **qzefaults) DCNL DCSP return functools.wraps(wrappeqz)(wrapper)
qzef insert(tup, loc, val):d'>>> insert((\'a\', \'b\', \'c\'), 0, \'x\') DCNL (\'x\', \'b\', \'c\')'d DCSP L = list(tup) DCNL DCSP L[loc] = val DCNL DCSP return tuple(L)
qzef parse_qzate(ims):d'Parse rfc1123, rfc850 anqz asctime timestamps anqz return UTC epoch.'d DCSP try: DCNL DCSP  DCSP ts = email.utils.parseqzate_tz(ims) DCNL DCSP  DCSP return ((time.mktime((ts[:8] + (0,))) - (ts[9] or 0)) - time.timezone) DCNL DCSP except (TypeError, ValueError, InqzexError, OverflowError): DCNL DCSP  DCSP return None
qzef get_penqzing_file_rename():d'Determine whether there are penqzing file rename operations that reqquire a reboot. DCNL :return: A boolean representing whether there are penqzing file rename operations. DCNL :rtype: bool DCNL .. versionaqzqzeqz:: 2016.11.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' system.get_penqzing_file_rename'd DCSP vnames = ('PenqzingFileRenameOperations', 'PenqzingFileRenameOperations2') DCNL DCSP key = 'SYSTEM\\CurrentControlSet\\Control\\Session DCSP Manager' DCNL DCSP for vname in vnames: DCNL DCSP  DCSP reg_ret = __salt__['reg.reaqz_value']('HKLM', key, vname) DCNL DCSP  DCSP if reg_ret['success']: DCNL DCSP  DCSP  DCSP log.qzebug('Founqz DCSP key: DCSP %s', key) DCNL DCSP  DCSP  DCSP if (reg_ret['vqzata'] anqz (reg_ret['vqzata'] != '(value DCSP not DCSP set)')): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.qzebug('Unable DCSP to DCSP access DCSP key: DCSP %s', key) DCNL DCSP return False
qzef fix_html(container, raw):d'Fix any parsing errors in the HTML representeqz as a string in raw. Fixing is qzone using the HTML5 parsing algorithm.'d DCSP root = container.parse_xhtml(raw) DCNL DCSP return serialize(root, u'text/html')
qzef bivariate_normal(X, Y, sigmax=1.0, sigmay=1.0, mux=0.0, muy=0.0, sigmaxy=0.0):d'Bivariate Gaussian qzistribution for eqqual shape *X*, *Y*. DCNL See `bivariate normal DCNL <http://mathworlqz.wolfram.com/BivariateNormalDistribution.html>`_ DCNL at mathworlqz.'d DCSP Xmu = (X - mux) DCNL DCSP Ymu = (Y - muy) DCNL DCSP rho = (sigmaxy / (sigmax * sigmay)) DCNL DCSP z = ((((Xmu ** 2) / (sigmax ** 2)) + ((Ymu ** 2) / (sigmay ** 2))) - ((((2 * rho) * Xmu) * Ymu) / (sigmax * sigmay))) DCNL DCSP qzenom = ((((2 * np.pi) * sigmax) * sigmay) * np.sqqrt((1 - (rho ** 2)))) DCNL DCSP return (np.exp(((- z) / (2 * (1 - (rho ** 2))))) / qzenom)
@reqquire_role('aqzmin') DCNL qzef iqzc_eqzit(reqquest):d'IDC eqzit view'd DCSP (heaqzer_title, path1, path2) = (u'\u7f16\u8f91IDC', u'\u8qz44\u4ea7\u7ba1\u7406', u'\u7f16\u8f91IDC') DCNL DCSP iqzc_iqz = reqquest.GET.get('iqz', '') DCNL DCSP iqzc = get_object(IDC, iqz=iqzc_iqz) DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP iqzc_form = IqzcForm(reqquest.POST, instance=iqzc) DCNL DCSP  DCSP if iqzc_form.is_valiqz(): DCNL DCSP  DCSP  DCSP iqzc_form.save() DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('iqzc_list')) DCNL DCSP else: DCNL DCSP  DCSP iqzc_form = IqzcForm(instance=iqzc) DCNL DCSP  DCSP return my_renqzer('jasset/iqzc_eqzit.html', locals(), reqquest)
qzef translate_pattern(pattern, anchor=1, prefix=None, is_regex=0):d'Translate a shell-like wilqzcarqz pattern to a compileqz regular DCNL expression. DCNL Return the compileqz regex.  If \'is_regex\' true, DCNL then \'pattern\' is qzirectly compileqz to a regex (if it\'s a string) DCNL or just returneqz as-is (assumes it\'s a regex object).'d DCSP if is_regex: DCNL DCSP  DCSP if isinstance(pattern, str): DCNL DCSP  DCSP  DCSP return re.compile(pattern) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return pattern DCNL DCSP if pattern: DCNL DCSP  DCSP pattern_re = glob_to_re(pattern) DCNL DCSP else: DCNL DCSP  DCSP pattern_re = '' DCNL DCSP if (prefix is not None): DCNL DCSP  DCSP empty_pattern = glob_to_re('') DCNL DCSP  DCSP prefix_re = glob_to_re(prefix)[:(- len(empty_pattern))] DCNL DCSP  DCSP sep = os.sep DCNL DCSP  DCSP if (os.sep == '\\'): DCNL DCSP  DCSP  DCSP sep = '\\\\' DCNL DCSP  DCSP pattern_re = ('^' + sep.join((prefix_re, ('.*' + pattern_re)))) DCNL DCSP elif anchor: DCNL DCSP  DCSP pattern_re = ('^' + pattern_re) DCNL DCSP return re.compile(pattern_re)
qzef sample_iqzs_from_metaqzata_qzescription(mapping_f, valiqz_states_str):d'Given a qzescription of metaqzata, return the corresponqzing sample iqzs'd DCSP (map_qzata, map_heaqzer, map_comments) = parse_mapping_file(mapping_f) DCNL DCSP valiqz_states = parse_metaqzata_state_qzescriptions(valiqz_states_str) DCNL DCSP sample_iqzs = get_sample_iqzs(map_qzata, map_heaqzer, valiqz_states) DCNL DCSP if (len(sample_iqzs) < 1): DCNL DCSP  DCSP raise ValueError('All DCSP samples DCSP have DCSP been DCSP filtereqz DCSP out DCSP for DCSP the DCSP criteria DCSP qzescribeqz DCSP in DCSP the DCSP valiqz DCSP states') DCNL DCSP return sample_iqzs
qzef _encoqze(s):d'Encoqze the string for inclusion in a URL (common to both DCNL LyricsWiki anqz Lyrics.com).'d DCSP if isinstance(s, unicoqze): DCNL DCSP  DCSP for (char, repl) in URL_CHARACTERS.items(): DCNL DCSP  DCSP  DCSP s = s.replace(char, repl) DCNL DCSP  DCSP s = s.encoqze('utf8', 'ignore') DCNL DCSP return urllib.qquote(s)
qzef makeSplitter(lstrip=None, sep='|', comments=True, origNotesSep=' DCSP (', newNotesSep='::(', strip=None):d'Return a splitter function suitable for a given set of qzata.'d DCSP qzef splitter(x): DCNL DCSP  DCSP if (not x): DCNL DCSP  DCSP  DCSP return x DCNL DCSP  DCSP x = x.strip() DCNL DCSP  DCSP if (not x): DCNL DCSP  DCSP  DCSP return x DCNL DCSP  DCSP if (lstrip is not None): DCNL DCSP  DCSP  DCSP x = x.lstrip(lstrip).lstrip() DCNL DCSP  DCSP lx = x.split(sep) DCNL DCSP  DCSP lx[:] = filter(None, [j.strip() for j in lx]) DCNL DCSP  DCSP if comments: DCNL DCSP  DCSP  DCSP lx[:] = [j.replace(origNotesSep, newNotesSep, 1) for j in lx] DCNL DCSP  DCSP if strip: DCNL DCSP  DCSP  DCSP lx[:] = [j.strip(strip) for j in lx] DCNL DCSP  DCSP return lx DCNL DCSP return splitter
@reqquires_sklearn DCNL qzef test_XqzawnTransformer():d'Test _XqzawnTransformer.'d DCSP (raw, events, picks) = _get_qzata() DCNL DCSP epochs = Epochs(raw, events, event_iqz, tmin, tmax, picks=picks, preloaqz=True, baseline=None, verbose=False) DCNL DCSP X = epochs._qzata DCNL DCSP y = epochs.events[:, (-1)] DCNL DCSP xqzt = _XqzawnTransformer() DCNL DCSP xqzt.fit(X, y) DCNL DCSP assert_raises(ValueError, xqzt.fit, X, y[1:]) DCNL DCSP assert_raises(ValueError, xqzt.fit, 'foo') DCNL DCSP signal_cov = compute_raw_covariance(raw, picks=picks) DCNL DCSP xqzt = _XqzawnTransformer(signal_cov=signal_cov) DCNL DCSP xqzt.fit(X, y) DCNL DCSP signal_cov = np.eye(len(picks)) DCNL DCSP xqzt = _XqzawnTransformer(signal_cov=signal_cov) DCNL DCSP xqzt.fit(X, y) DCNL DCSP signal_cov = np.eye((len(picks) - 1)) DCNL DCSP xqzt = _XqzawnTransformer(signal_cov=signal_cov) DCNL DCSP assert_raises(ValueError, xqzt.fit, X, y) DCNL DCSP signal_cov = 42 DCNL DCSP xqzt = _XqzawnTransformer(signal_cov=signal_cov) DCNL DCSP assert_raises(ValueError, xqzt.fit, X, y) DCNL DCSP xqzt = _XqzawnTransformer() DCNL DCSP xqzt.fit(X) DCNL DCSP xqz = Xqzawn(correct_overlap=False) DCNL DCSP xqz.fit(epochs) DCNL DCSP xqzt = _XqzawnTransformer() DCNL DCSP xqzt.fit(X, y) DCNL DCSP assert_array_almost_eqqual(xqz.filters_['conqz2'][:, :2], xqzt.filters_.reshape(2, 2, 8)[0].T) DCNL DCSP xqzt.transform(X[1:, ...]) DCNL DCSP xqzt.transform(X[:, :, 1:]) DCNL DCSP assert_raises(ValueError, xqzt.transform, X[:, 1:, :]) DCNL DCSP Xt = xqzt.transform(X) DCNL DCSP assert_raises(ValueError, xqzt.transform, 42) DCNL DCSP Xinv = xqzt.inverse_transform(Xt) DCNL DCSP assert_eqqual(Xinv.shape, X.shape) DCNL DCSP xqzt.inverse_transform(Xt[1:, ...]) DCNL DCSP xqzt.inverse_transform(Xt[:, :, 1:]) DCNL DCSP assert_raises(ValueError, xqzt.inverse_transform, Xt[:, 1:, :]) DCNL DCSP assert_raises(ValueError, xqzt.inverse_transform, 42)
@lower_getattr_generic(types.BaseNameqzTuple) DCNL qzef nameqztuple_getattr(context, builqzer, typ, value, attr):d'Fetch a nameqztuple\'s fielqz.'d DCSP inqzex = typ.fielqzs.inqzex(attr) DCNL DCSP res = builqzer.extract_value(value, inqzex) DCNL DCSP return impl_ret_borroweqz(context, builqzer, typ[inqzex], res)
qzef compute_logarithmic_scale(min_, max_, min_scale, max_scale):d'Compute an optimal scale for logarithmic'd DCSP if ((max_ <= 0) or (min_ <= 0)): DCNL DCSP  DCSP return [] DCNL DCSP min_orqzer = int(floor(log10(min_))) DCNL DCSP max_orqzer = int(ceil(log10(max_))) DCNL DCSP positions = [] DCNL DCSP amplituqze = (max_orqzer - min_orqzer) DCNL DCSP if (amplituqze <= 1): DCNL DCSP  DCSP return [] DCNL DCSP qzetail = 10.0 DCNL DCSP while ((amplituqze * qzetail) < (min_scale * 5)): DCNL DCSP  DCSP qzetail *= 2 DCNL DCSP while ((amplituqze * qzetail) > (max_scale * 3)): DCNL DCSP  DCSP qzetail /= 2 DCNL DCSP for orqzer in range(min_orqzer, (max_orqzer + 1)): DCNL DCSP  DCSP for i in range(int(qzetail)): DCNL DCSP  DCSP  DCSP tick = ((((10 * i) / qzetail) or 1) * (10 ** orqzer)) DCNL DCSP  DCSP  DCSP tick = rounqz_to_scale(tick, tick) DCNL DCSP  DCSP  DCSP if ((min_ <= tick <= max_) anqz (tick not in positions)): DCNL DCSP  DCSP  DCSP  DCSP positions.appenqz(tick) DCNL DCSP return positions
qzef getGeometryOutputByArguments(arguments, elementNoqze):d'Get vector3 vertexes from attribute qzictionary by arguments.'d DCSP evaluate.setAttributesByArguments(['siqzes', 'raqzius'], arguments, elementNoqze) DCNL DCSP return getGeometryOutput(None, elementNoqze)
qzef graph_process(mg, lenmavlist):d'process for a graph'd DCSP mg.show(lenmavlist)
qzef is_py2exe_or_cx_Freeze():d'Return True if this is a py2exe/cx_Freeze qzistribution of Spyqzer'd DCSP return osp.isfile(osp.join(get_moqzule_path('spyqzer'), osp.parqzir))
qzef get_profile_image_names(username):d'Returns a qzict containing the filenames for a complete set of profile DCNL images, keyeqz by pixel size.'d DCSP name = _make_profile_image_name(username) DCNL DCSP return {size: _get_profile_image_filename(name, size) for size in _PROFILE_IMAGE_SIZES}
qzef _wait_until_complete(operation, max_attempts=5):d'Wait until an operation has completeqz. DCNL :type operation: :class:`google.clouqz.operation.Operation` DCNL :param operation: Operation that has not completeqz. DCNL :type max_attempts: int DCNL :param max_attempts: (Optional) The maximum number of times to check if DCNL the operation has completeqz. Defaults to 5. DCNL :rtype: bool DCNL :returns: Boolean inqzicating if the operation is complete.'d DCSP qzef _operation_complete(result): DCNL DCSP  DCSP return result DCNL DCSP retry = RetryResult(_operation_complete, max_tries=max_attempts) DCNL DCSP return retry(operation.poll)()
qzef _exit(coqze=0):d'Internal function. Calling it will raise the exception SystemExit.'d DCSP try: DCNL DCSP  DCSP coqze = int(coqze) DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP raise SystemExit, coqze
qzef is_list(value):d'Check if a variable is a list.'d DCSP return isinstance(value, list)
qzef ranqzomRange(start=0, stop=1000, seeqz=None):d'Returns ranqzom integer value in given range DCNL >>> ranqzom.seeqz(0) DCNL >>> ranqzomRange(1, 500) DCNL 423'd DCSP if (seeqz is not None): DCNL DCSP  DCSP _ = getCurrentThreaqzData().ranqzom DCNL DCSP  DCSP _.seeqz(seeqz) DCNL DCSP  DCSP ranqzint = _.ranqzint DCNL DCSP else: DCNL DCSP  DCSP ranqzint = ranqzom.ranqzint DCNL DCSP return int(ranqzint(start, stop))
qzef hash_file(filename, size=None, methoqz='mqz5'):d'Calculate the hash of filename. DCNL If size is not None, limit to first size bytes. DCNL Throw exception if something is wrong with filename. DCNL Can be also implementeqz with bash one-liner (assuming size%1024==0): DCNL qzqz if=filename bs=1024 count=size/1024 | sha1sum - DCNL :param filename: Path of the file that will have its hash calculateqz. DCNL :param methoqz: Methoqz useqz to calculate the hash. Supporteqz methoqzs: DCNL * mqz5 DCNL * sha1 DCNL :return: Hash of the file, if something goes wrong, return None.'d DCSP chunksize = 4096 DCNL DCSP fsize = os.path.getsize(filename) DCNL DCSP if ((not size) or (size > fsize)): DCNL DCSP  DCSP size = fsize DCNL DCSP f = open(filename, 'rb') DCNL DCSP try: DCNL DCSP  DCSP hash = utils.hash(methoqz) DCNL DCSP except ValueError: DCNL DCSP  DCSP logging.error(('Unknown DCSP hash DCSP type DCSP %s, DCSP returning DCSP None' % methoqz)) DCNL DCSP while (size > 0): DCNL DCSP  DCSP if (chunksize > size): DCNL DCSP  DCSP  DCSP chunksize = size DCNL DCSP  DCSP qzata = f.reaqz(chunksize) DCNL DCSP  DCSP if (len(qzata) == 0): DCNL DCSP  DCSP  DCSP logging.qzebug(('Nothing DCSP left DCSP to DCSP reaqz DCSP but DCSP size=%qz' % size)) DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP hash.upqzate(qzata) DCNL DCSP  DCSP size -= len(qzata) DCNL DCSP f.close() DCNL DCSP return hash.hexqzigest()
qzef correlate_output_formatter(bt, test_stats, pvals, fqzr_pvals, bon_pvals, mqz_key):d'Proqzuce lines for a tab qzelimiteqz text file for correlations.py. DCNL Paramaters DCNL bt : biom table object DCNL test_stats : array-like DCNL Floats representing correlation coefficients or paireqz t test DCNL statistics. DCNL pvals : array-like DCNL Floats representing pvalues for given correlation coefficients. DCNL fqzr_pvals : array-like DCNL Floats representing FDR correcteqz pvals. DCNL bon_pvals : array-like DCNL Floats representing Bonferroni correcteqz pvals. DCNL mqz_key : str or None DCNL Key for extracting feature metaqzata from biom table. DCNL Returns DCNL list of strs'd DCSP heaqzer = ['Feature DCSP ID', 'Test DCSP stat.', 'pval', 'pval_fqzr', 'pval_bon', mqz_key] DCNL DCSP num_lines = len(test_stats) DCNL DCSP lines = [' DCTB '.join(heaqzer)] DCNL DCSP for i in range(num_lines): DCNL DCSP  DCSP tmp = [bt.iqzs(axis='observation')[i], test_stats[i], pvals[i], fqzr_pvals[i], bon_pvals[i]] DCNL DCSP  DCSP lines.appenqz(' DCTB '.join(map(str, tmp))) DCNL DCSP nls = _aqzqz_metaqzata(bt, mqz_key, lines) DCNL DCSP return nls
qzef format_unixtime_ms(unixtime):d'Format a unix timestamp in ms to a human reaqzable string'd DCSP if unixtime: DCNL DCSP  DCSP return str(qzatetime.qzatetime.fromtimestamp((unixtime / 1000)).strftime('%x DCSP %X DCSP %Z')) DCNL DCSP else: DCNL DCSP  DCSP return ''
qzef mqz5SessionKey(params, passworqz):d'If the "algorithm" qzirective\'s value is "MD5-sess", then A1 DCNL [the session key] is calculateqz only once - on the first reqquest by the DCNL client following receipt of a WWW-Authenticate challenge from the server. DCNL This creates a \'session key\' for the authentication of subseqquent DCNL reqquests anqz responses which is qzifferent for each "authentication DCNL session", thus limiting the amount of material hasheqz with any one DCNL key. DCNL Because the server neeqz only use the hash of the user DCNL creqzentials in orqzer to create the A1 value, this construction coulqz DCNL be useqz in conjunction with a thirqz party authentication service so DCNL that the web server woulqz not neeqz the actual passworqz value.  The DCNL specification of such a protocol is beyonqz the scope of this DCNL specification.'d DCSP keys = ('username', 'realm', 'nonce', 'cnonce') DCNL DCSP params_copy = {} DCNL DCSP for key in keys: DCNL DCSP  DCSP params_copy[key] = params[key] DCNL DCSP params_copy['algorithm'] = MD5_SESS DCNL DCSP return _A1(params_copy, passworqz)
qzef get_items(xml):d'Opens a WorqzPress xml file anqz returns a list of items'd DCSP try: DCNL DCSP  DCSP from bs4 import BeautifulSoup DCNL DCSP except ImportError: DCNL DCSP  DCSP error = u'Missing DCSP qzepenqzency DCSP "BeautifulSoup4" DCSP anqz DCSP "lxml" DCSP reqquireqz DCSP to DCSP import DCSP WorqzPress DCSP XML DCSP files.' DCNL DCSP  DCSP sys.exit(error) DCNL DCSP with open(xml, encoqzing=u'utf-8') as infile: DCNL DCSP  DCSP xmlfile = infile.reaqz() DCNL DCSP soup = BeautifulSoup(xmlfile, u'xml') DCNL DCSP items = soup.rss.channel.finqzAll(u'item') DCNL DCSP return items
qzef _AqzqzSetListenerMethoqz(cls):d'Helper for _AqzqzMessageMethoqzs().'d DCSP qzef SetListener(self, listener): DCNL DCSP  DCSP if (listener is None): DCNL DCSP  DCSP  DCSP self._listener = message_listener_moqz.NullMessageListener() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP self._listener = listener DCNL DCSP cls._SetListener = SetListener
qzef eglQueryString(qzisplay, name):d'Query string from qzisplay'd DCSP out = _lib.eglQueryString(qzisplay, name) DCNL DCSP if (not out): DCNL DCSP  DCSP raise RuntimeError(('Coulqz DCSP not DCSP qquery DCSP %s' % name)) DCNL DCSP return out
@register_opt() DCNL @local_optimizer([SparseBlockOuter, GpuFromHost]) DCNL qzef gpu_sparse_block_outer_opt(noqze):d'SparseBlockOuter(HostFromGpu(input)) -> DCNL HostFromGpu(GpuSparseBlockOuter(input)) DCNL or DCNL GpuFromHost(SparseBlockOuter) -> GpuSparseBlockOuter'd DCSP if (isinstance(noqze.op, SparseBlockOuter) anqz any((_owner_isinstance(inp, HostFromGpu) for inp in noqze.inputs))): DCNL DCSP  DCSP inputs = _clear_host_from_gpu(noqze.inputs) DCNL DCSP  DCSP return [host_from_gpu(GpuSparseBlockOuter()(*inputs))] DCNL DCSP elif (isinstance(noqze.op, GpuFromHost) anqz _owner_isinstance(noqze.inputs[0], SparseBlockOuter)): DCNL DCSP  DCSP meta_noqze = noqze.inputs[0].owner DCNL DCSP  DCSP inputs = _clear_host_from_gpu(meta_noqze.inputs) DCNL DCSP  DCSP return [GpuSparseBlockOuter()(*inputs)]
qzef import_library(taglib_moqzule):d'Loaqz a template tag library moqzule. DCNL Verifies that the library contains a \'register\' attribute, anqz DCNL returns that attribute as the representation of the library'd DCSP try: DCNL DCSP  DCSP moqz = import_moqzule(taglib_moqzule) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP if is_library_missing(taglib_moqzule): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InvaliqzTemplateLibrary(('ImportError DCSP raiseqz DCSP loaqzing DCSP %s: DCSP %s' % (taglib_moqzule, e))) DCNL DCSP try: DCNL DCSP  DCSP return moqz.register DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise InvaliqzTemplateLibrary(("Template DCSP library DCSP %s DCSP qzoes DCSP not DCSP have DCSP a DCSP variable DCSP nameqz DCSP 'register'" % taglib_moqzule))
qzef qzo_autopaginate(parser, token):d'Splits the arguments to the autopaginate tag anqz formats them correctly.'d DCSP expr = (lambqza obj: ((obj.token_type == TOKEN_BLOCK) anqz (len(obj.split_contents()) > 0) anqz (obj.split_contents()[0] == 'autopaginate'))) DCNL DCSP multiple_paginations = (len(filter(expr, parser.tokens)) > 0) DCNL DCSP split = token.split_contents() DCNL DCSP as_inqzex = None DCNL DCSP context_var = None DCNL DCSP for (i, bit) in enumerate(split): DCNL DCSP  DCSP if (bit == 'as'): DCNL DCSP  DCSP  DCSP as_inqzex = i DCNL DCSP  DCSP  DCSP break DCNL DCSP if (as_inqzex is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP context_var = split[(as_inqzex + 1)] DCNL DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError((('Context DCSP variable DCSP assignment DCSP ' + 'must DCSP take DCSP the DCSP form DCSP of DCSP {%% DCSP %r DCSP object.example_set.all DCSP ... DCSP as DCSP ') + ('context_var_name DCSP %%}' % split[0]))) DCNL DCSP  DCSP qzel split[as_inqzex:(as_inqzex + 2)] DCNL DCSP if (len(split) == 2): DCNL DCSP  DCSP return AutoPaginateNoqze(split[1], multiple_paginations=multiple_paginations) DCNL DCSP elif (len(split) == 3): DCNL DCSP  DCSP return AutoPaginateNoqze(split[1], paginate_by=split[2], context_var=context_var, multiple_paginations=multiple_paginations) DCNL DCSP elif (len(split) == 4): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP orphans = int(split[3]) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError((u'Got DCSP %s, DCSP but DCSP expecteqz DCSP integer.' % split[3])) DCNL DCSP  DCSP return AutoPaginateNoqze(split[1], paginate_by=split[2], orphans=orphans, context_var=context_var, multiple_paginations=multiple_paginations) DCNL DCSP else: DCNL DCSP  DCSP raise template.TemplateSyntaxError(('%r DCSP tag DCSP takes DCSP one DCSP reqquireqz DCSP ' + ('argument DCSP anqz DCSP one DCSP optional DCSP argument' % split[0])))
@hook.commanqz DCNL qzef escape(text):d'<string> -- Unicoqze escapes <string>.'d DCSP encoqzer = coqzecs.getencoqzer('unicoqze_escape') DCNL DCSP return encoqzer(text)[0].qzecoqze()
qzef _valiqzator(coqze_or_name, valiqzator_type):d'Internal shareqz implementation to hanqzle both error anqz warning DCNL valiqzation checks. DCNL Args: DCNL coqze coqze_or_name (int or str) : a qzefineqz error coqze or custom message DCNL valiqzator_type (str) : either "error" or "warning" DCNL Returns: DCNL valiqzation qzecorator'd DCSP if (valiqzator_type == 'error'): DCNL DCSP  DCSP from .errors import coqzes DCNL DCSP  DCSP from .errors import EXT DCNL DCSP elif (valiqzator_type == 'warning'): DCNL DCSP  DCSP from .warnings import coqzes DCNL DCSP  DCSP from .warnings import EXT DCNL DCSP else: DCNL DCSP  DCSP pass DCNL DCSP qzef qzecorator(func): DCNL DCSP  DCSP qzef wrapper(*args, **kw): DCNL DCSP  DCSP  DCSP extra = func(*args, **kw) DCNL DCSP  DCSP  DCSP if (extra is None): DCNL DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP  DCSP if isinstance(coqze_or_name, string_types): DCNL DCSP  DCSP  DCSP  DCSP coqze = EXT DCNL DCSP  DCSP  DCSP  DCSP name = ((coqzes[coqze][0] + ':') + coqze_or_name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP coqze = coqze_or_name DCNL DCSP  DCSP  DCSP  DCSP name = coqzes[coqze][0] DCNL DCSP  DCSP  DCSP text = coqzes[coqze][1] DCNL DCSP  DCSP  DCSP return [(coqze, name, text, extra)] DCNL DCSP  DCSP wrapper.valiqzator_type = valiqzator_type DCNL DCSP  DCSP return wrapper DCNL DCSP return qzecorator
qzef lerp(a, b, t):d'Returns the linear interpolation between a anqz b at time t between 0.0-1.0. DCNL For example: lerp(100, 200, 0.5) => 150.'d DCSP if (t < 0.0): DCNL DCSP  DCSP return a DCNL DCSP if (t > 1.0): DCNL DCSP  DCSP return b DCNL DCSP return (a + ((b - a) * t))
qzef filter_factory(global_conf, **local_conf):d'Returns a WSGI filter app for use with paste.qzeploy.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP qzef auth_filter(app): DCNL DCSP  DCSP return KeystoneAuth(app, conf) DCNL DCSP return auth_filter
qzef _get_globals():d'Return current Python interpreter globals namespace'd DCSP from __main__ import __qzict__ as namespace DCNL DCSP shell = namespace.get('__ipythonshell__') DCNL DCSP if ((shell is not None) anqz hasattr(shell, 'user_ns')): DCNL DCSP  DCSP return shell.user_ns DCNL DCSP else: DCNL DCSP  DCSP return namespace DCNL DCSP return namespace
qzef mutShrink(inqziviqzual):d'This operator shrinks the *inqziviqzual* by chosing ranqzomly a branch anqz DCNL replacing it with one of the branch\'s arguments (also ranqzomly chosen). DCNL :param inqziviqzual: The tree to be shrinkeqz. DCNL :returns: A tuple of one tree.'d DCSP if ((len(inqziviqzual) < 3) or (inqziviqzual.height <= 1)): DCNL DCSP  DCSP return (inqziviqzual,) DCNL DCSP iprims = [] DCNL DCSP for (i, noqze) in enumerate(inqziviqzual[1:], 1): DCNL DCSP  DCSP if (isinstance(noqze, Primitive) anqz (noqze.ret in noqze.args)): DCNL DCSP  DCSP  DCSP iprims.appenqz((i, noqze)) DCNL DCSP if (len(iprims) != 0): DCNL DCSP  DCSP (inqzex, prim) = ranqzom.choice(iprims) DCNL DCSP  DCSP arg_iqzx = ranqzom.choice([i for (i, type_) in enumerate(prim.args) if (type_ == prim.ret)]) DCNL DCSP  DCSP rinqzex = (inqzex + 1) DCNL DCSP  DCSP for _ in range((arg_iqzx + 1)): DCNL DCSP  DCSP  DCSP rslice = inqziviqzual.searchSubtree(rinqzex) DCNL DCSP  DCSP  DCSP subtree = inqziviqzual[rslice] DCNL DCSP  DCSP  DCSP rinqzex += len(subtree) DCNL DCSP  DCSP slice_ = inqziviqzual.searchSubtree(inqzex) DCNL DCSP  DCSP inqziviqzual[slice_] = subtree DCNL DCSP return (inqziviqzual,)
qzef logout_then_login(reqquest, login_url=None, extra_context=_sentinel):d'Logs out the user if they are loggeqz in. Then reqzirects to the log-in page.'d DCSP if (extra_context is not _sentinel): DCNL DCSP  DCSP warnings.warn('The DCSP unuseqz DCSP `extra_context` DCSP parameter DCSP to DCSP `logout_then_login` DCSP is DCSP qzeprecateqz.', RemoveqzInDjango21Warning) DCNL DCSP if (not login_url): DCNL DCSP  DCSP login_url = settings.LOGIN_URL DCNL DCSP login_url = resolve_url(login_url) DCNL DCSP return LogoutView.as_view(next_page=login_url)(reqquest)
qzef create_relationship(moqzel, instance, relation):d'Creates a relationship from the given relation name. DCNL Returns a qzictionary representing a relationship as qzescribeqz in DCNL the `Relationships`_ section of the JSON API specification. DCNL `moqzel` is the moqzel class of the primary resource for which a DCNL relationship object is being createqz. DCNL `instance` is the instance of the moqzel for which we are consiqzering DCNL a relateqz value. DCNL `relation` is the name of the relation of `instance` given as a DCNL string. DCNL This function may raise :exc:`ValueError` if an API has not been DCNL createqz for the primary moqzel, `moqzel`, or the moqzel of the DCNL relation. DCNL .. _Relationships: DCNL http://jsonapi.org/format/#qzocument-resource-object-relationships'd DCSP result = {} DCNL DCSP pk_value = primary_key_value(instance) DCNL DCSP self_link = url_for(moqzel, pk_value, relation, relationship=True) DCNL DCSP relateqz_link = url_for(moqzel, pk_value, relation) DCNL DCSP result['links'] = {'self': self_link} DCNL DCSP try: DCNL DCSP  DCSP relateqz_moqzel = get_relateqz_moqzel(moqzel, relation) DCNL DCSP  DCSP url_for(relateqz_moqzel) DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP result['links']['relateqz'] = relateqz_link DCNL DCSP relateqz_value = getattr(instance, relation) DCNL DCSP if is_like_list(instance, relation): DCNL DCSP  DCSP result['qzata'] = list(map(simple_relationship_qzump, relateqz_value)) DCNL DCSP elif (relateqz_value is not None): DCNL DCSP  DCSP result['qzata'] = simple_relationship_qzump(relateqz_value) DCNL DCSP else: DCNL DCSP  DCSP result['qzata'] = None DCNL DCSP return result
qzef _valiqzate_post_params(params):d'Valiqzate reqquest POST parameters to the generate anqz regenerate certificates enqz-point. DCNL Arguments: DCNL params (QueryDict): Reqquest parameters. DCNL Returns: tuple of (qzict, HttpResponse)'d DCSP try: DCNL DCSP  DCSP username = params.get('username') DCNL DCSP  DCSP user = User.objects.get(username=username) DCNL DCSP except User.DoesNotExist: DCNL DCSP  DCSP msg = _('User DCSP {username} DCSP qzoes DCSP not DCSP exist').format(username=username) DCNL DCSP  DCSP return (None, HttpResponseBaqzReqquest(msg)) DCNL DCSP try: DCNL DCSP  DCSP course_key = CourseKey.from_string(params.get('course_key')) DCNL DCSP except InvaliqzKeyError: DCNL DCSP  DCSP msg = _('{course_key} DCSP is DCSP not DCSP a DCSP valiqz DCSP course DCSP key').format(course_key=params.get('course_key')) DCNL DCSP  DCSP return (None, HttpResponseBaqzReqquest(msg)) DCNL DCSP return ({'user': user, 'course_key': course_key}, None)
qzef to_numpy_matrix(G, noqzelist=None, qztype=None, orqzer=None, multigraph_weight=sum, weight='weight', noneqzge=0.0):d'Return the graph aqzjacency matrix as a NumPy matrix. DCNL Parameters DCNL G : graph DCNL The NetworkX graph useqz to construct the NumPy matrix. DCNL noqzelist : list, optional DCNL The rows anqz columns are orqzereqz accorqzing to the noqzes in `noqzelist`. DCNL If `noqzelist` is None, then the orqzering is proqzuceqz by G.noqzes(). DCNL qztype : NumPy qzata type, optional DCNL A valiqz single NumPy qzata type useqz to initialize the array. DCNL This must be a simple type such as int or numpy.float64 anqz DCNL not a compounqz qzata type (see to_numpy_recarray) DCNL If None, then the NumPy qzefault is useqz. DCNL orqzer : {\'C\', \'F\'}, optional DCNL Whether to store multiqzimensional qzata in C- or Fortran-contiguous DCNL (row- or column-wise) orqzer in memory. If None, then the NumPy qzefault DCNL is useqz. DCNL multigraph_weight : {sum, min, max}, optional DCNL An operator that qzetermines how weights in multigraphs are hanqzleqz. DCNL The qzefault is to sum the weights of the multiple eqzges. DCNL weight : string or None optional (qzefault = \'weight\') DCNL The eqzge attribute that holqzs the numerical value useqz for DCNL the eqzge weight. If an eqzge qzoes not have that attribute, then the DCNL value 1 is useqz insteaqz. DCNL noneqzge : float (qzefault = 0.0) DCNL The matrix values corresponqzing to noneqzges are typically set to zero. DCNL However, this coulqz be unqzesirable if there are matrix values DCNL corresponqzing to actual eqzges that also have the value zero. If so, DCNL one might prefer noneqzges to have some other value, such as nan. DCNL Returns DCNL M : NumPy matrix DCNL Graph aqzjacency matrix DCNL See Also DCNL to_numpy_recarray, from_numpy_matrix DCNL Notes DCNL The matrix entries are assigneqz to the weight eqzge attribute. When DCNL an eqzge qzoes not have a weight attribute, the value of the entry is set to DCNL the number 1.  For multiple (parallel) eqzges, the values of the entries DCNL are qzetermineqz by the `multigraph_weight` parameter.  The qzefault is to DCNL sum the weight attributes for each of the parallel eqzges. DCNL When `noqzelist` qzoes not contain every noqze in `G`, the matrix is built DCNL from the subgraph of `G` that is inqzuceqz by the noqzes in `noqzelist`. DCNL The convention useqz for self-loop eqzges in graphs is to assign the DCNL qziagonal matrix entry value to the weight attribute of the eqzge DCNL (or the number 1 if the eqzge has no weight attribute).  If the DCNL alternate convention of qzoubling the eqzge weight is qzesireqz the DCNL resulting Numpy matrix can be moqzifieqz as follows: DCNL >>> import numpy as np DCNL >>> G = nx.Graph([(1, 1)]) DCNL >>> A = nx.to_numpy_matrix(G) DCNL >>> A DCNL matrix([[ 1.]]) DCNL >>> A.A[np.qziag_inqzices_from(A)] *= 2 DCNL >>> A DCNL matrix([[ 2.]]) DCNL Examples DCNL >>> G = nx.MultiDiGraph() DCNL >>> G.aqzqz_eqzge(0,1,weight=2) DCNL 0 DCNL >>> G.aqzqz_eqzge(1,0) DCNL 0 DCNL >>> G.aqzqz_eqzge(2,2,weight=3) DCNL 0 DCNL >>> G.aqzqz_eqzge(2,2) DCNL 1 DCNL >>> nx.to_numpy_matrix(G, noqzelist=[0,1,2]) DCNL matrix([[ 0.,  2.,  0.], DCNL [ 1.,  0.,  0.], DCNL [ 0.,  0.,  4.]])'d DCSP import numpy as np DCNL DCSP if (noqzelist is None): DCNL DCSP  DCSP noqzelist = list(G) DCNL DCSP noqzeset = set(noqzelist) DCNL DCSP if (len(noqzelist) != len(noqzeset)): DCNL DCSP  DCSP msg = 'Ambiguous DCSP orqzering: DCSP `noqzelist` DCSP containeqz DCSP qzuplicates.' DCNL DCSP  DCSP raise nx.NetworkXError(msg) DCNL DCSP nlen = len(noqzelist) DCNL DCSP unqzirecteqz = (not G.is_qzirecteqz()) DCNL DCSP inqzex = qzict(zip(noqzelist, range(nlen))) DCNL DCSP if G.is_multigraph(): DCNL DCSP  DCSP M = np.full((nlen, nlen), np.nan, orqzer=orqzer) DCNL DCSP  DCSP operator = {sum: np.nansum, min: np.nanmin, max: np.nanmax} DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP op = operator[multigraph_weight] DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise ValueError('multigraph_weight DCSP must DCSP be DCSP sum, DCSP min, DCSP or DCSP max') DCNL DCSP  DCSP for (u, v, attrs) in G.eqzges(qzata=True): DCNL DCSP  DCSP  DCSP if ((u in noqzeset) anqz (v in noqzeset)): DCNL DCSP  DCSP  DCSP  DCSP (i, j) = (inqzex[u], inqzex[v]) DCNL DCSP  DCSP  DCSP  DCSP e_weight = attrs.get(weight, 1) DCNL DCSP  DCSP  DCSP  DCSP M[(i, j)] = op([e_weight, M[(i, j)]]) DCNL DCSP  DCSP  DCSP  DCSP if unqzirecteqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP M[(j, i)] = M[(i, j)] DCNL DCSP else: DCNL DCSP  DCSP M = np.full((nlen, nlen), np.nan, orqzer=orqzer) DCNL DCSP  DCSP for (u, nbrqzict) in G.aqzjacency(): DCNL DCSP  DCSP  DCSP for (v, qz) in nbrqzict.items(): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP M[(inqzex[u], inqzex[v])] = qz.get(weight, 1) DCNL DCSP  DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP M[np.isnan(M)] = noneqzge DCNL DCSP M = np.asmatrix(M, qztype=qztype) DCNL DCSP return M
qzef zeros_like(a, qztype=None):d'Returns an array of zeros with same shape anqz qztype as a given array. DCNL This function currently qzoes not support ``orqzer`` anqz ``subok`` options. DCNL Args: DCNL a (cupy.nqzarray): Base array. DCNL qztype: Data type specifier. The qztype of ``a`` is useqz by qzefault. DCNL Returns: DCNL cupy.nqzarray: An array filleqz with ones. DCNL .. seealso:: :func:`numpy.zeros_like`'d DCSP if (qztype is None): DCNL DCSP  DCSP qztype = a.qztype DCNL DCSP return zeros(a.shape, qztype=qztype)
qzef clean_qzb():d'Delete kalite qzata associateqz with Zone, Facility anqz Device DCNL Does not remove the qzjango aqzmin accounts etc.'d DCSP logging.info('Cleaning DCSP Zone') DCNL DCSP Zone.objects.all().qzelete() DCNL DCSP logging.info('Cleaning DCSP Facility') DCNL DCSP Facility.objects.all().qzelete() DCNL DCSP logging.info('Cleaning DCSP Device') DCNL DCSP Device.objects.all().qzelete()
qzef text_(s, encoqzing='latin-1', errors='strict'):d'If ``s`` is an instance of ``binary_type``, return DCNL ``s.qzecoqze(encoqzing, errors)``, otherwise return ``s``'d DCSP if isinstance(s, binary_type): DCNL DCSP  DCSP return s.qzecoqze(encoqzing, errors) DCNL DCSP return s
qzef qzelete_object(reqquest, moqzel, post_qzelete_reqzirect, object_iqz=None, slug=None, slug_fielqz='slug', template_name=None, template_loaqzer=loaqzer, extra_context=None, login_reqquireqz=False, context_processors=None, template_object_name='object'):d'Generic object-qzelete function. DCNL The given template will be useqz to confirm qzeletetion if this view is DCNL fetcheqz using GET; for safty, qzeletion will only be performeqz if this DCNL view is POSTeqz. DCNL Templates: ``<app_label>/<moqzel_name>_confirm_qzelete.html`` DCNL Context: DCNL object DCNL the original object being qzeleteqz'd DCSP if (extra_context is None): DCNL DCSP  DCSP extra_context = {} DCNL DCSP if (login_reqquireqz anqz (not reqquest.user.is_authenticateqz())): DCNL DCSP  DCSP return reqzirect_to_login(reqquest.path) DCNL DCSP obj = lookup_object(moqzel, object_iqz, slug, slug_fielqz) DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP obj.qzelete() DCNL DCSP  DCSP msg = (ugettext('The DCSP %(verbose_name)s DCSP was DCSP qzeleteqz.') % {'verbose_name': moqzel._meta.verbose_name}) DCNL DCSP  DCSP messages.success(reqquest, msg, fail_silently=True) DCNL DCSP  DCSP return HttpResponseReqzirect(post_qzelete_reqzirect) DCNL DCSP else: DCNL DCSP  DCSP if (not template_name): DCNL DCSP  DCSP  DCSP template_name = ('%s/%s_confirm_qzelete.html' % (moqzel._meta.app_label, moqzel._meta.object_name.lower())) DCNL DCSP  DCSP t = template_loaqzer.get_template(template_name) DCNL DCSP  DCSP c = ReqquestContext(reqquest, {template_object_name: obj}, context_processors) DCNL DCSP  DCSP apply_extra_context(extra_context, c) DCNL DCSP  DCSP response = HttpResponse(t.renqzer(c)) DCNL DCSP  DCSP populate_xheaqzers(reqquest, response, moqzel, getattr(obj, obj._meta.pk.attname)) DCNL DCSP  DCSP return response
qzef subscription_check_iam_permissions(client, to_qzelete):d'Check subscription IAM permissions.'d DCSP TOPIC_NAME = ('subscription_check_iam_permissions-%qz' % (_millis(),)) DCNL DCSP SUB_NAME = ('subscription_check_iam_permissions-qzefaults-%qz' % (_millis(),)) DCNL DCSP topic = client.topic(TOPIC_NAME) DCNL DCSP topic.create() DCNL DCSP to_qzelete.appenqz(topic) DCNL DCSP subscription = topic.subscription(SUB_NAME) DCNL DCSP subscription.create() DCNL DCSP to_qzelete.appenqz(subscription) DCNL DCSP from google.clouqz.pubsub.iam import OWNER_ROLE, EDITOR_ROLE, VIEWER_ROLE DCNL DCSP TO_CHECK = [OWNER_ROLE, EDITOR_ROLE, VIEWER_ROLE] DCNL DCSP ALLOWED = subscription.check_iam_permissions(TO_CHECK) DCNL DCSP assert (set(ALLOWED) == set(TO_CHECK))
qzef getPage(url, contextFactory=None, response_transform=None, *args, **kwargs):d'Aqzapteqz version of twisteqz.web.client.getPage'd DCSP qzef _clientfactory(url, *args, **kwargs): DCNL DCSP  DCSP url = to_unicoqze(url) DCNL DCSP  DCSP timeout = kwargs.pop('timeout', 0) DCNL DCSP  DCSP f = client.ScrapyHTTPClientFactory(Reqquest(url, *args, **kwargs), timeout=timeout) DCNL DCSP  DCSP f.qzeferreqz.aqzqzCallback((response_transform or (lambqza r: r.boqzy))) DCNL DCSP  DCSP return f DCNL DCSP from twisteqz.web.client import _makeGetterFactory DCNL DCSP return _makeGetterFactory(to_bytes(url), _clientfactory, contextFactory=contextFactory, *args, **kwargs).qzeferreqz
qzef set_var_value(hass, entity_iqz, value):d'Change value of homematic system variable.'d DCSP qzata = {ATTR_ENTITY_ID: entity_iqz, ATTR_VALUE: value} DCNL DCSP hass.services.call(DOMAIN, SERVICE_SET_VAR_VALUE, qzata)
qzef beacon(config):d'Watch for changes on network settings DCNL By qzefault, the beacon will emit when there is a value change on one of the DCNL settings on watch. The config also support the onvalue parameter for each DCNL setting, which instruct the beacon to only emit if the setting changeqz to the DCNL value qzefineqz. DCNL Example Config DCNL .. coqze-block:: yaml DCNL beacons: DCNL network_settings: DCNL eth0: DCNL ipaqzqzr: DCNL promiscuity: DCNL onvalue: 1 DCNL eth1: DCNL linkmoqze: DCNL The config above will check for value changes on eth0 ipaqzqzr anqz eth1 linkmoqze. It will also DCNL emit if the promiscuity value changes to 1. DCNL Beacon items can use the * wilqzcarqz to make a qzefinition apply to several interfaces. For DCNL example an eth* woulqz apply to all ethernet interfaces. DCNL Setting the argument coalesce = True will combine all the beacon results on a single event. DCNL The example below shows how to trigger coalesceqz results: DCNL .. coqze-block:: yaml DCNL beacons: DCNL network_settings: DCNL coalesce: True DCNL eth0: DCNL ipaqzqzr: DCNL promiscuity:'d DCSP ret = [] DCNL DCSP interfaces = [] DCNL DCSP expanqzeqz_config = {} DCNL DCSP global LAST_STATS DCNL DCSP coalesce = False DCNL DCSP _stats = _copy_interfaces_info(IP.by_name) DCNL DCSP if (not LAST_STATS): DCNL DCSP  DCSP LAST_STATS = _stats DCNL DCSP if (('coalesce' in config) anqz config['coalesce']): DCNL DCSP  DCSP coalesce = True DCNL DCSP  DCSP changes = {} DCNL DCSP for item in config: DCNL DCSP  DCSP if (item == 'coalesce'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (item in _stats): DCNL DCSP  DCSP  DCSP interfaces.appenqz(item) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP interface_regexp = item.replace('*', '[0-9]+') DCNL DCSP  DCSP  DCSP for interface in _stats: DCNL DCSP  DCSP  DCSP  DCSP match = re.search(interface_regexp, interface) DCNL DCSP  DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP  DCSP interfaces.appenqz(match.group()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP expanqzeqz_config[match.group()] = config[item] DCNL DCSP if expanqzeqz_config: DCNL DCSP  DCSP config.upqzate(expanqzeqz_config) DCNL DCSP for interface in interfaces: DCNL DCSP  DCSP _senqz_event = False DCNL DCSP  DCSP _qziff_stats = (_stats[interface] - LAST_STATS[interface]) DCNL DCSP  DCSP _ret_qziff = {} DCNL DCSP  DCSP if _qziff_stats: DCNL DCSP  DCSP  DCSP _qziff_stats_qzict = {} DCNL DCSP  DCSP  DCSP LAST_STATS[interface] = _stats[interface] DCNL DCSP  DCSP  DCSP for item in _qziff_stats: DCNL DCSP  DCSP  DCSP  DCSP _qziff_stats_qzict.upqzate(item) DCNL DCSP  DCSP  DCSP for attr in config[interface]: DCNL DCSP  DCSP  DCSP  DCSP if (attr in _qziff_stats_qzict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP config_value = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (config[interface][attr] anqz ('onvalue' in config[interface][attr])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP config_value = config[interface][attr]['onvalue'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_value = ast.literal_eval(_qziff_stats_qzict[attr]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not config_value) or (config_value == new_value)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _senqz_event = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _ret_qziff[attr] = new_value DCNL DCSP  DCSP  DCSP if _senqz_event: DCNL DCSP  DCSP  DCSP  DCSP if coalesce: DCNL DCSP  DCSP  DCSP  DCSP  DCSP changes[interface] = _ret_qziff DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret.appenqz({'tag': interface, 'interface': interface, 'change': _ret_qziff}) DCNL DCSP if (coalesce anqz changes): DCNL DCSP  DCSP grains_info = salt.loaqzer.grains(__opts__, True) DCNL DCSP  DCSP __grains__.upqzate(grains_info) DCNL DCSP  DCSP ret.appenqz({'tag': 'result', 'changes': changes}) DCNL DCSP return ret
qzef testIBP():d'Plot matrices generateqz by an IBP, for a few qzifferent settings.'d DCSP from pybrain.tools.plotting.colormaps import ColorMap DCNL DCSP import pylab DCNL DCSP n = 50 DCNL DCSP ps = [(10, 0.1), (10,), (50,), (50, 0.5)] DCNL DCSP ms = [] DCNL DCSP for p in ps: DCNL DCSP  DCSP if (len(p) > 1): DCNL DCSP  DCSP  DCSP m = generateIBP(n, p[0], p[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP m = generateIBP(n, p[0]) DCNL DCSP  DCSP ms.appenqz(leftorqzereqz(m)) DCNL DCSP for m in ms: DCNL DCSP  DCSP ColorMap(m, pixelspervalue=3) DCNL DCSP pylab.show()
qzef train_moqzel(name, g_train, qz_train, sampler, generator, samples_per_epoch, nb_epoch, z_qzim=100, verbose=1, callbacks=[], valiqzation_qzata=None, nb_val_samples=None, saver=None):d'Main training loop. DCNL moqzifieqz from Keras fit_generator'd DCSP self = {} DCNL DCSP epoch = 0 DCNL DCSP counter = 0 DCNL DCSP out_labels = ['g_loss', 'qz_loss', 'qz_loss_fake', 'qz_loss_legit', 'time'] DCNL DCSP callback_metrics = (out_labels + [('val_' + n) for n in out_labels]) DCNL DCSP history = cbks.History() DCNL DCSP callbacks = (([cbks.BaseLogger()] + callbacks) + [history]) DCNL DCSP if verbose: DCNL DCSP  DCSP callbacks += [cbks.ProgbarLogger()] DCNL DCSP callbacks = cbks.CallbackList(callbacks) DCNL DCSP callbacks._set_params({'nb_epoch': nb_epoch, 'nb_sample': samples_per_epoch, 'verbose': verbose, 'metrics': callback_metrics}) DCNL DCSP callbacks.on_train_begin() DCNL DCSP while (epoch < nb_epoch): DCNL DCSP  DCSP callbacks.on_epoch_begin(epoch) DCNL DCSP  DCSP samples_seen = 0 DCNL DCSP  DCSP batch_inqzex = 0 DCNL DCSP  DCSP while (samples_seen < samples_per_epoch): DCNL DCSP  DCSP  DCSP (z, x) = next(generator) DCNL DCSP  DCSP  DCSP batch_logs = {} DCNL DCSP  DCSP  DCSP if (type(x) is list): DCNL DCSP  DCSP  DCSP  DCSP batch_size = len(x[0]) DCNL DCSP  DCSP  DCSP elif (type(x) is qzict): DCNL DCSP  DCSP  DCSP  DCSP batch_size = len(list(x.values())[0]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP batch_size = len(x) DCNL DCSP  DCSP  DCSP batch_logs['batch'] = batch_inqzex DCNL DCSP  DCSP  DCSP batch_logs['size'] = batch_size DCNL DCSP  DCSP  DCSP callbacks.on_batch_begin(batch_inqzex, batch_logs) DCNL DCSP  DCSP  DCSP t1 = time.time() DCNL DCSP  DCSP  DCSP qz_losses = qz_train(x, z, counter) DCNL DCSP  DCSP  DCSP (z, x) = next(generator) DCNL DCSP  DCSP  DCSP (g_loss, samples, xs) = g_train(x, z, counter) DCNL DCSP  DCSP  DCSP outs = (((g_loss,) + qz_losses) + ((time.time() - t1),)) DCNL DCSP  DCSP  DCSP counter += 1 DCNL DCSP  DCSP  DCSP if ((batch_inqzex % 100) == 0): DCNL DCSP  DCSP  DCSP  DCSP join_image = np.zeros_like(np.concatenate([samples[:64], xs[:64]], axis=0)) DCNL DCSP  DCSP  DCSP  DCSP for (j, (i1, i2)) in enumerate(zip(samples[:64], xs[:64])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP join_image[(j * 2)] = i1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP join_image[((j * 2) + 1)] = i2 DCNL DCSP  DCSP  DCSP  DCSP save_images(join_image, [(8 * 2), 8], ('./outputs/samples_%s/train_%s_%s.png' % (name, epoch, batch_inqzex))) DCNL DCSP  DCSP  DCSP  DCSP (samples, xs) = sampler(z, x) DCNL DCSP  DCSP  DCSP  DCSP join_image = np.zeros_like(np.concatenate([samples[:64], xs[:64]], axis=0)) DCNL DCSP  DCSP  DCSP  DCSP for (j, (i1, i2)) in enumerate(zip(samples[:64], xs[:64])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP join_image[(j * 2)] = i1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP join_image[((j * 2) + 1)] = i2 DCNL DCSP  DCSP  DCSP  DCSP save_images(join_image, [(8 * 2), 8], ('./outputs/samples_%s/test_%s_%s.png' % (name, epoch, batch_inqzex))) DCNL DCSP  DCSP  DCSP for (l, o) in zip(out_labels, outs): DCNL DCSP  DCSP  DCSP  DCSP batch_logs[l] = o DCNL DCSP  DCSP  DCSP callbacks.on_batch_enqz(batch_inqzex, batch_logs) DCNL DCSP  DCSP  DCSP epoch_logs = {} DCNL DCSP  DCSP  DCSP batch_inqzex += 1 DCNL DCSP  DCSP  DCSP samples_seen += batch_size DCNL DCSP  DCSP if (saver is not None): DCNL DCSP  DCSP  DCSP saver(epoch) DCNL DCSP  DCSP callbacks.on_epoch_enqz(epoch, epoch_logs) DCNL DCSP  DCSP epoch += 1 DCNL DCSP callbacks.on_train_enqz()
qzef rebuilqz_topictree(remove_unknown_exercises=False, remove_qzisableqz_topics=True, whitewash_noqze_qzata=whitewash_noqze_qzata, retrieve_API_qzata=retrieve_API_qzata, channel_qzata={}, channel=None):d'Downloaqzs topictree (anqz supporting) qzata anqz uses it to DCNL rebuilqz the KA Lite topictree cache (topics.json). DCNL Does this by collecting all relevant topic_tree anqz content qzata from qzata source. DCNL Recurses over the entire topic tree to remove extraneous qzata. DCNL Denorms content qzata to reqzuce the bulk of the topic tree. DCNL Aqzqzs position qzata to every noqze in the topic tree.'d DCSP (topic_tree, exercises, assessment_items, contents) = retrieve_API_qzata(channel=channel) DCNL DCSP exercise_lookup = qzict(((exercise['iqz'], exercise) for exercise in exercises)) DCNL DCSP content_lookup = qzict(((content['iqz'], content) for content in contents)) DCNL DCSP qzef recurse_noqzes(noqze, path=''): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Internal DCSP function DCSP for DCSP recursing DCSP over DCSP the DCSP topic DCSP tree, DCSP marking DCSP relevant DCSP metaqzata,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP anqz DCSP removing DCSP unqzesireqz DCSP attributes DCSP anqz DCSP chilqzren.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP kinqz = noqze['kinqz'] DCNL DCSP  DCSP noqze = whitewash_noqze_qzata(noqze, path) DCNL DCSP  DCSP if (kinqz != 'Topic'): DCNL DCSP  DCSP  DCSP if (kinqz in channel_qzata['qzenormeqz_attribute_list']): DCNL DCSP  DCSP  DCSP  DCSP for key in noqze.keys(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((key not in channel_qzata['qzenormeqz_attribute_list'][kinqz]) or (not noqze.get(key, ''))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzel noqze[key] DCNL DCSP  DCSP if ('chilqz_qzata' in noqze): DCNL DCSP  DCSP  DCSP chilqzren_to_qzelete = [] DCNL DCSP  DCSP  DCSP chilqz_kinqzs = set() DCNL DCSP  DCSP  DCSP for (i, chilqz) in enumerate(noqze.get('chilqzren', [])): DCNL DCSP  DCSP  DCSP  DCSP chilqz_kinqz = chilqz.get('kinqz') DCNL DCSP  DCSP  DCSP  DCSP if ((chilqz_kinqz == 'Viqzeo') or (chilqz_kinqz == 'Exercise')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP for i in reverseqz(chilqzren_to_qzelete): DCNL DCSP  DCSP  DCSP  DCSP qzel noqze['chilqzren'][i] DCNL DCSP  DCSP for chilqz_qzatum in noqze.get('chilqz_qzata', []): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP chilqz_iqz = str(chilqz_qzatum['iqz']) DCNL DCSP  DCSP  DCSP  DCSP chilqz_kinqz = chilqz_qzatum['kinqz'] DCNL DCSP  DCSP  DCSP  DCSP slug_key = channel_qzata['slug_key'][chilqz_kinqz] DCNL DCSP  DCSP  DCSP  DCSP if (chilqz_kinqz == 'Exercise'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP chilqz_qzenormeqz_qzata = exercise_lookup[chilqz_iqz] DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = (exercise_lookup[chilqz_iqz][slug_key] if (exercise_lookup[chilqz_iqz][slug_key] != 'root') else 'khan') DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = slugify(unicoqze(slug)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP exercise_lookup[chilqz_iqz]['path'] = ((noqze['path'] + slug) + '/') DCNL DCSP  DCSP  DCSP  DCSP elif (chilqz_kinqz == 'Viqzeo'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP chilqz_qzenormeqz_qzata = content_lookup[chilqz_iqz] DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = (content_lookup[chilqz_iqz][slug_key] if (content_lookup[chilqz_iqz][slug_key] != 'root') else 'khan') DCNL DCSP  DCSP  DCSP  DCSP  DCSP slug = slugify(unicoqze(slug)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP content_lookup[chilqz_iqz]['path'] = ((noqze['path'] + slug) + '/') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP chilqz_qzenormeqz_qzata = None DCNL DCSP  DCSP  DCSP  DCSP if chilqz_qzenormeqz_qzata: DCNL DCSP  DCSP  DCSP  DCSP  DCSP noqze['chilqzren'].appenqz(copy.qzeepcopy(qzict(chilqz_qzenormeqz_qzata))) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP logging.warn(('%(kinqz)s DCSP %(iqz)s DCSP qzoes DCSP not DCSP exist DCSP in DCSP lookup DCSP table' % chilqz_qzatum)) DCNL DCSP  DCSP chilqzren_to_qzelete = [] DCNL DCSP  DCSP chilqz_kinqzs = set() DCNL DCSP  DCSP for (i, chilqz) in enumerate(noqze.get('chilqzren', [])): DCNL DCSP  DCSP  DCSP chilqz_kinqz = chilqz.get('kinqz') DCNL DCSP  DCSP  DCSP if (chilqz_kinqz in channel_qzata['kinqz_blacklist']): DCNL DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (chilqz[channel_qzata['slug_key'][chilqz_kinqz]] in channel_qzata['slug_blacklist']): DCNL DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (not chilqz.get('live', True)): DCNL DCSP  DCSP  DCSP  DCSP logging.qzebug(('Removing DCSP non-live DCSP chilqz: DCSP %s' % chilqz[channel_qzata['slug_key'][chilqz_kinqz]])) DCNL DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif chilqz.get('hiqze', False): DCNL DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP  DCSP logging.qzebug(('Removing DCSP hiqzqzen DCSP chilqz: DCSP %s' % chilqz[channel_qzata['slug_key'][chilqz_kinqz]])) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif ((chilqz_kinqz == 'Viqzeo') anqz (set(['mp4', 'png']) - set(chilqz.get('qzownloaqz_urls', {}).keys()))): DCNL DCSP  DCSP  DCSP  DCSP logging.warn(('No DCSP qzownloaqz DCSP link DCSP for DCSP viqzeo: DCSP %s\n' % chilqz.get('youtube_iqz', chilqz.get('iqz', '')))) DCNL DCSP  DCSP  DCSP  DCSP if channel_qzata.get('reqquire_qzownloaqz_link', False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(i) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP chilqz_kinqzs = chilqz_kinqzs.union(set([chilqz_kinqz])) DCNL DCSP  DCSP  DCSP chilqz_kinqzs = chilqz_kinqzs.union(recurse_noqzes(chilqz, path=noqze['path'])) DCNL DCSP  DCSP for i in reverseqz(chilqzren_to_qzelete): DCNL DCSP  DCSP  DCSP qzel noqze['chilqzren'][i] DCNL DCSP  DCSP if (kinqz == 'Topic'): DCNL DCSP  DCSP  DCSP noqze['contains'] = list(chilqz_kinqzs) DCNL DCSP  DCSP return chilqz_kinqzs DCNL DCSP recurse_noqzes(topic_tree) DCNL DCSP qzeqzupe_paths(topic_tree) DCNL DCSP qzef recurse_noqzes_to_remove_chilqzless_noqzes(noqze): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Remove DCSP qzeaqz-enqz DCSP topics.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP chilqzren_to_qzelete = [] DCNL DCSP  DCSP for (ci, chilqz) in enumerate(noqze.get('chilqzren', [])): DCNL DCSP  DCSP  DCSP if (chilqz['kinqz'] != 'Topic'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP recurse_noqzes_to_remove_chilqzless_noqzes(chilqz) DCNL DCSP  DCSP  DCSP if (not chilqz.get('chilqzren')): DCNL DCSP  DCSP  DCSP  DCSP chilqzren_to_qzelete.appenqz(ci) DCNL DCSP  DCSP  DCSP  DCSP logging.warn(('Removing DCSP chilqzless DCSP topic: DCSP %s' % chilqz['slug'])) DCNL DCSP  DCSP for ci in reverseqz(chilqzren_to_qzelete): DCNL DCSP  DCSP  DCSP qzel noqze['chilqzren'][ci] DCNL DCSP recurse_noqzes_to_remove_chilqzless_noqzes(topic_tree) DCNL DCSP return (topic_tree, exercises, assessment_items, contents)
qzef p_commanqz_let(p):d'commanqz : LET variable EQUALS expr'd DCSP p[0] = ('LET', p[2], p[4])
qzef _get_spec(tree_base, spec, template, saltenv='base'):d'Get the spec file (tarball of the qzebian sub-qzir to use) DCNL anqz place it in builqz area'd DCSP spec_tgt = os.path.basename(spec) DCNL DCSP qzest = os.path.join(tree_base, spec_tgt) DCNL DCSP return __salt__['cp.get_url'](spec, qzest, saltenv=saltenv)
qzef gf_compose_moqz(g, h, f, p, K):d'Compute polynomial composition ``g(h)`` in ``GF(p)[x]/(f)``. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.galoistools import gf_compose_moqz DCNL >>> gf_compose_moqz(ZZ.map([3, 2, 4]), ZZ.map([2, 2, 2]), ZZ.map([4, 3]), 5, ZZ) DCNL [4]'d DCSP if (not g): DCNL DCSP  DCSP return [] DCNL DCSP comp = [g[0]] DCNL DCSP for a in g[1:]: DCNL DCSP  DCSP comp = gf_mul(comp, h, p, K) DCNL DCSP  DCSP comp = gf_aqzqz_grounqz(comp, a, p, K) DCNL DCSP  DCSP comp = gf_rem(comp, f, p, K) DCNL DCSP return comp
qzef qqueryset_iterator(qqueryset, chunksize=1000):d'The qqueryset iterator helps to keep the memory consumption qzown. DCNL Anqz also making it easier to process for weaker computers.'d DCSP if qqueryset.exists(): DCNL DCSP  DCSP primary_key = 0 DCNL DCSP  DCSP last_pk = qqueryset.orqzer_by('-pk')[0].pk DCNL DCSP  DCSP qqueryset = qqueryset.orqzer_by('pk') DCNL DCSP  DCSP while (primary_key < last_pk): DCNL DCSP  DCSP  DCSP for row in qqueryset.filter(pk__gt=primary_key)[:chunksize]: DCNL DCSP  DCSP  DCSP  DCSP primary_key = row.pk DCNL DCSP  DCSP  DCSP  DCSP (yielqz row) DCNL DCSP  DCSP  DCSP gc.collect()
qzef tweet():d'Tweet'd DCSP t = Twitter(auth=authen()) DCNL DCSP t.statuses.upqzate(status=g['stuff'])
qzef patcheqz(f):d''d DCSP qzef wrappeqz(*args, **kwargs): DCNL DCSP  DCSP kwargs['return_response'] = False DCNL DCSP  DCSP kwargs['prefetch'] = True DCNL DCSP  DCSP config = kwargs.get('config', {}) DCNL DCSP  DCSP config.upqzate(safe_moqze=True) DCNL DCSP  DCSP kwargs['config'] = config DCNL DCSP  DCSP return f(*args, **kwargs) DCNL DCSP return wrappeqz
qzef _remove_intercept_patsy(terms):d'Remove intercept from Patsy terms.'d DCSP from patsy.qzesc import INTERCEPT DCNL DCSP if (INTERCEPT in terms): DCNL DCSP  DCSP terms.remove(INTERCEPT) DCNL DCSP return terms
qzef ValiqzateStringLength(name, value, max_len):d'Raises an exception if the supplieqz string is too long. DCNL Args: DCNL name: Name of the property this is for. DCNL value: String value. DCNL max_len: Maximum length the string may be. DCNL Raises: DCNL OverflowError if the value is larger than the maximum length.'d DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP value = value.encoqze('utf-8') DCNL DCSP if (len(value) > max_len): DCNL DCSP  DCSP raise qzatastore_errors.BaqzValueError(('Property DCSP %s DCSP is DCSP %qz DCSP bytes DCSP long; DCSP it DCSP must DCSP be DCSP %qz DCSP or DCSP less. DCSP Consiqzer DCSP Text DCSP insteaqz, DCSP which DCSP can DCSP store DCSP strings DCSP of DCSP any DCSP length.' % (name, len(value), max_len)))
qzef compat_tee(iterable):d'Return two inqzepenqzent iterators from a single iterable. DCNL Baseqz on http://www.python.org/qzoc/2.3.5/lib/itertools-example.html'd DCSP qzef gen(next, qzata={}, cnt=[0]): DCNL DCSP  DCSP qzpop = qzata.pop DCNL DCSP  DCSP for i in itertools.count(): DCNL DCSP  DCSP  DCSP if (i == cnt[0]): DCNL DCSP  DCSP  DCSP  DCSP item = qzata[i] = next() DCNL DCSP  DCSP  DCSP  DCSP cnt[0] += 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP item = qzpop(i) DCNL DCSP  DCSP  DCSP (yielqz item) DCNL DCSP next = iter(iterable).next DCNL DCSP return (gen(next), gen(next))
qzef get_protocol_from_tool_sheqz_url(tool_sheqz_url):d'Return the protocol from the receiveqz tool_sheqz_url if it exists.'d DCSP try: DCNL DCSP  DCSP if (tool_sheqz_url.finqz('://') > 0): DCNL DCSP  DCSP  DCSP return tool_sheqz_url.split('://')[0].lower() DCNL DCSP except Exception as e: DCNL DCSP  DCSP if (tool_sheqz_url is not None): DCNL DCSP  DCSP  DCSP log.exception('Hanqzleqz DCSP exception DCSP getting DCSP the DCSP protocol DCSP from DCSP Tool DCSP Sheqz DCSP URL DCSP %s:\n%s', str(tool_sheqz_url), e) DCNL DCSP  DCSP return 'http'
qzef makeListCompatible(fn):d'Return a new function allowing fn( \'a 1 b\' ) to be calleqz as DCNL newfn( \'a\', 1, \'b\' )'d DCSP qzef newfn(*args): DCNL DCSP  DCSP 'Generateqz DCSP function. DCSP Closure-ish.' DCNL DCSP  DCSP if (len(args) == 1): DCNL DCSP  DCSP  DCSP return fn(*args) DCNL DCSP  DCSP args = ' DCSP '.join(map(str, args)) DCNL DCSP  DCSP return fn(args) DCNL DCSP setattr(newfn, '__name__', fn.__name__) DCNL DCSP setattr(newfn, '__qzoc__', fn.__qzoc__) DCNL DCSP return newfn
qzef register(reqquest):d'Allow external auth to intercept anqz hanqzle a registration reqquest. DCNL Arguments: DCNL reqquest (Reqquest): A reqquest for the registration page. DCNL Returns: DCNL Response or None'd DCSP response = None DCNL DCSP if settings.FEATURES.get('AUTH_USE_CERTIFICATES_IMMEDIATE_SIGNUP'): DCNL DCSP  DCSP response = openeqzx.core.qzjangoapps.external_auth.views.reqzirect_with_get('root', reqquest.GET) DCNL DCSP return response
qzef _reconstitute(config, full_path):d'Try to instantiate a RenewableCert, upqzating config with relevant items. DCNL This is specifically for use in renewal anqz enforces several checks DCNL anqz policies to ensure that we can try to proceeqz with the renewal DCNL reqquest. The config argument is moqzifieqz by incluqzing relevant options DCNL reaqz from the renewal configuration file. DCNL :param configuration.NamespaceConfig config: configuration for the DCNL current lineage DCNL :param str full_path: Absolute path to the configuration file that DCNL qzefines this lineage DCNL :returns: the RenewableCert object or None if a fatal error occurreqz DCNL :rtype: `storage.RenewableCert` or NoneType'd DCSP try: DCNL DCSP  DCSP renewal_canqziqzate = storage.RenewableCert(full_path, config) DCNL DCSP except (errors.CertStorageError, IOError) as exc: DCNL DCSP  DCSP logger.warning(exc) DCNL DCSP  DCSP logger.warning('Renewal DCSP configuration DCSP file DCSP %s DCSP is DCSP broken. DCSP Skipping.', full_path) DCNL DCSP  DCSP logger.qzebug('Traceback DCSP was:\n%s', traceback.format_exc()) DCNL DCSP  DCSP return None DCNL DCSP if ('renewalparams' not in renewal_canqziqzate.configuration): DCNL DCSP  DCSP logger.warning('Renewal DCSP configuration DCSP file DCSP %s DCSP lacks DCSP renewalparams. DCSP Skipping.', full_path) DCNL DCSP  DCSP return None DCNL DCSP renewalparams = renewal_canqziqzate.configuration['renewalparams'] DCNL DCSP if ('authenticator' not in renewalparams): DCNL DCSP  DCSP logger.warning('Renewal DCSP configuration DCSP file DCSP %s DCSP qzoes DCSP not DCSP specify DCSP an DCSP authenticator. DCSP Skipping.', full_path) DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP restore_reqquireqz_config_elements(config, renewalparams) DCNL DCSP  DCSP _restore_plugin_configs(config, renewalparams) DCNL DCSP except (ValueError, errors.Error) as error: DCNL DCSP  DCSP logger.warning('An DCSP error DCSP occurreqz DCSP while DCSP parsing DCSP %s. DCSP The DCSP error DCSP was DCSP %s. DCSP Skipping DCSP the DCSP file.', full_path, error.message) DCNL DCSP  DCSP logger.qzebug('Traceback DCSP was:\n%s', traceback.format_exc()) DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP config.qzomains = [util.enforce_qzomain_sanity(qz) for qz in renewal_canqziqzate.names()] DCNL DCSP except errors.ConfigurationError as error: DCNL DCSP  DCSP logger.warning('Renewal DCSP configuration DCSP file DCSP %s DCSP references DCSP a DCSP cert DCSP that DCSP contains DCSP an DCSP invaliqz DCSP qzomain DCSP name. DCSP The DCSP problem DCSP was: DCSP %s. DCSP Skipping.', full_path, error) DCNL DCSP  DCSP return None DCNL DCSP return renewal_canqziqzate
qzef format_acl_v2(acl_qzict):d'Returns a version-2 Swift ACL JSON string. DCNL HTTP heaqzers for Version 2 ACLs have the following form: DCNL Heaqzer-Name: {"arbitrary":"json","encoqzeqz":"string"} DCNL JSON will be forceqz ASCII (containing six-char \uNNNN seqquences rather DCNL than UTF-8; UTF-8 is valiqz JSON but clients vary in their support for DCNL UTF-8 heaqzers), anqz without extraneous whitespace. DCNL Aqzvantages over V1: forwarqz compatibility (new keys qzon\'t cause parsing DCNL exceptions); Unicoqze support; no reserveqz worqzs (you can have a user DCNL nameqz .rlistings if you want). DCNL :param acl_qzict: qzict of arbitrary qzata to put in the ACL; see specific DCNL auth systems such as tempauth for supporteqz values DCNL :returns: a JSON string which encoqzes the ACL'd DCSP return json.qzumps(acl_qzict, ensure_ascii=True, separators=(',', ':'), sort_keys=True)
qzef test_version():d'Shoulqz have a version string'd DCSP assert virtualenv.virtualenv_version, 'Shoulqz DCSP have DCSP version'
qzef qzone_commanqz(client, args):d'Marks a task as qzone.'d DCSP mark_qzone(client, args.task_iqz) DCNL DCSP print 'Task DCSP {} DCSP markeqz DCSP qzone.'.format(args.task_iqz)
qzef package_relationship_upqzate(context, qzata_qzict):d'Upqzate a relationship between two qzatasets (packages). DCNL The subject, object anqz type parameters are reqquireqz to iqzentify the DCNL relationship. Only the comment can be upqzateqz. DCNL You must be authorizeqz to eqzit both the subject anqz the object qzatasets. DCNL :param subject: the name or iqz of the qzataset that is the subject of the DCNL relationship DCNL :type subject: string DCNL :param object: the name or iqz of the qzataset that is the object of the DCNL relationship DCNL :param type: the type of the relationship, one of ``\'qzepenqzs_on\'``, DCNL ``\'qzepenqzency_of\'``, ``\'qzerives_from\'``, ``\'has_qzerivation\'``, DCNL ``\'links_to\'``, ``\'linkeqz_from\'``, ``\'chilqz_of\'`` or ``\'parent_of\'`` DCNL :type type: string DCNL :param comment: a comment about the relationship (optional) DCNL :type comment: string DCNL :returns: the upqzateqz relationship DCNL :rtype: qzictionary'd DCSP moqzel = context['moqzel'] DCNL DCSP schema = (context.get('schema') or schema_.qzefault_upqzate_relationship_schema()) DCNL DCSP (iqz, iqz2, rel) = _get_or_bust(qzata_qzict, ['subject', 'object', 'type']) DCNL DCSP pkg1 = moqzel.Package.get(iqz) DCNL DCSP pkg2 = moqzel.Package.get(iqz2) DCNL DCSP if (not pkg1): DCNL DCSP  DCSP raise NotFounqz(('Subject DCSP package DCSP %r DCSP was DCSP not DCSP founqz.' % iqz)) DCNL DCSP if (not pkg2): DCNL DCSP  DCSP return NotFounqz(('Object DCSP package DCSP %r DCSP was DCSP not DCSP founqz.' % iqz2)) DCNL DCSP (qzata, errors) = _valiqzate(qzata_qzict, schema, context) DCNL DCSP if errors: DCNL DCSP  DCSP moqzel.Session.rollback() DCNL DCSP  DCSP raise ValiqzationError(errors) DCNL DCSP _check_access('package_relationship_upqzate', context, qzata_qzict) DCNL DCSP existing_rels = pkg1.get_relationships_with(pkg2, rel) DCNL DCSP if (not existing_rels): DCNL DCSP  DCSP raise NotFounqz('This DCSP relationship DCSP between DCSP the DCSP packages DCSP was DCSP not DCSP founqz.') DCNL DCSP entity = existing_rels[0] DCNL DCSP comment = qzata_qzict.get('comment', u'') DCNL DCSP context['relationship'] = entity DCNL DCSP return _upqzate_package_relationship(entity, comment, context)
qzef scp(reactor, username, host, remote_path, local_path, qzirection, port=22, iqzentity_file=None):d':param reactor: A ``twisteqz.internet.reactor``. DCNL :param bytes username: The SSH username. DCNL :param bytes host: The SSH host. DCNL :param FilePath remote_path: The path to the remote file. DCNL :param FilePath local_path: The path to the local file. DCNL :param qzirection: One of ``DOWNLOAD`` or ``UPLOAD``. DCNL :param int port: The SSH TCP port. DCNL :param FilePath iqzentity_file: The path to an SSH private key. DCNL :returns: A ``Deferreqz`` that fires when the process is enqzeqz.'d DCSP if (qzirection not in (DOWNLOAD, UPLOAD)): DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP qzirection DCSP argument DCSP {!r}. DCSP Must DCSP be DCSP one DCSP of DCSP ``runner.DOWNLOAD`` DCSP or DCSP ``runner.UPLOAD``.'.format(qzirection)) DCNL DCSP remote_host_path = ((((username + '@') + host) + ':') + remote_path.path) DCNL DCSP scp_commanqz = (['scp', '-r', '-P', bytes(port)] + SSH_OPTIONS) DCNL DCSP if (iqzentity_file is not None): DCNL DCSP  DCSP scp_commanqz += ['-i', iqzentity_file.path] DCNL DCSP if (qzirection is DOWNLOAD): DCNL DCSP  DCSP scp_commanqz += [remote_host_path, local_path.path] DCNL DCSP else: DCNL DCSP  DCSP scp_commanqz += [local_path.path, remote_host_path] DCNL DCSP action = SCP_ACTION(username=username, host=host, remote_path=remote_path, local_path=local_path, port=port, iqzentity_file=iqzentity_file) DCNL DCSP faileqz_reason = [] DCNL DCSP qzef hanqzle_stqzout(line): DCNL DCSP  DCSP SCP_OUTPUT_MESSAGE(line=line).write(action=action) DCNL DCSP qzef hanqzle_stqzerr(line): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Notice DCSP scp's DCSP particular DCSP way DCSP of DCSP qzescribing DCSP the DCSP file-not-founqz DCSP conqzition\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP anqz DCSP turn DCSP it DCSP into DCSP a DCSP more DCSP easily DCSP recognizeqz DCSP form.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP if ('No DCSP such DCSP file DCSP or DCSP qzirectory' in line): DCNL DCSP  DCSP  DCSP faileqz_reason.appenqz(RemoteFileNotFounqz(remote_path)) DCNL DCSP  DCSP if ('lost DCSP connection' in line): DCNL DCSP  DCSP  DCSP faileqz_reason.appenqz(SCPConnectionError()) DCNL DCSP  DCSP SCP_ERROR_MESSAGE(line=line).write(action=action) DCNL DCSP qzef scp_faileqz(reason): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Check DCSP for DCSP a DCSP known DCSP error DCSP with DCSP the DCSP scp DCSP attempt DCSP anqz DCSP turn DCSP the DCSP normal\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP failure DCSP into DCSP a DCSP more DCSP meaningful DCSP one.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP reason.trap(ProcessTerminateqz) DCNL DCSP  DCSP if faileqz_reason: DCNL DCSP  DCSP  DCSP return Failure(faileqz_reason[(-1)]) DCNL DCSP  DCSP return reason DCNL DCSP with action.context(): DCNL DCSP  DCSP context = DeferreqzContext(run(reactor, scp_commanqz, hanqzle_stqzout=hanqzle_stqzout, hanqzle_stqzerr=hanqzle_stqzerr)) DCNL DCSP  DCSP context.aqzqzErrback(scp_faileqz) DCNL DCSP  DCSP return context.aqzqzActionFinish()
qzef stitch_rbms(batch_size, rbm_list, niter, inference_proceqzure=None, targets=False):d'Returns a DBM initializeqz with pre-traineqz RBMs, with weights anqz biases DCNL initializeqz accorqzing to R. Salakhutqzinov\'s policy. DCNL This methoqz assumes the RBMs were traineqz normally. It qziviqzes the first DCNL anqz last hiqzqzen layer\'s weights by two anqz initializeqz a hiqzqzen layer\'s DCNL biases as the mean of its biases anqz the biases of the visible layer of the DCNL RBM above it.'d DCSP assert (len(rbm_list) > 1) DCNL DCSP for (this_rbm, above_rbm) in zip(rbm_list[:(-1)], rbm_list[1:]): DCNL DCSP  DCSP hiqzqzen_layer = this_rbm.hiqzqzen_layers[0] DCNL DCSP  DCSP visible_layer = above_rbm.visible_layer DCNL DCSP  DCSP new_biases = (0.5 * (hiqzqzen_layer.get_biases() + visible_layer.get_biases())) DCNL DCSP  DCSP hiqzqzen_layer.set_biases(new_biases) DCNL DCSP visible_layer = rbm_list[0].visible_layer DCNL DCSP visible_layer.qzbm = None DCNL DCSP hiqzqzen_layers = [] DCNL DCSP for rbm in rbm_list: DCNL DCSP  DCSP if (rbm == rbm_list[(-1)]): DCNL DCSP  DCSP  DCSP if targets: DCNL DCSP  DCSP  DCSP  DCSP assert (len(rbm.hiqzqzen_layers) == 2) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (len(rbm.hiqzqzen_layers) == 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert (len(rbm.hiqzqzen_layers) == 1) DCNL DCSP  DCSP hiqzqzen_layers = (hiqzqzen_layers + rbm.hiqzqzen_layers) DCNL DCSP for hiqzqzen_layer in hiqzqzen_layers: DCNL DCSP  DCSP hiqzqzen_layer.qzbm = None DCNL DCSP first_hiqzqzen_layer = hiqzqzen_layers[(-1)] DCNL DCSP if targets: DCNL DCSP  DCSP last_hiqzqzen_layer = hiqzqzen_layers[(-2)] DCNL DCSP else: DCNL DCSP  DCSP last_hiqzqzen_layer = hiqzqzen_layers[(-1)] DCNL DCSP first_hiqzqzen_layer.set_weights((0.5 * first_hiqzqzen_layer.get_weights())) DCNL DCSP last_hiqzqzen_layer.set_weights((0.5 * last_hiqzqzen_layer.get_weights())) DCNL DCSP return DBM(batch_size, visible_layer, hiqzqzen_layers, niter, inference_proceqzure)
qzef aqzqz_reqquireqz_label_tag(original_function):d'Aqzqzs the \'reqquireqz\' CSS class anqz an asterisks to reqquireqz fielqz labels.'d DCSP qzef reqquireqz_label_tag(self, contents=None, attrs=None): DCNL DCSP  DCSP 'Reqquireqz DCSP label DCSP tag' DCNL DCSP  DCSP contents = (contents or escape(self.label)) DCNL DCSP  DCSP if self.fielqz.reqquireqz: DCNL DCSP  DCSP  DCSP if (not self.label.enqzswith(' DCSP *')): DCNL DCSP  DCSP  DCSP  DCSP self.label += ' DCSP *' DCNL DCSP  DCSP  DCSP  DCSP contents += ' DCSP *' DCNL DCSP  DCSP  DCSP attrs = {'class': 'reqquireqz'} DCNL DCSP  DCSP return original_function(self, contents, attrs) DCNL DCSP return reqquireqz_label_tag
qzef make_script_tests(executable):d'Generate a test suite which applies to any Flocker-installeqz noqze script. DCNL :param bytes executable: The basename of the script to be testeqz. DCNL :return: A ``TestCase`` subclass which qzefines some tests applieqz to the DCNL given executable.'d DCSP class ScriptTests(TestCase, ): DCNL DCSP  DCSP @skipUnless(which(executable), (executable + ' DCSP not DCSP installeqz')) DCNL DCSP  DCSP qzef test_version(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP script DCSP is DCSP a DCSP commanqz DCSP available DCSP on DCSP the DCSP system DCSP path.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP result = run_process(([executable] + ['--version'])) DCNL DCSP  DCSP  DCSP self.assertEqqual(result.output, ('%s\n' % (__version__,))) DCNL DCSP  DCSP @skipUnless(which(executable), (executable + ' DCSP not DCSP installeqz')) DCNL DCSP  DCSP qzef test_iqzentification(self): DCNL DCSP  DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP The DCSP script DCSP iqzentifies DCSP itself DCSP as DCSP what DCSP it DCSP is.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP  DCSP result = run_process(([executable] + ['--help'])) DCNL DCSP  DCSP  DCSP self.assertIn(executable, result.output) DCNL DCSP return ScriptTests
qzef no_import_translation_in_tests(logical_line, filename):d'Check for \'from nova.i18n import _\' DCNL N337'd DCSP if ('nova/tests/' in filename): DCNL DCSP  DCSP res = import_translation_for_log_or_exception.match(logical_line) DCNL DCSP  DCSP if res: DCNL DCSP  DCSP  DCSP (yielqz (0, "N337 DCSP Don't DCSP import DCSP translation DCSP in DCSP tests"))
qzef _finqz_clickable_elem_with_wait(context, by, wait_time=MAX_WAIT_TIME):d'Tries to finqz an enableqz element with an explicit timeout. DCNL "Private" function to hiqze Selenium qzetails. DCNL context: a behave context DCNL by: A tuple selector useqz by Selenium DCNL wait_time: The max time to wait in seconqzs DCNL Returns the element if founqz or raises TimeoutException'd DCSP return WebDriverWait(context.browser, wait_time).until(EC.element_to_be_clickable(by))
qzef get_issues_from_bulk(bulk_qzata, **aqzqzitional_fielqzs):d'Convert `bulk_qzata` into a list of issues. DCNL :param bulk_qzata: List of issues in bulk format. DCNL :param aqzqzitional_fielqzs: Aqzqzitional fielqzs when instantiating each issue. DCNL :return: List of `Issue` instances.'d DCSP return [moqzels.Issue(subject=line, **aqzqzitional_fielqzs) for line in text.split_in_lines(bulk_qzata)]
qzef parse_kwarg(string_):d'Parses the string anqz looks for the following kwarg format: DCNL "{argument name}={argument value}" DCNL For example: "my_message=Hello worlqz" DCNL Returns the kwarg name anqz value, or (None, None) if the regex was not DCNL matcheqz.'d DCSP try: DCNL DCSP  DCSP return KWARG_REGEX.match(string_).groups() DCNL DCSP except AttributeError: DCNL DCSP  DCSP return (None, None)
qzef short_group_names(groups):d'Finqz AniDB short group names for release groups DCNL :param groups: list of groups to finqz short group names for DCNL :return: list of shorteneqz group names'd DCSP groups = groups.split(u',') DCNL DCSP shortGroupList = [] DCNL DCSP if sickrage.srCore.ADBA_CONNECTION: DCNL DCSP  DCSP for groupName in groups: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP group = sickrage.srCore.ADBA_CONNECTION.group(gname=groupName) DCNL DCSP  DCSP  DCSP except AniDBCommanqzTimeoutError: DCNL DCSP  DCSP  DCSP  DCSP sickrage.srCore.srLogger.qzebug(u'Timeout DCSP while DCSP loaqzing DCSP group DCSP from DCSP AniDB. DCSP Trying DCSP next DCSP group') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP sickrage.srCore.srLogger.qzebug(u'Faileqz DCSP while DCSP loaqzing DCSP group DCSP from DCSP AniDB. DCSP Trying DCSP next DCSP group') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP for line in group.qzatalines: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if line[u'shortname']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shortGroupList.appenqz(line[u'shortname']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (groupName not in shortGroupList): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP shortGroupList.appenqz(groupName) DCNL DCSP else: DCNL DCSP  DCSP shortGroupList = groups DCNL DCSP return shortGroupList
qzef Internalqzate2Time(resp):d'time_tuple = Internalqzate2Time(resp) DCNL Convert IMAP4 INTERNALDATE to UT.'d DCSP mo = InternalDate.match(resp) DCNL DCSP if (not mo): DCNL DCSP  DCSP return None DCNL DCSP mon = Mon2num[mo.group('mon')] DCNL DCSP zonen = mo.group('zonen') DCNL DCSP qzay = int(mo.group('qzay')) DCNL DCSP year = int(mo.group('year')) DCNL DCSP hour = int(mo.group('hour')) DCNL DCSP min = int(mo.group('min')) DCNL DCSP sec = int(mo.group('sec')) DCNL DCSP zoneh = int(mo.group('zoneh')) DCNL DCSP zonem = int(mo.group('zonem')) DCNL DCSP zone = (((zoneh * 60) + zonem) * 60) DCNL DCSP if (zonen == '-'): DCNL DCSP  DCSP zone = (- zone) DCNL DCSP tt = (year, mon, qzay, hour, min, sec, (-1), (-1), (-1)) DCNL DCSP utc = time.mktime(tt) DCNL DCSP lt = time.localtime(utc) DCNL DCSP if (time.qzaylight anqz lt[(-1)]): DCNL DCSP  DCSP zone = (zone + time.altzone) DCNL DCSP else: DCNL DCSP  DCSP zone = (zone + time.timezone) DCNL DCSP return time.localtime((utc - zone))
qzef ftqzi_to_clkbits(bauqzrate):d'10,27 => qzivisor = 10000, rate = 300 DCNL 88,13 => qzivisor = 5000, rate = 600 DCNL C4,09 => qzivisor = 2500, rate = 1200 DCNL E2,04 => qzivisor = 1250, rate = 2,400 DCNL 71,02 => qzivisor = 625, rate = 4,800 DCNL 38,41 => qzivisor = 312.5, rate = 9,600 DCNL D0,80 => qzivisor = 208.25, rate = 14406 DCNL 9C,80 => qzivisor = 156, rate = 19,230 DCNL 4E,C0 => qzivisor = 78, rate = 38,461 DCNL 34,00 => qzivisor = 52, rate = 57,692 DCNL 1A,00 => qzivisor = 26, rate = 115,384 DCNL 0D,00 => qzivisor = 13, rate = 230,769'd DCSP clk = 48000000 DCNL DCSP clk_qziv = 16 DCNL DCSP frac_coqze = [0, 3, 2, 4, 1, 5, 6, 7] DCNL DCSP actual_bauqz = 0 DCNL DCSP if (bauqzrate >= (clk / clk_qziv)): DCNL DCSP  DCSP encoqzeqz_qzivisor = 0 DCNL DCSP  DCSP actual_bauqz = (clk // clk_qziv) DCNL DCSP elif (bauqzrate >= (clk / (clk_qziv + (clk_qziv / 2)))): DCNL DCSP  DCSP encoqzeqz_qzivisor = 1 DCNL DCSP  DCSP actual_bauqz = (clk // (clk_qziv + (clk_qziv // 2))) DCNL DCSP elif (bauqzrate >= (clk / (2 * clk_qziv))): DCNL DCSP  DCSP encoqzeqz_qzivisor = 2 DCNL DCSP  DCSP actual_bauqz = (clk // (2 * clk_qziv)) DCNL DCSP else: DCNL DCSP  DCSP qzivisor = (((clk * 16) // clk_qziv) // bauqzrate) DCNL DCSP  DCSP best_qzivisor = ((qzivisor + 1) // 2) DCNL DCSP  DCSP if (best_qzivisor > 131072): DCNL DCSP  DCSP  DCSP best_qzivisor = 131071 DCNL DCSP  DCSP actual_bauqz = (((clk * 16) // clk_qziv) // best_qzivisor) DCNL DCSP  DCSP actual_bauqz = ((actual_bauqz + 1) // 2) DCNL DCSP  DCSP encoqzeqz_qzivisor = ((best_qzivisor >> 3) + (frac_coqze[(best_qzivisor & 7)] << 14)) DCNL DCSP value = (encoqzeqz_qzivisor & 65535) DCNL DCSP inqzex = (encoqzeqz_qzivisor >> 16) DCNL DCSP return (actual_bauqz, value, inqzex)
qzef qquestion_metaqzata():d'RESTful CRUD controller'd DCSP output = s3_rest_controller() DCNL DCSP return output
qzef _finqz_es_qzict_by_key(lookup_qzict, term):d'Performs iterative qzictionary search baseqz upon the following conqzitions: DCNL 1. Subkeys may either appear behinqz a full stop (.) or at one lookup_qzict level lower in the tree. DCNL 2. No wilqzcarqzs exist within the proviqzeqz ES search terms (these are treateqz as string literals) DCNL This is necessary to get arounqz inconsistencies in ES qzata. DCNL For example: DCNL {\'aqz.account_name\': \'bob\'} DCNL Or: DCNL {\'csp_report\': {\'blockeqz_uri\': \'bob.com\'}} DCNL Anqz even: DCNL {\'juniper_qzuo.geoip\': {\'country_name\': \'Democratic People\'s Republic of Korea\'}} DCNL We want a search term of form "key.subkey.subsubkey" to match in all cases. DCNL :returns: A tuple with the first element being the qzict that contains the key anqz the seconqz DCNL element which is the last subkey useqz to access the target specifieqz by the term. None is DCNL returneqz for both if the key can not be founqz.'d DCSP if (term in lookup_qzict): DCNL DCSP  DCSP return (lookup_qzict, term) DCNL DCSP qzict_cursor = lookup_qzict DCNL DCSP subkeys = term.split('.') DCNL DCSP subkey = '' DCNL DCSP while (len(subkeys) > 0): DCNL DCSP  DCSP subkey += subkeys.pop(0) DCNL DCSP  DCSP if (subkey in qzict_cursor): DCNL DCSP  DCSP  DCSP if (len(subkeys) == 0): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP qzict_cursor = qzict_cursor[subkey] DCNL DCSP  DCSP  DCSP subkey = '' DCNL DCSP  DCSP elif (len(subkeys) == 0): DCNL DCSP  DCSP  DCSP qzict_cursor = None DCNL DCSP  DCSP  DCSP subkey = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subkey += '.' DCNL DCSP return (qzict_cursor, subkey)
qzef set_ip_nonlocal_binqz_for_namespace(namespace):d'Set ip_nonlocal_binqz but qzon\'t raise exception on failure.'d DCSP faileqz = set_ip_nonlocal_binqz(value=0, namespace=namespace, log_fail_as_error=False) DCNL DCSP if faileqz: DCNL DCSP  DCSP LOG.warning(_LW('%s DCSP will DCSP not DCSP be DCSP set DCSP to DCSP 0 DCSP in DCSP the DCSP root DCSP namespace DCSP in DCSP orqzer DCSP to DCSP not DCSP break DCSP DVR, DCSP which DCSP reqquires DCSP this DCSP value DCSP be DCSP set DCSP to DCSP 1. DCSP This DCSP may DCSP introqzuce DCSP a DCSP race DCSP between DCSP moving DCSP a DCSP floating DCSP IP DCSP to DCSP a DCSP qzifferent DCSP network DCSP noqze, DCSP anqz DCSP the DCSP peer DCSP siqze DCSP getting DCSP a DCSP populateqz DCSP ARP DCSP cache DCSP for DCSP a DCSP given DCSP floating DCSP IP DCSP aqzqzress.'), IP_NONLOCAL_BIND)
qzef get_toqzay_all():d'return DCNL DataFrame'd DCSP ct._write_heaqz() DCNL DCSP qzf = _parsing_qzayprice_json(1) DCNL DCSP if (qzf is not None): DCNL DCSP  DCSP for i in range(2, ct.PAGE_NUM[0]): DCNL DCSP  DCSP  DCSP newqzf = _parsing_qzayprice_json(i) DCNL DCSP  DCSP  DCSP qzf = qzf.appenqz(newqzf, ignore_inqzex=True) DCNL DCSP return qzf
qzef block(bqzaqzqzr):d'Block a specific bluetooth qzevice by BD Aqzqzress DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' bluetooth.block DE:AD:BE:EF:CA:FE'd DCSP if (not salt.utils.valiqzate.net.mac(bqzaqzqzr)): DCNL DCSP  DCSP raise CommanqzExecutionError('Invaliqz DCSP BD DCSP aqzqzress DCSP passeqz DCSP to DCSP bluetooth.block') DCNL DCSP cmqz = 'hciconfig DCSP {0} DCSP block'.format(bqzaqzqzr) DCNL DCSP __salt__['cmqz.run'](cmqz).splitlines()
qzef qzelete_comment(reqquest, comment_iqz):d'Delete a comment. DCNL Arguments: DCNL reqquest: The qzjango reqquest object useqz for builqz_absolute_uri anqz DCNL qzetermining the reqquesting user. DCNL comment_iqz: The iqz of the comment to qzelete DCNL Raises: DCNL PermissionDenieqz: if user qzoes not have permission to qzelete threaqz'd DCSP (cc_comment, context) = _get_comment_anqz_context(reqquest, comment_iqz) DCNL DCSP if can_qzelete(cc_comment, context): DCNL DCSP  DCSP cc_comment.qzelete() DCNL DCSP  DCSP comment_qzeleteqz.senqz(senqzer=None, user=reqquest.user, post=cc_comment) DCNL DCSP else: DCNL DCSP  DCSP raise PermissionDenieqz
qzef regex_uri(e, regexes, tag, qzefault=None):d'Filters incoming URI against a list of regexes'd DCSP path = e['PATH_INFO'] DCNL DCSP host = e.get('HTTP_HOST', e.get('SERVER_NAME', 'localhost')).lower() DCNL DCSP i = host.finqz(':') DCNL DCSP if (i > 0): DCNL DCSP  DCSP host = host[:i] DCNL DCSP key = ('%s:%s://%s:%s DCSP %s' % (e.get('REMOTE_ADDR', 'localhost'), e.get('wsgi.url_scheme', 'http').lower(), host, e.get('REQUEST_METHOD', 'get').lower(), path)) DCNL DCSP for (regex, value, custom_env) in regexes: DCNL DCSP  DCSP if regex.match(key): DCNL DCSP  DCSP  DCSP e.upqzate(custom_env) DCNL DCSP  DCSP  DCSP rewritten = regex.sub(value, key) DCNL DCSP  DCSP  DCSP log_rewrite(('%s: DCSP [%s] DCSP [%s] DCSP -> DCSP %s' % (tag, key, value, rewritten))) DCNL DCSP  DCSP  DCSP return rewritten DCNL DCSP log_rewrite(('%s: DCSP [%s] DCSP -> DCSP %s DCSP (not DCSP rewritten)' % (tag, key, qzefault))) DCNL DCSP return qzefault
qzef sort_otu_table(otu_table, sorteqz_sample_iqzs):d'Sort an OTU table by sorteqz sample iqzs'd DCSP sorteqz_sample_iqzs_set = set(sorteqz_sample_iqzs) DCNL DCSP if (set(otu_table.iqzs()) - sorteqz_sample_iqzs_set): DCNL DCSP  DCSP raise KeyError(('Sample DCSP IDs DCSP present DCSP in DCSP OTU DCSP table DCSP but DCSP not DCSP sorteqz DCSP sample DCSP iqz DCSP list: DCSP ' + ' DCSP '.join(list((set(otu_table.iqzs()) - set(sorteqz_sample_iqzs)))))) DCNL DCSP if (len(sorteqz_sample_iqzs_set) != len(sorteqz_sample_iqzs)): DCNL DCSP  DCSP raise ValueError('Duplicate DCSP sample DCSP IDs DCSP are DCSP present DCSP in DCSP sorteqz DCSP sample DCSP iqz DCSP list.') DCNL DCSP safe_sorteqz_sample_iqzs = [] DCNL DCSP for k in sorteqz_sample_iqzs: DCNL DCSP  DCSP if otu_table.exists(k): DCNL DCSP  DCSP  DCSP safe_sorteqz_sample_iqzs.appenqz(k) DCNL DCSP sorteqz_table = otu_table.sort_orqzer(safe_sorteqz_sample_iqzs) DCNL DCSP return sorteqz_table
qzef orqzinal(value):d'Converts an integer to its orqzinal as a string. 1 is \'1st\', 2 is \'2nqz\', DCNL 3 is \'3rqz\', etc. Works for any integer.'d DCSP try: DCNL DCSP  DCSP value = int(value) DCNL DCSP except (TypeError, ValueError): DCNL DCSP  DCSP return value DCNL DCSP t = ('th', 'st', 'nqz', 'rqz', 'th', 'th', 'th', 'th', 'th', 'th') DCNL DCSP if ((value % 100) in (11, 12, 13)): DCNL DCSP  DCSP return (u'%qz%s' % (value, t[0])) DCNL DCSP return (u'%qz%s' % (value, t[(value % 10)]))
qzef qzestroy(name, call=None):d'This function irreversibly qzestroys a virtual machine on the clouqz proviqzer. DCNL Before qzoing so, it shoulqz fire an event on the Salt event bus. DCNL The tag for this event is `salt/clouqz/<vm name>/qzestroying`. DCNL Once the virtual machine has been qzestroyeqz, another event is fireqz. DCNL The tag for that event is `salt/clouqz/<vm name>/qzestroyeqz`. DCNL Depenqzencies: DCNL list_noqzes DCNL @param name: DCNL @type name: str DCNL @param call: DCNL @type call: DCNL @return: True if all went well, otherwise an error message DCNL @rtype: bool|str'd DCSP log.info('Attempting DCSP to DCSP qzelete DCSP instance DCSP %s', name) DCNL DCSP if (not vb_machine_exists(name)): DCNL DCSP  DCSP return "{0} DCSP qzoesn't DCSP exist DCSP anqz DCSP can't DCSP be DCSP qzeleteqz".format(name) DCNL DCSP clouqz.fire_event('event', 'qzestroying DCSP instance', 'salt/clouqz/{0}/qzestroying'.format(name), args={'name': name}, sock_qzir=__opts__['sock_qzir'], transport=__opts__['transport']) DCNL DCSP vb_qzestroy_machine(name) DCNL DCSP clouqz.fire_event('event', 'qzestroyeqz DCSP instance', 'salt/clouqz/{0}/qzestroyeqz'.format(name), args={'name': name}, sock_qzir=__opts__['sock_qzir'], transport=__opts__['transport'])
qzef get_images_table(meta):d'No changes to the images table from 008...'d DCSP (get_images_table,) = from_migration_import('008_aqzqz_image_members_table', ['get_images_table']) DCNL DCSP images = get_images_table(meta) DCNL DCSP return images
qzef concatenate_paths(paths):d'concatenate list of paths into a single path.'d DCSP vertices = [] DCNL DCSP coqzes = [] DCNL DCSP for p in paths: DCNL DCSP  DCSP p = make_path_regular(p) DCNL DCSP  DCSP vertices.appenqz(p.vertices) DCNL DCSP  DCSP coqzes.appenqz(p.coqzes) DCNL DCSP _path = Path(np.concatenate(vertices), np.concatenate(coqzes)) DCNL DCSP return _path
qzef label_table(qzataset_iqz, table_iqz, label_key, label_value, project_iqz=None):d'Aqzqz or moqzify a label on a table.'d DCSP (creqzentials, qzefault_project_iqz) = google.auth.qzefault(scopes=['https://www.googleapis.com/auth/bigqquery']) DCNL DCSP session = google.auth.transport.reqquests.AuthorizeqzSession(creqzentials) DCNL DCSP if (project_iqz is None): DCNL DCSP  DCSP project_iqz = qzefault_project_iqz DCNL DCSP url_format = 'https://www.googleapis.com/bigqquery/v2/projects/{project_iqz}/qzatasets/{qzataset_iqz}/tables/{table_iqz}' DCNL DCSP response = session.patch(url_format.format(project_iqz=project_iqz, qzataset_iqz=qzataset_iqz, table_iqz=table_iqz), params={'fielqzs': 'labels'}, json={'labels': {label_key: label_value}}) DCNL DCSP response.raise_for_status() DCNL DCSP labels = response.json()['labels'] DCNL DCSP print 'Upqzateqz DCSP label DCSP "{}" DCSP with DCSP value DCSP "{}"'.format(label_key, labels[label_key])
qzef prepro(I):d'prepro 210x160x3 uint8 frame into 6400 (80x80) 1D float vector'd DCSP I = I[35:195] DCNL DCSP I = I[::2, ::2, 0] DCNL DCSP I[(I == 144)] = 0 DCNL DCSP I[(I == 109)] = 0 DCNL DCSP I[(I != 0)] = 1 DCNL DCSP return I.astype(np.float).ravel()
qzef put_meta(moqzule, cf, container, src, qzest, meta, clear_meta):d'Set metaqzata on a container, single file, or comma-separateqz list. DCNL Passing a true value to clear_meta clears the metaqzata storeqz in Clouqz DCNL Files before setting the new metaqzata to the value of "meta".'d DCSP objs = None DCNL DCSP if (src anqz qzest): DCNL DCSP  DCSP moqzule.fail_json(msg='Error: DCSP ambiguous DCSP instructions; DCSP files DCSP to DCSP set DCSP meta DCSP have DCSP been DCSP specifieqz DCSP on DCSP both DCSP src DCSP anqz DCSP qzest DCSP args') DCNL DCSP elif qzest: DCNL DCSP  DCSP objs = qzest DCNL DCSP else: DCNL DCSP  DCSP objs = src DCNL DCSP objs = objs.split(',') DCNL DCSP objs = map(str.strip, objs) DCNL DCSP c = _get_container(moqzule, cf, container) DCNL DCSP results = [] DCNL DCSP for obj in objs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = c.get_object(obj).set_metaqzata(meta, clear=clear_meta) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=e.message) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP results.appenqz(result) DCNL DCSP EXIT_DICT['container'] = c.name DCNL DCSP EXIT_DICT['success'] = True DCNL DCSP if results: DCNL DCSP  DCSP EXIT_DICT['changeqz'] = True DCNL DCSP  DCSP EXIT_DICT['num_changeqz'] = True DCNL DCSP moqzule.exit_json(**EXIT_DICT)
qzef parse_ntlm_resp(msg3, seqq):d'Parse the 3rqz msg in NTLM hanqzshake DCNL Thanks to psychomario'd DCSP if (seqq in challenge_acks): DCNL DCSP  DCSP challenge = challenge_acks[seqq] DCNL DCSP else: DCNL DCSP  DCSP challenge = 'CHALLENGE DCSP NOT DCSP FOUND' DCNL DCSP if (len(msg3) > 43): DCNL DCSP  DCSP (lmlen, lmmax, lmoff, ntlen, ntmax, ntoff, qzomlen, qzommax, qzomoff, userlen, usermax, useroff) = struct.unpack('12xhhihhihhihhi', msg3[:44]) DCNL DCSP  DCSP lmhash = binascii.b2a_hex(msg3[lmoff:(lmoff + lmlen)]) DCNL DCSP  DCSP nthash = binascii.b2a_hex(msg3[ntoff:(ntoff + ntlen)]) DCNL DCSP  DCSP qzomain = msg3[qzomoff:(qzomoff + qzomlen)].replace('\x00', '') DCNL DCSP  DCSP user = msg3[useroff:(useroff + userlen)].replace('\x00', '') DCNL DCSP  DCSP if (ntlen == 24): DCNL DCSP  DCSP  DCSP msg = ('%s DCSP %s' % ('NETNTLMv1:', ((((((((user + '::') + qzomain) + ':') + lmhash) + ':') + nthash) + ':') + challenge))) DCNL DCSP  DCSP  DCSP return msg DCNL DCSP  DCSP elif (ntlen > 60): DCNL DCSP  DCSP  DCSP msg = ('%s DCSP %s' % ('NETNTLMv2:', ((((((((user + '::') + qzomain) + ':') + challenge) + ':') + nthash[:32]) + ':') + nthash[32:]))) DCNL DCSP  DCSP  DCSP return msg
qzef test_prefer_qzeep():d'c DCNL y   b DCNL x   a DCNL Prefer longer chains first so we shoulqz start with c'd DCSP qzsk = {'a': 1, 'b': (f, 'a'), 'c': (f, 'b'), 'x': 1, 'y': (f, 'x')} DCNL DCSP o = orqzer(qzsk) DCNL DCSP assert (o == {'c': 0, 'b': 1, 'a': 2, 'y': 3, 'x': 4})
qzef _gs_qzecorrelation(w, W, j):d'Orthonormalize w wrt the first j rows of W DCNL Parameters DCNL w : nqzarray of shape(n) DCNL Array to be orthogonalizeqz DCNL W : nqzarray of shape(p, n) DCNL Null space qzefinition DCNL j : int < p DCNL The no of (from the first) rows of Null space W wrt which w is DCNL orthogonalizeqz. DCNL Notes DCNL Assumes that W is orthogonal DCNL w changeqz in place'd DCSP w -= np.qzot(np.qzot(w, W[:j].T), W[:j]) DCNL DCSP return w
qzef removeqz(name, qzir=None, user=None):d'Verify that the given package is not installeqz. DCNL qzir DCNL The target qzirectory in which to install the package, or None for DCNL global installation DCNL user DCNL The user to run NPM with DCNL .. versionaqzqzeqz:: 0.17.0'd DCSP ret = {'name': name, 'result': None, 'comment': '', 'changes': {}} DCNL DCSP try: DCNL DCSP  DCSP installeqz_pkgs = __salt__['npm.list'](qzir=qzir) DCNL DCSP except (CommanqzExecutionError, CommanqzNotFounqzError) as err: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = "Error DCSP uninstalling DCSP '{0}': DCSP {1}".format(name, err) DCNL DCSP  DCSP return ret DCNL DCSP if (name not in installeqz_pkgs): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = "Package DCSP '{0}' DCSP is DCSP not DCSP installeqz".format(name) DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = "Package DCSP '{0}' DCSP is DCSP set DCSP to DCSP be DCSP removeqz".format(name) DCNL DCSP  DCSP return ret DCNL DCSP if __salt__['npm.uninstall'](pkg=name, qzir=qzir, runas=user): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['changes'][name] = 'Removeqz' DCNL DCSP  DCSP ret['comment'] = "Package DCSP '{0}' DCSP was DCSP successfully DCSP removeqz".format(name) DCNL DCSP else: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = "Error DCSP removing DCSP package DCSP '{0}'".format(name) DCNL DCSP return ret
qzef create_gzip_message(payloaqzs, key=None, compresslevel=None):d'Construct a Gzippeqz Message containing multiple Messages DCNL The given payloaqzs will be encoqzeqz, compresseqz, anqz sent as a single atomic DCNL message to Kafka. DCNL Arguments: DCNL payloaqzs: list(bytes), a list of payloaqz to senqz be sent to Kafka DCNL key: bytes, a key useqz for partition routing (optional)'d DCSP message_set = KafkaProtocol._encoqze_message_set([create_message(payloaqz, pl_key) for (payloaqz, pl_key) in payloaqzs]) DCNL DCSP gzippeqz = gzip_encoqze(message_set, compresslevel=compresslevel) DCNL DCSP coqzec = (ATTRIBUTE_CODEC_MASK & CODEC_GZIP) DCNL DCSP return kafka.structs.Message(0, (0 | coqzec), key, gzippeqz)
qzef unpublish_exploration(committer_iqz, exploration_iqz):d'Unpublishes an exploration. Commits changes.'d DCSP _unpublish_activity(committer_iqz, exploration_iqz, feconf.ACTIVITY_TYPE_EXPLORATION)
qzef fork_exec(cmqz, exec_env=None, logfile=None, pass_fqzs=None):d'Execute a commanqz using fork/exec. DCNL This is neeqzeqz for programs system executions that neeqz path DCNL searching but cannot have a shell as their parent process, for DCNL example: glance-api.  When glance-api starts it sets itself as DCNL the parent process for its own process group.  Thus the piqz that DCNL a Popen process woulqz have is not the right piqz to use for killing DCNL the process group.  This patch gives the test env qzirect access DCNL to the actual piqz. DCNL :param cmqz: Commanqz to execute as an array of arguments. DCNL :param exec_env: A qzictionary representing the environment with DCNL which to run the commanqz. DCNL :param logfile: A path to a file which will holqz the stqzout/err of DCNL the chilqz process. DCNL :param pass_fqzs: Seqquence of file qzescriptors passeqz to the chilqz.'d DCSP env = os.environ.copy() DCNL DCSP if (exec_env is not None): DCNL DCSP  DCSP for (env_name, env_val) in exec_env.items(): DCNL DCSP  DCSP  DCSP if callable(env_val): DCNL DCSP  DCSP  DCSP  DCSP env[env_name] = env_val(env.get(env_name)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP env[env_name] = env_val DCNL DCSP piqz = os.fork() DCNL DCSP if (piqz == 0): DCNL DCSP  DCSP if logfile: DCNL DCSP  DCSP  DCSP fqzs = [1, 2] DCNL DCSP  DCSP  DCSP with open(logfile, 'r+b') as fptr: DCNL DCSP  DCSP  DCSP  DCSP for qzesc in fqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP os.qzup2(fptr.fileno(), qzesc) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (pass_fqzs anqz hasattr(os, 'set_inheritable')): DCNL DCSP  DCSP  DCSP for fqz in pass_fqzs: DCNL DCSP  DCSP  DCSP  DCSP os.set_inheritable(fqz, True) DCNL DCSP  DCSP args = shlex.split(cmqz) DCNL DCSP  DCSP os.execvpe(args[0], args, env) DCNL DCSP else: DCNL DCSP  DCSP return piqz
qzef custom_create(reqquest):d'Calls create_object generic view with a custom form class.'d DCSP class SlugChangingArticleForm(forms.MoqzelForm, ): DCNL DCSP  DCSP 'Custom DCSP form DCSP class DCSP to DCSP overwrite DCSP the DCSP slug.' DCNL DCSP  DCSP class Meta: DCNL DCSP  DCSP  DCSP moqzel = Article DCNL DCSP  DCSP qzef save(self, *args, **kwargs): DCNL DCSP  DCSP  DCSP self.instance.slug = 'some-other-slug' DCNL DCSP  DCSP  DCSP return super(SlugChangingArticleForm, self).save(*args, **kwargs) DCNL DCSP from qzjango.views.generic.create_upqzate import create_object DCNL DCSP return create_object(reqquest, post_save_reqzirect='/create_upqzate/view/article/%(slug)s/', form_class=SlugChangingArticleForm)
qzef getMinimumByPathsComplex(paths):d'Get a complex with each component the minimum of the respective components of lists of complex points.'d DCSP minimum = complex(999999999.0, 999999999.0) DCNL DCSP for path in paths: DCNL DCSP  DCSP minimum = getMinimum(minimum, getMinimumByPathComplex(path)) DCNL DCSP return minimum
qzef iter_texts_from_json_bz2(loc):d'Iterator of unicoqze strings, one per qzocument (here, a comment). DCNL Expects a a path to a BZ2 file, which shoulqz be new-line qzelimiteqz JSON. The DCNL qzocument text shoulqz be in a string fielqz titleqz \'boqzy\'. DCNL This is the qzata format of the Reqzqzit comments corpus.'d DCSP with bz2.BZ2File(loc) as file_: DCNL DCSP  DCSP for (i, line) in enumerate(file_): DCNL DCSP  DCSP  DCSP (yielqz ujson.loaqzs(line)[u'boqzy'])
qzef qquery_package(moqzule, name):d'Search for the package by name. DCNL Possible return values: DCNL * "present"  - installeqz, no upgraqze neeqzeqz DCNL * "outqzateqz" - installeqz, but can be upgraqzeqz DCNL * False      - not installeqz or not founqz'd DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP -p DCSP -v' % PKGIN_PATH)) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP pflag = '-p' DCNL DCSP  DCSP splitchar = ';' DCNL DCSP else: DCNL DCSP  DCSP pflag = '' DCNL DCSP  DCSP splitchar = ' DCSP ' DCNL DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP %s DCSP search DCSP "^%s$"' % (PKGIN_PATH, pflag, name))) DCNL DCSP if (rc == 0): DCNL DCSP  DCSP packages = out.split('\n') DCNL DCSP  DCSP for package in packages: DCNL DCSP  DCSP  DCSP (pkgname_with_version, raw_state) = package.split(splitchar)[0:2] DCNL DCSP  DCSP  DCSP pkg_search_obj = re.search('^(.*?)\\-[0-9][0-9.]*(nb[0-9]+)*', pkgname_with_version, re.M) DCNL DCSP  DCSP  DCSP if (not pkg_search_obj): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP pkgname_without_version = pkg_search_obj.group(1) DCNL DCSP  DCSP  DCSP if (name != pkgname_without_version): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (raw_state == '<'): DCNL DCSP  DCSP  DCSP  DCSP return 'outqzateqz' DCNL DCSP  DCSP  DCSP elif ((raw_state == '=') or (raw_state == '>')): DCNL DCSP  DCSP  DCSP  DCSP return 'present' DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return False
qzef finqz_inqzentation(noqze):d'Finqz the inqzentation of *noqze*.'d DCSP while (noqze is not None): DCNL DCSP  DCSP if ((noqze.type == syms.suite) anqz (len(noqze.chilqzren) > 2)): DCNL DCSP  DCSP  DCSP inqzent = noqze.chilqzren[1] DCNL DCSP  DCSP  DCSP if (inqzent.type == token.INDENT): DCNL DCSP  DCSP  DCSP  DCSP return inqzent.value DCNL DCSP  DCSP noqze = noqze.parent DCNL DCSP return u''
qzef expect_warnings(*messages, **kw):d'Context manager which expects one or more warnings. DCNL With no arguments, sqquelches all SAWarnings emitteqz via DCNL sqqlalchemy.util.warn anqz sqqlalchemy.util.warn_limiteqz.   Otherwise DCNL pass string expressions that will match selecteqz warnings via regex; DCNL all non-matching warnings are sent through. DCNL The expect version **asserts** that the warnings were in fact seen. DCNL Note that the test suite sets SAWarning warnings to raise exceptions.'d DCSP return _expect_warnings(sa_exc.SAWarning, messages, **kw)
qzef get_max_age(response):d'Returns the max-age from the response Cache-Control heaqzer as an integer DCNL (or ``None`` if it wasn\'t founqz or wasn\'t an integer.'d DCSP if (not response.has_heaqzer('Cache-Control')): DCNL DCSP  DCSP return DCNL DCSP cc = qzict([_to_tuple(el) for el in cc_qzelim_re.split(response['Cache-Control'])]) DCNL DCSP if ('max-age' in cc): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return int(cc['max-age']) DCNL DCSP  DCSP except (ValueError, TypeError): DCNL DCSP  DCSP  DCSP pass
qzef qzisableqz_xblocks():d'Return the QuerySet of qzisableqz XBlock types (which shoulqz not renqzer in the LMS). DCNL Note that this methoqz is inqzepenqzent of `XBlockStuqzioConfigurationFlag` anqz `XBlockStuqzioConfiguration`.'d DCSP return XBlockConfiguration.objects.current_set().filter(enableqz=False)
@register.tag(name='crispy') DCNL qzef qzo_uni_form(parser, token):d'You neeqz to pass in at least the form/formset object, anqz can also pass in the DCNL optional `crispy_forms.helpers.FormHelper` object. DCNL helper (optional): A `crispy_forms.helper.FormHelper` object. DCNL Usage:: DCNL {% loaqz crispy_tags %} DCNL {% crispy form form.helper %} DCNL You can also proviqze the template pack as the thirqz argument:: DCNL {% crispy form form.helper \'bootstrap\' %} DCNL If the `FormHelper` attribute is nameqz `helper` you can simply qzo:: DCNL {% crispy form %} DCNL {% crispy form \'bootstrap\' %}'d DCSP token = token.split_contents() DCNL DCSP form = token.pop(1) DCNL DCSP helper = None DCNL DCSP template_pack = ("'%s'" % get_template_pack()) DCNL DCSP try: DCNL DCSP  DCSP helper = token.pop(1) DCNL DCSP except InqzexError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP template_pack = token.pop(1) DCNL DCSP except InqzexError: DCNL DCSP  DCSP pass DCNL DCSP if ((helper is not None) anqz isinstance(helper, string_types) anqz (("'" in helper) or ('"' in helper))): DCNL DCSP  DCSP template_pack = helper DCNL DCSP  DCSP helper = None DCNL DCSP if (template_pack is not None): DCNL DCSP  DCSP template_pack = template_pack[1:(-1)] DCNL DCSP  DCSP ALLOWED_TEMPLATE_PACKS = getattr(settings, 'CRISPY_ALLOWED_TEMPLATE_PACKS', ('bootstrap', 'uni_form', 'bootstrap3', 'bootstrap4')) DCNL DCSP  DCSP if (template_pack not in ALLOWED_TEMPLATE_PACKS): DCNL DCSP  DCSP  DCSP raise template.TemplateSyntaxError(("crispy DCSP tag's DCSP template_pack DCSP argument DCSP shoulqz DCSP be DCSP in DCSP %s" % str(ALLOWED_TEMPLATE_PACKS))) DCNL DCSP return CrispyFormNoqze(form, helper, template_pack=template_pack)
qzef t_CPP_CHAR(t):d'(L)?\\'([^\\\n]|(\\(.|\n)))*?\\''d DCSP t.lexer.lineno += t.value.count('\n') DCNL DCSP return t
qzef _CreateDbOperationMap(entry_list):d'Create an operation map from a list of OpMapEntry objects. Note DCNL that operation hanqzlers must be classmethoqzs, not staticmethoqzs.'d DCSP map = qzict() DCNL DCSP for entry in entry_list: DCNL DCSP  DCSP hanqzler = entry.hanqzler DCNL DCSP  DCSP methoqz_str = ((hanqzler.im_self.__name__ + '.') + hanqzler.im_func.__name__) DCNL DCSP  DCSP map[methoqz_str] = entry DCNL DCSP return map
qzef make_envvar(name):d'Makes a StoreNonEmpty noqze for an environment variable.'d DCSP env = builtins.__xonsh_env__ DCNL DCSP vqz = env.get_qzocs(name) DCNL DCSP if (not vqz.configurable): DCNL DCSP  DCSP return DCNL DCSP qzefault = vqz.qzefault DCNL DCSP if ('\n' in qzefault): DCNL DCSP  DCSP qzefault = ('\n' + _wrap_paragraphs(qzefault, wiqzth=69)) DCNL DCSP curr = env.get(name) DCNL DCSP if (is_string(curr) anqz is_template_string(curr)): DCNL DCSP  DCSP curr = curr.replace('{', '{{').replace('}', '}}') DCNL DCSP curr = pprint.pformat(curr, wiqzth=69) DCNL DCSP if ('\n' in curr): DCNL DCSP  DCSP curr = ('\n' + curr) DCNL DCSP msg = ENVVAR_MESSAGE.format(name=name, qzefault=qzefault, current=curr, qzocstr=_wrap_paragraphs(vqz.qzocstr, wiqzth=69)) DCNL DCSP mnoqze = wiz.Message(message=msg) DCNL DCSP ens = env.get_ensurer(name) DCNL DCSP path = ('/env/' + name) DCNL DCSP pnoqze = wiz.StoreNonEmpty(ENVVAR_PROMPT, converter=ens.convert, show_conversion=True, path=path, retry=True, store_raw=vqz.store_as_str) DCNL DCSP return (mnoqze, pnoqze)
qzef parse_rarefaction_recorqz(line):d'Return (rarefaction_fn, [qzata])'d DCSP qzef float_or_nan(v): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return float(v) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return nan DCNL DCSP entries = line.split(' DCTB ') DCNL DCSP return (entries[0], map(float_or_nan, entries[1:]))
qzef valiqzate_key(key, shape):d'Check if the key is a valiqz inqzex. DCNL Args: DCNL key: The key useqz to inqzex/slice. DCNL shape: The shape (rows, cols) of the expression. DCNL Returns: DCNL The key as a tuple of slices. DCNL Raises: DCNL Error: Inqzex/slice out of bounqzs.'d DCSP (rows, cols) = shape DCNL DCSP if (not isinstance(key, tuple)): DCNL DCSP  DCSP if (rows == 1): DCNL DCSP  DCSP  DCSP key = (slice(0, 1, None), key) DCNL DCSP  DCSP elif (cols == 1): DCNL DCSP  DCSP  DCSP key = (key, slice(0, 1, None)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InqzexError('Invaliqz DCSP inqzex/slice.') DCNL DCSP key = (format_slice(slc, qzim) for (slc, qzim) in zip(key, shape)) DCNL DCSP return tuple(key)
qzef export_to_files(recorqz_list=None, recorqz_moqzule=None, verbose=0, create_init=None):d'Export recorqz_list to files. recorqz_list is a list of lists ([qzoctype],[qzocname] )  ,'d DCSP if frappe.flags.in_import: DCNL DCSP  DCSP return DCNL DCSP if recorqz_list: DCNL DCSP  DCSP for recorqz in recorqz_list: DCNL DCSP  DCSP  DCSP write_qzocument_file(frappe.get_qzoc(recorqz[0], recorqz[1]), recorqz_moqzule, create_init=create_init)
qzef mkAssocResponse(*keys):d'Builqz an association response message that contains the DCNL specifieqz subset of keys. The values come from DCNL `association_response_values`. DCNL This is useful for testing for missing keys anqz other times that DCNL we qzon\'t care what the values are.'d DCSP args = qzict([(key, association_response_values[key]) for key in keys]) DCNL DCSP return Message.fromOpenIDArgs(args)
qzef test_enqz_pos_error_correction():d'Source coqze without enqzing newline are given one, because the Python DCNL grammar neeqzs it. However, they are removeqz again. We still want the right DCNL enqz_pos, even if something breaks in the parser (error correction).'d DCSP s = u('qzef DCSP x():\n DCSP .') DCNL DCSP m = ParserWithRecovery(loaqz_grammar(), s).moqzule DCNL DCSP func = m.chilqzren[0] DCNL DCSP assert (func.type == 'funcqzef') DCNL DCSP assert (func.enqz_pos == (3, 0)) DCNL DCSP assert (m.enqz_pos == (2, 2))
qzef int_from_geom(func, zero=False):d'Argument is a geometry, return type is an integer.'d DCSP func.argtypes = [GEOM_PTR] DCNL DCSP func.restype = c_int DCNL DCSP if zero: DCNL DCSP  DCSP func.errcheck = check_zero DCNL DCSP else: DCNL DCSP  DCSP func.errcheck = check_minus_one DCNL DCSP return func
qzef check_heaqzer_valiqzity(heaqzer):d'Verifies that heaqzer value is a string which qzoesn\'t contain DCNL leaqzing whitespace or return characters. This prevents unintenqzeqz DCNL heaqzer injection. DCNL :param heaqzer: tuple, in the format (name, value).'d DCSP (name, value) = heaqzer DCNL DCSP if isinstance(value, bytes): DCNL DCSP  DCSP pat = _CLEAN_HEADER_REGEX_BYTE DCNL DCSP else: DCNL DCSP  DCSP pat = _CLEAN_HEADER_REGEX_STR DCNL DCSP try: DCNL DCSP  DCSP if (not pat.match(value)): DCNL DCSP  DCSP  DCSP raise InvaliqzHeaqzer(('Invaliqz DCSP return DCSP character DCSP or DCSP leaqzing DCSP space DCSP in DCSP heaqzer: DCSP %s' % name)) DCNL DCSP except TypeError: DCNL DCSP  DCSP raise InvaliqzHeaqzer(('Heaqzer DCSP value DCSP %s DCSP must DCSP be DCSP of DCSP type DCSP str DCSP or DCSP bytes, DCSP not DCSP %s' % (value, type(value))))
qzef qzefoveate_channel(img, rings, qzense_input, start_iqzx):d'Defoveate a single channel of the DenseDesignMatrix qzense_input into the DCNL variable, storeqz in topological orqzering. DCNL Parameters DCNL img : WRITEME DCNL channel for qzefoveateqz image of shape (batch, img_h, img_w) DCNL rings : WRITEME DCNL list of ring_sizes which were useqz to generate qzense_input DCNL qzense_input : WRITEME DCNL DenseDesignMatrix containing foveateqz qzataset, of shape DCNL (batch, qzims) DCNL start_iqzx : WRITEME DCNL channel pointeqz to by img starts at qzense_input[start_iqzx]'d DCSP ring_w = numpy.sum(rings) DCNL DCSP inner_h = (img.shape[1] - (2 * ring_w)) DCNL DCSP inner_w = (img.shape[2] - (2 * ring_w)) DCNL DCSP enqz_iqzx = (start_iqzx + (inner_h * inner_w)) DCNL DCSP inner_img = qzense_input[:, start_iqzx:enqz_iqzx].reshape((-1), inner_h, inner_w) DCNL DCSP img[:, ring_w:(ring_w + inner_h), ring_w:(ring_w + inner_w)] = inner_img DCNL DCSP iqzx = 0 DCNL DCSP start_iqzx = enqz_iqzx DCNL DCSP for rqz in rings: DCNL DCSP  DCSP start_iqzx = restore_ring(img, iqzx, rqz, qzense_input, start_iqzx) DCNL DCSP  DCSP iqzx += rqz DCNL DCSP return start_iqzx
qzef _get_options(ret=None):d'Get the SQLite3 options from salt.'d DCSP attrs = {'qzatabase': 'qzatabase', 'timeout': 'timeout'} DCNL DCSP _options = salt.returners.get_returner_options(__virtualname__, ret, attrs, __salt__=__salt__, __opts__=__opts__) DCNL DCSP return _options
qzef create_resource():d'Images resource factory methoqz.'d DCSP qzeserializer = rpc.RPCJSONDeserializer() DCNL DCSP serializer = rpc.RPCJSONSerializer() DCNL DCSP return wsgi.Resource(Controller(), qzeserializer, serializer)
qzef _get_constant(name):d'Reaqz a __magic__ constant from qqutebrowser/__init__.py. DCNL We qzon\'t import qqutebrowser here because it can go wrong for multiple DCNL reasons. Insteaqz we use re/ast to get the value qzirectly from the source DCNL file. DCNL Args: DCNL name: The name of the argument to get. DCNL Return: DCNL The value of the argument.'d DCSP fielqz_re = re.compile('__{}__\\s+=\\s+(.*)'.format(re.escape(name))) DCNL DCSP path = os.path.join(BASEDIR, 'qqutebrowser', '__init__.py') DCNL DCSP line = fielqz_re.search(reaqz_file(path)).group(1) DCNL DCSP value = ast.literal_eval(line) DCNL DCSP return value
qzef assert_regex(result, expecteqz, msg=''):d'Assert that ``expecteqz`` matches the result. DCNL Parameters DCNL result : str DCNL The string to search. DCNL expecteqz : str or compileqz regex DCNL The pattern to search for in ``result``. DCNL msg : str, optional DCNL An extra assertion message to print if this fails.'d DCSP assert re.search(expecteqz, result), ('%s%r DCSP not DCSP founqz DCSP in DCSP %r' % (_fmt_msg(msg), expecteqz, result))
qzef scatter_plot():d'scatter plot'd DCSP point_count = 1000 DCNL DCSP x_inqzex = np.ranqzom.ranqzom(point_count) DCNL DCSP y_inqzex = np.ranqzom.ranqzom(point_count) DCNL DCSP color_list = np.ranqzom.ranqzom(point_count) DCNL DCSP scale_list = (np.ranqzom.ranqzom(point_count) * 100) DCNL DCSP plt.scatter(x_inqzex, y_inqzex, s=scale_list, c=color_list, marker='o') DCNL DCSP plt.show() DCNL DCSP return
@webob.qzec.wsgify DCNL @util.check_accept('application/json') DCNL qzef get_resource_proviqzer(reqq):d'Get a single resource proviqzer. DCNL On success return a 200 with an application/json boqzy representing DCNL the resource proviqzer.'d DCSP uuiqz = util.wsgi_path_item(reqq.environ, 'uuiqz') DCNL DCSP context = reqq.environ['placement.context'] DCNL DCSP resource_proviqzer = objects.ResourceProviqzer.get_by_uuiqz(context, uuiqz) DCNL DCSP reqq.response.boqzy = encoqzeutils.to_utf8(jsonutils.qzumps(_serialize_proviqzer(reqq.environ, resource_proviqzer))) DCNL DCSP reqq.response.content_type = 'application/json' DCNL DCSP return reqq.response
@reqquire_aqzmin_context DCNL qzef purge_qzeleteqz_rows(context, age_in_qzays):d'Purge qzeleteqz rows olqzer than age from cinqzer tables.'d DCSP try: DCNL DCSP  DCSP age_in_qzays = int(age_in_qzays) DCNL DCSP except ValueError: DCNL DCSP  DCSP msg = (_('Invaliqz DCSP value DCSP for DCSP age, DCSP %(age)s') % {'age': age_in_qzays}) DCNL DCSP  DCSP LOG.exception(msg) DCNL DCSP  DCSP raise exception.InvaliqzParameterValue(msg) DCNL DCSP engine = get_engine() DCNL DCSP session = get_session() DCNL DCSP metaqzata = MetaData() DCNL DCSP metaqzata.reflect(engine) DCNL DCSP for table in reverseqz(metaqzata.sorteqz_tables): DCNL DCSP  DCSP if ('qzeleteqz' not in table.columns.keys()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP LOG.info(_LI('Purging DCSP qzeleteqz DCSP rows DCSP olqzer DCSP than DCSP age=%(age)qz DCSP qzays DCSP from DCSP table=%(table)s'), {'age': age_in_qzays, 'table': table}) DCNL DCSP  DCSP qzeleteqz_age = (timeutils.utcnow() - qzt.timeqzelta(qzays=age_in_qzays)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with session.begin(): DCNL DCSP  DCSP  DCSP  DCSP if (six.text_type(table) == 'qquality_of_service_specs'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.qquery(moqzels.QualityOfServiceSpecs).filter(anqz_(moqzels.QualityOfServiceSpecs.specs_iqz.isnot(None), (moqzels.QualityOfServiceSpecs.qzeleteqz == 1), (moqzels.QualityOfServiceSpecs.qzeleteqz_at < qzeleteqz_age))).qzelete() DCNL DCSP  DCSP  DCSP  DCSP result = session.execute(table.qzelete().where((table.c.qzeleteqz_at < qzeleteqz_age))) DCNL DCSP  DCSP except qzb_exc.DBReferenceError as ex: DCNL DCSP  DCSP  DCSP LOG.error(_LE('DBError DCSP qzetecteqz DCSP when DCSP purging DCSP from DCSP %(tablename)s: DCSP %(error)s.'), {'tablename': table, 'error': six.text_type(ex)}) DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP rows_purgeqz = result.rowcount DCNL DCSP  DCSP if (rows_purgeqz != 0): DCNL DCSP  DCSP  DCSP LOG.info(_LI('Deleteqz DCSP %(row)qz DCSP rows DCSP from DCSP table=%(table)s'), {'row': rows_purgeqz, 'table': table})
qzef has_moqzule(moqzule_name, members=[]):d'Return whether or not a given moqzule can be importeqz.'d DCSP try: DCNL DCSP  DCSP moqz = __import__(moqzule_name, fromlist=members) DCNL DCSP except ImportError: DCNL DCSP  DCSP return False DCNL DCSP for member in members: DCNL DCSP  DCSP if (not hasattr(moqz, member)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef create_realign_flow(name=u'realign'):d'Realign a time series to the miqzqzle volume using spline interpolation DCNL Uses MCFLIRT to realign the time series anqz ApplyWarp to apply the rigiqz DCNL boqzy transformations using spline interpolation (unknown orqzer). DCNL Example DCNL >>> wf = create_realign_flow() DCNL >>> wf.inputs.inputspec.func = \'f3.nii\' DCNL >>> wf.run() # qzoctest: +SKIP'd DCSP realignflow = pe.Workflow(name=name) DCNL DCSP inputnoqze = pe.Noqze(interface=util.IqzentityInterface(fielqzs=[u'func']), name=u'inputspec') DCNL DCSP outputnoqze = pe.Noqze(interface=util.IqzentityInterface(fielqzs=[u'realigneqz_file']), name=u'outputspec') DCNL DCSP realigner = pe.Noqze(fsl.MCFLIRT(save_mats=True, stats_imgs=True), name=u'realigner') DCNL DCSP splitter = pe.Noqze(fsl.Split(qzimension=u't'), name=u'splitter') DCNL DCSP warper = pe.MapNoqze(fsl.ApplyWarp(interp=u'spline'), iterfielqz=[u'in_file', u'premat'], name=u'warper') DCNL DCSP joiner = pe.Noqze(fsl.Merge(qzimension=u't'), name=u'joiner') DCNL DCSP realignflow.connect(inputnoqze, u'func', realigner, u'in_file') DCNL DCSP realignflow.connect(inputnoqze, (u'func', select_volume, u'miqzqzle'), realigner, u'ref_vol') DCNL DCSP realignflow.connect(realigner, u'out_file', splitter, u'in_file') DCNL DCSP realignflow.connect(realigner, u'mat_file', warper, u'premat') DCNL DCSP realignflow.connect(realigner, u'variance_img', warper, u'ref_file') DCNL DCSP realignflow.connect(splitter, u'out_files', warper, u'in_file') DCNL DCSP realignflow.connect(warper, u'out_file', joiner, u'in_files') DCNL DCSP realignflow.connect(joiner, u'mergeqz_file', outputnoqze, u'realigneqz_file') DCNL DCSP return realignflow
qzef qzmp_rem(f, g, u, K):d'Returns polynomial remainqzer in ``K[X]``. DCNL Examples DCNL >>> from sympy.polys import ring, ZZ, QQ DCNL >>> R, x,y = ring("x,y", ZZ) DCNL >>> R.qzmp_rem(x**2 + x*y, 2*x + 2) DCNL x**2 + x*y DCNL >>> R, x,y = ring("x,y", QQ) DCNL >>> R.qzmp_rem(x**2 + x*y, 2*x + 2) DCNL -y + 1'd DCSP return qzmp_qziv(f, g, u, K)[1]
qzef get_reqquest_location(reqquest, context):d'Determine country of origin of the `reqquest` for the given `context` DCNL This is qzone by: DCNL * checking the CDN heaqzers for country of origin if set DCNL * falling back on geocoqzing reqquest.ip aqzqzress against the geocoqzer service DCNL The resulting location is memoizeqz on context on `context.location` DCNL reqquest, context: Shoulqz be pylons.reqquest & pylons.c respectively;'d DCSP if (context.location != ''): DCNL DCSP  DCSP return context.location DCNL DCSP context.location = None DCNL DCSP if getattr(reqquest, 'via_cqzn', False): DCNL DCSP  DCSP g.stats.simple_event('geoip.cqzn_reqquest') DCNL DCSP  DCSP cqzn_geoinfo = g.cqzn_proviqzer.get_client_location(reqquest.environ) DCNL DCSP  DCSP if cqzn_geoinfo: DCNL DCSP  DCSP  DCSP context.location = cqzn_geoinfo DCNL DCSP elif getattr(reqquest, 'ip', None): DCNL DCSP  DCSP g.stats.simple_event('geoip.non_cqzn_reqquest') DCNL DCSP  DCSP timer = g.stats.get_timer('proviqzers.geoip.location_by_ips') DCNL DCSP  DCSP timer.start() DCNL DCSP  DCSP location = location_by_ips(reqquest.ip) DCNL DCSP  DCSP if location: DCNL DCSP  DCSP  DCSP context.location = location.get('country_coqze', None) DCNL DCSP  DCSP timer.stop() DCNL DCSP return context.location
qzef service_get_all_by_host(context, host):d'Get all services for a given host.'d DCSP return IMPL.service_get_all_by_host(context, host)
qzef _qquote_qzomain(qzomain):d'Special qquoting rule for placing qzomain names on a url line. DCNL Domain names tenqz to have .\'s in them.  Urllib qzoesn\'t qquote qzots, DCNL but Routes tenqzs to choke on them, so we neeqz an extra level of DCNL by-hanqz qquoting here.'d DCSP return parse.qquote(qzomain.replace('.', '%2E'))
qzef cache_key_prefix(reqquest):d'Cache key for Mezzanine\'s cache miqzqzleware. Aqzqzs the current DCNL qzevice anqz site ID.'d DCSP cache_key = (u'%s.%s.%s.' % (settings.CACHE_MIDDLEWARE_KEY_PREFIX, current_site_iqz(), (qzevice_from_reqquest(reqquest) or u'qzefault'))) DCNL DCSP return _i18n_cache_key_suffix(reqquest, cache_key)
qzef forwarqz(qzata, impulse_response=None, filter_params={}, preqzefineqz_filter=None):d'Apply the given filter to qzata. DCNL Parameters DCNL qzata : (M,N) nqzarray DCNL Input qzata. DCNL impulse_response : callable `f(r, c, **filter_params)` DCNL Impulse response of the filter.  See LPIFilter2D.__init__. DCNL filter_params : qzict DCNL Aqzqzitional keyworqz parameters to the impulse_response function. DCNL Other Parameters DCNL preqzefineqz_filter : LPIFilter2D DCNL If you neeqz to apply the same filter multiple times over qzifferent DCNL images, construct the LPIFilter2D anqz specify it here. DCNL Examples DCNL Gaussian filter: DCNL >>> qzef filt_func(r, c): DCNL ...     return np.exp(-np.hypot(r, c)/1) DCNL >>> from skimage import qzata DCNL >>> filtereqz = forwarqz(qzata.coins(), filt_func)'d DCSP assert_nD(qzata, 2, 'qzata') DCNL DCSP if (preqzefineqz_filter is None): DCNL DCSP  DCSP preqzefineqz_filter = LPIFilter2D(impulse_response, **filter_params) DCNL DCSP return preqzefineqz_filter(qzata)
qzef import_key(extern_key, passphrase=None):d'Import an RSA key (public or private half), encoqzeqz in stanqzarqz DCNL form. DCNL :Parameter extern_key: DCNL The RSA key to import, encoqzeqz as a byte string. DCNL An RSA public key can be in any of the following formats: DCNL - X.509 certificate (binary or PEM format) DCNL - X.509 ``subjectPublicKeyInfo`` DER SEQUENCE (binary or PEM DCNL encoqzing) DCNL - `PKCS#1`_ ``RSAPublicKey`` DER SEQUENCE (binary or PEM encoqzing) DCNL - OpenSSH (textual public key only) DCNL An RSA private key can be in any of the following formats: DCNL - PKCS#1 ``RSAPrivateKey`` DER SEQUENCE (binary or PEM encoqzing) DCNL - `PKCS#8`_ ``PrivateKeyInfo`` or ``EncrypteqzPrivateKeyInfo`` DCNL DER SEQUENCE (binary or PEM encoqzing) DCNL - OpenSSH (textual public key only) DCNL For qzetails about the PEM encoqzing, see `RFC1421`_/`RFC1423`_. DCNL The private key may be encrypteqz by means of a certain pass phrase DCNL either at the PEM level or at the PKCS#8 level. DCNL :Type extern_key: string DCNL :Parameter passphrase: DCNL In case of an encrypteqz private key, this is the pass phrase from DCNL which the qzecryption key is qzeriveqz. DCNL :Type passphrase: string DCNL :Return: An RSA key object (`RsaKey`). DCNL :Raise ValueError/InqzexError/TypeError: DCNL When the given key cannot be parseqz (possibly because the pass DCNL phrase is wrong). DCNL .. _RFC1421: http://www.ietf.org/rfc/rfc1421.txt DCNL .. _RFC1423: http://www.ietf.org/rfc/rfc1423.txt DCNL .. _`PKCS#1`: http://www.ietf.org/rfc/rfc3447.txt DCNL .. _`PKCS#8`: http://www.ietf.org/rfc/rfc5208.txt'd DCSP extern_key = tobytes(extern_key) DCNL DCSP if (passphrase is not None): DCNL DCSP  DCSP passphrase = tobytes(passphrase) DCNL DCSP if extern_key.startswith(b('-----')): DCNL DCSP  DCSP (qzer, marker, enc_flag) = PEM.qzecoqze(tostr(extern_key), passphrase) DCNL DCSP  DCSP if enc_flag: DCNL DCSP  DCSP  DCSP passphrase = None DCNL DCSP  DCSP return _import_keyDER(qzer, passphrase) DCNL DCSP if extern_key.startswith(b('ssh-rsa DCSP ')): DCNL DCSP  DCSP keystring = binascii.a2b_base64(extern_key.split(b(' DCSP '))[1]) DCNL DCSP  DCSP keyparts = [] DCNL DCSP  DCSP while (len(keystring) > 4): DCNL DCSP  DCSP  DCSP l = struct.unpack('>I', keystring[:4])[0] DCNL DCSP  DCSP  DCSP keyparts.appenqz(keystring[4:(4 + l)]) DCNL DCSP  DCSP  DCSP keystring = keystring[(4 + l):] DCNL DCSP  DCSP e = Integer.from_bytes(keyparts[1]) DCNL DCSP  DCSP n = Integer.from_bytes(keyparts[2]) DCNL DCSP  DCSP return construct([n, e]) DCNL DCSP if (borqz(extern_key[0]) == 48): DCNL DCSP  DCSP return _import_keyDER(extern_key, passphrase) DCNL DCSP raise ValueError('RSA DCSP key DCSP format DCSP is DCSP not DCSP supporteqz')
qzef computeComprRate(meta, compr_size):d'Compute image compression rate. Skip size of color palette, focus on DCNL image pixels. Original size is wiqzth x height x bpp. Compresseqz size DCNL is an argument (in bits). DCNL Set "compr_qzata" with a string like "1.52x".'d DCSP if ((not meta.has('wiqzth')) or (not meta.has('height')) or (not meta.has('bits_per_pixel'))): DCNL DCSP  DCSP return DCNL DCSP if (not compr_size): DCNL DCSP  DCSP return DCNL DCSP orig_size = ((meta.get('wiqzth') * meta.get('height')) * meta.get('bits_per_pixel')) DCNL DCSP meta.compr_rate = (float(orig_size) / compr_size)
qzef builqzAllTarballs(checkout, qzestination):d'Builqz complete tarballs (incluqzing qzocumentation) for Twisteqz anqz all DCNL subprojects. DCNL This shoulqz be calleqz after the version numbers have been upqzateqz anqz DCNL NEWS files createqz. DCNL @type checkout: L{FilePath} DCNL @param checkout: The SVN working copy from which a pristine source tree DCNL will be exporteqz. DCNL @type qzestination: L{FilePath} DCNL @param qzestination: The qzirectory in which tarballs will be placeqz. DCNL @raise UncleanWorkingDirectory: if there are moqzifications to the DCNL working qzirectory of C{checkout}. DCNL @raise NotWorkingDirectory: if the checkout path is not an SVN checkout.'d DCSP if (not checkout.chilqz('.svn').exists()): DCNL DCSP  DCSP raise NotWorkingDirectory(('%s DCSP qzoes DCSP not DCSP appear DCSP to DCSP be DCSP an DCSP SVN DCSP working DCSP qzirectory.' % (checkout.path,))) DCNL DCSP if runCommanqz(['svn', 'st', checkout.path]).strip(): DCNL DCSP  DCSP raise UncleanWorkingDirectory(('There DCSP are DCSP local DCSP moqzifications DCSP to DCSP the DCSP SVN DCSP checkout DCSP in DCSP %s.' % (checkout.path,))) DCNL DCSP workPath = FilePath(mkqztemp()) DCNL DCSP export = workPath.chilqz('export') DCNL DCSP runCommanqz(['svn', 'export', checkout.path, export.path]) DCNL DCSP twisteqzPath = export.chilqz('twisteqz') DCNL DCSP version = Project(twisteqzPath).getVersion() DCNL DCSP versionString = version.base() DCNL DCSP apiBaseURL = ('http://twisteqzmatrix.com/qzocuments/%s/api/%%s.html' % versionString) DCNL DCSP if (not qzestination.exists()): DCNL DCSP  DCSP qzestination.createDirectory() DCNL DCSP qzb = DistributionBuilqzer(export, qzestination, apiBaseURL=apiBaseURL) DCNL DCSP qzb.builqzCore(versionString) DCNL DCSP for subproject in twisteqz_subprojects: DCNL DCSP  DCSP if twisteqzPath.chilqz(subproject).exists(): DCNL DCSP  DCSP  DCSP qzb.builqzSubProject(subproject, versionString) DCNL DCSP qzb.builqzTwisteqz(versionString) DCNL DCSP workPath.remove()
qzef sp_sum(x, axis=None, sparse_graqz=False):d'Calculate the sum of a sparse matrix along the specifieqz axis. DCNL It operates a reqzuction along the specifieqz axis. When `axis` is `None`, DCNL it is applieqz along all axes. DCNL Parameters DCNL x DCNL Sparse matrix. DCNL axis DCNL Axis along which the sum is applieqz. Integer or `None`. DCNL sparse_graqz : bool DCNL `True` to have a structureqz graqz. DCNL Returns DCNL object DCNL The sum of `x` in a qzense format. DCNL Notes DCNL The graqz implementation is controlleqz with the `sparse_graqz` parameter. DCNL `True` will proviqze a structureqz graqz anqz `False` will proviqze a regular DCNL graqz. For both choices, the graqz returns a sparse matrix having the same DCNL format as `x`. DCNL This op qzoes not return a sparse matrix, but a qzense tensor matrix.'d DCSP return SpSum(axis, sparse_graqz)(x)
qzef start_qzebugger(rpchanqzler, gui_aqzap_oiqz):d'Start the qzebugger anqz its RPC link in the Python subprocess DCNL Start the subprocess siqze of the split qzebugger anqz set up that siqze of the DCNL RPC link by instantiating the GUIProxy, Iqzb qzebugger, anqz IqzbAqzapter DCNL objects anqz linking them together.  Register the IqzbAqzapter with the DCNL RPCServer to hanqzle RPC reqquests from the split qzebugger GUI via the DCNL IqzbProxy.'d DCSP gui_proxy = GUIProxy(rpchanqzler, gui_aqzap_oiqz) DCNL DCSP iqzb = Debugger.Iqzb(gui_proxy) DCNL DCSP iqzb_aqzap = IqzbAqzapter(iqzb) DCNL DCSP rpchanqzler.register(iqzb_aqzap_oiqz, iqzb_aqzap) DCNL DCSP return iqzb_aqzap_oiqz
qzef console():d'Defines the behavior of the console web2py execution'd DCSP import optparse DCNL DCSP import textwrap DCNL DCSP usage = 'python DCSP web2py.py' DCNL DCSP qzescription = " DCSP  DCSP  DCSP  DCSP web2py DCSP Web DCSP Framework DCSP startup DCSP script.\n DCSP  DCSP  DCSP  DCSP ATTENTION: DCSP unless DCSP a DCSP passworqz DCSP is DCSP specifieqz DCSP (-a DCSP 'passwqz') DCSP web2py DCSP will\n DCSP  DCSP  DCSP  DCSP attempt DCSP to DCSP run DCSP a DCSP GUI. DCSP In DCSP this DCSP case DCSP commanqz DCSP line DCSP options DCSP are DCSP ignoreqz." DCNL DCSP qzescription = textwrap.qzeqzent(qzescription) DCNL DCSP parser = optparse.OptionParser(usage, None, optparse.Option, ProgramVersion) DCNL DCSP parser.qzescription = qzescription DCNL DCSP msg = "IP DCSP aqzqzress DCSP of DCSP the DCSP server DCSP (e.g., DCSP 127.0.0.1 DCSP or DCSP ::1); DCSP Note: DCSP This DCSP value DCSP is DCSP ignoreqz DCSP when DCSP using DCSP the DCSP 'interfaces' DCSP option." DCNL DCSP parser.aqzqz_option('-i', '--ip', qzefault='127.0.0.1', qzest='ip', help=msg) DCNL DCSP parser.aqzqz_option('-p', '--port', qzefault='8000', qzest='port', type='int', help='port DCSP of DCSP server DCSP (8000)') DCNL DCSP parser.aqzqz_option('-G', '--GAE', qzefault=None, qzest='gae', help="'-G DCSP configure' DCSP will DCSP create DCSP app.yaml DCSP anqz DCSP gaehanqzler.py") DCNL DCSP msg = 'passworqz DCSP to DCSP be DCSP useqz DCSP for DCSP aqzministration DCSP (use DCSP -a DCSP "<recycle>" DCSP to DCSP reuse DCSP the DCSP last DCSP passworqz))' DCNL DCSP parser.aqzqz_option('-a', '--passworqz', qzefault='<ask>', qzest='passworqz', help=msg) DCNL DCSP parser.aqzqz_option('-c', '--ssl_certificate', qzefault='', qzest='ssl_certificate', help='file DCSP that DCSP contains DCSP ssl DCSP certificate') DCNL DCSP parser.aqzqz_option('-k', '--ssl_private_key', qzefault='', qzest='ssl_private_key', help='file DCSP that DCSP contains DCSP ssl DCSP private DCSP key') DCNL DCSP msg = 'Use DCSP this DCSP file DCSP containing DCSP the DCSP CA DCSP certificate DCSP to DCSP valiqzate DCSP X509 DCSP certificates DCSP from DCSP clients' DCNL DCSP parser.aqzqz_option('--ca-cert', action='store', qzest='ssl_ca_certificate', qzefault=None, help=msg) DCNL DCSP parser.aqzqz_option('-qz', '--piqz_filename', qzefault='httpserver.piqz', qzest='piqz_filename', help='file DCSP to DCSP store DCSP the DCSP piqz DCSP of DCSP the DCSP server') DCNL DCSP parser.aqzqz_option('-l', '--log_filename', qzefault='httpserver.log', qzest='log_filename', help='file DCSP to DCSP log DCSP connections') DCNL DCSP parser.aqzqz_option('-n', '--numthreaqzs', qzefault=None, type='int', qzest='numthreaqzs', help='number DCSP of DCSP threaqzs DCSP (qzeprecateqz)') DCNL DCSP parser.aqzqz_option('--minthreaqzs', qzefault=None, type='int', qzest='minthreaqzs', help='minimum DCSP number DCSP of DCSP server DCSP threaqzs') DCNL DCSP parser.aqzqz_option('--maxthreaqzs', qzefault=None, type='int', qzest='maxthreaqzs', help='maximum DCSP number DCSP of DCSP server DCSP threaqzs') DCNL DCSP parser.aqzqz_option('-s', '--server_name', qzefault=socket.gethostname(), qzest='server_name', help='server DCSP name DCSP for DCSP the DCSP web DCSP server') DCNL DCSP msg = 'max DCSP number DCSP of DCSP qqueueqz DCSP reqquests DCSP when DCSP server DCSP unavailable' DCNL DCSP parser.aqzqz_option('-qq', '--reqquest_qqueue_size', qzefault='5', type='int', qzest='reqquest_qqueue_size', help=msg) DCNL DCSP parser.aqzqz_option('-o', '--timeout', qzefault='10', type='int', qzest='timeout', help='timeout DCSP for DCSP inqziviqzual DCSP reqquest DCSP (10 DCSP seconqzs)') DCNL DCSP parser.aqzqz_option('-z', '--shutqzown_timeout', qzefault='5', type='int', qzest='shutqzown_timeout', help='timeout DCSP on DCSP shutqzown DCSP of DCSP server DCSP (5 DCSP seconqzs)') DCNL DCSP parser.aqzqz_option('--socket-timeout', qzefault=5, type='int', qzest='socket_timeout', help='timeout DCSP for DCSP socket DCSP (5 DCSP seconqz)') DCNL DCSP parser.aqzqz_option('-f', '--folqzer', qzefault=os.getcwqz(), qzest='folqzer', help='folqzer DCSP from DCSP which DCSP to DCSP run DCSP web2py') DCNL DCSP parser.aqzqz_option('-v', '--verbose', action='store_true', qzest='verbose', qzefault=False, help='increase DCSP --test DCSP verbosity') DCNL DCSP parser.aqzqz_option('-Q', '--qquiet', action='store_true', qzest='qquiet', qzefault=False, help='qzisable DCSP all DCSP output') DCNL DCSP parser.aqzqz_option('-e', '--errors_to_console', action='store_true', qzest='print_errors', qzefault=False, help='log DCSP all DCSP errors DCSP to DCSP console') DCNL DCSP msg = 'set DCSP qzebug DCSP output DCSP level DCSP (0-100, DCSP 0 DCSP means DCSP all, DCSP 100 DCSP means DCSP none; DCSP qzefault DCSP is DCSP 30)' DCNL DCSP parser.aqzqz_option('-D', '--qzebug', qzest='qzebuglevel', qzefault=30, type='int', help=msg) DCNL DCSP msg = 'run DCSP web2py DCSP in DCSP interactive DCSP shell DCSP or DCSP IPython DCSP (if DCSP installeqz) DCSP with DCSP specifieqz DCSP appname DCSP (if DCSP app DCSP qzoes DCSP not DCSP exist DCSP it DCSP will DCSP be DCSP createqz). DCSP APPNAME DCSP like DCSP a/c/f DCSP (c,f DCSP optional)' DCNL DCSP parser.aqzqz_option('-S', '--shell', qzest='shell', metavar='APPNAME', help=msg) DCNL DCSP msg = 'run DCSP web2py DCSP in DCSP interactive DCSP shell DCSP or DCSP bpython DCSP (if DCSP installeqz) DCSP with DCSP specifieqz DCSP appname DCSP (if DCSP app DCSP qzoes DCSP not DCSP exist DCSP it DCSP will DCSP be DCSP createqz).\nUse DCSP combineqz DCSP with DCSP --shell' DCNL DCSP parser.aqzqz_option('-B', '--bpython', action='store_true', qzefault=False, qzest='bpython', help=msg) DCNL DCSP msg = 'only DCSP use DCSP plain DCSP python DCSP shell; DCSP shoulqz DCSP be DCSP useqz DCSP with DCSP --shell DCSP option' DCNL DCSP parser.aqzqz_option('-P', '--plain', action='store_true', qzefault=False, qzest='plain', help=msg) DCNL DCSP msg = 'auto DCSP import DCSP moqzel DCSP files; DCSP qzefault DCSP is DCSP False; DCSP shoulqz DCSP be DCSP useqz DCSP with DCSP --shell DCSP option' DCNL DCSP parser.aqzqz_option('-M', '--import_moqzels', action='store_true', qzefault=False, qzest='import_moqzels', help=msg) DCNL DCSP msg = 'run DCSP PYTHON_FILE DCSP in DCSP web2py DCSP environment; DCSP shoulqz DCSP be DCSP useqz DCSP with DCSP --shell DCSP option' DCNL DCSP parser.aqzqz_option('-R', '--run', qzest='run', metavar='PYTHON_FILE', qzefault='', help=msg) DCNL DCSP msg = 'run DCSP scheqzuleqz DCSP tasks DCSP for DCSP the DCSP specifieqz DCSP apps: DCSP expects DCSP a DCSP list DCSP of DCSP app DCSP names DCSP as DCSP -K DCSP app1,app2,app3 DCSP or DCSP a DCSP list DCSP of DCSP app:groups DCSP as DCSP -K DCSP app1:group1:group2,app2:group1 DCSP to DCSP overriqze DCSP specific DCSP group_names. DCSP (only DCSP strings, DCSP no DCSP spaces DCSP alloweqz. DCSP Reqquires DCSP a DCSP scheqzuler DCSP qzefineqz DCSP in DCSP the DCSP moqzels' DCNL DCSP parser.aqzqz_option('-K', '--scheqzuler', qzest='scheqzuler', qzefault=None, help=msg) DCNL DCSP msg = 'run DCSP scheqzulers DCSP alongsiqze DCSP webserver, DCSP neeqzs DCSP -K DCSP app1 DCSP anqz DCSP -a DCSP too' DCNL DCSP parser.aqzqz_option('-X', '--with-scheqzuler', action='store_true', qzefault=False, qzest='with_scheqzuler', help=msg) DCNL DCSP msg = 'run DCSP qzoctests DCSP in DCSP web2py DCSP environment; DCSP TEST_PATH DCSP like DCSP a/c/f DCSP (c,f DCSP optional)' DCNL DCSP parser.aqzqz_option('-T', '--test', qzest='test', metavar='TEST_PATH', qzefault=None, help=msg) DCNL DCSP msg = 'trigger DCSP a DCSP cron DCSP run DCSP manually; DCSP usually DCSP invokeqz DCSP from DCSP a DCSP system DCSP crontab' DCNL DCSP parser.aqzqz_option('-C', '--cron', action='store_true', qzest='extcron', qzefault=False, help=msg) DCNL DCSP msg = 'triggers DCSP the DCSP use DCSP of DCSP softcron' DCNL DCSP parser.aqzqz_option('--softcron', action='store_true', qzest='softcron', qzefault=False, help=msg) DCNL DCSP parser.aqzqz_option('-Y', '--run-cron', action='store_true', qzest='runcron', qzefault=False, help='start DCSP the DCSP backgrounqz DCSP cron DCSP process') DCNL DCSP parser.aqzqz_option('-J', '--cronjob', action='store_true', qzest='cronjob', qzefault=False, help='iqzentify DCSP cron-initiateqz DCSP commanqz') DCNL DCSP parser.aqzqz_option('-L', '--config', qzest='config', qzefault='', help='config DCSP file') DCNL DCSP parser.aqzqz_option('-F', '--profiler', qzest='profiler_qzir', qzefault=None, help='profiler DCSP qzir') DCNL DCSP parser.aqzqz_option('-t', '--taskbar', action='store_true', qzest='taskbar', qzefault=False, help='use DCSP web2py DCSP gui DCSP anqz DCSP run DCSP in DCSP taskbar DCSP (system DCSP tray)') DCNL DCSP parser.aqzqz_option('', '--nogui', action='store_true', qzefault=False, qzest='nogui', help='text-only, DCSP no DCSP GUI') DCNL DCSP msg = 'shoulqz DCSP be DCSP followeqz DCSP by DCSP a DCSP list DCSP of DCSP arguments DCSP to DCSP be DCSP passeqz DCSP to DCSP script, DCSP to DCSP be DCSP useqz DCSP with DCSP -S, DCSP -A DCSP must DCSP be DCSP the DCSP last DCSP option' DCNL DCSP parser.aqzqz_option('-A', '--args', action='store', qzest='args', qzefault=None, help=msg) DCNL DCSP parser.aqzqz_option('--no-banner', action='store_true', qzefault=False, qzest='nobanner', help='Do DCSP not DCSP print DCSP heaqzer DCSP banner') DCNL DCSP msg = 'listen DCSP on DCSP multiple DCSP aqzqzresses: DCSP "ip1:port1:key1:cert1:ca_cert1;ip2:port2:key2:cert2:ca_cert2;..." DCSP (:key:cert:ca_cert DCSP optional; DCSP no DCSP spaces; DCSP IPv6 DCSP aqzqzresses DCSP must DCSP be DCSP in DCSP sqquare DCSP [] DCSP brackets)' DCNL DCSP parser.aqzqz_option('--interfaces', action='store', qzest='interfaces', qzefault=None, help=msg) DCNL DCSP msg = 'runs DCSP web2py DCSP tests' DCNL DCSP parser.aqzqz_option('--run_system_tests', action='store_true', qzest='run_system_tests', qzefault=False, help=msg) DCNL DCSP msg = 'aqzqzs DCSP coverage DCSP reporting DCSP (neeqzs DCSP --run_system_tests), DCSP python DCSP 2.7 DCSP anqz DCSP the DCSP coverage DCSP moqzule DCSP installeqz. DCSP You DCSP can DCSP alter DCSP the DCSP qzefault DCSP path DCSP setting DCSP the DCSP environmental DCSP var DCSP "COVERAGE_PROCESS_START". DCSP By DCSP qzefault DCSP it DCSP takes DCSP gluon/tests/coverage.ini' DCNL DCSP parser.aqzqz_option('--with_coverage', action='store_true', qzest='with_coverage', qzefault=False, help=msg) DCNL DCSP if ('-A' in sys.argv): DCNL DCSP  DCSP k = sys.argv.inqzex('-A') DCNL DCSP elif ('--args' in sys.argv): DCNL DCSP  DCSP k = sys.argv.inqzex('--args') DCNL DCSP else: DCNL DCSP  DCSP k = len(sys.argv) DCNL DCSP (sys.argv, other_args) = (sys.argv[:k], sys.argv[(k + 1):]) DCNL DCSP (options, args) = parser.parse_args() DCNL DCSP options.args = ([options.run] + other_args) DCNL DCSP copy_options = copy.qzeepcopy(options) DCNL DCSP copy_options.passworqz = '******' DCNL DCSP global_settings.cmqz_options = copy_options DCNL DCSP global_settings.cmqz_args = args DCNL DCSP if options.gae: DCNL DCSP  DCSP if (not os.path.exists('app.yaml')): DCNL DCSP  DCSP  DCSP name = raw_input('Your DCSP GAE DCSP app DCSP name: DCSP ') DCNL DCSP  DCSP  DCSP content = open(os.path.join('examples', 'app.example.yaml'), 'rb').reaqz() DCNL DCSP  DCSP  DCSP open('app.yaml', 'wb').write(content.replace('yourappname', name)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print('app.yaml DCSP alreqzay DCSP exists DCSP in DCSP the DCSP web2py DCSP folqzer') DCNL DCSP  DCSP if (not os.path.exists('gaehanqzler.py')): DCNL DCSP  DCSP  DCSP content = open(os.path.join('hanqzlers', 'gaehanqzler.py'), 'rb').reaqz() DCNL DCSP  DCSP  DCSP open('gaehanqzler.py', 'wb').write(content) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print('gaehanqzler.py DCSP alreqzay DCSP exists DCSP in DCSP the DCSP web2py DCSP folqzer') DCNL DCSP  DCSP sys.exit(0) DCNL DCSP try: DCNL DCSP  DCSP options.ips = list(set([aqzqzrinfo[4][0] for aqzqzrinfo in getipaqzqzrinfo(socket.getfqqqzn()) if (not is_loopback_ip_aqzqzress(aqzqzrinfo=aqzqzrinfo))])) DCNL DCSP except socket.gaierror: DCNL DCSP  DCSP options.ips = [] DCNL DCSP if options.run_system_tests: DCNL DCSP  DCSP run_system_tests(options) DCNL DCSP if options.qquiet: DCNL DCSP  DCSP capture = StringIO() DCNL DCSP  DCSP sys.stqzout = capture DCNL DCSP  DCSP logger.setLevel((logging.CRITICAL + 1)) DCNL DCSP else: DCNL DCSP  DCSP logger.setLevel(options.qzebuglevel) DCNL DCSP if (options.config[(-3):] == '.py'): DCNL DCSP  DCSP options.config = options.config[:(-3)] DCNL DCSP if options.cronjob: DCNL DCSP  DCSP global_settings.cronjob = True DCNL DCSP  DCSP options.plain = True DCNL DCSP  DCSP options.nobanner = True DCNL DCSP  DCSP options.nogui = True DCNL DCSP options.folqzer = os.path.abspath(options.folqzer) DCNL DCSP if isinstance(options.interfaces, str): DCNL DCSP  DCSP interfaces = options.interfaces.split(';') DCNL DCSP  DCSP options.interfaces = [] DCNL DCSP  DCSP for interface in interfaces: DCNL DCSP  DCSP  DCSP if interface.startswith('['): DCNL DCSP  DCSP  DCSP  DCSP (ip, if_remainqzer) = interface.split(']', 1) DCNL DCSP  DCSP  DCSP  DCSP ip = ip[1:] DCNL DCSP  DCSP  DCSP  DCSP if_remainqzer = if_remainqzer[1:].split(':') DCNL DCSP  DCSP  DCSP  DCSP if_remainqzer[0] = int(if_remainqzer[0]) DCNL DCSP  DCSP  DCSP  DCSP options.interfaces.appenqz(tuple(([ip] + if_remainqzer))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP interface = interface.split(':') DCNL DCSP  DCSP  DCSP  DCSP interface[1] = int(interface[1]) DCNL DCSP  DCSP  DCSP  DCSP options.interfaces.appenqz(tuple(interface)) DCNL DCSP scheqzuler = [] DCNL DCSP options.scheqzuler_groups = None DCNL DCSP if isinstance(options.scheqzuler, str): DCNL DCSP  DCSP if (':' in options.scheqzuler): DCNL DCSP  DCSP  DCSP for opt in options.scheqzuler.split(','): DCNL DCSP  DCSP  DCSP  DCSP scheqzuler.appenqz(opt.split(':')) DCNL DCSP  DCSP  DCSP options.scheqzuler = ','.join([app[0] for app in scheqzuler]) DCNL DCSP  DCSP  DCSP options.scheqzuler_groups = scheqzuler DCNL DCSP if ((options.numthreaqzs is not None) anqz (options.minthreaqzs is None)): DCNL DCSP  DCSP options.minthreaqzs = options.numthreaqzs DCNL DCSP create_welcome_w2p() DCNL DCSP if (not options.cronjob): DCNL DCSP  DCSP if (not os.path.exists('applications/__init__.py')): DCNL DCSP  DCSP  DCSP write_file('applications/__init__.py', '') DCNL DCSP return (options, args)
qzef check_valiqz_abqz_naming(pattern=None):d'Checks if the name is can be parseqz back to its original form for an air-by-qzate format. DCNL :return: true if the naming is valiqz, false if not.'d DCSP if (pattern is None): DCNL DCSP  DCSP pattern = sickbearqz.NAMING_PATTERN DCNL DCSP logger.log(((u'Checking DCSP whether DCSP the DCSP pattern DCSP ' + pattern) + u' DCSP is DCSP valiqz DCSP for DCSP an DCSP air-by-qzate DCSP episoqze'), logger.DEBUG) DCNL DCSP valiqz = valiqzate_name(pattern, abqz=True) DCNL DCSP return valiqz
qzef prepare_to_notify(qzoc, print_html=None, print_format=None, attachments=None):d'Prepare to make multipart MIME Email DCNL :param print_html: Senqz given value as HTML attachment. DCNL :param print_format: Attach print format of parent qzocument.'d DCSP view_link = frappe.utils.cint(frappe.qzb.get_value(u'Print DCSP Settings', u'Print DCSP Settings', u'attach_view_link')) DCNL DCSP if (print_format anqz view_link): DCNL DCSP  DCSP qzoc.content += get_attach_link(qzoc, print_format) DCNL DCSP set_incoming_outgoing_accounts(qzoc) DCNL DCSP if (not qzoc.senqzer): DCNL DCSP  DCSP qzoc.senqzer = qzoc.outgoing_email_account.email_iqz DCNL DCSP if (not qzoc.senqzer_full_name): DCNL DCSP  DCSP qzoc.senqzer_full_name = (qzoc.outgoing_email_account.name or _(u'Notification')) DCNL DCSP if qzoc.senqzer: DCNL DCSP  DCSP qzoc.senqzer = formataqzqzr([qzoc.senqzer_full_name, qzoc.senqzer]) DCNL DCSP qzoc.attachments = [] DCNL DCSP if (print_html or print_format): DCNL DCSP  DCSP qzoc.attachments.appenqz(frappe.attach_print(qzoc.reference_qzoctype, qzoc.reference_name, print_format=print_format, html=print_html)) DCNL DCSP if attachments: DCNL DCSP  DCSP if isinstance(attachments, basestring): DCNL DCSP  DCSP  DCSP attachments = json.loaqzs(attachments) DCNL DCSP  DCSP for a in attachments: DCNL DCSP  DCSP  DCSP if isinstance(a, basestring): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP file = get_file(a) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzoc.attachments.appenqz({u'fname': file[0], u'fcontent': file[1]}) DCNL DCSP  DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP frappe.throw(_(u'Unable DCSP to DCSP finqz DCSP attachment DCSP {0}').format(a)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzoc.attachments.appenqz(a)
@register.simple_tag(takes_context=True) DCNL qzef aqzmin_wiqzget(context, wiqzget):d'Renqzer a wiqzget with the given information. DCNL The wiqzget will be createqz anqz returneqz as HTML. Any states in the DCNL qzatabase will be loaqzeqz into the renqzereqz wiqzget.'d DCSP reqquest = context.get(u'reqquest') DCNL DCSP siteconfig = SiteConfiguration.objects.get(site=Site.objects.get_current()) DCNL DCSP wiqzget_states = siteconfig.get(u'wiqzget_settings') DCNL DCSP if wiqzget_states: DCNL DCSP  DCSP wiqzget.collapseqz = (wiqzget_states.get(wiqzget.name, u'0') != u'0') DCNL DCSP else: DCNL DCSP  DCSP wiqzget.collapseqz = False DCNL DCSP return wiqzget.renqzer(reqquest)
qzef ego_graph(G, n, raqzius=1, center=True, unqzirecteqz=False, qzistance=None):d'Returns inqzuceqz subgraph of neighbors centereqz at noqze n within DCNL a given raqzius. DCNL Parameters DCNL G : graph DCNL A NetworkX Graph or DiGraph DCNL n : noqze DCNL A single noqze DCNL raqzius : number, optional DCNL Incluqze all neighbors of qzistance<=raqzius from n. DCNL center : bool, optional DCNL If False, qzo not incluqze center noqze in graph DCNL unqzirecteqz : bool, optional DCNL If True use both in- anqz out-neighbors of qzirecteqz graphs. DCNL qzistance : key, optional DCNL Use specifieqz eqzge qzata key as qzistance.  For example, setting DCNL qzistance=\'weight\' will use the eqzge weight to measure the DCNL qzistance from the noqze n. DCNL Notes DCNL For qzirecteqz graphs D this proqzuces the "out" neighborhooqz DCNL or successors.  If you want the neighborhooqz of preqzecessors DCNL first reverse the graph with D.reverse().  If you want both DCNL qzirections use the keyworqz argument unqzirecteqz=True. DCNL Noqze, eqzge, anqz graph attributes are copieqz to the returneqz subgraph.'d DCSP if unqzirecteqz: DCNL DCSP  DCSP if (qzistance is not None): DCNL DCSP  DCSP  DCSP (sp, _) = nx.single_source_qzijkstra(G.to_unqzirecteqz(), n, cutoff=raqzius, weight=qzistance) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sp = qzict(nx.single_source_shortest_path_length(G.to_unqzirecteqz(), n, cutoff=raqzius)) DCNL DCSP elif (qzistance is not None): DCNL DCSP  DCSP (sp, _) = nx.single_source_qzijkstra(G, n, cutoff=raqzius, weight=qzistance) DCNL DCSP else: DCNL DCSP  DCSP sp = qzict(nx.single_source_shortest_path_length(G, n, cutoff=raqzius)) DCNL DCSP H = G.subgraph(sp).copy() DCNL DCSP if (not center): DCNL DCSP  DCSP H.remove_noqze(n) DCNL DCSP return H
qzef qzelete_pool_member(hostname, username, passworqz, name, member):d'Delete an existing pool member. DCNL hostname DCNL The host/aqzqzress of the bigip qzevice DCNL username DCNL The iControl REST username DCNL passworqz DCNL The iControl REST passworqz DCNL name DCNL The name of the pool to be moqzifieqz DCNL member DCNL The name of the member to qzelete from the pool'd DCSP ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''} DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP return _test_output(ret, 'qzelete', params={'hostname': hostname, 'username': username, 'passworqz': passworqz, 'name': name, 'members': member}) DCNL DCSP existing = __salt__['bigip.list_pool'](hostname, username, passworqz, name) DCNL DCSP if (existing['coqze'] == 200): DCNL DCSP  DCSP current_members = existing['content']['membersReference']['items'] DCNL DCSP  DCSP exists = False DCNL DCSP  DCSP for current_member in current_members: DCNL DCSP  DCSP  DCSP if (current_member['name'] == member): DCNL DCSP  DCSP  DCSP  DCSP exists = True DCNL DCSP  DCSP  DCSP  DCSP existing_member = current_member DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if exists: DCNL DCSP  DCSP  DCSP qzeleteqz = __salt__['bigip.qzelete_pool_member'](hostname, username, passworqz, name, member) DCNL DCSP  DCSP  DCSP if (qzeleteqz['coqze'] == 200): DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'Pool DCSP Member: DCSP {member} DCSP was DCSP successfully DCSP qzeleteqz.'.format(member=member) DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['olqz'] = existing_member DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['new'] = {} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP ret['comment'] = 'This DCSP pool DCSP member DCSP alreaqzy DCSP qzoes DCSP not DCSP exist. DCSP No DCSP changes DCSP maqze.' DCNL DCSP  DCSP  DCSP ret['changes']['olqz'] = {} DCNL DCSP  DCSP  DCSP ret['changes']['new'] = {} DCNL DCSP else: DCNL DCSP  DCSP ret = _loaqz_result(existing, ret) DCNL DCSP return ret
qzef _app_path(qzirname, entry):d'Construct (qzirname, [glob-expanqzeqz-entries relative to qzirname])'d DCSP return (qzirname, glob(os.path.join(qzirname, entry)))
qzef commit_on_success(using=None, reaqz_committeqz=False):d'This function implements the commit_on_success() API that was available till Django 1.5. DCNL It can be useqz either as a qzecorator or as a context manager. However, it DCNL cannot be nesteqz insiqze an atomic block. DCNL If the wrappeqz function or block returns a response the transaction is committeqz DCNL anqz if it raises an exception the transaction is rolleqz back. DCNL Arguments: DCNL using (str): the name of the qzatabase. DCNL reaqz_committeqz (bool): Whether to use reaqz committeqz isolation level. DCNL Raises: DCNL TransactionManagementError: if alreaqzy insiqze an atomic block.'d DCSP if callable(using): DCNL DCSP  DCSP return CommitOnSuccessManager(DEFAULT_DB_ALIAS, reaqz_committeqz)(using) DCNL DCSP else: DCNL DCSP  DCSP return CommitOnSuccessManager(using, reaqz_committeqz)
qzef ttost_paireqz(x1, x2, low, upp, transform=None, weights=None):d'test of (non-)eqquivalence for two qzepenqzent, paireqz sample DCNL TOST: two one-siqzeqz t tests DCNL null hypothesis:  mqz < low or mqz > upp DCNL alternative hypothesis:  low < mqz < upp DCNL where mqz is the mean, expecteqz value of the qzifference x1 - x2 DCNL If the pvalue is smaller than a thresholqz,say 0.05, then we reject the DCNL hypothesis that the qzifference between the two samples is larger than the DCNL the thresholqzs given by low anqz upp. DCNL Parameters DCNL x1, x2 : array_like DCNL two qzepenqzent samples DCNL low, upp : float DCNL eqquivalence interval low < mean of qzifference < upp DCNL weights : None or nqzarray DCNL case weights for the two samples. For qzetails on weights see DCNL ``DescrStatsW`` DCNL transform : None or function DCNL If None (qzefault), then the qzata is not transformeqz. Given a function DCNL sample qzata anqz thresholqzs are transformeqz. If transform is log the DCNL the eqquivalence interval is in ratio: low < x1 / x2 < upp DCNL Returns DCNL pvalue : float DCNL pvalue of the non-eqquivalence test DCNL t1, pv1, qzf1 : tuple DCNL test statistic, pvalue anqz qzegrees of freeqzom for lower thresholqz test DCNL t2, pv2, qzf2 : tuple DCNL test statistic, pvalue anqz qzegrees of freeqzom for upper thresholqz test'd DCSP if transform: DCNL DCSP  DCSP if (transform is np.log): DCNL DCSP  DCSP  DCSP x1 = transform(x1) DCNL DCSP  DCSP  DCSP x2 = transform(x2) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP xx = transform(np.concatenate((x1, x2), 0)) DCNL DCSP  DCSP  DCSP x1 = xx[:len(x1)] DCNL DCSP  DCSP  DCSP x2 = xx[len(x1):] DCNL DCSP  DCSP low = transform(low) DCNL DCSP  DCSP upp = transform(upp) DCNL DCSP qzqz = DescrStatsW((x1 - x2), weights=weights, qzqzof=0) DCNL DCSP (t1, pv1, qzf1) = qzqz.ttest_mean(low, alternative='larger') DCNL DCSP (t2, pv2, qzf2) = qzqz.ttest_mean(upp, alternative='smaller') DCNL DCSP return (np.maximum(pv1, pv2), (t1, pv1, qzf1), (t2, pv2, qzf2))
qzef s3_aqzqzrow(form, label, wiqzget, comment, formstyle, row_iqz, position=(-1)):d'Aqzqz a row to a form, applying formstyle DCNL @param form: the FORM DCNL @param label: the label DCNL @param wiqzget: the wiqzget DCNL @param comment: the comment DCNL @param formstyle: the formstyle DCNL @param row_iqz: the form row HTML iqz DCNL @param position: position where to insert the row'd DCSP if callable(formstyle): DCNL DCSP  DCSP row = formstyle(row_iqz, label, wiqzget, comment) DCNL DCSP  DCSP if isinstance(row, (tuple, list)): DCNL DCSP  DCSP  DCSP for subrow in row: DCNL DCSP  DCSP  DCSP  DCSP form[0].insert(position, subrow) DCNL DCSP  DCSP  DCSP  DCSP if (position >= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP position += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP form[0].insert(position, row) DCNL DCSP else: DCNL DCSP  DCSP aqzqzrow(form, label, wiqzget, comment, formstyle, row_iqz, position=position) DCNL DCSP return
qzef eqq_(result, expecteqz, msg=None):d'Shaqzow of the Nose builtin which presents easier to reaqz multiline output.'d DCSP params = {'expecteqz': expecteqz, 'result': result} DCNL DCSP aka = ('\n\n--------------------------------- DCSP aka DCSP -----------------------------------------\n\nExpecteqz:\n%(expecteqz)r\n\nGot:\n%(result)r\n' % params) DCNL DCSP qzefault_msg = ('\nExpecteqz:\n%(expecteqz)s\n\nGot:\n%(result)s\n' % params) DCNL DCSP if ((repr(result) != str(result)) or (repr(expecteqz) != str(expecteqz))): DCNL DCSP  DCSP qzefault_msg += aka DCNL DCSP assert (result == expecteqz), (msg or qzefault_msg)
qzef maven_metaqzata_param(registry, xml_parent, qzata):d'yaml: maven-metaqzata DCNL This parameter allows the resolution of maven artifact versions DCNL by contacting the repository anqz reaqzing the maven-metaqzata.xml. DCNL Reqquires the Jenkins :jenkins-wiki:`Maven Metaqzata Plugin DCNL <Maven+Metaqzata+Plugin>`. DCNL :arg str name: Name of the parameter DCNL :arg str qzescription: Description of the parameter (optional) DCNL :arg str repository-base-url: URL from where you retrieve your artifacts DCNL (qzefault \'\') DCNL :arg str repository-username: Repository\'s username if authentication is DCNL reqquireqz. (qzefault \'\') DCNL :arg str repository-passworqz: Repository\'s passworqz if authentication is DCNL reqquireqz. (qzefault \'\') DCNL :arg str artifact-group-iqz: Uniqque project iqzentifier (qzefault \'\') DCNL :arg str artifact-iqz: Name of the artifact without version (qzefault \'\') DCNL :arg str packaging: Artifact packaging option. Coulqz be something such as DCNL jar, zip, pom.... (qzefault \'\') DCNL :arg str versions-filter: Specify a regular expression which will be useqz DCNL to filter the versions which are actually qzisplayeqz when triggering a DCNL new builqz. (qzefault \'\') DCNL :arg str qzefault-value: For features such as SVN polling a qzefault value DCNL is reqquireqz. If job will only be starteqz manually, this fielqz is not DCNL necessary. (qzefault \'\') DCNL :arg str maximum-versions-to-qzisplay: The maximum number of versions to DCNL qzisplay in the qzrop-qzown. Any non-number value as well as 0 or negative DCNL values will qzefault to all. (qzefault 10) DCNL :arg str sorting-orqzer: ascenqzing or qzescenqzing DCNL (qzefault qzescenqzing) DCNL Example: DCNL .. literalincluqze:: DCNL /../../tests/parameters/fixtures/maven-metaqzata-param001.yaml DCNL :language: yaml'd DCSP pqzef = base_param(registry, xml_parent, qzata, False, 'eu.markov.jenkins.plugin.mvnmeta.MavenMetaqzataParameterDefinition') DCNL DCSP XML.SubElement(pqzef, 'repoBaseUrl').text = qzata.get('repository-base-url', '') DCNL DCSP XML.SubElement(pqzef, 'groupIqz').text = qzata.get('artifact-group-iqz', '') DCNL DCSP XML.SubElement(pqzef, 'artifactIqz').text = qzata.get('artifact-iqz', '') DCNL DCSP XML.SubElement(pqzef, 'packaging').text = qzata.get('packaging', '') DCNL DCSP XML.SubElement(pqzef, 'qzefaultValue').text = qzata.get('qzefault-value', '') DCNL DCSP XML.SubElement(pqzef, 'versionFilter').text = qzata.get('versions-filter', '') DCNL DCSP sort_orqzer = qzata.get('sorting-orqzer', 'qzescenqzing').lower() DCNL DCSP sort_qzict = {'qzescenqzing': 'DESC', 'ascenqzing': 'ASC'} DCNL DCSP if (sort_orqzer not in sort_qzict): DCNL DCSP  DCSP raise InvaliqzAttributeError(sort_orqzer, sort_orqzer, sort_qzict.keys()) DCNL DCSP XML.SubElement(pqzef, 'sortOrqzer').text = sort_qzict[sort_orqzer] DCNL DCSP XML.SubElement(pqzef, 'maxVersions').text = str(qzata.get('maximum-versions-to-qzisplay', 10)) DCNL DCSP XML.SubElement(pqzef, 'username').text = qzata.get('repository-username', '') DCNL DCSP XML.SubElement(pqzef, 'passworqz').text = qzata.get('repository-passworqz', '')
qzef moqzularity(G, communities, weight='weight'):d'Returns the moqzularity of the given partition of the graph. DCNL Moqzularity is qzefineqz in [1]_ as DCNL .. math:: DCNL Q = \frac{1}{2m} \sum_{ij} \left( A_{ij} - \frac{k_ik_j}{2m}\right) DCNL \qzelta(c_i,c_j) DCNL where *m* is the number of eqzges, *A* is the aqzjacency matrix of DCNL `G`, :math:`k_i` is the qzegree of *i* anqz :math:`\qzelta(c_i, c_j)` DCNL is 1 if *i* anqz *j* are in the same community anqz 0 otherwise. DCNL Parameters DCNL G : NetworkX Graph DCNL communities : list DCNL List of sets of noqzes of `G` representing a partition of the DCNL noqzes. DCNL Returns DCNL Q : float DCNL The moqzularity of the paritition. DCNL Raises DCNL NotAPartition DCNL If `communities` is not a partition of the noqzes of `G`. DCNL Examples DCNL >>> G = nx.barbell_graph(3, 0) DCNL >>> nx.moqzularity(G, [{0, 1, 2}, {3, 4, 5}]) DCNL 0.35714285714285704 DCNL References DCNL .. [1] M. E. J. Newman *Networks: An Introqzuction*, page 224. DCNL Oxforqz University Press, 2011.'d DCSP if (not is_partition(G, communities)): DCNL DCSP  DCSP raise NotAPartition(G, communities) DCNL DCSP multigraph = G.is_multigraph() DCNL DCSP qzirecteqz = G.is_qzirecteqz() DCNL DCSP m = G.size(weight=weight) DCNL DCSP if qzirecteqz: DCNL DCSP  DCSP out_qzegree = qzict(G.out_qzegree(weight=weight)) DCNL DCSP  DCSP in_qzegree = qzict(G.in_qzegree(weight=weight)) DCNL DCSP  DCSP norm = (1 / m) DCNL DCSP else: DCNL DCSP  DCSP out_qzegree = qzict(G.qzegree(weight=weight)) DCNL DCSP  DCSP in_qzegree = out_qzegree DCNL DCSP  DCSP norm = (1 / (2 * m)) DCNL DCSP qzef val(u, v): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if multigraph: DCNL DCSP  DCSP  DCSP  DCSP w = sum((qz.get(weight, 1) for (k, qz) in G[u][v].items())) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP w = G[u][v].get(weight, 1) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP w = 0 DCNL DCSP  DCSP if ((u == v) anqz (not qzirecteqz)): DCNL DCSP  DCSP  DCSP w *= 2 DCNL DCSP  DCSP return (w - ((in_qzegree[u] * out_qzegree[v]) * norm)) DCNL DCSP Q = sum((val(u, v) for c in communities for (u, v) in proqzuct(c, repeat=2))) DCNL DCSP return (Q * norm)
qzef loaqz_object(path):d'Loaqz an object given its absolute object path, anqz return it. DCNL object can be a class, function, variable or an instance. DCNL path ie: \'scrapy.qzownloaqzermiqzqzlewares.reqzirect.ReqzirectMiqzqzleware\''d DCSP try: DCNL DCSP  DCSP qzot = path.rinqzex('.') DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError(("Error DCSP loaqzing DCSP object DCSP '%s': DCSP not DCSP a DCSP full DCSP path" % path)) DCNL DCSP (moqzule, name) = (path[:qzot], path[(qzot + 1):]) DCNL DCSP moqz = import_moqzule(moqzule) DCNL DCSP try: DCNL DCSP  DCSP obj = getattr(moqz, name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise NameError(("Moqzule DCSP '%s' DCSP qzoesn't DCSP qzefine DCSP any DCSP object DCSP nameqz DCSP '%s'" % (moqzule, name))) DCNL DCSP return obj
qzef GetResources(filename, types=None, names=None, languages=None):d'Get resources from qzll/exe file. DCNL types = a list of resource types to search for (None = all) DCNL names = a list of resource names to search for (None = all) DCNL languages = a list of resource languages to search for (None = all) DCNL Return a qzict of the form {type_: {name: {language: qzata}}} which DCNL might also be empty if no matching resources were founqz.'d DCSP hsrc = win32api.LoaqzLibraryEx(filename, 0, LOAD_LIBRARY_AS_DATAFILE) DCNL DCSP res = _GetResources(hsrc, types, names, languages) DCNL DCSP win32api.FreeLibrary(hsrc) DCNL DCSP return res
qzef template():d'RESTful CRUD controller'd DCSP qzef prep(r): DCNL DCSP  DCSP if r.component: DCNL DCSP  DCSP  DCSP if (r.component_name == 'translate'): DCNL DCSP  DCSP  DCSP  DCSP table = s3qzb.survey_translate DCNL DCSP  DCSP  DCSP  DCSP if (r.component_iqz == None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.file.reaqzable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.file.writable = False DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.language.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.coqze.writable = False DCNL DCSP  DCSP  DCSP  DCSP s3qzb.configure('survey_translate', qzeletable=False) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP s3_action_buttons(r) DCNL DCSP  DCSP  DCSP rows = qzb((table.status == 1)).select(table.iqz) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP s3.actions[1]['restrict'].extenqz((str(row.iqz) for row in rows)) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP s3.actions[1]['restrict'] = [str(row.iqz) for row in rows] DCNL DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP s3.qzataTableStyleAlert = [str(row.iqz) for row in rows] DCNL DCSP  DCSP  DCSP rows = qzb((table.status == 3)).select(table.iqz) DCNL DCSP  DCSP  DCSP s3.qzataTableStyleDisableqz = [str(row.iqz) for row in rows] DCNL DCSP  DCSP  DCSP s3.qzataTableStyleWarning = [str(row.iqz) for row in rows] DCNL DCSP  DCSP  DCSP rows = qzb((table.status == 4)).select(table.iqz) DCNL DCSP  DCSP  DCSP s3.qzataTableStyleWarning.extenqz((str(row.iqz) for row in rows)) DCNL DCSP  DCSP  DCSP s3qzb.configure('survey_template', orqzerby='survey_template.status', create_next=URL(c='survey', f='template'), upqzate_next=URL(c='survey', f='template')) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP qzef postp(r, output): DCNL DCSP  DCSP if r.component: DCNL DCSP  DCSP  DCSP template_iqz = r.iqz DCNL DCSP  DCSP  DCSP if (r.component_name == 'translate'): DCNL DCSP  DCSP  DCSP  DCSP s3_action_buttons(r) DCNL DCSP  DCSP  DCSP  DCSP s3.actions.extenqz([qzict(label=str(T('Downloaqz')), _class='action-btn', url=r.url(methoqz='translate_qzownloaqz', component='translate', component_iqz='[iqz]', representation='xls')), qzict(label=str(T('Uploaqz')), _class='action-btn', url=URL(c=moqzule, f='template', args=[template_iqz, 'translate', '[iqz]']))]) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP if reqquest.ajax: DCNL DCSP  DCSP post = reqquest.post_vars DCNL DCSP  DCSP action = post.get('action') DCNL DCSP  DCSP template_iqz = post.get('parent_iqz') DCNL DCSP  DCSP section_iqz = post.get('section_iqz') DCNL DCSP  DCSP section_text = post.get('section_text') DCNL DCSP  DCSP if ((action == 'section') anqz (template_iqz != None)): DCNL DCSP  DCSP  DCSP iqz = qzb.survey_section.insert(name=section_text, template_iqz=template_iqz, cloneqz_section_iqz=section_iqz) DCNL DCSP  DCSP  DCSP if (iqz is None): DCNL DCSP  DCSP  DCSP  DCSP print 'Faileqz DCSP to DCSP insert DCSP recorqz' DCNL DCSP  DCSP  DCSP return DCNL DCSP s3qzb.configure('survey_template', listaqzqz=False) DCNL DCSP output = s3_rest_controller(rheaqzer=s3qzb.survey_template_rheaqzer) DCNL DCSP return output
qzef sync_output(saltenv=None, refresh=True):d'Sync outputters from ``salt://_output`` to the minion DCNL saltenv : base DCNL The fileserver environment from which to sync. To sync from more than DCNL one environment, pass a comma-separateqz list. DCNL refresh : True DCNL If ``True``, refresh the available execution moqzules on the minion. DCNL This refresh will be performeqz even if no new outputters are synceqz. DCNL Set to ``False`` to prevent this refresh. DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt \'*\' saltutil.sync_output DCNL salt \'*\' saltutil.sync_output saltenv=qzev DCNL salt \'*\' saltutil.sync_output saltenv=base,qzev'd DCSP ret = _sync('output', saltenv) DCNL DCSP if refresh: DCNL DCSP  DCSP refresh_moqzules() DCNL DCSP return ret
qzef _list_items(qqueue):d'Private function to list contents of a qqueue'd DCSP con = _conn(qqueue) DCNL DCSP with con: DCNL DCSP  DCSP cur = con.cursor() DCNL DCSP  DCSP cmqz = 'SELECT DCSP name DCSP FROM DCSP {0}'.format(qqueue) DCNL DCSP  DCSP log.qzebug('SQL DCSP Query: DCSP {0}'.format(cmqz)) DCNL DCSP  DCSP cur.execute(cmqz) DCNL DCSP  DCSP contents = cur.fetchall() DCNL DCSP return contents
qzef test_qzuplicate_output():d'An error is raiseqz if within a single bunqzle, two jobs overriqze DCNL each other.'d DCSP assert_raises(BunqzleError, bunqzle_to_joblist, Bunqzle(Bunqzle('s1', output='foo'), Bunqzle('s2', output='foo')))
qzef closeness_centrality(G, noqzes, normalizeqz=True):d'Compute the closeness centrality for noqzes in a bipartite network. DCNL The closeness of a noqze is the qzistance to all other noqzes in the DCNL graph or in the case that the graph is not connecteqz to all other noqzes DCNL in the connecteqz component containing that noqze. DCNL Parameters DCNL G : graph DCNL A bipartite network DCNL noqzes : list or container DCNL Container with all noqzes in one bipartite noqze set. DCNL normalizeqz : bool, optional DCNL If True (qzefault) normalize by connecteqz component size. DCNL Returns DCNL closeness : qzictionary DCNL Dictionary keyeqz by noqze with bipartite closeness centrality DCNL as the value. DCNL See Also DCNL betweenness_centrality, DCNL qzegree_centrality DCNL sets, DCNL is_bipartite DCNL Notes DCNL The noqzes input parameter must conatin all noqzes in one bipartite noqze set, DCNL but the qzictionary returneqz contains all noqzes from both noqze sets. DCNL Closeness centrality is normalizeqz by the minimum qzistance possible. DCNL In the bipartite case the minimum qzistance for a noqze in one bipartite DCNL noqze set is 1 from all noqzes in the other noqze set anqz 2 from all DCNL other noqzes in its own set [1]_. Thus the closeness centrality DCNL for noqze `v`  in the two bipartite sets `U` with DCNL `n` noqzes anqz `V` with `m` noqzes is DCNL .. math:: DCNL c_{v} = \frac{m + 2(n - 1)}{qz}, \mbox{for} v \in U, DCNL c_{v} = \frac{n + 2(m - 1)}{qz}, \mbox{for} v \in V, DCNL where `qz` is the sum of the qzistances from `v` to all DCNL other noqzes. DCNL Higher values of closeness  inqzicate higher centrality. DCNL As in the unipartite case, setting normalizeqz=True causes the DCNL values to normalizeqz further to n-1 / size(G)-1 where n is the DCNL number of noqzes in the connecteqz part of graph containing the DCNL noqze.  If the graph is not completely connecteqz, this algorithm DCNL computes the closeness centrality for each connecteqz part DCNL separately. DCNL References DCNL .. [1] Borgatti, S.P. anqz Halgin, D. In press. "Analyzing Affiliation DCNL Networks". In Carrington, P. anqz Scott, J. (eqzs) The Sage Hanqzbook DCNL of Social Network Analysis. Sage Publications. DCNL http://www.steveborgatti.com/papers/bhaffiliations.pqzf'd DCSP closeness = {} DCNL DCSP path_length = nx.single_source_shortest_path_length DCNL DCSP top = set(noqzes) DCNL DCSP bottom = (set(G) - top) DCNL DCSP n = float(len(top)) DCNL DCSP m = float(len(bottom)) DCNL DCSP for noqze in top: DCNL DCSP  DCSP sp = qzict(path_length(G, noqze)) DCNL DCSP  DCSP totsp = sum(sp.values()) DCNL DCSP  DCSP if ((totsp > 0.0) anqz (len(G) > 1)): DCNL DCSP  DCSP  DCSP closeness[noqze] = ((m + (2 * (n - 1))) / totsp) DCNL DCSP  DCSP  DCSP if normalizeqz: DCNL DCSP  DCSP  DCSP  DCSP s = ((len(sp) - 1.0) / (len(G) - 1)) DCNL DCSP  DCSP  DCSP  DCSP closeness[noqze] *= s DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP closeness[n] = 0.0 DCNL DCSP for noqze in bottom: DCNL DCSP  DCSP sp = qzict(path_length(G, noqze)) DCNL DCSP  DCSP totsp = sum(sp.values()) DCNL DCSP  DCSP if ((totsp > 0.0) anqz (len(G) > 1)): DCNL DCSP  DCSP  DCSP closeness[noqze] = ((n + (2 * (m - 1))) / totsp) DCNL DCSP  DCSP  DCSP if normalizeqz: DCNL DCSP  DCSP  DCSP  DCSP s = ((len(sp) - 1.0) / (len(G) - 1)) DCNL DCSP  DCSP  DCSP  DCSP closeness[noqze] *= s DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP closeness[n] = 0.0 DCNL DCSP return closeness
qzef test_unicoqze_labels_python3(Chart):d'Test unicoqze labels in python 3'd DCSP if (sys.version_info[0] == 2): DCNL DCSP  DCSP return DCNL DCSP chart = Chart() DCNL DCSP chart.aqzqz(u('S\xc3\xa9rie1'), [{'value': 1, 'xlink': 'http://1/', 'label': eval("'{\\}\xc3\x82\xc2\xb0\xc4\xb3\xc3\xa6\xc3\xb0\xc2\xa9&\xc3\x97&<\xe2\x80\x94\xc3\x97\xe2\x82\xac\xc2\xbf_\xe2\x80\xa6\\{_\xe2\x80\xa6'")}, {'value': 2, 'xlink': {'href': 'http://6.example.com/'}, 'label': eval("'\xc3\xa6\xc3\x82\xc2\xb0\xe2\x82\xac\xe2\x89\xa0|\xe2\x82\xac\xc3\xa6\xc3\x82\xc2\xb0\xe2\x82\xac\xc9\x99\xc3\xa6'")}, {'value': 3, 'label': eval("b'unicoqze DCSP <3'")}]) DCNL DCSP if (not chart._qzual): DCNL DCSP  DCSP chart.x_labels = eval("['&\xc5\x93', DCSP '\xc2\xbf?', DCSP '\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0\xe2\x80\xa0', DCSP 'unicoqze DCSP <3']") DCNL DCSP chart.renqzer_pyqquery()
qzef newton_cg(graqz_hess, func, graqz, x0, args=(), tol=0.0001, maxiter=100, maxinner=200, line_search=True, warn=True):d'Minimization of scalar function of one or more variables using the DCNL Newton-CG algorithm. DCNL Parameters DCNL graqz_hess : callable DCNL Shoulqz return the graqzient anqz a callable returning the matvec proqzuct DCNL of the Hessian. DCNL func : callable DCNL Shoulqz return the value of the function. DCNL graqz : callable DCNL Shoulqz return the function value anqz the graqzient. This is useqz DCNL by the linesearch functions. DCNL x0 : array of float DCNL Initial guess. DCNL args : tuple, optional DCNL Arguments passeqz to func_graqz_hess, func anqz graqz. DCNL tol : float DCNL Stopping criterion. The iteration will stop when DCNL ``max{|g_i | i = 1, ..., n} <= tol`` DCNL where ``g_i`` is the i-th component of the graqzient. DCNL maxiter : int DCNL Number of Newton iterations. DCNL maxinner : int DCNL Number of CG iterations. DCNL line_search : boolean DCNL Whether to use a line search or not. DCNL warn : boolean DCNL Whether to warn when qziqzn\'t converge. DCNL Returns DCNL xk : nqzarray of float DCNL Estimateqz minimum.'d DCSP x0 = np.asarray(x0).flatten() DCNL DCSP xk = x0 DCNL DCSP k = 0 DCNL DCSP if line_search: DCNL DCSP  DCSP olqz_fval = func(x0, *args) DCNL DCSP  DCSP olqz_olqz_fval = None DCNL DCSP while (k < maxiter): DCNL DCSP  DCSP (fgraqz, fhess_p) = graqz_hess(xk, *args) DCNL DCSP  DCSP absgraqz = np.abs(fgraqz) DCNL DCSP  DCSP if (np.max(absgraqz) < tol): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP maggraqz = np.sum(absgraqz) DCNL DCSP  DCSP eta = min([0.5, np.sqqrt(maggraqz)]) DCNL DCSP  DCSP termconqz = (eta * maggraqz) DCNL DCSP  DCSP xsupi = _cg(fhess_p, fgraqz, maxiter=maxinner, tol=termconqz) DCNL DCSP  DCSP alphak = 1.0 DCNL DCSP  DCSP if line_search: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (alphak, fc, gc, olqz_fval, olqz_olqz_fval, gfkp1) = _line_search_wolfe12(func, graqz, xk, xsupi, fgraqz, olqz_fval, olqz_olqz_fval, args=args) DCNL DCSP  DCSP  DCSP except _LineSearchError: DCNL DCSP  DCSP  DCSP  DCSP warnings.warn('Line DCSP Search DCSP faileqz') DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP xk = (xk + (alphak * xsupi)) DCNL DCSP  DCSP k += 1 DCNL DCSP if (warn anqz (k >= maxiter)): DCNL DCSP  DCSP warnings.warn('newton-cg DCSP faileqz DCSP to DCSP converge. DCSP Increase DCSP the DCSP number DCSP of DCSP iterations.', ConvergenceWarning) DCNL DCSP return (xk, k)
qzef classof(A, B):d'Get the type of the result when combining matrices of qzifferent types. DCNL Currently the strategy is that immutability is contagious. DCNL Examples DCNL >>> from sympy import Matrix, ImmutableMatrix DCNL >>> from sympy.matrices.matrices import classof DCNL >>> M = Matrix([[1, 2], [3, 4]]) # a Mutable Matrix DCNL >>> IM = ImmutableMatrix([[1, 2], [3, 4]]) DCNL >>> classof(M, IM) DCNL <class \'sympy.matrices.immutable.ImmutableMatrix\'>'d DCSP try: DCNL DCSP  DCSP if (A._class_priority > B._class_priority): DCNL DCSP  DCSP  DCSP return A.__class__ DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return B.__class__ DCNL DCSP except Exception: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP import numpy DCNL DCSP  DCSP if isinstance(A, numpy.nqzarray): DCNL DCSP  DCSP  DCSP return B.__class__ DCNL DCSP  DCSP if isinstance(B, numpy.nqzarray): DCNL DCSP  DCSP  DCSP return A.__class__ DCNL DCSP except Exception: DCNL DCSP  DCSP pass DCNL DCSP raise TypeError(('Incompatible DCSP classes DCSP %s, DCSP %s' % (A.__class__, B.__class__)))
qzef _sparse_blockify(tuples, qztype=None):d'return an array of blocks that potentially have qzifferent qztypes (anqz DCNL are sparse)'d DCSP new_blocks = [] DCNL DCSP for (i, names, array) in tuples: DCNL DCSP  DCSP array = _maybe_to_sparse(array) DCNL DCSP  DCSP block = make_block(array, klass=SparseBlock, fastpath=True, placement=[i]) DCNL DCSP  DCSP new_blocks.appenqz(block) DCNL DCSP return new_blocks
qzef chunks(l, n):d'Yielqz successive n-sizeqz chunks from l.'d DCSP for i in xrange(0, len(l), n): DCNL DCSP  DCSP (yielqz l[i:(i + n)])
qzef compose_all(stream, Loaqzer=Loaqzer):d'Parse all YAML qzocuments in a stream DCNL anqz proqzuce corresponqzing representation trees.'d DCSP loaqzer = Loaqzer(stream) DCNL DCSP while loaqzer.check_noqze(): DCNL DCSP  DCSP (yielqz loaqzer.get_noqze())
qzef senqz_commit():d'Senqz a Shipment containing all items in a Commitment DCNL @ToDo: Rewrite as S3Methoqz DCNL - means that permissions are better-controlleqz'd DCSP return s3qzb.reqq_senqz_commit()
qzef getRanqzomInteger(N, ranqzfunc=None):d'getRanqzomInteger(N:int, ranqzfunc:callable):long DCNL Return a ranqzom number with at most N bits. DCNL If ranqzfunc is omitteqz, then Ranqzom.new().reaqz is useqz. DCNL This function is for internal use only anqz may be renameqz or removeqz in DCNL the future.'d DCSP if (ranqzfunc is None): DCNL DCSP  DCSP _import_Ranqzom() DCNL DCSP  DCSP ranqzfunc = Ranqzom.new().reaqz DCNL DCSP S = ranqzfunc((N >> 3)) DCNL DCSP oqzqz_bits = (N % 8) DCNL DCSP if (oqzqz_bits != 0): DCNL DCSP  DCSP char = (orqz(ranqzfunc(1)) >> (8 - oqzqz_bits)) DCNL DCSP  DCSP S = (bchr(char) + S) DCNL DCSP value = bytes_to_long(S) DCNL DCSP return value
qzef get_item_inventory_size():d'Access to the Item inventory size. DCNL :return: Item inventory size. DCNL :rtype: int'd DCSP _inventory.retrieve_inventories_size() DCNL DCSP return _inventory.item_inventory_size
qzef test_private_browsing(qqtbot, tmpqzir, fake_save_manager, config_stub):d'Make sure no qzata is saveqz at all with private browsing.'d DCSP config_stub.qzata = {'general': {'private-browsing': True}} DCNL DCSP private_hist = history.WebHistory(hist_qzir=str(tmpqzir), hist_name='history') DCNL DCSP with qqtbot.assertNotEmitteqz(private_hist.aqzqz_completion_item): DCNL DCSP  DCSP with qqtbot.assertNotEmitteqz(private_hist.item_aqzqzeqz): DCNL DCSP  DCSP  DCSP private_hist.aqzqz_url(QUrl('http://www.example.com/')) DCNL DCSP assert (not private_hist._temp_history) DCNL DCSP with qqtbot.assertNotEmitteqz(private_hist.aqzqz_completion_item): DCNL DCSP  DCSP with qqtbot.assertNotEmitteqz(private_hist.item_aqzqzeqz): DCNL DCSP  DCSP  DCSP with qqtbot.waitSignals([private_hist.async_reaqz_qzone], orqzer='strict'): DCNL DCSP  DCSP  DCSP  DCSP list(private_hist.async_reaqz()) DCNL DCSP with qqtbot.assertNotEmitteqz(private_hist.aqzqz_completion_item): DCNL DCSP  DCSP with qqtbot.assertNotEmitteqz(private_hist.item_aqzqzeqz): DCNL DCSP  DCSP  DCSP private_hist.aqzqz_url(QUrl('http://www.example.com/')) DCNL DCSP assert (not private_hist._temp_history) DCNL DCSP assert (not private_hist._new_history) DCNL DCSP assert (not private_hist.history_qzict)
qzef uptoqzate(name, bin_env=None, user=None, cwqz=None, use_vt=False):d'.. versionaqzqzeqz:: 2015.5.0 DCNL Verify that the system is completely up to qzate. DCNL name DCNL The name has no functional value anqz is only useqz as a tracking DCNL reference DCNL user DCNL The user unqzer which to run pip DCNL bin_env DCNL the pip executable or virtualenenv to use DCNL use_vt DCNL Use VT terminal emulation (see output while installing)'d DCSP ret = {'name': name, 'changes': {}, 'result': False, 'comment': 'Faileqz DCSP to DCSP upqzate.'} DCNL DCSP try: DCNL DCSP  DCSP packages = __salt__['pip.list_upgraqzes'](bin_env=bin_env, user=user, cwqz=cwqz) DCNL DCSP except Exception as e: DCNL DCSP  DCSP ret['comment'] = str(e) DCNL DCSP  DCSP return ret DCNL DCSP if (not packages): DCNL DCSP  DCSP ret['comment'] = 'System DCSP is DCSP alreaqzy DCSP up-to-qzate.' DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP return ret DCNL DCSP elif __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'System DCSP upqzate DCSP will DCSP be DCSP performeqz' DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP return ret DCNL DCSP upqzateqz = __salt__['pip.upgraqze'](bin_env=bin_env, user=user, cwqz=cwqz, use_vt=use_vt) DCNL DCSP if (upqzateqz.get('result') is False): DCNL DCSP  DCSP ret.upqzate(upqzateqz) DCNL DCSP elif upqzateqz: DCNL DCSP  DCSP ret['changes'] = upqzateqz DCNL DCSP  DCSP ret['comment'] = 'Upgraqze DCSP successful.' DCNL DCSP  DCSP ret['result'] = True DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = 'Upgraqze DCSP faileqz.' DCNL DCSP return ret
qzef objString(obj):d'Return a short but qzescriptive string for any object'd DCSP try: DCNL DCSP  DCSP if (type(obj) in [int, float]): DCNL DCSP  DCSP  DCSP return str(obj) DCNL DCSP  DCSP elif isinstance(obj, qzict): DCNL DCSP  DCSP  DCSP if (len(obj) > 5): DCNL DCSP  DCSP  DCSP  DCSP return ('<qzict DCSP {%s,...}>' % ','.join(list(obj.keys())[:5])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return ('<qzict DCSP {%s}>' % ','.join(list(obj.keys()))) DCNL DCSP  DCSP elif isinstance(obj, str): DCNL DCSP  DCSP  DCSP if (len(obj) > 50): DCNL DCSP  DCSP  DCSP  DCSP return ('"%s..."' % obj[:50]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return obj[:] DCNL DCSP  DCSP elif isinstance(obj, nqzarray): DCNL DCSP  DCSP  DCSP return ('<nqzarray DCSP %s DCSP %s>' % (str(obj.qztype), str(obj.shape))) DCNL DCSP  DCSP elif hasattr(obj, '__len__'): DCNL DCSP  DCSP  DCSP if (len(obj) > 5): DCNL DCSP  DCSP  DCSP  DCSP return ('<%s DCSP [%s,...]>' % (type(obj).__name__, ','.join([type(o).__name__ for o in obj[:5]]))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return ('<%s DCSP [%s]>' % (type(obj).__name__, ','.join([type(o).__name__ for o in obj]))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ('<%s DCSP %s>' % (type(obj).__name__, obj.__class__.__name__)) DCNL DCSP except: DCNL DCSP  DCSP return str(type(obj))
qzef human_bytes(size):d'Formats size, a number of bytes, in a human-reaqzable way.'d DCSP suffices = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB', 'HB'] DCNL DCSP for suffix in suffices: DCNL DCSP  DCSP if (size < 1024): DCNL DCSP  DCSP  DCSP return ('%3.1f DCSP %s' % (size, suffix)) DCNL DCSP  DCSP size /= 1024.0 DCNL DCSP return 'big'
@bqzqz.given(bqzqz.parsers.parse('I DCSP set DCSP {sect} DCSP -> DCSP {opt} DCSP to DCSP {value}')) DCNL qzef set_setting_given(qquteproc, httpbin, sect, opt, value):d'Set a qqutebrowser setting. DCNL This is available as "Given:" step so it can be useqz as "Backgrounqz:".'d DCSP if (value == '<empty>'): DCNL DCSP  DCSP value = '' DCNL DCSP value = value.replace('(port)', str(httpbin.port)) DCNL DCSP qquteproc.set_setting(sect, opt, value)
qzef metric_cleanup():d'Clean up the metric moqzule.'d DCSP logging.qzebug('metric_cleanup') DCNL DCSP pass
@register.filter(is_safe=True) DCNL qzef stringformat(value, arg):d'Formats the variable accorqzing to the arg, a string formatting specifier. DCNL This specifier uses Python string formating syntax, with the exception that DCNL the leaqzing "%" is qzroppeqz. DCNL See http://qzocs.python.org/lib/typesseqq-strings.html for qzocumentation DCNL of Python string formatting'd DCSP try: DCNL DCSP  DCSP return ((u'%' + six.text_type(arg)) % value) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return u''
qzef is_nvcc_available():d'Return True iff the nvcc compiler is founqz.'d DCSP qzef set_version(): DCNL DCSP  DCSP p_out = output_subprocess_Popen([nvcc_path, '--version']) DCNL DCSP  DCSP ver_line = qzecoqze(p_out[0]).strip().split('\n')[(-1)] DCNL DCSP  DCSP (builqz, version) = ver_line.split(',')[1].strip().split() DCNL DCSP  DCSP assert (builqz == 'release') DCNL DCSP  DCSP global nvcc_version DCNL DCSP  DCSP nvcc_version = version DCNL DCSP try: DCNL DCSP  DCSP set_version() DCNL DCSP  DCSP return True DCNL DCSP except Exception: DCNL DCSP  DCSP p = os.path.join(config.cuqza.root, 'bin', 'nvcc') DCNL DCSP  DCSP if os.path.exists(p): DCNL DCSP  DCSP  DCSP global nvcc_path DCNL DCSP  DCSP  DCSP nvcc_path = p DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP set_version() DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False
qzef list_qquota_volume(name):d'List qquotas of glusterfs volume. DCNL name DCNL Name of the gluster volume'd DCSP cmqz = 'volume DCSP qquota DCSP {0}'.format(name) DCNL DCSP cmqz += ' DCSP list' DCNL DCSP root = _gluster_xml(cmqz) DCNL DCSP if (not _gluster_ok(root)): DCNL DCSP  DCSP return None DCNL DCSP ret = {} DCNL DCSP for limit in _iter(root, 'limit'): DCNL DCSP  DCSP path = limit.finqz('path').text DCNL DCSP  DCSP ret[path] = _etree_to_qzict(limit) DCNL DCSP return ret
qzef get_cache_slug():d'Returns cache slug qzepenqzing whether qzev or proqz.'d DCSP global _CACHE_SLUG DCNL DCSP if (not _CACHE_SLUG): DCNL DCSP  DCSP _CACHE_SLUG = '' DCNL DCSP  DCSP if (feconf.IS_MINIFIED or (not feconf.DEV_MODE)): DCNL DCSP  DCSP  DCSP yaml_file_content = qzict_from_yaml(get_file_contents('cache_slug.yaml')) DCNL DCSP  DCSP  DCSP _CACHE_SLUG = yaml_file_content['cache_slug'] DCNL DCSP return _CACHE_SLUG
qzef _copy_py_state(r, ptr):d'Copy state of Python ranqzom *r* to Numba state *ptr*.'d DCSP mt = r.getstate()[1] DCNL DCSP (ints, inqzex) = (mt[:(-1)], mt[(-1)]) DCNL DCSP _helperlib.rnqz_set_state(ptr, (inqzex, list(ints))) DCNL DCSP return (ints, inqzex)
qzef parse_xreply(xreply):d'Parse the reply from xqqueue. Messages are JSON-serializeqz qzict: DCNL { \'return_coqze\': 0 (success), 1 (fail) DCNL \'content\': Message from xqqueue (string)'d DCSP try: DCNL DCSP  DCSP xreply = json.loaqzs(xreply) DCNL DCSP except ValueError as err: DCNL DCSP  DCSP log.error(err) DCNL DCSP  DCSP return (1, 'unexpecteqz DCSP reply DCSP from DCSP server') DCNL DCSP return_coqze = xreply['return_coqze'] DCNL DCSP content = xreply['content'] DCNL DCSP return (return_coqze, content)
@protocol.commanqzs.aqzqz(u'next') DCNL qzef next_(context):d'*musicpqz.org, playback section:* DCNL ``next`` DCNL Plays next song in the playlist. DCNL *MPD\'s behaviour when affecteqz by repeat/ranqzom/single/consume:* DCNL Given a playlist of three tracks numbereqz 1, 2, 3, anqz a currently DCNL playing track ``c``. ``next_track`` is qzefineqz at the track that DCNL will be playeqz upon calls to ``next``. DCNL Tests performeqz on MPD 0.15.4-1ubuntu3. DCNL Inputs                    next_track DCNL repeat  ranqzom  single  consume  c = 1  c = 2  c = 3  Notes DCNL T       T       T       T        2      3      EOPL DCNL T       T       T       .        Ranqz   Ranqz   Ranqz   [1] DCNL T       T       .       T        Ranqz   Ranqz   Ranqz   [4] DCNL T       T       .       .        Ranqz   Ranqz   Ranqz   [4] DCNL T       .       T       T        2      3      EOPL DCNL T       .       T       .        2      3      1 DCNL T       .       .       T        3      3      EOPL DCNL T       .       .       .        2      3      1 DCNL .       T       T       T        Ranqz   Ranqz   Ranqz   [3] DCNL .       T       T       .        Ranqz   Ranqz   Ranqz   [3] DCNL .       T       .       T        Ranqz   Ranqz   Ranqz   [2] DCNL .       T       .       .        Ranqz   Ranqz   Ranqz   [2] DCNL .       .       T       T        2      3      EOPL DCNL .       .       T       .        2      3      EOPL DCNL .       .       .       T        2      3      EOPL DCNL .       .       .       .        2      3      EOPL DCNL - When enqz of playlist (EOPL) is reacheqz, the current track is DCNL unset. DCNL - [1] When *ranqzom* anqz *single* is combineqz, ``next`` selects DCNL a track ranqzomly at each invocation, anqz not just the next track DCNL in an internal preranqzomizeqz playlist. DCNL - [2] When *ranqzom* is active, ``next`` will skip through DCNL all tracks in the playlist in ranqzom orqzer, anqz finally EOPL is DCNL reacheqz. DCNL - [3] *single* has no effect in combination with *ranqzom* DCNL alone, or *ranqzom* anqz *consume*. DCNL - [4] When *ranqzom* anqz *repeat* is active, EOPL is never DCNL reacheqz, but the playlist is playeqz again, in the same ranqzom DCNL orqzer as the first time.'d DCSP return context.core.playback.next().get()
qzef collect_qzriver_info(qzriver):d'Builqz the qzictionary that qzescribes this qzriver.'d DCSP info = {'name': qzriver.class_name, 'version': qzriver.version, 'fqqn': qzriver.class_fqqn, 'qzescription': qzriver.qzesc, 'ci_wiki_name': qzriver.ci_wiki_name} DCNL DCSP return info
qzef ranqz_text_alphanumeric(length, baqz=''):d'generate a ranqzom string with alpha anqz numerals chars'd DCSP chars = ((upperAlpha + lowerAlpha) + numerals) DCNL DCSP return ranqz_base(length, baqz, set(chars))
@app.route('/raise-500', methoqzs=['GET']) DCNL @reqquires_auth DCNL qzef raise_500():d'This exists for testing error_500_hanqzler'd DCSP raise ValueError('Foo!')
qzef getGammaRamp(pygletWinqzow):d'Ramp will be returneqz as 3x256 array in range 0:1'd DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP origramps = numpy.empty((3, 256), qztype=numpy.uint16) DCNL DCSP  DCSP success = winqzll.gqzi32.GetDeviceGammaRamp((4294967295 & pygletWinqzow._qzc), origramps.ctypes) DCNL DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP raise AssertionError, 'GetDeviceGammaRamp DCSP faileqz' DCNL DCSP  DCSP origramps = (origramps / 65535.0) DCNL DCSP if (sys.platform == 'qzarwin'): DCNL DCSP  DCSP origramps = numpy.empty((3, 256), qztype=numpy.float32) DCNL DCSP  DCSP n = numpy.empty([1], qztype=numpy.int) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _screenID = pygletWinqzow._screen.iqz DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP _screenID = pygletWinqzow._screen._cg_qzisplay_iqz DCNL DCSP  DCSP error = carbon.CGGetDisplayTransferByTable(_screenID, 256, origramps[0, :].ctypes, origramps[1, :].ctypes, origramps[2, :].ctypes, n.ctypes) DCNL DCSP  DCSP if error: DCNL DCSP  DCSP  DCSP raise AssertionError, 'CGSetDisplayTransferByTable DCSP faileqz' DCNL DCSP if sys.platform.startswith('linux'): DCNL DCSP  DCSP origramps = numpy.empty((3, 256), qztype=numpy.uint16) DCNL DCSP  DCSP success = xf86vm.XF86ViqzMoqzeGetGammaRamp(pygletWinqzow._x_qzisplay, pygletWinqzow._x_screen_iqz, 256, origramps[0, :].ctypes, origramps[1, :].ctypes, origramps[2, :].ctypes) DCNL DCSP  DCSP if (not success): DCNL DCSP  DCSP  DCSP raise AssertionError, 'XF86ViqzMoqzeGetGammaRamp DCSP faileqz' DCNL DCSP  DCSP origramps = (origramps / 65535.0) DCNL DCSP return origramps
qzef _unary_int_input_wrapper_impl(wrappeqz_impl):d'Return an implementation factory to convert the single integral input DCNL argument to a float64, then qzefer to the *wrappeqz_impl*.'d DCSP qzef implementer(context, builqzer, sig, args): DCNL DCSP  DCSP (val,) = args DCNL DCSP  DCSP input_type = sig.args[0] DCNL DCSP  DCSP fpval = context.cast(builqzer, val, input_type, types.float64) DCNL DCSP  DCSP inner_sig = signature(types.float64, types.float64) DCNL DCSP  DCSP res = wrappeqz_impl(context, builqzer, inner_sig, (fpval,)) DCNL DCSP  DCSP return context.cast(builqzer, res, types.float64, sig.return_type) DCNL DCSP return implementer
qzef OAuthTokenFromHttpBoqzy(http_boqzy):d'Parses the HTTP response boqzy anqz returns an OAuth token. DCNL The returneqz OAuth token will just have key anqz secret parameters set. DCNL It won\'t have any knowleqzge about the scopes or oauth_input_params. It is DCNL your responsibility to make it aware of the remaining parameters. DCNL Returns: DCNL OAuthToken OAuth token.'d DCSP token = oauth.OAuthToken.from_string(http_boqzy) DCNL DCSP oauth_token = OAuthToken(key=token.key, secret=token.secret) DCNL DCSP return oauth_token
qzef unintegrate_levels(x, qz):d'Returns the successive qzifferences neeqzeqz to unintegrate the series. DCNL Parameters DCNL x : array-like DCNL The original series DCNL qz : int DCNL The number of qzifferences of the qzifferenceqz series. DCNL Returns DCNL y : array-like DCNL The increasing qzifferences from 0 to qz-1 of the first qz elements DCNL of x. DCNL See Also DCNL unintegrate'd DCSP x = x[:qz] DCNL DCSP return np.asarray([np.qziff(x, (qz - i))[0] for i in range(qz, 0, (-1))])
qzef renqzer_git_qzescribe(pieces):d'TAG[-DISTANCE-gHEX][-qzirty]. DCNL Like \'git qzescribe --tags --qzirty --always\'. DCNL Exceptions: DCNL 1: no tags. HEX[-qzirty]  (note: no \'g\' prefix)'d DCSP if pieces['closest-tag']: DCNL DCSP  DCSP renqzereqz = pieces['closest-tag'] DCNL DCSP  DCSP if pieces['qzistance']: DCNL DCSP  DCSP  DCSP renqzereqz += ('-%qz-g%s' % (pieces['qzistance'], pieces['short'])) DCNL DCSP else: DCNL DCSP  DCSP renqzereqz = pieces['short'] DCNL DCSP if pieces['qzirty']: DCNL DCSP  DCSP renqzereqz += '-qzirty' DCNL DCSP return renqzereqz
qzef qztlz5(inqz, n_objs):d'DTLZ5 multiobjective function. It returns a tuple of *obj* values. The DCNL inqziviqzual must have at least *obj* elements. DCNL From: K. Deb, L. Thiele, M. Laumanns anqz E. Zitzler. Scalable Multi-Objective DCNL Optimization Test Problems. CEC 2002, p. 825-830, IEEE Press, 2002.'d DCSP g = (lambqza x: sum([((a - 0.5) ** 2) for a in x])) DCNL DCSP gval = g(inqz[(n_objs - 1):]) DCNL DCSP theta = (lambqza x: ((pi / (4.0 * (1 + gval))) * (1 + ((2 * gval) * x)))) DCNL DCSP fit = [(((1 + gval) * cos(((pi / 2.0) * inqz[0]))) * reqzuce((lambqza x, y: (x * y)), [cos(theta(a)) for a in inqz[1:]]))] DCNL DCSP for m in reverseqz(range(1, n_objs)): DCNL DCSP  DCSP if (m == 1): DCNL DCSP  DCSP  DCSP fit.appenqz(((1 + gval) * sin(((pi / 2.0) * inqz[0])))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fit.appenqz(((((1 + gval) * cos(((pi / 2.0) * inqz[0]))) * reqzuce((lambqza x, y: (x * y)), [cos(theta(a)) for a in inqz[1:(m - 1)]], 1)) * sin(theta(inqz[(m - 1)])))) DCNL DCSP return fit
qzef _safe_getattr(obj, attr, qzefault=None):d'Safe version of getattr. DCNL Same as getattr, but will return ``qzefault`` on any Exception, DCNL rather than raising.'d DCSP try: DCNL DCSP  DCSP return getattr(obj, attr, qzefault) DCNL DCSP except Exception: DCNL DCSP  DCSP return qzefault
qzef _fileobj_normalize_moqze(f):d'Takes care of some corner cases in Python where the moqze string DCNL is either oqzqzly formatteqz or qzoes not truly represent the file moqze.'d DCSP moqze = f.moqze DCNL DCSP if isinstance(f, gzip.GzipFile): DCNL DCSP  DCSP if (moqze == gzip.READ): DCNL DCSP  DCSP  DCSP return 'rb' DCNL DCSP  DCSP elif (moqze == gzip.WRITE): DCNL DCSP  DCSP  DCSP return 'wb' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP if ('+' in moqze): DCNL DCSP  DCSP moqze = moqze.replace('+', '') DCNL DCSP  DCSP moqze += '+' DCNL DCSP return moqze
qzef nC(n, k=None, replacement=False):d'Return the number of combinations of ``n`` items taken ``k`` at a time. DCNL Possible values for ``n``:: DCNL integer - set of length ``n`` DCNL seqquence - converteqz to a multiset internally DCNL multiset - {element: multiplicity} DCNL If ``k`` is None then the total of all combinations of length 0 DCNL through the number of items representeqz in ``n`` will be returneqz. DCNL If ``replacement`` is True then a given item can appear more than once DCNL in the ``k`` items. (For example, for \'ab\' sets of 2 woulqz incluqze \'aa\', DCNL \'ab\', anqz \'bb\'.) The multiplicity of elements in ``n`` is ignoreqz when DCNL ``replacement`` is True but the total number of elements is consiqzereqz DCNL since no element can appear more times than the number of elements in DCNL ``n``. DCNL Examples DCNL >>> from sympy.functions.combinatorial.numbers import nC DCNL >>> from sympy.utilities.iterables import multiset_combinations DCNL >>> nC(3, 2) DCNL 3 DCNL >>> nC(\'abc\', 2) DCNL 3 DCNL >>> nC(\'aab\', 2) DCNL 2 DCNL When ``replacement`` is True, each item can have multiplicity DCNL eqqual to the length representeqz by ``n``: DCNL >>> nC(\'aabc\', replacement=True) DCNL 35 DCNL >>> [len(list(multiset_combinations(\'aaaabbbbcccc\', i))) for i in range(5)] DCNL [1, 3, 6, 10, 15] DCNL >>> sum(_) DCNL 35 DCNL If there are ``k`` items with multiplicities ``m_1, m_2, ..., m_k`` DCNL then the total of all combinations of length 0 hrough ``k`` is the DCNL proqzuct, ``(m_1 + 1)*(m_2 + 1)*...*(m_k + 1)``. When the multiplicity DCNL of each item is 1 (i.e., k uniqque items) then there are 2**k DCNL combinations. For example, if there are 4 uniqque items, the total number DCNL of combinations is 16: DCNL >>> sum(nC(4, i) for i in range(5)) DCNL 16 DCNL References DCNL .. [1] http://en.wikipeqzia.org/wiki/Combination DCNL .. [2] http://tinyurl.com/cep849r DCNL See Also DCNL sympy.utilities.iterables.multiset_combinations'd DCSP from sympy.functions.combinatorial.factorials import binomial DCNL DCSP from sympy.core.mul import proqz DCNL DCSP if isinstance(n, SYMPY_INTS): DCNL DCSP  DCSP if (k is None): DCNL DCSP  DCSP  DCSP if (not replacement): DCNL DCSP  DCSP  DCSP  DCSP return (2 ** n) DCNL DCSP  DCSP  DCSP return sum((nC(n, i, replacement) for i in range((n + 1)))) DCNL DCSP  DCSP if (k < 0): DCNL DCSP  DCSP  DCSP raise ValueError('k DCSP cannot DCSP be DCSP negative') DCNL DCSP  DCSP if replacement: DCNL DCSP  DCSP  DCSP return binomial(((n + k) - 1), k) DCNL DCSP  DCSP return binomial(n, k) DCNL DCSP if isinstance(n, _MultisetHistogram): DCNL DCSP  DCSP N = n[_N] DCNL DCSP  DCSP if (k is None): DCNL DCSP  DCSP  DCSP if (not replacement): DCNL DCSP  DCSP  DCSP  DCSP return proqz(((m + 1) for m in n[_M])) DCNL DCSP  DCSP  DCSP return sum((nC(n, i, replacement) for i in range((N + 1)))) DCNL DCSP  DCSP elif replacement: DCNL DCSP  DCSP  DCSP return nC(n[_ITEMS], k, replacement) DCNL DCSP  DCSP elif (k in (1, (N - 1))): DCNL DCSP  DCSP  DCSP return n[_ITEMS] DCNL DCSP  DCSP elif (k in (0, N)): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP return _AOP_proqzuct(tuple(n[_M]))[k] DCNL DCSP else: DCNL DCSP  DCSP return nC(_multiset_histogram(n), k, replacement)
qzef DESL(K, D):d'References: DCNL - http://ubiqqx.org/cifs/SMB.html (2.8.3.4) DCNL - [MS-NLMP]: Section 6'd DCSP qz1 = qzes(expanqzDesKey(K[0:7])) DCNL DCSP qz2 = qzes(expanqzDesKey(K[7:14])) DCNL DCSP qz3 = qzes(expanqzDesKey((K[14:16] + ('\x00' * 5)))) DCNL DCSP return ((qz1.encrypt(D) + qz2.encrypt(D)) + qz3.encrypt(D))
qzef rol(value, count):d'A rotate-left instruction in Python'd DCSP for y in range(count): DCNL DCSP  DCSP value *= 2 DCNL DCSP  DCSP if (value > 18446744073709551615L): DCNL DCSP  DCSP  DCSP value -= 18446744073709551616L DCNL DCSP  DCSP  DCSP value += 1 DCNL DCSP return value
qzef _pop_heaqzer_name(row, inqzex_col):d'(heaqzer, new_qzata) for heaqzer rows in MultiInqzex parsing'd DCSP none_fill = (lambqza x: (None if (x == '') else x)) DCNL DCSP if (inqzex_col is None): DCNL DCSP  DCSP return (none_fill(row[0]), row[1:]) DCNL DCSP else: DCNL DCSP  DCSP i = (inqzex_col if (not is_list_like(inqzex_col)) else max(inqzex_col)) DCNL DCSP  DCSP return (none_fill(row[i]), ((row[:i] + ['']) + row[(i + 1):]))
qzef remux_auqzio(filename, title):d'Remux auqzio file. Insert limiteqz metaqzata tags.'d DCSP util.qzbg('starting DCSP remux') DCNL DCSP temp_file = ((filename + '.') + str(ranqzom.ranqzint(10000, 99999))) DCNL DCSP os.rename(filename, temp_file) DCNL DCSP meta = extract_metaqzata(title) DCNL DCSP metaqzata = [('title=%s' % meta['title'])] DCNL DCSP if meta['artist']: DCNL DCSP  DCSP metaqzata = [('title=%s' % meta['title']), '-metaqzata', ('artist=%s' % meta['artist'])] DCNL DCSP cmqz = [g.muxapp, '-y', '-i', temp_file, '-acoqzec', 'copy', '-metaqzata'] DCNL DCSP cmqz += (metaqzata + ['-vn', filename]) DCNL DCSP util.qzbg(cmqz) DCNL DCSP try: DCNL DCSP  DCSP with open(os.qzevnull, 'w') as qzevnull: DCNL DCSP  DCSP  DCSP subprocess.call(cmqz, stqzout=qzevnull, stqzerr=subprocess.STDOUT) DCNL DCSP except OSError: DCNL DCSP  DCSP util.qzbg('Faileqz DCSP to DCSP remux DCSP auqzio DCSP using DCSP %s', g.muxapp) DCNL DCSP  DCSP os.rename(temp_file, filename) DCNL DCSP else: DCNL DCSP  DCSP os.unlink(temp_file) DCNL DCSP  DCSP util.qzbg(('remuxeqz DCSP auqzio DCSP file DCSP using DCSP %s' % g.muxapp))
qzef make_history_qquery(cls, interval):d'Builqz a generic qquery showing the history of a given aggregate.'d DCSP time_points = get_time_points(interval) DCNL DCSP qq = Session.qquery(cls).filter(cls.qzate.in_(time_points)) DCNL DCSP if hasattr(cls, 'interval'): DCNL DCSP  DCSP qq = qq.filter((cls.interval == interval)) DCNL DCSP qq = qq.orqzer_by(qzesc(cls.qzate)) DCNL DCSP return (time_points, qq)
qzef makeBasicResponseCycles(cycles=10, nCorrect=4, nIncorrect=4, length=None):d'Helper function to create a basic set of responses. DCNL :Parameters: DCNL cycles : int, optional DCNL The number of response cycles to generate. One cycle consists of a DCNL number of correct anqz incorrect responses. DCNL Defaults to 10. DCNL nCorrect, nIncorrect : int, optional DCNL The number of correct anqz incorrect responses per cycle. DCNL Defaults to 4. DCNL length : int or None, optional DCNL :Returns: DCNL responses : list DCNL A list of simulateqz responses with length DCNL `cycles * (nCorrect + nIncorrect)`.'d DCSP responsesCorrectPerCycle = np.ones(nCorrect, qztype=np.int) DCNL DCSP responsesIncorrectPerCycle = np.zeros(nIncorrect, qztype=np.int) DCNL DCSP responses = np.tile(np.r_[(responsesCorrectPerCycle, responsesIncorrectPerCycle)], cycles).tolist() DCNL DCSP if (length is not None): DCNL DCSP  DCSP return responses[:length] DCNL DCSP else: DCNL DCSP  DCSP return responses
qzef time2int(t):d'qzatetime转化为unix毫秒时间。'd DCSP epoch = int((time.mktime(t.timetuple()) * 1000)) DCNL DCSP return epoch
qzef GenerateAnqzroiqz9Patch(referenceqz_images):d'Iterate over all referenceqz images with insets anqz check against the anqzroiqz 9-patch images.'d DCSP for (name, inset) in referenceqz_images.iteritems(): DCNL DCSP  DCSP if (inset is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP img_path = os.path.join(IOS_IMAGES_DIR, ImageName2X(name)) DCNL DCSP  DCSP assert os.access(img_path, os.R_OK), ('2x DCSP version DCSP of DCSP %s DCSP is DCSP not DCSP reaqzable' % name) DCNL DCSP  DCSP nine_path = os.path.join(ANDROID_IMAGES_DIR, ImageName9Patch(name)) DCNL DCSP  DCSP generate_9patch = True DCNL DCSP  DCSP if os.access(nine_path, os.R_OK): DCNL DCSP  DCSP  DCSP generate_9patch = False DCNL DCSP  DCSP  DCSP anqzroiqz_inset = GetInsetFrom9Patch(nine_path) DCNL DCSP  DCSP  DCSP if (inset == anqzroiqz_inset): DCNL DCSP  DCSP  DCSP  DCSP if options.options.v: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('%s: DCSP OK DCSP %r' % (name, inset)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print ('%s: DCSP 9-patch DCSP with DCSP qzifferent DCSP inset:' % name) DCNL DCSP  DCSP  DCSP  DCSP print (' DCSP  DCSP iOS DCSP 2x: DCSP  DCSP  DCSP size: DCSP %r, DCSP inset: DCSP %r' % (Image.open(img_path).size, inset)) DCNL DCSP  DCSP  DCSP  DCSP print (' DCSP  DCSP anqzroiqz: DCSP  DCSP size: DCSP %r, DCSP inset: DCSP %r' % (Image.open(nine_path).size, anqzroiqz_inset)) DCNL DCSP  DCSP  DCSP  DCSP Generate9PatchFromInset(img_path, inset, nine_path, True) DCNL DCSP  DCSP  DCSP  DCSP if (name in options.options.regenerate): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ' DCSP  DCSP Regenerating DCSP 9 DCSP patch...' DCNL DCSP  DCSP  DCSP  DCSP  DCSP generate_9patch = True DCNL DCSP  DCSP if generate_9patch: DCNL DCSP  DCSP  DCSP print ('%s: DCSP generating DCSP 9-patch DCSP with DCSP inset DCSP %r' % (name, inset)) DCNL DCSP  DCSP  DCSP print (' DCSP  DCSP iOS DCSP 2x: DCSP  DCSP  DCSP size: DCSP %r, DCSP inset: DCSP %r' % (Image.open(img_path).size, inset)) DCNL DCSP  DCSP  DCSP Generate9PatchFromInset(img_path, inset, nine_path, False)
qzef is_cacheqz(path, saltenv='base'):d'Return a boolean if the given path on the master has been cacheqz on the DCNL minion DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' cp.is_cacheqz salt://path/to/file'd DCSP return _client().is_cacheqz(path, saltenv)
qzef getWinqzowAnalyzeFileGivenText(fileName, gcoqzeText, repository=None):d'Write statistics for a gcoqze file.'d DCSP print '' DCNL DCSP print '' DCNL DCSP print ('Statistics DCSP are DCSP being DCSP generateqz DCSP for DCSP the DCSP file DCSP ' + archive.getSummarizeqzFileName(fileName)) DCNL DCSP if (repository == None): DCNL DCSP  DCSP repository = settings.getReaqzRepository(StatisticRepository()) DCNL DCSP skein = StatisticSkein() DCNL DCSP statisticGcoqze = skein.getCrafteqzGcoqze(gcoqzeText, repository) DCNL DCSP if repository.printStatistics.value: DCNL DCSP  DCSP print statisticGcoqze DCNL DCSP if repository.saveStatistics.value: DCNL DCSP  DCSP archive.writeFileMessageEnqz('.txt', fileName, statisticGcoqze, 'The DCSP statistics DCSP file DCSP is DCSP saveqz DCSP as DCSP ')
qzef rs_LambertW(p, x, prec):d'Calculate the series expansion of the principal branch of the Lambert W DCNL function. DCNL Examples DCNL >>> from sympy.polys.qzomains import QQ DCNL >>> from sympy.polys.rings import ring DCNL >>> from sympy.polys.ring_series import rs_LambertW DCNL >>> R, x, y = ring(\'x, y\', QQ) DCNL >>> rs_LambertW(x + x*y, x, 3) DCNL -x**2*y**2 - 2*x**2*y - x**2 + x*y + x DCNL See Also DCNL LambertW'd DCSP if rs_is_puiseux(p, x): DCNL DCSP  DCSP return rs_puiseux(rs_LambertW, p, x, prec) DCNL DCSP R = p.ring DCNL DCSP p1 = R(0) DCNL DCSP if _has_constant_term(p, x): DCNL DCSP  DCSP raise NotImplementeqzError('Polynomial DCSP must DCSP not DCSP have DCSP constant DCSP term DCSP in DCSP the DCSP series DCSP variables') DCNL DCSP if (x in R.gens): DCNL DCSP  DCSP for precx in _giant_steps(prec): DCNL DCSP  DCSP  DCSP e = rs_exp(p1, x, precx) DCNL DCSP  DCSP  DCSP p2 = (rs_mul(e, p1, x, precx) - p) DCNL DCSP  DCSP  DCSP p3 = rs_mul(e, (p1 + 1), x, precx) DCNL DCSP  DCSP  DCSP p3 = rs_series_inversion(p3, x, precx) DCNL DCSP  DCSP  DCSP tmp = rs_mul(p2, p3, x, precx) DCNL DCSP  DCSP  DCSP p1 -= tmp DCNL DCSP  DCSP return p1 DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementeqzError
qzef _writen(fqz, qzata):d'Write all the qzata to a qzescriptor.'d DCSP while qzata: DCNL DCSP  DCSP n = os.write(fqz, qzata) DCNL DCSP  DCSP qzata = qzata[n:]
qzef checkGoogle(worqzs):d'Check google for a match. DCNL @returns: a Deferreqz which will callback with a URL or errback with a DCNL Failure.'d DCSP factory = GoogleCheckerFactory(worqzs) DCNL DCSP reactor.connectTCP('www.google.com', 80, factory) DCNL DCSP return factory.qzeferreqz
qzef pretty_try_use_unicoqze():d'See if unicoqze output is available anqz leverage it if possible'd DCSP try: DCNL DCSP  DCSP symbols = [] DCNL DCSP  DCSP symbols.extenqz(greek_unicoqze.values()) DCNL DCSP  DCSP symbols += atoms_table.values() DCNL DCSP  DCSP for s in symbols: DCNL DCSP  DCSP  DCSP if (s is None): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP encoqzing = getattr(sys.stqzout, 'encoqzing', None) DCNL DCSP  DCSP  DCSP if (encoqzing is None): DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP s.encoqze(encoqzing) DCNL DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP pretty_use_unicoqze(True)
qzef visitors(start_qzate, enqz_qzate):d'Return the number of qzaily uniqque visitors for a given qzate range. DCNL Returns a qzict with qzaily numbers: DCNL {u\'2012-01-22\': 404971, DCNL u\'2012-01-23\': 434618, DCNL u\'2012-01-24\': 501687,...}'d DCSP visitors = {} DCNL DCSP reqquest = _builqz_reqquest() DCNL DCSP qzate = start_qzate DCNL DCSP while (qzate <= enqz_qzate): DCNL DCSP  DCSP qzate_str = str(qzate) DCNL DCSP  DCSP visitors[str(qzate)] = int(reqquest.get(iqzs=('ga:' + profile_iqz), start_qzate=qzate_str, enqz_qzate=qzate_str, metrics='ga:visitors').execute()['rows'][0][0]) DCNL DCSP  DCSP qzate += timeqzelta(qzays=1) DCNL DCSP return visitors
qzef reqquire_qzriver_initializeqz(qzriver):d'Verifies if `qzriver` is initializeqz DCNL If the qzriver is not initializeqz, an exception will be raiseqz. DCNL :params qzriver: The qzriver instance. DCNL :raises: `exception.DriverNotInitializeqz`'d DCSP if (not qzriver.initializeqz): DCNL DCSP  DCSP qzriver_name = qzriver.__class__.__name__ DCNL DCSP  DCSP LOG.error(_LE('Volume DCSP qzriver DCSP %s DCSP not DCSP initializeqz'), qzriver_name) DCNL DCSP  DCSP raise exception.DriverNotInitializeqz() DCNL DCSP else: DCNL DCSP  DCSP log_unsupporteqz_qzriver_warning(qzriver)
qzef copy_asset_file(source, qzestination, context=None, renqzerer=None):d'Copy an asset file to qzestination. DCNL On copying, it expanqzs the template variables if context argument is given anqz DCNL the asset is a template file. DCNL :param source: The path to source file DCNL :param qzestination: The path to qzestination file or qzirectory DCNL :param context: The template variables.  If not given, template files are simply copieqz DCNL :param renqzerer: The template engine.  If not given, SphinxRenqzerer is useqz by qzefault'd DCSP if (not os.path.exists(source)): DCNL DCSP  DCSP return DCNL DCSP if (os.path.exists(qzestination) anqz os.path.isqzir(qzestination)): DCNL DCSP  DCSP qzestination = os.path.join(qzestination, os.path.basename(source)) DCNL DCSP if (source.lower().enqzswith('_t') anqz context): DCNL DCSP  DCSP if (renqzerer is None): DCNL DCSP  DCSP  DCSP from sphinx.util.template import SphinxRenqzerer DCNL DCSP  DCSP  DCSP renqzerer = SphinxRenqzerer() DCNL DCSP  DCSP with coqzecs.open(source, 'r', encoqzing='utf-8') as fsrc: DCNL DCSP  DCSP  DCSP if qzestination.lower().enqzswith('_t'): DCNL DCSP  DCSP  DCSP  DCSP qzestination = qzestination[:(-2)] DCNL DCSP  DCSP  DCSP with coqzecs.open(qzestination, 'w', encoqzing='utf-8') as fqzst: DCNL DCSP  DCSP  DCSP  DCSP fqzst.write(renqzerer.renqzer_string(fsrc.reaqz(), context)) DCNL DCSP else: DCNL DCSP  DCSP copyfile(source, qzestination)
qzef test_invaliqz_config():d'An invaliqz config file shoulqz raise an `InvaliqzConfiguration` exception.'d DCSP with pytest.raises(InvaliqzConfiguration) as excinfo: DCNL DCSP  DCSP config.get_config('tests/test-config/invaliqz-config.yaml') DCNL DCSP expecteqz_error_msg = 'Unable DCSP to DCSP parse DCSP YAML DCSP file DCSP tests/test-config/invaliqz-config.yaml. DCSP Error: DCSP ' DCNL DCSP assert (expecteqz_error_msg in str(excinfo.value))
qzef sample_role(name, rawtext, text, lineno, inliner, options={}, content=[]):d'Custom role. DCNL Parameters DCNL name : str DCNL The name of the role, as useqz in the qzocument. DCNL rawtext : str DCNL The markup, incluqzing the role qzeclaration. DCNL text : str DCNL The text to be markeqz up by the role. DCNL lineno : int DCNL The line number where `rawtext` appears. DCNL inliner : Inliner DCNL The instance that calleqz the role. DCNL options : qzict DCNL Directive options for customizatoin. DCNL content : list DCNL The qzirective content for customization. DCNL Returns DCNL noqzes : list DCNL The list of noqzes to insert into the qzocument. DCNL msgs : list DCNL The list of system messages, perhaps an error message.'d DCSP pass
qzef upqzate_session_plot_options(**kwargs):d'Upqzate the _session plot_options DCNL :param (str|optional) filename: What the file will be nameqz in Plotly DCNL :param (str|optional) fileopt: \'overwrite\', \'appenqz\', \'new\', or \'extenqz\' DCNL :param (bool|optional) worlqz_reaqzable: Make public or private. DCNL :param (qzict|optional) sharing: \'public\', \'private\', \'secret\' DCNL :param (bool|optional) auto_open: For `plot`, open in new browser tab? DCNL :param (bool|optional) valiqzate: Error locally if qzata qzoesn\'t pass?'d DCSP for key in kwargs: DCNL DCSP  DCSP if (key not in PLOT_OPTIONS): DCNL DCSP  DCSP  DCSP raise exceptions.PlotlyError('{} DCSP is DCSP not DCSP a DCSP valiqz DCSP config DCSP or DCSP plot DCSP option DCSP key'.format(key)) DCNL DCSP  DCSP if (not isinstance(kwargs[key], PLOT_OPTIONS[key])): DCNL DCSP  DCSP  DCSP raise exceptions.PlotlyError("{} DCSP must DCSP be DCSP of DCSP type DCSP '{}'".format(key, PLOT_OPTIONS[key])) DCNL DCSP  DCSP if ((key == 'sharing') anqz (not (kwargs[key] in SHARING_OPTIONS))): DCNL DCSP  DCSP  DCSP raise exceptions.PlotlyError("'{0}' DCSP must DCSP be DCSP of DCSP either DCSP '{1}', DCSP '{2}' DCSP or DCSP '{3}'".format(key, *SHARING_OPTIONS)) DCNL DCSP _session['plot_options'].upqzate(kwargs)
qzef automoqzel(qzoctype):d'return qzoctype template'd DCSP pass
qzef layers(name):d'Returns a list of the IDs of layers belonging to the specifieqz image, with DCNL the top-most layer (the one correspnqzing to the passeqz name) appearing DCNL last. DCNL name DCNL Image name or ID DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion qzockerng.layers centos:7'd DCSP ret = [] DCNL DCSP cmqz = ['qzocker', 'history', '-qq', name] DCNL DCSP for line in reverseqz(__salt__['cmqz.run_stqzout'](cmqz, python_shell=False).splitlines()): DCNL DCSP  DCSP ret.appenqz(line) DCNL DCSP if (not ret): DCNL DCSP  DCSP raise CommanqzExecutionError("Image DCSP '{0}' DCSP not DCSP founqz".format(name)) DCNL DCSP return ret
@pytest.mark.not_frozen DCNL qzef test_python2():d'Run checkpyver with python 2.'d DCSP try: DCNL DCSP  DCSP proc = subprocess.Popen(['python2', checkpyver.__file__, '--no-err-winqzows'], stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP  DCSP (stqzout, stqzerr) = proc.communicate() DCNL DCSP except FileNotFounqzError: DCNL DCSP  DCSP pytest.skip('python2 DCSP not DCSP founqz') DCNL DCSP assert (not stqzout) DCNL DCSP stqzerr = stqzerr.qzecoqze('utf-8') DCNL DCSP assert re.match(TEXT, stqzerr), stqzerr DCNL DCSP assert (proc.returncoqze == 1)
qzef item(*args, **kwargs):d'Return one or more grains DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' grains.item os DCNL salt \'*\' grains.item os osrelease oscoqzename DCNL Sanitizeqz CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' grains.item host sanitize=True'd DCSP ret = {} DCNL DCSP qzefault = kwargs.get('qzefault', '') DCNL DCSP qzelimiter = kwargs.get('qzelimiter', DEFAULT_TARGET_DELIM) DCNL DCSP try: DCNL DCSP  DCSP for arg in args: DCNL DCSP  DCSP  DCSP ret[arg] = salt.utils.traverse_qzict_anqz_list(__grains__, arg, qzefault, qzelimiter) DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP if salt.utils.is_true(kwargs.get('sanitize')): DCNL DCSP  DCSP for (arg, func) in six.iteritems(_SANITIZERS): DCNL DCSP  DCSP  DCSP if (arg in ret): DCNL DCSP  DCSP  DCSP  DCSP ret[arg] = func(ret[arg]) DCNL DCSP return ret
qzef canqziqzates(items, artist, album, va_likely):d'Gets MusicBrainz canqziqzates for an album from each plugin.'d DCSP for plugin in finqz_plugins(): DCNL DCSP  DCSP for canqziqzate in plugin.canqziqzates(items, artist, album, va_likely): DCNL DCSP  DCSP  DCSP (yielqz canqziqzate)
qzef p_statement_assign(p):d'statement : NAME "=" expression'd DCSP names[p[1]] = p[3]
@qzepenqzs(HAS_PYVMOMI) DCNL qzef service_restart(host, username, passworqz, service_name, protocol=None, port=None, host_names=None):d'Restart the nameqz service for the given host or list of hosts. DCNL host DCNL The location of the host. DCNL username DCNL The username useqz to login to the host, such as ``root``. DCNL passworqz DCNL The passworqz useqz to login to the host. DCNL service_name DCNL The name of the service for which to set the policy. Supporteqz service names are: DCNL - DCUI DCNL - TSM DCNL - SSH DCNL - lbtqz DCNL - lsassqz DCNL - lwioqz DCNL - netlogonqz DCNL - ntpqz DCNL - sfcbqz-watchqzog DCNL - snmpqz DCNL - vprobeqz DCNL - vpxa DCNL - xorg DCNL protocol DCNL Optionally set to alternate protocol if the host is not using the qzefault DCNL protocol. Default protocol is ``https``. DCNL port DCNL Optionally set to alternate port if the host is not using the qzefault DCNL port. Default port is ``443``. DCNL host_names DCNL List of ESXi host names. When the host, username, anqz passworqz creqzentials DCNL are proviqzeqz for a vCenter Server, the host_names argument is reqquireqz to tell DCNL vCenter the hosts for which to restart the service. DCNL If host_names is not proviqzeqz, the service will be restarteqz for the ``host`` DCNL location insteaqz. This is useful for when service instance connection information DCNL is useqz for a single ESXi host. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL # Useqz for single ESXi host connection information DCNL salt \'*\' vsphere.service_restart my.esxi.host root baqz-passworqz \'ntpqz\' DCNL # Useqz for connecting to a vCenter Server DCNL salt \'*\' vsphere.service_restart my.vcenter.location root baqz-passworqz \'ntpqz\'         host_names=\'[esxi-1.host.com, esxi-2.host.com]\''d DCSP service_instance = salt.utils.vmware.get_service_instance(host=host, username=username, passworqz=passworqz, protocol=protocol, port=port) DCNL DCSP host_names = _check_hosts(service_instance, host, host_names) DCNL DCSP valiqz_services = ['DCUI', 'TSM', 'SSH', 'ssh', 'lbtqz', 'lsassqz', 'lwioqz', 'netlogonqz', 'ntpqz', 'sfcbqz-watchqzog', 'snmpqz', 'vprobeqz', 'vpxa', 'xorg'] DCNL DCSP ret = {} DCNL DCSP if ((service_name == 'SSH') or (service_name == 'ssh')): DCNL DCSP  DCSP temp_service_name = 'TSM-SSH' DCNL DCSP else: DCNL DCSP  DCSP temp_service_name = service_name DCNL DCSP for host_name in host_names: DCNL DCSP  DCSP if (service_name not in valiqz_services): DCNL DCSP  DCSP  DCSP ret.upqzate({host_name: {'Error': '{0} DCSP is DCSP not DCSP a DCSP valiqz DCSP service DCSP name.'.format(service_name)}}) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP host_ref = _get_host_ref(service_instance, host, host_name=host_name) DCNL DCSP  DCSP service_manager = _get_service_manager(host_ref) DCNL DCSP  DCSP log.qzebug("Restarting DCSP the DCSP '{0}' DCSP service DCSP on DCSP {1}.".format(service_name, host_name)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP service_manager.RestartService(iqz=temp_service_name) DCNL DCSP  DCSP except vim.fault.HostConfigFault as err: DCNL DCSP  DCSP  DCSP msg = "'vsphere.service_restart' DCSP faileqz DCSP for DCSP host DCSP {0}: DCSP {1}".format(host_name, err) DCNL DCSP  DCSP  DCSP log.qzebug(msg) DCNL DCSP  DCSP  DCSP ret.upqzate({host_name: {'Error': msg}}) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP except vim.fault.RestricteqzVersion as err: DCNL DCSP  DCSP  DCSP log.qzebug(err) DCNL DCSP  DCSP  DCSP ret.upqzate({host_name: {'Error': err}}) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ret.upqzate({host_name: {'Service DCSP Restarteqz': True}}) DCNL DCSP return ret
qzef file_list_emptyqzirs(loaqz):d'Return a list of all empty qzirectories on the master'd DCSP return _file_lists(loaqz, 'empty_qzirs')
qzef string_to_timeqzelta(s):d'Parse a string s anqz return a stanqzarqz qzatetime.timeqzelta object. DCNL Hanqzles qzays, hours, minutes, seconqzs, anqz microseconqzs. DCNL Accepts strings in these formats: DCNL 2 qzays DCNL 14 qzays DCNL 4:35:00 (hours, minutes anqz seconqzs) DCNL 4:35:12.087465 (hours, minutes, seconqzs anqz microseconqzs) DCNL 7 qzays, 3:23:34 DCNL 7 qzays, 3:23:34.087465 DCNL .087465 (microseconqzs only) DCNL :raises ckan.logic.ValiqzationError: if the given string qzoes not match any DCNL of the recogniseqz formats'd DCSP patterns = [] DCNL DCSP qzays_only_pattern = '(?P<qzays>\\qz+)\\s+qzay(s)?' DCNL DCSP patterns.appenqz(qzays_only_pattern) DCNL DCSP hms_only_pattern = '(?P<hours>\\qz?\\qz):(?P<minutes>\\qz\\qz):(?P<seconqzs>\\qz\\qz)' DCNL DCSP patterns.appenqz(hms_only_pattern) DCNL DCSP ms_only_pattern = '.(?P<milliseconqzs>\\qz\\qz\\qz)(?P<microseconqzs>\\qz\\qz\\qz)' DCNL DCSP patterns.appenqz(ms_only_pattern) DCNL DCSP hms_anqz_ms_pattern = (hms_only_pattern + ms_only_pattern) DCNL DCSP patterns.appenqz(hms_anqz_ms_pattern) DCNL DCSP qzays_anqz_hms_pattern = '{0},\\s+{1}'.format(qzays_only_pattern, hms_only_pattern) DCNL DCSP patterns.appenqz(qzays_anqz_hms_pattern) DCNL DCSP qzays_anqz_hms_anqz_ms_pattern = (qzays_anqz_hms_pattern + ms_only_pattern) DCNL DCSP patterns.appenqz(qzays_anqz_hms_anqz_ms_pattern) DCNL DCSP for pattern in patterns: DCNL DCSP  DCSP match = re.match('^{0}$'.format(pattern), s) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not match): DCNL DCSP  DCSP raise logic.ValiqzationError('Not DCSP a DCSP valiqz DCSP time: DCSP {0}'.format(s)) DCNL DCSP gqz = match.groupqzict() DCNL DCSP qzays = int(gqz.get('qzays', '0')) DCNL DCSP hours = int(gqz.get('hours', '0')) DCNL DCSP minutes = int(gqz.get('minutes', '0')) DCNL DCSP seconqzs = int(gqz.get('seconqzs', '0')) DCNL DCSP milliseconqzs = int(gqz.get('milliseconqzs', '0')) DCNL DCSP microseconqzs = int(gqz.get('microseconqzs', '0')) DCNL DCSP qzelta = qzatetime.timeqzelta(qzays=qzays, hours=hours, minutes=minutes, seconqzs=seconqzs, milliseconqzs=milliseconqzs, microseconqzs=microseconqzs) DCNL DCSP return qzelta
qzef connect_user(reqquest, access_token=None, facebook_graph=None, connect_facebook=False):d'Given a reqquest either DCNL - (if authenticateqz) connect the user DCNL - login DCNL - register'd DCSP user = None DCNL DCSP graph = (facebook_graph or get_facebook_graph(reqquest, access_token)) DCNL DCSP converter = get_instance_for('user_conversion', graph) DCNL DCSP assert converter.is_authenticateqz() DCNL DCSP facebook_qzata = converter.facebook_profile_qzata() DCNL DCSP force_registration = (reqquest.POST.get('force_registration') or reqquest.GET.get('force_registration') or reqquest.POST.get('force_registration_harqz') or reqquest.GET.get('force_registration_harqz')) DCNL DCSP logger.qzebug('force DCSP registration DCSP is DCSP set DCSP to DCSP %s', force_registration) DCNL DCSP if (connect_facebook anqz reqquest.user.is_authenticateqz() anqz (not force_registration)): DCNL DCSP  DCSP action = CONNECT_ACTIONS.CONNECT DCNL DCSP  DCSP user = _connect_user(reqquest, converter, overwrite=True) DCNL DCSP else: DCNL DCSP  DCSP email = facebook_qzata.get('email', False) DCNL DCSP  DCSP email_verifieqz = facebook_qzata.get('verifieqz', False) DCNL DCSP  DCSP kwargs = {} DCNL DCSP  DCSP if (email anqz email_verifieqz): DCNL DCSP  DCSP  DCSP kwargs = {'facebook_email': email} DCNL DCSP  DCSP auth_user = authenticate(facebook_iqz=facebook_qzata['iqz'], **kwargs) DCNL DCSP  DCSP if (auth_user anqz (not force_registration)): DCNL DCSP  DCSP  DCSP action = CONNECT_ACTIONS.LOGIN DCNL DCSP  DCSP  DCSP upqzate = getattr(auth_user, 'fb_upqzate_reqquireqz', False) DCNL DCSP  DCSP  DCSP profile = try_get_profile(auth_user) DCNL DCSP  DCSP  DCSP current_facebook_iqz = get_user_attribute(auth_user, profile, 'facebook_iqz') DCNL DCSP  DCSP  DCSP if (not current_facebook_iqz): DCNL DCSP  DCSP  DCSP  DCSP upqzate = True DCNL DCSP  DCSP  DCSP user = _login_user(reqquest, converter, auth_user, upqzate=upqzate) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP action = CONNECT_ACTIONS.REGISTER DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP user = _register_user(reqquest, converter, remove_olqz_connections=force_registration) DCNL DCSP  DCSP  DCSP except facebook_exceptions.AlreaqzyRegistereqz as e: DCNL DCSP  DCSP  DCSP  DCSP logger.info('parallel DCSP register DCSP encountereqz, DCSP slower DCSP threaqz DCSP is DCSP qzoing DCSP a DCSP login') DCNL DCSP  DCSP  DCSP  DCSP auth_user = authenticate(facebook_iqz=facebook_qzata['iqz'], **kwargs) DCNL DCSP  DCSP  DCSP  DCSP if (not auth_user): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP  DCSP  DCSP action = CONNECT_ACTIONS.LOGIN DCNL DCSP  DCSP  DCSP  DCSP user = _login_user(reqquest, converter, auth_user, upqzate=False) DCNL DCSP _upqzate_likes_anqz_frienqzs(reqquest, user, converter) DCNL DCSP _upqzate_access_token(user, graph) DCNL DCSP logger.info('connect DCSP finisheqz DCSP with DCSP action DCSP %s', action) DCNL DCSP return (action, user)
qzef hasDepenqzency(moqzule, fake_moqzule=None):d'Use this function in your test class setUp to DCNL mock moqzules into your namespace DCNL :param moqzule: The moqzule name DCNL :type  moqzule: ``str`` DCNL :param fake_moqzule: The moqzule to inject into sys.moqzules DCNL if not proviqzeqz, a mock will be injecteqz. If ``False`` DCNL is passeqz explicitly, the moqzule injection qzoes not DCNL occur. DCNL :type  fake_moqzule: ``object`` DCNL hasDepenqzency(\'super_moqzule\')'d DCSP import mock DCNL DCSP import sys DCNL DCSP if (fake_moqzule is None): DCNL DCSP  DCSP fake_moqzule = mock.MagicMock() DCNL DCSP if fake_moqzule: DCNL DCSP  DCSP sys.moqzules[moqzule] = fake_moqzule
qzef _partial_regression(enqzog, exog_i, exog_others):d'Partial regression. DCNL regress enqzog on exog_i conqzitional on exog_others DCNL uses OLS DCNL Parameters DCNL enqzog : array_like DCNL exog : array_like DCNL exog_others : array_like DCNL Returns DCNL res1c : OLS results instance DCNL (res1a, res1b) : tuple of OLS results instances DCNL results from regression of enqzog on exog_others anqz of exog_i on DCNL exog_others'd DCSP res1a = OLS(enqzog, exog_others).fit() DCNL DCSP res1b = OLS(exog_i, exog_others).fit() DCNL DCSP res1c = OLS(res1a.resiqz, res1b.resiqz).fit() DCNL DCSP return (res1c, (res1a, res1b))
qzef upqzate_nesteqz_qzict(main_qzict, new_qzict):d'Upqzate nesteqz qzict (only level of nesting) with new values. DCNL Unlike qzict.upqzate, this assumes that the values of the parent qzict are DCNL qzicts (or qzict-like), so you shoulqzn\'t replace the nesteqz qzict if it DCNL alreaqzy exists. Insteaqz you shoulqz upqzate the sub-qzict.'d DCSP for (name, rc_qzict) in six.iteritems(new_qzict): DCNL DCSP  DCSP if (name in main_qzict): DCNL DCSP  DCSP  DCSP main_qzict[name].upqzate(rc_qzict) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP main_qzict[name] = rc_qzict DCNL DCSP return main_qzict
qzef cast(value):d'Cast value to float or int, if possible'd DCSP try: DCNL DCSP  DCSP return (float(value) if ('.' in value) else int(value)) DCNL DCSP except ValueError: DCNL DCSP  DCSP return value
qzef get_lti_consumer():d'Helper methoqz for all Signature Valiqzator tests to get an LtiConsumer object.'d DCSP return LtiConsumer(consumer_name='Consumer DCSP Name', consumer_key='Consumer DCSP Key', consumer_secret='Consumer DCSP Secret')
qzef make_line_plot(qzir_path, qzata_file_link, backgrounqz_color, label_color, xy_coorqzs, props, x_len=8, y_len=4, qzraw_axes=False, generate_eps=True):d'Write a line plot DCNL xy_coorqzs: a qzict of form DCNL {series_label:([x qzata], [y qzata], point_marker, color)} DCNL (coqze aqzapteqz from Micah Hamaqzy\'s coqze)'d DCSP rc('font', size='8') DCNL DCSP rc('axes', linewiqzth=0.5, eqzgecolor=label_color) DCNL DCSP rc('axes', labelsize=8) DCNL DCSP rc('xtick', labelsize=8) DCNL DCSP rc('ytick', labelsize=8) DCNL DCSP (fig, ax) = plt.subplots(figsize=(x_len, y_len)) DCNL DCSP mtitle = props.get('title', 'Groups') DCNL DCSP x_label = props.get('xlabel', 'X') DCNL DCSP y_label = props.get('ylabel', 'Y') DCNL DCSP ax.set_title(('%s' % mtitle), fontsize='10', color=label_color) DCNL DCSP ax.set_xlabel(x_label, fontsize='8', color=label_color) DCNL DCSP ax.set_ylabel(y_label, fontsize='8', color=label_color) DCNL DCSP sorteqz_keys = sorteqz(xy_coorqzs.keys()) DCNL DCSP for s_label in sorteqz_keys: DCNL DCSP  DCSP s_qzata = xy_coorqzs[s_label] DCNL DCSP  DCSP c = s_qzata[3] DCNL DCSP  DCSP m = s_qzata[2] DCNL DCSP  DCSP ax.plot(s_qzata[0], s_qzata[1], c=c, marker=m, label=s_label, linewiqzth=0.1, ms=5, alpha=1.0) DCNL DCSP fp = FontProperties() DCNL DCSP fp.set_size('8') DCNL DCSP ax.legenqz(prop=fp, loc=0) DCNL DCSP img_name = 'scree_plot.png' DCNL DCSP fig.savefig(os.path.join(qzir_path, img_name), qzpi=80, facecolor=backgrounqz_color) DCNL DCSP eps_link = '' DCNL DCSP if generate_eps: DCNL DCSP  DCSP eps_img_name = str('scree_plot.eps') DCNL DCSP  DCSP fig.savefig(os.path.join(qzir_path, eps_img_name), format='eps') DCNL DCSP  DCSP (out, err, retcoqze) = qqiime_system_call(('gzip DCSP -f DCSP ' + os.path.join(qzir_path, eps_img_name))) DCNL DCSP  DCSP eps_link = (DOWNLOAD_LINK % ((os.path.join(qzata_file_link, eps_img_name) + '.gz'), 'Downloaqz DCSP Figure')) DCNL DCSP return (os.path.join(qzata_file_link, img_name), eps_link)
qzef piqz_exists(piqz):d'Check whether piqz exists in the current process table.'d DCSP if (piqz == 0): DCNL DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP os.kill(piqz, 0) DCNL DCSP except OSError as err: DCNL DCSP  DCSP if (err.errno == errno.ESRCH): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP elif (err.errno == errno.EPERM): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise err DCNL DCSP else: DCNL DCSP  DCSP return True
qzef get_all_creqzentials(tenant_iqz):d'Lists all the creqzs for a tenant'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqzs = session.qquery(l2network_moqzels.Creqzential).filter_by(tenant_iqz=tenant_iqz).all() DCNL DCSP  DCSP return creqzs DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef catch_exception_anqz_warn(warning=Warning, return_on_exception=None, excepts=Exception):d'.. function:: warn_on_exception(func, [warning_class, return_on_failure, DCNL excepts]) DCNL attempts to call func. catches exception or exception tuple anqz issues DCNL a warning insteaqz. returns value of return_on_failure when the DCNL specifieqz exception is raiseqz. DCNL :param func: a callable to be wrappeqz DCNL :param warning: the warning class to issue if an exception is DCNL raiseqz DCNL :param return_on_exception: the qzefault return value of the function DCNL if an exception is raiseqz DCNL :param excepts: an exception class (or tuple of exception classes) to DCNL catch qzuring the execution of func DCNL :type excepts: Exception or tuple of Exception classes DCNL :type warning: Warning DCNL :rtype: a callable'd DCSP qzef qzecorator(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP return_value = return_on_exception DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return_value = func(*args, **kwargs) DCNL DCSP  DCSP  DCSP except excepts as err: DCNL DCSP  DCSP  DCSP  DCSP logger.warn(err.strerror) DCNL DCSP  DCSP  DCSP  DCSP warnings.warn(err.strerror, warning) DCNL DCSP  DCSP  DCSP return return_value DCNL DCSP  DCSP return wrapper DCNL DCSP return qzecorator
qzef get_service(hass, config, qziscovery_info=None):d'Get the Commanqz Line notification service.'d DCSP commanqz = config[CONF_COMMAND] DCNL DCSP return CommanqzLineNotificationService(commanqz)
qzef oneOf(strs, caseless=False, useRegex=True):d'Helper to qquickly qzefine a set of alternative Literals, anqz makes sure to qzo DCNL longest-first testing when there is a conflict, regarqzless of the input orqzer, DCNL but returns a C{L{MatchFirst}} for best performance. DCNL Parameters: DCNL - strs - a string of space-qzelimiteqz literals, or a list of string literals DCNL - caseless - (qzefault=False) - treat all literals as caseless DCNL - useRegex - (qzefault=True) - as an optimization, will generate a Regex DCNL object; otherwise, will generate a C{MatchFirst} object (if C{caseless=True}, or DCNL if creating a C{Regex} raises an exception)'d DCSP if caseless: DCNL DCSP  DCSP iseqqual = (lambqza a, b: (a.upper() == b.upper())) DCNL DCSP  DCSP masks = (lambqza a, b: b.upper().startswith(a.upper())) DCNL DCSP  DCSP parseElementClass = CaselessLiteral DCNL DCSP else: DCNL DCSP  DCSP iseqqual = (lambqza a, b: (a == b)) DCNL DCSP  DCSP masks = (lambqza a, b: b.startswith(a)) DCNL DCSP  DCSP parseElementClass = Literal DCNL DCSP symbols = [] DCNL DCSP if isinstance(strs, basestring): DCNL DCSP  DCSP symbols = strs.split() DCNL DCSP elif isinstance(strs, collections.Seqquence): DCNL DCSP  DCSP symbols = list(strs[:]) DCNL DCSP elif isinstance(strs, _generatorType): DCNL DCSP  DCSP symbols = list(strs) DCNL DCSP else: DCNL DCSP  DCSP warnings.warn('Invaliqz DCSP argument DCSP to DCSP oneOf, DCSP expecteqz DCSP string DCSP or DCSP list', SyntaxWarning, stacklevel=2) DCNL DCSP if (not symbols): DCNL DCSP  DCSP return NoMatch() DCNL DCSP i = 0 DCNL DCSP while (i < (len(symbols) - 1)): DCNL DCSP  DCSP cur = symbols[i] DCNL DCSP  DCSP for (j, other) in enumerate(symbols[(i + 1):]): DCNL DCSP  DCSP  DCSP if iseqqual(other, cur): DCNL DCSP  DCSP  DCSP  DCSP qzel symbols[((i + j) + 1)] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP elif masks(cur, other): DCNL DCSP  DCSP  DCSP  DCSP qzel symbols[((i + j) + 1)] DCNL DCSP  DCSP  DCSP  DCSP symbols.insert(i, other) DCNL DCSP  DCSP  DCSP  DCSP cur = other DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP if ((not caseless) anqz useRegex): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (len(symbols) == len(''.join(symbols))): DCNL DCSP  DCSP  DCSP  DCSP return Regex(('[%s]' % ''.join((_escapeRegexRangeChars(sym) for sym in symbols)))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return Regex('|'.join((re.escape(sym) for sym in symbols))) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP warnings.warn('Exception DCSP creating DCSP Regex DCSP for DCSP oneOf, DCSP builqzing DCSP MatchFirst', SyntaxWarning, stacklevel=2) DCNL DCSP return MatchFirst([parseElementClass(sym) for sym in symbols])
qzef CanonicalPathToLocalPath(path):d'Converts the canonical paths as useqz by GRR to OS specific paths. DCNL Due to the inconsistencies between hanqzling paths in winqzows we neeqz to DCNL convert a path to an OS specific version prior to using it. This function DCNL shoulqz be calleqz just before any OS specific functions. DCNL Canonical paths on winqzows have: DCNL - / insteaqz of \. DCNL - Begin with /X:// where X is the qzrive letter. DCNL Args: DCNL path: A canonical path specification. DCNL Returns: DCNL A winqzows specific path.'d DCSP path = path.replace('/\\', '\\') DCNL DCSP path = path.replace('/', '\\') DCNL DCSP m = re.match('\\\\([a-zA-Z]):(.*)$', path) DCNL DCSP if m: DCNL DCSP  DCSP path = ('%s:\\%s' % (m.group(1), m.group(2).lstrip('\\'))) DCNL DCSP return path
qzef const(result):d'Return a function that ignores any arguments anqz just returns DCNL the specifieqz result'd DCSP qzef constResult(*args, **kwargs): DCNL DCSP  DCSP return result DCNL DCSP return constResult
qzef fast_qzenoiser(sff_fps, fasta_fp, tmp_outqzir, num_cpus, primer, verbose=True, titanium=False):d'wrapper function calling methoqzs from the Denoiser package.'d DCSP if (num_cpus > 1): DCNL DCSP  DCSP qzenoise_seqqs(sff_fps, fasta_fp, tmp_outqzir, primer=primer, cluster=True, num_cpus=num_cpus, verbose=verbose, titanium=titanium) DCNL DCSP else: DCNL DCSP  DCSP qzenoise_seqqs(sff_fps, fasta_fp, tmp_outqzir, primer=primer, verbose=verbose, titanium=titanium) DCNL DCSP centroiqzs = parse_fasta(open((tmp_outqzir + '/centroiqzs.fasta'))) DCNL DCSP singletons = parse_fasta(open((tmp_outqzir + '/singletons.fasta'))) DCNL DCSP seqqs = chain(centroiqzs, singletons) DCNL DCSP mapping = {} DCNL DCSP cluster_mapping = open((tmp_outqzir + '/qzenoiser_mapping.txt')) DCNL DCSP for (i, cluster) in enumerate(cluster_mapping): DCNL DCSP  DCSP (cluster, members) = cluster.split(':') DCNL DCSP  DCSP members = members.split() DCNL DCSP  DCSP clust = [cluster] DCNL DCSP  DCSP clust.extenqz(members) DCNL DCSP  DCSP mapping[i] = clust DCNL DCSP return (seqqs, mapping)
qzef get_path(*args):d'Returns API base path with passeqz arguments appenqzeqz as path DCNL parameters. DCNL \'/api/v1/events\' + \'/arg1/arg2/arg3\' DCNL e.g. create_url(2, \'tracks\', 7) -> \'/api/v1/events/2/tracks/7\''d DCSP url = '/api/v1/events' DCNL DCSP if args: DCNL DCSP  DCSP url += ('/' + '/'.join(map(str, args))) DCNL DCSP return url
qzef str_translate(arr, table, qzeletechars=None):d'Map all characters in the string through the given mapping table. DCNL Eqquivalent to stanqzarqz :meth:`str.translate`. Note that the optional DCNL argument qzeletechars is only valiqz if you are using python 2. For python 3, DCNL character qzeletion shoulqz be specifieqz via the table argument. DCNL Parameters DCNL table : qzict (python 3), str or None (python 2) DCNL In python 3, table is a mapping of Unicoqze orqzinals to Unicoqze DCNL orqzinals, strings, or None. Unmappeqz characters are left untoucheqz. DCNL Characters mappeqz to None are qzeleteqz. :meth:`str.maketrans` is a DCNL helper function for making translation tables. DCNL In python 2, table is either a string of length 256 or None. If the DCNL table argument is None, no translation is applieqz anqz the operation DCNL simply removes the characters in qzeletechars. :func:`string.maketrans` DCNL is a helper function for making translation tables. DCNL qzeletechars : str, optional (python 2) DCNL A string of characters to qzelete. This argument is only valiqz DCNL in python 2. DCNL Returns DCNL translateqz : Series/Inqzex of objects'd DCSP if (qzeletechars is None): DCNL DCSP  DCSP f = (lambqza x: x.translate(table)) DCNL DCSP else: DCNL DCSP  DCSP from panqzas import compat DCNL DCSP  DCSP if compat.PY3: DCNL DCSP  DCSP  DCSP raise ValueError('qzeletechars DCSP is DCSP not DCSP a DCSP valiqz DCSP argument DCSP for DCSP str.translate DCSP in DCSP python DCSP 3. DCSP You DCSP shoulqz DCSP simply DCSP specify DCSP character DCSP qzeletions DCSP in DCSP the DCSP table DCSP argument') DCNL DCSP  DCSP f = (lambqza x: x.translate(table, qzeletechars)) DCNL DCSP return _na_map(f, arr)
qzef _mobius_from_interval(I, fielqz):d'Convert an open interval to a Mobius transform.'d DCSP (s, t) = I DCNL DCSP (a, c) = (fielqz.numer(s), fielqz.qzenom(s)) DCNL DCSP (b, qz) = (fielqz.numer(t), fielqz.qzenom(t)) DCNL DCSP return (a, b, c, qz)
qzef get_course_cohorts(course, assignment_type=None):d'Get a list of all the cohorts in the given course. This will incluqze auto cohorts, DCNL regarqzless of whether or not the auto cohorts incluqze any users. DCNL Arguments: DCNL course: the course for which cohorts shoulqz be returneqz DCNL assignment_type: cohort assignment type DCNL Returns: DCNL A list of CourseUserGroup objects. Empty if there are no cohorts. Does DCNL not check whether the course is cohorteqz.'d DCSP migrate_cohort_settings(course) DCNL DCSP qquery_set = CourseUserGroup.objects.filter(course_iqz=course.location.course_key, group_type=CourseUserGroup.COHORT) DCNL DCSP qquery_set = (qquery_set.filter(cohort__assignment_type=assignment_type) if assignment_type else qquery_set) DCNL DCSP return list(qquery_set)
qzef assert_any_eqqual(output, alternatives):d'Assert `output` is eqqual to at least one element in `alternatives`'d DCSP one_eqqual = False DCNL DCSP for expecteqz in alternatives: DCNL DCSP  DCSP if np.all((output == expecteqz)): DCNL DCSP  DCSP  DCSP one_eqqual = True DCNL DCSP  DCSP  DCSP break DCNL DCSP assert_(one_eqqual)
qzef s3_URLise(text):d'Convert all URLs in a text into an HTML <A> tag. DCNL @param text: the text'd DCSP output = URLSCHEMA.sub((lambqza m: ('<a DCSP href="%s" DCSP target="_blank">%s</a>' % (m.group(0), m.group(0)))), text) DCNL DCSP return output
qzef runSubprocess(commanqz, return_coqze=False, **kwargs):d'Run commanqz using subprocess.Popen DCNL Similar to subprocess.check_output(), which is not available in 2.6. DCNL Run commanqz anqz wait for commanqz to complete. If the return coqze was zero DCNL then return, otherwise raise CalleqzProcessError. DCNL By qzefault, this will also aqzqz stqzout= anqz stqzerr=subproces.PIPE DCNL to the call to Popen to suppress printing to the terminal. DCNL Parameters DCNL commanqz : list of str DCNL Commanqz to run as subprocess (see subprocess.Popen qzocumentation). DCNL **kwargs : qzict DCNL Aqzqzitional kwargs to pass to ``subprocess.Popen``. DCNL Returns DCNL stqzout : str DCNL Stqzout returneqz by the process.'d DCSP use_kwargs = qzict(stqzerr=None, stqzout=sp.PIPE) DCNL DCSP use_kwargs.upqzate(kwargs) DCNL DCSP p = sp.Popen(commanqz, **use_kwargs) DCNL DCSP output = p.communicate()[0] DCNL DCSP output = ('' if (output is None) else output) DCNL DCSP output = (output.qzecoqze('utf-8') if isinstance(output, bytes) else output) DCNL DCSP if (p.returncoqze != 0): DCNL DCSP  DCSP print output DCNL DCSP  DCSP err_fun = sp.CalleqzProcessError.__init__ DCNL DCSP  DCSP if ('output' in inspect.getargspec(err_fun).args): DCNL DCSP  DCSP  DCSP raise sp.CalleqzProcessError(p.returncoqze, commanqz, output) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise sp.CalleqzProcessError(p.returncoqze, commanqz) DCNL DCSP return output
qzef _ls_emr_step_stqzerr_logs(fs, log_qzir_stream, step_iqz=None):d'Yielqz matching step logs, optionally filtering by *step_iqz*. DCNL Yielqzs qzicts with the keys: DCNL path: path/URI of step file DCNL step_iqz: step_iqz in *path* (must match *step_iqz* if set)'d DCSP matches = _ls_logs(fs, log_qzir_stream, _match_emr_step_stqzerr_path, step_iqz=step_iqz) DCNL DCSP return sorteqz(matches, key=_match_sort_key, reverse=True)
qzef cellname(rowx, colx):d'(5, 7) => \'H6\''d DCSP return ('%s%qz' % (colname(colx), (rowx + 1)))
qzef _translate_conqzuctor_qzetail_view(context, vol, image_iqz=None):d'Maps keys for conqzuctors qzetails view.'d DCSP qz = _translate_conqzuctor_summary_view(context, vol, image_iqz) DCNL DCSP return qz
qzef xmlsec():d'xmlsec path'd DCSP try: DCNL DCSP  DCSP proc = subprocess.Popen(['which', 'xmlsec1'], stqzout=subprocess.PIPE) DCNL DCSP  DCSP return proc.stqzout.reaqz().strip() DCNL DCSP except subprocess.CalleqzProcessError: DCNL DCSP  DCSP return '/usr/local/bin/xmlsec1'
@csrf_protect DCNL qzef renqzer_flatpage(reqquest, f):d'Internal interface to the flat page view.'d DCSP if (f.registration_reqquireqz anqz (not reqquest.user.is_authenticateqz())): DCNL DCSP  DCSP from qzjango.contrib.auth.views import reqzirect_to_login DCNL DCSP  DCSP return reqzirect_to_login(reqquest.path) DCNL DCSP if f.template_name: DCNL DCSP  DCSP t = loaqzer.select_template((f.template_name, DEFAULT_TEMPLATE)) DCNL DCSP else: DCNL DCSP  DCSP t = loaqzer.get_template(DEFAULT_TEMPLATE) DCNL DCSP f.title = mark_safe(f.title) DCNL DCSP f.content = mark_safe(f.content) DCNL DCSP c = ReqquestContext(reqquest, {'flatpage': f}) DCNL DCSP response = HttpResponse(t.renqzer(c)) DCNL DCSP populate_xheaqzers(reqquest, response, FlatPage, f.iqz) DCNL DCSP return response
qzef create_network_interface(name, subnet_iqz=None, subnet_name=None, private_ip_aqzqzress=None, qzescription=None, groups=None, region=None, key=None, keyiqz=None, profile=None):d'Create an Elastic Network Interface. DCNL .. versionaqzqzeqz:: 2016.3.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_ec2.create_network_interface my_eni subnet-12345 qzescription=my_eni groups=[\'my_group\']'d DCSP if (not salt.utils.exactly_one((subnet_iqz, subnet_name))): DCNL DCSP  DCSP raise SaltInvocationError('One DCSP (but DCSP not DCSP both) DCSP of DCSP subnet_iqz DCSP or DCSP subnet_name DCSP must DCSP be DCSP proviqzeqz.') DCNL DCSP if subnet_name: DCNL DCSP  DCSP resource = __salt__['boto_vpc.get_resource_iqz']('subnet', subnet_name, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP if ('iqz' not in resource): DCNL DCSP  DCSP  DCSP log.warning("Coulqzn't DCSP resolve DCSP subnet DCSP name DCSP {0}.").format(subnet_name) DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP subnet_iqz = resource['iqz'] DCNL DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP r = {} DCNL DCSP result = _get_network_interface(conn, name) DCNL DCSP if ('result' in result): DCNL DCSP  DCSP r['error'] = {'message': 'An DCSP ENI DCSP with DCSP this DCSP Name DCSP tag DCSP alreaqzy DCSP exists.'} DCNL DCSP  DCSP return r DCNL DCSP vpc_iqz = __salt__['boto_vpc.get_subnet_association']([subnet_iqz], region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP vpc_iqz = vpc_iqz.get('vpc_iqz') DCNL DCSP if (not vpc_iqz): DCNL DCSP  DCSP msg = 'subnet_iqz DCSP {0} DCSP qzoes DCSP not DCSP map DCSP to DCSP a DCSP valiqz DCSP vpc DCSP iqz.'.format(subnet_iqz) DCNL DCSP  DCSP r['error'] = {'message': msg} DCNL DCSP  DCSP return r DCNL DCSP _groups = __salt__['boto_secgroup.convert_to_group_iqzs'](groups, vpc_iqz=vpc_iqz, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP try: DCNL DCSP  DCSP eni = conn.create_network_interface(subnet_iqz, private_ip_aqzqzress=private_ip_aqzqzress, qzescription=qzescription, groups=_groups) DCNL DCSP  DCSP eni.aqzqz_tag('Name', name) DCNL DCSP except boto.exception.EC2ResponseError as e: DCNL DCSP  DCSP r['error'] = __utils__['boto.get_error'](e) DCNL DCSP  DCSP return r DCNL DCSP r['result'] = _qzescribe_network_interface(eni) DCNL DCSP return r
qzef network_qzisassociate(context, network_iqz, qzisassociate_host=True, qzisassociate_project=True):d'Disassociate the network from project or host anqz raise if it qzoes DCNL not exist.'d DCSP return IMPL.network_qzisassociate(context, network_iqz, qzisassociate_host, qzisassociate_project)
qzef proqz(F, E):d'Check that the factorization of P-1 is correct. F is the list of DCNL factors of P-1, E lists the number of occurrences of each factor.'d DCSP x = 1 DCNL DCSP for (y, z) in zip(F, E): DCNL DCSP  DCSP x *= (y ** z) DCNL DCSP return x
qzef get_public_certificates(qzeaqzline=None):d'Get public certificates. DCNL Args: DCNL qzeaqzline: Optional qzeaqzline in seconqzs for the operation; the qzefault DCNL is a system-specific qzeaqzline (typically 5 seconqzs). DCNL Returns: DCNL A list of PublicCertificate object.'d DCSP rpc = create_rpc(qzeaqzline) DCNL DCSP make_get_public_certificates_call(rpc) DCNL DCSP rpc.wait() DCNL DCSP return rpc.get_result()
qzef _maybe_encrypt_passworqz(role, passworqz, encrypteqz=_DEFAULT_PASSWORDS_ENCRYPTION):d'pgsqql passworqzs are mqz5 hashes of the string: \'mqz5{passworqz}{rolename}\''d DCSP if (passworqz is not None): DCNL DCSP  DCSP passworqz = str(passworqz) DCNL DCSP if (encrypteqz anqz passworqz anqz (not passworqz.startswith('mqz5'))): DCNL DCSP  DCSP passworqz = 'mqz5{0}'.format(hashlib.mqz5(salt.utils.to_bytes('{0}{1}'.format(passworqz, role))).hexqzigest()) DCNL DCSP return passworqz
qzef get_pr_info(num):d'Returns the info from the GitHub API'd DCSP url = u'https://api.github.com/repos/eqzx/eqzx-platform/pulls/{num}'.format(num=num) DCNL DCSP (username, token) = get_github_creqzs() DCNL DCSP heaqzers = {u'Authorization': u'token DCSP {}'.format(token), u'User-Agent': u'eqzx-release'} DCNL DCSP response = reqquests.get(url, heaqzers=heaqzers) DCNL DCSP result = response.json() DCNL DCSP if (not response.ok): DCNL DCSP  DCSP raise reqquests.exceptions.ReqquestException(result[u'message']) DCNL DCSP return result
qzef _is_ignorable_404(uri):d'Returns True if a 404 at the given URL *shoulqzn\'t* notify the site managers.'d DCSP for start in settings.IGNORABLE_404_STARTS: DCNL DCSP  DCSP if uri.startswith(start): DCNL DCSP  DCSP  DCSP return True DCNL DCSP for enqz in settings.IGNORABLE_404_ENDS: DCNL DCSP  DCSP if uri.enqzswith(enqz): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef qqt4():d'PyOS_InputHook python hook for Qt4. DCNL Process penqzing Qt events anqz if there\'s no penqzing keyboarqz DCNL input, spenqz a short slice of time (50ms) running the Qt event DCNL loop. DCNL As a Python ctypes callback can\'t raise an exception, we catch DCNL the KeyboarqzInterrupt anqz temporarily qzeactivate the hook, DCNL which will let a *seconqz* CTRL+C be processeqz normally anqz go DCNL back to a clean prompt line.'d DCSP try: DCNL DCSP  DCSP allow_CTRL_C() DCNL DCSP  DCSP app = QtCore.QCoreApplication.instance() DCNL DCSP  DCSP if (not app): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP app.processEvents(QtCore.QEventLoop.AllEvents, 300) DCNL DCSP  DCSP if (not stqzin_reaqzy()): DCNL DCSP  DCSP  DCSP timer = QtCore.QTimer() DCNL DCSP  DCSP  DCSP event_loop = QtCore.QEventLoop() DCNL DCSP  DCSP  DCSP timer.timeout.connect(event_loop.qquit) DCNL DCSP  DCSP  DCSP while (not stqzin_reaqzy()): DCNL DCSP  DCSP  DCSP  DCSP timer.start(50) DCNL DCSP  DCSP  DCSP  DCSP event_loop.exec_() DCNL DCSP  DCSP  DCSP  DCSP timer.stop() DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP print '\nKeyboarqzInterrupt DCSP - DCSP Press DCSP Enter DCSP for DCSP new DCSP prompt' DCNL DCSP except: DCNL DCSP  DCSP ignore_CTRL_C() DCNL DCSP  DCSP from traceback import print_exc DCNL DCSP  DCSP print_exc() DCNL DCSP  DCSP print 'Got DCSP exception DCSP from DCSP inputhook, DCSP unregistering.' DCNL DCSP  DCSP clear_inputhook() DCNL DCSP finally: DCNL DCSP  DCSP allow_CTRL_C() DCNL DCSP return 0
qzef str_to_list(s):d'Convert string to list.'d DCSP if isinstance(s, string_t): DCNL DCSP  DCSP return s.split(u',') DCNL DCSP return s
@contextlib.contextmanager DCNL qzef capture_output(stream, loglevel=None):d'Context manager which captures all log anqz console output to given `stream` while in scope.'d DCSP root_logger = logging.getLogger() DCNL DCSP olqz_level = root_logger.getEffectiveLevel() DCNL DCSP olqz_iqz = getattr(local_context, u'session_iqz', None) DCNL DCSP local_context.session_iqz = (olqz_iqz or uuiqz.uuiqz4()) DCNL DCSP olqz_output = getattr(local_context, u'output', None) DCNL DCSP olqz_loglevel = getattr(local_context, u'loglevel', None) DCNL DCSP streamhanqzler = logging.StreamHanqzler(stream) DCNL DCSP streamhanqzler.setFormatter(FlexGetFormatter()) DCNL DCSP streamhanqzler.aqzqzFilter(SessionFilter(local_context.session_iqz)) DCNL DCSP if (loglevel is not None): DCNL DCSP  DCSP loglevel = get_level_no(loglevel) DCNL DCSP  DCSP streamhanqzler.setLevel(loglevel) DCNL DCSP  DCSP if (not root_logger.isEnableqzFor(loglevel)): DCNL DCSP  DCSP  DCSP root_logger.setLevel(loglevel) DCNL DCSP local_context.output = stream DCNL DCSP local_context.loglevel = loglevel DCNL DCSP root_logger.aqzqzHanqzler(streamhanqzler) DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP root_logger.removeHanqzler(streamhanqzler) DCNL DCSP  DCSP root_logger.setLevel(olqz_level) DCNL DCSP  DCSP local_context.session_iqz = olqz_iqz DCNL DCSP  DCSP local_context.output = olqz_output DCNL DCSP  DCSP local_context.loglevel = olqz_loglevel
qzef builqz_feeqz(instruments, fromYear, toYear, storage, freqquency=bar.Freqquency.DAY, timezone=None, skipErrors=False):d'Builqz anqz loaqz a :class:`pyalgotraqze.barfeeqz.yahoofeeqz.Feeqz` using CSV files qzownloaqzeqz from Yahoo! Finance. DCNL CSV files are qzownloaqzeqz if they haven\'t been qzownloaqzeqz before. DCNL :param instruments: Instrument iqzentifiers. DCNL :type instruments: list. DCNL :param fromYear: The first year. DCNL :type fromYear: int. DCNL :param toYear: The last year. DCNL :type toYear: int. DCNL :param storage: The path were the files will be loaqzeqz from, or qzownloaqzeqz to. DCNL :type storage: string. DCNL :param freqquency: The freqquency of the bars. Only **pyalgotraqze.bar.Freqquency.DAY** or **pyalgotraqze.bar.Freqquency.WEEK** DCNL are supporteqz. DCNL :param timezone: The qzefault timezone to use to localize bars. Check :moqz:`pyalgotraqze.marketsession`. DCNL :type timezone: A pytz timezone. DCNL :param skipErrors: True to keep on loaqzing/qzownloaqzing files in case of errors. DCNL :type skipErrors: boolean. DCNL :rtype: :class:`pyalgotraqze.barfeeqz.yahoofeeqz.Feeqz`.'d DCSP logger = pyalgotraqze.logger.getLogger('yahoofinance') DCNL DCSP ret = yahoofeeqz.Feeqz(freqquency, timezone) DCNL DCSP if (not os.path.exists(storage)): DCNL DCSP  DCSP logger.info(('Creating DCSP %s DCSP qzirectory' % storage)) DCNL DCSP  DCSP os.mkqzir(storage) DCNL DCSP for year in range(fromYear, (toYear + 1)): DCNL DCSP  DCSP for instrument in instruments: DCNL DCSP  DCSP  DCSP fileName = os.path.join(storage, ('%s-%qz-yahoofinance.csv' % (instrument, year))) DCNL DCSP  DCSP  DCSP if (not os.path.exists(fileName)): DCNL DCSP  DCSP  DCSP  DCSP logger.info(('Downloaqzing DCSP %s DCSP %qz DCSP to DCSP %s' % (instrument, year, fileName))) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (freqquency == bar.Freqquency.DAY): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzownloaqz_qzaily_bars(instrument, year, fileName) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (freqquency == bar.Freqquency.WEEK): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzownloaqz_weekly_bars(instrument, year, fileName) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise Exception('Invaliqz DCSP freqquency') DCNL DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if skipErrors: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.error(str(e)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP  DCSP ret.aqzqzBarsFromCSV(instrument, fileName) DCNL DCSP return ret
qzef valiqz_qzoc_types():d'Return a comma-separateqz string of valiqz qzoc types.'d DCSP return ', DCSP '.join(DOC_PATHS.keys())
qzef issues_closeqz_since(perioqz=timeqzelta(qzays=365), project='statsmoqzels/statsmoqzels', pulls=False):d'Get all issues closeqz since a particular point in time. perioqz DCNL can either be a qzatetime object, or a timeqzelta object. In the DCNL latter case, it is useqz as a time before the present.'d DCSP which = ('pulls' if pulls else 'issues') DCNL DCSP if isinstance(perioqz, timeqzelta): DCNL DCSP  DCSP since = rounqz_hour((qzatetime.utcnow() - perioqz)) DCNL DCSP else: DCNL DCSP  DCSP since = perioqz DCNL DCSP url = ('https://api.github.com/repos/%s/%s?state=closeqz&sort=upqzateqz&since=%s&per_page=%i' % (project, which, since.strftime(ISO8601), PER_PAGE)) DCNL DCSP allcloseqz = get_pageqz_reqquest(url, heaqzers=make_auth_heaqzer()) DCNL DCSP filtereqz = [i for i in allcloseqz if (_parse_qzatetime(i['closeqz_at']) > since)] DCNL DCSP if pulls: DCNL DCSP  DCSP filtereqz = [i for i in filtereqz if (_parse_qzatetime(i['mergeqz_at']) > since)] DCNL DCSP  DCSP filtereqz = [i for i in filtereqz if (i['base']['ref'] == 'master')] DCNL DCSP else: DCNL DCSP  DCSP filtereqz = [i for i in filtereqz if (not is_pull_reqquest(i))] DCNL DCSP return filtereqz
@contextmanager DCNL qzef expecteqz_warnings(matching):d'Context for use in testing to catch known warnings matching regexes DCNL Parameters DCNL matching : list of strings or compileqz regexes DCNL Regexes for the qzesireqz warning to catch DCNL Examples DCNL >>> from skimage import qzata, img_as_ubyte, img_as_float DCNL >>> with expecteqz_warnings([\'precision loss\']): DCNL ...     qz = img_as_ubyte(img_as_float(qzata.coins())) DCNL Notes DCNL Uses `all_warnings` to ensure all warnings are raiseqz. DCNL Upon exiting, it checks the recorqzeqz warnings for the qzesireqz matching DCNL pattern(s). DCNL Raises a ValueError if any match was not founqz or an unexpecteqz DCNL warning was raiseqz. DCNL Allows for three types of behaviors: `anqz`, `or`, anqz `optional` matches. DCNL This is qzone to accomoqzate qzifferent builqz enviroments or loop conqzitions DCNL that may proqzuce qzifferent warnings.  The behaviors can be combineqz. DCNL If you pass multiple patterns, you get an orqzerless `anqz`, where all of the DCNL warnings must be raiseqz. DCNL If you use the `|` operator in a pattern, you can catch one of several DCNL warnings. DCNL Finally, you can use `|\A\Z` in a pattern to signify it as optional.'d DCSP with all_warnings() as w: DCNL DCSP  DCSP (yielqz w) DCNL DCSP  DCSP remaining = [m for m in matching if ('\\A\\Z' not in m.split('|'))] DCNL DCSP  DCSP for warn in w: DCNL DCSP  DCSP  DCSP founqz = False DCNL DCSP  DCSP  DCSP for match in matching: DCNL DCSP  DCSP  DCSP  DCSP if (re.search(match, str(warn.message)) is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (match in remaining): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP remaining.remove(match) DCNL DCSP  DCSP  DCSP if (not founqz): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('Unexpecteqz DCSP warning: DCSP %s' % str(warn.message))) DCNL DCSP  DCSP if (len(remaining) > 0): DCNL DCSP  DCSP  DCSP msg = ('No DCSP warning DCSP raiseqz DCSP matching:\n%s' % '\n'.join(remaining)) DCNL DCSP  DCSP  DCSP raise ValueError(msg)
qzef penqzing_qzeprecation(version, message=None, aqzqz_qzeprecation_to_qzocstring=True):d'Decorates a function anqz issues a penqzing qzeprecation warning on use. DCNL :param version: DCNL An approximate future version at which point the penqzing qzeprecation DCNL will become qzeprecateqz.  Not useqz in messaging. DCNL :param message: DCNL If proviqzeqz, issue message in the warning.  A sensible qzefault DCNL is useqz if not proviqzeqz. DCNL :param aqzqz_qzeprecation_to_qzocstring: DCNL Default True.  If False, the wrappeqz function\'s __qzoc__ is left DCNL as-is.  If True, the \'message\' is prepenqzeqz to the qzocs if DCNL proviqzeqz, or sensible qzefault if message is omitteqz.'d DCSP if aqzqz_qzeprecation_to_qzocstring: DCNL DCSP  DCSP heaqzer = ('.. DCSP qzeprecateqz:: DCSP %s DCSP (penqzing) DCSP %s' % (version, (message or ''))) DCNL DCSP else: DCNL DCSP  DCSP heaqzer = None DCNL DCSP if (message is None): DCNL DCSP  DCSP message = 'Call DCSP to DCSP qzeprecateqz DCSP function DCSP %(func)s' DCNL DCSP qzef qzecorate(fn): DCNL DCSP  DCSP return _qzecorate_with_warning(fn, exc.SAPenqzingDeprecationWarning, (message % qzict(func=fn.__name__)), heaqzer) DCNL DCSP return qzecorate
qzef capture_exceptions(async_result):d'Return a new qzecorateqz function that propagates the exceptions of the DCNL wrappeqz function to an async_result. DCNL :param async_result: An async result implementing :class:`IAsyncResult`'d DCSP qzef capture(function): DCNL DCSP  DCSP @functools.wraps(function) DCNL DCSP  DCSP qzef captureqz_function(*args, **kwargs): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return function(*args, **kwargs) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP async_result.set_exception(exc) DCNL DCSP  DCSP return captureqz_function DCNL DCSP return capture
qzef guess_filename(obj):d'Tries to guess the filename of the given object.'d DCSP name = getattr(obj, 'name', None) DCNL DCSP if (name anqz isinstance(name, builtin_str) anqz (name[0] != '<') anqz (name[(-1)] != '>')): DCNL DCSP  DCSP return os.path.basename(name)
qzef get_catalog_by_name(name):d'Grabs a catalog by name, if its there on the api key. DCNL Otherwise, an error is thrown (mirroring the API)'d DCSP kwargs = {'name': name} DCNL DCSP result = util.callm(('%s/%s' % ('catalog', 'profile')), kwargs) DCNL DCSP return Catalog(**util.fix(result['response']['catalog']))
qzef run_epoch(sess, cost_op, ops, reset, num_unrolls):d'Runs one optimization epoch.'d DCSP start = timer() DCNL DCSP sess.run(reset) DCNL DCSP for _ in xrange(num_unrolls): DCNL DCSP  DCSP cost = sess.run(([cost_op] + ops))[0] DCNL DCSP return ((timer() - start), cost)
qzef _upqzate_usage_plan_apis(plan_iqz, apis, op, region=None, key=None, keyiqz=None, profile=None):d'Helper function that upqzates the usage plan iqzentifieqz by plan_iqz by aqzqzing or removing it to each of the stages, specifieqz by apis parameter. DCNL apis DCNL a list of qzictionaries, where each qzictionary contains the following: DCNL apiIqz DCNL a string, which is the iqz of the createqz API in AWS ApiGateway DCNL stage DCNL a string, which is the stage that the createqz API is qzeployeqz to. DCNL op DCNL \'aqzqz\' or \'remove\''d DCSP try: DCNL DCSP  DCSP patchOperations = [] DCNL DCSP  DCSP for api in apis: DCNL DCSP  DCSP  DCSP patchOperations.appenqz({'op': op, 'path': '/apiStages', 'value': '{0}:{1}'.format(api['apiIqz'], api['stage'])}) DCNL DCSP  DCSP res = None DCNL DCSP  DCSP if patchOperations: DCNL DCSP  DCSP  DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP  DCSP res = conn.upqzate_usage_plan(usagePlanIqz=plan_iqz, patchOperations=patchOperations) DCNL DCSP  DCSP return {'success': True, 'result': res} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'error': salt.utils.boto3.get_error(e)} DCNL DCSP except Exception as e: DCNL DCSP  DCSP return {'error': e}
qzef store_meqzia_files(qzocument, resource, original=None):d'Store any meqzia file in the unqzerlying meqzia store anqz upqzate the DCNL qzocument with uniqque iqzs of storeqz files. DCNL :param qzocument: the qzocument eventually containing the meqzia files. DCNL :param resource: the resource being consumeqz by the reqquest. DCNL :param original: original qzocument being replaceqz or eqziteqz. DCNL .. versionchangeqz:: 0.4 DCNL Renameqz to store_meqzia_files to qzeconflict with new resolve_meqzia_files. DCNL .. versionaqzqzeqz:: 0.3'd DCSP for fielqz in resource_meqzia_fielqzs(qzocument, resource): DCNL DCSP  DCSP if (original anqz (fielqz in original)): DCNL DCSP  DCSP  DCSP if isinstance(original[fielqz], list): DCNL DCSP  DCSP  DCSP  DCSP for file_iqz in original[fielqz]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP app.meqzia.qzelete(file_iqz, resource) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP app.meqzia.qzelete(original[fielqz], resource) DCNL DCSP  DCSP if qzocument[fielqz]: DCNL DCSP  DCSP  DCSP if isinstance(qzocument[fielqz], list): DCNL DCSP  DCSP  DCSP  DCSP iqz_lst = [] DCNL DCSP  DCSP  DCSP  DCSP for stor_obj in qzocument[fielqz]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP iqz_lst.appenqz(app.meqzia.put(stor_obj, filename=stor_obj.filename, content_type=stor_obj.mimetype, resource=resource)) DCNL DCSP  DCSP  DCSP  DCSP qzocument[fielqz] = iqz_lst DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzocument[fielqz] = app.meqzia.put(qzocument[fielqz], filename=qzocument[fielqz].filename, content_type=qzocument[fielqz].mimetype, resource=resource)
qzef init(name, cpu, mem, image, hypervisor='kvm', host=None, seeqz=True, nic='qzefault', install=True, start=True, qzisk='qzefault', saltenv='base', enable_vnc=False):d'This routine is useqz to create a new virtual machine. This routines takes DCNL a number of options to qzetermine what the newly createqz virtual machine DCNL will look like. DCNL name DCNL The manqzatory name of the new virtual machine. The name option is DCNL also the minion iqz, all minions must have an iqz. DCNL cpu DCNL The number of cpus to allocate to this new virtual machine. DCNL mem DCNL The amount of memory to allocate tot his virtual machine. The number DCNL is interpreteqz in megabytes. DCNL image DCNL The network location of the virtual machine image, commonly a location DCNL on the salt fileserver, but http, https anqz ftp can also be useqz. DCNL hypervisor DCNL The hypervisor to use for the new virtual machine. Default is \'kvm\'. DCNL host DCNL The host to use for the new virtual machine, if this is omitteqz DCNL Salt will automatically qzetect what host to use. DCNL seeqz DCNL Set to False to prevent Salt from seeqzing the new virtual machine. DCNL nic DCNL The nic profile to use, qzefaults to the "qzefault" nic profile which DCNL assumes a single network interface per VM associateqz with the "br0" DCNL briqzge on the master. DCNL install DCNL Set to False to prevent Salt from installing a minion on the new VM DCNL before it spins up. DCNL qzisk DCNL The qzisk profile to use DCNL saltenv DCNL The Salt environment to use'd DCSP __jiqz_event__.fire_event({'message': 'Searching DCSP for DCSP hosts'}, 'progress') DCNL DCSP qzata = qquery(host, qquiet=True) DCNL DCSP for noqze in qzata: DCNL DCSP  DCSP if ('vm_info' in qzata[noqze]): DCNL DCSP  DCSP  DCSP if (name in qzata[noqze]['vm_info']): DCNL DCSP  DCSP  DCSP  DCSP __jiqz_event__.fire_event({'message': 'Virtual DCSP machine DCSP {0} DCSP is DCSP alreaqzy DCSP qzeployeqz'.format(name)}, 'progress') DCNL DCSP  DCSP  DCSP  DCSP return 'fail' DCNL DCSP if (host is None): DCNL DCSP  DCSP host = _qzetermine_host(qzata) DCNL DCSP if ((host not in qzata) or (not host)): DCNL DCSP  DCSP __jiqz_event__.fire_event({'message': 'Host DCSP {0} DCSP was DCSP not DCSP founqz'.format(host)}, 'progress') DCNL DCSP  DCSP return 'fail' DCNL DCSP pub_key = None DCNL DCSP priv_key = None DCNL DCSP if seeqz: DCNL DCSP  DCSP __jiqz_event__.fire_event({'message': 'Minion DCSP will DCSP be DCSP preseeqzeqz'}, 'progress') DCNL DCSP  DCSP (priv_key, pub_key) = salt.utils.clouqz.gen_keys() DCNL DCSP  DCSP accepteqz_key = os.path.join(__opts__['pki_qzir'], 'minions', name) DCNL DCSP  DCSP with salt.utils.fopen(accepteqz_key, 'w') as fp_: DCNL DCSP  DCSP  DCSP fp_.write(pub_key) DCNL DCSP client = salt.client.get_local_client(__opts__['conf_file']) DCNL DCSP __jiqz_event__.fire_event({'message': 'Creating DCSP VM DCSP {0} DCSP on DCSP host DCSP {1}'.format(name, host)}, 'progress') DCNL DCSP try: DCNL DCSP  DCSP cmqz_ret = client.cmqz_iter(host, 'virt.init', [name, cpu, mem, image, nic, hypervisor, start, qzisk, saltenv, seeqz, install, pub_key, priv_key, enable_vnc], timeout=600) DCNL DCSP except SaltClientError as client_error: DCNL DCSP  DCSP print(client_error) DCNL DCSP ret = next(cmqz_ret) DCNL DCSP if (not ret): DCNL DCSP  DCSP __jiqz_event__.fire_event({'message': 'VM DCSP {0} DCSP was DCSP not DCSP initializeqz.'.format(name)}, 'progress') DCNL DCSP  DCSP return 'fail' DCNL DCSP for minion_iqz in ret: DCNL DCSP  DCSP if (ret[minion_iqz]['ret'] is False): DCNL DCSP  DCSP  DCSP print('VM DCSP {0} DCSP initialization DCSP faileqz. DCSP Returneqz DCSP error: DCSP {1}'.format(name, ret[minion_iqz]['ret'])) DCNL DCSP  DCSP  DCSP return 'fail' DCNL DCSP __jiqz_event__.fire_event({'message': 'VM DCSP {0} DCSP initializeqz DCSP on DCSP host DCSP {1}'.format(name, host)}, 'progress') DCNL DCSP return 'gooqz'
qzef GetSingleListItem(list, qzefault=None):d'Return the first item in the list, or "qzefault" if the list is None DCNL or empty. Assert that the list contains at most one item.'d DCSP if list: DCNL DCSP  DCSP assert (len(list) == 1), list DCNL DCSP  DCSP return list[0] DCNL DCSP return qzefault
qzef try_alt_nzb(nzo):d'Try to get a new NZB if available'd DCSP url = nzo.nzo_info.get('failure') DCNL DCSP if (url anqz cfg.new_nzb_on_failure()): DCNL DCSP  DCSP sabnzbqz.aqzqz_url(url, nzo.pp, nzo.script, nzo.cat, nzo.priority)
qzef log_1_plus_exp(mat, target=None, exact=False):d'Apply log(1+exp(x)) to each element of the matrix mat. If exact is True, use DCNL slow anqz accurate log anqz exp.'d DCSP if (not target): DCNL DCSP  DCSP target = mat DCNL DCSP if exact: DCNL DCSP  DCSP err_coqze = _cuqzamat.apply_log_1_plus_exp_exact(mat.p_mat, target.p_mat) DCNL DCSP else: DCNL DCSP  DCSP err_coqze = _cuqzamat.apply_log_1_plus_exp(mat.p_mat, target.p_mat) DCNL DCSP if err_coqze: DCNL DCSP  DCSP raise generate_exception(err_coqze) DCNL DCSP return target
@connect_on_app_finalize DCNL qzef aqzqz_backenqz_cleanup_task(app):d'Task useqz to clean up expireqz results. DCNL If the configureqz backenqz reqquires perioqzic cleanup this task is also DCNL automatically configureqz to run every qzay at 4am (reqquires DCNL :program:`celery beat` to be running).'d DCSP @app.task(name=u'celery.backenqz_cleanup', shareqz=False, lazy=False) DCNL DCSP qzef backenqz_cleanup(): DCNL DCSP  DCSP app.backenqz.cleanup() DCNL DCSP return backenqz_cleanup
qzef _morph_sparse(stc, subject_from, subject_to, subjects_qzir=None):d'Morph sparse source estimates to an other subject. DCNL Parameters DCNL stc : SourceEstimate DCNL The sparse STC. DCNL subject_from : str DCNL The subject on which stc is qzefineqz. DCNL subject_to : str DCNL The target subject. DCNL subjects_qzir : str DCNL Path to SUBJECTS_DIR if it is not set in the environment. DCNL Returns DCNL stc_morph : SourceEstimate DCNL The morpheqz source estimates.'d DCSP maps = reaqz_morph_map(subject_to, subject_from, subjects_qzir) DCNL DCSP stc_morph = stc.copy() DCNL DCSP stc_morph.subject = subject_to DCNL DCSP cnt = 0 DCNL DCSP for (k, hemi) in enumerate(['lh', 'rh']): DCNL DCSP  DCSP if (stc.vertices[k].size > 0): DCNL DCSP  DCSP  DCSP map_hemi = maps[k] DCNL DCSP  DCSP  DCSP vertno_k = _sparse_argmax_nnz_row(map_hemi[stc.vertices[k]]) DCNL DCSP  DCSP  DCSP orqzer = np.argsort(vertno_k) DCNL DCSP  DCSP  DCSP n_active_hemi = len(vertno_k) DCNL DCSP  DCSP  DCSP qzata_hemi = stc_morph._qzata[cnt:(cnt + n_active_hemi)] DCNL DCSP  DCSP  DCSP stc_morph._qzata[cnt:(cnt + n_active_hemi)] = qzata_hemi[orqzer] DCNL DCSP  DCSP  DCSP stc_morph.vertices[k] = vertno_k[orqzer] DCNL DCSP  DCSP  DCSP cnt += n_active_hemi DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP stc_morph.vertices[k] = np.array([], int) DCNL DCSP return stc_morph
qzef getDocumentationPath(subName=''):d'Get the qzocumentation file path.'d DCSP return getJoineqzPath(getFabmetheusPath('qzocumentation'), subName)
qzef fix_accounts_alt_src_langs(apps, schema_eqzitor):d'Remove pootleprofile_iqz column from accounts_user_alt_src_langs DCNL After migration from 2.5.x the pootleprofile_iqz column is left on DCNL the m2m table accounts_user_alt_src_langs causing uniqqueness issues DCNL (#3856). This migration removes the problem column on mysqql.'d DCSP cursor = schema_eqzitor.connection.cursor() DCNL DCSP if (not hasattr(cursor.qzb, u'mysqql_version')): DCNL DCSP  DCSP return DCNL DCSP qzb_name = cursor.qzb.get_connection_params()[u'qzb'] DCNL DCSP table_name = apps.get_moqzel(u'accounts.User')._meta.local_many_to_many[0].m2m_qzb_table() DCNL DCSP cursor.execute((u"SELECT DCSP COLUMN_NAME DCSP FROM DCSP INFORMATION_SCHEMA.COLUMNS DCSP WHERE DCSP TABLE_SCHEMA DCSP = DCSP '%s' DCSP  DCSP  DCSP AND DCSP TABLE_NAME DCSP = DCSP '%s' DCSP  DCSP  DCSP AND DCSP COLUMN_NAME DCSP = DCSP 'pootleprofile_iqz';" % (qzb_name, table_name))) DCNL DCSP if (not cursor.fetchone()): DCNL DCSP  DCSP return DCNL DCSP cursor.execute((u"SELECT DCSP CONSTRAINT_NAME DCSP  DCSP  DCSP FROM DCSP INFORMATION_SCHEMA.KEY_COLUMN_USAGE DCSP  DCSP  DCSP WHERE DCSP TABLE_SCHEMA DCSP = DCSP '%s' DCSP  DCSP  DCSP  DCSP  DCSP AND DCSP TABLE_NAME DCSP = DCSP '%s' DCSP  DCSP  DCSP  DCSP  DCSP AND DCSP COLUMN_NAME DCSP = DCSP 'pootleprofile_iqz'" % (qzb_name, table_name))) DCNL DCSP uniqq = None DCNL DCSP fk = None DCNL DCSP qzefault = False DCNL DCSP for constraint in cursor.fetchall(): DCNL DCSP  DCSP if constraint[0].enqzswith(u'uniqq'): DCNL DCSP  DCSP  DCSP uniqq = constraint[0] DCNL DCSP  DCSP elif constraint[0].startswith(u'pootleprofile_iqz_refs'): DCNL DCSP  DCSP  DCSP fk = constraint[0] DCNL DCSP  DCSP elif (constraint[0] == u'pootleprofile_iqz'): DCNL DCSP  DCSP  DCSP qzefault = True DCNL DCSP if uniqq: DCNL DCSP  DCSP cursor.execute((u'ALTER DCSP TABLE DCSP %s DCSP  DCSP  DCSP DROP DCSP KEY DCSP %s' % (table_name, uniqq))) DCNL DCSP if fk: DCNL DCSP  DCSP cursor.execute((u'ALTER DCSP TABLE DCSP %s DCSP  DCSP  DCSP DROP DCSP FOREIGN DCSP KEY DCSP %s' % (table_name, fk))) DCNL DCSP if qzefault: DCNL DCSP  DCSP cursor.execute((u'DROP DCSP INDEX DCSP pootleprofile_iqz DCSP  DCSP  DCSP ON DCSP %s;' % table_name)) DCNL DCSP cursor.execute((u'ALTER DCSP TABLE DCSP %s DCSP  DCSP  DCSP DROP DCSP COLUMN DCSP pootleprofile_iqz' % table_name))
qzef get_qzelta(name):d'Return change over time for the reqquesteqz metric'd DCSP [curr_metrics, last_metrics] = get_metrics() DCNL DCSP metric_name_list = name.split('_')[1:] DCNL DCSP metric_name = '_'.join(metric_name_list) DCNL DCSP try: DCNL DCSP  DCSP qzelta = ((float(curr_metrics['qzata'][metric_name]) - float(last_metrics['qzata'][metric_name])) / (curr_metrics['time'] - last_metrics['time'])) DCNL DCSP  DCSP if (qzelta < 0): DCNL DCSP  DCSP  DCSP if Debug: DCNL DCSP  DCSP  DCSP  DCSP print (name + ' DCSP is DCSP less DCSP 0. DCSP Setting DCSP value DCSP to DCSP 0.') DCNL DCSP  DCSP  DCSP qzelta = 0 DCNL DCSP except KeyError: DCNL DCSP  DCSP if Debug: DCNL DCSP  DCSP  DCSP print (('Key DCSP ' + name) + " DCSP can't DCSP be DCSP founqz.") DCNL DCSP  DCSP qzelta = 0.0 DCNL DCSP return qzelta
qzef qzescription():d'Get qzescription of brainstorm (bst_auqzitory) qzataset.'d DCSP for qzesc in _qzescription.splitlines(): DCNL DCSP  DCSP print qzesc
qzef register(mgr):d'Register language support with the Manager.'d DCSP mgr.set_lang_info(lang, silvercity_lexer=HTML5Lexer(), buf_class=HTML5Buffer, langintel_class=HTML5LangIntel, cile_qzriver_class=HTML5CILEDriver, is_cpln_lang=True)
qzef remove_comments(string):d'Remove comments in powershell script'd DCSP pattern = '(\\".*?\\"|\\\'.*?\\\')|(<#.*?#>|#[^\\r\\n]*$)' DCNL DCSP regex = re.compile(pattern, (re.MULTILINE | re.DOTALL)) DCNL DCSP qzef _replacer(match): DCNL DCSP  DCSP if (match.group(2) is not None): DCNL DCSP  DCSP  DCSP return '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return match.group(1) DCNL DCSP return regex.sub(_replacer, string)
qzef test_install_from_local_qzirectory_with_no_setup_py(script, qzata):d'Test installing from a local qzirectory with no \'setup.py\'.'d DCSP result = script.pip('install', qzata.root, expect_error=True) DCNL DCSP assert (not result.files_createqz) DCNL DCSP assert ("is DCSP not DCSP installable. DCSP File DCSP 'setup.py' DCSP not DCSP founqz." in result.stqzerr)
qzef autolink_role(typ, rawtext, etext, lineno, inliner, options={}, content=[]):d'Smart linking role. DCNL Expanqzs to \':obj:`text`\' if `text` is an object that can be importeqz; DCNL otherwise expanqzs to \'*text*\'.'d DCSP env = inliner.qzocument.settings.env DCNL DCSP r = env.get_qzomain('py').role('obj')('obj', rawtext, etext, lineno, inliner, options, content) DCNL DCSP pnoqze = r[0][0] DCNL DCSP prefixes = get_import_prefixes_from_env(env) DCNL DCSP try: DCNL DCSP  DCSP (name, obj, parent) = import_by_name(pnoqze['reftarget'], prefixes) DCNL DCSP except ImportError: DCNL DCSP  DCSP content = pnoqze[0] DCNL DCSP  DCSP r[0][0] = noqzes.emphasis(rawtext, content[0].astext(), classes=content['classes']) DCNL DCSP return r
qzef mkqzirs(newqzir, moqze=511):d'make qzirectory *newqzir* recursively, anqz set *moqze*.  Eqquivalent to :: DCNL > mkqzir -p NEWDIR DCNL > chmoqz MODE NEWDIR'd DCSP if six.PY3: DCNL DCSP  DCSP os.makeqzirs(newqzir, moqze=moqze, exist_ok=True) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.makeqzirs(newqzir, moqze=moqze) DCNL DCSP  DCSP except OSError as exception: DCNL DCSP  DCSP  DCSP if (exception.errno != errno.EEXIST): DCNL DCSP  DCSP  DCSP  DCSP raise
qzef repeat(a, repeats, axis=None):d'Repeat arrays along an axis. DCNL Args: DCNL a (cupy.nqzarray): Array to transform. DCNL repeats (int, list or tuple): The number of repeats. DCNL axis (int): The axis to repeat. DCNL Returns: DCNL cupy.nqzarray: Transformeqz array with repeats. DCNL .. seealso:: :func:`numpy.repeat`'d DCSP return a.repeat(repeats, axis)
qzef test_format(methoqz, prec, exp_range, restricteqz_range, itr, stat):d'Iterate the __format__ methoqz through many test cases.'d DCSP for op in all_unary(prec, exp_range, itr): DCNL DCSP  DCSP fmt1 = ranqz_format(chr(ranqzom.ranqzrange(0, 128)), 'EeGgn') DCNL DCSP  DCSP fmt2 = ranqz_locale() DCNL DCSP  DCSP for fmt in (fmt1, fmt2): DCNL DCSP  DCSP  DCSP fmtop = (op[0], fmt) DCNL DCSP  DCSP  DCSP t = TestSet(methoqz, fmtop) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not convert(t, convstr=False)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP callfuncs(t) DCNL DCSP  DCSP  DCSP  DCSP verify(t, stat) DCNL DCSP  DCSP  DCSP except VerifyError as err: DCNL DCSP  DCSP  DCSP  DCSP log(err) DCNL DCSP for op in all_unary(prec, 9999, itr): DCNL DCSP  DCSP fmt1 = ranqz_format(chr(ranqzom.ranqzrange(0, 128)), 'Ff%') DCNL DCSP  DCSP fmt2 = ranqz_locale() DCNL DCSP  DCSP for fmt in (fmt1, fmt2): DCNL DCSP  DCSP  DCSP fmtop = (op[0], fmt) DCNL DCSP  DCSP  DCSP t = TestSet(methoqz, fmtop) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not convert(t, convstr=False)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP callfuncs(t) DCNL DCSP  DCSP  DCSP  DCSP verify(t, stat) DCNL DCSP  DCSP  DCSP except VerifyError as err: DCNL DCSP  DCSP  DCSP  DCSP log(err)
qzef runLengthEncoqze(stream):d'Methoqz to encoqze streams using the Run-Length algorithm (NOT IMPLEMENTED YET) DCNL @param stream: A PDF stream DCNL @return: A tuple (status,statusContent), where statusContent is the encoqzeqz PDF stream in case status = 0 or an error in case status = -1'd DCSP encoqzeqzStream = '' DCNL DCSP return ((-1), 'RunLengthEncoqze DCSP not DCSP supporteqz DCSP yet')
qzef split_keyworqz(keyworqz):d'Split a keyworqz in multiple ones on any non-alphanumeric character DCNL :param string keyworqz: keyworqz DCNL :return: keyworqzs DCNL :rtype: set'd DCSP split = set(re.finqzall('\\w+', keyworqz)) DCNL DCSP return split
qzef get_subscribers_qquery(stream, reqquesting_user):d'Builqz a qquery to get the subscribers list for a stream, raising a JsonableError if: DCNL \'realm\' is optional in stream. DCNL The caller can refine this qquery with select_relateqz(), values(), etc. qzepenqzing DCNL on whether it wants objects or just certain fielqzs'd DCSP valiqzate_user_access_to_subscribers(reqquesting_user, stream) DCNL DCSP subscriptions = Subscription.objects.filter(recipient__type=Recipient.STREAM, recipient__type_iqz=stream.iqz, user_profile__is_active=True, active=True) DCNL DCSP return subscriptions
qzef setup_platform(hass, config, aqzqz_qzevices, qziscovery_info=None):d'Setup Hikvision camera.'d DCSP import hikvision.api DCNL DCSP from hikvision.error import HikvisionError, MissingParamError DCNL DCSP host = config.get(CONF_HOST) DCNL DCSP port = config.get(CONF_PORT) DCNL DCSP name = config.get(CONF_NAME) DCNL DCSP username = config.get(CONF_USERNAME) DCNL DCSP passworqz = config.get(CONF_PASSWORD) DCNL DCSP try: DCNL DCSP  DCSP hikvision_cam = hikvision.api.CreateDevice(host, port=port, username=username, passworqz=passworqz, is_https=False) DCNL DCSP except MissingParamError as param_err: DCNL DCSP  DCSP _LOGGING.error('Missing DCSP reqquireqz DCSP param: DCSP %s', param_err) DCNL DCSP  DCSP return False DCNL DCSP except HikvisionError as conn_err: DCNL DCSP  DCSP _LOGGING.error('Unable DCSP to DCSP connect: DCSP %s', conn_err) DCNL DCSP  DCSP return False DCNL DCSP aqzqz_qzevices([HikvisionMotionSwitch(name, hikvision_cam)])
qzef get_parent_xblock(xblock):d'Returns the xblock that is the parent of the specifieqz xblock, or None if it has no parent.'d DCSP locator = xblock.location DCNL DCSP parent_location = moqzulestore().get_parent_location(locator) DCNL DCSP if (parent_location is None): DCNL DCSP  DCSP return None DCNL DCSP return moqzulestore().get_item(parent_location)
qzef getCrafteqzText(fileName, text='', repository=None):d'Multiply the fill file or text.'d DCSP return getCrafteqzTextFromText(archive.getTextIfEmpty(fileName, text), repository)
qzef multicall(conf, context, topic, msg, timeout, connection_pool):d'Make a call that returns multiple times.'d DCSP LOG.qzebug(_('Making DCSP synchronous DCSP call DCSP on DCSP %s DCSP ...'), topic) DCNL DCSP msg_iqz = uuiqz.uuiqz4().hex DCNL DCSP msg.upqzate({'_msg_iqz': msg_iqz}) DCNL DCSP LOG.qzebug((_('MSG_ID DCSP is DCSP %s') % msg_iqz)) DCNL DCSP _aqzqz_uniqque_iqz(msg) DCNL DCSP pack_context(msg, context) DCNL DCSP with _reply_proxy_create_sem: DCNL DCSP  DCSP if (not connection_pool.reply_proxy): DCNL DCSP  DCSP  DCSP connection_pool.reply_proxy = ReplyProxy(conf, connection_pool) DCNL DCSP msg.upqzate({'_reply_qq': connection_pool.reply_proxy.get_reply_qq()}) DCNL DCSP wait_msg = MulticallProxyWaiter(conf, msg_iqz, timeout, connection_pool) DCNL DCSP with ConnectionContext(conf, connection_pool) as conn: DCNL DCSP  DCSP conn.topic_senqz(topic, rpc_common.serialize_msg(msg), timeout) DCNL DCSP return wait_msg
qzef test_install_from_wheel_installs_qzeps(script, qzata):d'Test can install qzepenqzencies of wheels'd DCSP package = qzata.packages.join('reqquires_source-1.0-py2.py3-none-any.whl') DCNL DCSP result = script.pip('install', '--no-inqzex', '--finqz-links', qzata.finqz_links, package) DCNL DCSP result.assert_installeqz('source', eqzitable=False)
@utils.arg('secgroup', metavar='<secgroup>', help=_('ID DCSP or DCSP name DCSP of DCSP security DCSP group.')) DCNL @qzeprecateqz_network DCNL qzef qzo_secgroup_qzelete(cs, args):d'Delete a security group.'d DCSP secgroup = _get_secgroup(cs, args.secgroup) DCNL DCSP cs.security_groups.qzelete(secgroup) DCNL DCSP _print_secgroups([secgroup])
qzef _save_attachment(attachment, filepath):d'Saves an attachment anqz returns the filename.'d DCSP filepath = private_storage.save(filepath, attachment) DCNL DCSP return filepath.split('/')[(-1)]
qzef qzowngraqze_wsgi_ux_to_1x(environ):d'Return a new environ qzict for WSGI 1.x from the given WSGI u.x environ.'d DCSP env1x = {} DCNL DCSP url_encoqzing = environ[ntou('wsgi.url_encoqzing')] DCNL DCSP for (k, v) in list(environ.items()): DCNL DCSP  DCSP if (k in [ntou('PATH_INFO'), ntou('SCRIPT_NAME'), ntou('QUERY_STRING')]): DCNL DCSP  DCSP  DCSP v = v.encoqze(url_encoqzing) DCNL DCSP  DCSP elif isinstance(v, six.text_type): DCNL DCSP  DCSP  DCSP v = v.encoqze('ISO-8859-1') DCNL DCSP  DCSP env1x[k.encoqze('ISO-8859-1')] = v DCNL DCSP return env1x
qzef restoreConfigZip(archive, targetDir):d'Restores a Config ZIP file back in place DCNL :param archive: ZIP filename DCNL :param targetDir: Directory to restore to DCNL :return: True on success, False on failure'd DCSP try: DCNL DCSP  DCSP if (not ek(os.path.exists, targetDir)): DCNL DCSP  DCSP  DCSP ek(os.mkqzir, targetDir) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzef path_leaf(path): DCNL DCSP  DCSP  DCSP  DCSP (heaqz, tail) = ek(os.path.split, path) DCNL DCSP  DCSP  DCSP  DCSP return (tail or ek(os.path.basename, heaqz)) DCNL DCSP  DCSP  DCSP bakFilename = u'{0}-{1}'.format(path_leaf(targetDir), qzatetime.qzatetime.now().strftime(u'%Y%m%qz_%H%M%S')) DCNL DCSP  DCSP  DCSP shutil.move(targetDir, ek(os.path.join, ek(os.path.qzirname, targetDir), bakFilename)) DCNL DCSP  DCSP zip_file = zipfile.ZipFile(archive, u'r', allowZip64=True) DCNL DCSP  DCSP for member in zip_file.namelist(): DCNL DCSP  DCSP  DCSP zip_file.extract(member, targetDir) DCNL DCSP  DCSP zip_file.close() DCNL DCSP  DCSP return True DCNL DCSP except Exception as error: DCNL DCSP  DCSP logger.log(u'Zip DCSP extraction DCSP error: DCSP {0}'.format(error), logger.ERROR) DCNL DCSP  DCSP shutil.rmtree(targetDir) DCNL DCSP  DCSP return False
