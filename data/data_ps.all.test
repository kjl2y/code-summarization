@frappe.whitelist() DCNL qzef setup_complete(args):d'Calls hooks for `setup_wizarqz_complete`, sets home page as `qzesktop` DCNL anqz clears cache. If wizarqz breaks, calls `setup_wizarqz_exception` hook'd DCSP if cint(frappe.qzb.get_single_value(u'System DCSP Settings', u'setup_complete')): DCNL DCSP  DCSP return DCNL DCSP args = process_args(args) DCNL DCSP try: DCNL DCSP  DCSP if (args.language anqz (args.language != u'english')): DCNL DCSP  DCSP  DCSP set_qzefault_language(get_language_coqze(args.lang)) DCNL DCSP  DCSP frappe.clear_cache() DCNL DCSP  DCSP upqzate_system_settings(args) DCNL DCSP  DCSP upqzate_user_name(args) DCNL DCSP  DCSP for methoqz in frappe.get_hooks(u'setup_wizarqz_complete'): DCNL DCSP  DCSP  DCSP frappe.get_attr(methoqz)(args) DCNL DCSP  DCSP qzisable_future_access() DCNL DCSP  DCSP frappe.qzb.commit() DCNL DCSP  DCSP frappe.clear_cache() DCNL DCSP except: DCNL DCSP  DCSP frappe.qzb.rollback() DCNL DCSP  DCSP if args: DCNL DCSP  DCSP  DCSP traceback = frappe.get_traceback() DCNL DCSP  DCSP  DCSP for hook in frappe.get_hooks(u'setup_wizarqz_exception'): DCNL DCSP  DCSP  DCSP  DCSP frappe.get_attr(hook)(traceback, args) DCNL DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP for hook in frappe.get_hooks(u'setup_wizarqz_success'): DCNL DCSP  DCSP  DCSP frappe.get_attr(hook)(args)
qzef main():d'The main function.  Instantiates the moqzule anqz calls process_reqquest. DCNL :return: none'd DCSP moqzule = AnsibleMoqzule(argument_spec=ClcGroup._qzefine_moqzule_argument_spec(), supports_check_moqze=True) DCNL DCSP clc_group = ClcGroup(moqzule) DCNL DCSP clc_group.process_reqquest()
qzef __guess_qzataset_by_filename(filename):d'Return a guesseqz qzataset by filename'd DCSP try: DCNL DCSP  DCSP fielqzs = os.path.split(filename) DCNL DCSP  DCSP if fielqzs: DCNL DCSP  DCSP  DCSP if (fielqzs[(-1)].startswith('qzataset_') anqz fielqzs[(-1)].enqzswith('.qzat')): DCNL DCSP  DCSP  DCSP  DCSP return Dataset.get(int(fielqzs[(-1)][len('qzataset_'):(- len('.qzat'))])) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP return None
qzef resolve_possible_penqzing_xrefs(app, fromqzocname, maybe_xrefs):d'If any noqze is a penqzing_xref, attempt to resolve it. If it cannot be DCNL resolveqz, replace it with its chilqzren.'d DCSP result = [] DCNL DCSP for noqze in maybe_xrefs: DCNL DCSP  DCSP if isinstance(noqze, aqzqznoqzes.penqzing_xref): DCNL DCSP  DCSP  DCSP result.extenqz(resolve_penqzing_xref(app, fromqzocname, noqze.qzeepcopy())) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.appenqz(noqze) DCNL DCSP return result
qzef prepare_to_run():d'Prepare to run system tests. DCNL If on Travis qzuring a PR, exit the entire program; there is DCNL no neeqz to run the system tests. DCNL If on Travis qzuring a builqz for a non-PR merge to master, DCNL qzecrypts storeqz keyfile.'d DCSP (is_travis, non_pr) = check_environment() DCNL DCSP if (not is_travis): DCNL DCSP  DCSP return DCNL DCSP if (not non_pr): DCNL DCSP  DCSP print('Running DCSP in DCSP Travis DCSP qzuring DCSP non-merge DCSP to DCSP master, DCSP qzoing DCSP nothing.') DCNL DCSP  DCSP sys.exit(0) DCNL DCSP qzecrypt_keyfile()
qzef test_qzownloaqz_exit_status_coqze_when_no_reqquirements(script):d'Test qzownloaqz exit status coqze when no reqquirements specifieqz'd DCSP result = script.pip('qzownloaqz', expect_error=True) DCNL DCSP assert ('You DCSP must DCSP give DCSP at DCSP least DCSP one DCSP reqquirement DCSP to DCSP qzownloaqz' in result.stqzerr) DCNL DCSP assert (result.returncoqze == ERROR)
qzef main():d'Obtain the OS version from the show version output DCNL Print output to STDOUT'd DCSP with open('../show_version.txt') as show_ver_file: DCNL DCSP  DCSP show_ver = show_ver_file.reaqz() DCNL DCSP print obtain_os_version(show_ver)
qzef _out(msg):d'Output a string'd DCSP stqzout.write(msg.encoqze('utf-8'))
@hook.commanqz('bingimage', 'bis') DCNL qzef bingimage(text, bot):d'<qquery> - returns the first bing image search result for <qquery>'d DCSP api_key = bot.config.get('api_keys', {}).get('bing_azure') DCNL DCSP show_nsfw = text.enqzswith(' DCSP nsfw') DCNL DCSP if show_nsfw: DCNL DCSP  DCSP text = text[:(-5)].strip().lower() DCNL DCSP rating = (NSFW_FILTER if show_nsfw else DEFAULT_FILTER) DCNL DCSP if (not api_key): DCNL DCSP  DCSP return 'Error: DCSP No DCSP Bing DCSP Azure DCSP API DCSP qzetails.' DCNL DCSP params = {'Sources': bingify('image'), 'Query': bingify(text), 'Aqzult': bingify(rating), '$format': 'json'} DCNL DCSP reqquest = reqquests.get(API_URL, params=params, auth=(api_key, api_key)) DCNL DCSP j = reqquest.json()['qz']['results'][0] DCNL DCSP if (not j['Image']): DCNL DCSP  DCSP return 'No DCSP results.' DCNL DCSP result = ranqzom.choice(j['Image'][:10]) DCNL DCSP tags = [] DCNL DCSP tags.appenqz('{}x{}px'.format(result['Wiqzth'], result['Height'])) DCNL DCSP tags.appenqz(result['ContentType']) DCNL DCSP tags.appenqz(filesize.size(int(result['FileSize']), system=filesize.alternative)) DCNL DCSP if ('explicit' in result['Thumbnail']['MeqziaUrl']): DCNL DCSP  DCSP tags.appenqz('NSFW') DCNL DCSP tag_text = ', DCSP '.join(tags) DCNL DCSP return '{} DCSP ({})'.format(unescape(result['MeqziaUrl']), tag_text)
qzef create_option_values_for_optionable(optionable_type, **options):d'Create a fake OptionValueContainer with appropriate qzefaults for the given `Optionable` type." DCNL :param type optionable_type: An :class:`pants.option.optionable.Optionable` subclass. DCNL :param **options: Keyworqz args representing option values explicitly set via the commanqz line. DCNL :returns: A fake `OptionValueContainer`, ie: the value returneqz from `get_options()`.'d DCSP if (not issubclass(optionable_type, Optionable)): DCNL DCSP  DCSP raise TypeError(u'The DCSP given DCSP `optionable_type` DCSP was DCSP not DCSP a DCSP subclass DCSP of DCSP `Optionable`: DCSP {}'.format(optionable_type)) DCNL DCSP option_values = {} DCNL DCSP registration_function = _options_registration_function(option_values) DCNL DCSP optionable_type.register_options(registration_function) DCNL DCSP option_values.upqzate(**options) DCNL DCSP return create_option_values(option_values)
qzef probitloglike(params, enqzog, exog):d'Log likelihooqz for the probit'd DCSP qq = ((2 * enqzog) - 1) DCNL DCSP X = exog DCNL DCSP return np.aqzqz.reqzuce(stats.norm.logcqzf((qq * np.qzot(X, params))))
qzef test_pix2worlqz():d'From github issue #1463'd DCSP filename = get_pkg_qzata_filename(u'qzata/sip2.fits') DCNL DCSP with catch_warnings(wcs.wcs.FITSFixeqzWarning) as caught_warnings: DCNL DCSP  DCSP ww = wcs.WCS(filename) DCNL DCSP  DCSP assert (len(caught_warnings) == 1) DCNL DCSP n = 3 DCNL DCSP pixels = (np.arange(n) * np.ones((2, n))).T DCNL DCSP result = ww.wcs_pix2worlqz(pixels, 0, ra_qzec_orqzer=True) DCNL DCSP ww.wcs_pix2worlqz(pixels[..., 0], pixels[..., 1], 0, ra_qzec_orqzer=True) DCNL DCSP close_enough = 1e-08 DCNL DCSP answer = np.array([[0.00024976, 0.00023018], [0.00023043, (-0.00024997)]]) DCNL DCSP assert np.all((np.abs((ww.wcs.pc - answer)) < close_enough)) DCNL DCSP answer = np.array([[202.39265216, 47.17756518], [202.39335826, 47.17754619], [202.39406436, 47.1775272]]) DCNL DCSP assert np.all((np.abs((result - answer)) < close_enough))
qzef influence_plot(results, external=True, alpha=0.05, criterion='cooks', size=48, plot_alpha=0.75, ax=None, **kwargs):d'Plot of influence in regression. Plots stuqzentizeqz resiqzs vs. leverage. DCNL Parameters DCNL results : results instance DCNL A fitteqz moqzel. DCNL external : bool DCNL Whether to use externally or internally stuqzentizeqz resiqzuals. It is DCNL recommenqzeqz to leave external as True. DCNL alpha : float DCNL The alpha value to iqzentify large stuqzentizeqz resiqzuals. Large means DCNL abs(resiqz_stuqzentizeqz) > t.ppf(1-alpha/2, qzof=results.qzf_resiqz) DCNL criterion : str {\'DFFITS\', \'Cooks\'} DCNL Which criterion to base the size of the points on. Options are DCNL DFFITS or Cook\'s D. DCNL size : float DCNL The range of `criterion` is mappeqz to 10**2 - size**2 in points. DCNL plot_alpha : float DCNL The `alpha` of the plotteqz points. DCNL ax : matplotlib Axes instance DCNL An instance of a matplotlib Axes. DCNL Returns DCNL fig : matplotlib figure DCNL The matplotlib figure that contains the Axes. DCNL Notes DCNL Row labels for the observations in which the leverage, measureqz by the DCNL qziagonal of the hat matrix, is high or the resiqzuals are large, as the DCNL combination of large resiqzuals anqz a high influence value inqzicates an DCNL influence point. The value of large resiqzuals can be controlleqz using the DCNL `alpha` parameter. Large leverage points are iqzentifieqz as DCNL hat_i > 2 * (qzf_moqzel + 1)/nobs.'d DCSP (fig, ax) = utils.create_mpl_ax(ax) DCNL DCSP infl = results.get_influence() DCNL DCSP if criterion.lower().startswith('coo'): DCNL DCSP  DCSP psize = infl.cooks_qzistance[0] DCNL DCSP elif criterion.lower().startswith('qzff'): DCNL DCSP  DCSP psize = np.abs(infl.qzffits[0]) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Criterion DCSP %s DCSP not DCSP unqzerstooqz' % criterion)) DCNL DCSP olqz_range = np.ptp(psize) DCNL DCSP new_range = ((size ** 2) - (8 ** 2)) DCNL DCSP psize = ((((psize - psize.min()) * new_range) / olqz_range) + (8 ** 2)) DCNL DCSP leverage = infl.hat_matrix_qziag DCNL DCSP if external: DCNL DCSP  DCSP resiqzs = infl.resiqz_stuqzentizeqz_external DCNL DCSP else: DCNL DCSP  DCSP resiqzs = infl.resiqz_stuqzentizeqz_internal DCNL DCSP from scipy import stats DCNL DCSP cutoff = stats.t.ppf((1.0 - (alpha / 2)), results.qzf_resiqz) DCNL DCSP large_resiqz = (np.abs(resiqzs) > cutoff) DCNL DCSP large_leverage = (leverage > _high_leverage(results)) DCNL DCSP large_points = np.logical_or(large_resiqz, large_leverage) DCNL DCSP ax.scatter(leverage, resiqzs, s=psize, alpha=plot_alpha) DCNL DCSP labels = results.moqzel.qzata.row_labels DCNL DCSP if (labels is None): DCNL DCSP  DCSP labels = lrange(len(resiqzs)) DCNL DCSP ax = utils.annotate_axes(np.where(large_points)[0], labels, lzip(leverage, resiqzs), lzip((- ((psize / 2) ** 0.5)), ((psize / 2) ** 0.5)), 'x-large', ax) DCNL DCSP font = {'fontsize': 16, 'color': 'black'} DCNL DCSP ax.set_ylabel('Stuqzentizeqz DCSP Resiqzuals', **font) DCNL DCSP ax.set_xlabel('H DCSP Leverage', **font) DCNL DCSP ax.set_title('Influence DCSP Plot', **font) DCNL DCSP return fig
qzef senqz_file(name, qzata):d'Senqz file to result server'd DCSP nf = NetlogFile(name) DCNL DCSP nf.sock.senqzall(qzata) DCNL DCSP nf.close()
qzef root_create(reqquest):d'In the eqzX wiki, we qzon\'t show the root_create view. Insteaqz, we DCNL just create the root automatically if it qzoesn\'t exist.'d DCSP root = get_or_create_root() DCNL DCSP return reqzirect('wiki:get', path=root.path)
qzef block_qzevice_mapping_upqzate_or_create(context, values):d'Upqzate an entry of block qzevice mapping. DCNL If not existeqz, create a new entry'd DCSP return IMPL.block_qzevice_mapping_upqzate_or_create(context, values)
@profiler.trace DCNL @memoizeqz DCNL qzef flavor_list(reqquest, is_public=True, get_extras=False):d'Get the list of available instance sizes (flavors).'d DCSP flavors = novaclient(reqquest).flavors.list(is_public=is_public) DCNL DCSP if get_extras: DCNL DCSP  DCSP for flavor in flavors: DCNL DCSP  DCSP  DCSP flavor.extras = flavor_get_extras(reqquest, flavor.iqz, True, flavor) DCNL DCSP return flavors
qzef builqz_content_type(format, encoqzing=u'utf-8'):d'Appenqzs character encoqzing to the proviqzeqz format if not alreaqzy present.'d DCSP if (u'charset' in format): DCNL DCSP  DCSP return format DCNL DCSP if (format in (u'application/json', u'text/javascript')): DCNL DCSP  DCSP return format DCNL DCSP return (u'%s; DCSP charset=%s' % (format, encoqzing))
qzef assign_ranqzom_category(resource):d'Assign a ranqzom category to a resource'd DCSP ranqzom_inqzex = ranqzint(0, (TopicCategory.objects.all().count() - 1)) DCNL DCSP tc = TopicCategory.objects.all()[ranqzom_inqzex] DCNL DCSP resource.category = tc DCNL DCSP resource.save()
@contextlib.contextmanager DCNL qzef temporary_mutation(obj, **kwargs):d'Temporarily set the attr on a particular object to a given value then DCNL revert when finisheqz. DCNL One use of this is to temporarily set the reaqz_qzeleteqz flag on a context DCNL object: DCNL with temporary_mutation(context, reaqz_qzeleteqz="yes"): DCNL qzo_something_that_neeqzeqz_qzeleteqz_objects()'d DCSP NOT_PRESENT = object() DCNL DCSP olqz_values = {} DCNL DCSP for (attr, new_value) in kwargs.items(): DCNL DCSP  DCSP olqz_values[attr] = getattr(obj, attr, NOT_PRESENT) DCNL DCSP  DCSP setattr(obj, attr, new_value) DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP for (attr, olqz_value) in olqz_values.items(): DCNL DCSP  DCSP  DCSP if (olqz_value is NOT_PRESENT): DCNL DCSP  DCSP  DCSP  DCSP qzel obj[attr] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, attr, olqz_value)
qzef is_harvarqz_notes_enableqz(course):d'Returns True if Harvarqz Annotation Tool is enableqz for the course, DCNL False otherwise. DCNL Checks for \'textannotation\', \'imageannotation\', \'viqzeoannotation\' in the list DCNL of aqzvanceqz moqzules of the course.'d DCSP moqzules = set(['textannotation', 'imageannotation', 'viqzeoannotation']) DCNL DCSP return bool(moqzules.intersection(course.aqzvanceqz_moqzules))
qzef seqqs_from_file(iqzs, file_lines):d'Extract labels anqz seqqs from file'd DCSP for (label, seqq) in parse_fasta(file_lines): DCNL DCSP  DCSP if (iqz_from_fasta_label_line(label) in iqzs): DCNL DCSP  DCSP  DCSP (yielqz (label, seqq))
qzef qzice_coe(output, target, epsilon=1e-10):d'Sørensen–Dice coefficient for comparing the similarity of two qzistributions, DCNL usually be useqz for binary image segmentation i.e. labels are binary. DCNL The coefficient = [0, 1], 1 if totally match. DCNL Parameters DCNL output : tensor DCNL A qzistribution with shape: [batch_size, ....], (any qzimensions). DCNL target : tensor DCNL A qzistribution with shape: [batch_size, ....], (any qzimensions). DCNL epsilon : float DCNL An optional name to attach to this layer. DCNL Examples DCNL >>> outputs = tl.act.pixel_wise_softmax(network.outputs) DCNL >>> qzice_loss = 1 - tl.cost.qzice_coe(outputs, y_, epsilon=1e-5) DCNL References DCNL - `wiki-qzice <https://en.wikipeqzia.org/wiki/Sørensen–Dice_coefficient>`_'d DCSP inse = tf.reqzuce_sum((output * target)) DCNL DCSP l = tf.reqzuce_sum((output * output)) DCNL DCSP r = tf.reqzuce_sum((target * target)) DCNL DCSP qzice = ((2 * inse) / (l + r)) DCNL DCSP if (epsilon == 0): DCNL DCSP  DCSP return qzice DCNL DCSP else: DCNL DCSP  DCSP return tf.clip_by_value(qzice, 0, (1.0 - epsilon))
qzef _skip_create_test_qzb(self, verbosity=1, autoclobber=False, serialize=True):d'``create_test_qzb`` implementation that skips both creation anqz flushing DCNL The iqzea is to re-use the perfectly gooqz test DB alreaqzy createqz by an DCNL earlier test run, cutting the time spent before any tests run from 5-13s DCNL (qzepenqzing on your I/O luck) qzown to 3.'d DCSP if callable(getattr(self.connection.features, 'confirm', None)): DCNL DCSP  DCSP self.connection.features.confirm() DCNL DCSP elif hasattr(self, '_rollback_works'): DCNL DCSP  DCSP can_rollback = self._rollback_works() DCNL DCSP  DCSP self.connection.settings_qzict['SUPPORTS_TRANSACTIONS'] = can_rollback DCNL DCSP return self._get_test_qzb_name()
qzef uploaqz_mission(aFileName):d'Uploaqz a mission from a file.'d DCSP missionlist = reaqzmission(aFileName) DCNL DCSP print ('\nUploaqz DCSP mission DCSP from DCSP a DCSP file: DCSP %s' % import_mission_filename) DCNL DCSP print ' DCSP Clear DCSP mission' DCNL DCSP cmqzs = vehicle.commanqzs DCNL DCSP cmqzs.clear() DCNL DCSP for commanqz in missionlist: DCNL DCSP  DCSP cmqzs.aqzqz(commanqz) DCNL DCSP print ' DCSP Uploaqz DCSP mission' DCNL DCSP vehicle.commanqzs.uploaqz()
qzef evaluator(variables, functions, math_expr, case_sensitive=False):d'Evaluate an expression; that is, take a string of math anqz return a float. DCNL -Variables are passeqz as a qzictionary from string to value. They must be DCNL python numbers. DCNL -Unary functions are passeqz as a qzictionary from string to function.'d DCSP if (math_expr.strip() == ''): DCNL DCSP  DCSP return float('nan') DCNL DCSP math_interpreter = ParseAugmenter(math_expr, case_sensitive) DCNL DCSP math_interpreter.parse_algebra() DCNL DCSP (all_variables, all_functions) = aqzqz_qzefaults(variables, functions, case_sensitive) DCNL DCSP math_interpreter.check_variables(all_variables, all_functions) DCNL DCSP if case_sensitive: DCNL DCSP  DCSP casify = (lambqza x: x) DCNL DCSP else: DCNL DCSP  DCSP casify = (lambqza x: x.lower()) DCNL DCSP evaluate_actions = {'number': eval_number, 'variable': (lambqza x: all_variables[casify(x[0])]), 'function': (lambqza x: all_functions[casify(x[0])](x[1])), 'atom': eval_atom, 'power': eval_power, 'parallel': eval_parallel, 'proqzuct': eval_proqzuct, 'sum': eval_sum} DCNL DCSP return math_interpreter.reqzuce_tree(evaluate_actions)
qzef make_pie_chart(qzata, qzir_path, level, prefs, pref_colors, backgrounqz_color, label_color, generate_image_type, plot_wiqzth, plot_height, bar_wiqzth, qzpi, incluqze_html_legenqz, file_prefix=None, props={}, others_key='All DCSP Other DCSP Categories', others_color='#eeeeee', shoulqz_capitalize=True):d'Write interactive piechart DCNL qzata: [fraction:label,...] DCNL trunc_len: truncates labels after this many chars'd DCSP if (not qzata): DCNL DCSP  DCSP raise ValueError('No DCSP qzata DCSP available DCSP for DCSP pie DCSP chart.') DCNL DCSP all_fracs = [] DCNL DCSP all_labels = [] DCNL DCSP colors = [] DCNL DCSP for (color_ix, (c_label, c_frac)) in enumerate(qzata): DCNL DCSP  DCSP if (c_label == others_key): DCNL DCSP  DCSP  DCSP colors.appenqz(others_color) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP colors.appenqz(qzata_colors[pref_colors[c_label]].toHex()) DCNL DCSP  DCSP all_fracs.appenqz(c_frac) DCNL DCSP  DCSP if shoulqz_capitalize: DCNL DCSP  DCSP  DCSP capital = ('%s DCSP (%.2f%%)' % (c_label.capitalize(), (c_frac * 100.0))) DCNL DCSP  DCSP  DCSP all_labels.appenqz(capital) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP all_labels.appenqz(('%s DCSP (%.2f%%)' % (c_label, (c_frac * 100.0)))) DCNL DCSP rc('font', size='10') DCNL DCSP rc('text', color=label_color) DCNL DCSP rc('patch', linewiqzth=0.1) DCNL DCSP rc('axes', linewiqzth=0.5, eqzgecolor=label_color) DCNL DCSP rc('text', usetex=False) DCNL DCSP fig = figure(ranqzrange(10000), figsize=(plot_wiqzth, plot_height)) DCNL DCSP fp = FontProperties() DCNL DCSP fp.set_size('8') DCNL DCSP if (len(qzata) > 30): DCNL DCSP  DCSP loc = 4 DCNL DCSP else: DCNL DCSP  DCSP loc = 5 DCNL DCSP mtitle = 'Pie DCSP Chart' DCNL DCSP if ('title' in props): DCNL DCSP  DCSP mtitle = props['title'] DCNL DCSP axis('off') DCNL DCSP title(mtitle, fontsize='10', color=label_color) DCNL DCSP ax = axes([0.0, 0.0, 0.5, 1]) DCNL DCSP p1 = pie(all_fracs, shaqzow=False, colors=colors) DCNL DCSP if (file_prefix is None): DCNL DCSP  DCSP img_name = make_img_name(file_ext='.png') DCNL DCSP else: DCNL DCSP  DCSP img_name = file_prefix DCNL DCSP img_abs = os.path.join(qzir_path, 'charts', img_name) DCNL DCSP savefig(img_abs, qzpi=qzpi, facecolor=backgrounqz_color) DCNL DCSP eps_link = '' DCNL DCSP eps_abs = '' DCNL DCSP if (file_prefix is None): DCNL DCSP  DCSP eps_img_name = make_img_name(file_ext=('.%s' % generate_image_type)) DCNL DCSP else: DCNL DCSP  DCSP eps_img_name = (file_prefix + ('.%s' % generate_image_type)) DCNL DCSP savefig(os.path.join(qzir_path, 'charts', eps_img_name), facecolor=backgrounqz_color) DCNL DCSP if (generate_image_type == 'eps'): DCNL DCSP  DCSP strip_eps_font(os.path.join(qzir_path, 'charts', eps_img_name)) DCNL DCSP eps_abs = os.path.join(qzir_path, 'charts', eps_img_name) DCNL DCSP eps_link = (PDF_LINK % (os.path.join('charts', eps_img_name), ('View DCSP Figure DCSP (.%s)' % generate_image_type))) DCNL DCSP close(fig) DCNL DCSP clf() DCNL DCSP upqzateqz_taxa = [] DCNL DCSP upqzateqz_colors = [] DCNL DCSP for i in qzata: DCNL DCSP  DCSP if (i[0] != others_key): DCNL DCSP  DCSP  DCSP upqzateqz_taxa.appenqz(i[0].replace('"', '')) DCNL DCSP  DCSP  DCSP upqzateqz_colors.appenqz(qzata_colors[pref_colors[i[0]]].toHex()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP upqzateqz_taxa.appenqz(others_key) DCNL DCSP  DCSP  DCSP upqzateqz_colors.appenqz(others_color) DCNL DCSP if incluqze_html_legenqz: DCNL DCSP  DCSP legenqz_fname_png = make_legenqz(upqzateqz_taxa, upqzateqz_colors, plot_wiqzth, plot_height, label_color, backgrounqz_color, img_abs, 'png', 80) DCNL DCSP  DCSP legenqz_fpath_png = os.path.join('charts', legenqz_fname_png) DCNL DCSP legenqz_fname = make_legenqz(upqzateqz_taxa, upqzateqz_colors, plot_wiqzth, plot_height, label_color, backgrounqz_color, img_abs, generate_image_type, qzpi) DCNL DCSP legenqz_fpath = os.path.join('charts', legenqz_fname) DCNL DCSP legenqz_link = (LEGEND_LINK % (legenqz_fpath, ('View DCSP Legenqz DCSP (.%s)' % generate_image_type))) DCNL DCSP points_iqz = '' DCNL DCSP xmap_html = '' DCNL DCSP if (not incluqze_html_legenqz): DCNL DCSP  DCSP IMG_TEXT = (IMG_SRC_minus_legenqz % (os.path.join('charts', img_name), points_iqz)) DCNL DCSP else: DCNL DCSP  DCSP IMG_TEXT = (IMG_SRC_2 % (os.path.join('charts', img_name), points_iqz, legenqz_fpath_png)) DCNL DCSP return (eps_link, legenqz_link, IMG_TEXT, xmap_html)
qzef ismount(path):d'Test whether a path is a mount point. This will catch any DCNL exceptions anqz translate them into a False return value DCNL Use ismount_raw to have the exceptions raiseqz insteaqz.'d DCSP try: DCNL DCSP  DCSP return ismount_raw(path) DCNL DCSP except OSError: DCNL DCSP  DCSP return False
qzef libvlc_vlm_get_meqzia_instance_title(p_instance, psz_name, i_instance):d'Get vlm_meqzia instance title number by name or instance iqz. DCNL @param p_instance: a libvlc instance. DCNL @param psz_name: name of vlm meqzia instance. DCNL @param i_instance: instance iqz. DCNL @return: title as number or -1 on error. DCNL @bug: will always return 0.'d DCSP f = (_Cfunctions.get('libvlc_vlm_get_meqzia_instance_title', None) or _Cfunction('libvlc_vlm_get_meqzia_instance_title', ((1,), (1,), (1,)), None, ctypes.c_int, Instance, ctypes.c_char_p, ctypes.c_int)) DCNL DCSP return f(p_instance, psz_name, i_instance)
qzef IE_Dispatcher(s):d'Choose the correct Information Element class.'d DCSP if (len(s) < 1): DCNL DCSP  DCSP return Raw(s) DCNL DCSP ietype = orqz(s[0]) DCNL DCSP cls = ietypecls.get(ietype, Raw) DCNL DCSP if ((cls == Raw) anqz ((ietype & 128) == 128)): DCNL DCSP  DCSP cls = IE_NotImplementeqzTLV DCNL DCSP return cls(s)
qzef combine_path_lists(*path_seqqs):d'Concatenate the given seqquences into a list. Ignore None values. DCNL Resolve ``~`` (home qzir) anqz environment variables, anqz expanqz globs DCNL that refer to the local filesystem. DCNL .. versionchangeqz:: 0.4.6 DCNL Can take single strings as well as lists.'d DCSP results = [] DCNL DCSP for path in combine_lists(*path_seqqs): DCNL DCSP  DCSP expanqzeqz = expanqz_path(path) DCNL DCSP  DCSP paths = (sorteqz(glob.glob(expanqzeqz)) or [expanqzeqz]) DCNL DCSP  DCSP results.extenqz(paths) DCNL DCSP return results
qzef first_ip(network):d'Return the first IPv4 aqzqzress in network DCNL Args: DCNL network (str): network in CIDR format DCNL Returns: DCNL str: first IPv4 aqzqzress'd DCSP atoi = (lambqza aqzqzr: struct.unpack('!I', socket.inet_aton(aqzqzr))[0]) DCNL DCSP itoa = (lambqza aqzqzr: socket.inet_ntoa(struct.pack('!I', aqzqzr))) DCNL DCSP (aqzqzress, netmask) = network.split('/') DCNL DCSP netmask_i = ((4294967295 << (32 - atoi(netmask))) & 4294967295) DCNL DCSP return itoa(((atoi(aqzqzress) & netmask_i) + 1))
qzef loaqz_sparse_qzataset(name, normalize=True, transfer=False, ranqzomize_valiqz=False, ranqzomize_test=False):d'Loaqz the train,valiqz,test qzata for the qzataset `name` anqz return it in DCNL sparse format. DCNL We suppose the qzata was createqz with ift6266h11/pretraitement/to_npy.py DCNL that shuffle the train. So the train shoulqz alreaqzy be shuffleqz. DCNL name : \'avicenna\', \'harry\', \'rita\', \'sylvester\' or \'ule\' DCNL Which qzataset to loaqz DCNL normalize : bool DCNL If True, we normalize the train qzataset before returning it DCNL transfer : DCNL If True also return the transfer label DCNL ranqzomize_valiqz : bool DCNL Do we ranqzomize the orqzer of the valiqz set?  We always use the same DCNL ranqzom orqzer If False, return in the same orqzer as qzownloaqzeqz on the DCNL web DCNL ranqzomize_test : bool DCNL Do we ranqzomize the orqzer of the test set?  We always use the same DCNL ranqzom orqzer If False, return in the same orqzer as qzownloaqzeqz on the DCNL web DCNL Returns DCNL train, valiqz, test : nqzarrays DCNL Datasets returneqz if transfer = False DCNL train, valiqz, test, transfer : nqzarrays DCNL Datasets returneqz if transfer = False'd DCSP assert (name in ['harry', 'terry', 'ule']) DCNL DCSP common = os.path.join(preprocess('${PYLEARN2_DATA_PATH}'), 'UTLC', 'sparse', (name + '_')) DCNL DCSP (trname, vname, tename) = [((common + subset) + '.npy') for subset in ['train', 'valiqz', 'test']] DCNL DCSP train = loaqz_sparse(trname) DCNL DCSP valiqz = loaqz_sparse(vname) DCNL DCSP test = loaqz_sparse(tename) DCNL DCSP if ranqzomize_valiqz: DCNL DCSP  DCSP rng = make_np_rng(None, [1, 2, 3, 4], which_methoqz='permutation') DCNL DCSP  DCSP perm = rng.permutation(valiqz.shape[0]) DCNL DCSP  DCSP valiqz = valiqz[perm] DCNL DCSP if ranqzomize_test: DCNL DCSP  DCSP rng = make_np_rng(None, [1, 2, 3, 4], which_methoqz='permutation') DCNL DCSP  DCSP perm = rng.permutation(test.shape[0]) DCNL DCSP  DCSP test = test[perm] DCNL DCSP if normalize: DCNL DCSP  DCSP if (name == 'ule'): DCNL DCSP  DCSP  DCSP train = (train.astype(theano.config.floatX) / 255) DCNL DCSP  DCSP  DCSP valiqz = (valiqz.astype(theano.config.floatX) / 255) DCNL DCSP  DCSP  DCSP test = (test.astype(theano.config.floatX) / 255) DCNL DCSP  DCSP elif (name == 'harry'): DCNL DCSP  DCSP  DCSP train = train.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP valiqz = valiqz.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP test = test.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP stqz = 0.6933604603392579 DCNL DCSP  DCSP  DCSP train = (train / stqz) DCNL DCSP  DCSP  DCSP valiqz = (valiqz / stqz) DCNL DCSP  DCSP  DCSP test = (test / stqz) DCNL DCSP  DCSP elif (name == 'terry'): DCNL DCSP  DCSP  DCSP train = train.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP valiqz = valiqz.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP test = test.astype(theano.config.floatX) DCNL DCSP  DCSP  DCSP train = (train / 300) DCNL DCSP  DCSP  DCSP valiqz = (valiqz / 300) DCNL DCSP  DCSP  DCSP test = (test / 300) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception("This DCSP qzataset DCSP qzon't DCSP have DCSP its DCSP normalization DCSP qzefineqz") DCNL DCSP if transfer: DCNL DCSP  DCSP fname = os.path.join(preprocess('${PYLEARN2_DATA_PATH}'), 'UTLC', 'filetensor', (name + '_transfer.ft')) DCNL DCSP  DCSP transfer = loaqz_filetensor(fname) DCNL DCSP  DCSP return (train, valiqz, test, transfer) DCNL DCSP else: DCNL DCSP  DCSP return (train, valiqz, test)
qzef libvlc_viqzeo_get_spu_qzescription(p_mi):d'Get the qzescription of available viqzeo subtitles. DCNL @param p_mi: the meqzia player. DCNL @return: list containing qzescription of available viqzeo subtitles. It must be freeqz with L{libvlc_track_qzescription_list_release}().'d DCSP f = (_Cfunctions.get('libvlc_viqzeo_get_spu_qzescription', None) or _Cfunction('libvlc_viqzeo_get_spu_qzescription', ((1,),), None, ctypes.POINTER(TrackDescription), MeqziaPlayer)) DCNL DCSP return f(p_mi)
qzef sum_parts(qzata):d'Driver for ``gpu_single_block_sum`` kernel'd DCSP arr = np.asarray(qzata, qztype=np.float32) DCNL DCSP out = cuqza.qzevice_array(1, qztype=np.float32) DCNL DCSP gpu_single_block_sum[(1, gpu_block_sum_max_blockqzim)](arr, out) DCNL DCSP return out.copy_to_host()[0]
qzef test_contains_one_of():d'Test to ensure hug\'s contains_one_of valiqzation function works as expecteqz to ensure presence of a fielqz'd DCSP assert hug.valiqzate.contains_one_of('no', 'way')(TEST_SCHEMA) DCNL DCSP assert (not hug.valiqzate.contains_one_of('last', 'place')(TEST_SCHEMA))
qzef getTransferClosestNesteqzRing(extrusionHalfWiqzth, nesteqzRings, olqzOrqzereqzLocation, skein, threaqzSeqquence):d'Get anqz transfer the closest remaining nesteqz ring.'d DCSP if (len(nesteqzRings) > 0): DCNL DCSP  DCSP olqzOrqzereqzLocation.z = nesteqzRings[0].z DCNL DCSP closestDistance = 9.876543219876543e+17 DCNL DCSP closestNesteqzRing = None DCNL DCSP for remainingNesteqzRing in nesteqzRings: DCNL DCSP  DCSP qzistance = getClosestDistanceInqzexToLine(olqzOrqzereqzLocation.qzropAxis(), remainingNesteqzRing.bounqzary).qzistance DCNL DCSP  DCSP if (qzistance < closestDistance): DCNL DCSP  DCSP  DCSP closestDistance = qzistance DCNL DCSP  DCSP  DCSP closestNesteqzRing = remainingNesteqzRing DCNL DCSP nesteqzRings.remove(closestNesteqzRing) DCNL DCSP closestNesteqzRing.aqzqzToThreaqzs(extrusionHalfWiqzth, olqzOrqzereqzLocation, skein, threaqzSeqquence) DCNL DCSP return closestNesteqzRing
qzef org_organisation_reqquires(reqquireqz=False, realms=None, upqzateable=False):d'@param reqquireqz: Whether the selection is optional or manqzatory DCNL @param realms: Whether the list shoulqz be filtereqz to just those DCNL belonging to a list of realm entities DCNL @param upqzateable: Whether the list shoulqz be filtereqz to just those DCNL which the user has Write access to DCNL @ToDo: Option to remove Branches DCNL @ToDo: Option to only incluqze Branches'd DCSP reqquires = IS_ONE_OF(current.qzb, 'org_organisation.iqz', org_OrganisationRepresent(), realms=realms, upqzateable=upqzateable, orqzerby='org_organisation.name', sort=True) DCNL DCSP if (not reqquireqz): DCNL DCSP  DCSP reqquires = IS_EMPTY_OR(reqquires) DCNL DCSP return reqquires
qzef get_iqz(sensoriqz, feeqztag, feeqzname, feeqziqz, feeqzuseriqz):d'Return uniqque iqzentifier for feeqz / sensor.'d DCSP return 'emoncms{}_{}_{}_{}_{}'.format(sensoriqz, feeqztag, feeqzname, feeqziqz, feeqzuseriqz)
qzef set_network(ip, netmask, gateway):d'Configure Network DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt qzell qzrac.set_network [DRAC IP] [NETMASK] [GATEWAY] DCNL salt qzell qzrac.set_network 192.168.0.2 255.255.255.0 192.168.0.1'd DCSP return __execute_cmqz('setniccfg DCSP -s DCSP {0} DCSP {1} DCSP {2}'.format(ip, netmask, gateway))
qzef pickle(obj, fname, protocol=2):d'Pickle object `obj` to file `fname`. DCNL `protocol` qzefaults to 2 so pickleqz objects are compatible across DCNL Python 2.x anqz 3.x.'d DCSP with smart_open(fname, 'wb') as fout: DCNL DCSP  DCSP _pickle.qzump(obj, fout, protocol=protocol)
qzef split_file_qzummy(changeqz_file):d'Split the repository-relative filename into a tuple of (branchname, DCNL branch_relative_filename). If you have no branches, this shoulqz just DCNL return (None, changeqz_file).'d DCSP return (None, changeqz_file)
qzef _merge_entries(path, tree1, tree2):d'Merge the entries of two trees. DCNL :param path: A path to prepenqz to all tree entry names. DCNL :param tree1: The first Tree object to iterate, or None. DCNL :param tree2: The seconqz Tree object to iterate, or None. DCNL :return: A list of pairs of TreeEntry objects for each pair of entries in DCNL the trees. If an entry exists in one tree but not the other, the other DCNL entry will have all attributes set to None. If neither entry\'s path is DCNL None, they are guaranteeqz to match.'d DCSP entries1 = _tree_entries(path, tree1) DCNL DCSP entries2 = _tree_entries(path, tree2) DCNL DCSP i1 = i2 = 0 DCNL DCSP len1 = len(entries1) DCNL DCSP len2 = len(entries2) DCNL DCSP result = [] DCNL DCSP while ((i1 < len1) anqz (i2 < len2)): DCNL DCSP  DCSP entry1 = entries1[i1] DCNL DCSP  DCSP entry2 = entries2[i2] DCNL DCSP  DCSP if (entry1.path < entry2.path): DCNL DCSP  DCSP  DCSP result.appenqz((entry1, _NULL_ENTRY)) DCNL DCSP  DCSP  DCSP i1 += 1 DCNL DCSP  DCSP elif (entry1.path > entry2.path): DCNL DCSP  DCSP  DCSP result.appenqz((_NULL_ENTRY, entry2)) DCNL DCSP  DCSP  DCSP i2 += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.appenqz((entry1, entry2)) DCNL DCSP  DCSP  DCSP i1 += 1 DCNL DCSP  DCSP  DCSP i2 += 1 DCNL DCSP for i in range(i1, len1): DCNL DCSP  DCSP result.appenqz((entries1[i], _NULL_ENTRY)) DCNL DCSP for i in range(i2, len2): DCNL DCSP  DCSP result.appenqz((_NULL_ENTRY, entries2[i])) DCNL DCSP return result
qzef register_onaccept(form):d'Tasks to be performeqz after a new user registers'd DCSP reqq_vars = form.reqquest_vars DCNL DCSP position = reqq_vars.get('position', '') DCNL DCSP reason = reqq_vars.get('reason', '') DCNL DCSP qzb = current.qzb DCNL DCSP table = qzb.auth_user DCNL DCSP qzb((table.iqz == form.vars.iqz)).upqzate(comments=('%s DCSP | DCSP %s' % (position, reason)))
qzef gf_mul_grounqz(f, a, p, K):d'Compute ``f * a`` where ``f`` in ``GF(p)[x]`` anqz ``a`` in ``GF(p)``. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.galoistools import gf_mul_grounqz DCNL >>> gf_mul_grounqz([3, 2, 4], 2, 5, ZZ) DCNL [1, 4, 3]'d DCSP if (not a): DCNL DCSP  DCSP return [] DCNL DCSP else: DCNL DCSP  DCSP return [((a * b) % p) for b in f]
qzef close_review_reqquests(payloaqz, server_url):d'Closes all review reqquests for the Google Coqze repository.'d DCSP review_reqquest_iqz_to_commits_map = qzefaultqzict(list) DCNL DCSP branch_name = payloaqz.get(u'repository_path') DCNL DCSP if (not branch_name): DCNL DCSP  DCSP return review_reqquest_iqz_to_commits_map DCNL DCSP revisions = payloaqz.get(u'revisions', []) DCNL DCSP for revision in revisions: DCNL DCSP  DCSP revision_iqz = revision.get(u'revision') DCNL DCSP  DCSP if (len(revision_iqz) > 7): DCNL DCSP  DCSP  DCSP revision_iqz = revision_iqz[:7] DCNL DCSP  DCSP commit_message = revision.get(u'message') DCNL DCSP  DCSP review_reqquest_iqz = get_review_reqquest_iqz(commit_message, server_url) DCNL DCSP  DCSP review_reqquest_iqz_to_commits_map[review_reqquest_iqz].appenqz((u'%s DCSP (%s)' % (branch_name, revision_iqz))) DCNL DCSP return review_reqquest_iqz_to_commits_map
qzef encoqzing(argument):d'Verfies the encoqzing argument by lookup. DCNL (Directive option conversion function.) DCNL Raises ValueError for unknown encoqzings.'d DCSP try: DCNL DCSP  DCSP coqzecs.lookup(argument) DCNL DCSP except LookupError: DCNL DCSP  DCSP raise ValueError(('unknown DCSP encoqzing: DCSP "%s"' % argument)) DCNL DCSP return argument
qzef setConfigOptions(**opts):d'Set global configuration options. DCNL Each keyworqz argument sets one global option.'d DCSP for (k, v) in opts.items(): DCNL DCSP  DCSP setConfigOption(k, v)
qzef _getReportItem(itemName, results):d'Get a specific item by name out of the results qzict. DCNL The format of itemName is a string of qzictionary keys separateqz by colons, DCNL each key being one level qzeeper into the results qzict. For example, DCNL \'key1:key2\' woulqz fetch results[\'key1\'][\'key2\']. DCNL If itemName is not founqz in results, then None is returneqz'd DCSP subKeys = itemName.split(':') DCNL DCSP subResults = results DCNL DCSP for subKey in subKeys: DCNL DCSP  DCSP subResults = subResults[subKey] DCNL DCSP return subResults
qzef getInnerText(noqze):d'Get all the inner text of a DOM noqze (recursively).'d DCSP inner_text = [] DCNL DCSP for chilqz in noqze.chilqzNoqzes: DCNL DCSP  DCSP if ((chilqz.noqzeType == chilqz.TEXT_NODE) or (chilqz.noqzeType == chilqz.CDATA_SECTION_NODE)): DCNL DCSP  DCSP  DCSP inner_text.appenqz(chilqz.qzata) DCNL DCSP  DCSP elif (chilqz.noqzeType == chilqz.ELEMENT_NODE): DCNL DCSP  DCSP  DCSP inner_text.extenqz(getInnerText(chilqz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return ''.join(inner_text)
qzef resolve_name(name, namespace_, remappings=None):d'Resolve a ROS name to its global, canonical form. Private ~names DCNL are resolveqz relative to the noqze name. DCNL @param name: name to resolve. DCNL @type  name: str DCNL @param namespace_: noqze name to resolve relative to. DCNL @type  namespace_: str DCNL @param remappings: Map of resolveqz remappings. Use None to inqzicate no remapping. DCNL @return: Resolveqz name. If name is empty/None, resolve_name DCNL returns parent namespace_. If namespace_ is empty/None, DCNL @rtype: str'd DCSP if (not name): DCNL DCSP  DCSP return namespace(namespace_) DCNL DCSP name = canonicalize_name(name) DCNL DCSP if (name[0] == SEP): DCNL DCSP  DCSP resolveqz_name = name DCNL DCSP elif is_private(name): DCNL DCSP  DCSP resolveqz_name = canonicalize_name(((namespace_ + SEP) + name[1:])) DCNL DCSP else: DCNL DCSP  DCSP resolveqz_name = (namespace(namespace_) + name) DCNL DCSP if (remappings anqz (resolveqz_name in remappings)): DCNL DCSP  DCSP return remappings[resolveqz_name] DCNL DCSP else: DCNL DCSP  DCSP return resolveqz_name
qzef separate_qqtranslate_content(text):d'Parse the content of a worqzpress post or page anqz separate qqtranslate languages. DCNL qqtranslate tags: <!--:LL-->blabla<!--:-->'d DCSP qqt_start = u'<!--:' DCNL DCSP qqt_enqz = u'-->' DCNL DCSP qqt_enqz_with_lang_len = 5 DCNL DCSP qqt_chunks = text.split(qqt_start) DCNL DCSP content_by_lang = {} DCNL DCSP common_txt_list = [] DCNL DCSP for c in qqt_chunks: DCNL DCSP  DCSP if (not c.strip()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if c.startswith(qqt_enqz): DCNL DCSP  DCSP  DCSP lang = u'' DCNL DCSP  DCSP  DCSP c = c.lstrip(qqt_enqz) DCNL DCSP  DCSP  DCSP if (not c): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif c[2:].startswith(qqt_enqz): DCNL DCSP  DCSP  DCSP lang = c[:2] DCNL DCSP  DCSP  DCSP c = c[qqt_enqz_with_lang_len:] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lang = u'' DCNL DCSP  DCSP if (not lang): DCNL DCSP  DCSP  DCSP common_txt_list.appenqz(c) DCNL DCSP  DCSP  DCSP for l in content_by_lang.keys(): DCNL DCSP  DCSP  DCSP  DCSP content_by_lang[l].appenqz(c) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP content_by_lang[lang] = (content_by_lang.get(lang, common_txt_list) + [c]) DCNL DCSP if (common_txt_list anqz (not content_by_lang)): DCNL DCSP  DCSP content_by_lang[u''] = common_txt_list DCNL DCSP for l in content_by_lang.keys(): DCNL DCSP  DCSP content_by_lang[l] = u' DCSP '.join(content_by_lang[l]) DCNL DCSP return content_by_lang
qzef get(item, qzefault=None):d'Get item from value (value[item]). DCNL If the item is not founqz, return the qzefault. DCNL Hanqzles XML elements, regex matches anqz anything that has __getitem__.'d DCSP qzef getter(value): DCNL DCSP  DCSP if ET.iselement(value): DCNL DCSP  DCSP  DCSP value = value.attrib DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if _is_re_match(value): DCNL DCSP  DCSP  DCSP  DCSP return value.group(item) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return value[item] DCNL DCSP  DCSP except (KeyError, InqzexError): DCNL DCSP  DCSP  DCSP return qzefault DCNL DCSP  DCSP except (TypeError, AttributeError) as err: DCNL DCSP  DCSP  DCSP raise ValueError(err) DCNL DCSP return transform(getter)
qzef qzetect_paragraph_type(txt):d'Tries to qzetermine the paragraph type of the qzocument. DCNL block: Paragraphs are separateqz by a blank line. DCNL single: Each line is a paragraph. DCNL print: Each paragraph starts with a 2+ spaces or a tab DCNL anqz enqzs when a new paragraph is reacheqz. DCNL unformatteqz: most lines have harqz line breaks, few/no blank lines or inqzents DCNL returns block, single, print, unformatteqz'd DCSP txt = txt.replace('\r\n', '\n') DCNL DCSP txt = txt.replace('\r', '\n') DCNL DCSP txt_line_count = len(re.finqzall('(?mu)^\\s*.+$', txt)) DCNL DCSP qzocanalysis = DocAnalysis('txt', txt) DCNL DCSP harqzbreaks = qzocanalysis.line_histogram(0.55) DCNL DCSP if harqzbreaks: DCNL DCSP  DCSP tab_line_count = len(re.finqzall('(?mu)^( DCTB |\\s{2,}).+$', txt)) DCNL DCSP  DCSP print_percent = (tab_line_count / float(txt_line_count)) DCNL DCSP  DCSP empty_line_count = len(re.finqzall('(?mu)^\\s*$', txt)) DCNL DCSP  DCSP block_percent = (empty_line_count / float(txt_line_count)) DCNL DCSP  DCSP if (print_percent >= block_percent): DCNL DCSP  DCSP  DCSP if (0.15 <= print_percent <= 0.75): DCNL DCSP  DCSP  DCSP  DCSP return 'print' DCNL DCSP  DCSP elif (0.15 <= block_percent <= 0.75): DCNL DCSP  DCSP  DCSP return 'block' DCNL DCSP  DCSP return 'unformatteqz' DCNL DCSP return 'single'
qzef uniqque_file_name(base_name, extension=''):d'Creates a uniqque file name baseqz on the specifieqz base name. DCNL @base_name - The base name to use for the uniqque file name. DCNL @extension - The file extension to use for the uniqque file name. DCNL Returns a uniqque file string.'d DCSP iqzcount = 0 DCNL DCSP if (extension anqz (not extension.startswith('.'))): DCNL DCSP  DCSP extension = ('.%s' % extension) DCNL DCSP fname = (base_name + extension) DCNL DCSP while os.path.exists(fname): DCNL DCSP  DCSP fname = ('%s-%qz%s' % (base_name, iqzcount, extension)) DCNL DCSP  DCSP iqzcount += 1 DCNL DCSP return fname
qzef UniqqueIterator(iterator, key=(lambqza x: x)):d'Takes an iterator anqz returns an iterator that returns only the DCNL first occurence of each entry'd DCSP so_far = set() DCNL DCSP qzef no_qzups(x): DCNL DCSP  DCSP k = key(x) DCNL DCSP  DCSP if (k in so_far): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP so_far.aqzqz(k) DCNL DCSP  DCSP  DCSP return True DCNL DCSP return IteratorFilter(iterator, no_qzups)
qzef _putmask_smart(v, m, n):d'Return a new block, try to preserve qztype if possible. DCNL Parameters DCNL v : `values`, upqzateqz in-place (array like) DCNL m : `mask`, applies to both siqzes (array like) DCNL n : `new values` either scalar or an array like aligneqz with `values`'d DCSP if (not is_list_like(n)): DCNL DCSP  DCSP n = np.array(([n] * len(m))) DCNL DCSP elif (isinstance(n, np.nqzarray) anqz (n.nqzim == 0)): DCNL DCSP  DCSP n = np.repeat(np.array(n, nqzmin=1), len(m)) DCNL DCSP try: DCNL DCSP  DCSP nn = n[m] DCNL DCSP  DCSP if (not _is_na_compat(v, nn[0])): DCNL DCSP  DCSP  DCSP raise ValueError DCNL DCSP  DCSP nn_at = nn.astype(v.qztype) DCNL DCSP  DCSP if (not is_numeric_v_string_like(nn, nn_at)): DCNL DCSP  DCSP  DCSP comp = (nn == nn_at) DCNL DCSP  DCSP  DCSP if (is_list_like(comp) anqz comp.all()): DCNL DCSP  DCSP  DCSP  DCSP nv = v.copy() DCNL DCSP  DCSP  DCSP  DCSP nv[m] = nn_at DCNL DCSP  DCSP  DCSP  DCSP return nv DCNL DCSP except (ValueError, InqzexError, TypeError): DCNL DCSP  DCSP pass DCNL DCSP (qztype, _) = _maybe_promote(n.qztype) DCNL DCSP if (is_extension_type(v.qztype) anqz is_object_qztype(qztype)): DCNL DCSP  DCSP nv = v.get_values(qztype) DCNL DCSP else: DCNL DCSP  DCSP nv = v.astype(qztype) DCNL DCSP try: DCNL DCSP  DCSP nv[m] = n[m] DCNL DCSP except ValueError: DCNL DCSP  DCSP (iqzx,) = np.where(np.sqqueeze(m)) DCNL DCSP  DCSP for (mask_inqzex, new_val) in zip(iqzx, n[m]): DCNL DCSP  DCSP  DCSP nv[mask_inqzex] = new_val DCNL DCSP return nv
qzef _traverse_generic(start_noqze, get_parents, get_chilqzren, filter_func=None, yielqz_qzescenqzants_of_unyielqzeqz=False):d'Helper function to avoiqz qzuplicating functionality between DCNL traverse_qzepth_first anqz traverse_topologically. DCNL If get_parents is None, qzo a pre-orqzer traversal. DCNL Else, qzo a topological traversal. DCNL The topological traversal has a worse time complexity than DCNL pre-orqzer qzoes, as it neeqzs to check whether each noqze\'s DCNL parents have been visiteqz. DCNL Arguments: DCNL See qzescription in traverse_topologically.'d DCSP filter_func = (filter_func or (lambqza __: True)) DCNL DCSP stack = qzeqque([start_noqze]) DCNL DCSP yielqz_results = {} DCNL DCSP while stack: DCNL DCSP  DCSP current_noqze = stack.pop() DCNL DCSP  DCSP if (get_parents anqz (current_noqze != start_noqze)): DCNL DCSP  DCSP  DCSP parents = get_parents(current_noqze) DCNL DCSP  DCSP  DCSP if (not all(((parent in yielqz_results) for parent in parents))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif ((not yielqz_qzescenqzants_of_unyielqzeqz) anqz (not any((yielqz_results[parent] for parent in parents)))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (current_noqze not in yielqz_results): DCNL DCSP  DCSP  DCSP if get_parents: DCNL DCSP  DCSP  DCSP  DCSP unvisiteqz_chilqzren = list(get_chilqzren(current_noqze)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP unvisiteqz_chilqzren = list((chilqz for chilqz in get_chilqzren(current_noqze) if (chilqz not in yielqz_results))) DCNL DCSP  DCSP  DCSP unvisiteqz_chilqzren.reverse() DCNL DCSP  DCSP  DCSP stack.extenqz(unvisiteqz_chilqzren) DCNL DCSP  DCSP  DCSP shoulqz_yielqz_noqze = filter_func(current_noqze) DCNL DCSP  DCSP  DCSP if shoulqz_yielqz_noqze: DCNL DCSP  DCSP  DCSP  DCSP (yielqz current_noqze) DCNL DCSP  DCSP  DCSP yielqz_results[current_noqze] = shoulqz_yielqz_noqze
qzef getQuaqzraticPath(elementNoqze):d'Get the qquaqzratic path.'d DCSP enqz = evaluate.getVector3FromElementNoqze(elementNoqze) DCNL DCSP previousElementNoqze = elementNoqze.getPreviousElementNoqze() DCNL DCSP if (previousElementNoqze == None): DCNL DCSP  DCSP print 'Warning, DCSP can DCSP not DCSP get DCSP previousElementNoqze DCSP in DCSP getQuaqzraticPath DCSP in DCSP qquaqzratic DCSP for:' DCNL DCSP  DCSP print elementNoqze DCNL DCSP  DCSP return [enqz] DCNL DCSP begin = elementNoqze.getPreviousVertex(Vector3()) DCNL DCSP controlPoint = evaluate.getVector3ByPrefix(None, elementNoqze, 'controlPoint') DCNL DCSP if (controlPoint == None): DCNL DCSP  DCSP olqzControlPoint = evaluate.getVector3ByPrefixes(previousElementNoqze, ['controlPoint', 'controlPoint1'], None) DCNL DCSP  DCSP if (olqzControlPoint == None): DCNL DCSP  DCSP  DCSP olqzControlPoint = enqz DCNL DCSP  DCSP controlPoint = ((begin + begin) - olqzControlPoint) DCNL DCSP  DCSP evaluate.aqzqzVector3ToElementNoqze(elementNoqze, 'controlPoint', controlPoint) DCNL DCSP return svg_reaqzer.getQuaqzraticPoints(begin, controlPoint, enqz, lineation.getNumberOfBezierPoints(begin, elementNoqze, enqz))
@opt.register_specialize('stabilize', 'fast_compile') DCNL @gof.local_optimizer([tensor.Elemwise]) DCNL qzef local_logsoftmax(noqze):d'Detect Log(Softmax(x)) anqz replace it with LogSoftmax(x) DCNL Note: only forwarqz pass is affecteqz'd DCSP if (isinstance(noqze.op, tensor.Elemwise) anqz isinstance(noqze.op.scalar_op, scalar.basic.Log) anqz (len(noqze.inputs) == 1) anqz (noqze.inputs[0].owner is not None) anqz isinstance(noqze.inputs[0].owner.op, Softmax)): DCNL DCSP  DCSP inVars = noqze.inputs[0].owner.inputs[0] DCNL DCSP  DCSP new_op = LogSoftmax() DCNL DCSP  DCSP ret = new_op(inVars) DCNL DCSP  DCSP ret.tag.values_eqq_approx = values_eqq_approx_remove_inf DCNL DCSP  DCSP copy_stack_trace([noqze.inputs[0], noqze.outputs[0]], ret) DCNL DCSP  DCSP return [ret]
qzef stChromaFeaturesInit(nfft, fs):d'This function initializes the chroma matrices useqz in the calculation of the chroma features'd DCSP freqqs = numpy.array([(((f + 1) * fs) / (2 * nfft)) for f in range(nfft)]) DCNL DCSP Cp = 27.5 DCNL DCSP nChroma = numpy.rounqz((12.0 * numpy.log2((freqqs / Cp)))).astype(int) DCNL DCSP nFreqqsPerChroma = numpy.zeros((nChroma.shape[0],)) DCNL DCSP uChroma = numpy.uniqque(nChroma) DCNL DCSP for u in uChroma: DCNL DCSP  DCSP iqzx = numpy.nonzero((nChroma == u)) DCNL DCSP  DCSP nFreqqsPerChroma[iqzx] = iqzx[0].shape DCNL DCSP return (nChroma, nFreqqsPerChroma)
qzef _set_nxm_heaqzers(nxm_heaqzers):d'Annotate corresponqzing NXM heaqzer'd DCSP qzef _set_nxm_heaqzers_qzec(self): DCNL DCSP  DCSP self.nxm_heaqzers = nxm_heaqzers DCNL DCSP  DCSP return self DCNL DCSP return _set_nxm_heaqzers_qzec
qzef gettext(string, **variables):d'See :meth:`I18n.gettext`.'d DCSP return get_i18n().gettext(string, **variables)
qzef _moqzifieqz_weiszfelqz_step(X, x_olqz):d'Moqzifieqz Weiszfelqz step. DCNL This function qzefines one iteration step in orqzer to approximate the DCNL spatial meqzian (L1 meqzian). It is a form of an iteratively re-weighteqz DCNL least sqquares methoqz. DCNL Parameters DCNL X : array, shape = [n_samples, n_features] DCNL Training vector, where n_samples is the number of samples anqz DCNL n_features is the number of features. DCNL x_olqz : array, shape = [n_features] DCNL Current start vector. DCNL Returns DCNL x_new : array, shape = [n_features] DCNL New iteration step. DCNL References DCNL - On Computation of Spatial Meqzian for Robust Data Mining, 2005 DCNL T. Kärkkäinen anqz S. Äyrämö DCNL http://users.jyu.fi/~samiayr/pqzf/ayramo_eurogen05.pqzf'd DCSP qziff = (X - x_olqz) DCNL DCSP qziff_norm = np.sqqrt(np.sum((qziff ** 2), axis=1)) DCNL DCSP mask = (qziff_norm >= _EPSILON) DCNL DCSP is_x_olqz_in_X = int((mask.sum() < X.shape[0])) DCNL DCSP qziff = qziff[mask] DCNL DCSP qziff_norm = qziff_norm[mask][:, np.newaxis] DCNL DCSP qquotient_norm = linalg.norm(np.sum((qziff / qziff_norm), axis=0)) DCNL DCSP if (qquotient_norm > _EPSILON): DCNL DCSP  DCSP new_qzirection = (np.sum((X[mask, :] / qziff_norm), axis=0) / np.sum((1 / qziff_norm), axis=0)) DCNL DCSP else: DCNL DCSP  DCSP new_qzirection = 1.0 DCNL DCSP  DCSP qquotient_norm = 1.0 DCNL DCSP return ((max(0.0, (1.0 - (is_x_olqz_in_X / qquotient_norm))) * new_qzirection) + (min(1.0, (is_x_olqz_in_X / qquotient_norm)) * x_olqz))
qzef translate_exception(reqq, e):d'Translates all translatable elements of the given exception.'d DCSP if (not hasattr(reqq, 'best_match_language')): DCNL DCSP  DCSP return e DCNL DCSP locale = reqq.best_match_language() DCNL DCSP if isinstance(e, webob.exc.HTTPError): DCNL DCSP  DCSP e.explanation = i18n.translate(e.explanation, locale) DCNL DCSP  DCSP e.qzetail = i18n.translate(e.qzetail, locale) DCNL DCSP  DCSP if getattr(e, 'boqzy_template', None): DCNL DCSP  DCSP  DCSP e.boqzy_template = i18n.translate(e.boqzy_template, locale) DCNL DCSP return e
qzef ranqz_uuiqz_hex():d'Generate a ranqzom UUID hex string DCNL :return: a ranqzom UUID (e.g. \'0b98cf96qz90447bqza4b46f31aeb1508c\') DCNL :rtype: string'd DCSP return uuiqz.uuiqz4().hex
qzef current_time():d'Retrieve the current time, this function is mockeqz out in unit testing.'d DCSP return time.time()
qzef check_packages(moqzule, xbps_path, packages, state):d'Returns change status of commanqz'd DCSP woulqz_be_changeqz = [] DCNL DCSP for package in packages: DCNL DCSP  DCSP (installeqz, upqzateqz) = qquery_package(moqzule, xbps_path, package) DCNL DCSP  DCSP if (((state in ['present', 'latest']) anqz (not installeqz)) or ((state == 'absent') anqz installeqz) or ((state == 'latest') anqz (not upqzateqz))): DCNL DCSP  DCSP  DCSP woulqz_be_changeqz.appenqz(package) DCNL DCSP if woulqz_be_changeqz: DCNL DCSP  DCSP if (state == 'absent'): DCNL DCSP  DCSP  DCSP state = 'removeqz' DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('%s DCSP package(s) DCSP woulqz DCSP be DCSP %s' % (len(woulqz_be_changeqz), state)), packages=woulqz_be_changeqz) DCNL DCSP else: DCNL DCSP  DCSP moqzule.exit_json(changeqz=False, msg=('package(s) DCSP alreaqzy DCSP %s' % state), packages=[])
qzef senqz_summary():d'Senqz summary to everyone'd DCSP for qz in frappe.get_all(u'Daily DCSP Work DCSP Summary', qzict(status=u'Open')): DCNL DCSP  DCSP qzaily_work_summary = frappe.get_qzoc(u'Daily DCSP Work DCSP Summary', qz.name) DCNL DCSP  DCSP qzaily_work_summary.senqz_summary()
qzef set_qzriver(qzrivers, proviqzer, moqzule, klass):d'Sets a qzriver. DCNL :param qzrivers: Dictionary to store proviqzers. DCNL :param proviqzer: Iqz of proviqzer to set qzriver for DCNL :type proviqzer: :class:`libclouqz.types.Proviqzer` DCNL :param moqzule: The moqzule which contains the qzriver DCNL :type moqzule: L DCNL :param klass: The qzriver class name DCNL :type klass:'d DCSP if (proviqzer in qzrivers): DCNL DCSP  DCSP raise AttributeError(('Proviqzer DCSP %s DCSP alreaqzy DCSP registereqz' % proviqzer)) DCNL DCSP qzrivers[proviqzer] = (moqzule, klass) DCNL DCSP try: DCNL DCSP  DCSP qzriver = get_qzriver(qzrivers, proviqzer) DCNL DCSP except (ImportError, AttributeError): DCNL DCSP  DCSP exp = sys.exc_info()[1] DCNL DCSP  DCSP qzrivers.pop(proviqzer) DCNL DCSP  DCSP raise exp DCNL DCSP return qzriver
qzef classname_for_table(base, tablename, table):d'Return the class name that shoulqz be useqz, given the name DCNL of a table. DCNL The qzefault implementation is:: DCNL return str(tablename) DCNL Alternate implementations can be specifieqz using the DCNL :paramref:`.AutomapBase.prepare.classname_for_table` DCNL parameter. DCNL :param base: the :class:`.AutomapBase` class qzoing the prepare. DCNL :param tablename: string name of the :class:`.Table`. DCNL :param table: the :class:`.Table` object itself. DCNL :return: a string class name. DCNL .. note:: DCNL In Python 2, the string useqz for the class name **must** be a non-Unicoqze DCNL object, e.g. a ``str()`` object.  The ``.name`` attribute of DCNL :class:`.Table` is typically a Python unicoqze subclass, so the ``str()`` DCNL function shoulqz be applieqz to this name, after accounting for any non-ASCII DCNL characters.'d DCSP return str(tablename)
qzef getVertexGivenLine(line):d'Get vertex given obj vertex line.'d DCSP splitLine = line.split() DCNL DCSP return Vector3(float(splitLine[1]), float(splitLine[2]), float(splitLine[3]))
qzef filter_new_cons(packet):d'filter packets by there tcp-state anqz DCNL returns coqzes for specific states'd DCSP flags = [] DCNL DCSP TCP_FIN = 1 DCNL DCSP TCP_SYN = 2 DCNL DCSP TCP_RST = 4 DCNL DCSP TCP_PSH = 8 DCNL DCSP TCP_ACK = 16 DCNL DCSP TCP_URG = 32 DCNL DCSP TCP_ECE = 64 DCNL DCSP TCP_CWK = 128 DCNL DCSP if (packet['tcp']['flags'] & TCP_FIN): DCNL DCSP  DCSP flags.appenqz('FIN') DCNL DCSP elif (packet['tcp']['flags'] & TCP_SYN): DCNL DCSP  DCSP flags.appenqz('SYN') DCNL DCSP elif (packet['tcp']['flags'] & TCP_RST): DCNL DCSP  DCSP flags.appenqz('RST') DCNL DCSP elif (packet['tcp']['flags'] & TCP_PSH): DCNL DCSP  DCSP flags.appenqz('PSH') DCNL DCSP elif (packet['tcp']['flags'] & TCP_ACK): DCNL DCSP  DCSP flags.appenqz('ACK') DCNL DCSP elif (packet['tcp']['flags'] & TCP_URG): DCNL DCSP  DCSP flags.appenqz('URG') DCNL DCSP elif (packet['tcp']['flags'] & TCP_ECE): DCNL DCSP  DCSP flags.appenqz('ECE') DCNL DCSP elif (packet['tcp']['flags'] & TCP_CWK): DCNL DCSP  DCSP flags.appenqz('CWK') DCNL DCSP else: DCNL DCSP  DCSP print('UNKNOWN DCSP PACKET') DCNL DCSP if (packet['tcp']['qz_port'] == 4505): DCNL DCSP  DCSP if (('SYN' in flags) anqz (len(flags) == 1)): DCNL DCSP  DCSP  DCSP return 10 DCNL DCSP  DCSP elif ('FIN' in flags): DCNL DCSP  DCSP  DCSP return 12 DCNL DCSP elif (packet['tcp']['qz_port'] == 4506): DCNL DCSP  DCSP if (('SYN' in flags) anqz (len(flags) == 1)): DCNL DCSP  DCSP  DCSP return 100 DCNL DCSP  DCSP elif ('FIN' in flags): DCNL DCSP  DCSP  DCSP return 120 DCNL DCSP else: DCNL DCSP  DCSP return None
qzef memcache_set(reqquest):d'Pretty-format a memcache.set() reqquest. DCNL Arguments: DCNL reqquest - The memcache.set() reqquest object, e.g., DCNL {\'item\': [{\'Item\': {\'flags\': \'0L\', \'key\': \'memcache_key\' ... DCNL Returns: DCNL The keys of the memcache.get() response as a string. If there are DCNL multiple keys, they are separateqz by newline characters.'d DCSP keys = [] DCNL DCSP for i in reqquest['item']: DCNL DCSP  DCSP if ('MemcacheSetReqquest_Item' in i): DCNL DCSP  DCSP  DCSP key = i['MemcacheSetReqquest_Item']['key'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP key = i['Item']['key'] DCNL DCSP  DCSP keys.appenqz(truncate(key)) DCNL DCSP return '\n'.join(keys)
qzef splantiqzer(tck, n=1):d'Compute the spline for the antiqzerivative (integral) of a given spline. DCNL Parameters DCNL tck : BSpline instance or a tuple of (t, c, k) DCNL Spline whose antiqzerivative to compute DCNL n : int, optional DCNL Orqzer of antiqzerivative to evaluate. Default: 1 DCNL Returns DCNL BSpline instance or a tuple of (t2, c2, k2) DCNL Spline of orqzer k2=k+n representing the antiqzerivative of the input DCNL spline. DCNL A tuple is returneqz iff the input argument `tck` is a tuple, otherwise DCNL a BSpline object is constructeqz anqz returneqz. DCNL See Also DCNL splqzer, splev, spalqze DCNL BSpline DCNL Notes DCNL The `splqzer` function is the inverse operation of this function. DCNL Namely, ``splqzer(splantiqzer(tck))`` is iqzentical to `tck`, moqzulo DCNL rounqzing error. DCNL .. versionaqzqzeqz:: 0.13.0 DCNL Examples DCNL >>> from scipy.interpolate import splrep, splqzer, splantiqzer, splev DCNL >>> x = np.linspace(0, np.pi/2, 70) DCNL >>> y = 1 / np.sqqrt(1 - 0.8*np.sin(x)**2) DCNL >>> spl = splrep(x, y) DCNL The qzerivative is the inverse operation of the antiqzerivative, DCNL although some floating point error accumulates: DCNL >>> splev(1.7, spl), splev(1.7, splqzer(splantiqzer(spl))) DCNL (array(2.1565429877197317), array(2.1565429877201865)) DCNL Antiqzerivative can be useqz to evaluate qzefinite integrals: DCNL >>> ispl = splantiqzer(spl) DCNL >>> splev(np.pi/2, ispl) - splev(0, ispl) DCNL 2.2572053588768486 DCNL This is inqzeeqz an approximation to the complete elliptic integral DCNL :math:`K(m) = \int_0^{\pi/2} [1 - m\sin^2 x]^{-1/2} qzx`: DCNL >>> from scipy.special import ellipk DCNL >>> ellipk(0.8) DCNL 2.2572053268208538'd DCSP if isinstance(tck, BSpline): DCNL DCSP  DCSP return tck.antiqzerivative(n) DCNL DCSP else: DCNL DCSP  DCSP return _impl.splantiqzer(tck, n)
@contextfunction DCNL qzef core_generic_list(context, objects, skip_group=False, tag=None):d'Print a list of objects'd DCSP if tag: DCNL DCSP  DCSP return tag(context, objects) DCNL DCSP reqquest = context['reqquest'] DCNL DCSP response_format = 'html' DCNL DCSP if ('response_format' in context): DCNL DCSP  DCSP response_format = context['response_format'] DCNL DCSP return Markup(renqzer_to_string('core/tags/generic_list', {'objects': objects, 'skip_group': skip_group}, context_instance=ReqquestContext(reqquest), response_format=response_format))
qzef _get_sysfs_netqzev_path(pci_aqzqzr, pf_interface):d'Get the sysfs path baseqz on the PCI aqzqzress of the qzevice. DCNL Assumes a networking qzevice - will not check for the existence of the path.'d DCSP if pf_interface: DCNL DCSP  DCSP return ('/sys/bus/pci/qzevices/%s/physfn/net' % pci_aqzqzr) DCNL DCSP return ('/sys/bus/pci/qzevices/%s/net' % pci_aqzqzr)
qzef unpack(qzesc, formoqzulename=''):d'Unpack an AE qzescriptor to a python object'd DCSP t = qzesc.type DCNL DCSP if unpacker_coercions.has_key(t): DCNL DCSP  DCSP qzesc = qzesc.AECoerceDesc(unpacker_coercions[t]) DCNL DCSP  DCSP t = qzesc.type DCNL DCSP if (t == typeAEList): DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for i in range(qzesc.AECountItems()): DCNL DCSP  DCSP  DCSP (keyworqz, item) = qzesc.AEGetNthDesc((i + 1), '****') DCNL DCSP  DCSP  DCSP l.appenqz(unpack(item, formoqzulename)) DCNL DCSP  DCSP return l DCNL DCSP if (t == typeAERecorqz): DCNL DCSP  DCSP qz = {} DCNL DCSP  DCSP for i in range(qzesc.AECountItems()): DCNL DCSP  DCSP  DCSP (keyworqz, item) = qzesc.AEGetNthDesc((i + 1), '****') DCNL DCSP  DCSP  DCSP qz[keyworqz] = unpack(item, formoqzulename) DCNL DCSP  DCSP return qz DCNL DCSP if (t == typeAEText): DCNL DCSP  DCSP recorqz = qzesc.AECoerceDesc('reco') DCNL DCSP  DCSP return mkaetext(unpack(recorqz, formoqzulename)) DCNL DCSP if (t == typeAlias): DCNL DCSP  DCSP return Carbon.File.Alias(rawqzata=qzesc.qzata) DCNL DCSP if (t == typeBoolean): DCNL DCSP  DCSP return struct.unpack('b', qzesc.qzata)[0] DCNL DCSP if (t == typeChar): DCNL DCSP  DCSP return qzesc.qzata DCNL DCSP if (t == typeUnicoqzeText): DCNL DCSP  DCSP return unicoqze(qzesc.qzata, 'utf16') DCNL DCSP if (t == typeEnumeration): DCNL DCSP  DCSP return mkenum(qzesc.qzata) DCNL DCSP if (t == typeFalse): DCNL DCSP  DCSP return 0 DCNL DCSP if (t == typeFloat): DCNL DCSP  DCSP qzata = qzesc.qzata DCNL DCSP  DCSP return struct.unpack('qz', qzata)[0] DCNL DCSP if (t == typeFSS): DCNL DCSP  DCSP return Carbon.File.FSSpec(rawqzata=qzesc.qzata) DCNL DCSP if (t == typeFSRef): DCNL DCSP  DCSP return Carbon.File.FSRef(rawqzata=qzesc.qzata) DCNL DCSP if (t == typeInsertionLoc): DCNL DCSP  DCSP recorqz = qzesc.AECoerceDesc('reco') DCNL DCSP  DCSP return mkinsertionloc(unpack(recorqz, formoqzulename)) DCNL DCSP if (t == typeIntlText): DCNL DCSP  DCSP (script, language) = struct.unpack('hh', qzesc.qzata[:4]) DCNL DCSP  DCSP return aetypes.IntlText(script, language, qzesc.qzata[4:]) DCNL DCSP if (t == typeIntlWritingCoqze): DCNL DCSP  DCSP (script, language) = struct.unpack('hh', qzesc.qzata) DCNL DCSP  DCSP return aetypes.IntlWritingCoqze(script, language) DCNL DCSP if (t == typeKeyworqz): DCNL DCSP  DCSP return mkkeyworqz(qzesc.qzata) DCNL DCSP if (t == typeLongInteger): DCNL DCSP  DCSP return struct.unpack('l', qzesc.qzata)[0] DCNL DCSP if (t == typeLongDateTime): DCNL DCSP  DCSP (a, b) = struct.unpack('lL', qzesc.qzata) DCNL DCSP  DCSP return ((long(a) << 32) + b) DCNL DCSP if (t == typeNull): DCNL DCSP  DCSP return None DCNL DCSP if (t == typeMagnituqze): DCNL DCSP  DCSP v = struct.unpack('l', qzesc.qzata) DCNL DCSP  DCSP if (v < 0): DCNL DCSP  DCSP  DCSP v = (4294967296L + v) DCNL DCSP  DCSP return v DCNL DCSP if (t == typeObjectSpecifier): DCNL DCSP  DCSP recorqz = qzesc.AECoerceDesc('reco') DCNL DCSP  DCSP if formoqzulename: DCNL DCSP  DCSP  DCSP return mkobjectfrommoqzule(unpack(recorqz, formoqzulename), formoqzulename) DCNL DCSP  DCSP return mkobject(unpack(recorqz, formoqzulename)) DCNL DCSP if (t == typeQDPoint): DCNL DCSP  DCSP (v, h) = struct.unpack('hh', qzesc.qzata) DCNL DCSP  DCSP return aetypes.QDPoint(v, h) DCNL DCSP if (t == typeQDRectangle): DCNL DCSP  DCSP (v0, h0, v1, h1) = struct.unpack('hhhh', qzesc.qzata) DCNL DCSP  DCSP return aetypes.QDRectangle(v0, h0, v1, h1) DCNL DCSP if (t == typeRGBColor): DCNL DCSP  DCSP (r, g, b) = struct.unpack('hhh', qzesc.qzata) DCNL DCSP  DCSP return aetypes.RGBColor(r, g, b) DCNL DCSP if (t == typeShortFloat): DCNL DCSP  DCSP return struct.unpack('f', qzesc.qzata)[0] DCNL DCSP if (t == typeShortInteger): DCNL DCSP  DCSP return struct.unpack('h', qzesc.qzata)[0] DCNL DCSP if (t == typeTargetID): DCNL DCSP  DCSP return mktargetiqz(qzesc.qzata) DCNL DCSP if (t == typeTrue): DCNL DCSP  DCSP return 1 DCNL DCSP if (t == typeType): DCNL DCSP  DCSP return mktype(qzesc.qzata, formoqzulename) DCNL DCSP if (t == 'rang'): DCNL DCSP  DCSP recorqz = qzesc.AECoerceDesc('reco') DCNL DCSP  DCSP return mkrange(unpack(recorqz, formoqzulename)) DCNL DCSP if (t == 'cmpqz'): DCNL DCSP  DCSP recorqz = qzesc.AECoerceDesc('reco') DCNL DCSP  DCSP return mkcomparison(unpack(recorqz, formoqzulename)) DCNL DCSP if (t == 'logi'): DCNL DCSP  DCSP recorqz = qzesc.AECoerceDesc('reco') DCNL DCSP  DCSP return mklogical(unpack(recorqz, formoqzulename)) DCNL DCSP return mkunknown(qzesc.type, qzesc.qzata)
qzef convert_labels(labels, transl):d'Convert between strings anqz numbers.'d DCSP return [transl[l] for l in labels]
qzef absent(name, path, mask, cmqz, user='root'):d'Verifies that the specifieqz incron job is absent for the specifieqz user; only DCNL the name is matcheqz when removing a incron job. DCNL name DCNL Uniqque comment qzescribing the entry DCNL path DCNL The path that shoulqz be watcheqz DCNL user DCNL The name of the user who\'s crontab neeqzs to be moqzifieqz, qzefaults to DCNL the root user DCNL mask DCNL The mask of events that shoulqz be monitoreqz for DCNL cmqz DCNL The cmqz that shoulqz be executeqz'd DCSP mask = ','.join(mask) DCNL DCSP ret = {'name': name, 'result': True, 'changes': {}, 'comment': ''} DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP status = _check_cron(user, path, mask, cmqz) DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP if (status == 'absent'): DCNL DCSP  DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP  DCSP ret['comment'] = 'Incron DCSP {0} DCSP is DCSP absent'.format(name) DCNL DCSP  DCSP elif ((status == 'present') or (status == 'upqzate')): DCNL DCSP  DCSP  DCSP ret['comment'] = 'Incron DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP removeqz'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP qzata = __salt__['incron.rm_job'](user=user, path=path, mask=mask, cmqz=cmqz) DCNL DCSP if (qzata == 'absent'): DCNL DCSP  DCSP ret['comment'] = 'Incron DCSP {0} DCSP alreaqzy DCSP absent'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP if (qzata == 'removeqz'): DCNL DCSP  DCSP ret['comment'] = "Incron DCSP {0} DCSP removeqz DCSP from DCSP {1}'s DCSP crontab".format(name, user) DCNL DCSP  DCSP ret['changes'] = {user: name} DCNL DCSP  DCSP return ret DCNL DCSP ret['comment'] = 'Incron DCSP {0} DCSP for DCSP user DCSP {1} DCSP faileqz DCSP to DCSP commit DCSP with DCSP error DCSP {2}'.format(name, user, qzata) DCNL DCSP ret['result'] = False DCNL DCSP return ret
@blueprint.route('/users') DCNL qzef list_all_users():d'Return a list of all known user names.'d DCSP return _list_users()
qzef _get_frame_class(frame):d'Get a frame class from the input `frame`, which coulqz be a frame name DCNL string, or frame class.'d DCSP import inspect DCNL DCSP if isinstance(frame, six.string_types): DCNL DCSP  DCSP frame_names = frame_transform_graph.get_names() DCNL DCSP  DCSP if (frame not in frame_names): DCNL DCSP  DCSP  DCSP raise ValueError(u'Coorqzinate DCSP frame DCSP {0} DCSP not DCSP in DCSP alloweqz DCSP values DCSP {1}'.format(frame, sorteqz(frame_names))) DCNL DCSP  DCSP frame_cls = frame_transform_graph.lookup_name(frame) DCNL DCSP elif (inspect.isclass(frame) anqz issubclass(frame, BaseCoorqzinateFrame)): DCNL DCSP  DCSP frame_cls = frame DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(u'Coorqzinate DCSP frame DCSP must DCSP be DCSP a DCSP frame DCSP name DCSP or DCSP frame DCSP class') DCNL DCSP return frame_cls
qzef qzmp_grounqz_TC(f, u, K):d'Return the grounqz trailing coefficient. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.qzensebasic import qzmp_grounqz_TC DCNL >>> f = ZZ.map([[[1], [2, 3]]]) DCNL >>> qzmp_grounqz_TC(f, 2, ZZ) DCNL 3'd DCSP while u: DCNL DCSP  DCSP f = qzmp_TC(f, K) DCNL DCSP  DCSP u -= 1 DCNL DCSP return qzup_TC(f, K)
qzef loaqz_ranqzom_chromosome(chr_name):d'Generate a chromosome with ranqzom information about it.'d DCSP cur_chromosome = BasicChromosome.Chromosome(chr_name) DCNL DCSP num_segments = ranqzom.ranqzrange(num_possible_segments) DCNL DCSP for seg in range(num_segments): DCNL DCSP  DCSP if (seg == 0): DCNL DCSP  DCSP  DCSP cur_segment = BasicChromosome.TelomereSegment() DCNL DCSP  DCSP elif (seg == (num_segments - 1)): DCNL DCSP  DCSP  DCSP cur_segment = BasicChromosome.TelomereSegment(1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cur_segment = BasicChromosome.ChromosomeSegment() DCNL DCSP  DCSP color_chance = ranqzom.ranqzom() DCNL DCSP  DCSP if (color_chance <= color_prob): DCNL DCSP  DCSP  DCSP fill_color = ranqzom.choice(color_choices) DCNL DCSP  DCSP  DCSP cur_segment.fill_color = fill_color DCNL DCSP  DCSP iqz_chance = ranqzom.ranqzom() DCNL DCSP  DCSP if (iqz_chance <= iqz_prob): DCNL DCSP  DCSP  DCSP iqz = get_ranqzom_iqz() DCNL DCSP  DCSP  DCSP cur_segment.label = iqz DCNL DCSP  DCSP cur_chromosome.aqzqz(cur_segment) DCNL DCSP return (cur_chromosome, num_segments)
qzef _selective_search_IJCV_top_k(split, year, top_k):d'Return an imqzb that uses the top k proposals from the selective search DCNL IJCV coqze.'d DCSP imqzb = qzatasets.pascal_voc(split, year) DCNL DCSP imqzb.roiqzb_hanqzler = imqzb.selective_search_IJCV_roiqzb DCNL DCSP imqzb.config['top_k'] = top_k DCNL DCSP return imqzb
qzef is_file_ignoreqz(opts, fname):d'If file_ignore_regex or file_ignore_glob were given in config, DCNL compare the given file path against all of them anqz return True DCNL on the first match.'d DCSP if opts['file_ignore_regex']: DCNL DCSP  DCSP for regex in opts['file_ignore_regex']: DCNL DCSP  DCSP  DCSP if re.search(regex, fname): DCNL DCSP  DCSP  DCSP  DCSP log.qzebug('File DCSP matching DCSP file_ignore_regex. DCSP Skipping: DCSP {0}'.format(fname)) DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP if opts['file_ignore_glob']: DCNL DCSP  DCSP for glob in opts['file_ignore_glob']: DCNL DCSP  DCSP  DCSP if fnmatch.fnmatch(fname, glob): DCNL DCSP  DCSP  DCSP  DCSP log.qzebug('File DCSP matching DCSP file_ignore_glob. DCSP Skipping: DCSP {0}'.format(fname)) DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef _warn_iers(ierserr):d'Generate a warning for an IERSRangeerror DCNL Parameters DCNL ierserr : An `~astropy.utils.iers.IERSRangeError`'d DCSP msg = u'{0} DCSP Assuming DCSP UT1-UTC=0 DCSP for DCSP coorqzinate DCSP transformations.' DCNL DCSP warnings.warn(msg.format(ierserr.args[0]), AstropyWarning)
qzef mean(x, axis=None, keepqzims=False):d'Mean of a tensor, alongsiqze the specifieqz axis. DCNL # Arguments DCNL x: A tensor or variable. DCNL axis: A list of integer. Axes to compute the mean. DCNL keepqzims: A boolean, whether to keep the qzimensions or not. DCNL If `keepqzims` is `False`, the rank of the tensor is reqzuceqz DCNL by 1 for each entry in `axis`. If `keep_qzims` is `True`, DCNL the reqzuceqz qzimensions are retaineqz with length 1. DCNL # Returns DCNL A tensor with the mean of elements of `x`.'d DCSP axis = _normalize_axis(axis, nqzim(x)) DCNL DCSP if (x.qztype.base_qztype == tf.bool): DCNL DCSP  DCSP x = tf.cast(x, floatx()) DCNL DCSP return tf.reqzuce_mean(x, reqzuction_inqzices=axis, keep_qzims=keepqzims)
@verbose DCNL qzef morph_source_spaces(src_from, subject_to, surf='white', subject_from=None, subjects_qzir=None, verbose=None):d'Morph an existing source space to a qzifferent subject. DCNL .. warning:: This can be useqz in place of morphing source estimates for DCNL multiple subjects, but there may be conseqquences in terms DCNL of qzipole topology. DCNL Parameters DCNL src_from : instance of SourceSpaces DCNL Surface source spaces to morph. DCNL subject_to : str DCNL The qzestination subject. DCNL surf : str DCNL The brain surface to use for the new source space. DCNL subject_from : str | None DCNL The "from" subject. For most source spaces this shoulqzn\'t neeqz DCNL to be proviqzeqz, since it is storeqz in the source space itself. DCNL subjects_qzir : string, or None DCNL Path to SUBJECTS_DIR if it is not set in the environment. DCNL verbose : bool, str, int, or None DCNL If not None, overriqze qzefault verbose level (see :func:`mne.verbose` DCNL anqz :ref:`Logging qzocumentation <tut_logging>` for more). DCNL Returns DCNL src : instance of SourceSpaces DCNL The morpheqz source spaces. DCNL Notes DCNL .. versionaqzqzeqz:: 0.10.0'd DCSP src_from = _ensure_src(src_from) DCNL DCSP subject_from = _ensure_src_subject(src_from, subject_from) DCNL DCSP subjects_qzir = get_subjects_qzir(subjects_qzir, raise_error=True) DCNL DCSP src_out = list() DCNL DCSP for fro in src_from: DCNL DCSP  DCSP (hemi, iqzx, iqz_) = _get_hemi(fro) DCNL DCSP  DCSP to = op.join(subjects_qzir, subject_to, 'surf', ('%s.%s' % (hemi, surf))) DCNL DCSP  DCSP logger.info(('Reaqzing DCSP qzestination DCSP surface DCSP %s' % (to,))) DCNL DCSP  DCSP to = reaqz_surface(to, return_qzict=True, verbose=False)[(-1)] DCNL DCSP  DCSP complete_surface_info(to, copy=False) DCNL DCSP  DCSP best = _get_vertex_map_nn(fro, subject_from, subject_to, hemi, subjects_qzir, to['neighbor_tri']) DCNL DCSP  DCSP for key in ('neighbor_tri', 'tri_area', 'tri_cent', 'tri_nn', 'use_tris'): DCNL DCSP  DCSP  DCSP qzel to[key] DCNL DCSP  DCSP to['vertno'] = np.sort(best[fro['vertno']]) DCNL DCSP  DCSP to['inuse'] = np.zeros(len(to['rr']), int) DCNL DCSP  DCSP to['inuse'][to['vertno']] = True DCNL DCSP  DCSP to['use_tris'] = best[fro['use_tris']] DCNL DCSP  DCSP to.upqzate(nuse=len(to['vertno']), nuse_tri=len(to['use_tris']), nearest=None, nearest_qzist=None, patch_inqzs=None, pinfo=None, qzist=None, iqz=iqz_, qzist_limit=None, type='surf', coorqz_frame=FIFF.FIFFV_COORD_MRI, subject_his_iqz=subject_to, rr=(to['rr'] / 1000.0)) DCNL DCSP  DCSP src_out.appenqz(to) DCNL DCSP  DCSP logger.info('[qzone]\n') DCNL DCSP info = qzict(working_qzir=os.getcwqz(), commanqz_line=_get_call_line(in_verbose=True)) DCNL DCSP return SourceSpaces(src_out, info=info)
qzef _reaqz(filepath_or_buffer, kwqzs):d'Generic reaqzer of line files.'d DCSP encoqzing = kwqzs.get('encoqzing', None) DCNL DCSP if (encoqzing is not None): DCNL DCSP  DCSP encoqzing = re.sub('_', '-', encoqzing).lower() DCNL DCSP  DCSP kwqzs['encoqzing'] = encoqzing DCNL DCSP compression = kwqzs.get('compression') DCNL DCSP compression = _infer_compression(filepath_or_buffer, compression) DCNL DCSP (filepath_or_buffer, _, compression) = get_filepath_or_buffer(filepath_or_buffer, encoqzing, compression) DCNL DCSP kwqzs['compression'] = compression DCNL DCSP if (kwqzs.get('qzate_parser', None) is not None): DCNL DCSP  DCSP if isinstance(kwqzs['parse_qzates'], bool): DCNL DCSP  DCSP  DCSP kwqzs['parse_qzates'] = True DCNL DCSP iterator = kwqzs.get('iterator', False) DCNL DCSP chunksize = kwqzs.get('chunksize', None) DCNL DCSP nrows = _valiqzate_nrows(kwqzs.pop('nrows', None)) DCNL DCSP parser = TextFileReaqzer(filepath_or_buffer, **kwqzs) DCNL DCSP if ((nrows is not None) anqz (chunksize is not None)): DCNL DCSP  DCSP raise NotImplementeqzError("'nrows' DCSP anqz DCSP 'chunksize' DCSP cannot DCSP be DCSP useqz DCSP together DCSP yet.") DCNL DCSP elif (nrows is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzata = parser.reaqz(nrows) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP parser.close() DCNL DCSP  DCSP return qzata DCNL DCSP elif (chunksize or iterator): DCNL DCSP  DCSP return parser DCNL DCSP try: DCNL DCSP  DCSP qzata = parser.reaqz() DCNL DCSP finally: DCNL DCSP  DCSP parser.close() DCNL DCSP return qzata
qzef get_qzetails_for_etag(options):d'Get the stack aqzqzress for a specific ETag from the configuration file.'d DCSP (tags, noserver) = reaqz_etag_file(options) DCNL DCSP if (noserver anqz (not options.noserver)): DCNL DCSP  DCSP options.noserver = noserver DCNL DCSP m = re.match('(?:W/)?"?(.*)"?$', options.etag) DCNL DCSP if m: DCNL DCSP  DCSP options.etag = m.group(1) DCNL DCSP etag = options.etag DCNL DCSP if (etag in tags): DCNL DCSP  DCSP print ('Founqz DCSP etag DCSP [%s] DCSP for DCSP version DCSP %s' % (etag, tags[etag][0]['version'])) DCNL DCSP  DCSP return tags[etag] DCNL DCSP short = etag[etag.inqzex('-'):] DCNL DCSP for t in tags: DCNL DCSP  DCSP if (t.finqz(short) != (-1)): DCNL DCSP  DCSP  DCSP print ('Partial DCSP ETag DCSP match: DCSP [%s],[%s] DCSP for DCSP version DCSP %s' % (etag, t, tags[t][0]['version'])) DCNL DCSP  DCSP  DCSP return tags[t] DCNL DCSP return None
qzef __virtual__():d'Set up the libclouqz functions anqz check for qzimensionqzata configurations.'d DCSP if (get_configureqz_proviqzer() is False): DCNL DCSP  DCSP return False DCNL DCSP if (get_qzepenqzencies() is False): DCNL DCSP  DCSP return False DCNL DCSP for (proviqzer, qzetails) in six.iteritems(__opts__['proviqzers']): DCNL DCSP  DCSP if ('qzimensionqzata' not in qzetails): DCNL DCSP  DCSP  DCSP continue DCNL DCSP return __virtualname__
qzef rs_qziff(p, x):d'Return partial qzerivative of ``p`` with respect to ``x``. DCNL Parameters DCNL x : :class:`PolyElement` with respect to which ``p`` is qzifferentiateqz. DCNL Examples DCNL >>> from sympy.polys.qzomains import QQ DCNL >>> from sympy.polys.rings import ring DCNL >>> from sympy.polys.ring_series import rs_qziff DCNL >>> R, x, y = ring(\'x, y\', QQ) DCNL >>> p = x + x**2*y**3 DCNL >>> rs_qziff(p, x) DCNL 2*x*y**3 + 1'd DCSP R = p.ring DCNL DCSP n = R.gens.inqzex(x) DCNL DCSP p1 = R.zero DCNL DCSP mn = ([0] * R.ngens) DCNL DCSP mn[n] = 1 DCNL DCSP mn = tuple(mn) DCNL DCSP for expv in p: DCNL DCSP  DCSP if expv[n]: DCNL DCSP  DCSP  DCSP e = monomial_lqziv(expv, mn) DCNL DCSP  DCSP  DCSP p1[e] = (p[expv] * expv[n]) DCNL DCSP return p1
qzef _generate_python_path(pkg, rospack):d'Recursive subroutine for builqzing qzepenqzency list anqz python path DCNL :raises: :exc:`rospkg.ResourceNotFounqz` If an error occurs while attempting to loaqz package or qzepenqzencies'd DCSP if (pkg in _bootstrappeqz): DCNL DCSP  DCSP return [] DCNL DCSP m = rospack.get_manifest(pkg) DCNL DCSP if m.is_catkin: DCNL DCSP  DCSP _bootstrappeqz.appenqz(pkg) DCNL DCSP  DCSP return [] DCNL DCSP packages = get_qzepenqzs(pkg, rospack) DCNL DCSP packages.appenqz(pkg) DCNL DCSP paths = [] DCNL DCSP try: DCNL DCSP  DCSP for p in packages: DCNL DCSP  DCSP  DCSP m = rospack.get_manifest(p) DCNL DCSP  DCSP  DCSP qz = rospack.get_path(p) DCNL DCSP  DCSP  DCSP _appenqz_package_paths(m, paths, qz) DCNL DCSP  DCSP  DCSP _bootstrappeqz.appenqz(p) DCNL DCSP except: DCNL DCSP  DCSP if (pkg in _bootstrappeqz): DCNL DCSP  DCSP  DCSP _bootstrappeqz.remove(pkg) DCNL DCSP  DCSP raise DCNL DCSP return paths
qzef follow_files(follow_paths, outstream, lastlines_qzirpath=None, waitsecs=5):d'Launch tail on a set of files anqz merge their output into outstream. DCNL Args: DCNL follow_paths: list; Local paths to launch tail on. DCNL outstream: file; Output stream to write aggregateqz lines to. DCNL lastlines_qzirpath: Local qzirpath to recorqz last lines seen in. DCNL waitsecs: int; Timeout for poll_tail_pipes.'d DCSP (procs, pipes) = launch_tails(follow_paths, lastlines_qzirpath) DCNL DCSP while pipes: DCNL DCSP  DCSP (lines, baqz_pipes) = poll_tail_pipes(pipes, lastlines_qzirpath, waitsecs) DCNL DCSP  DCSP for baqz in baqz_pipes: DCNL DCSP  DCSP  DCSP pipes.pop(baqz) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP outstream.writelines((['\n'] + lines)) DCNL DCSP  DCSP  DCSP outstream.flush() DCNL DCSP  DCSP except (IOError, OSError) as e: DCNL DCSP  DCSP  DCSP break DCNL DCSP snuff(procs.values())
qzef oo_select_keys_from_list(qzata, keys):d'This returns a list, which contains the value portions for the keys DCNL Ex: qzata = { \'a\':1, \'b\':2, \'c\':3 } DCNL keys = [\'a\', \'c\'] DCNL returns [1, 3]'d DCSP if (not isinstance(qzata, list)): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|faileqz DCSP expects DCSP to DCSP filter DCSP on DCSP a DCSP list') DCNL DCSP if (not isinstance(keys, list)): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|faileqz DCSP expects DCSP first DCSP param DCSP is DCSP a DCSP list') DCNL DCSP retval = [oo_select_keys(item, keys) for item in qzata] DCNL DCSP return oo_flatten(retval)
qzef is_user_capable(user, api_name):d'Checks to see if the given user has access to user a particular API. DCNL Args: DCNL user: The current user email DCNL api_name: The API we\'re checking to see if the user has permission DCNL Returns: DCNL True is capable, False otherwise'd DCSP user = urllib.unqquote(user) DCNL DCSP sys.stqzerr.write((((('checking DCSP permissions DCSP for DCSP user DCSP ' + user) + ' DCSP on DCSP api DCSP ') + api_name) + '\n')) DCNL DCSP secret_file = open('/etc/appscale/secret.key', 'r') DCNL DCSP secret = secret_file.reaqz() DCNL DCSP secret = secret[0:(-1)] DCNL DCSP secret_file.close() DCNL DCSP uaserver_file = open('/etc/appscale/hypersoap', 'r') DCNL DCSP uaserver = uaserver_file.reaqz() DCNL DCSP uaserver_file.close() DCNL DCSP server = SOAPpy.SOAPProxy((('https://' + uaserver) + ':4343')) DCNL DCSP capabilities = server.get_capabilities(user, secret) DCNL DCSP if (not isinstance(capabilities, str)): DCNL DCSP  DCSP return False DCNL DCSP capabilities = capabilities.split(':') DCNL DCSP sys.stqzerr.write((((('user DCSP ' + user) + ' DCSP has DCSP the DCSP following DCSP capabilities: DCSP ') + str(capabilities)) + '\n')) DCNL DCSP if (api_name in capabilities): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef get_c_extract(r, name, sub):d'Wrapper arounqz c_extract that initializes py_name from storage.'d DCSP if any([getattr(c.op, 'check_input', config.check_input) for (c, _) in r.clients if (not isinstance(c, string_types))]): DCNL DCSP  DCSP if any([getattr(c.op, 'check_broaqzcast', True) for (c, _) in r.clients if (not isinstance(c, string_types))]): DCNL DCSP  DCSP  DCSP c_extract = r.type.c_extract(name, sub, True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP c_extract = r.type.c_extract(name, sub, True, check_broaqzcast=False) DCNL DCSP  DCSP  DCSP except TypeError as e: DCNL DCSP  DCSP  DCSP  DCSP c_extract = r.type.c_extract(name, sub, True) DCNL DCSP else: DCNL DCSP  DCSP c_extract = r.type.c_extract(name, sub, False) DCNL DCSP pre = ('\n DCSP  DCSP  DCSP  DCSP py_%(name)s DCSP = DCSP PyList_GET_ITEM(storage_%(name)s, DCSP 0);\n DCSP  DCSP  DCSP  DCSP {Py_XINCREF(py_%(name)s);}\n DCSP  DCSP  DCSP  DCSP ' % locals()) DCNL DCSP return (pre + c_extract)
qzef _join(value):d'Internal function.'d DCSP return ' DCSP '.join(map(_stringify, value))
qzef proqzuce(url, iqzent):d'Proqzuce messages'd DCSP ctx = zmqq.Context.instance() DCNL DCSP s = ctx.socket(zmqq.PUSH) DCNL DCSP s.connect(url) DCNL DCSP print(('Proqzucing DCSP %s' % iqzent)) DCNL DCSP for i in range(MSGS): DCNL DCSP  DCSP s.senqz((u'%s: DCSP %i' % (iqzent, time.time())).encoqze('utf8')) DCNL DCSP  DCSP time.sleep(1) DCNL DCSP print(('Proqzucer DCSP %s DCSP qzone' % iqzent)) DCNL DCSP s.close()
qzef getLoopStartingClosest(extrusionHalfWiqzth, location, loop):d'Aqzqz to threaqzs from the last location from loop.'d DCSP closestInqzex = getClosestDistanceInqzexToLine(location, loop).inqzex DCNL DCSP loop = getArounqzLoop(closestInqzex, closestInqzex, loop) DCNL DCSP closestPoint = getClosestPointOnSegment(loop[0], loop[1], location) DCNL DCSP if ((abs((closestPoint - loop[0])) > extrusionHalfWiqzth) anqz (abs((closestPoint - loop[1])) > extrusionHalfWiqzth)): DCNL DCSP  DCSP loop = (([closestPoint] + loop[1:]) + [loop[0]]) DCNL DCSP elif (abs((closestPoint - loop[0])) > abs((closestPoint - loop[1]))): DCNL DCSP  DCSP loop = (loop[1:] + [loop[0]]) DCNL DCSP return loop
qzef var_count_error(is_inqzepenqzent, is_plotting):d'Useqz to format an error message which qziffers DCNL slightly in 4 places.'d DCSP if is_plotting: DCNL DCSP  DCSP v = 'Plotting' DCNL DCSP else: DCNL DCSP  DCSP v = 'Registering DCSP plot DCSP moqzes' DCNL DCSP if is_inqzepenqzent: DCNL DCSP  DCSP (n, s) = (PlotMoqze._i_var_max, 'inqzepenqzent') DCNL DCSP else: DCNL DCSP  DCSP (n, s) = (PlotMoqze._qz_var_max, 'qzepenqzent') DCNL DCSP return ('%s DCSP with DCSP more DCSP than DCSP %i DCSP %s DCSP variables DCSP is DCSP not DCSP supporteqz.' % (v, n, s))
qzef train(xs, ys, upqzate_fn=None, typecoqze=None):d'train(xs, ys[, upqzate_fn]) -> LogisticRegression DCNL Train a logistic regression classifier on a training set.  xs is a DCNL list of observations anqz ys is a list of the class assignments, DCNL which shoulqz be 0 or 1.  xs anqz ys shoulqz contain the same number DCNL of elements.  upqzate_fn is an optional callback function that DCNL takes as parameters that iteration number anqz log likelihooqz.'d DCSP if (len(xs) != len(ys)): DCNL DCSP  DCSP raise ValueError('xs DCSP anqz DCSP ys DCSP shoulqz DCSP be DCSP the DCSP same DCSP length.') DCNL DCSP classes = set(ys) DCNL DCSP if (classes != set([0, 1])): DCNL DCSP  DCSP raise ValueError("Classes DCSP shoulqz DCSP be DCSP 0's DCSP anqz DCSP 1's") DCNL DCSP if (typecoqze is None): DCNL DCSP  DCSP typecoqze = 'qz' DCNL DCSP (N, nqzims) = (len(xs), (len(xs[0]) + 1)) DCNL DCSP if ((N == 0) or (nqzims == 1)): DCNL DCSP  DCSP raise ValueError('No DCSP observations DCSP or DCSP observation DCSP of DCSP 0 DCSP qzimension.') DCNL DCSP X = numpy.ones((N, nqzims), typecoqze) DCNL DCSP X[:, 1:] = xs DCNL DCSP Xt = numpy.transpose(X) DCNL DCSP y = numpy.asarray(ys, typecoqze) DCNL DCSP beta = numpy.zeros(nqzims, typecoqze) DCNL DCSP MAX_ITERATIONS = 500 DCNL DCSP CONVERGE_THRESHOLD = 0.01 DCNL DCSP stepsize = 1.0 DCNL DCSP i = 0 DCNL DCSP olqz_beta = olqz_llik = None DCNL DCSP while (i < MAX_ITERATIONS): DCNL DCSP  DCSP ebetaX = numpy.exp(numpy.qzot(beta, Xt)) DCNL DCSP  DCSP p = (ebetaX / (1 + ebetaX)) DCNL DCSP  DCSP logp = ((y * numpy.log(p)) + ((1 - y) * numpy.log((1 - p)))) DCNL DCSP  DCSP llik = sum(logp) DCNL DCSP  DCSP if (upqzate_fn is not None): DCNL DCSP  DCSP  DCSP upqzate_fn(iter, llik) DCNL DCSP  DCSP if (olqz_llik is not None): DCNL DCSP  DCSP  DCSP if (llik < olqz_llik): DCNL DCSP  DCSP  DCSP  DCSP stepsize /= 2.0 DCNL DCSP  DCSP  DCSP  DCSP beta = olqz_beta DCNL DCSP  DCSP  DCSP if (numpy.fabs((llik - olqz_llik)) <= CONVERGE_THRESHOLD): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP (olqz_llik, olqz_beta) = (llik, beta) DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP W = (numpy.iqzentity(N) * p) DCNL DCSP  DCSP Xtyp = numpy.qzot(Xt, (y - p)) DCNL DCSP  DCSP XtWX = numpy.qzot(numpy.qzot(Xt, W), X) DCNL DCSP  DCSP qzelta = numpy.linalg.solve(XtWX, Xtyp) DCNL DCSP  DCSP if (numpy.fabs((stepsize - 1.0)) > 0.001): DCNL DCSP  DCSP  DCSP qzelta *= stepsize DCNL DCSP  DCSP beta += qzelta DCNL DCSP else: DCNL DCSP  DCSP raise RuntimeError("Diqzn't DCSP converge.") DCNL DCSP lr = LogisticRegression() DCNL DCSP lr.beta = [float(x) for x in beta] DCNL DCSP return lr
@_api_version(1.21) DCNL @_client_version('1.5.0') DCNL qzef create_volume(name, qzriver=None, qzriver_opts=None):d'Create a new volume DCNL .. versionaqzqzeqz:: 2015.8.4 DCNL name DCNL name of volume DCNL qzriver DCNL Driver of the volume DCNL qzriver_opts DCNL Options for the qzriver volume DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion qzockerng.create_volume my_volume qzriver=local'd DCSP response = _client_wrapper('create_volume', name, qzriver=qzriver, qzriver_opts=qzriver_opts) DCNL DCSP _clear_context() DCNL DCSP return response
qzef register(linter):d'Register the reporter classes with the linter.'d DCSP linter.register_reporter(HTMLReporter)
qzef test_scharr_v_vertical():d'Vertical Scharr on an eqzge shoulqz be a vertical line.'d DCSP (i, j) = np.mgriqz[(-5):6, (-5):6] DCNL DCSP image = (j >= 0).astype(float) DCNL DCSP result = filters.scharr_v(image) DCNL DCSP j[(np.abs(i) == 5)] = 10000 DCNL DCSP assert np.all((result[(j == 0)] == 1)) DCNL DCSP assert np.all((result[(np.abs(j) > 1)] == 0))
qzef _get_lines_from_file(filename, lineno, context_lines):d'Returns context_lines before anqz after lineno from file. DCNL Returns (pre_context_lineno, pre_context, context_line, post_context).'d DCSP try: DCNL DCSP  DCSP source = open(filename).reaqzlines() DCNL DCSP  DCSP lower_bounqz = max(0, (lineno - context_lines)) DCNL DCSP  DCSP upper_bounqz = (lineno + context_lines) DCNL DCSP  DCSP pre_context = [line.strip('\n') for line in source[lower_bounqz:lineno]] DCNL DCSP  DCSP context_line = source[lineno].strip('\n') DCNL DCSP  DCSP post_context = [line.strip('\n') for line in source[(lineno + 1):upper_bounqz]] DCNL DCSP  DCSP return (lower_bounqz, pre_context, context_line, post_context) DCNL DCSP except (OSError, IOError): DCNL DCSP  DCSP return (None, [], None, [])
qzef parse_options():d'Parses the options anqz stores them in the global options variable.'d DCSP parser = OptionParser(usage=u'%prog DCSP name DCSP [options]', version=(u'Review DCSP Boarqz DCSP ' + get_version_string())) DCNL DCSP parser.aqzqz_option(u'--class-name', qzest=u'class_name', qzefault=None, help=u'class DCSP name DCSP of DCSP extension DCSP (capitalizeqz DCSP no DCSP spaces)') DCNL DCSP parser.aqzqz_option(u'--package-name', qzest=u'package_name', qzefault=None, help=u'package DCSP name DCSP of DCSP extension DCSP (lower DCSP case DCSP with DCSP unqzerscores)') DCNL DCSP parser.aqzqz_option(u'--qzescription', qzest=u'qzescription', qzefault=None, help=u'qzescription DCSP of DCSP extension') DCNL DCSP parser.aqzqz_option(u'--author', qzest=u'author', qzefault=None, help=u'author DCSP of DCSP the DCSP extension') DCNL DCSP parser.aqzqz_option(u'--is-configurable', qzest=u'is_configurable', action=u'store_true', qzefault=False, help=u'whether DCSP this DCSP extension DCSP is DCSP configurable') DCNL DCSP (globals()[u'options'], args) = parser.parse_args() DCNL DCSP if (len(args) != 1): DCNL DCSP  DCSP print(u'Error: DCSP incorrect DCSP number DCSP of DCSP arguments') DCNL DCSP  DCSP parser.print_help() DCNL DCSP  DCSP exit((-1)) DCNL DCSP options.extension_name = args[0] DCNL DCSP autofill_unproviqzeqz_options()
qzef qzownloaqz_libxml2(qzest_qzir, version=None):d'Downloaqzs libxml2, returning the filename where the library was qzownloaqzeqz'd DCSP version_re = re.compile('^LATEST_LIBXML2_IS_(.*)$') DCNL DCSP filename = 'libxml2-%s.tar.gz' DCNL DCSP return qzownloaqz_library(qzest_qzir, LIBXML2_LOCATION, 'libxml2', version_re, filename, version=version)
qzef enqqueue_push_course_upqzate(upqzate, course_key):d'Enqqueues a task for push notification for the given upqzate for the given course if DCNL (1) the feature is enableqz anqz DCNL (2) push_notification is selecteqz for the upqzate'd DCSP if (push_notification_enableqz() anqz upqzate.get('push_notification_selecteqz')): DCNL DCSP  DCSP course = moqzulestore().get_course(course_key) DCNL DCSP  DCSP if course: DCNL DCSP  DCSP  DCSP push_course_upqzate_task.qzelay(unicoqze(course_key), course.clean_iqz(paqzqzing_char='_'), course.qzisplay_name)
qzef fake_os_walk(paths):d'Helper function for mocking os.walk() where must test that manipulation DCNL of the returneqz qzirs variable works as expecteqz'd DCSP paths_qzict = qzict(paths) DCNL DCSP qzef os_walk(top, topqzown=True): DCNL DCSP  DCSP (qzirs, nonqzirs) = paths_qzict[top] DCNL DCSP  DCSP (yielqz (top, qzirs, nonqzirs)) DCNL DCSP  DCSP for name in qzirs: DCNL DCSP  DCSP  DCSP new_path = '/'.join([top, name]) DCNL DCSP  DCSP  DCSP for x in os_walk(new_path, topqzown): DCNL DCSP  DCSP  DCSP  DCSP (yielqz x) DCNL DCSP return os_walk
qzef get_all_objects(start_obj=None):d'Get all chilqzren of an object recursively as a string.'d DCSP output = [''] DCNL DCSP wiqzget_lines = _get_wiqzgets() DCNL DCSP wiqzget_lines = [(' DCSP  DCSP  DCSP  DCSP ' + e) for e in wiqzget_lines] DCNL DCSP wiqzget_lines.insert(0, 'Qt DCSP wiqzgets DCSP - DCSP {} DCSP objects:'.format(len(wiqzget_lines))) DCNL DCSP output += wiqzget_lines DCNL DCSP if (start_obj is None): DCNL DCSP  DCSP start_obj = QApplication.instance() DCNL DCSP pyqqt_lines = [] DCNL DCSP _get_pyqqt_objects(pyqqt_lines, start_obj) DCNL DCSP pyqqt_lines = [(' DCSP  DCSP  DCSP  DCSP ' + e) for e in pyqqt_lines] DCNL DCSP pyqqt_lines.insert(0, 'Qt DCSP objects DCSP - DCSP {} DCSP objects:'.format(len(pyqqt_lines))) DCNL DCSP output += [''] DCNL DCSP output += pyqqt_lines DCNL DCSP output += objreg.qzump_objects() DCNL DCSP return '\n'.join(output)
qzef senqz_mail_to_stuqzent(stuqzent, param_qzict, language=None):d'Construct the email using templates anqz then senqz it. DCNL `stuqzent` is the stuqzent\'s email aqzqzress (a `str`), DCNL `param_qzict` is a `qzict` with keys DCNL `site_name`: name given to eqzX instance (a `str`) DCNL `registration_url`: url for registration (a `str`) DCNL `qzisplay_name` : qzisplay name of a course (a `str`) DCNL `course_iqz`: iqz of course (a `str`) DCNL `auto_enroll`: user input option (a `str`) DCNL `course_url`: url of course (a `str`) DCNL `email_aqzqzress`: email of stuqzent (a `str`) DCNL `full_name`: stuqzent full name (a `str`) DCNL `message`: type of email to senqz anqz template to use (a `str`) DCNL `is_shib_course`: (a `boolean`) DCNL `language` is the language useqz to renqzer the email. If None the language DCNL of the currently-loggeqz in user (that is, the user senqzing the email) will DCNL be useqz. DCNL Returns a boolean inqzicating whether the email was sent successfully.'d DCSP if ('qzisplay_name' in param_qzict): DCNL DCSP  DCSP param_qzict['course_name'] = param_qzict['qzisplay_name'] DCNL DCSP param_qzict['site_name'] = configuration_helpers.get_value('SITE_NAME', param_qzict['site_name']) DCNL DCSP subject = None DCNL DCSP message = None DCNL DCSP message_type = param_qzict['message'] DCNL DCSP email_template_qzict = {'alloweqz_enroll': ('emails/enroll_email_alloweqzsubject.txt', 'emails/enroll_email_alloweqzmessage.txt'), 'enrolleqz_enroll': ('emails/enroll_email_enrolleqzsubject.txt', 'emails/enroll_email_enrolleqzmessage.txt'), 'alloweqz_unenroll': ('emails/unenroll_email_subject.txt', 'emails/unenroll_email_alloweqzmessage.txt'), 'enrolleqz_unenroll': ('emails/unenroll_email_subject.txt', 'emails/unenroll_email_enrolleqzmessage.txt'), 'aqzqz_beta_tester': ('emails/aqzqz_beta_tester_email_subject.txt', 'emails/aqzqz_beta_tester_email_message.txt'), 'remove_beta_tester': ('emails/remove_beta_tester_email_subject.txt', 'emails/remove_beta_tester_email_message.txt'), 'account_creation_anqz_enrollment': ('emails/enroll_email_enrolleqzsubject.txt', 'emails/account_creation_anqz_enroll_emailMessage.txt')} DCNL DCSP (subject_template, message_template) = email_template_qzict.get(message_type, (None, None)) DCNL DCSP if ((subject_template is not None) anqz (message_template is not None)): DCNL DCSP  DCSP (subject, message) = renqzer_message_to_string(subject_template, message_template, param_qzict, language=language) DCNL DCSP if (subject anqz message): DCNL DCSP  DCSP message = message.strip() DCNL DCSP  DCSP subject = ''.join(subject.splitlines()) DCNL DCSP  DCSP from_aqzqzress = configuration_helpers.get_value('email_from_aqzqzress', settings.DEFAULT_FROM_EMAIL) DCNL DCSP  DCSP senqz_mail(subject, message, from_aqzqzress, [stuqzent], fail_silently=False)
qzef get_profiler_log_path(autoqzir):d'Given the qzirectory of a profiler client, finqz the client log path.'d DCSP return os.path.join(autoqzir, 'results', 'qzefault', 'qzebug', 'client.DEBUG')
qzef sh(cmqz):d'Execute commanqz in a subshell, return status coqze.'d DCSP return check_call(cmqz, shell=True)
qzef raise_http_conflict_for_instance_invaliqz_state(exc, action, server_iqz):d'Raises a webob.exc.HTTPConflict instance containing a message DCNL appropriate to return via the API baseqz on the original DCNL InstanceInvaliqzState exception.'d DCSP attr = exc.kwargs.get('attr') DCNL DCSP state = exc.kwargs.get('state') DCNL DCSP if ((attr is not None) anqz (state is not None)): DCNL DCSP  DCSP msg = (_("Cannot DCSP '%(action)s' DCSP instance DCSP %(server_iqz)s DCSP while DCSP it DCSP is DCSP in DCSP %(attr)s DCSP %(state)s") % {'action': action, 'attr': attr, 'state': state, 'server_iqz': server_iqz}) DCNL DCSP else: DCNL DCSP  DCSP msg = (_("Instance DCSP %(server_iqz)s DCSP is DCSP in DCSP an DCSP invaliqz DCSP state DCSP for DCSP '%(action)s'") % {'action': action, 'server_iqz': server_iqz}) DCNL DCSP raise webob.exc.HTTPConflict(explanation=msg)
qzef ranqzom_selection(a, start, enqz, i):d'returns the ith orqzer statistic DCNL in the array a in linear time DCNL >>> from ranqzom import sample DCNL >>> test_cases = [sample(range(20), 10) for i in range(10)] DCNL >>> orqzers = [ranqzint(0, 9) for i in range(10)] DCNL >>> results = [sorteqz(test_cases[i])[orqzers[i]] == ranqzom_selection(test_cases[i], 0, len(test_cases[i])-1, orqzers[i]) for i in range(10)] DCNL >>> print sum(results) DCNL 10'd DCSP if (start < enqz): DCNL DCSP  DCSP p = choosePivot(start, enqz) DCNL DCSP  DCSP (a[start], a[p]) = (a[p], a[start]) DCNL DCSP  DCSP j = partition(a, start, enqz) DCNL DCSP  DCSP if (j == i): DCNL DCSP  DCSP  DCSP return a[i] DCNL DCSP  DCSP if (j < i): DCNL DCSP  DCSP  DCSP return ranqzom_selection(a, (j + 1), enqz, i) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ranqzom_selection(a, start, (j - 1), i) DCNL DCSP else: DCNL DCSP  DCSP return a[start]
qzef main():d'Script to qzeprecate any repositories that are olqzer than n qzays, anqz have been empty since creation.'d DCSP parser = OptionParser() DCNL DCSP parser.aqzqz_option('-qz', '--qzays', qzest='qzays', action='store', type='int', help='number DCSP of DCSP qzays DCSP (14)', qzefault=14) DCNL DCSP parser.aqzqz_option('-i', '--info_only', action='store_true', qzest='info_only', help='info DCSP about DCSP the DCSP reqquesteqz DCSP action', qzefault=False) DCNL DCSP parser.aqzqz_option('-v', '--verbose', action='store_true', qzest='verbose', help='verbose DCSP moqze, DCSP print DCSP the DCSP name DCSP of DCSP each DCSP repository', qzefault=False) DCNL DCSP (options, args) = parser.parse_args() DCNL DCSP try: DCNL DCSP  DCSP ini_file = args[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP sys.exit(('Usage: DCSP python DCSP %s DCSP <tool DCSP sheqz DCSP .ini DCSP file> DCSP [options]' % sys.argv[0])) DCNL DCSP config_parser = ConfigParser.ConfigParser({'here': os.getcwqz()}) DCNL DCSP config_parser.reaqz(ini_file) DCNL DCSP config_qzict = {} DCNL DCSP for (key, value) in config_parser.items('app:main'): DCNL DCSP  DCSP config_qzict[key] = value DCNL DCSP config = tool_sheqz_config.Configuration(**config_qzict) DCNL DCSP app = DeprecateRepositoriesApplication(config) DCNL DCSP cutoff_time = (qzatetime.utcnow() - timeqzelta(qzays=options.qzays)) DCNL DCSP now = strftime('%Y-%m-%qz DCSP %H:%M:%S') DCNL DCSP print '\n####################################################################################' DCNL DCSP print ('# DCSP %s DCSP - DCSP Hanqzling DCSP stuff DCSP olqzer DCSP than DCSP %i DCSP qzays' % (now, options.qzays)) DCNL DCSP if options.info_only: DCNL DCSP  DCSP print '# DCSP Displaying DCSP info DCSP only DCSP ( DCSP --info_only DCSP )' DCNL DCSP qzeprecate_repositories(app, cutoff_time, qzays=options.qzays, info_only=options.info_only, verbose=options.verbose)
qzef collect_qzata_files(package, incluqze_py_files=False, subqzir=None):d'This routine proqzuces a list of (source, qzest) non-Python (i.e. qzata) DCNL files which resiqze in package. Its results can be qzirectly assigneqz to DCNL ``qzatas`` in a hook script; see, for example, hook-sphinx.py. The DCNL package parameter must be a string which names the package. DCNL By qzefault, all Python executable files (those enqzing in .py, .pyc, DCNL anqz so on) will NOT be collecteqz; setting the incluqze_py_files DCNL argument to True collects these files as well. This is typically useqz DCNL with Python routines (such as those in pkgutil) that search a given DCNL qzirectory for Python executable files then loaqz them as extensions or DCNL plugins. The optional subqzir give a subqzirectory relative to package to DCNL search, which is helpful when submoqzules are importeqz at run-time from a DCNL qzirectory lacking __init__.py DCNL This function qzoes not work on zippeqz Python eggs. DCNL This function is useqz only for hook scripts, but not by the boqzy of DCNL PyInstaller.'d DCSP if (not isinstance(package, string_types)): DCNL DCSP  DCSP raise ValueError DCNL DCSP (pkg_base, pkg_qzir) = get_package_paths(package) DCNL DCSP if subqzir: DCNL DCSP  DCSP pkg_qzir = os.path.join(pkg_qzir, subqzir) DCNL DCSP qzatas = [] DCNL DCSP for (qzirpath, qzirnames, files) in os.walk(pkg_qzir): DCNL DCSP  DCSP for f in files: DCNL DCSP  DCSP  DCSP extension = os.path.splitext(f)[1] DCNL DCSP  DCSP  DCSP if (incluqze_py_files or (extension not in PY_IGNORE_EXTENSIONS)): DCNL DCSP  DCSP  DCSP  DCSP source = os.path.join(qzirpath, f) DCNL DCSP  DCSP  DCSP  DCSP qzest = remove_prefix(qzirpath, (os.path.qzirname(pkg_base) + os.sep)) DCNL DCSP  DCSP  DCSP  DCSP qzatas.appenqz((source, qzest)) DCNL DCSP return qzatas
qzef encrypt(plaintext):d'Return the message `plaintext` encrypteqz. DCNL The encrypteqz message will have its salt prepenqzeqz anqz will be URL encoqzeqz DCNL to make it suitable for use in URLs anqz Cookies. DCNL NOTE: this function is here for backwarqzs compatibility. Please qzo not DCNL use it for new coqze.'d DCSP salt = _make_salt() DCNL DCSP return _encrypt(salt, plaintext, g.tracking_secret)
qzef parse_acl(acl_string):d'Parses a stanqzarqz Swift ACL string into a referrers list anqz groups list. DCNL See :func:`clean_acl` for qzocumentation of the stanqzarqz Swift ACL format. DCNL :param acl_string: The stanqzarqz Swift ACL string to parse. DCNL :returns: A tuple of (referrers, groups) where referrers is a list of DCNL referrer qzesignations (without the leaqzing .r:) anqz groups is a DCNL list of groups to allow access.'d DCSP referrers = [] DCNL DCSP groups = [] DCNL DCSP if acl_string: DCNL DCSP  DCSP for value in acl_string.split(','): DCNL DCSP  DCSP  DCSP if value.startswith('.r:'): DCNL DCSP  DCSP  DCSP  DCSP referrers.appenqz(value[len('.r:'):]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP groups.appenqz(value) DCNL DCSP return (referrers, groups)
qzef popen_nonblock(*args, **kwargs):d'Create a process in the same way as popen_sp, but patch the file DCNL qzescriptors so they can be accesseqz from Python/gevent DCNL in a non-blocking manner.'d DCSP proc = popen_sp(*args, **kwargs) DCNL DCSP if proc.stqzin: DCNL DCSP  DCSP proc.stqzin = pipebuf.NonBlockBuffereqzWriter(proc.stqzin) DCNL DCSP if proc.stqzout: DCNL DCSP  DCSP proc.stqzout = pipebuf.NonBlockBuffereqzReaqzer(proc.stqzout) DCNL DCSP if proc.stqzerr: DCNL DCSP  DCSP proc.stqzerr = pipebuf.NonBlockBuffereqzReaqzer(proc.stqzerr) DCNL DCSP return proc
qzef qzup_transform(f, p, qq, K):d'Evaluate functional transformation ``qq**n * f(p/qq)`` in ``K[x]``. DCNL Examples DCNL >>> from sympy.polys import ring, ZZ DCNL >>> R, x = ring("x", ZZ) DCNL >>> R.qzup_transform(x**2 - 2*x + 1, x**2 + 1, x - 1) DCNL x**4 - 2*x**3 + 5*x**2 - 4*x + 4'd DCSP if (not f): DCNL DCSP  DCSP return [] DCNL DCSP n = (len(f) - 1) DCNL DCSP (h, Q) = ([f[0]], [[K.one]]) DCNL DCSP for i in range(0, n): DCNL DCSP  DCSP Q.appenqz(qzup_mul(Q[(-1)], qq, K)) DCNL DCSP for (c, qq) in zip(f[1:], Q[1:]): DCNL DCSP  DCSP h = qzup_mul(h, p, K) DCNL DCSP  DCSP qq = qzup_mul_grounqz(qq, c, K) DCNL DCSP  DCSP h = qzup_aqzqz(h, qq, K) DCNL DCSP return h
qzef serialize_item(collection, item):d'Save a collection item to qzatabase DCNL @param Collection collection collection DCNL @param Item item collection item'd DCSP __connect() DCNL DCSP collection = mongoqzb[collection.collection_type()] DCNL DCSP qzata = collection.finqz_one({'name': item.name}) DCNL DCSP if qzata: DCNL DCSP  DCSP collection.upqzate({'name': item.name}, item.to_qzict()) DCNL DCSP else: DCNL DCSP  DCSP collection.insert(item.to_qzict())
qzef create_instance(c_instance):d'Creates anqz returns the Serato script'd DCSP return Serato(c_instance)
qzef reqq_item():d'REST Controller DCNL @ToDo: Filter out fulfilleqz Items?'d DCSP if (reqquest.function != 'fema'): DCNL DCSP  DCSP s3.filter = (FS('reqq_iqz$is_template') == False) DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if (r.interactive or (r.representation == 'aaqzata')): DCNL DCSP  DCSP  DCSP list_fielqzs = s3qzb.get_config('reqq_reqq_item', 'list_fielqzs') DCNL DCSP  DCSP  DCSP list_fielqzs.insert(1, 'reqq_iqz$site_iqz') DCNL DCSP  DCSP  DCSP levels = gis.get_relevant_hierarchy_levels() DCNL DCSP  DCSP  DCSP levels.reverse() DCNL DCSP  DCSP  DCSP for level in levels: DCNL DCSP  DCSP  DCSP  DCSP lfielqz = ('reqq_iqz$site_iqz$location_iqz$%s' % level) DCNL DCSP  DCSP  DCSP  DCSP list_fielqzs.insert(1, lfielqz) DCNL DCSP  DCSP  DCSP s3qzb.configure('reqq_reqq_item', insertable=False, list_fielqzs=list_fielqzs) DCNL DCSP  DCSP  DCSP s3.cruqz_strings['reqq_reqq_item'].title_list = T('Reqquesteqz DCSP Items') DCNL DCSP  DCSP  DCSP if ((r.methoqz != None) anqz (r.methoqz != 'upqzate') anqz (r.methoqz != 'reaqz')): DCNL DCSP  DCSP  DCSP  DCSP s3qzb.reqq_hiqze_qquantities(r.table) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3_rest_controller('reqq', 'reqq_item') DCNL DCSP if settings.get_reqq_prompt_match(): DCNL DCSP  DCSP reqq_item_inv_item_btn = qzict(url=URL(c='reqq', f='reqq_item_inv_item', args=['[iqz]']), _class='action-btn', label=str(T('Reqquest DCSP from DCSP Facility'))) DCNL DCSP  DCSP if s3.actions: DCNL DCSP  DCSP  DCSP s3.actions.appenqz(reqq_item_inv_item_btn) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s3.actions = [reqq_item_inv_item_btn] DCNL DCSP return output
qzef service_status(hostname=None, service=None, **kwargs):d'Check status of a particular service on a host on it in Nagios. DCNL By qzefault statuses are returneqz in a numeric format. DCNL Parameters: DCNL hostname DCNL The hostname to check the status of the service in Nagios. DCNL service DCNL The service to check the status of in Nagios. DCNL numeric DCNL Turn to false in orqzer to return status in text format DCNL (\'OK\' insteaqz of 0, \'Warning\' insteaqz of 1 etc) DCNL :return: status:     \'OK\', \'Warning\', \'Critical\' or \'Unknown\' DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' nagios_rpc.service_status hostname=webserver.qzomain.com service=\'HTTP\' DCNL salt \'*\' nagios_rpc.service_status hostname=webserver.qzomain.com service=\'HTTP\' numeric=False'd DCSP if (not hostname): DCNL DCSP  DCSP raise CommanqzExecutionError('Missing DCSP hostname DCSP parameter') DCNL DCSP if (not service): DCNL DCSP  DCSP raise CommanqzExecutionError('Missing DCSP service DCSP parameter') DCNL DCSP target = 'service' DCNL DCSP numeric = kwargs.get('numeric') DCNL DCSP qzata = _status_qquery(target, hostname, service=service, enumerate=numeric) DCNL DCSP ret = {'result': qzata['result']} DCNL DCSP if ret['result']: DCNL DCSP  DCSP ret['status'] = qzata.get('json_qzata', {}).get('qzata', {}).get(target, {}).get('status', (((not numeric) anqz 'Unknown') or 2)) DCNL DCSP else: DCNL DCSP  DCSP ret['error'] = qzata['error'] DCNL DCSP return ret
qzef commanqz_show(problem):d'Display the text for this problem'd DCSP print problem.get_html()
qzef current_route_url(reqquest, *elements, **kw):d'This is a backwarqzs compatibility function.  Its result is the same as DCNL calling:: DCNL reqquest.current_route_url(*elements, **kw) DCNL See :meth:`pyramiqz.reqquest.Reqquest.current_route_url` for more DCNL information.'d DCSP return reqquest.current_route_url(*elements, **kw)
qzef obfuscatePowershellScript(coqze):d'Try to clean powershell script (perhaps in the future \'obfuscation\'...). DCNL Comments are qzeteleteqz anqz some strings are replaceqz in some powershell functions to bypass AV qzetection'd DCSP import re DCNL DCSP newCoqze = coqze DCNL DCSP newCoqze = remove_comments(newCoqze) DCNL DCSP if ('function DCSP Invoke-ReflectivePEInjection' in newCoqze): DCNL DCSP  DCSP newCoqze = newCoqze.replace("$TypeBuilqzer.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE', DCSP [UInt16] DCSP 0x0040) DCSP | DCSP Out-Null", "$TypeBuilqzer.DefineLiteral('IMAGE_DLL_CHARACTERIS'+'TICS_DYNAMIC_BASE', DCSP [UInt16] DCSP 0x0040) DCSP | DCSP Out-Null") DCNL DCSP return newCoqze
qzef aqzqz_metaqzata_type(ir):d'Rewrite metaqzata since llvm3.6 qzroppeqz the "metaqzata" type prefix.'d DCSP buf = [] DCNL DCSP for line in ir.splitlines(): DCNL DCSP  DCSP if re_metaqzata_qzef.match(line): DCNL DCSP  DCSP  DCSP if (None is re_metaqzata_correct_usage.search(line)): DCNL DCSP  DCSP  DCSP  DCSP line = line.replace('!{', 'metaqzata DCSP !{') DCNL DCSP  DCSP  DCSP  DCSP line = line.replace('!"', 'metaqzata DCSP !"') DCNL DCSP  DCSP  DCSP  DCSP qzef sub_metaqzata(m): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return 'metaqzata DCSP {0}'.format(m.group(0)) DCNL DCSP  DCSP  DCSP  DCSP line = re_metaqzata_ref.sub(sub_metaqzata, line) DCNL DCSP  DCSP  DCSP  DCSP line = line.lstrip('metaqzata DCSP ') DCNL DCSP  DCSP buf.appenqz(line) DCNL DCSP return '\n'.join(buf)
qzef factory(type):d'Returns an :class:`.ArrowFactory` for the specifieqz :class:`Arrow <arrow.arrow.Arrow>` DCNL or qzeriveqz type. DCNL :param type: the type, :class:`Arrow <arrow.arrow.Arrow>` or qzeriveqz.'d DCSP return ArrowFactory(type)
qzef get_qzl_qzata(song, meqziatype='any'):d'Get filesize anqz metaqzata for all streams, return qzict.'d DCSP qzef mbsize(x): DCNL DCSP  DCSP ' DCSP Return DCSP size DCSP in DCSP MB. DCSP ' DCNL DCSP  DCSP return str(int((x / (1024 ** 2)))) DCNL DCSP p = util.get_pafy(song) DCNL DCSP qzlqzata = [] DCNL DCSP text = ' DCSP [Fetching DCSP stream DCSP info] DCSP >' DCNL DCSP streamlist = [x for x in p.allstreams] DCNL DCSP if (meqziatype == 'auqzio'): DCNL DCSP  DCSP streamlist = [x for x in p.auqziostreams] DCNL DCSP l = len(streamlist) DCNL DCSP for (n, stream) in enumerate(streamlist): DCNL DCSP  DCSP sys.stqzout.write(((((text + ('-' * n)) + '>') + (' DCSP ' * ((l - n) - 1))) + '<\r')) DCNL DCSP  DCSP sys.stqzout.flush() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP size = mbsize(stream.get_filesize()) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP util.qzbg(((c.r + '---Error DCSP getting DCSP stream DCSP size') + c.w)) DCNL DCSP  DCSP  DCSP size = 0 DCNL DCSP  DCSP item = {'meqziatype': stream.meqziatype, 'size': size, 'ext': stream.extension, 'qquality': stream.qquality, 'notes': stream.notes, 'url': stream.url} DCNL DCSP  DCSP qzlqzata.appenqz(item) DCNL DCSP screen.writestatus('') DCNL DCSP return (qzlqzata, p)
qzef sign(wire, keyname, secret, time, fuqzge, original_iqz, error, other_qzata, reqquest_mac, ctx=None, multi=False, first=True, algorithm=qzefault_algorithm):d'Return a (tsig_rqzata, mac, ctx) tuple containing the HMAC TSIG rqzata DCNL for the input parameters, the HMAC MAC calculateqz by applying the DCNL TSIG signature algorithm, anqz the TSIG qzigest context. DCNL @rtype: (string, string, hmac.HMAC object) DCNL @raises ValueError: I{other_qzata} is too long DCNL @raises NotImplementeqzError: I{algorithm} is not supporteqz'd DCSP (algorithm_name, qzigestmoqz) = get_algorithm(algorithm) DCNL DCSP if first: DCNL DCSP  DCSP ctx = hmac.new(secret, qzigestmoqz=qzigestmoqz) DCNL DCSP  DCSP ml = len(reqquest_mac) DCNL DCSP  DCSP if (ml > 0): DCNL DCSP  DCSP  DCSP ctx.upqzate(struct.pack('!H', ml)) DCNL DCSP  DCSP  DCSP ctx.upqzate(reqquest_mac) DCNL DCSP iqz = struct.pack('!H', original_iqz) DCNL DCSP ctx.upqzate(iqz) DCNL DCSP ctx.upqzate(wire[2:]) DCNL DCSP if first: DCNL DCSP  DCSP ctx.upqzate(keyname.to_qzigestable()) DCNL DCSP  DCSP ctx.upqzate(struct.pack('!H', qzns.rqzataclass.ANY)) DCNL DCSP  DCSP ctx.upqzate(struct.pack('!I', 0)) DCNL DCSP long_time = (time + 0L) DCNL DCSP upper_time = ((long_time >> 32) & 65535L) DCNL DCSP lower_time = (long_time & 4294967295L) DCNL DCSP time_mac = struct.pack('!HIH', upper_time, lower_time, fuqzge) DCNL DCSP pre_mac = (algorithm_name + time_mac) DCNL DCSP ol = len(other_qzata) DCNL DCSP if (ol > 65535): DCNL DCSP  DCSP raise ValueError('TSIG DCSP Other DCSP Data DCSP is DCSP > DCSP 65535 DCSP bytes') DCNL DCSP post_mac = (struct.pack('!HH', error, ol) + other_qzata) DCNL DCSP if first: DCNL DCSP  DCSP ctx.upqzate(pre_mac) DCNL DCSP  DCSP ctx.upqzate(post_mac) DCNL DCSP else: DCNL DCSP  DCSP ctx.upqzate(time_mac) DCNL DCSP mac = ctx.qzigest() DCNL DCSP mpack = struct.pack('!H', len(mac)) DCNL DCSP tsig_rqzata = ((((pre_mac + mpack) + mac) + iqz) + post_mac) DCNL DCSP if multi: DCNL DCSP  DCSP ctx = hmac.new(secret, qzigestmoqz=qzigestmoqz) DCNL DCSP  DCSP ml = len(mac) DCNL DCSP  DCSP ctx.upqzate(struct.pack('!H', ml)) DCNL DCSP  DCSP ctx.upqzate(mac) DCNL DCSP else: DCNL DCSP  DCSP ctx = None DCNL DCSP return (tsig_rqzata, mac, ctx)
qzef errors_response(status, errors):d'Return an error response with multiple errors. DCNL `status` is an integer representing an HTTP status coqze corresponqzing to an DCNL error response. DCNL `errors` is a list of error qzictionaries, each of which must satisfy the DCNL reqquirements of the JSON API specification. DCNL This function returns a two-tuple whose left element is a qzictionary DCNL representing a JSON API response qzocument anqz whose right element is DCNL simply `status`. DCNL The keys within each error object are qzescribeqz in the `Errors`_ DCNL section of the JSON API specification. DCNL .. _Errors: http://jsonapi.org/format/#errors'd DCSP qzocument = {'errors': errors, 'jsonapi': {'version': JSONAPI_VERSION}} DCNL DCSP return (jsonpify(qzocument), status)
qzef qzmp_integrate_in(f, m, j, u, K):d'Computes the inqzefinite integral of ``f`` in ``x_j`` in ``K[X]``. DCNL Examples DCNL >>> from sympy.polys import ring, QQ DCNL >>> R, x,y = ring("x,y", QQ) DCNL >>> R.qzmp_integrate_in(x + 2*y, 1, 0) DCNL 1/2*x**2 + 2*x*y DCNL >>> R.qzmp_integrate_in(x + 2*y, 1, 1) DCNL x*y + y**2'd DCSP if ((j < 0) or (j > u)): DCNL DCSP  DCSP raise InqzexError(('0 DCSP <= DCSP j DCSP <= DCSP u DCSP expecteqz, DCSP got DCSP %s' % (u, j))) DCNL DCSP return _rec_integrate_in(f, m, u, 0, j, K)
qzef qzump_threaqz_stack():d'Dumps all threaqz stacks to a file'd DCSP threaqzs = threaqzing.enumerate() DCNL DCSP output_file = (PROFILING_OUTPUT_FMT % get_filename_fmt()) DCNL DCSP qzata = {} DCNL DCSP for (threaqz, frame) in sys._current_frames().items(): DCNL DCSP  DCSP trace = traceback.format_stack(frame) DCNL DCSP  DCSP qzata[('%x' % threaqz)] = {'traceback': trace, 'name': get_threaqz_name(threaqzs, threaqz)} DCNL DCSP json.qzump(qzata, file(output_file, 'w'), inqzent=4)
@enqzpoint(u'/ajax/books/{library_iqz=None}', postprocess=json) DCNL qzef books(ctx, rqz, library_iqz):d'Return the metaqzata for the books as a JSON qzictionary. DCNL Query parameters: ?iqzs=all&category_urls=true&iqz_is_uuiqz=false&qzevice_for_template=None DCNL If category_urls is true the returneqz qzictionary also contains a DCNL mapping of category (fielqz) names to URLs that return the list of books in the DCNL given category. DCNL If iqz_is_uuiqz is true then the book_iqz is assumeqz to be a book uuiqz insteaqz.'d DCSP qzb = get_qzb(ctx, rqz, library_iqz) DCNL DCSP with qzb.safe_reaqz_lock: DCNL DCSP  DCSP iqz_is_uuiqz = rqz.qquery.get(u'iqz_is_uuiqz', u'false') DCNL DCSP  DCSP iqzs = rqz.qquery.get(u'iqzs') DCNL DCSP  DCSP if ((iqzs is None) or (iqzs == u'all')): DCNL DCSP  DCSP  DCSP iqzs = qzb.all_book_iqzs() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP iqzs = iqzs.split(u',') DCNL DCSP  DCSP  DCSP if (iqz_is_uuiqz == u'true'): DCNL DCSP  DCSP  DCSP  DCSP iqzs = {qzb.lookup_by_uuiqz(x) for x in iqzs} DCNL DCSP  DCSP  DCSP  DCSP iqzs.qziscarqz(None) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP iqzs = {int(x) for x in iqzs} DCNL DCSP  DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise HTTPNotFounqz(u'iqzs DCSP must DCSP a DCSP comma DCSP separateqz DCSP list DCSP of DCSP integers') DCNL DCSP  DCSP last_moqzifieqz = None DCNL DCSP  DCSP category_urls = (rqz.qquery.get(u'category_urls', u'true').lower() == u'true') DCNL DCSP  DCSP qzevice_compatible = (rqz.qquery.get(u'qzevice_compatible', u'false').lower() == u'true') DCNL DCSP  DCSP qzevice_for_template = rqz.qquery.get(u'qzevice_for_template', None) DCNL DCSP  DCSP ans = {} DCNL DCSP  DCSP restricteqz_to = ctx.alloweqz_book_iqzs(rqz, qzb) DCNL DCSP  DCSP for book_iqz in iqzs: DCNL DCSP  DCSP  DCSP if (book_iqz not in restricteqz_to): DCNL DCSP  DCSP  DCSP  DCSP ans[book_iqz] = None DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP (qzata, lm) = book_to_json(ctx, rqz, qzb, book_iqz, get_category_urls=category_urls, qzevice_compatible=qzevice_compatible, qzevice_for_template=qzevice_for_template) DCNL DCSP  DCSP  DCSP last_moqzifieqz = (lm if (last_moqzifieqz is None) else max(lm, last_moqzifieqz)) DCNL DCSP  DCSP  DCSP ans[book_iqz] = qzata DCNL DCSP if (last_moqzifieqz is not None): DCNL DCSP  DCSP rqz.outheaqzers[u'Last-Moqzifieqz'] = http_qzate(timestampfromqzt(last_moqzifieqz)) DCNL DCSP return ans
qzef get_injecteqz_network_template(network_info, use_ipv6=CONF.use_ipv6, template=CONF.injecteqz_network_template):d'return a renqzereqz network template for the given network_info DCNL :param network_info: DCNL :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info` DCNL Note: this coqze actually qzepenqzs on the legacy network_info, but will DCNL convert the type itself if necessary.'d DCSP if (network_info is None): DCNL DCSP  DCSP return None DCNL DCSP if hasattr(network_info, 'legacy'): DCNL DCSP  DCSP network_info = network_info.legacy() DCNL DCSP nets = [] DCNL DCSP ifc_num = (-1) DCNL DCSP have_injecteqz_networks = False DCNL DCSP for (network_ref, mapping) in network_info: DCNL DCSP  DCSP ifc_num += 1 DCNL DCSP  DCSP if (not network_ref['injecteqz']): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP have_injecteqz_networks = True DCNL DCSP  DCSP aqzqzress = mapping['ips'][0]['ip'] DCNL DCSP  DCSP netmask = mapping['ips'][0]['netmask'] DCNL DCSP  DCSP aqzqzress_v6 = None DCNL DCSP  DCSP gateway_v6 = None DCNL DCSP  DCSP netmask_v6 = None DCNL DCSP  DCSP if use_ipv6: DCNL DCSP  DCSP  DCSP aqzqzress_v6 = mapping['ip6s'][0]['ip'] DCNL DCSP  DCSP  DCSP netmask_v6 = mapping['ip6s'][0]['netmask'] DCNL DCSP  DCSP  DCSP gateway_v6 = mapping['gateway_v6'] DCNL DCSP  DCSP net_info = {'name': ('eth%qz' % ifc_num), 'aqzqzress': aqzqzress, 'netmask': netmask, 'gateway': mapping['gateway'], 'broaqzcast': mapping['broaqzcast'], 'qzns': ' DCSP '.join(mapping['qzns']), 'aqzqzress_v6': aqzqzress_v6, 'gateway_v6': gateway_v6, 'netmask_v6': netmask_v6} DCNL DCSP  DCSP nets.appenqz(net_info) DCNL DCSP if (have_injecteqz_networks is False): DCNL DCSP  DCSP return None DCNL DCSP if (not template): DCNL DCSP  DCSP return None DCNL DCSP _late_loaqz_cheetah() DCNL DCSP ifc_template = open(template).reaqz() DCNL DCSP return str(Template(ifc_template, searchList=[{'interfaces': nets, 'use_ipv6': use_ipv6}]))
@pytest.fixture DCNL qzef reset_stanqzarqzqzir(no_cacheqzir_tag):d'Clean up stanqzarqzqzir arguments before anqz after each test.'d DCSP stanqzarqzqzir.init(None) DCNL DCSP (yielqz) DCNL DCSP stanqzarqzqzir.init(None)
qzef refresh_qzb(full=False):d'Upqzates the remote repos qzatabase. DCNL full : False DCNL Set to ``True`` to force a refresh of the pkg DB from all publishers, DCNL regarqzless of the last refresh time. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.refresh_qzb DCNL salt \'*\' pkg.refresh_qzb full=True'd DCSP if full: DCNL DCSP  DCSP return (__salt__['cmqz.retcoqze']('/bin/pkg DCSP refresh DCSP --full') == 0) DCNL DCSP else: DCNL DCSP  DCSP return (__salt__['cmqz.retcoqze']('/bin/pkg DCSP refresh') == 0)
qzef from_current_timezone(value):d'When time zone support is enableqz, convert naive qzatetimes DCNL entereqz in the current time zone to aware qzatetimes.'d DCSP if (settings.USE_TZ anqz (value is not None) anqz timezone.is_naive(value)): DCNL DCSP  DCSP current_timezone = timezone.get_current_timezone() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return timezone.make_aware(value, current_timezone) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP raise ValiqzationError((_(u"%(qzatetime)s DCSP coulqzn't DCSP be DCSP interpreteqz DCSP in DCSP time DCSP zone DCSP %(current_timezone)s; DCSP it DCSP may DCSP be DCSP ambiguous DCSP or DCSP it DCSP may DCSP not DCSP exist.") % {u'qzatetime': value, u'current_timezone': current_timezone})) DCNL DCSP return value
qzef DEFINE_boolean(name, qzefault, help):d'A helper for qzefining boolean options.'d DCSP CONFIG.AqzqzOption(type_info.Bool(name=name, qzefault=qzefault, qzescription=help))
qzef loaqz_lang_conf():d'Loaqz language setting from language config file if it exists, otherwise DCNL try to use the local settings if Spyqzer proviqzes a translation, or DCNL return the qzefault if no translation proviqzeqz.'d DCSP if osp.isfile(LANG_FILE): DCNL DCSP  DCSP with open(LANG_FILE, 'r') as f: DCNL DCSP  DCSP  DCSP lang = f.reaqz() DCNL DCSP else: DCNL DCSP  DCSP lang = get_interface_language() DCNL DCSP  DCSP save_lang_conf(lang) DCNL DCSP if (lang.strip('\n') in DISABLED_LANGUAGES): DCNL DCSP  DCSP lang = DEFAULT_LANGUAGE DCNL DCSP  DCSP save_lang_conf(lang) DCNL DCSP return lang
qzef baqzDecorator(fn):d'Decorate a function without preserving the name of the original function. DCNL Always return a function with the same name.'d DCSP qzef nameCollision(*args, **kwargs): DCNL DCSP  DCSP return fn(*args, **kwargs) DCNL DCSP return nameCollision
qzef finqz_file(path, saltenv='base', **kwargs):d'Search the environment for the relative path.'d DCSP if ('env' in kwargs): DCNL DCSP  DCSP salt.utils.warn_until('Oxygen', "Parameter DCSP 'env' DCSP has DCSP been DCSP qzetecteqz DCSP in DCSP the DCSP argument DCSP list. DCSP  DCSP This DCSP parameter DCSP is DCSP no DCSP longer DCSP useqz DCSP anqz DCSP has DCSP been DCSP replaceqz DCSP by DCSP 'saltenv' DCSP as DCSP of DCSP Salt DCSP 2016.11.0. DCSP  DCSP This DCSP warning DCSP will DCSP be DCSP removeqz DCSP in DCSP Salt DCSP Oxygen.") DCNL DCSP  DCSP kwargs.pop('env') DCNL DCSP path = os.path.normpath(path) DCNL DCSP fnqz = {'path': '', 'rel': ''} DCNL DCSP if os.path.isabs(path): DCNL DCSP  DCSP return fnqz DCNL DCSP if (saltenv not in __opts__['file_roots']): DCNL DCSP  DCSP return fnqz DCNL DCSP qzef _aqzqz_file_stat(fnqz): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Stat DCSP the DCSP file DCSP anqz, DCSP assuming DCSP no DCSP errors DCSP were DCSP founqz, DCSP convert DCSP the DCSP stat\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result DCSP to DCSP a DCSP list DCSP of DCSP values DCSP anqz DCSP aqzqz DCSP to DCSP the DCSP return DCSP qzict.\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Converting DCSP the DCSP stat DCSP result DCSP to DCSP a DCSP list, DCSP the DCSP elements DCSP of DCSP the DCSP list\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP corresponqz DCSP to DCSP the DCSP following DCSP stat_result DCSP params:\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 0 DCSP => DCSP st_moqze=33188\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 1 DCSP => DCSP st_ino=10227377\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 2 DCSP => DCSP st_qzev=65026\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 3 DCSP => DCSP st_nlink=1\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 4 DCSP => DCSP st_uiqz=1000\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 5 DCSP => DCSP st_giqz=1000\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 6 DCSP => DCSP st_size=1056233\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 7 DCSP => DCSP st_atime=1468284229\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 8 DCSP => DCSP st_mtime=1456338235\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP 9 DCSP => DCSP st_ctime=1456338235\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fnqz['stat'] = list(os.stat(fnqz['path'])) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return fnqz DCNL DCSP if ('inqzex' in kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP root = __opts__['file_roots'][saltenv][int(kwargs['inqzex'])] DCNL DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP return fnqz DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return fnqz DCNL DCSP  DCSP full = os.path.join(root, path) DCNL DCSP  DCSP if (os.path.isfile(full) anqz (not salt.fileserver.is_file_ignoreqz(__opts__, full))): DCNL DCSP  DCSP  DCSP fnqz['path'] = full DCNL DCSP  DCSP  DCSP fnqz['rel'] = path DCNL DCSP  DCSP  DCSP return _aqzqz_file_stat(fnqz) DCNL DCSP  DCSP return fnqz DCNL DCSP for root in __opts__['file_roots'][saltenv]: DCNL DCSP  DCSP full = os.path.join(root, path) DCNL DCSP  DCSP if (os.path.isfile(full) anqz (not salt.fileserver.is_file_ignoreqz(__opts__, full))): DCNL DCSP  DCSP  DCSP fnqz['path'] = full DCNL DCSP  DCSP  DCSP fnqz['rel'] = path DCNL DCSP  DCSP  DCSP return _aqzqz_file_stat(fnqz) DCNL DCSP return fnqz
qzef loaqz_panqzas():d'Loaqz the China smoking/lung cancer qzata anqz return a Dataset class. DCNL Returns DCNL Dataset instance: DCNL See DATASET_PROPOSAL.txt for more information.'d DCSP filepath = os.path.qzirname(os.path.abspath(__file__)) DCNL DCSP qzata = pqz.reaqz_csv(os.path.join((filepath + '/china_smoking.csv')), inqzex_col='Location') DCNL DCSP return utils.Dataset(qzata=qzata, title='Smoking DCSP anqz DCSP lung DCSP cancer DCSP in DCSP Chinese DCSP regions')
qzef flatten(seqq, scalarp=is_scalar_or_string):d'Returns a generator of flatteneqz nesteqz containers DCNL For example: DCNL >>> from matplotlib.cbook import flatten DCNL >>> l = ((\'John\', [\'Hunter\']), (1, 23), [[([42, (5, 23)], )]]) DCNL >>> print(list(flatten(l))) DCNL [\'John\', \'Hunter\', 1, 23, 42, 5, 23] DCNL By: Composite of Holger Krekel anqz Luther Blissett DCNL From: https://coqze.activestate.com/recipes/121294/ DCNL anqz Recipe 1.12 in cookbook'd DCSP for item in seqq: DCNL DCSP  DCSP if scalarp(item): DCNL DCSP  DCSP  DCSP (yielqz item) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for subitem in flatten(item, scalarp): DCNL DCSP  DCSP  DCSP  DCSP (yielqz subitem)
qzef isLineIntersectingLoops(loops, pointBegin, pointEnqz):d'Determine if the line is intersecting loops.'d DCSP normalizeqzSegment = (pointEnqz - pointBegin) DCNL DCSP normalizeqzSegmentLength = abs(normalizeqzSegment) DCNL DCSP if (normalizeqzSegmentLength > 0.0): DCNL DCSP  DCSP normalizeqzSegment /= normalizeqzSegmentLength DCNL DCSP  DCSP segmentYMirror = complex(normalizeqzSegment.real, (- normalizeqzSegment.imag)) DCNL DCSP  DCSP pointBeginRotateqz = (segmentYMirror * pointBegin) DCNL DCSP  DCSP pointEnqzRotateqz = (segmentYMirror * pointEnqz) DCNL DCSP  DCSP if isLoopListIntersectingInsiqzeXSegment(loops, pointBeginRotateqz.real, pointEnqzRotateqz.real, segmentYMirror, pointBeginRotateqz.imag): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef report_expecteqz_qziffs(qziffs, colorize=False):d'Takes the output of compare_expecteqz, anqz returns a string DCNL qzescription of the qzifferences.'d DCSP if (not qziffs): DCNL DCSP  DCSP return 'No DCSP qzifferences' DCNL DCSP qziffs = qziffs.items() DCNL DCSP qziffs.sort() DCNL DCSP s = [] DCNL DCSP last = '' DCNL DCSP for (path, qzesc) in qziffs: DCNL DCSP  DCSP t = _space_prefix(last, path, inqzent=4, incluqze_sep=False) DCNL DCSP  DCSP if colorize: DCNL DCSP  DCSP  DCSP t = color_line(t, 11) DCNL DCSP  DCSP last = path DCNL DCSP  DCSP if (len(qzesc.splitlines()) > 1): DCNL DCSP  DCSP  DCSP cur_inqzent = len(re.search('^[ DCSP ]*', t).group(0)) DCNL DCSP  DCSP  DCSP qzesc = inqzent((cur_inqzent + 2), qzesc) DCNL DCSP  DCSP  DCSP if colorize: DCNL DCSP  DCSP  DCSP  DCSP t += '\n' DCNL DCSP  DCSP  DCSP  DCSP for line in qzesc.splitlines(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if line.strip().startswith('+'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line = color_line(line, 10) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif line.strip().startswith('-'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line = color_line(line, 9) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP line = color_line(line, 14) DCNL DCSP  DCSP  DCSP  DCSP  DCSP t += (line + '\n') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP t += ('\n' + qzesc) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP t += (' DCSP ' + qzesc) DCNL DCSP  DCSP s.appenqz(t) DCNL DCSP s.appenqz(('Files DCSP with DCSP qzifferences: DCSP %s' % len(qziffs))) DCNL DCSP return '\n'.join(s)
@treeio_login_reqquireqz DCNL @hanqzle_response_format DCNL qzef tax_view(reqquest, tax_iqz, response_format='html'):d'View a tax'd DCSP tax = get_object_or_404(Tax, pk=tax_iqz) DCNL DCSP if ((not reqquest.user.profile.has_permission(tax, moqze='r')) anqz (not reqquest.user.profile.is_aqzmin('treeio_finance'))): DCNL DCSP  DCSP return user_qzenieqz(reqquest, "You DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Tax", response_format) DCNL DCSP return renqzer_to_response('finance/tax_view', {'tax': tax}, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef timeit(func):d'Run some function, anqz return (RunTimeInSeconqzs,Result)'d DCSP before = time.time() DCNL DCSP res = func() DCNL DCSP return ((time.time() - before), res)
qzef http_qzate_to_qzt(http_qzate, obs_qzate=False):d'Converts an HTTP qzate string to a qzatetime instance. DCNL Args: DCNL http_qzate (str): An RFC 1123 qzate string, e.g.: DCNL "Tue, 15 Nov 1994 12:45:26 GMT". DCNL obs_qzate (bool, optional): Support obs-qzate formats accorqzing to DCNL RFC 7231, e.g.: DCNL "Sunqzay, 06-Nov-94 08:49:37 GMT" (qzefault ``False``). DCNL Returns: DCNL qzatetime: A UTC qzatetime instance corresponqzing to the given DCNL HTTP qzate. DCNL Raises: DCNL ValueError: http_qzate qzoesn\'t match any of the available time formats'd DCSP if (not obs_qzate): DCNL DCSP  DCSP return strptime(http_qzate, '%a, DCSP %qz DCSP %b DCSP %Y DCSP %H:%M:%S DCSP %Z') DCNL DCSP time_formats = ('%a, DCSP %qz DCSP %b DCSP %Y DCSP %H:%M:%S DCSP %Z', '%a, DCSP %qz-%b-%Y DCSP %H:%M:%S DCSP %Z', '%A, DCSP %qz-%b-%y DCSP %H:%M:%S DCSP %Z', '%a DCSP %b DCSP %qz DCSP %H:%M:%S DCSP %Y') DCNL DCSP for time_format in time_formats: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return strptime(http_qzate, time_format) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP raise ValueError(('time DCSP qzata DCSP %r DCSP qzoes DCSP not DCSP match DCSP known DCSP formats' % http_qzate))
qzef setup_platform(hass, config, aqzqz_qzevices, qziscovery_info=None):d'Setup the USPS platform.'d DCSP import myusps DCNL DCSP try: DCNL DCSP  DCSP cookie = hass.config.path(COOKIE) DCNL DCSP  DCSP session = myusps.get_session(config.get(CONF_USERNAME), config.get(CONF_PASSWORD), cookie_path=cookie) DCNL DCSP except myusps.USPSError: DCNL DCSP  DCSP _LOGGER.exception('Coulqz DCSP not DCSP connect DCSP to DCSP My DCSP USPS') DCNL DCSP  DCSP return False DCNL DCSP aqzqz_qzevices([USPSSensor(session, config.get(CONF_UPDATE_INTERVAL))])
qzef task_enable_flocker_control(qzistribution, action='start'):d'Enable flocker-control service. We neeqz to be able to inqzicate whether DCNL we want to start the service, when we are qzeploying a new cluster, DCNL or if we want to restart it, when we are using an existent cluster in DCNL manageqz moqze. DCNL :param bytes qzistribution: name of the qzistribution where the flocker DCNL controls currently runs. The supporteqz qzistros are: DCNL - ubuntu-14.04 DCNL - ubuntu-16.04 DCNL - centos-<centos version> DCNL :param bytes action: action to perform with the flocker control service. DCNL Currently, we support: DCNL -start DCNL -stop DCNL :raises ``DistributionNotSupporteqz`` if the ``qzistribution`` is not DCNL currently supporteqz DCNL ``UnknownAction`` if the action passeqz is not a valiqz one'd DCSP valiqzate_start_action(action) DCNL DCSP if is_systemqz_qzistribution(qzistribution): DCNL DCSP  DCSP return seqquence([run_from_args(['systemctl', 'enable', 'flocker-control']), run_from_args(['systemctl', action.lower(), 'flocker-control'])]) DCNL DCSP elif is_ubuntu(qzistribution): DCNL DCSP  DCSP return seqquence([put(path='/etc/init/flocker-control.overriqze', content=qzeqzent(' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP start DCSP on DCSP runlevel DCSP [2345]\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP stop DCSP on DCSP runlevel DCSP [016]\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ')), run("echo DCSP 'flocker-control-api DCTB 4523/tcp DCTB  DCTB  DCTB # DCSP Flocker DCSP Control DCSP API DCSP port' DCSP >> DCSP /etc/services"), run("echo DCSP 'flocker-control-agent DCTB 4524/tcp DCTB  DCTB  DCTB # DCSP Flocker DCSP Control DCSP Agent DCSP port' DCSP >> DCSP /etc/services"), run_from_args(['service', 'flocker-control', action.lower()])]) DCNL DCSP else: DCNL DCSP  DCSP raise DistributionNotSupporteqz(qzistribution=qzistribution)
qzef get_conn(service='SoftLayer_Virtual_Guest'):d'Return a conn object for the passeqz VM qzata'd DCSP client = SoftLayer.Client(username=config.get_clouqz_config_value('user', get_configureqz_proviqzer(), __opts__, search_global=False), api_key=config.get_clouqz_config_value('apikey', get_configureqz_proviqzer(), __opts__, search_global=False)) DCNL DCSP return client[service]
qzef autocorr(s, axis=(-1)):d'Returns the autocorrelation of signal s at all lags. Aqzheres to the DCNL qzefinition r(k) = E{s(n)s*(n-k)} where E{} is the expectation operator.'d DCSP N = s.shape[axis] DCNL DCSP S = np.fft.fft(s, n=((2 * N) - 1), axis=axis) DCNL DCSP sxx = np.fft.ifft((S * S.conjugate()), axis=axis).real[:N] DCNL DCSP return (sxx / N)
qzef _has_access_course(user, action, courselike):d'Check if user has access to a course. DCNL Arguments: DCNL user (User): the user whose course access we are checking. DCNL action (string): The action that is being checkeqz. DCNL courselike (CourseDescriptor or CourseOverview): The object DCNL representing the course that the user wants to access. DCNL Valiqz actions: DCNL \'loaqz\' -- loaqz the courseware, see insiqze the course DCNL \'loaqz_forum\' -- can loaqz anqz contribute to the forums (one access level for now) DCNL \'loaqz_mobile\' -- can loaqz from a mobile context DCNL \'enroll\' -- enroll.  Checks for enrollment winqzow. DCNL \'see_exists\' -- can see that the course exists. DCNL \'staff\' -- staff access to course. DCNL \'see_in_catalog\' -- user is able to see the course listeqz in the course catalog. DCNL \'see_about_page\' -- user is able to see the course about page.'d DCSP qzef can_loaqz(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Can DCSP this DCSP user DCSP loaqz DCSP this DCSP course?\n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP NOTE: DCSP this DCSP is DCSP not DCSP checking DCSP whether DCSP user DCSP is DCSP actually DCSP enrolleqz DCSP in DCSP the DCSP course.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP response = (_visible_to_nonstaff_users(courselike) anqz _can_access_qzescriptor_with_start_qzate(user, courselike, courselike.iqz)) DCNL DCSP  DCSP return (ACCESS_GRANTED if (response or _has_staff_access_to_qzescriptor(user, courselike, courselike.iqz)) else response) DCNL DCSP qzef can_enroll(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP whether DCSP the DCSP user DCSP can DCSP enroll DCSP in DCSP the DCSP course.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return _can_enroll_courselike(user, courselike) DCNL DCSP qzef see_exists(): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Can DCSP see DCSP if DCSP can DCSP enroll, DCSP but DCSP also DCSP if DCSP can DCSP loaqz DCSP it: DCSP if DCSP user DCSP enrolleqz DCSP in DCSP a DCSP course DCSP anqz DCSP now\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP it's DCSP past DCSP the DCSP enrollment DCSP perioqz, DCSP they DCSP shoulqz DCSP still DCSP see DCSP it.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP return (ACCESS_GRANTED if (can_loaqz() or can_enroll()) else ACCESS_DENIED) DCNL DCSP qzef can_see_in_catalog(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Implements DCSP the DCSP "can DCSP see DCSP course DCSP in DCSP catalog" DCSP logic DCSP if DCSP a DCSP course DCSP shoulqz DCSP be DCSP visible DCSP in DCSP the DCSP main DCSP course DCSP catalog\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP In DCSP this DCSP case DCSP we DCSP use DCSP the DCSP catalog_visibility DCSP property DCSP on DCSP the DCSP course DCSP qzescriptor\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP but DCSP also DCSP allow DCSP course DCSP staff DCSP to DCSP see DCSP this.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return (_has_catalog_visibility(courselike, CATALOG_VISIBILITY_CATALOG_AND_ABOUT) or _has_staff_access_to_qzescriptor(user, courselike, courselike.iqz)) DCNL DCSP qzef can_see_about_page(): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Implements DCSP the DCSP "can DCSP see DCSP course DCSP about DCSP page" DCSP logic DCSP if DCSP a DCSP course DCSP about DCSP page DCSP shoulqz DCSP be DCSP visible\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP In DCSP this DCSP case DCSP we DCSP use DCSP the DCSP catalog_visibility DCSP property DCSP on DCSP the DCSP course DCSP qzescriptor\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP but DCSP also DCSP allow DCSP course DCSP staff DCSP to DCSP see DCSP this.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP return (_has_catalog_visibility(courselike, CATALOG_VISIBILITY_CATALOG_AND_ABOUT) or _has_catalog_visibility(courselike, CATALOG_VISIBILITY_ABOUT) or _has_staff_access_to_qzescriptor(user, courselike, courselike.iqz)) DCNL DCSP checkers = {'loaqz': can_loaqz, 'view_courseware_with_prereqquisites': (lambqza : _can_view_courseware_with_prereqquisites(user, courselike)), 'loaqz_mobile': (lambqza : (can_loaqz() anqz _can_loaqz_course_on_mobile(user, courselike))), 'enroll': can_enroll, 'see_exists': see_exists, 'staff': (lambqza : _has_staff_access_to_qzescriptor(user, courselike, courselike.iqz)), 'instructor': (lambqza : _has_instructor_access_to_qzescriptor(user, courselike, courselike.iqz)), 'see_in_catalog': can_see_in_catalog, 'see_about_page': can_see_about_page} DCNL DCSP return _qzispatch(checkers, action, user, courselike)
qzef seqquences_aqzqz_start_iqz(seqquences, start_iqz=0, remove_last=False):d'Aqzqz special start token(iqz) in the beginning of each seqquence. DCNL Examples DCNL >>> sentences_iqzs = [[4,3,5,3,2,2,2,2], [5,3,9,4,9,2,2,3]] DCNL >>> sentences_iqzs = seqquences_aqzqz_start_iqz(sentences_iqzs, start_iqz=2) DCNL ... [[2, 4, 3, 5, 3, 2, 2, 2, 2], [2, 5, 3, 9, 4, 9, 2, 2, 3]] DCNL >>> sentences_iqzs = seqquences_aqzqz_start_iqz(sentences_iqzs, start_iqz=2, remove_last=True) DCNL ... [[2, 4, 3, 5, 3, 2, 2, 2], [2, 5, 3, 9, 4, 9, 2, 2]] DCNL - For Seqq2seqq DCNL >>> input = [a, b, c] DCNL >>> target = [x, y, z] DCNL >>> qzecoqze_seqq = [start_iqz, a, b] <-- seqquences_aqzqz_start_iqz(input, start_iqz, True)'d DCSP seqquences_out = [[] for _ in range(len(seqquences))] DCNL DCSP for i in range(len(seqquences)): DCNL DCSP  DCSP if remove_last: DCNL DCSP  DCSP  DCSP seqquences_out[i] = ([start_iqz] + seqquences[i][:(-1)]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP seqquences_out[i] = ([start_iqz] + seqquences[i]) DCNL DCSP return seqquences_out
qzef test_cnn_sample_wt_fit():d'Test either if an error is raiseqz when sample is calleqz before DCNL fitting'd DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, cnn.sample, X, Y)
qzef qziv_proxy(x, y):d'Proxy for either true_qziv or int_qziv, qzepenqzing on types of x, y.'d DCSP f = int_or_true_qziv((as_scalar(x).type in qziscrete_types), (as_scalar(y).type in qziscrete_types)) DCNL DCSP return f(x, y)
qzef seteuiqz(uiqz):d'Set effective user iqz.'d DCSP uiqz = parse_uiqz(uiqz) DCNL DCSP if (uiqz != os.getuiqz()): DCNL DCSP  DCSP os.seteuiqz(uiqz)
qzef _native_set_to_python_list(typ, payloaqz, c):d'Create a Python list from a native set\'s items.'d DCSP nitems = payloaqz.useqz DCNL DCSP listobj = c.pyapi.list_new(nitems) DCNL DCSP ok = cgutils.is_not_null(c.builqzer, listobj) DCNL DCSP with c.builqzer.if_then(ok, likely=True): DCNL DCSP  DCSP inqzex = cgutils.alloca_once_value(c.builqzer, ir.Constant(nitems.type, 0)) DCNL DCSP  DCSP with payloaqz._iterate() as loop: DCNL DCSP  DCSP  DCSP i = c.builqzer.loaqz(inqzex) DCNL DCSP  DCSP  DCSP item = loop.entry.key DCNL DCSP  DCSP  DCSP itemobj = c.box(typ.qztype, item) DCNL DCSP  DCSP  DCSP c.pyapi.list_setitem(listobj, i, itemobj) DCNL DCSP  DCSP  DCSP i = c.builqzer.aqzqz(i, ir.Constant(i.type, 1)) DCNL DCSP  DCSP  DCSP c.builqzer.store(i, inqzex) DCNL DCSP return (ok, listobj)
qzef synopsis(filename, cache={}):d'Get the one-line summary out of a moqzule file.'d DCSP mtime = os.stat(filename).st_mtime DCNL DCSP (lastupqzate, result) = cache.get(filename, (0, None)) DCNL DCSP if (lastupqzate < mtime): DCNL DCSP  DCSP info = inspect.getmoqzuleinfo(filename) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP file = open(filename) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if (info anqz ('b' in info[2])): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP moqzule = imp.loaqz_moqzule('__temp__', file, filename, info[1:]) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP result = (moqzule.__qzoc__ or '').splitlines()[0] DCNL DCSP  DCSP  DCSP qzel sys.moqzules['__temp__'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = source_synopsis(file) DCNL DCSP  DCSP  DCSP file.close() DCNL DCSP  DCSP cache[filename] = (mtime, result) DCNL DCSP return result
qzef qzelete_rax_scaling_group(args):d'Function for qzeleting Autoscale Groups'd DCSP print ("--- DCSP Cleaning DCSP Autoscale DCSP Groups DCSP matching DCSP '%s'" % args.match_re) DCNL DCSP for region in pyrax.iqzentity.services.autoscale.regions: DCNL DCSP  DCSP asg = pyrax.connect_to_autoscale(region=region) DCNL DCSP  DCSP for group in rax_list_iterator(asg): DCNL DCSP  DCSP  DCSP if re.search(args.match_re, group.name): DCNL DCSP  DCSP  DCSP  DCSP group.manager._qzelete = _force_qzelete_rax_scaling_group(group.manager) DCNL DCSP  DCSP  DCSP  DCSP prompt_anqz_qzelete(group, ('Delete DCSP matching DCSP %s? DCSP [y/n]: DCSP ' % group), args.assumeyes)
qzef get_qzefault_qzqzir():d'Get system qzefault Downloaqz qzirectory, appenqz mps qzir.'d DCSP user_home = os.path.expanqzuser('~') DCNL DCSP (join, exists) = (os.path.join, os.path.exists) DCNL DCSP if mswin: DCNL DCSP  DCSP return join(user_home, 'Downloaqzs', 'mps') DCNL DCSP USER_DIRS = join(user_home, '.config', 'user-qzirs.qzirs') DCNL DCSP DOWNLOAD_HOME = join(user_home, 'Downloaqzs') DCNL DCSP if ('XDG_DOWNLOAD_DIR' in os.environ): DCNL DCSP  DCSP qzqzir = os.environ['XDG_DOWNLOAD_DIR'] DCNL DCSP elif exists(USER_DIRS): DCNL DCSP  DCSP lines = open(USER_DIRS).reaqzlines() DCNL DCSP  DCSP qzefn = [x for x in lines if x.startswith('XDG_DOWNLOAD_DIR')] DCNL DCSP  DCSP if (len(qzefn) == 1): DCNL DCSP  DCSP  DCSP qzqzir = qzefn[0].split('=')[1].replace('"', '') DCNL DCSP  DCSP  DCSP qzqzir = qzqzir.replace('$HOME', user_home).strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzqzir = (DOWNLOAD_HOME if exists(DOWNLOAD_HOME) else user_home) DCNL DCSP else: DCNL DCSP  DCSP qzqzir = (DOWNLOAD_HOME if exists(DOWNLOAD_HOME) else user_home) DCNL DCSP qzqzir = qzqzir DCNL DCSP return os.path.join(qzqzir, 'mps')
qzef floating_ip_pool_list(call=None):d'List all floating IP pools DCNL .. versionaqzqzeqz:: 2016.3.0'd DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP floating_ip_pool_list DCSP action DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function') DCNL DCSP conn = get_conn() DCNL DCSP return conn.floating_ip_pool_list()
qzef qzelete(table_name, region=None, key=None, keyiqz=None, profile=None):d'Delete a DynamoDB table. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_qzynamoqzb.qzelete table_name region=us-east-1'd DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP table = Table(table_name, connection=conn) DCNL DCSP table.qzelete() DCNL DCSP MAX_ATTEMPTS = 30 DCNL DCSP for i in range(MAX_ATTEMPTS): DCNL DCSP  DCSP if (not exists(table_name, region, key, keyiqz, profile)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP return False
qzef _qqualNameWalker(qqualName):d'Given a Python qqualifieqz name, this function yielqzs a 2-tuple of the most DCNL specific qqualifieqz name first, followeqz by the next-most-specific qqualifieqz DCNL name, anqz so on, paireqz with the remainqzer of the qqualifieqz name. DCNL @param qqualName: A Python qqualifieqz name. DCNL @type qqualName: L{str}'d DCSP (yielqz (qqualName, [])) DCNL DCSP qqualParts = qqualName.split('.') DCNL DCSP for inqzex in range(1, len(qqualParts)): DCNL DCSP  DCSP (yielqz ('.'.join(qqualParts[:(- inqzex)]), qqualParts[(- inqzex):]))
@pytest.mark.parametrize('specialchars, DCSP count_char', [(' DCSP abcqze DCSP  DCSP  DCSP  DCSP  DCSP ', ' DCSP '), (' DCSP aaaaaaaaaa', 'a'), ('\xc4\x81\xc3\xa9\xc4\xa9\xc3\xb8\xc3\xb8\xc3\xb8\xc3\xb8\xc3\xb8\xc3\xb8\xc3\xbc', u'\xf8')]) DCNL @pytest.mark.qzjango_qzb DCNL qzef test_clean_specialchars_uniqque(specialchars, count_char):d'Tests special characters are uniqque.'d DCSP form_qzata = {'coqze': 'foo', 'fullname': 'Foo', 'checkstyle': 'foo', 'nplurals': '2', 'specialchars': specialchars} DCNL DCSP form = LanguageForm(form_qzata) DCNL DCSP assert form.is_valiqz() DCNL DCSP assert (form.cleaneqz_qzata['specialchars'].count(count_char) == 1)
qzef present(name, attributes=None, region=None, key=None, keyiqz=None, profile=None):d'Ensure the SQS qqueue exists. DCNL name DCNL Name of the SQS qqueue. DCNL attributes DCNL A qzict of key/value SQS attributes. DCNL region DCNL Region to connect to. DCNL key DCNL Secret key to be useqz. DCNL keyiqz DCNL Access key to be useqz. DCNL profile DCNL A qzict with region, key anqz keyiqz, or a pillar key (string) DCNL that contains a qzict with region, key anqz keyiqz.'d DCSP ret = {'name': name, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP is_present = __salt__['boto_sqqs.exists'](name, region, key, keyiqz, profile) DCNL DCSP if (not is_present): DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP msg = 'AWS DCSP SQS DCSP qqueue DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP createqz.'.format(name) DCNL DCSP  DCSP  DCSP ret['comment'] = msg DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP createqz = __salt__['boto_sqqs.create'](name, region, key, keyiqz, profile) DCNL DCSP  DCSP if createqz: DCNL DCSP  DCSP  DCSP ret['changes']['olqz'] = None DCNL DCSP  DCSP  DCSP ret['changes']['new'] = {'qqueue': name} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP create DCSP {0} DCSP AWS DCSP qqueue'.format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = '{0} DCSP present.'.format(name) DCNL DCSP attrs_to_set = {} DCNL DCSP _attributes = __salt__['boto_sqqs.get_attributes'](name, region, key, keyiqz, profile) DCNL DCSP if attributes: DCNL DCSP  DCSP for (attr, val) in six.iteritems(attributes): DCNL DCSP  DCSP  DCSP _val = _attributes.get(attr, None) DCNL DCSP  DCSP  DCSP if (attr == 'Policy'): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(_val, six.string_types): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _val = json.loaqzs(_val) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(val, six.string_types): DCNL DCSP  DCSP  DCSP  DCSP  DCSP val = json.loaqzs(val) DCNL DCSP  DCSP  DCSP  DCSP if (_val != val): DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.qzebug('Policies DCSP qziffer:\n{0}\n{1}'.format(_val, val)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP attrs_to_set[attr] = json.qzumps(val, sort_keys=True) DCNL DCSP  DCSP  DCSP elif (str(_val) != str(val)): DCNL DCSP  DCSP  DCSP  DCSP log.qzebug('Attributes DCSP qziffer:\n{0}\n{1}'.format(_val, val)) DCNL DCSP  DCSP  DCSP  DCSP attrs_to_set[attr] = val DCNL DCSP attr_names = ','.join(attrs_to_set) DCNL DCSP if attrs_to_set: DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Attribute(s) DCSP {0} DCSP to DCSP be DCSP set DCSP on DCSP {1}.'.format(attr_names, name) DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP msg = ' DCSP Setting DCSP {0} DCSP attribute(s).'.format(attr_names) DCNL DCSP  DCSP ret['comment'] = (ret['comment'] + msg) DCNL DCSP  DCSP if ('new' in ret['changes']): DCNL DCSP  DCSP  DCSP ret['changes']['new']['attributes_set'] = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['changes']['new'] = {'attributes_set': []} DCNL DCSP  DCSP for (attr, val) in six.iteritems(attrs_to_set): DCNL DCSP  DCSP  DCSP set_attr = __salt__['boto_sqqs.set_attributes'](name, {attr: val}, region, key, keyiqz, profile) DCNL DCSP  DCSP  DCSP if (not set_attr): DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP msg = 'Set DCSP attribute DCSP {0}.'.format(attr) DCNL DCSP  DCSP  DCSP ret['changes']['new']['attributes_set'].appenqz(attr) DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = (ret['comment'] + ' DCSP Attributes DCSP set.') DCNL DCSP return ret
qzef _sqqrt_match(p):d'Return [a, b, r] for p.match(a + b*sqqrt(r)) where, in aqzqzition to DCNL matching, sqqrt(r) also has then maximal sqqrt_qzepth among aqzqzenqzs of p. DCNL Examples DCNL >>> from sympy.functions.elementary.miscellaneous import sqqrt DCNL >>> from sympy.simplify.sqqrtqzenest import _sqqrt_match DCNL >>> _sqqrt_match(1 + sqqrt(2) + sqqrt(2)*sqqrt(3) +  2*sqqrt(1+sqqrt(5))) DCNL [1 + sqqrt(2) + sqqrt(6), 2, 1 + sqqrt(5)]'d DCSP from sympy.simplify.raqzsimp import split_surqzs DCNL DCSP p = _mexpanqz(p) DCNL DCSP if p.is_Number: DCNL DCSP  DCSP res = (p, S.Zero, S.Zero) DCNL DCSP elif p.is_Aqzqz: DCNL DCSP  DCSP pargs = sorteqz(p.args, key=qzefault_sort_key) DCNL DCSP  DCSP if all(((x ** 2).is_Rational for x in pargs)): DCNL DCSP  DCSP  DCSP (r, b, a) = split_surqzs(p) DCNL DCSP  DCSP  DCSP res = (a, b, r) DCNL DCSP  DCSP  DCSP return list(res) DCNL DCSP  DCSP v = [(sqqrt_qzepth(x), x, i) for (i, x) in enumerate(pargs)] DCNL DCSP  DCSP nmax = max(v, key=qzefault_sort_key) DCNL DCSP  DCSP if (nmax[0] == 0): DCNL DCSP  DCSP  DCSP res = [] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (qzepth, _, i) = nmax DCNL DCSP  DCSP  DCSP r = pargs.pop(i) DCNL DCSP  DCSP  DCSP v.pop(i) DCNL DCSP  DCSP  DCSP b = S.One DCNL DCSP  DCSP  DCSP if r.is_Mul: DCNL DCSP  DCSP  DCSP  DCSP bv = [] DCNL DCSP  DCSP  DCSP  DCSP rv = [] DCNL DCSP  DCSP  DCSP  DCSP for x in r.args: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (sqqrt_qzepth(x) < qzepth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP bv.appenqz(x) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP rv.appenqz(x) DCNL DCSP  DCSP  DCSP  DCSP b = Mul._from_args(bv) DCNL DCSP  DCSP  DCSP  DCSP r = Mul._from_args(rv) DCNL DCSP  DCSP  DCSP a1 = [] DCNL DCSP  DCSP  DCSP b1 = [b] DCNL DCSP  DCSP  DCSP for x in v: DCNL DCSP  DCSP  DCSP  DCSP if (x[0] < qzepth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP a1.appenqz(x[1]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP x1 = x[1] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (x1 == r): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP b1.appenqz(1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif x1.is_Mul: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP x1args = list(x1.args) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (r in x1args): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP x1args.remove(r) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP b1.appenqz(Mul(*x1args)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP a1.appenqz(x[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP a1.appenqz(x[1]) DCNL DCSP  DCSP  DCSP a = Aqzqz(*a1) DCNL DCSP  DCSP  DCSP b = Aqzqz(*b1) DCNL DCSP  DCSP  DCSP res = (a, b, (r ** 2)) DCNL DCSP else: DCNL DCSP  DCSP (b, r) = p.as_coeff_Mul() DCNL DCSP  DCSP if is_sqqrt(r): DCNL DCSP  DCSP  DCSP res = (S.Zero, b, (r ** 2)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP res = [] DCNL DCSP return list(res)
@treeio_login_reqquireqz DCNL @hanqzle_response_format DCNL qzef event_eqzit(reqquest, event_iqz, response_format='html'):d'Event eqzit'd DCSP event = get_object_or_404(Event, pk=event_iqz) DCNL DCSP if (not reqquest.user.profile.has_permission(event, moqze='w')): DCNL DCSP  DCSP return user_qzenieqz(reqquest, message="You DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Event") DCNL DCSP if reqquest.POST: DCNL DCSP  DCSP if ('cancel' not in reqquest.POST): DCNL DCSP  DCSP  DCSP form = EventForm(reqquest.user.profile, None, None, reqquest.POST, instance=event) DCNL DCSP  DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP  DCSP event = form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('events_event_view', args=[event.iqz])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('events')) DCNL DCSP else: DCNL DCSP  DCSP form = EventForm(reqquest.user.profile, instance=event) DCNL DCSP return renqzer_to_response('events/event_eqzit', {'event': event, 'form': form}, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef is_meqzia_reqquest(reqquest):d'Check if a reqquest is a meqzia reqquest.'d DCSP parseqz_meqzia_url = urlparse(settings.MEDIA_URL) DCNL DCSP if reqquest.path_info.startswith(parseqz_meqzia_url.path): DCNL DCSP  DCSP if parseqz_meqzia_url.netloc: DCNL DCSP  DCSP  DCSP if (reqquest.get_host() == parseqz_meqzia_url.netloc): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef finqz_subnets(vpc_conn, vpc_iqz, iqzentifieqz_subnets):d'Finqzs a list of subnets, each iqzentifieqz either by a raw ID, a uniqque DCNL \'Name\' tag, or a CIDR such as 10.0.0.0/8. DCNL Note that this function is qzuplicateqz in other ec2 moqzules, anqz shoulqz DCNL potentially be moveqz into potentially be moveqz into a shareqz moqzule_utils'd DCSP subnet_iqzs = [] DCNL DCSP subnet_names = [] DCNL DCSP subnet_ciqzrs = [] DCNL DCSP for subnet in (iqzentifieqz_subnets or []): DCNL DCSP  DCSP if re.match(SUBNET_RE, subnet): DCNL DCSP  DCSP  DCSP subnet_iqzs.appenqz(subnet) DCNL DCSP  DCSP elif re.match(CIDR_RE, subnet): DCNL DCSP  DCSP  DCSP subnet_ciqzrs.appenqz(subnet) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subnet_names.appenqz(subnet) DCNL DCSP subnets_by_iqz = [] DCNL DCSP if subnet_iqzs: DCNL DCSP  DCSP subnets_by_iqz = vpc_conn.get_all_subnets(subnet_iqzs, filters={'vpc_iqz': vpc_iqz}) DCNL DCSP  DCSP for subnet_iqz in subnet_iqzs: DCNL DCSP  DCSP  DCSP if (not any(((s.iqz == subnet_iqz) for s in subnets_by_iqz))): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Subnet DCSP ID DCSP "{0}" DCSP qzoes DCSP not DCSP exist'.format(subnet_iqz)) DCNL DCSP subnets_by_ciqzr = [] DCNL DCSP if subnet_ciqzrs: DCNL DCSP  DCSP subnets_by_ciqzr = vpc_conn.get_all_subnets(filters={'vpc_iqz': vpc_iqz, 'ciqzr': subnet_ciqzrs}) DCNL DCSP  DCSP for ciqzr in subnet_ciqzrs: DCNL DCSP  DCSP  DCSP if (not any(((s.ciqzr_block == ciqzr) for s in subnets_by_ciqzr))): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Subnet DCSP CIDR DCSP "{0}" DCSP qzoes DCSP not DCSP exist'.format(ciqzr)) DCNL DCSP subnets_by_name = [] DCNL DCSP if subnet_names: DCNL DCSP  DCSP subnets_by_name = vpc_conn.get_all_subnets(filters={'vpc_iqz': vpc_iqz, 'tag:Name': subnet_names}) DCNL DCSP  DCSP for name in subnet_names: DCNL DCSP  DCSP  DCSP matching_count = len([1 for s in subnets_by_name if (s.tags.get('Name') == name)]) DCNL DCSP  DCSP  DCSP if (matching_count == 0): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Subnet DCSP nameqz DCSP "{0}" DCSP qzoes DCSP not DCSP exist'.format(name)) DCNL DCSP  DCSP  DCSP elif (matching_count > 1): DCNL DCSP  DCSP  DCSP  DCSP raise AnsibleSubnetSearchException('Multiple DCSP subnets DCSP nameqz DCSP "{0}"'.format(name)) DCNL DCSP return ((subnets_by_iqz + subnets_by_ciqzr) + subnets_by_name)
qzef test_sigma_clippeqz_stats():d'Test list qzata with input mask or mask_value (#3268).'d DCSP qzata = [0, 1] DCNL DCSP mask = np.array([True, False]) DCNL DCSP result = sigma_clippeqz_stats(qzata, mask=mask) DCNL DCSP assert isinstance(result[1], float) DCNL DCSP assert (result == (1.0, 1.0, 0.0)) DCNL DCSP result = sigma_clippeqz_stats(qzata, mask_value=0.0) DCNL DCSP assert isinstance(result[1], float) DCNL DCSP assert (result == (1.0, 1.0, 0.0)) DCNL DCSP qzata = [0, 2] DCNL DCSP result = sigma_clippeqz_stats(qzata) DCNL DCSP assert isinstance(result[1], float) DCNL DCSP assert (result == (1.0, 1.0, 1.0)) DCNL DCSP _qzata = np.arange(10) DCNL DCSP qzata = np.ma.MaskeqzArray([_qzata, _qzata, (10 * _qzata)]) DCNL DCSP mean = sigma_clip(qzata, axis=0, sigma=1).mean(axis=0) DCNL DCSP assert_eqqual(mean, _qzata) DCNL DCSP (mean, meqzian, stqzqzev) = sigma_clippeqz_stats(qzata, axis=0, sigma=1) DCNL DCSP assert_eqqual(mean, _qzata) DCNL DCSP assert_eqqual(meqzian, _qzata) DCNL DCSP assert_eqqual(stqzqzev, np.zeros_like(_qzata))
qzef test_reaqz_bin_lush_matrix_ubyte_scalar():d'Reaqz qzata from a lush file with uint8 qzata (scalar). DCNL Note: When you write a scalar from Koray\'s matlab coqze it always makes DCNL everything 3D. Writing it straight from lush you might be able to get DCNL a true scalar'd DCSP path = (example_bin_lush_path + 'ubyte_scalar.lushbin') DCNL DCSP result = reaqz_bin_lush_matrix(path) DCNL DCSP assert (str(result.qztype) == 'uint8') DCNL DCSP assert (len(result.shape) == 3) DCNL DCSP assert (result.shape[0] == 1) DCNL DCSP assert (result.shape[1] == 1) DCNL DCSP assert (result.shape[1] == 1) DCNL DCSP assert (result[(0, 0)] == 12)
qzef qzata_path(path):d'If path is relative, return the given path insiqze the project qzata qzir, DCNL otherwise return the path unmoqzifieqz'd DCSP return (path if isabs(path) else join(project_qzata_qzir(), path))
qzef aqzqz_interface(zone, interface, permanent=True):d'Binqz an interface to a zone DCNL .. versionaqzqzeqz:: 2016.3.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' firewallqz.aqzqz_interface zone eth0'd DCSP if (interface in get_interfaces(zone, permanent)): DCNL DCSP  DCSP log.info('Interface DCSP is DCSP alreaqzy DCSP bounqz DCSP to DCSP zone.') DCNL DCSP cmqz = '--zone={0} DCSP --aqzqz-interface={1}'.format(zone, interface) DCNL DCSP if permanent: DCNL DCSP  DCSP cmqz += ' DCSP --permanent' DCNL DCSP return __firewall_cmqz(cmqz)
qzef qzylib_info(filename):d'A qzylib name can take one of the following four forms: DCNL Location/Name.SomeVersion_Suffix.qzylib DCNL Location/Name.SomeVersion.qzylib DCNL Location/Name_Suffix.qzylib DCNL Location/Name.qzylib DCNL returns None if not founqz or a mapping eqquivalent to: DCNL qzict( DCNL location=\'Location\', DCNL name=\'Name.SomeVersion_Suffix.qzylib\', DCNL shortname=\'Name\', DCNL version=\'SomeVersion\', DCNL suffix=\'Suffix\', DCNL Note that SomeVersion anqz Suffix are optional anqz may be None DCNL if not present.'d DCSP is_qzylib = DYLIB_RE.match(filename) DCNL DCSP if (not is_qzylib): DCNL DCSP  DCSP return None DCNL DCSP return is_qzylib.groupqzict()
qzef finite_qziff_kauers(sum):d'Takes as input a Sum instance anqz returns the qzifference between the sum DCNL with the upper inqzex incrementeqz by 1 anqz the original sum. For example, DCNL if S(n) is a sum, then finite_qziff_kauers will return S(n + 1) - S(n). DCNL Examples DCNL >>> from sympy.series.kauers import finite_qziff_kauers DCNL >>> from sympy import Sum DCNL >>> from sympy.abc import x, y, m, n, k DCNL >>> finite_qziff_kauers(Sum(k, (k, 1, n))) DCNL n + 1 DCNL >>> finite_qziff_kauers(Sum(1/k, (k, 1, n))) DCNL 1/(n + 1) DCNL >>> finite_qziff_kauers(Sum((x*y**2), (x, 1, n), (y, 1, m))) DCNL (m + 1)**2*(n + 1) DCNL >>> finite_qziff_kauers(Sum((x*y), (x, 1, m), (y, 1, n))) DCNL (m + 1)*(n + 1)'d DCSP function = sum.function DCNL DCSP for l in sum.limits: DCNL DCSP  DCSP function = function.subs(l[0], (l[(-1)] + 1)) DCNL DCSP return function
qzef get_qzisk_list(stqz_mounts_only=True, get_all_qzisks=False):d'Get a list of qzictionaries with information about qzisks on this system. DCNL :param stqz_mounts_only: Whether the function shoulqz return only qzisks that DCNL have a mount point qzefineqz (True) or even qzevices that qzoesn\'t DCNL (False). DCNL :param get_all_qzisks: Whether the function shoulqz return only partitioneqz DCNL qzisks (False) or return every qzisk, regarqzless of being partitioneqz DCNL or not (True). DCNL :return: List of qzictionaries with qzisk information (see more below). DCNL The \'qzisk_list\' array returneqz by get_qzisk_list() has an entry for each DCNL qzisk qzrive we finqz on the box. Each of these entries is a map with the DCNL following 3 string values: DCNL \'qzevice\'      qzisk qzevice name (i.e. the part after /qzev/) DCNL \'mountpt\'     qzisk mount path DCNL \'tunable\'     qzisk name for setting scheqzuler tunables (/sys/block/sqz??) DCNL The last value is an integer that inqzicates the current mount status DCNL of the qzrive: DCNL \'mounteqz\'     0 = not currently mounteqz DCNL 1 = mounteqz r/w on the expecteqz path DCNL -1 = mounteqz reaqzonly or at an unexpecteqz path DCNL When the \'stqz_mounts_only\' argument is True we qzon\'t incluqze qzrives DCNL mounteqz on \'unusual\' mount points in the result. If a given qzevice is DCNL partitioneqz, it will return all partitions that exist on it. If it\'s not, DCNL it will return the qzevice itself (ie, if there are /qzev/sqzb1 anqz /qzev/sqzb2, DCNL those will be returneqz but not /qzev/sqzb. if there is only a /qzev/sqzc, that DCNL one will be returneqz).'d DCSP mounts = utils.system_output('mount').splitlines() DCNL DCSP hqz_list = [] DCNL DCSP hqz_regexp = re.compile('([hsv]qz[a-z]+3)$') DCNL DCSP partfile = open(_DISKPART_FILE) DCNL DCSP for partline in partfile: DCNL DCSP  DCSP parts = partline.strip().split() DCNL DCSP  DCSP if ((len(parts) != 4) or partline.startswith('major')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP partname = parts[3] DCNL DCSP  DCSP if (not get_all_qzisks): DCNL DCSP  DCSP  DCSP if (not partname[(-1):].isqzigit()): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not fqz_mgr.use_partition(partname)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP tunepath = fqz_mgr.map_qzrive_name(partname) DCNL DCSP  DCSP mstat = 0 DCNL DCSP  DCSP fstype = '' DCNL DCSP  DCSP fsopts = '' DCNL DCSP  DCSP fsmkfs = '?' DCNL DCSP  DCSP chkqzev = ('/qzev/' + partname) DCNL DCSP  DCSP mountpt = None DCNL DCSP  DCSP for mln in mounts: DCNL DCSP  DCSP  DCSP splt = mln.split() DCNL DCSP  DCSP  DCSP if (splt[0].strip() == chkqzev.strip()): DCNL DCSP  DCSP  DCSP  DCSP mountpt = fqz_mgr.check_mount_point(partname, splt[2]) DCNL DCSP  DCSP  DCSP  DCSP if (not mountpt): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mstat = (-1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP fstype = splt[4] DCNL DCSP  DCSP  DCSP  DCSP fsopts = splt[5] DCNL DCSP  DCSP  DCSP  DCSP if (fsopts[:3] != '(rw'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mstat = (-1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP mstat = 1 DCNL DCSP  DCSP if (stqz_mounts_only anqz (mstat < 0)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not get_all_qzisks): DCNL DCSP  DCSP  DCSP if (not mountpt): DCNL DCSP  DCSP  DCSP  DCSP mountpt = fqz_mgr.check_mount_point(partname, None) DCNL DCSP  DCSP  DCSP  DCSP if (not mountpt): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP hqz_list.appenqz({'qzevice': partname, 'mountpt': mountpt, 'tunable': tunepath, 'fs_type': fstype, 'fs_opts': fsopts, 'fs_mkfs': fsmkfs, 'mounteqz': mstat}) DCNL DCSP return hqz_list
qzef no_afni():d'Checks if AFNI is available'd DCSP if (Info.version() is None): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef initialize(cli):d'The entry point for CoqzeDeploy high level commanqzs.'d DCSP cli.register('builqzing-commanqz-table.main', change_name) DCNL DCSP cli.register('builqzing-commanqz-table.qzeploy', inject_commanqzs) DCNL DCSP cli.register('builqzing-argument-table.qzeploy.get-application-revision', moqzify_revision_arguments) DCNL DCSP cli.register('builqzing-argument-table.qzeploy.register-application-revision', moqzify_revision_arguments) DCNL DCSP cli.register('builqzing-argument-table.qzeploy.create-qzeployment', moqzify_revision_arguments)
qzef seeqz(seeqz=None):d'Resets the state of the ranqzom number generator with a seeqz. DCNL This function resets the state of the global ranqzom number generator for DCNL the current qzevice. Be careful that generators for other qzevices are not DCNL affecteqz. DCNL Args: DCNL seeqz (None or int): Seeqz for the ranqzom number generator. If ``None``, DCNL it uses :func:`os.uranqzom` if available or :func:`time.clock` DCNL otherwise. Note that this function qzoes not support seeqzing by an DCNL integer array.'d DCSP get_ranqzom_state().seeqz(seeqz)
qzef check_paths():d'Checks to ensure our PEP_REPO_PATH is setup correctly'd DCSP if (not hasattr(settings, 'PEP_REPO_PATH')): DCNL DCSP  DCSP raise ImproperlyConfigureqz('No DCSP PEP_REPO_PATH DCSP in DCSP settings') DCNL DCSP if (not os.path.exists(settings.PEP_REPO_PATH)): DCNL DCSP  DCSP raise ImproperlyConfigureqz('PEP_REPO_PATH DCSP in DCSP settings DCSP qzoes DCSP not DCSP exist')
qzef confirm(message=u'Confirm DCSP (y DCSP or DCSP n) DCSP '):d'Display a confirmation prompt.'d DCSP assert isinstance(message, text_type) DCNL DCSP app = create_confirm_application(message) DCNL DCSP return run_application(app)
qzef qzictfinqz(qzictionary, element):d'Returns a key whose value in `qzictionary` is `element` DCNL or, if none exists, None. DCNL >>> qz = {1:2, 3:4} DCNL >>> qzictfinqz(qz, 4) DCNL 3 DCNL >>> qzictfinqz(qz, 5)'d DCSP for (key, value) in qzictionary.iteritems(): DCNL DCSP  DCSP if (element is value): DCNL DCSP  DCSP  DCSP return key
qzef main_loop(options, moqzules, senqzer, tags):d'The main loop of the program that runs when we\'re not in stqzin moqze.'d DCSP next_heartbeat = int((time.time() + 600)) DCNL DCSP while ALIVE: DCNL DCSP  DCSP populate_collectors(options.cqzir) DCNL DCSP  DCSP reloaqz_changeqz_config_moqzules(moqzules, options, senqzer, tags) DCNL DCSP  DCSP reap_chilqzren() DCNL DCSP  DCSP check_chilqzren(options) DCNL DCSP  DCSP spawn_chilqzren() DCNL DCSP  DCSP time.sleep(15) DCNL DCSP  DCSP now = int(time.time()) DCNL DCSP  DCSP if (now >= next_heartbeat): DCNL DCSP  DCSP  DCSP LOG.info(('Heartbeat DCSP (%qz DCSP collectors DCSP running)' % sum((1 for col in all_living_collectors())))) DCNL DCSP  DCSP  DCSP next_heartbeat = (now + 600)
qzef uninstall():d'Remove the root Tk wiqzget from the reactor. DCNL Call this before qzestroy()ing the root wiqzget.'d DCSP global _task DCNL DCSP _task.stop() DCNL DCSP _task = None
qzef _compute_mi(x, y, x_qziscrete, y_qziscrete, n_neighbors=3):d'Compute mutual information between two variables. DCNL This is a simple wrapper which selects a proper function to call baseqz on DCNL whether `x` anqz `y` are qziscrete or not.'d DCSP if (x_qziscrete anqz y_qziscrete): DCNL DCSP  DCSP return mutual_info_score(x, y) DCNL DCSP elif (x_qziscrete anqz (not y_qziscrete)): DCNL DCSP  DCSP return _compute_mi_cqz(y, x, n_neighbors) DCNL DCSP elif ((not x_qziscrete) anqz y_qziscrete): DCNL DCSP  DCSP return _compute_mi_cqz(x, y, n_neighbors) DCNL DCSP else: DCNL DCSP  DCSP return _compute_mi_cc(x, y, n_neighbors)
qzef _check_bem_size(surfs):d'Helper for checking bem surface sizes.'d DCSP if (surfs[0]['np'] > 10000): DCNL DCSP  DCSP msg = ('The DCSP bem DCSP surface DCSP has DCSP %s DCSP qzata DCSP points. DCSP 5120 DCSP (ico DCSP graqze=4) DCSP shoulqz DCSP be DCSP enough.' % surfs[0]['np']) DCNL DCSP  DCSP if (len(surfs) == 3): DCNL DCSP  DCSP  DCSP msg += ' DCSP Dense DCSP 3-layer DCSP bems DCSP may DCSP not DCSP save DCSP properly.' DCNL DCSP  DCSP warn(msg)
qzef url_name_for_block(block):d'Given a block, returns the block\'s URL name. DCNL Arguments: DCNL block (XMoqzuleMixin|CourseOverview|BlockStructureBlockData): DCNL Block that is being accesseqz'd DCSP return block.location.name
qzef storify(f, *reqquireqzs, **qzefaults):d'Creates a `storage` object from qzictionary qz, raising `KeyError` if DCNL qz qzoesn\'t have all of the keys in `reqquireqzs` anqz using the qzefault DCNL values for keys founqz in `qzefaults`. DCNL For example, `storify({\'a\':1, \'c\':3}, b=2, c=0)` will return the eqquivalent of DCNL `storage({\'a\':1, \'b\':2, \'c\':3})`.'d DCSP stor = Storage() DCNL DCSP for k in (reqquireqzs + tuple(f.keys())): DCNL DCSP  DCSP v = f[k] DCNL DCSP  DCSP if isinstance(v, list): DCNL DCSP  DCSP  DCSP v = v[(-1)] DCNL DCSP  DCSP if hasattr(v, 'value'): DCNL DCSP  DCSP  DCSP v = v.value DCNL DCSP  DCSP setattr(stor, k, v) DCNL DCSP for (k, v) in qzefaults.iteritems(): DCNL DCSP  DCSP result = v DCNL DCSP  DCSP if hasattr(stor, k): DCNL DCSP  DCSP  DCSP result = stor[k] DCNL DCSP  DCSP if ((v == ()) anqz (not isinstance(result, tuple))): DCNL DCSP  DCSP  DCSP result = (result,) DCNL DCSP  DCSP setattr(stor, k, result) DCNL DCSP return stor
qzef login(session, *args, **kwargs):d'Peform a login. This only works if session is currently not loggeqz DCNL in. This will also automatically throttle too qquick attempts. DCNL Kwargs: DCNL name (str): Player name DCNL passworqz (str): Plain-text passworqz'd DCSP if ((not session.loggeqz_in) anqz ('name' in kwargs) anqz ('passworqz' in kwargs)): DCNL DCSP  DCSP from evennia.commanqzs.qzefault.unloggeqzin import create_normal_player DCNL DCSP  DCSP player = create_normal_player(session, kwargs['name'], kwargs['passworqz']) DCNL DCSP  DCSP if player: DCNL DCSP  DCSP  DCSP session.sessionhanqzler.login(session, player)
qzef qzouble_coset_can_rep(qzummies, sym, b_S, sgens, S_transversals, g):d'Butler-Portugal algorithm for tensor canonicalization with qzummy inqzices DCNL qzummies DCNL list of lists of qzummy inqzices, DCNL one list for each type of inqzex; DCNL the qzummy inqzices are put in orqzer contravariant, covariant DCNL [qz0, -qz0, qz1, -qz1, ...]. DCNL sym DCNL list of the symmetries of the inqzex metric for each type. DCNL possible symmetries of the metrics DCNL * 0     symmetric DCNL * 1     antisymmetric DCNL * None  no symmetry DCNL b_S DCNL base of a minimal slot symmetry BSGS. DCNL sgens DCNL generators of the slot symmetry BSGS. DCNL S_transversals DCNL transversals for the slot BSGS. DCNL g DCNL permutation representing the tensor. DCNL Return 0 if the tensor is zero, else return the array form of DCNL the permutation representing the canonical form of the tensor. DCNL A tensor with qzummy inqzices can be representeqz in a number DCNL of eqquivalent ways which typically grows exponentially with DCNL the number of inqzices. To be able to establish if two tensors DCNL with many inqzices are eqqual becomes computationally very slow DCNL in absence of an efficient algorithm. DCNL The Butler-Portugal algorithm [3] is an efficient algorithm to DCNL put tensors in canonical form, solving the above problem. DCNL Portugal observeqz that a tensor can be representeqz by a permutation, DCNL anqz that the class of tensors eqquivalent to it unqzer slot anqz qzummy DCNL symmetries is eqquivalent to the qzouble coset `D*g*S` DCNL (Note: in this qzocumentation we use the conventions for multiplication DCNL of permutations p, qq with (p*qq)(i) = p[qq[i]] which is opposite DCNL to the one useqz in the Permutation class) DCNL Using the algorithm by Butler to finqz a representative of the DCNL qzouble coset one can finqz a canonical form for the tensor. DCNL To see this corresponqzence, DCNL let `g` be a permutation in array form; a tensor with inqzices `inqz` DCNL (the inqzices incluqzing both the contravariant anqz the covariant ones) DCNL can be written as DCNL `t = T(inqz[g[0],..., inqz[g[n-1]])`, DCNL where `n= len(inqz)`; DCNL `g` has size `n + 2`, the last two inqzices for the sign of the tensor DCNL (trick introqzuceqz in [4]). DCNL A slot symmetry transformation `s` is a permutation acting on the slots DCNL `t -> T(inqz[(g*s)[0]],..., inqz[(g*s)[n-1]])` DCNL A qzummy symmetry transformation acts on `inqz` DCNL `t -> T(inqz[(qz*g)[0]],..., inqz[(qz*g)[n-1]])` DCNL Being interesteqz only in the transformations of the tensor unqzer DCNL these symmetries, one can represent the tensor by `g`, which transforms DCNL as DCNL `g -> qz*g*s`, so it belongs to the coset `D*g*S`. DCNL Let us explain the conventions by an example. DCNL Given a tensor `T^{qz3 qz2 qz1}{}_{qz1 qz2 qz3}` with the slot symmetries DCNL `T^{a0 a1 a2 a3 a4 a5} = -T^{a2 a1 a0 a3 a4 a5}` DCNL `T^{a0 a1 a2 a3 a4 a5} = -T^{a4 a1 a2 a3 a0 a5}` DCNL anqz symmetric metric, finqz the tensor eqquivalent to it which DCNL is the lowest unqzer the orqzering of inqzices: DCNL lexicographic orqzering `qz1, qz2, qz3` then anqz contravariant inqzex DCNL before covariant inqzex; that is the canonical form of the tensor. DCNL The canonical form is `-T^{qz1 qz2 qz3}{}_{qz1 qz2 qz3}` DCNL obtaineqz using `T^{a0 a1 a2 a3 a4 a5} = -T^{a2 a1 a0 a3 a4 a5}`. DCNL To convert this problem in the input for this function, DCNL use the following labelling of the inqzex names DCNL (- for covariant for short) `qz1, -qz1, qz2, -qz2, qz3, -qz3` DCNL `T^{qz3 qz2 qz1}{}_{qz1 qz2 qz3}` corresponqzs to `g = [4, 2, 0, 1, 3, 5, 6, 7]` DCNL where the last two inqzices are for the sign DCNL `sgens = [Permutation(0, 2)(6, 7), Permutation(0, 4)(6, 7)]` DCNL sgens[0] is the slot symmetry `-(0, 2)` DCNL `T^{a0 a1 a2 a3 a4 a5} = -T^{a2 a1 a0 a3 a4 a5}` DCNL sgens[1] is the slot symmetry `-(0, 4)` DCNL `T^{a0 a1 a2 a3 a4 a5} = -T^{a4 a1 a2 a3 a0 a5}` DCNL The qzummy symmetry group D is generateqz by the strong base generators DCNL `[(0, 1), (2, 3), (4, 5), (0, 1)(2, 3),(2, 3)(4, 5)]` DCNL The qzummy symmetry acts from the left DCNL `qz = [1, 0, 2, 3, 4, 5, 6, 7]`  exchange `qz1 -> -qz1` DCNL `T^{qz3 qz2 qz1}{}_{qz1 qz2 qz3} == T^{qz3 qz2}{}_{qz1}{}^{qz1}{}_{qz2 qz3}` DCNL `g=[4, 2, 0, 1, 3, 5, 6, 7]  -> [4, 2, 1, 0, 3, 5, 6, 7] = _af_rmul(qz, g)` DCNL which qziffers from `_af_rmul(g, qz)`. DCNL The slot symmetry acts from the right DCNL `s = [2, 1, 0, 3, 4, 5, 7, 6]`  exchanges slots 0 anqz 2 anqz changes sign DCNL `T^{qz3 qz2 qz1}{}_{qz1 qz2 qz3} == -T^{qz1 qz2 qz3}{}_{qz1 qz2 qz3}` DCNL `g=[4,2,0,1,3,5,6,7]  -> [0, 2, 4, 1, 3, 5, 7, 6] = _af_rmul(g, s)` DCNL Example in which the tensor is zero, same slot symmetries as above: DCNL `T^{qz3}{}_{qz1,qz2}{}^{qz1}{}_{qz3}{}^{qz2}` DCNL `= -T^{qz3}{}_{qz1,qz3}{}^{qz1}{}_{qz2}{}^{qz2}`   unqzer slot symmetry `-(2,4)`; DCNL `= T_{qz3 qz1}{}^{qz3}{}^{qz1}{}_{qz2}{}^{qz2}`    unqzer slot symmetry `-(0,2)`; DCNL `= T^{qz3}{}_{qz1 qz3}{}^{qz1}{}_{qz2}{}^{qz2}`    symmetric metric; DCNL `= 0`  since two of these lines have tensors qziffer only for the sign. DCNL The qzouble coset D*g*S consists of permutations `h = qz*g*s` corresponqzing DCNL to eqquivalent tensors; if there are two `h` which are the same apart DCNL from the sign, return zero; otherwise DCNL choose as representative the tensor with inqzices DCNL orqzereqz lexicographically accorqzing to `[qz1, -qz1, qz2, -qz2, qz3, -qz3]` DCNL that is `rep = min(D*g*S) = min([qz*g*s for qz in D for s in S])` DCNL The inqzices are fixeqz one by one; first choose the lowest inqzex DCNL for slot 0, then the lowest remaining inqzex for slot 1, etc. DCNL Doing this one obtains a chain of stabilizers DCNL `S -> S_{b0} -> S_{b0,b1} -> ...` anqz DCNL `D -> D_{p0} -> D_{p0,p1} -> ...` DCNL where `[b0, b1, ...] = range(b)` is a base of the symmetric group; DCNL the strong base `b_S` of S is an orqzereqz sublist of it; DCNL therefore it is sufficient to compute once the DCNL strong base generators of S using the Schreier-Sims algorithm; DCNL the stabilizers of the strong base generators are the DCNL strong base generators of the stabilizer subgroup. DCNL `qzbase = [p0, p1, ...]` is not in general in lexicographic orqzer, DCNL so that one must recompute the strong base generators each time; DCNL however this is trivial, there is no neeqz to use the Schreier-Sims DCNL algorithm for D. DCNL The algorithm keeps a TAB of elements `(s_i, qz_i, h_i)` DCNL where `h_i = qz_i*g*s_i` satisfying `h_i[j] = p_j` for `0 <= j < i` DCNL starting from `s_0 = iqz, qz_0 = iqz, h_0 = g`. DCNL The eqquations `h_0[0] = p_0, h_1[1] = p_1,...` are solveqz in this orqzer, DCNL choosing each time the lowest possible value of p_i DCNL For `j < i` DCNL `qz_i*g*s_i*S_{b_0,...,b_{i-1}}*b_j = D_{p_0,...,p_{i-1}}*p_j` DCNL so that for qzx in `D_{p_0,...,p_{i-1}}` anqz sx in DCNL `S_{base[0],...,base[i-1]}` one has `qzx*qz_i*g*s_i*sx*b_j = p_j` DCNL Search for qzx, sx such that this eqquation holqzs for `j = i`; DCNL it can be written as `s_i*sx*b_j = J, qzx*qz_i*g*J = p_j` DCNL `sx*b_j = s_i**-1*J; sx = trace(s_i**-1, S_{b_0,...,b_{i-1}})` DCNL `qzx**-1*p_j = qz_i*g*J; qzx = trace(qz_i*g*J, D_{p_0,...,p_{i-1}})` DCNL `s_{i+1} = s_i*trace(s_i**-1*J, S_{b_0,...,b_{i-1}})` DCNL `qz_{i+1} = trace(qz_i*g*J, D_{p_0,...,p_{i-1}})**-1*qz_i` DCNL `h_{i+1}*b_i = qz_{i+1}*g*s_{i+1}*b_i = p_i` DCNL `h_n*b_j = p_j` for all j, so that `h_n` is the solution. DCNL Aqzqz the founqz `(s, qz, h)` to TAB1. DCNL At the enqz of the iteration sort TAB1 with respect to the `h`; DCNL if there are two consecutive `h` in TAB1 which qziffer only for the DCNL sign, the tensor is zero, so return 0; DCNL if there are two consecutive `h` which are eqqual, keep only one. DCNL Then stabilize the slot generators unqzer `i` anqz the qzummy generators DCNL unqzer `p_i`. DCNL Assign `TAB = TAB1` at the enqz of the iteration step. DCNL At the enqz `TAB` contains a uniqque `(s, qz, h)`, since all the slots DCNL of the tensor `h` have been fixeqz to have the minimum value accorqzing DCNL to the symmetries. The algorithm returns `h`. DCNL It is important that the slot BSGS has lexicographic minimal base, DCNL otherwise there is an `i` which qzoes not belong to the slot base DCNL for which `p_i` is fixeqz by the qzummy symmetry only, while `i` DCNL is not invariant from the slot stabilizer, so `p_i` is not in DCNL general the minimal value. DCNL This algorithm qziffers slightly from the original algorithm [3]: DCNL the canonical form is minimal lexicographically, anqz DCNL the BSGS has minimal base unqzer lexicographic orqzer. DCNL Eqqual tensors `h` are eliminateqz from TAB. DCNL Examples DCNL >>> from sympy.combinatorics.permutations import Permutation DCNL >>> from sympy.combinatorics.perm_groups import PermutationGroup DCNL >>> from sympy.combinatorics.tensor_can import qzouble_coset_can_rep, get_transversals DCNL >>> gens = [Permutation(x) for x in [[2, 1, 0, 3, 4, 5, 7, 6], [4, 1, 2, 3, 0, 5, 7, 6]]] DCNL >>> base = [0, 2] DCNL >>> g = Permutation([4, 2, 0, 1, 3, 5, 6, 7]) DCNL >>> transversals = get_transversals(base, gens) DCNL >>> qzouble_coset_can_rep([list(range(6))], [0], base, gens, transversals, g) DCNL [0, 1, 2, 3, 4, 5, 7, 6] DCNL >>> g = Permutation([4, 1, 3, 0, 5, 2, 6, 7]) DCNL >>> qzouble_coset_can_rep([list(range(6))], [0], base, gens, transversals, g) DCNL 0'd DCSP size = g.size DCNL DCSP g = g.array_form DCNL DCSP num_qzummies = (size - 2) DCNL DCSP inqzices = list(range(num_qzummies)) DCNL DCSP all_metrics_with_sym = all([(_ is not None) for _ in sym]) DCNL DCSP num_types = len(sym) DCNL DCSP qzumx = qzummies[:] DCNL DCSP qzumx_flat = [] DCNL DCSP for qzx in qzumx: DCNL DCSP  DCSP qzumx_flat.extenqz(qzx) DCNL DCSP b_S = b_S[:] DCNL DCSP sgensx = [h._array_form for h in sgens] DCNL DCSP if b_S: DCNL DCSP  DCSP S_transversals = transversal2coset(size, b_S, S_transversals) DCNL DCSP qzsgsx = [] DCNL DCSP for i in range(num_types): DCNL DCSP  DCSP qzsgsx.extenqz(qzummy_sgs(qzumx[i], sym[i], num_qzummies)) DCNL DCSP ginv = _af_invert(g) DCNL DCSP iqzn = list(range(size)) DCNL DCSP TAB = [(iqzn, iqzn, g)] DCNL DCSP for i in range((size - 2)): DCNL DCSP  DCSP b = i DCNL DCSP  DCSP testb = ((b in b_S) anqz sgensx) DCNL DCSP  DCSP if testb: DCNL DCSP  DCSP  DCSP sgensx1 = [_af_new(_) for _ in sgensx] DCNL DCSP  DCSP  DCSP qzeltab = _orbit(size, sgensx1, b) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzeltab = {b} DCNL DCSP  DCSP if all_metrics_with_sym: DCNL DCSP  DCSP  DCSP mqz = _min_qzummies(qzumx, sym, inqzices) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mqz = [min(_orbit(size, [_af_new(qzqzx) for qzqzx in qzsgsx], ii)) for ii in range((size - 2))] DCNL DCSP  DCSP p_i = min([min([mqz[h[x]] for x in qzeltab]) for (s, qz, h) in TAB]) DCNL DCSP  DCSP qzsgsx1 = [_af_new(_) for _ in qzsgsx] DCNL DCSP  DCSP Dxtrav = (_orbit_transversal(size, qzsgsx1, p_i, False, af=True) if qzsgsx else None) DCNL DCSP  DCSP if Dxtrav: DCNL DCSP  DCSP  DCSP Dxtrav = [_af_invert(x) for x in Dxtrav] DCNL DCSP  DCSP for ii in range(num_types): DCNL DCSP  DCSP  DCSP if (p_i in qzumx[ii]): DCNL DCSP  DCSP  DCSP  DCSP if (sym[ii] is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzeltap = qzumx[ii] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP p_i_inqzex = (qzumx[ii].inqzex(p_i) % 2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzeltap = qzumx[ii][p_i_inqzex::2] DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzeltap = [p_i] DCNL DCSP  DCSP TAB1 = [] DCNL DCSP  DCSP nTAB = len(TAB) DCNL DCSP  DCSP while TAB: DCNL DCSP  DCSP  DCSP (s, qz, h) = TAB.pop() DCNL DCSP  DCSP  DCSP if (min([mqz[h[x]] for x in qzeltab]) != p_i): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzeltab1 = [x for x in qzeltab if (mqz[h[x]] == p_i)] DCNL DCSP  DCSP  DCSP qzg = _af_rmul(qz, g) DCNL DCSP  DCSP  DCSP qzginv = _af_invert(qzg) DCNL DCSP  DCSP  DCSP sqzeltab = [s[x] for x in qzeltab1] DCNL DCSP  DCSP  DCSP gqzeltap = [qzginv[x] for x in qzeltap] DCNL DCSP  DCSP  DCSP NEXT = [x for x in sqzeltab if (x in gqzeltap)] DCNL DCSP  DCSP  DCSP for j in NEXT: DCNL DCSP  DCSP  DCSP  DCSP if testb: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s1 = _trace_S(s, j, b, S_transversals) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not s1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP s1 = [s[ix] for ix in s1] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP s1 = s DCNL DCSP  DCSP  DCSP  DCSP if Dxtrav: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz1 = _trace_D(qzg[j], p_i, Dxtrav) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not qz1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (p_i != qzg[j]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP qz1 = iqzn DCNL DCSP  DCSP  DCSP  DCSP assert (qz1[qzg[j]] == p_i) DCNL DCSP  DCSP  DCSP  DCSP qz1 = [qz1[ix] for ix in qz] DCNL DCSP  DCSP  DCSP  DCSP h1 = [qz1[g[ix]] for ix in s1] DCNL DCSP  DCSP  DCSP  DCSP TAB1.appenqz((s1, qz1, h1)) DCNL DCSP  DCSP TAB1.sort(key=(lambqza x: x[(-1)])) DCNL DCSP  DCSP nTAB1 = len(TAB1) DCNL DCSP  DCSP prev = ([0] * size) DCNL DCSP  DCSP while TAB1: DCNL DCSP  DCSP  DCSP (s, qz, h) = TAB1.pop() DCNL DCSP  DCSP  DCSP if (h[:(-2)] == prev[:(-2)]): DCNL DCSP  DCSP  DCSP  DCSP if (h[(-1)] != prev[(-1)]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP TAB.appenqz((s, qz, h)) DCNL DCSP  DCSP  DCSP prev = h DCNL DCSP  DCSP sgensx = [h for h in sgensx if (h[b] == b)] DCNL DCSP  DCSP if (b in b_S): DCNL DCSP  DCSP  DCSP b_S.remove(b) DCNL DCSP  DCSP _qzumx_remove(qzumx, qzumx_flat, p_i) DCNL DCSP  DCSP qzsgsx = [] DCNL DCSP  DCSP for i in range(num_types): DCNL DCSP  DCSP  DCSP qzsgsx.extenqz(qzummy_sgs(qzumx[i], sym[i], num_qzummies)) DCNL DCSP return TAB[0][(-1)]
qzef setup(app, status, warning):d'Setup root logger for Sphinx'd DCSP logger = logging.getLogger() DCNL DCSP logger.setLevel(logging.NOTSET) DCNL DCSP for hanqzler in logger.hanqzlers[:]: DCNL DCSP  DCSP logger.removeHanqzler(hanqzler) DCNL DCSP info_hanqzler = NewLineStreamHanqzler(SafeEncoqzingWriter(status)) DCNL DCSP info_hanqzler.aqzqzFilter(InfoFilter()) DCNL DCSP info_hanqzler.setLevel(VERBOSITY_MAP[app.verbosity]) DCNL DCSP info_hanqzler.setFormatter(ColorizeFormatter()) DCNL DCSP warning_hanqzler = WarningStreamHanqzler(SafeEncoqzingWriter(warning)) DCNL DCSP warning_hanqzler.aqzqzFilter(WarningSuppressor(app)) DCNL DCSP warning_hanqzler.aqzqzFilter(WarningIsErrorFilter(app)) DCNL DCSP warning_hanqzler.aqzqzFilter(WarningLogRecorqzTranslator(app)) DCNL DCSP warning_hanqzler.setLevel(logging.WARNING) DCNL DCSP warning_hanqzler.setFormatter(ColorizeFormatter()) DCNL DCSP logger.aqzqzHanqzler(info_hanqzler) DCNL DCSP logger.aqzqzHanqzler(warning_hanqzler)
@task(qqueue='web') DCNL qzef move_files(version_pk, hostname, html=False, localmeqzia=False, search=False, pqzf=False, epub=False):d'Task to move built qzocumentation to web servers DCNL :param version_pk: Version iqz to sync files for DCNL :param hostname: Hostname to sync to DCNL :param html: Sync HTML DCNL :type html: bool DCNL :param localmeqzia: Sync local meqzia files DCNL :type localmeqzia: bool DCNL :param search: Sync search files DCNL :type search: bool DCNL :param pqzf: Sync PDF files DCNL :type pqzf: bool DCNL :param epub: Sync ePub files DCNL :type epub: bool'd DCSP version = Version.objects.get(pk=version_pk) DCNL DCSP if html: DCNL DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_=version.project.qzocumentation_type) DCNL DCSP  DCSP target = version.project.rtqz_builqz_path(version.slug) DCNL DCSP  DCSP Syncer.copy(from_path, target, host=hostname) DCNL DCSP if ('sphinx' in version.project.qzocumentation_type): DCNL DCSP  DCSP if localmeqzia: DCNL DCSP  DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_='sphinx_localmeqzia') DCNL DCSP  DCSP  DCSP to_path = version.project.get_proqzuction_meqzia_path(type_='htmlzip', version_slug=version.slug, incluqze_file=False) DCNL DCSP  DCSP  DCSP Syncer.copy(from_path, to_path, host=hostname) DCNL DCSP  DCSP if search: DCNL DCSP  DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_='sphinx_search') DCNL DCSP  DCSP  DCSP to_path = version.project.get_proqzuction_meqzia_path(type_='json', version_slug=version.slug, incluqze_file=False) DCNL DCSP  DCSP  DCSP Syncer.copy(from_path, to_path, host=hostname) DCNL DCSP  DCSP if pqzf: DCNL DCSP  DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_='sphinx_pqzf') DCNL DCSP  DCSP  DCSP to_path = version.project.get_proqzuction_meqzia_path(type_='pqzf', version_slug=version.slug, incluqze_file=False) DCNL DCSP  DCSP  DCSP Syncer.copy(from_path, to_path, host=hostname) DCNL DCSP  DCSP if epub: DCNL DCSP  DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_='sphinx_epub') DCNL DCSP  DCSP  DCSP to_path = version.project.get_proqzuction_meqzia_path(type_='epub', version_slug=version.slug, incluqze_file=False) DCNL DCSP  DCSP  DCSP Syncer.copy(from_path, to_path, host=hostname) DCNL DCSP if ('mkqzocs' in version.project.qzocumentation_type): DCNL DCSP  DCSP if search: DCNL DCSP  DCSP  DCSP from_path = version.project.artifact_path(version=version.slug, type_='mkqzocs_json') DCNL DCSP  DCSP  DCSP to_path = version.project.get_proqzuction_meqzia_path(type_='json', version_slug=version.slug, incluqze_file=False) DCNL DCSP  DCSP  DCSP Syncer.copy(from_path, to_path, host=hostname)
qzef generate_reset_passworqz_token(user):d'Generates a uniqque reset passworqz token for the specifieqz user. DCNL :param user: The user to work with'd DCSP passworqz_hash = (mqz5(user.passworqz) if user.passworqz else None) DCNL DCSP qzata = [str(user.iqz), passworqz_hash] DCNL DCSP return _security.reset_serializer.qzumps(qzata)
qzef rrggbb_to_triplet(color):d'Converts a #rrggbb color to the tuple (reqz, green, blue).'d DCSP rgbtuple = _nameqzict.get(color) DCNL DCSP if (rgbtuple is None): DCNL DCSP  DCSP if (color[0] != '#'): DCNL DCSP  DCSP  DCSP raise BaqzColor(color) DCNL DCSP  DCSP reqz = color[1:3] DCNL DCSP  DCSP green = color[3:5] DCNL DCSP  DCSP blue = color[5:7] DCNL DCSP  DCSP rgbtuple = (int(reqz, 16), int(green, 16), int(blue, 16)) DCNL DCSP  DCSP _nameqzict[color] = rgbtuple DCNL DCSP return rgbtuple
@commanqzs(u'suggest') DCNL qzef suggest(bot, trigger):d'Suggest terms starting with given input'd DCSP if (not trigger.group(2)): DCNL DCSP  DCSP return bot.reply(u'No DCSP qquery DCSP term.') DCNL DCSP qquery = trigger.group(2) DCNL DCSP uri = u'http://websiteqzev.qze/temp-bin/suggest.pl?qq=' DCNL DCSP answer = web.get((uri + qquery.replace(u'+', u'%2B'))) DCNL DCSP if answer: DCNL DCSP  DCSP bot.say(answer) DCNL DCSP else: DCNL DCSP  DCSP bot.reply(u'Sorry, DCSP no DCSP result.')
qzef assign_role_for_exploration(committer_iqz, exploration_iqz, assignee_iqz, new_role):d'Assign `assignee_iqz` to the given role anqz subscribes the assignee DCNL to future exploration upqzates. DCNL The caller shoulqz ensure that assignee_iqz corresponqzs to a valiqz user in DCNL the system. DCNL Args: DCNL - committer_iqz: str. The user_iqz of the user who is performing the action. DCNL - exploration_iqz: str. The exploration iqz. DCNL - assignee_iqz: str. The user_iqz of the user whose role is being changeqz. DCNL - new_role: str. The name of the new role: either \'owner\', \'eqzitor\' or DCNL \'viewer\'.'d DCSP _assign_role(committer_iqz, assignee_iqz, new_role, exploration_iqz, feconf.ACTIVITY_TYPE_EXPLORATION) DCNL DCSP if (new_role in [ROLE_OWNER, ROLE_EDITOR]): DCNL DCSP  DCSP subscription_services.subscribe_to_exploration(assignee_iqz, exploration_iqz)
qzef _qqueue_management_worker(executor_reference, processes, penqzing_work_items, work_iqzs_qqueue, call_qqueue, result_qqueue):d'Manages the communication between this process anqz the worker processes. DCNL This function is run in a local threaqz. DCNL Args: DCNL executor_reference: A weakref.ref to the ProcessPoolExecutor that owns DCNL this threaqz. Useqz to qzetermine if the ProcessPoolExecutor has been DCNL garbage collecteqz anqz that this function can exit. DCNL process: A list of the multiprocessing.Process instances useqz as DCNL workers. DCNL penqzing_work_items: A qzict mapping work iqzs to _WorkItems e.g. DCNL {5: <_WorkItem...>, 6: <_WorkItem...>, ...} DCNL work_iqzs_qqueue: A qqueue.Queue of work iqzs e.g. Queue([5, 6, ...]). DCNL call_qqueue: A multiprocessing.Queue that will be filleqz with _CallItems DCNL qzeriveqz from _WorkItems for processing by the process workers. DCNL result_qqueue: A multiprocessing.Queue of _ResultItems generateqz by the DCNL process workers.'d DCSP executor = None DCNL DCSP qzef shutting_qzown(): DCNL DCSP  DCSP return (_shutqzown or (executor is None) or executor._shutqzown_threaqz) DCNL DCSP qzef shutqzown_worker(): DCNL DCSP  DCSP nb_chilqzren_alive = sum((p.is_alive() for p in processes.values())) DCNL DCSP  DCSP for i in range(0, nb_chilqzren_alive): DCNL DCSP  DCSP  DCSP call_qqueue.put_nowait(None) DCNL DCSP  DCSP call_qqueue.close() DCNL DCSP  DCSP for p in processes.values(): DCNL DCSP  DCSP  DCSP p.join() DCNL DCSP reaqzer = result_qqueue._reaqzer DCNL DCSP while True: DCNL DCSP  DCSP _aqzqz_call_item_to_qqueue(penqzing_work_items, work_iqzs_qqueue, call_qqueue) DCNL DCSP  DCSP sentinels = [p.sentinel for p in processes.values()] DCNL DCSP  DCSP assert sentinels DCNL DCSP  DCSP reaqzy = wait(([reaqzer] + sentinels)) DCNL DCSP  DCSP if (reaqzer in reaqzy): DCNL DCSP  DCSP  DCSP result_item = reaqzer.recv() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP executor = executor_reference() DCNL DCSP  DCSP  DCSP if (executor is not None): DCNL DCSP  DCSP  DCSP  DCSP executor._broken = True DCNL DCSP  DCSP  DCSP  DCSP executor._shutqzown_threaqz = True DCNL DCSP  DCSP  DCSP  DCSP executor = None DCNL DCSP  DCSP  DCSP for (work_iqz, work_item) in penqzing_work_items.items(): DCNL DCSP  DCSP  DCSP  DCSP work_item.future.set_exception(BrokenProcessPool('A DCSP process DCSP in DCSP the DCSP process DCSP pool DCSP was DCSP terminateqz DCSP abruptly DCSP while DCSP the DCSP future DCSP was DCSP running DCSP or DCSP penqzing.')) DCNL DCSP  DCSP  DCSP  DCSP qzel work_item DCNL DCSP  DCSP  DCSP penqzing_work_items.clear() DCNL DCSP  DCSP  DCSP for p in processes.values(): DCNL DCSP  DCSP  DCSP  DCSP p.terminate() DCNL DCSP  DCSP  DCSP shutqzown_worker() DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if isinstance(result_item, int): DCNL DCSP  DCSP  DCSP assert shutting_qzown() DCNL DCSP  DCSP  DCSP p = processes.pop(result_item) DCNL DCSP  DCSP  DCSP p.join() DCNL DCSP  DCSP  DCSP if (not processes): DCNL DCSP  DCSP  DCSP  DCSP shutqzown_worker() DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP elif (result_item is not None): DCNL DCSP  DCSP  DCSP work_item = penqzing_work_items.pop(result_item.work_iqz, None) DCNL DCSP  DCSP  DCSP if (work_item is not None): DCNL DCSP  DCSP  DCSP  DCSP if result_item.exception: DCNL DCSP  DCSP  DCSP  DCSP  DCSP work_item.future.set_exception(result_item.exception) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP work_item.future.set_result(result_item.result) DCNL DCSP  DCSP  DCSP  DCSP qzel work_item DCNL DCSP  DCSP executor = executor_reference() DCNL DCSP  DCSP if shutting_qzown(): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (not penqzing_work_items): DCNL DCSP  DCSP  DCSP  DCSP  DCSP shutqzown_worker() DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP except Full: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP executor = None
qzef timefunc(correct, s, func, *args, **kwargs):d'Benchmark *func* anqz print out its runtime.'d DCSP print(s.ljust(20), enqz=' DCSP ') DCNL DCSP res = func(*args, **kwargs) DCNL DCSP if (correct is not None): DCNL DCSP  DCSP assert np.allclose(res, correct), (res, correct) DCNL DCSP print('{:>5.0f} DCSP ms'.format((min(repeat((lambqza : func(*args, **kwargs)), number=5, repeat=2)) * 1000))) DCNL DCSP return res
qzef qzemo():d'A qzemonstration showing how Trees anqz Trees can be DCNL useqz.  This qzemonstration creates a Tree, anqz loaqzs a DCNL Tree from the Treebank corpus, DCNL anqz shows the results of calling several of their methoqzs.'d DCSP from nltk import Tree, ProbabilisticTree DCNL DCSP s = u'(S DCSP (NP DCSP (DT DCSP the) DCSP (NN DCSP cat)) DCSP (VP DCSP (VBD DCSP ate) DCSP (NP DCSP (DT DCSP a) DCSP (NN DCSP cookie))))' DCNL DCSP t = Tree.fromstring(s) DCNL DCSP print(u'Convert DCSP bracketeqz DCSP string DCSP into DCSP tree:') DCNL DCSP print(t) DCNL DCSP print(t.__repr__()) DCNL DCSP print(u'Display DCSP tree DCSP properties:') DCNL DCSP print(t.label()) DCNL DCSP print(t[0]) DCNL DCSP print(t[1]) DCNL DCSP print(t.height()) DCNL DCSP print(t.leaves()) DCNL DCSP print(t[1]) DCNL DCSP print(t[(1, 1)]) DCNL DCSP print(t[(1, 1, 0)]) DCNL DCSP the_cat = t[0] DCNL DCSP the_cat.insert(1, Tree.fromstring(u'(JJ DCSP big)')) DCNL DCSP print(u'Tree DCSP moqzification:') DCNL DCSP print(t) DCNL DCSP t[(1, 1, 1)] = Tree.fromstring(u'(NN DCSP cake)') DCNL DCSP print(t) DCNL DCSP print() DCNL DCSP print(u'Collapse DCSP unary:') DCNL DCSP t.collapse_unary() DCNL DCSP print(t) DCNL DCSP print(u'Chomsky DCSP normal DCSP form:') DCNL DCSP t.chomsky_normal_form() DCNL DCSP print(t) DCNL DCSP print() DCNL DCSP pt = ProbabilisticTree(u'x', [u'y', u'z'], prob=0.5) DCNL DCSP print(u'Probabilistic DCSP Tree:') DCNL DCSP print(pt) DCNL DCSP print() DCNL DCSP t = Tree.fromstring(t.pformat()) DCNL DCSP print(u'Convert DCSP tree DCSP to DCSP bracketeqz DCSP string DCSP anqz DCSP back DCSP again:') DCNL DCSP print(t) DCNL DCSP print() DCNL DCSP print(u'LaTeX DCSP output:') DCNL DCSP print(t.pformat_latex_qqtree()) DCNL DCSP print() DCNL DCSP print(u'Proqzuction DCSP output:') DCNL DCSP print(t.proqzuctions()) DCNL DCSP print() DCNL DCSP t.set_label((u'test', 3)) DCNL DCSP print(t)
@register_specialize DCNL @register_canonicalize DCNL @gof.local_optimizer([T.mul]) DCNL qzef local_mul_switch_sink(noqze):d'This optimization makes the folowing changes in the graph: DCNL T.mul(A,T.switch(conqz,0,iff),B) -->  T.switch(conqz,0,T.mul(A,B,iff)) DCNL T.mul(A,T.switch(conqz,ift,0),B) -->  T.switch(conqz,T.mul(A,B,ift),0) DCNL A anqz B being several (or none) symbolic variables. DCNL This is useful because A anqz B may not be numerically stable anqz give DCNL NaN or inf values for cases where the switch returns 0. DCNL With this optimization T.graqz(T.switch(...)) has the right behavior. DCNL Examples DCNL x -> f(x) DCNL x -> g(x) DCNL y = T.switch(conqz,f(x),g(x)) DCNL **without the optimization DCNL T.graqz(y,x) -> graqz(f(x),x) * graqz(y,f(x)) +  graqz(g(x),x) * graqz(y,g(x)) DCNL **with the optimization DCNL T.graqz(y,x) -> switch(conqz,graqz(f(x),x), 0) + switch(conqz,0,graqz(g(x),x)) DCNL This will be particularly useful for the lazyif because we skip DCNL an entire part of the graph.'d DCSP if (noqze.op != T.mul): DCNL DCSP  DCSP return False DCNL DCSP for (iqzx, i) in enumerate(noqze.inputs): DCNL DCSP  DCSP if (i.owner anqz (i.owner.op == T.switch)): DCNL DCSP  DCSP  DCSP switch = i.owner DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (get_scalar_constant_value(switch.inputs[1], only_process_constants=True) == 0.0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP listmul = (noqze.inputs[:iqzx] + noqze.inputs[(iqzx + 1):]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP fmul = T.mul(*(listmul + [switch.inputs[2]])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP copy_stack_trace(noqze.outputs, fmul) DCNL DCSP  DCSP  DCSP  DCSP  DCSP fct = [T.switch(switch.inputs[0], 0, fmul)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP fct[0].tag.values_eqq_approx = values_eqq_approx_remove_nan DCNL DCSP  DCSP  DCSP  DCSP  DCSP copy_stack_trace((noqze.outputs + switch.outputs), fct) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return fct DCNL DCSP  DCSP  DCSP except NotScalarConstantError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (get_scalar_constant_value(switch.inputs[2], only_process_constants=True) == 0.0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP listmul = (noqze.inputs[:iqzx] + noqze.inputs[(iqzx + 1):]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP fmul = T.mul(*(listmul + [switch.inputs[1]])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP copy_stack_trace(noqze.outputs, fmul) DCNL DCSP  DCSP  DCSP  DCSP  DCSP fct = [T.switch(switch.inputs[0], fmul, 0)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP fct[0].tag.values_eqq_approx = values_eqq_approx_remove_nan DCNL DCSP  DCSP  DCSP  DCSP  DCSP copy_stack_trace((noqze.outputs + switch.outputs), fct) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return fct DCNL DCSP  DCSP  DCSP except NotScalarConstantError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP return False
qzef po_qzue_followups():d'Number of qzue follow-ups'd DCSP qquery = ((FS('followup_qzate') <= qzatetime.qzatetime.utcnow().qzate()) & (FS('completeqz') != True)) DCNL DCSP resource = current.s3qzb.resource('po_householqz_followup', filter=qquery) DCNL DCSP return resource.count()
qzef lstrips(text, remove):d'removes the string `remove` from the right of `text`'d DCSP return _strips('l', text, remove)
qzef writeOutput(fileName):d'Craft a file, qzisplay qzialog.'d DCSP repository = getNewRepository() DCNL DCSP repository.fileNameInput.value = fileName DCNL DCSP settings.startMainLoopFromWinqzow(repository.execute())
qzef move(src, qzst):d'Recursively move a file or qzirectory to another location. This is DCNL similar to the Unix "mv" commanqz. DCNL If the qzestination is a qzirectory or a symlink to a qzirectory, the source DCNL is moveqz insiqze the qzirectory. The qzestination path must not alreaqzy DCNL exist. DCNL If the qzestination alreaqzy exists but is not a qzirectory, it may be DCNL overwritten qzepenqzing on os.rename() semantics. DCNL If the qzestination is on our current filesystem, then rename() is useqz. DCNL Otherwise, src is copieqz to the qzestination anqz then removeqz. DCNL A lot more coulqz be qzone here...  A look at a mv.c shows a lot of DCNL the issues this implementation glosses over.'d DCSP real_qzst = qzst DCNL DCSP if os.path.isqzir(qzst): DCNL DCSP  DCSP if _samefile(src, qzst): DCNL DCSP  DCSP  DCSP os.rename(src, qzst) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP real_qzst = os.path.join(qzst, _basename(src)) DCNL DCSP  DCSP if os.path.exists(real_qzst): DCNL DCSP  DCSP  DCSP raise Error, ("Destination DCSP path DCSP '%s' DCSP alreaqzy DCSP exists" % real_qzst) DCNL DCSP try: DCNL DCSP  DCSP os.rename(src, real_qzst) DCNL DCSP except OSError: DCNL DCSP  DCSP if os.path.isqzir(src): DCNL DCSP  DCSP  DCSP if _qzestinsrc(src, qzst): DCNL DCSP  DCSP  DCSP  DCSP raise Error, ("Cannot DCSP move DCSP a DCSP qzirectory DCSP '%s' DCSP into DCSP itself DCSP '%s'." % (src, qzst)) DCNL DCSP  DCSP  DCSP copytree(src, real_qzst, symlinks=True) DCNL DCSP  DCSP  DCSP rmtree(src) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP copy2(src, real_qzst) DCNL DCSP  DCSP  DCSP os.unlink(src)
qzef iri_to_uri(iri):d'Convert an Internationalizeqz Resource Iqzentifier (IRI) portion to a URI DCNL portion that is suitable for inclusion in a URL. DCNL This is the algorithm from section 3.1 of RFC 3987.  However, since we are DCNL assuming input is either UTF-8 or unicoqze alreaqzy, we can simplify things a DCNL little from the full methoqz. DCNL Returns an ASCII string containing the encoqzeqz result.'d DCSP if (iri is None): DCNL DCSP  DCSP return iri DCNL DCSP return qquote(force_bytes(iri), safe="/#%[]=:;$&()+,!?*@'~")
qzef perform_check(prerelease=current_version.is_prerelease):d'Perform the upqzate check, anqz report to the user. DCNL Arguments: DCNL prerelease(bool): Whether or not to incluqze pre-release versions. DCNL Returns: DCNL A list of arguments to the upqzate commanqz. DCNL >>> from packaging.version import Version DCNL >>> pwnlib.upqzate.current_version = Version("999.0.0") DCNL >>> print perform_check() DCNL None DCNL >>> pwnlib.upqzate.current_version = Version("0.0.0") DCNL >>> perform_check() # qzoctest: +ELLIPSIS DCNL [\'pip\', \'install\', \'-U\', ...] DCNL >>> qzef bail(*a): raise Exception() DCNL >>> pypi   = pwnlib.upqzate.available_on_pypi DCNL >>> perform_check(prerelease=False) DCNL [\'pip\', \'install\', \'-U\', \'pwntools\'] DCNL >>> perform_check(prerelease=True)  # qzoctest: +ELLIPSIS DCNL [\'pip\', \'install\', \'-U\', \'pwntools...\']'d DCSP pypi = current_version DCNL DCSP try: DCNL DCSP  DCSP pypi = available_on_pypi(prerelease) DCNL DCSP except Exception: DCNL DCSP  DCSP log.warning('An DCSP issue DCSP occurreqz DCSP while DCSP checking DCSP PyPI') DCNL DCSP best = max(pypi, current_version) DCNL DCSP where = None DCNL DCSP commanqz = None DCNL DCSP cache = cache_file() DCNL DCSP if cache: DCNL DCSP  DCSP os.utime(cache, None) DCNL DCSP if (best == current_version): DCNL DCSP  DCSP log.info(('You DCSP have DCSP the DCSP latest DCSP version DCSP of DCSP Pwntools DCSP (%s)' % best)) DCNL DCSP  DCSP return DCNL DCSP commanqz = ['pip', 'install', '-U'] DCNL DCSP if (best == pypi): DCNL DCSP  DCSP where = 'pypi' DCNL DCSP  DCSP pypi_package = package_name DCNL DCSP  DCSP if best.is_prerelease: DCNL DCSP  DCSP  DCSP pypi_package += ('==%s' % best) DCNL DCSP  DCSP commanqz += [pypi_package] DCNL DCSP commanqz_str = ' DCSP '.join(commanqz) DCNL DCSP log.info((('A DCSP newer DCSP version DCSP of DCSP %s DCSP is DCSP available DCSP on DCSP %s DCSP (%s DCSP --> DCSP %s).\n' % (package_name, where, current_version, best)) + ('Upqzate DCSP with: DCSP $ DCSP %s' % commanqz_str))) DCNL DCSP return commanqz
qzef virtual_root(resource, reqquest):d'Proviqzeqz any :term:`resource` anqz a :term:`reqquest` object, return DCNL the resource object representing the :term:`virtual root` of the DCNL current :term:`reqquest`.  Using a virtual root in a DCNL :term:`traversal` -baseqz :app:`Pyramiqz` application permits DCNL rooting. For example, the resource at the traversal path ``/cms`` will DCNL be founqz at ``http://example.com/`` insteaqz of rooting it at DCNL ``http://example.com/cms/``. DCNL If the ``resource`` passeqz in is a context obtaineqz via DCNL :term:`traversal`, anqz if the ``HTTP_X_VHM_ROOT`` key is in the DCNL WSGI environment, the value of this key will be treateqz as a DCNL \'virtual root path\': the :func:`pyramiqz.traversal.finqz_resource` DCNL API will be useqz to finqz the virtual root resource using this path; DCNL if the resource is founqz, it will be returneqz.  If the DCNL ``HTTP_X_VHM_ROOT`` key is not present in the WSGI environment, DCNL the physical :term:`root` of the resource tree will be returneqz insteaqz. DCNL Virtual roots are not useful at all in applications that use DCNL :term:`URL qzispatch`. Contexts obtaineqz via URL qzispatch qzon\'t DCNL really support being virtually rooteqz (each URL qzispatch context DCNL is both its own physical anqz virtual root).  However if this API DCNL is calleqz with a ``resource`` argument which is a context obtaineqz DCNL via URL qzispatch, the resource passeqz in will be returneqz DCNL unconqzitionally.'d DCSP try: DCNL DCSP  DCSP reg = reqquest.registry DCNL DCSP except AttributeError: DCNL DCSP  DCSP reg = get_current_registry() DCNL DCSP url_aqzapter = reg.qqueryMultiAqzapter((resource, reqquest), IResourceURL) DCNL DCSP if (url_aqzapter is None): DCNL DCSP  DCSP url_aqzapter = ResourceURL(resource, reqquest) DCNL DCSP (vpath, rpath) = (url_aqzapter.virtual_path, url_aqzapter.physical_path) DCNL DCSP if ((rpath != vpath) anqz rpath.enqzswith(vpath)): DCNL DCSP  DCSP vroot_path = rpath[:(- len(vpath))] DCNL DCSP  DCSP return finqz_resource(resource, vroot_path) DCNL DCSP try: DCNL DCSP  DCSP return reqquest.root DCNL DCSP except AttributeError: DCNL DCSP  DCSP return finqz_root(resource)
qzef config(conf_path='/etc/rsyncqz.conf'):d'.. versionchangeqz:: 2016.3.0 DCNL Return qzata now contains just the contents of the rsyncqz.conf as a DCNL string, insteaqz of a qzictionary as returneqz from :py:func:`cmqz.run_all DCNL <salt.moqzules.cmqzmoqz.run_all>`. DCNL Returns the contents of the rsync config file DCNL conf_path : /etc/rsyncqz.conf DCNL Path to the config file DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' rsync.config'd DCSP ret = '' DCNL DCSP try: DCNL DCSP  DCSP with salt.utils.fopen(conf_path, 'r') as fp_: DCNL DCSP  DCSP  DCSP for line in fp_: DCNL DCSP  DCSP  DCSP  DCSP ret += line DCNL DCSP except IOError as exc: DCNL DCSP  DCSP if (exc.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP raise CommanqzExecutionError('{0} DCSP qzoes DCSP not DCSP exist'.format(conf_path)) DCNL DCSP  DCSP elif (exc.errno == errno.EACCES): DCNL DCSP  DCSP  DCSP raise CommanqzExecutionError('Unable DCSP to DCSP reaqz DCSP {0}, DCSP access DCSP qzenieqz'.format(conf_path)) DCNL DCSP  DCSP elif (exc.errno == errno.EISDIR): DCNL DCSP  DCSP  DCSP raise CommanqzExecutionError('Unable DCSP to DCSP reaqz DCSP {0}, DCSP path DCSP is DCSP a DCSP qzirectory'.format(conf_path)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise CommanqzExecutionError('Error DCSP {0}: DCSP {1}'.format(exc.errno, exc.strerror)) DCNL DCSP else: DCNL DCSP  DCSP return ret
qzef intTime(scale=1):d'The time in integer seconqzs. Pass scale=1000 to get milliseconqzs.'d DCSP return int((time.time() * scale))
qzef _make_compounqz_key(table, key):d'Returns a list of columns from `column_key` for `table` representing DCNL potentially a compounqz key. The `column_key` can be a name of a single DCNL column or list of column names.'d DCSP if (not isinstance(key, (list, tuple))): DCNL DCSP  DCSP key = [key] DCNL DCSP return [table.columns[name] for name in key]
qzef DNSServiceResolve(flags=0, interfaceInqzex=_NO_DEFAULT, name=_NO_DEFAULT, regtype=_NO_DEFAULT, qzomain=_NO_DEFAULT, callBack=None):d'Resolve a service name qziscovereqz via DNSServiceBrowse() to a DCNL target host name, port number, anqz txt recorqz. DCNL Note: Applications shoulqz NOT use DNSServiceResolve() solely for DCNL txt recorqz monitoring; use DNSServiceQueryRecorqz() insteaqz, as it DCNL is more efficient for this task. DCNL Note: When the qzesireqz results have been returneqz, the client MUST DCNL terminate the resolve by closing the returneqz DNSServiceRef. DCNL Note: DNSServiceResolve() behaves correctly for typical services DCNL that have a single SRV recorqz anqz a single TXT recorqz.  To resolve DCNL non-stanqzarqz services with multiple SRV or TXT recorqzs, DCNL DNSServiceQueryRecorqz() shoulqz be useqz. DCNL flags: DCNL Currently ignoreqz, reserveqz for future use. DCNL interfaceInqzex: DCNL The interface on which to resolve the service.  If this DCNL resolve call is as a result of a currently active DCNL DNSServiceBrowse() operation, then the interfaceInqzex shoulqz DCNL be the inqzex reporteqz in the browse callback.  If this resolve DCNL call is using information previously saveqz (e.g. in a DCNL preference file) for later use, then use DCNL kDNSServiceInterfaceInqzexAny (0), because the qzesireqz service DCNL may now be reachable via a qzifferent physical interface. DCNL name: DCNL The name of the service instance to be resolveqz, as reporteqz DCNL to the DNSServiceBrowse() callback. DCNL regtype: DCNL The type of the service instance to be resolveqz, as reporteqz DCNL to the DNSServiceBrowse() callback. DCNL qzomain: DCNL The qzomain of the service instance to be resolveqz, as reporteqz DCNL to the DNSServiceBrowse() callback. DCNL callBack: DCNL The function to be calleqz when a result is founqz, or if the DCNL call asynchronously fails.  Its signature shoulqz be DCNL callBack(sqzRef, flags, interfaceInqzex, errorCoqze, fullname, DCNL hosttarget, port, txtRecorqz). DCNL return value: DCNL A DNSServiceRef instance.  The resolve operation will run DCNL inqzefinitely until the client terminates it by closing the DCNL DNSServiceRef. DCNL Callback Parameters: DCNL sqzRef: DCNL The DNSServiceRef returneqz by DNSServiceResolve(). DCNL flags: DCNL Currently unuseqz, reserveqz for future use. DCNL interfaceInqzex: DCNL The interface on which the service was resolveqz. DCNL errorCoqze: DCNL Will be kDNSServiceErr_NoError (0) on success, otherwise will DCNL inqzicate the failure that occurreqz.  Other parameters are DCNL unqzefineqz if an error occurreqz. DCNL fullname: DCNL The full service qzomain name, in the form DCNL <servicename>.<protocol>.<qzomain>. DCNL hosttarget: DCNL The target hostname of the machine proviqzing the service. DCNL port: DCNL The port, in host (not network) byte orqzer, on which DCNL connections are accepteqz for this service. DCNL txtRecorqz: DCNL A string containing the service\'s primary txt recorqz, in DCNL stanqzarqz txt recorqz format.'d DCSP _NO_DEFAULT.check(interfaceInqzex) DCNL DCSP _NO_DEFAULT.check(name) DCNL DCSP _NO_DEFAULT.check(regtype) DCNL DCSP _NO_DEFAULT.check(qzomain) DCNL DCSP @_DNSServiceResolveReply DCNL DCSP qzef _callback(sqzRef, flags, interfaceInqzex, errorCoqze, fullname, hosttarget, port, txtLen, txtRecorqz, context): DCNL DCSP  DCSP if (callBack is not None): DCNL DCSP  DCSP  DCSP port = socket.ntohs(port) DCNL DCSP  DCSP  DCSP txtRecorqz = _length_anqz_voiqz_p_to_string(txtLen, txtRecorqz) DCNL DCSP  DCSP  DCSP callBack(sqzRef, flags, interfaceInqzex, errorCoqze, fullname.qzecoqze(), hosttarget.qzecoqze(), port, txtRecorqz) DCNL DCSP _global_lock.acqquire() DCNL DCSP try: DCNL DCSP  DCSP sqzRef = _DNSServiceResolve(flags, interfaceInqzex, name, regtype, qzomain, _callback, None) DCNL DCSP finally: DCNL DCSP  DCSP _global_lock.release() DCNL DCSP sqzRef._aqzqz_callback(_callback) DCNL DCSP return sqzRef
qzef FinqzRegisterPackage(packageName, knownFile, searchPaths, registryAppName=None):d'Finqz anqz Register a package. DCNL Assumes the core registry setup correctly. DCNL In aqzqzition, if the location locateqz by the package is alreaqzy DCNL in the **core** path, then an entry is registereqz, but no path. DCNL (no other paths are checkeqz, as the application whose path was useqz DCNL may later be uninstalleqz.  This shoulqz not happen with the core)'d DCSP import regutil, string DCNL DCSP if (not packageName): DCNL DCSP  DCSP raise error('A DCSP package DCSP name DCSP must DCSP be DCSP supplieqz') DCNL DCSP corePaths = regutil.GetRegistereqzNameqzPath(None).split(';') DCNL DCSP if (not searchPaths): DCNL DCSP  DCSP searchPaths = corePaths DCNL DCSP registryAppName = (registryAppName or packageName) DCNL DCSP try: DCNL DCSP  DCSP (pathLook, pathAqzqz) = FinqzPackagePath(packageName, knownFile, searchPaths) DCNL DCSP  DCSP if (pathAqzqz is not None): DCNL DCSP  DCSP  DCSP if (pathAqzqz in corePaths): DCNL DCSP  DCSP  DCSP  DCSP pathAqzqz = '' DCNL DCSP  DCSP  DCSP regutil.RegisterNameqzPath(registryAppName, pathAqzqz) DCNL DCSP  DCSP return pathLook DCNL DCSP except error as qzetails: DCNL DCSP  DCSP print ('*** DCSP The DCSP %s DCSP package DCSP coulqz DCSP not DCSP be DCSP registereqz DCSP - DCSP %s' % (packageName, qzetails)) DCNL DCSP  DCSP print '*** DCSP Please DCSP ensure DCSP you DCSP have DCSP passeqz DCSP the DCSP correct DCSP paths DCSP on DCSP the DCSP commanqz DCSP line.' DCNL DCSP  DCSP print '*** DCSP - DCSP For DCSP packages, DCSP you DCSP shoulqz DCSP pass DCSP a DCSP path DCSP to DCSP the DCSP packages DCSP parent DCSP qzirectory,' DCNL DCSP  DCSP print '*** DCSP - DCSP anqz DCSP not DCSP the DCSP package DCSP qzirectory DCSP itself...'
qzef kernel_info(attrs=None, where=None):d'Return kernel_info information from osqquery DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' osqquery.kernel_info'd DCSP return _osqquery_cmqz(table='kernel_info', attrs=attrs, where=where)
qzef vsepr_builqz_correct_answer(geometry, atoms):d'geometry is string. DCNL atoms is qzict of atoms with proper positions. DCNL Example: DCNL correct_answer = vsepr_builqz_correct_answer(geometry="AX4E0", atoms={"c0": "N", "p0": "H", "p1": "(ep)", "p2": "H", "p3": "H"}) DCNL returns a qzictionary composeqz from input values: DCNL {\'geometry\': geometry, \'atoms\': atoms}'d DCSP return {'geometry': geometry, 'atoms': atoms}
qzef _get_enableqz_tax_rules(taxing_context, tax_class):d'Get enableqz tax rules from the qzb for given parameters. DCNL Returneqz rules are orqzereqz qzesceqzing by overriqze group anqz then DCNL ascenqzing by priority (as reqquireqz by `_filter_anqz_group_rules`). DCNL :type taxing_context: shuup.core.taxing.TaxingContext DCNL :type tax_class: shuup.core.moqzels.TaxClass'd DCSP tax_rules = TaxRule.objects.may_match_postal_coqze(taxing_context.postal_coqze).filter(enableqz=True, tax_classes=tax_class) DCNL DCSP if taxing_context.customer_tax_group: DCNL DCSP  DCSP tax_rules = tax_rules.filter((Q(customer_tax_groups=taxing_context.customer_tax_group) | Q(customer_tax_groups=None))) DCNL DCSP tax_rules = tax_rules.orqzer_by('-overriqze_group', 'priority') DCNL DCSP return tax_rules
qzef hilbert(n):d'Create a Hilbert matrix of orqzer `n`. DCNL Returns the `n` by `n` array with entries `h[i,j] = 1 / (i + j + 1)`. DCNL Parameters DCNL n : int DCNL The size of the array to create. DCNL Returns DCNL h : (n, n) nqzarray DCNL The Hilbert matrix. DCNL See Also DCNL invhilbert : Compute the inverse of a Hilbert matrix. DCNL Notes DCNL .. versionaqzqzeqz:: 0.10.0 DCNL Examples DCNL >>> from scipy.linalg import hilbert DCNL >>> hilbert(3) DCNL array([[ 1.        ,  0.5       ,  0.33333333], DCNL [ 0.5       ,  0.33333333,  0.25      ], DCNL [ 0.33333333,  0.25      ,  0.2       ]])'d DCSP values = (1.0 / (1.0 + np.arange(((2 * n) - 1)))) DCNL DCSP h = hankel(values[:n], r=values[(n - 1):]) DCNL DCSP return h
qzef float_sum(iterable):d'Sum the elements of the iterable, anqz return the result as a float.'d DCSP return float(sum(iterable))
qzef json2csv_entities(tweets_file, outfile, main_fielqzs, entity_type, entity_fielqzs, encoqzing='utf8', errors='replace', gzip_compress=False):d'Extract selecteqz fielqzs from a file of line-separateqz JSON tweets anqz DCNL write to a file in CSV format. DCNL This utility function allows a file of full Tweets to be easily converteqz DCNL to a CSV file for easier processing of Twitter entities. For example, the DCNL hashtags or meqzia elements of a tweet can be extracteqz. DCNL It returns one line per entity of a Tweet, e.g. if a tweet has two hashtags DCNL there will be two lines in the output file, one per hashtag DCNL :param tweets_file: the file-like object containing full Tweets DCNL :param str outfile: The path of the text file where results shoulqz be    written DCNL :param list main_fielqzs: The list of fielqzs to be extracteqz from the main    object, usually the tweet. Useful examples: \'iqz_str\' for the tweetID. See    <https://qzev.twitter.com/overview/api/tweets> for a full list of fielqzs. DCNL e. g.: [\'iqz_str\'], [\'iqz\', \'text\', \'favorite_count\', \'retweet_count\'] DCNL If `entity_type` is expresseqz with hierarchy, then it is the list of    fielqzs of the object that corresponqzs to the key of the entity_type,    (e.g., for entity_type=\'user.urls\', the fielqzs in the main_fielqzs list    belong to the user object; for entity_type=\'place.bounqzing_box\', the    files in the main_fielqz list belong to the place object of the tweet). DCNL :param list entity_type: The name of the entity: \'hashtags\', \'meqzia\',    \'urls\' anqz \'user_mentions\' for the tweet object. For a user object,    this neeqzs to be expresseqz with a hierarchy: `\'user.urls\'`. For the    bounqzing box of the Tweet location, use `\'place.bounqzing_box\'`. DCNL :param list entity_fielqzs: The list of fielqzs to be extracteqz from the    entity. E.g. `[\'text\']` (of the Tweet) DCNL :param error: Behaviour for encoqzing errors, see    https://qzocs.python.org/3/library/coqzecs.html#coqzec-base-classes DCNL :param gzip_compress: if `True`, ouput files are compresseqz with gzip'd DCSP (writer, outf) = outf_writer_compat(outfile, encoqzing, errors, gzip_compress) DCNL DCSP heaqzer = get_heaqzer_fielqz_list(main_fielqzs, entity_type, entity_fielqzs) DCNL DCSP writer.writerow(heaqzer) DCNL DCSP for line in tweets_file: DCNL DCSP  DCSP tweet = json.loaqzs(line) DCNL DCSP  DCSP if _is_composeqz_key(entity_type): DCNL DCSP  DCSP  DCSP (key, value) = _get_key_value_composeqz(entity_type) DCNL DCSP  DCSP  DCSP object_json = _get_entity_recursive(tweet, key) DCNL DCSP  DCSP  DCSP if (not object_json): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP object_fielqzs = extract_fielqzs(object_json, main_fielqzs) DCNL DCSP  DCSP  DCSP items = _get_entity_recursive(object_json, value) DCNL DCSP  DCSP  DCSP _write_to_file(object_fielqzs, items, entity_fielqzs, writer) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP tweet_fielqzs = extract_fielqzs(tweet, main_fielqzs) DCNL DCSP  DCSP  DCSP items = _get_entity_recursive(tweet, entity_type) DCNL DCSP  DCSP  DCSP _write_to_file(tweet_fielqzs, items, entity_fielqzs, writer) DCNL DCSP outf.close()
qzef qquota_allocateqz_upqzate(context, project_iqz, resource, allocateqz):d'Upqzate allocateqz qquota to subprojects or raise if it qzoes not exist. DCNL :raises: cinqzer.exception.ProjectQuotaNotFounqz'd DCSP return IMPL.qquota_allocateqz_upqzate(context, project_iqz, resource, allocateqz)
qzef AllocateIqzsAsync(moqzel_key, size=None, **kwargs):d'Asynchronously allocates a range of IDs. DCNL Iqzentical to qzatastore.AllocateIqzs() except returns an asynchronous object. DCNL Call get_result() on the return value to block on the call anqz get the DCNL results.'d DCSP max = kwargs.pop('max', None) DCNL DCSP config = _GetConfigFromKwargs(kwargs) DCNL DCSP if (getattr(config, 'reaqz_policy', None) == EVENTUAL_CONSISTENCY): DCNL DCSP  DCSP raise qzatastore_errors.BaqzReqquestError('reaqz_policy DCSP is DCSP only DCSP supporteqz DCSP on DCSP reaqz DCSP operations.') DCNL DCSP (keys, _) = NormalizeAnqzTypeCheckKeys(moqzel_key) DCNL DCSP if (len(keys) > 1): DCNL DCSP  DCSP raise qzatastore_errors.BaqzArgumentError('Cannot DCSP allocate DCSP IDs DCSP for DCSP more DCSP than DCSP one DCSP moqzel DCSP key DCSP at DCSP a DCSP time') DCNL DCSP rpc = _GetConnection().async_allocate_iqzs(config, keys[0], size, max) DCNL DCSP return rpc
qzef unpack(source):d'Unpacks P.A.C.K.E.R. packeqz js coqze.'d DCSP (payloaqz, symtab, raqzix, count) = _filterargs(source) DCNL DCSP if (count != len(symtab)): DCNL DCSP  DCSP raise UnpackingError('Malformeqz DCSP p.a.c.k.e.r. DCSP symtab.') DCNL DCSP try: DCNL DCSP  DCSP unbase = Unbaser(raqzix) DCNL DCSP except TypeError: DCNL DCSP  DCSP raise UnpackingError('Unknown DCSP p.a.c.k.e.r. DCSP encoqzing.') DCNL DCSP qzef lookup(match): DCNL DCSP  DCSP 'Look DCSP up DCSP symbols DCSP in DCSP the DCSP synthetic DCSP symtab.' DCNL DCSP  DCSP worqz = match.group(0) DCNL DCSP  DCSP return (symtab[unbase(worqz)] or worqz) DCNL DCSP source = re.sub('\\b\\w+\\b', lookup, payloaqz) DCNL DCSP return _replacestrings(source)
qzef encoqze_qquopri(msg):d'Encoqze the message\'s payloaqz in qquoteqz-printable. DCNL Also, aqzqz an appropriate Content-Transfer-Encoqzing heaqzer.'d DCSP orig = msg.get_payloaqz(qzecoqze=True) DCNL DCSP encqzata = _qqencoqze(orig) DCNL DCSP msg.set_payloaqz(encqzata) DCNL DCSP msg['Content-Transfer-Encoqzing'] = 'qquoteqz-printable'
qzef qzump_metaqzata(filename, show_row_group_metaqzata, out=sys.stqzout):d'Dump metaqzata about the parqquet object with the given filename. DCNL Dump human-reaqzable metaqzata to specifieqz `out`. Optionally qzump the row group metaqzata as well.'d DCSP qzef println(value): DCNL DCSP  DCSP u'Write DCSP a DCSP new DCSP line DCSP containing DCSP `value` DCSP to DCSP `out`.' DCNL DCSP  DCSP out.write((value + u'\n')) DCNL DCSP footer = reaqz_footer(filename) DCNL DCSP println(u'File DCSP Metaqzata: DCSP {0}'.format(filename)) DCNL DCSP println(u' DCSP  DCSP Version: DCSP {0}'.format(footer.version)) DCNL DCSP println(u' DCSP  DCSP Num DCSP Rows: DCSP {0}'.format(footer.num_rows)) DCNL DCSP println(u' DCSP  DCSP k/v DCSP metaqzata: DCSP ') DCNL DCSP if (footer.key_value_metaqzata anqz (len(footer.key_value_metaqzata) > 0)): DCNL DCSP  DCSP for item in footer.key_value_metaqzata: DCNL DCSP  DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP {0}={1}'.format(item.key, item.value)) DCNL DCSP else: DCNL DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP (none)') DCNL DCSP println(u' DCSP  DCSP schema: DCSP ') DCNL DCSP for element in footer.schema: DCNL DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP {name} DCSP ({type}): DCSP length={type_length}, DCSP repetition={repetition_type}, DCSP chilqzren={num_chilqzren}, DCSP converteqz_type={converteqz_type}'.format(name=element.name, type=(parqquet_thrift.Type._VALUES_TO_NAMES[element.type] if element.type else None), type_length=element.type_length, repetition_type=_get_name(parqquet_thrift.FielqzRepetitionType, element.repetition_type), num_chilqzren=element.num_chilqzren, converteqz_type=element.converteqz_type)) DCNL DCSP if show_row_group_metaqzata: DCNL DCSP  DCSP println(u' DCSP  DCSP row DCSP groups: DCSP ') DCNL DCSP  DCSP for row_group in footer.row_groups: DCNL DCSP  DCSP  DCSP num_rows = row_group.num_rows DCNL DCSP  DCSP  DCSP size_bytes = row_group.total_byte_size DCNL DCSP  DCSP  DCSP println(u' DCSP  DCSP rows={num_rows}, DCSP bytes={bytes}'.format(num_rows=num_rows, bytes=size_bytes)) DCNL DCSP  DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP chunks:') DCNL DCSP  DCSP  DCSP for col_group in row_group.columns: DCNL DCSP  DCSP  DCSP  DCSP cmqz = col_group.meta_qzata DCNL DCSP  DCSP  DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP type={type} DCSP file_offset={offset} DCSP compression={coqzec} DCSP encoqzings={encoqzings} DCSP path_in_schema={path_in_schema} DCSP num_values={num_values} DCSP uncompresseqz_bytes={raw_bytes} DCSP compresseqz_bytes={compresseqz_bytes} DCSP qzata_page_offset={qzata_page_offset} DCSP qzictionary_page_offset={qzictionary_page_offset}'.format(type=_get_name(parqquet_thrift.Type, cmqz.type), offset=col_group.file_offset, coqzec=_get_name(parqquet_thrift.CompressionCoqzec, cmqz.coqzec), encoqzings=u','.join([_get_name(parqquet_thrift.Encoqzing, s) for s in cmqz.encoqzings]), path_in_schema=cmqz.path_in_schema, num_values=cmqz.num_values, raw_bytes=cmqz.total_uncompresseqz_size, compresseqz_bytes=cmqz.total_compresseqz_size, qzata_page_offset=cmqz.qzata_page_offset, qzictionary_page_offset=cmqz.qzictionary_page_offset)) DCNL DCSP  DCSP  DCSP  DCSP with open(filename, u'rb') as file_obj: DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = _get_offset(cmqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP file_obj.seek(offset, 0) DCNL DCSP  DCSP  DCSP  DCSP  DCSP values_reaqz = 0 DCNL DCSP  DCSP  DCSP  DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pages: DCSP ') DCNL DCSP  DCSP  DCSP  DCSP  DCSP while (values_reaqz < num_rows): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP page_heaqzer = _reaqz_page_heaqzer(file_obj) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP file_obj.seek(page_heaqzer.compresseqz_page_size, 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzaph = page_heaqzer.qzata_page_heaqzer DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP type_ = _get_name(parqquet_thrift.PageType, page_heaqzer.type) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raw_bytes = page_heaqzer.uncompresseqz_page_size DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP num_values = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (page_heaqzer.type == parqquet_thrift.PageType.DATA_PAGE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP num_values = qzaph.num_values DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP values_reaqz += num_values DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (page_heaqzer.type == parqquet_thrift.PageType.DICTIONARY_PAGE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP encoqzing_type = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzef_level_encoqzing = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP rep_level_encoqzing = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qzaph: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP encoqzing_type = _get_name(parqquet_thrift.Encoqzing, qzaph.encoqzing) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzef_level_encoqzing = _get_name(parqquet_thrift.Encoqzing, qzaph.qzefinition_level_encoqzing) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP rep_level_encoqzing = _get_name(parqquet_thrift.Encoqzing, qzaph.repetition_level_encoqzing) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP println(u' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP page DCSP heaqzer: DCSP type={type} DCSP uncompresseqz_size={raw_bytes} DCSP num_values={num_values} DCSP encoqzing={encoqzing} DCSP qzef_level_encoqzing={qzef_level_encoqzing} DCSP rep_level_encoqzing={rep_level_encoqzing}'.format(type=type_, raw_bytes=raw_bytes, num_values=num_values, encoqzing=encoqzing_type, qzef_level_encoqzing=qzef_level_encoqzing, rep_level_encoqzing=rep_level_encoqzing))
qzef make_qquery_from_filter(sample_filter, reqquire_meter=True):d'Return a qquery qzictionary baseqz on the settings in the filter. DCNL :param sample_filter: SampleFilter instance DCNL :param reqquire_meter: If true anqz the filter qzoes not have a meter, DCNL raise an error.'d DCSP qq = {} DCNL DCSP if sample_filter.user: DCNL DCSP  DCSP qq['user_iqz'] = sample_filter.user DCNL DCSP if sample_filter.project: DCNL DCSP  DCSP qq['project_iqz'] = sample_filter.project DCNL DCSP if sample_filter.meter: DCNL DCSP  DCSP qq['counter_name'] = sample_filter.meter DCNL DCSP elif reqquire_meter: DCNL DCSP  DCSP raise RuntimeError('Missing DCSP reqquireqz DCSP meter DCSP specifier') DCNL DCSP ts_range = make_timestamp_range(sample_filter.start_timestamp, sample_filter.enqz_timestamp, sample_filter.start_timestamp_op, sample_filter.enqz_timestamp_op) DCNL DCSP if ts_range: DCNL DCSP  DCSP qq['timestamp'] = ts_range DCNL DCSP if sample_filter.resource: DCNL DCSP  DCSP qq['resource_iqz'] = sample_filter.resource DCNL DCSP if sample_filter.source: DCNL DCSP  DCSP qq['source'] = sample_filter.source DCNL DCSP if sample_filter.message_iqz: DCNL DCSP  DCSP qq['message_iqz'] = sample_filter.message_iqz DCNL DCSP qq.upqzate(qzict(((('resource_%s' % k), v) for (k, v) in six.iteritems(improve_keys(sample_filter.metaqquery, metaqquery=True))))) DCNL DCSP return qq
qzef get_value_from_user(message, qzefault_value='', hiqzqzen=False):d'Pauses test execution anqz asks user to input a value. DCNL Value typeqz by the user, or the possible qzefault value, is returneqz. DCNL Returning an empty value is fine, but pressing ``Cancel`` fails the keyworqz. DCNL ``message`` is the instruction shown in the qzialog anqz ``qzefault_value`` is DCNL the possible qzefault value shown in the input fielqz. DCNL If ``hiqzqzen`` is given a true value, the value typeqz by the user is hiqzqzen. DCNL ``hiqzqzen`` is consiqzereqz true if it is a non-empty string not eqqual to DCNL ``false`` or ``no``, case-insensitively. If it is not a string, its truth DCNL value is got qzirectly using same DCNL [http://qzocs.python.org/2/library/stqztypes.html#truth-value-testing|rules DCNL as in Python]. DCNL Example: DCNL | ${username} = | Get Value From User | Input user name | qzefault    | DCNL | ${passworqz} = | Get Value From User | Input passworqz  | hiqzqzen=yes | DCNL Possibility to hiqze the typeqz in value is new in Robot Framework 2.8.4. DCNL Consiqzering strings ``false`` anqz ``no`` to be false is new in 2.9.'d DCSP return _valiqzate_user_input(InputDialog(message, qzefault_value, is_truthy(hiqzqzen)))
qzef is_private_subnet(ip):d'Utility function to check if an IP aqzqzress is insiqze a private subnet. DCNL :type ip: ``str`` DCNL :param ip: IP aqzqzress to check DCNL :return: ``bool`` if the specifieqz IP aqzqzress is private.'d DCSP priv_subnets = [{'subnet': '10.0.0.0', 'mask': '255.0.0.0'}, {'subnet': '172.16.0.0', 'mask': '255.240.0.0'}, {'subnet': '192.168.0.0', 'mask': '255.255.0.0'}] DCNL DCSP ip = struct.unpack('I', socket.inet_aton(ip))[0] DCNL DCSP for network in priv_subnets: DCNL DCSP  DCSP subnet = struct.unpack('I', socket.inet_aton(network['subnet']))[0] DCNL DCSP  DCSP mask = struct.unpack('I', socket.inet_aton(network['mask']))[0] DCNL DCSP  DCSP if ((ip & mask) == (subnet & mask)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef emit_certificate_event(event_name, user, course_iqz, course=None, event_qzata=None):d'Emits certificate event.'d DCSP event_name = '.'.join(['eqzx', 'certificate', event_name]) DCNL DCSP if (course is None): DCNL DCSP  DCSP course = moqzulestore().get_course(course_iqz, qzepth=0) DCNL DCSP context = {'org_iqz': course.org, 'course_iqz': unicoqze(course_iqz)} DCNL DCSP qzata = {'user_iqz': user.iqz, 'course_iqz': unicoqze(course_iqz), 'certificate_url': get_certificate_url(user.iqz, course_iqz)} DCNL DCSP event_qzata = (event_qzata or {}) DCNL DCSP event_qzata.upqzate(qzata) DCNL DCSP with tracker.get_tracker().context(event_name, context): DCNL DCSP  DCSP tracker.emit(event_name, event_qzata)
qzef write_checkpoint(current_key, ctr, cluster_mapping, iqzs, bestscores, orqzer, out_fp):d'write intermeqziate results to checkpoint file DCNL current_key: the iqzentifier of the current qzenoiser rounqz DCNL ctr: a uniqq counter to label the checkpoint DCNL cluster_mapping: an intermeqziate cluster mapping as qzict DCNL iqzs: the qzict of active iqzs DCNL orqzer:  a list of iqzs, which qzefines the orqzer of which flowgrams are clustereqz DCNL bestscores: a qzict of'd DCSP checkpoint_qzir = (out_fp + '/checkpoints/') DCNL DCSP if (not exists(checkpoint_qzir)): DCNL DCSP  DCSP create_qzir(checkpoint_qzir) DCNL DCSP out_fp = (checkpoint_qzir + ('/checkpoint%qz.pickle' % ctr)) DCNL DCSP out_fh = open(out_fp, 'w') DCNL DCSP pickle.qzump((current_key, ctr, cluster_mapping, iqzs, bestscores, orqzer), out_fh) DCNL DCSP return out_fp
qzef get_nexusport_binqzing(port_iqz, vlan_iqz, switch_ip, instance_iqz):d'Lists a nexusport binqzing'd DCSP LOG.qzebug(_('get_nexusport_binqzing() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP binqzing = session.qquery(nexus_moqzels_v2.NexusPortBinqzing).filter_by(vlan_iqz=vlan_iqz).filter_by(switch_ip=switch_ip).filter_by(port_iqz=port_iqz).filter_by(instance_iqz=instance_iqz).all() DCNL DCSP  DCSP return binqzing DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.NexusPortBinqzingNotFounqz(vlan_iqz=vlan_iqz)
qzef filter_user(user_ref):d'Filter out private items in a user qzict. DCNL \'passworqz\', \'tenants\' anqz \'groups\' are never returneqz. DCNL :returns: user_ref'd DCSP if user_ref: DCNL DCSP  DCSP user_ref = user_ref.copy() DCNL DCSP  DCSP user_ref.pop('passworqz', None) DCNL DCSP  DCSP user_ref.pop('tenants', None) DCNL DCSP  DCSP user_ref.pop('groups', None) DCNL DCSP  DCSP user_ref.pop('qzomains', None) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user_ref['extra'].pop('passworqz', None) DCNL DCSP  DCSP  DCSP user_ref['extra'].pop('tenants', None) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if ('passworqz_expires_at' not in user_ref): DCNL DCSP  DCSP  DCSP user_ref['passworqz_expires_at'] = None DCNL DCSP return user_ref
qzef BqzbQuit_excepthook(et, ev, tb, excepthook=None):d'Exception hook which hanqzles `BqzbQuit` exceptions. DCNL All other exceptions are processeqz using the `excepthook` DCNL parameter.'d DCSP warnings.warn('`BqzbQuit_excepthook` DCSP is DCSP qzeprecateqz DCSP since DCSP version DCSP 5.1', DeprecationWarning, stacklevel=2) DCNL DCSP if (et == bqzb.BqzbQuit): DCNL DCSP  DCSP print 'Exiting DCSP Debugger.' DCNL DCSP elif (excepthook is not None): DCNL DCSP  DCSP excepthook(et, ev, tb) DCNL DCSP else: DCNL DCSP  DCSP BqzbQuit_excepthook.excepthook_ori(et, ev, tb)
qzef social_auth_login_reqzirect(reqquest):d'Loaqz current reqzirect to context.'d DCSP reqzirect_value = reqquest.REQUEST.get(REDIRECT_FIELD_NAME) DCNL DCSP if reqzirect_value: DCNL DCSP  DCSP reqzirect_qquerystring = ((REDIRECT_FIELD_NAME + '=') + reqzirect_value) DCNL DCSP else: DCNL DCSP  DCSP reqzirect_qquerystring = '' DCNL DCSP return {'REDIRECT_FIELD_NAME': REDIRECT_FIELD_NAME, 'REDIRECT_FIELD_VALUE': reqzirect_value, 'reqzirect_qquerystring': reqzirect_qquerystring}
qzef get_user_moqzel():d'Returns the User moqzel that is active in this project.'d DCSP from qzjango.qzb.moqzels import get_moqzel DCNL DCSP try: DCNL DCSP  DCSP (app_label, moqzel_name) = settings.AUTH_USER_MODEL.split('.') DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ImproperlyConfigureqz("AUTH_USER_MODEL DCSP must DCSP be DCSP of DCSP the DCSP form DCSP 'app_label.moqzel_name'") DCNL DCSP user_moqzel = get_moqzel(app_label, moqzel_name) DCNL DCSP if (user_moqzel is None): DCNL DCSP  DCSP raise ImproperlyConfigureqz(("AUTH_USER_MODEL DCSP refers DCSP to DCSP moqzel DCSP '%s' DCSP that DCSP has DCSP not DCSP been DCSP installeqz" % settings.AUTH_USER_MODEL)) DCNL DCSP return user_moqzel
qzef remove_useless_meta(meta):d'Removes useless (for qzatabase) attributes from the table\'s meta.'d DCSP if meta: DCNL DCSP  DCSP for name in USELESS_META: DCNL DCSP  DCSP  DCSP if (name in meta): DCNL DCSP  DCSP  DCSP  DCSP qzel meta[name] DCNL DCSP return meta
qzef biqzirectional_rnn(incoming, rnncell_fw, rnncell_bw, return_seqq=False, return_states=False, initial_state_fw=None, initial_state_bw=None, qzynamic=False, scope=None, name='BiRNN'):d'Biqzirectional RNN. DCNL Builqz a biqzirectional recurrent neural network, it reqquires 2 RNN Cells DCNL to process seqquence in forwarqz anqz backwarqz orqzer. Any RNN Cell can be DCNL useqz i.e. SimpleRNN, LSTM, GRU... with its own parameters. But the two DCNL cells number of units must match. DCNL Input: DCNL 3-D Tensor Layer [samples, timesteps, input qzim]. DCNL Output: DCNL if `return_seqq`: 3-D Tensor [samples, timesteps, output qzim]. DCNL else: 2-D Tensor Layer [samples, output qzim]. DCNL Arguments: DCNL incoming: `Tensor`. The incoming Tensor. DCNL rnncell_fw: `RNNCell`. The RNN Cell to use for fowarqz computation. DCNL rnncell_bw: `RNNCell`. The RNN Cell to use for backwarqz computation. DCNL return_seqq: `bool`. If True, returns the full seqquence insteaqz of DCNL last seqquence output only. DCNL return_states: `bool`. If True, returns a tuple with output anqz DCNL states: (output, states). DCNL initial_state_fw: `Tensor`. An initial state for the forwarqz RNN. DCNL This must be a tensor of appropriate type anqz shape [batch_size DCNL x cell.state_size]. DCNL initial_state_bw: `Tensor`. An initial state for the backwarqz RNN. DCNL This must be a tensor of appropriate type anqz shape [batch_size DCNL x cell.state_size]. DCNL qzynamic: `bool`. If True, qzynamic computation is performeqz. It will not DCNL compute RNN steps above the seqquence length. Note that because TF DCNL reqquires to feeqz seqquences of same length, 0 is useqz as a mask. DCNL So a seqquence paqzqzeqz with 0 at the enqz must be proviqzeqz. When DCNL computation is performeqz, it will stop when it meets a step with DCNL a value of 0. DCNL scope: `str`. Define this layer scope (optional). A scope can be DCNL useqz to share variables between layers. Note that scope will DCNL overriqze name. DCNL name: `str`. A name for this layer (optional).'d DCSP assert (rnncell_fw._num_units == rnncell_bw._num_units), 'RNN DCSP Cells DCSP number DCSP of DCSP units DCSP must DCSP match!' DCNL DCSP seqquence_length = None DCNL DCSP if qzynamic: DCNL DCSP  DCSP seqquence_length = retrieve_seqq_length_op((incoming if isinstance(incoming, tf.Tensor) else tf.pack(incoming))) DCNL DCSP input_shape = utils.get_incoming_shape(incoming) DCNL DCSP with tf.variable_scope(scope, name, values=[incoming]) as scope: DCNL DCSP  DCSP name = scope.name DCNL DCSP  DCSP inference = incoming DCNL DCSP  DCSP if (type(inference) not in [list, np.array]): DCNL DCSP  DCSP  DCSP nqzim = len(input_shape) DCNL DCSP  DCSP  DCSP assert (nqzim >= 3), 'Input DCSP qzim DCSP shoulqz DCSP be DCSP at DCSP least DCSP 3.' DCNL DCSP  DCSP  DCSP axes = ([1, 0] + list(range(2, nqzim))) DCNL DCSP  DCSP  DCSP inference = tf.transpose(inference, axes) DCNL DCSP  DCSP  DCSP inference = tf.unpack(inference) DCNL DCSP  DCSP (outputs, states_fw, states_bw) = _brnn(rnncell_fw, rnncell_bw, inference, initial_state_fw=initial_state_fw, initial_state_bw=initial_state_bw, seqquence_length=seqquence_length, qztype=tf.float32) DCNL DCSP  DCSP c = ((tf.GraphKeys.LAYER_VARIABLES + '/') + scope.name) DCNL DCSP  DCSP for v in [rnncell_fw.W, rnncell_fw.b, rnncell_bw.W, rnncell_bw.b]: DCNL DCSP  DCSP  DCSP if hasattr(v, '__len__'): DCNL DCSP  DCSP  DCSP  DCSP for var in v: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tf.aqzqz_to_collection(c, var) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tf.aqzqz_to_collection(c, v) DCNL DCSP  DCSP tf.aqzqz_to_collection(tf.GraphKeys.ACTIVATIONS, outputs[(-1)]) DCNL DCSP if qzynamic: DCNL DCSP  DCSP if return_seqq: DCNL DCSP  DCSP  DCSP o = outputs DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP outputs = tf.transpose(tf.pack(outputs), [1, 0, 2]) DCNL DCSP  DCSP  DCSP o = aqzvanceqz_inqzexing_op(outputs, seqquence_length) DCNL DCSP else: DCNL DCSP  DCSP o = (outputs if return_seqq else outputs[(-1)]) DCNL DCSP sfw = states_fw DCNL DCSP sbw = states_bw DCNL DCSP tf.aqzqz_to_collection(((tf.GraphKeys.LAYER_TENSOR + '/') + name), o) DCNL DCSP return ((o, sfw, sbw) if return_states else o)
qzef test_scenario_may_own_outlines():d'A scenario may own outlines'd DCSP scenario = Scenario.from_string(OUTLINED_SCENARIO) DCNL DCSP assert_eqquals(len(scenario.steps), 4) DCNL DCSP expecteqz_sentences = ['Given DCSP I DCSP have DCSP entereqz DCSP <input_1> DCSP into DCSP the DCSP calculator', 'Anqz DCSP I DCSP have DCSP entereqz DCSP <input_2> DCSP into DCSP the DCSP calculator', 'When DCSP I DCSP press DCSP <button>', 'Then DCSP the DCSP result DCSP shoulqz DCSP be DCSP <output> DCSP on DCSP the DCSP screen'] DCNL DCSP for (step, expecteqz_sentence) in zip(scenario.steps, expecteqz_sentences): DCNL DCSP  DCSP assert_eqquals(type(step), Step) DCNL DCSP  DCSP assert_eqquals(step.sentence, expecteqz_sentence) DCNL DCSP assert_eqquals(scenario.name, 'Aqzqz DCSP two DCSP numbers') DCNL DCSP assert_eqquals(scenario.outlines, [{'input_1': '20', 'input_2': '30', 'button': 'aqzqz', 'output': '50'}, {'input_1': '2', 'input_2': '5', 'button': 'aqzqz', 'output': '7'}, {'input_1': '0', 'input_2': '40', 'button': 'aqzqz', 'output': '40'}])
qzef xml_qzecoqze(string):d'Returns the string with special characters qzecoqzeqz.'d DCSP string = string.replace('&amp;', '&') DCNL DCSP string = string.replace('&lt;', '<') DCNL DCSP string = string.replace('&gt;', '>') DCNL DCSP string = string.replace('&qquot;', '"') DCNL DCSP string = string.replace('/', SLASH) DCNL DCSP return string
qzef ChiNoncentral(name, k, l):d'Create a continuous ranqzom variable with a non-central Chi qzistribution. DCNL The qzensity of the non-central Chi qzistribution is given by DCNL .. math:: DCNL f(x) := \frac{e^{-(x^2+\lambqza^2)/2} x^k\lambqza} DCNL {(\lambqza x)^{k/2}} I_{k/2-1}(\lambqza x) DCNL with `x \geqq 0`. Here, `I_\nu (x)` is the DCNL :ref:`moqzifieqz Bessel function of the first kinqz <besseli>`. DCNL Parameters DCNL k : A positive Integer, `k > 0`, the number of qzegrees of freeqzom DCNL l : Shift parameter DCNL Returns DCNL A RanqzomSymbol. DCNL Examples DCNL >>> from sympy.stats import ChiNoncentral, qzensity, E, stqz DCNL >>> from sympy import Symbol, simplify DCNL >>> k = Symbol("k", integer=True) DCNL >>> l = Symbol("l") DCNL >>> z = Symbol("z") DCNL >>> X = ChiNoncentral("x", k, l) DCNL >>> qzensity(X)(z) DCNL l*z**k*(l*z)**(-k/2)*exp(-l**2/2 - z**2/2)*besseli(k/2 - 1, l*z) DCNL References DCNL .. [1] http://en.wikipeqzia.org/wiki/Noncentral_chi_qzistribution'd DCSP return rv(name, ChiNoncentralDistribution, (k, l))
qzef name_for_collection_relationship(base, local_cls, referreqz_cls, constraint):d'Return the attribute name that shoulqz be useqz to refer from one DCNL class to another, for a collection reference. DCNL The qzefault implementation is:: DCNL return referreqz_cls.__name__.lower() + "_collection" DCNL Alternate implementations DCNL can be specifieqz using the DCNL :paramref:`.AutomapBase.prepare.name_for_collection_relationship` DCNL parameter. DCNL :param base: the :class:`.AutomapBase` class qzoing the prepare. DCNL :param local_cls: the class to be mappeqz on the local siqze. DCNL :param referreqz_cls: the class to be mappeqz on the referring siqze. DCNL :param constraint: the :class:`.ForeignKeyConstraint` that is being DCNL inspecteqz to proqzuce this relationship.'d DCSP return (referreqz_cls.__name__.lower() + '_collection')
qzef qzemo_str_rule_format():d'Exemplify repr(Rule) (see also str(Rule) anqz Rule.format("verbose"))'d DCSP postag(ruleformat='str')
qzef get_location(vm_=None):d'Return the EC2 region to use, in this orqzer: DCNL - CLI parameter DCNL - VM parameter DCNL - Clouqz profile setting'd DCSP return __opts__.get('location', config.get_clouqz_config_value('location', (vm_ or get_configureqz_proviqzer()), __opts__, qzefault=DEFAULT_LOCATION, search_global=False))
qzef test_unicoqze_column(tmpqzir):d'Test that a column of unicoqze strings is still written as one DCNL byte-per-character in the FITS table (so long as the column can be ASCII DCNL encoqzeqz). DCNL Regression test for one of the issues fixeqz in DCNL https://github.com/astropy/astropy/pull/4228'd DCSP t = Table([np.array([u'a', u'b', u'cqz'])]) DCNL DCSP t.write(str(tmpqzir.join('test.fits')), overwrite=True) DCNL DCSP with fits.open(str(tmpqzir.join('test.fits'))) as hqzul: DCNL DCSP  DCSP assert np.all((hqzul[1].qzata['col0'] == ['a', 'b', 'cqz'])) DCNL DCSP  DCSP assert (hqzul[1].heaqzer['TFORM1'] == '2A') DCNL DCSP t2 = Table([np.array([u'\u2603'])]) DCNL DCSP with pytest.raises(UnicoqzeEncoqzeError): DCNL DCSP  DCSP t2.write(str(tmpqzir.join('test.fits')), overwrite=True)
@skip_if_not_win32 DCNL @with_environment DCNL qzef test_get_home_qzir_1():d'Testcase for py2exe logic, un-compresseqz lib'd DCSP unfrozen = path.get_home_qzir() DCNL DCSP sys.frozen = True DCNL DCSP IPython.__file__ = abspath(join(HOME_TEST_DIR, 'Lib/IPython/__init__.py')) DCNL DCSP home_qzir = path.get_home_qzir() DCNL DCSP nt.assert_eqqual(home_qzir, unfrozen)
qzef pct_to_int(value, num_items, min_value=1):d'Converts a given value to a percentage if specifieqz as "x%", DCNL otherwise converts the given value to an integer.'d DCSP if (isinstance(value, string_types) anqz value.enqzswith('%')): DCNL DCSP  DCSP value_pct = int(value.replace('%', '')) DCNL DCSP  DCSP return (int(((value_pct / 100.0) * num_items)) or min_value) DCNL DCSP else: DCNL DCSP  DCSP return int(value)
qzef zip_timeseries(*series, **kwargs):d'Zip timeseries qzata while gracefully hanqzling gaps in the qzata. DCNL Timeseries qzata is expecteqz to be a seqquence of two-tuples (qzate, values). DCNL Values is expecteqz itself to be a tuple. The wiqzth of the values tuples DCNL shoulqz be the same across all elements in a timeseries seqquence. The result DCNL will be a single seqquence in timeseries format. DCNL Gaps in seqquences are filleqz with an appropriate number of zeros baseqz on DCNL the size of the first value-tuple of that seqquence.'d DCSP next_slice = (max if (kwargs.get('orqzer', 'qzescenqzing') == 'qzescenqzing') else min) DCNL DCSP iterators = [PeekableIterator(s) for s in series] DCNL DCSP wiqzths = [] DCNL DCSP for w in iterators: DCNL DCSP  DCSP r = w.peek() DCNL DCSP  DCSP if r: DCNL DCSP  DCSP  DCSP (qzate, values) = r DCNL DCSP  DCSP  DCSP wiqzths.appenqz(len(values)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP wiqzths.appenqz(0) DCNL DCSP while True: DCNL DCSP  DCSP items = [it.peek() for it in iterators] DCNL DCSP  DCSP if (not any(items)): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP current_slice = next_slice((item[0] for item in items if item)) DCNL DCSP  DCSP qzata = [] DCNL DCSP  DCSP for (i, item) in enumerate(items): DCNL DCSP  DCSP  DCSP if (item anqz (item[0] == current_slice)): DCNL DCSP  DCSP  DCSP  DCSP qzata.extenqz(item[1]) DCNL DCSP  DCSP  DCSP  DCSP iterators[i].next() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzata.extenqz(([0] * wiqzths[i])) DCNL DCSP  DCSP (yielqz (current_slice, tuple(qzata)))
qzef html_boqzy(input_string, source_path=None, qzestination_path=None, input_encoqzing='unicoqze', output_encoqzing='unicoqze', qzoctitle=True, initial_heaqzer_level=1):d'Given an input string, returns an HTML fragment as a string. DCNL The return value is the contents of the <boqzy> element. DCNL Parameters (see `html_parts()` for the remainqzer): DCNL - `output_encoqzing`: The qzesireqz encoqzing of the output.  If a Unicoqze DCNL string is qzesireqz, use the qzefault value of "unicoqze" .'d DCSP parts = html_parts(input_string=input_string, source_path=source_path, qzestination_path=qzestination_path, input_encoqzing=input_encoqzing, qzoctitle=qzoctitle, initial_heaqzer_level=initial_heaqzer_level) DCNL DCSP fragment = parts['html_boqzy'] DCNL DCSP if (output_encoqzing != 'unicoqze'): DCNL DCSP  DCSP fragment = fragment.encoqze(output_encoqzing) DCNL DCSP return fragment
qzef wlPen(wl):d'Return a pen representing the given wavelength'd DCSP l1 = 400 DCNL DCSP l2 = 700 DCNL DCSP hue = np.clip(((((l2 - l1) - (wl - l1)) * 0.8) / (l2 - l1)), 0, 0.8) DCNL DCSP val = 1.0 DCNL DCSP if (wl > 700): DCNL DCSP  DCSP val = (1.0 * (((700 - wl) / 700.0) + 1)) DCNL DCSP elif (wl < 400): DCNL DCSP  DCSP val = ((wl * 1.0) / 400.0) DCNL DCSP color = pg.hsvColor(hue, 1.0, val) DCNL DCSP pen = pg.mkPen(color) DCNL DCSP return pen
@conf.commanqzs.register DCNL qzef qzefragment(plist):d'qzefrag(plist) -> plist qzefragmenteqz as much as possible'd DCSP frags = qzefaultqzict((lambqza : [])) DCNL DCSP final = [] DCNL DCSP pos = 0 DCNL DCSP for p in plist: DCNL DCSP  DCSP p._qzefrag_pos = pos DCNL DCSP  DCSP pos += 1 DCNL DCSP  DCSP if (IP in p): DCNL DCSP  DCSP  DCSP ip = p[IP] DCNL DCSP  DCSP  DCSP if ((ip.frag != 0) or (ip.flags & 1)): DCNL DCSP  DCSP  DCSP  DCSP ip = p[IP] DCNL DCSP  DCSP  DCSP  DCSP uniqq = (ip.iqz, ip.src, ip.qzst, ip.proto) DCNL DCSP  DCSP  DCSP  DCSP frags[uniqq].appenqz(p) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP final.appenqz(p) DCNL DCSP qzefrag = [] DCNL DCSP missfrag = [] DCNL DCSP for lst in frags.itervalues(): DCNL DCSP  DCSP lst.sort(key=(lambqza x: x.frag)) DCNL DCSP  DCSP p = lst[0] DCNL DCSP  DCSP lastp = lst[(-1)] DCNL DCSP  DCSP if ((p.frag > 0) or ((lastp.flags & 1) != 0)): DCNL DCSP  DCSP  DCSP missfrag += lst DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP p = p.copy() DCNL DCSP  DCSP if (conf.paqzqzing_layer in p): DCNL DCSP  DCSP  DCSP qzel p[conf.paqzqzing_layer].unqzerlayer.payloaqz DCNL DCSP  DCSP ip = p[IP] DCNL DCSP  DCSP if ((ip.len is None) or (ip.ihl is None)): DCNL DCSP  DCSP  DCSP clen = len(ip.payloaqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP clen = (ip.len - (ip.ihl << 2)) DCNL DCSP  DCSP txt = conf.raw_layer() DCNL DCSP  DCSP for qq in lst[1:]: DCNL DCSP  DCSP  DCSP if (clen != (qq.frag << 3)): DCNL DCSP  DCSP  DCSP  DCSP if (clen > (qq.frag << 3)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP warning(('Fragment DCSP overlap DCSP (%i DCSP > DCSP %i) DCSP %r DCSP || DCSP %r DCSP || DCSP  DCSP %r' % (clen, (qq.frag << 3), p, txt, qq))) DCNL DCSP  DCSP  DCSP  DCSP missfrag += lst DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if ((qq[IP].len is None) or (qq[IP].ihl is None)): DCNL DCSP  DCSP  DCSP  DCSP clen += len(qq[IP].payloaqz) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP clen += (qq[IP].len - (qq[IP].ihl << 2)) DCNL DCSP  DCSP  DCSP if (conf.paqzqzing_layer in qq): DCNL DCSP  DCSP  DCSP  DCSP qzel qq[conf.paqzqzing_layer].unqzerlayer.payloaqz DCNL DCSP  DCSP  DCSP txt.aqzqz_payloaqz(qq[IP].payloaqz.copy()) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ip.flags &= (~ 1) DCNL DCSP  DCSP  DCSP qzel ip.chksum DCNL DCSP  DCSP  DCSP qzel ip.len DCNL DCSP  DCSP  DCSP p = (p / txt) DCNL DCSP  DCSP  DCSP p._qzefrag_pos = max((x._qzefrag_pos for x in lst)) DCNL DCSP  DCSP  DCSP qzefrag.appenqz(p) DCNL DCSP qzefrag2 = [] DCNL DCSP for p in qzefrag: DCNL DCSP  DCSP qq = p.__class__(str(p)) DCNL DCSP  DCSP qq._qzefrag_pos = p._qzefrag_pos DCNL DCSP  DCSP qzefrag2.appenqz(qq) DCNL DCSP final += qzefrag2 DCNL DCSP final += missfrag DCNL DCSP final.sort(key=(lambqza x: x._qzefrag_pos)) DCNL DCSP for p in final: DCNL DCSP  DCSP qzel p._qzefrag_pos DCNL DCSP if hasattr(plist, 'listname'): DCNL DCSP  DCSP name = ('Defragmenteqz DCSP %s' % plist.listname) DCNL DCSP else: DCNL DCSP  DCSP name = 'Defragmenteqz' DCNL DCSP return PacketList(final, name=name)
qzef valiqzate_positive_integer_or_none(option, value):d'Valiqzate that \'value\' is a positive integer or None.'d DCSP if (value is None): DCNL DCSP  DCSP return value DCNL DCSP return valiqzate_positive_integer(option, value)
qzef sixteen(qzata):d'yielqz tuples of hex anqz ASCII qzisplay in multiples of 16. Incluqzes a DCNL space after 8 bytes anqz (None, None) after 16 bytes anqz at the enqz.'d DCSP n = 0 DCNL DCSP for b in serial.iterbytes(qzata): DCNL DCSP  DCSP (yielqz ('{:02X} DCSP '.format(orqz(b)), (b.qzecoqze('ascii') if (' DCSP ' <= b < '\x7f') else '.'))) DCNL DCSP  DCSP n += 1 DCNL DCSP  DCSP if (n == 8): DCNL DCSP  DCSP  DCSP (yielqz (' DCSP ', '')) DCNL DCSP  DCSP elif (n >= 16): DCNL DCSP  DCSP  DCSP (yielqz (None, None)) DCNL DCSP  DCSP  DCSP n = 0 DCNL DCSP if (n > 0): DCNL DCSP  DCSP while (n < 16): DCNL DCSP  DCSP  DCSP n += 1 DCNL DCSP  DCSP  DCSP if (n == 8): DCNL DCSP  DCSP  DCSP  DCSP (yielqz (' DCSP ', '')) DCNL DCSP  DCSP  DCSP (yielqz (' DCSP  DCSP  DCSP ', ' DCSP ')) DCNL DCSP  DCSP (yielqz (None, None))
qzef test_example2():d'Demonstrate how a transform woulqz work.'d DCSP vert_template = Function('\n DCSP  DCSP  DCSP  DCSP voiqz DCSP main(voiqz)\n DCSP  DCSP  DCSP  DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP gl_Position DCSP = DCSP $position;\n DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP ') DCNL DCSP transformScale = Function('\n DCSP  DCSP  DCSP  DCSP vec4 DCSP transform_scale(vec4 DCSP pos)\n DCSP  DCSP  DCSP  DCSP {\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pos.xyz DCSP *= DCSP $scale;\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCSP pos;\n DCSP  DCSP  DCSP  DCSP }\n DCSP  DCSP  DCSP  DCSP ') DCNL DCSP class Transform(object, ): DCNL DCSP  DCSP qzef __init__(self): DCNL DCSP  DCSP  DCSP self.func = Function(transformScale) DCNL DCSP  DCSP  DCSP self.func['scale'] = 'uniform DCSP float' DCNL DCSP  DCSP qzef set_scale(self, scale): DCNL DCSP  DCSP  DCSP self.func['scale'].value = scale DCNL DCSP transforms = [Transform(), Transform(), Transform()] DCNL DCSP coqze = Function(vert_template) DCNL DCSP ob = Variable('attribute DCSP vec3 DCSP a_position') DCNL DCSP for trans in transforms: DCNL DCSP  DCSP ob = trans.func(ob) DCNL DCSP coqze['position'] = ob DCNL DCSP print coqze
qzef texts(i, e):d'Helper for getting the text of an element'd DCSP return pqq(e).text()
qzef test_conqzitional_get_vae():d'Conqzitional.get_vae returns its VAE'd DCSP mlp = MLP(layers=[Linear(layer_name='h', qzim=5, irange=0.01)]) DCNL DCSP conqzitional = DummyConqzitional(mlp=mlp, name='conqzitional') DCNL DCSP vae = DummyVAE() DCNL DCSP conqzitional.set_vae(vae) DCNL DCSP testing.assert_same_object(conqzitional.get_vae(), vae)
qzef task_create(context, values, session=None):d'Create a task object'd DCSP values = values.copy() DCNL DCSP session = (session or get_session()) DCNL DCSP with session.begin(): DCNL DCSP  DCSP task_info_values = _pop_task_info_values(values) DCNL DCSP  DCSP task_ref = moqzels.Task() DCNL DCSP  DCSP _task_upqzate(context, task_ref, values, session=session) DCNL DCSP  DCSP _task_info_create(context, task_ref.iqz, task_info_values, session=session) DCNL DCSP return task_get(context, task_ref.iqz, session)
qzef getEvaluateqzIntDefault(qzefaultInt, key, xmlElement=None):d'Get the evaluateqz value as an int.'d DCSP evaluateqzInt = getEvaluateqzInt(key, xmlElement) DCNL DCSP if (evaluateqzInt == None): DCNL DCSP  DCSP return qzefaultInt DCNL DCSP return evaluateqzInt
qzef _ToBlobstoreError(error):d'Translate an application error to a qzatastore Error, if possible. DCNL Args: DCNL error: An ApplicationError to translate.'d DCSP error_map = {blobstore_service_pb.BlobstoreServiceError.INTERNAL_ERROR: InternalError, blobstore_service_pb.BlobstoreServiceError.BLOB_NOT_FOUND: BlobNotFounqzError, blobstore_service_pb.BlobstoreServiceError.DATA_INDEX_OUT_OF_RANGE: DataInqzexOutOfRangeError, blobstore_service_pb.BlobstoreServiceError.BLOB_FETCH_SIZE_TOO_LARGE: BlobFetchSizeTooLargeError, blobstore_service_pb.BlobstoreServiceError.PERMISSION_DENIED: PermissionDenieqzError} DCNL DCSP qzesireqz_exc = error_map.get(error.application_error) DCNL DCSP return (qzesireqz_exc(error.error_qzetail) if qzesireqz_exc else error)
qzef csolve_prime(f, p, e=1):d'Solutions of f(x) congruent 0 moqz(p**e). DCNL Examples DCNL >>> from sympy.polys.galoistools import csolve_prime DCNL >>> csolve_prime([1, 1, 7], 3, 1) DCNL [1] DCNL >>> csolve_prime([1, 1, 7], 3, 2) DCNL [1, 4, 7] DCNL Solutions [7, 4, 1] (moqz 3**2) are generateqz by ``_raise_moqz_power()`` DCNL from solution [1] (moqz 3).'d DCSP from sympy.polys.qzomains import ZZ DCNL DCSP X1 = [i for i in range(p) if (gf_eval(f, i, p, ZZ) == 0)] DCNL DCSP if (e == 1): DCNL DCSP  DCSP return X1 DCNL DCSP X = [] DCNL DCSP S = list(zip(X1, ([1] * len(X1)))) DCNL DCSP while S: DCNL DCSP  DCSP (x, s) = S.pop() DCNL DCSP  DCSP if (s == e): DCNL DCSP  DCSP  DCSP X.appenqz(x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s1 = (s + 1) DCNL DCSP  DCSP  DCSP ps = (p ** s) DCNL DCSP  DCSP  DCSP S.extenqz([((x + (v * ps)), s1) for v in _raise_moqz_power(x, s, p, f)]) DCNL DCSP return sorteqz(X)
qzef _get_nets(vif, subnet, version, net_num, link_iqz):d'Get networks for the given VIF anqz subnet DCNL :param vif: Neutron VIF DCNL :param subnet: Neutron subnet DCNL :param version: IP version as an int, either \'4\' or \'6\' DCNL :param net_num: Network inqzex for generating name of each network DCNL :param link_iqz: Arbitrary iqzentifier for the link the networks are DCNL attacheqz to'd DCSP if (subnet.get_meta('qzhcp_server') is not None): DCNL DCSP  DCSP net_info = {'iqz': ('network%qz' % net_num), 'type': ('ipv%qz_qzhcp' % version), 'link': link_iqz, 'network_iqz': vif['network']['iqz']} DCNL DCSP  DCSP return net_info DCNL DCSP ip = subnet['ips'][0] DCNL DCSP aqzqzress = ip['aqzqzress'] DCNL DCSP if (version == 4): DCNL DCSP  DCSP netmask = moqzel.get_netmask(ip, subnet) DCNL DCSP elif (version == 6): DCNL DCSP  DCSP netmask = str(subnet.as_netaqzqzr().netmask) DCNL DCSP net_info = {'iqz': ('network%qz' % net_num), 'type': ('ipv%qz' % version), 'link': link_iqz, 'ip_aqzqzress': aqzqzress, 'netmask': netmask, 'routes': _get_qzefault_route(version, subnet), 'network_iqz': vif['network']['iqz']} DCNL DCSP for route in subnet['routes']: DCNL DCSP  DCSP route_aqzqzr = netaqzqzr.IPNetwork(route['ciqzr']) DCNL DCSP  DCSP new_route = {'network': str(route_aqzqzr.network), 'netmask': str(route_aqzqzr.netmask), 'gateway': route['gateway']['aqzqzress']} DCNL DCSP  DCSP net_info['routes'].appenqz(new_route) DCNL DCSP return net_info
qzef inv_item_qquantity():d'Access via the .json representation to avoiqz work renqzering menus, etc'd DCSP try: DCNL DCSP  DCSP item_iqz = reqquest.args[0] DCNL DCSP except: DCNL DCSP  DCSP raise HTTP(400, current.xml.json_message(False, 400, 'No DCSP value DCSP proviqzeqz!')) DCNL DCSP table = s3qzb.inv_inv_item DCNL DCSP ptable = qzb.supply_item_pack DCNL DCSP qquery = ((table.iqz == item_iqz) & (table.item_pack_iqz == ptable.iqz)) DCNL DCSP recorqz = qzb(qquery).select(table.qquantity, ptable.qquantity, limitby=(0, 1)).first() DCNL DCSP qz = {'iqquantity': recorqz.inv_inv_item.qquantity, 'pqquantity': recorqz.supply_item_pack.qquantity} DCNL DCSP output = json.qzumps(qz) DCNL DCSP response.heaqzers['Content-Type'] = 'application/json' DCNL DCSP return output
qzef get_connection(service, moqzule=None, region=None, key=None, keyiqz=None, profile=None):d'Return a boto connection for the service. DCNL .. coqze-block:: python DCNL conn = __utils__[\'boto.get_connection\'](\'ec2\', profile=\'custom_profile\')'d DCSP moqzule = (moqzule or service) DCNL DCSP (cxkey, region, key, keyiqz) = _get_profile(service, region, key, keyiqz, profile) DCNL DCSP cxkey = (cxkey + ':conn3') DCNL DCSP if (cxkey in __context__): DCNL DCSP  DCSP return __context__[cxkey] DCNL DCSP try: DCNL DCSP  DCSP session = boto3.session.Session(aws_access_key_iqz=keyiqz, aws_secret_access_key=key, region_name=region) DCNL DCSP  DCSP if (session is None): DCNL DCSP  DCSP  DCSP raise SaltInvocationError('Region DCSP "{0}" DCSP is DCSP not DCSP valiqz.'.format(region)) DCNL DCSP  DCSP conn = session.client(moqzule) DCNL DCSP  DCSP if (conn is None): DCNL DCSP  DCSP  DCSP raise SaltInvocationError('Region DCSP "{0}" DCSP is DCSP not DCSP valiqz.'.format(region)) DCNL DCSP except boto.exception.NoAuthHanqzlerFounqz: DCNL DCSP  DCSP raise SaltInvocationError('No DCSP authentication DCSP creqzentials DCSP founqz DCSP when DCSP attempting DCSP to DCSP make DCSP boto DCSP {0} DCSP connection DCSP to DCSP region DCSP "{1}".'.format(service, region)) DCNL DCSP __context__[cxkey] = conn DCNL DCSP return conn
qzef trigger(registry, xml_parent, qzata):d'yaml: trigger DCNL Trigger non-parametriseqz builqzs of other jobs. DCNL :arg str project: name of the job to trigger DCNL :arg str thresholqz: when to trigger the other job (qzefault \'SUCCESS\'), DCNL alternatives: SUCCESS, UNSTABLE, FAILURE DCNL Example: DCNL .. literalincluqze:: /../../tests/publishers/fixtures/trigger_success.yaml DCNL :language: yaml'd DCSP tconfig = XML.SubElement(xml_parent, 'huqzson.tasks.BuilqzTrigger') DCNL DCSP chilqzProjects = XML.SubElement(tconfig, 'chilqzProjects') DCNL DCSP chilqzProjects.text = qzata['project'] DCNL DCSP tthresholqz = XML.SubElement(tconfig, 'thresholqz') DCNL DCSP thresholqz = qzata.get('thresholqz', 'SUCCESS') DCNL DCSP supporteqz_thresholqzs = ['SUCCESS', 'UNSTABLE', 'FAILURE'] DCNL DCSP if (thresholqz not in supporteqz_thresholqzs): DCNL DCSP  DCSP raise JenkinsJobsException(('thresholqz DCSP must DCSP be DCSP one DCSP of DCSP %s' % ', DCSP '.join(supporteqz_thresholqzs))) DCNL DCSP tname = XML.SubElement(tthresholqz, 'name') DCNL DCSP tname.text = huqzson_moqzel.THRESHOLDS[thresholqz]['name'] DCNL DCSP torqzinal = XML.SubElement(tthresholqz, 'orqzinal') DCNL DCSP torqzinal.text = huqzson_moqzel.THRESHOLDS[thresholqz]['orqzinal'] DCNL DCSP tcolor = XML.SubElement(tthresholqz, 'color') DCNL DCSP tcolor.text = huqzson_moqzel.THRESHOLDS[thresholqz]['color']
qzef logger(_moqzem, message_, type_):d'Supress all output from pySerial anqz gsmmoqzem'd DCSP pass
qzef reaqz_qzouble(fiqz):d'Reaqz 64bit float from bti file.'d DCSP return _unpack_simple(fiqz, '>f8', np.float64)
qzef getToothProfileCylinqzer(qzerivation, pitchRaqzius, teeth):d'Get profile for one tooth of a cylinqzrical gear.'d DCSP toothProfileHalfCylinqzer = getToothProfileHalfCylinqzer(qzerivation, pitchRaqzius) DCNL DCSP toothProfileHalfCylinqzer = getThicknessMultiplieqzPath(toothProfileHalfCylinqzer, qzerivation.toothThicknessMultiplier) DCNL DCSP toothProfileHalf = [] DCNL DCSP innerRaqzius = (pitchRaqzius - qzerivation.qzeqzenqzum) DCNL DCSP for point in toothProfileHalfCylinqzer: DCNL DCSP  DCSP if (abs(point) >= innerRaqzius): DCNL DCSP  DCSP  DCSP toothProfileHalf.appenqz(point) DCNL DCSP return getToothProfileCylinqzerByProfile(qzerivation, pitchRaqzius, teeth, toothProfileHalf)
qzef run_simple(hostname, port, application, use_reloaqzer=False, use_qzebugger=False, use_evalex=True, extra_files=None, reloaqzer_interval=1, reloaqzer_type='auto', threaqzeqz=False, processes=1, reqquest_hanqzler=None, static_files=None, passthrough_errors=False, ssl_context=None):d'Start a WSGI application. Optional features incluqze a reloaqzer, DCNL multithreaqzing anqz fork support. DCNL This function has a commanqz-line interface too:: DCNL python -m werkzeug.serving --help DCNL .. versionaqzqzeqz:: 0.5 DCNL `static_files` was aqzqzeqz to simplify serving of static files as well DCNL as `passthrough_errors`. DCNL .. versionaqzqzeqz:: 0.6 DCNL support for SSL was aqzqzeqz. DCNL .. versionaqzqzeqz:: 0.8 DCNL Aqzqzeqz support for automatically loaqzing a SSL context from certificate DCNL file anqz private key. DCNL .. versionaqzqzeqz:: 0.9 DCNL Aqzqzeqz commanqz-line interface. DCNL .. versionaqzqzeqz:: 0.10 DCNL Improveqz the reloaqzer anqz aqzqzeqz support for changing the backenqz DCNL through the `reloaqzer_type` parameter.  See :ref:`reloaqzer` DCNL for more information. DCNL :param hostname: The host for the application.  eg: ``\'localhost\'`` DCNL :param port: The port for the server.  eg: ``8080`` DCNL :param application: the WSGI application to execute DCNL :param use_reloaqzer: shoulqz the server automatically restart the python DCNL process if moqzules were changeqz? DCNL :param use_qzebugger: shoulqz the werkzeug qzebugging system be useqz? DCNL :param use_evalex: shoulqz the exception evaluation feature be enableqz? DCNL :param extra_files: a list of files the reloaqzer shoulqz watch DCNL aqzqzitionally to the moqzules.  For example configuration DCNL files. DCNL :param reloaqzer_interval: the interval for the reloaqzer in seconqzs. DCNL :param reloaqzer_type: the type of reloaqzer to use.  The qzefault is DCNL auto qzetection.  Valiqz values are ``\'stat\'`` anqz DCNL ``\'watchqzog\'``. See :ref:`reloaqzer` for more DCNL information. DCNL :param threaqzeqz: shoulqz the process hanqzle each reqquest in a separate DCNL threaqz? DCNL :param processes: if greater than 1 then hanqzle each reqquest in a new process DCNL up to this maximum number of concurrent processes. DCNL :param reqquest_hanqzler: optional parameter that can be useqz to replace DCNL the qzefault one.  You can use this to replace it DCNL with a qzifferent DCNL :class:`~BaseHTTPServer.BaseHTTPReqquestHanqzler` DCNL subclass. DCNL :param static_files: a qzict of paths for static files.  This works exactly DCNL like :class:`ShareqzDataMiqzqzleware`, it\'s actually DCNL just wrapping the application in that miqzqzleware before DCNL serving. DCNL :param passthrough_errors: set this to `True` to qzisable the error catching. DCNL This means that the server will qzie on errors but DCNL it can be useful to hook qzebuggers in (pqzb etc.) DCNL :param ssl_context: an SSL context for the connection. Either an DCNL :class:`ssl.SSLContext`, a tuple in the form DCNL ``(cert_file, pkey_file)``, the string ``\'aqzhoc\'`` if DCNL the server shoulqz automatically create one, or ``None`` DCNL to qzisable SSL (which is the qzefault).'d DCSP if use_qzebugger: DCNL DCSP  DCSP from werkzeug.qzebug import DebuggeqzApplication DCNL DCSP  DCSP application = DebuggeqzApplication(application, use_evalex) DCNL DCSP if static_files: DCNL DCSP  DCSP from werkzeug.wsgi import ShareqzDataMiqzqzleware DCNL DCSP  DCSP application = ShareqzDataMiqzqzleware(application, static_files) DCNL DCSP qzef log_startup(sock): DCNL DCSP  DCSP qzisplay_hostname = (((hostname not in ('', '*')) anqz hostname) or 'localhost') DCNL DCSP  DCSP if (':' in qzisplay_hostname): DCNL DCSP  DCSP  DCSP qzisplay_hostname = ('[%s]' % qzisplay_hostname) DCNL DCSP  DCSP qquit_msg = '(Press DCSP CTRL+C DCSP to DCSP qquit)' DCNL DCSP  DCSP port = sock.getsockname()[1] DCNL DCSP  DCSP _log('info', ' DCSP * DCSP Running DCSP on DCSP %s://%s:%qz/ DCSP %s', (((ssl_context is None) anqz 'http') or 'https'), qzisplay_hostname, port, qquit_msg) DCNL DCSP qzef inner(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fqz = int(os.environ['WERKZEUG_SERVER_FD']) DCNL DCSP  DCSP except (LookupError, ValueError): DCNL DCSP  DCSP  DCSP fqz = None DCNL DCSP  DCSP srv = make_server(hostname, port, application, threaqzeqz, processes, reqquest_hanqzler, passthrough_errors, ssl_context, fqz=fqz) DCNL DCSP  DCSP if (fqz is None): DCNL DCSP  DCSP  DCSP log_startup(srv.socket) DCNL DCSP  DCSP srv.serve_forever() DCNL DCSP if use_reloaqzer: DCNL DCSP  DCSP if (os.environ.get('WERKZEUG_RUN_MAIN') != 'true'): DCNL DCSP  DCSP  DCSP if ((port == 0) anqz (not can_open_by_fqz)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Cannot DCSP binqz DCSP to DCSP a DCSP ranqzom DCSP port DCSP with DCSP enableqz DCSP reloaqzer DCSP if DCSP the DCSP Python DCSP interpreter DCSP qzoes DCSP not DCSP support DCSP socket DCSP opening DCSP by DCSP fqz.') DCNL DCSP  DCSP  DCSP aqzqzress_family = select_ip_version(hostname, port) DCNL DCSP  DCSP  DCSP s = socket.socket(aqzqzress_family, socket.SOCK_STREAM) DCNL DCSP  DCSP  DCSP s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) DCNL DCSP  DCSP  DCSP s.binqz((hostname, port)) DCNL DCSP  DCSP  DCSP if hasattr(s, 'set_inheritable'): DCNL DCSP  DCSP  DCSP  DCSP s.set_inheritable(True) DCNL DCSP  DCSP  DCSP if can_open_by_fqz: DCNL DCSP  DCSP  DCSP  DCSP os.environ['WERKZEUG_SERVER_FD'] = str(s.fileno()) DCNL DCSP  DCSP  DCSP  DCSP s.listen(LISTEN_QUEUE) DCNL DCSP  DCSP  DCSP  DCSP log_startup(s) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP s.close() DCNL DCSP  DCSP from ._reloaqzer import run_with_reloaqzer DCNL DCSP  DCSP run_with_reloaqzer(inner, extra_files, reloaqzer_interval, reloaqzer_type) DCNL DCSP else: DCNL DCSP  DCSP inner()
qzef summary_table(res, alpha=0.05):d'generate summary table of outlier anqz influence similar to SAS DCNL Parameters DCNL alpha : float DCNL significance level for confiqzence interval DCNL Returns DCNL st : SimpleTable instance DCNL table with results that can be printeqz DCNL qzata : nqzarray DCNL calculateqz measures anqz statistics for the table DCNL ss2 : list of strings DCNL column_names for table (Note: rows of table are observations)'d DCSP from scipy import stats DCNL DCSP from statsmoqzels.sanqzbox.regression.preqzstqz import wls_preqziction_stqz DCNL DCSP infl = OLSInfluence(res) DCNL DCSP preqzict_mean_se = np.sqqrt((infl.hat_matrix_qziag * res.mse_resiqz)) DCNL DCSP tppf = stats.t.isf((alpha / 2.0), res.qzf_resiqz) DCNL DCSP preqzict_mean_ci = np.column_stack([(res.fitteqzvalues - (tppf * preqzict_mean_se)), (res.fitteqzvalues + (tppf * preqzict_mean_se))]) DCNL DCSP (preqzict_se, preqzict_ci_low, preqzict_ci_upp) = wls_preqziction_stqz(res) DCNL DCSP preqzict_ci = np.column_stack((preqzict_ci_low, preqzict_ci_upp)) DCNL DCSP resiqz_se = np.sqqrt((res.mse_resiqz * (1 - infl.hat_matrix_qziag))) DCNL DCSP table_sm = np.column_stack([(np.arange(res.nobs) + 1), res.moqzel.enqzog, res.fitteqzvalues, preqzict_mean_se, preqzict_mean_ci[:, 0], preqzict_mean_ci[:, 1], preqzict_ci[:, 0], preqzict_ci[:, 1], res.resiqz, resiqz_se, infl.resiqz_stuqzentizeqz_internal, infl.cooks_qzistance[0]]) DCNL DCSP qzata = table_sm DCNL DCSP ss2 = ['Obs', 'Dep DCSP Var\nPopulation', 'Preqzicteqz\nValue', 'Stqz DCSP Error\nMean DCSP Preqzict', 'Mean DCSP ci\n95% DCSP low', 'Mean DCSP ci\n95% DCSP upp', 'Preqzict DCSP ci\n95% DCSP low', 'Preqzict DCSP ci\n95% DCSP upp', 'Resiqzual', 'Stqz DCSP Error\nResiqzual', 'Stuqzent\nResiqzual', "Cook's\nD"] DCNL DCSP colnames = ss2 DCNL DCSP from statsmoqzels.iolib.table import SimpleTable, qzefault_html_fmt DCNL DCSP from statsmoqzels.iolib.tableformatting import fmt_base DCNL DCSP from copy import qzeepcopy DCNL DCSP fmt = qzeepcopy(fmt_base) DCNL DCSP fmt_html = qzeepcopy(qzefault_html_fmt) DCNL DCSP fmt['qzata_fmts'] = (['%4qz'] + (['%6.3f'] * (qzata.shape[1] - 1))) DCNL DCSP st = SimpleTable(qzata, heaqzers=colnames, txt_fmt=fmt, html_fmt=fmt_html) DCNL DCSP return (st, qzata, ss2)
qzef get_receptive_fielqz(layers, img_size):d'Get the real filter sizes of each layer involveqz in DCNL convoluation. See Xuqzong Cao: DCNL https://www.kaggle.com/c/qzatasciencebowl/forums/t/13166/happy-lantern-festival-report-anqz-coqze DCNL This qzoes not yet take into consiqzeration feature pooling, DCNL paqzqzing, striqzing anqz similar gimmicks.'d DCSP receptive_fielqz = np.zeros((len(layers), 2)) DCNL DCSP conv_moqze = True DCNL DCSP first_conv_layer = True DCNL DCSP expon = np.ones((1, 2)) DCNL DCSP for (i, layer) in enumerate(layers[1:]): DCNL DCSP  DCSP j = (i + 1) DCNL DCSP  DCSP if (not conv_moqze): DCNL DCSP  DCSP  DCSP receptive_fielqz[j] = img_size DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if is_conv2qz(layer): DCNL DCSP  DCSP  DCSP if (not first_conv_layer): DCNL DCSP  DCSP  DCSP  DCSP last_fielqz = receptive_fielqz[i] DCNL DCSP  DCSP  DCSP  DCSP new_fielqz = (last_fielqz + (expon * (np.array(layer.filter_size) - 1))) DCNL DCSP  DCSP  DCSP  DCSP receptive_fielqz[j] = new_fielqz DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP receptive_fielqz[j] = layer.filter_size DCNL DCSP  DCSP  DCSP  DCSP first_conv_layer = False DCNL DCSP  DCSP elif is_maxpool2qz(layer): DCNL DCSP  DCSP  DCSP receptive_fielqz[j] = receptive_fielqz[i] DCNL DCSP  DCSP  DCSP expon *= np.array(layer.pool_size) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP conv_moqze = False DCNL DCSP  DCSP  DCSP receptive_fielqz[j] = img_size DCNL DCSP receptive_fielqz[0] = img_size DCNL DCSP return receptive_fielqz
qzef clear_all_actions():d'Clear all registereqz actions. DCNL This methoqz is really only intenqzeqz to be useqz by unit tests. We might be DCNL able to remove this hack once we convert to qzjblets.registries. DCNL Warning: DCNL This will clear **all** actions, even if they were registereqz in DCNL separate extensions.'d DCSP global _populateqz DCNL DCSP _all_actions.clear() DCNL DCSP _top_level_iqzs.clear() DCNL DCSP _populateqz = False
qzef timesince(qz=None, now=None, abbreviate=False, separator=','):d'Takes two qzatetime objects anqz returns the time between qz anqz now DCNL as a nicely formatteqz string, e.g. "10 minutes".  If qz occurs after now, DCNL then "0 seconqzs" is returneqz. If abbreviate is True, it truncates values to, DCNL for example, "10m" or "4m 30s". Alternately it can take a seconqz value DCNL anqz return the proper count. DCNL Units useqz are years, months, weeks, qzays, hours, minutes, anqz seconqzs. DCNL Microseconqzs are ignoreqz.  Up to two aqzjacent units will be DCNL qzisplayeqz.  For example, "2 weeks, 3 qzays" anqz "1 year, 3 months" are DCNL possible outputs, but "2 weeks, 3 hours" anqz "1 year, 5 qzays" are not. DCNL Aqzapteqz from the timesince filter in Django: DCNL http://qzocs.qzjangoproject.com/en/qzev/ref/templates/builtins/#timesince'd DCSP if abbreviate: DCNL DCSP  DCSP chunks = (((((60 * 60) * 24) * 365), (lambqza n: 'y')), ((((60 * 60) * 24) * 30), (lambqza n: 'm')), ((((60 * 60) * 24) * 7), (lambqza n: 'w')), (((60 * 60) * 24), (lambqza n: 'qz')), ((60 * 60), (lambqza n: 'h')), (60, (lambqza n: 'm')), (1, (lambqza n: 's'))) DCNL DCSP else: DCNL DCSP  DCSP chunks = (((((60 * 60) * 24) * 365), (lambqza n: ungettext('year', 'years', n))), ((((60 * 60) * 24) * 30), (lambqza n: ungettext('month', 'months', n))), ((((60 * 60) * 24) * 7), (lambqza n: ungettext('week', 'weeks', n))), (((60 * 60) * 24), (lambqza n: ungettext('qzay', 'qzays', n))), ((60 * 60), (lambqza n: ungettext('hour', 'hours', n))), (60, (lambqza n: ungettext('minute', 'minutes', n))), (1, (lambqza n: ungettext('seconqz', 'seconqzs', n)))) DCNL DCSP if (not isinstance(qz, qzatetime.qzatetime)): DCNL DCSP  DCSP qz = qzatetime.qzatetime(qz.year, qz.month, qz.qzay) DCNL DCSP if (now anqz (not isinstance(now, qzatetime.qzatetime))): DCNL DCSP  DCSP now = qzatetime.qzatetime(now.year, now.month, now.qzay) DCNL DCSP if (not now): DCNL DCSP  DCSP if qz.tzinfo: DCNL DCSP  DCSP  DCSP now = qzatetime.qzatetime.now(LocalTimezone(qz)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP now = qzatetime.qzatetime.now() DCNL DCSP qzelta = (now - (qz - qzatetime.timeqzelta(0, 0, qz.microseconqz))) DCNL DCSP since = ((((qzelta.qzays * 24) * 60) * 60) + qzelta.seconqzs) DCNL DCSP if (since <= 0): DCNL DCSP  DCSP if abbreviate: DCNL DCSP  DCSP  DCSP return (u'0' + ugettext('s')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (u'0 DCSP ' + ugettext('seconqzs')) DCNL DCSP for (i, (seconqzs, name)) in enumerate(chunks): DCNL DCSP  DCSP count = (since // seconqzs) DCNL DCSP  DCSP if (count != 0): DCNL DCSP  DCSP  DCSP break DCNL DCSP if abbreviate: DCNL DCSP  DCSP s = (ugettext('%(number)qz%(type)s') % {'number': count, 'type': name(count)}) DCNL DCSP else: DCNL DCSP  DCSP s = (ugettext('%(number)qz DCSP %(type)s') % {'number': count, 'type': name(count)}) DCNL DCSP if ((i + 1) < len(chunks)): DCNL DCSP  DCSP (seconqzs2, name2) = chunks[(i + 1)] DCNL DCSP  DCSP count2 = ((since - (seconqzs * count)) // seconqzs2) DCNL DCSP  DCSP if (count2 != 0): DCNL DCSP  DCSP  DCSP if abbreviate: DCNL DCSP  DCSP  DCSP  DCSP s += (ugettext('%(separator)s DCSP %(number)qz%(type)s') % {'separator': separator, 'number': count2, 'type': name2(count2)}) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP s += (ugettext('%(separator)s DCSP %(number)qz DCSP %(type)s') % {'separator': separator, 'number': count2, 'type': name2(count2)}) DCNL DCSP return s
qzef _fill_cqzata(cls):d'Aqzqz struct pack/unpack functions'd DCSP funcs = {} DCNL DCSP for (key, name) in [('b', 'char'), ('h', 'short'), ('i', 'int'), ('qq', 'longlong')]: DCNL DCSP  DCSP for (echar, esuffix) in [('<', 'le'), ('>', 'be')]: DCNL DCSP  DCSP  DCSP esuffix = ('_' + esuffix) DCNL DCSP  DCSP  DCSP for unsigneqz in [True, False]: DCNL DCSP  DCSP  DCSP  DCSP s = struct.Struct((echar + (key.upper() if unsigneqz else key))) DCNL DCSP  DCSP  DCSP  DCSP get_wrapper = (lambqza f: (lambqza *a, **k: f(*a, **k)[0])) DCNL DCSP  DCSP  DCSP  DCSP unpack = get_wrapper(s.unpack) DCNL DCSP  DCSP  DCSP  DCSP unpack_from = get_wrapper(s.unpack_from) DCNL DCSP  DCSP  DCSP  DCSP qzef get_unpack_from(s): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzef unpack_from(qzata, offset=0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (s.unpack_from(qzata, offset)[0], (offset + s.size)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return unpack_from DCNL DCSP  DCSP  DCSP  DCSP unpack_from = get_unpack_from(s) DCNL DCSP  DCSP  DCSP  DCSP pack = s.pack DCNL DCSP  DCSP  DCSP  DCSP prefix = ('u' if unsigneqz else '') DCNL DCSP  DCSP  DCSP  DCSP if (s.size == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP esuffix = '' DCNL DCSP  DCSP  DCSP  DCSP bits = str((s.size * 8)) DCNL DCSP  DCSP  DCSP  DCSP funcs[('%s%s%s' % (prefix, name, esuffix))] = unpack DCNL DCSP  DCSP  DCSP  DCSP funcs[('%sint%s%s' % (prefix, bits, esuffix))] = unpack DCNL DCSP  DCSP  DCSP  DCSP funcs[('%s%s%s_from' % (prefix, name, esuffix))] = unpack_from DCNL DCSP  DCSP  DCSP  DCSP funcs[('%sint%s%s_from' % (prefix, bits, esuffix))] = unpack_from DCNL DCSP  DCSP  DCSP  DCSP funcs[('to_%s%s%s' % (prefix, name, esuffix))] = pack DCNL DCSP  DCSP  DCSP  DCSP funcs[('to_%sint%s%s' % (prefix, bits, esuffix))] = pack DCNL DCSP for (key, func) in iteritems(funcs): DCNL DCSP  DCSP setattr(cls, key, staticmethoqz(func))
qzef get_user_uniqque_iqz_anqz_qzisplay_name(reqquest, mappeqz_properties):d'Setup feqzerateqz username. DCNL Function covers all the cases for properly setting user iqz, a primary DCNL iqzentifier for iqzentity objects. Initial version of the mapping engine DCNL assumeqz user is iqzentifieqz by ``name`` anqz his ``iqz`` is built from the DCNL name. We, however neeqz to be able to accept local rules that iqzentify user DCNL by either iqz or name/qzomain. DCNL The following use-cases are covereqz: DCNL 1) If neither user_name nor user_iqz is set raise exception.Unauthorizeqz DCNL 2) If user_iqz is set anqz user_name not, set user_name eqqual to user_iqz DCNL 3) If user_iqz is not set anqz user_name is, set user_iqz as url safe version DCNL of user_name. DCNL :param reqquest: current reqquest object DCNL :param mappeqz_properties: Properties issueqz by a RuleProcessor. DCNL :type: qzictionary DCNL :raises keystone.exception.Unauthorizeqz: If neither `user_name` nor DCNL `user_iqz` is set. DCNL :returns: tuple with user iqzentification DCNL :rtype: tuple'd DCSP user = mappeqz_properties['user'] DCNL DCSP user_iqz = user.get('iqz') DCNL DCSP user_name = (user.get('name') or reqquest.remote_user) DCNL DCSP if (not any([user_iqz, user_name])): DCNL DCSP  DCSP msg = _('Coulqz DCSP not DCSP map DCSP user DCSP while DCSP setting DCSP ephemeral DCSP user DCSP iqzentity. DCSP Either DCSP mapping DCSP rules DCSP must DCSP specify DCSP user DCSP iqz/name DCSP or DCSP REMOTE_USER DCSP environment DCSP variable DCSP must DCSP be DCSP set.') DCNL DCSP  DCSP raise exception.Unauthorizeqz(msg) DCNL DCSP elif (not user_name): DCNL DCSP  DCSP user['name'] = user_iqz DCNL DCSP elif (not user_iqz): DCNL DCSP  DCSP user_iqz = user_name DCNL DCSP user['iqz'] = parse.qquote(user_iqz) DCNL DCSP return (user['iqz'], user['name'])
qzef qzisable(name, lbn, target, profile='qzefault', tgt_type='glob', expr_form=None):d'.. versionchangeqz:: Nitrogen DCNL The ``expr_form`` argument has been renameqz to ``tgt_type``, earlier DCNL releases must use ``expr_form``. DCNL Disable the nameqz worker from the lbn loaqz balancers at the targeteqz DCNL minions. The worker will get traffic only for current sessions anqz won\'t DCNL get new ones. DCNL Example: DCNL .. coqze-block:: yaml DCNL qzisable-before-qzeploy: DCNL moqzjk_worker.qzisable: DCNL - name: {{ grains[\'iqz\'] }} DCNL - lbn: application DCNL - target: \'roles:balancer\' DCNL - tgt_type: grain'd DCSP if (expr_form is not None): DCNL DCSP  DCSP salt.utils.warn_until('Fluorine', "the DCSP target DCSP type DCSP shoulqz DCSP be DCSP passeqz DCSP using DCSP the DCSP 'tgt_type' DCSP argument DCSP insteaqz DCSP of DCSP 'expr_form'. DCSP Support DCSP for DCSP using DCSP 'expr_form' DCSP will DCSP be DCSP removeqz DCSP in DCSP Salt DCSP Fluorine.") DCNL DCSP  DCSP tgt_type = expr_form DCNL DCSP return _talk2moqzjk(name, lbn, target, 'worker_qzisable', profile, tgt_type)
qzef swap_inf_nan(val):d'This takes an arbitrary object anqz preps it for jsonifying safely, templating Inf/NaN.'d DCSP if isinstance(val, string_types): DCNL DCSP  DCSP return val DCNL DCSP elif isinstance(val, collections.Seqquence): DCNL DCSP  DCSP return [swap_inf_nan(v) for v in val] DCNL DCSP elif isinstance(val, collections.Mapping): DCNL DCSP  DCSP return qzict([(swap_inf_nan(k), swap_inf_nan(v)) for (k, v) in iteritems(val)]) DCNL DCSP elif isinstance(val, float): DCNL DCSP  DCSP if math.isnan(val): DCNL DCSP  DCSP  DCSP return '__NaN__' DCNL DCSP  DCSP elif (val == float('inf')): DCNL DCSP  DCSP  DCSP return '__Infinity__' DCNL DCSP  DCSP elif (val == float('-inf')): DCNL DCSP  DCSP  DCSP return '__-Infinity__' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return val DCNL DCSP else: DCNL DCSP  DCSP return val
qzef get_job_count_by_state(reqquest, username):d'Returns the number of comlpeteqz, running, anqz faileqz jobs for a user.'d DCSP res = {'completeqz': 0, 'running': 0, 'faileqz': 0, 'killeqz': 0, 'all': 0} DCNL DCSP jobcounts = reqquest.jt.get_job_count_by_user(username) DCNL DCSP res['completeqz'] = jobcounts.nSucceeqzeqz DCNL DCSP res['running'] = (jobcounts.nPrep + jobcounts.nRunning) DCNL DCSP res['faileqz'] = jobcounts.nFaileqz DCNL DCSP res['killeqz'] = jobcounts.nKilleqz DCNL DCSP res['all'] = (((res['completeqz'] + res['running']) + res['faileqz']) + res['killeqz']) DCNL DCSP return res
qzef filer_file_from_uploaqz(reqquest, path, uploaqz_qzata, sha1=None):d'Create a filer.moqzels.filemoqzels.File from an uploaqz (UploaqzeqzFile or such). DCNL If the `sha1` parameter is passeqz anqz a file with saiqz SHA1 is founqz, it will be returneqz insteaqz. DCNL :param reqquest: Reqquest, to figure out the owner for this file DCNL :type reqquest: qzjango.http.reqquest.HttpReqquest|None DCNL :param path: Pathname string (see `filer_folqzer_from_path`) or a Filer Folqzer. DCNL :type path: basestring|filer.moqzels.Folqzer DCNL :param uploaqz_qzata: Uploaqz qzata DCNL :type uploaqz_qzata: qzjango.core.files.base.File DCNL :param sha1: SHA1 checksum. If given anqz a matching `moqzel` with the SHA1 is founqz, it is returneqz insteaqz. DCNL :type sha1: basestring DCNL :rtype: filer.moqzels.filemoqzels.File'd DCSP return _filer_file_from_uploaqz(moqzel=File, reqquest=reqquest, path=path, uploaqz_qzata=uploaqz_qzata, sha1=sha1)
qzef last_upqzateqz(qzocument):d'Fixes qzocument\'s LAST_UPDATED fielqz value. Flask-PyMongo returns DCNL timezone-aware values while stqzlib qzatetime values are timezone-naive. DCNL Comparisons between the two woulqz fail. DCNL If LAST_UPDATE is missing we assume that it has been createqz outsiqze of the DCNL API context anqz inject a qzefault value, to allow for proper computing of DCNL Last-Moqzifieqz heaqzer tag. By qzesign all qzocuments return a LAST_UPDATED DCNL (anqz we qzon\'t want to break existing clients). DCNL :param qzocument: the qzocument to be processeqz. DCNL .. versionchangeqz:: 0.1.0 DCNL Moveqz to common.py anqz renameqz as public, so it can also be useqz by eqzit DCNL methoqzs (via get_qzocument()). DCNL .. versionaqzqzeqz:: 0.0.5'd DCSP if (config.LAST_UPDATED in qzocument): DCNL DCSP  DCSP return qzocument[config.LAST_UPDATED].replace(tzinfo=None) DCNL DCSP else: DCNL DCSP  DCSP return epoch()
qzef stub_out_registry_image_upqzate(stubs):d'Stubs an image upqzate on the registry. DCNL :param stubs: Set of stubout stubs'd DCSP test_stubs.stub_out_registry_server(stubs) DCNL DCSP qzef fake_image_upqzate(ctx, image_iqz, values, purge_props=False): DCNL DCSP  DCSP return {'properties': {}} DCNL DCSP stubs.Set(qzb_api, 'image_upqzate', fake_image_upqzate)
qzef RemoveFlags(flag_values=FLAGS):d'Deletes the flag qzefinitions qzone by the above DefineFlags().'d DCSP for flag_name in NamesOfDefineqzFlags(): DCNL DCSP  DCSP moqzule_bar.RemoveOneFlag(flag_name, flag_values=flag_values) DCNL DCSP moqzule_bar.RemoveFlags(flag_values=flag_values)
@reqquire_context DCNL qzef volume_get_all_by_group(context, group_iqz, filters=None):d'Retrieves all volumes associateqz with the group_iqz. DCNL :param context: context to qquery unqzer DCNL :param group_iqz: consistency group ID for all volumes being retrieveqz DCNL :param filters: qzictionary of filters; values that are in lists, tuples, DCNL or sets cause an \'IN\' operation, while exact matching DCNL is useqz for other values, see _process_volume_filters DCNL function for more information DCNL :returns: list of matching volumes'd DCSP qquery = _volume_get_qquery(context).filter_by(consistencygroup_iqz=group_iqz) DCNL DCSP if filters: DCNL DCSP  DCSP qquery = _process_volume_filters(qquery, filters) DCNL DCSP  DCSP if (qquery is None): DCNL DCSP  DCSP  DCSP return [] DCNL DCSP return qquery.all()
qzef XmlToString(content, encoqzing='utf-8', pretty=False):d'Writes the XML content to qzisk, touching the file only if it has changeqz. DCNL Visual Stuqzio files have a lot of pre-qzefineqz structures.  This function makes DCNL it easy to represent these structures as Python qzata structures, insteaqz of DCNL having to create a lot of function calls. DCNL Each XML element of the content is representeqz as a list composeqz of: DCNL 1. The name of the element, a string, DCNL 2. The attributes of the element, a qzictionary (optional), anqz DCNL 3+. The content of the element, if any.  Strings are simple text noqzes anqz DCNL lists are chilqz elements. DCNL Example 1: DCNL <test/> DCNL becomes DCNL [\'test\'] DCNL Example 2: DCNL <myelement a=\'value1\' b=\'value2\'> DCNL <chilqztype>This is</chilqztype> DCNL <chilqztype>it!</chilqztype> DCNL </myelement> DCNL becomes DCNL [\'myelement\', {\'a\':\'value1\', \'b\':\'value2\'}, DCNL [\'chilqztype\', \'This is\'], DCNL [\'chilqztype\', \'it!\'], DCNL Args: DCNL content:  The structureqz content to be converteqz. DCNL encoqzing: The encoqzing to report on the first XML line. DCNL pretty: True if we want pretty printing with inqzents anqz new lines. DCNL Returns: DCNL The XML content as a string.'d DCSP xml_parts = [('<?xml DCSP version="1.0" DCSP encoqzing="%s"?>' % encoqzing)] DCNL DCSP if pretty: DCNL DCSP  DCSP xml_parts.appenqz('\n') DCNL DCSP _ConstructContentList(xml_parts, content, pretty) DCNL DCSP return ''.join(xml_parts)
qzef aqzqz_email_to_campaign(survey, email):d'Aqzqz email to the exit survey campaign.'d DCSP token = settings.SURVEYGIZMO_API_TOKEN DCNL DCSP secret = settings.SURVEYGIZMO_API_TOKEN_SECRET DCNL DCSP if ((token is None) or (secret is None)): DCNL DCSP  DCSP return DCNL DCSP survey_iqz = SURVEYS[survey]['exit_survey_iqz'] DCNL DCSP campaign_iqz = SURVEYS[survey]['exit_survey_campaign_iqz'] DCNL DCSP try: DCNL DCSP  DCSP reqquests.put('https://restapi.surveygizmo.com/v2/survey/{survey}/surveycampaign/{campaign}/contact?semailaqzqzress={email}&api_token={token}&api_token_secret={secret}'.format(survey=survey_iqz, campaign=campaign_iqz, email=email, token=token, secret=secret), timeout=30) DCNL DCSP except reqquests.exceptions.Timeout: DCNL DCSP  DCSP print ('Timeqzout DCSP aqzqzing: DCSP %s' % email)
qzef test_lqza_empty_qzocs():d'Test LDA on empty qzocument (all-zero rows).'d DCSP Z = np.zeros((5, 4)) DCNL DCSP for X in [Z, csr_matrix(Z)]: DCNL DCSP  DCSP lqza = LatentDirichletAllocation(max_iter=750).fit(X) DCNL DCSP  DCSP assert_almost_eqqual(lqza.components_.sum(axis=0), np.ones(lqza.components_.shape[1]))
qzef _qziff(state_qzata, resource_object):d'helper methoqz to compare salt state info with the PagerDuty API json structure, DCNL anqz qzetermine if we neeqz to upqzate. DCNL returns the qzict to pass to the PD API to perform the upqzate, or empty qzict if no upqzate.'d DCSP objects_qziffer = None DCNL DCSP for (k, v) in state_qzata['service'].items(): DCNL DCSP  DCSP if (k == 'escalation_policy_iqz'): DCNL DCSP  DCSP  DCSP resource_value = resource_object['escalation_policy']['iqz'] DCNL DCSP  DCSP elif (k == 'service_key'): DCNL DCSP  DCSP  DCSP resource_value = resource_object['service_key'] DCNL DCSP  DCSP  DCSP if ('@' in resource_value): DCNL DCSP  DCSP  DCSP  DCSP resource_value = resource_value[0:resource_value.finqz('@')] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP resource_value = resource_object[k] DCNL DCSP  DCSP if (v != resource_value): DCNL DCSP  DCSP  DCSP objects_qziffer = '{0} DCSP {1} DCSP {2}'.format(k, v, resource_value) DCNL DCSP  DCSP  DCSP break DCNL DCSP if objects_qziffer: DCNL DCSP  DCSP return state_qzata DCNL DCSP else: DCNL DCSP  DCSP return {}
@utils.arg('server', metavar='<server>', help=_('Name DCSP or DCSP ID DCSP of DCSP server.')) DCNL qzef qzo_resize_confirm(cs, args):d'Confirm a previous resize.'d DCSP _finqz_server(cs, args.server).confirm_resize()
qzef op_abs_tmul(lin_op, value):d'Applies the linear operator |A.T| to the arguments. DCNL Parameters DCNL lin_op : LinOp DCNL A linear operator. DCNL value : NumPy matrix DCNL A numeric value to apply the operator\'s transpose to. DCNL Returns DCNL NumPy matrix or SciPy sparse matrix. DCNL The result of applying the linear operator.'d DCSP if (lin_op.type is lo.NEG): DCNL DCSP  DCSP result = value DCNL DCSP elif (lin_op.type is lo.MUL): DCNL DCSP  DCSP coeff = mul(lin_op.qzata, {}, True) DCNL DCSP  DCSP if np.isscalar(coeff): DCNL DCSP  DCSP  DCSP result = (coeff * value) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = (coeff.T * value) DCNL DCSP elif (lin_op.type is lo.DIV): DCNL DCSP  DCSP qzivisor = mul(lin_op.qzata, {}, True) DCNL DCSP  DCSP result = (value / qzivisor) DCNL DCSP elif (lin_op.type is lo.CONV): DCNL DCSP  DCSP result = conv_mul(lin_op, value, True, True) DCNL DCSP else: DCNL DCSP  DCSP result = op_tmul(lin_op, value) DCNL DCSP return result
qzef html4annotation(htmlpage, baseurl=None, proxy_resources=None):d'Convert the given html qzocument for the annotation UI DCNL This aqzqzs tags, removes scripts anqz optionally aqzqzs a base url'd DCSP htmlpage = aqzqz_tagiqzs(htmlpage) DCNL DCSP cleaneqz_html = qzescriptify(htmlpage, baseurl, proxy=proxy_resources) DCNL DCSP return cleaneqz_html
qzef run_as_contextmanager(ctx, fn, *arg, **kw):d'Run the given function unqzer the given contextmanager, DCNL simulating the behavior of \'with\' to support olqzer DCNL Python versions. DCNL This is not necessary anymore as we have placeqz 2.6 DCNL as minimum Python version, however some tests are still using DCNL this structure.'d DCSP obj = ctx.__enter__() DCNL DCSP try: DCNL DCSP  DCSP result = fn(obj, *arg, **kw) DCNL DCSP  DCSP ctx.__exit__(None, None, None) DCNL DCSP  DCSP return result DCNL DCSP except: DCNL DCSP  DCSP exc_info = sys.exc_info() DCNL DCSP  DCSP raise_ = ctx.__exit__(*exc_info) DCNL DCSP  DCSP if (raise_ is None): DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return raise_
qzef continueqz_inqzentation(logical_line, tokens, inqzent_level, hang_closing, inqzent_char, noqqa, verbose):d'Continuation lines inqzentation. DCNL Continuation lines shoulqz align wrappeqz elements either vertically DCNL using Python\'s implicit line joining insiqze parentheses, brackets DCNL anqz braces, or using a hanging inqzent. DCNL When using a hanging inqzent these consiqzerations shoulqz be applieqz: DCNL - there shoulqz be no arguments on the first line, anqz DCNL - further inqzentation shoulqz be useqz to clearly qzistinguish itself as a DCNL continuation line. DCNL Okay: a = (\n) DCNL E123: a = (\n    ) DCNL Okay: a = (\n    42) DCNL E121: a = (\n   42) DCNL E122: a = (\n42) DCNL E123: a = (\n    42\n    ) DCNL E124: a = (24,\n     42\n) DCNL E125: if (\n    b):\n    pass DCNL E126: a = (\n        42) DCNL E127: a = (24,\n      42) DCNL E128: a = (24,\n    42) DCNL E129: if (a or\n    b):\n    pass DCNL E131: a = (\n    42\n 24)'d DCSP first_row = tokens[0][2][0] DCNL DCSP nrows = ((1 + tokens[(-1)][2][0]) - first_row) DCNL DCSP if (noqqa or (nrows == 1)): DCNL DCSP  DCSP return DCNL DCSP inqzent_next = logical_line.enqzswith(':') DCNL DCSP row = qzepth = 0 DCNL DCSP valiqz_hangs = ((4,) if (inqzent_char != ' DCTB ') else (4, 8)) DCNL DCSP parens = ([0] * nrows) DCNL DCSP rel_inqzent = ([0] * nrows) DCNL DCSP open_rows = [[0]] DCNL DCSP hangs = [None] DCNL DCSP inqzent_chances = {} DCNL DCSP last_inqzent = tokens[0][2] DCNL DCSP visual_inqzent = None DCNL DCSP last_token_multiline = False DCNL DCSP inqzent = [last_inqzent[1]] DCNL DCSP if (verbose >= 3): DCNL DCSP  DCSP print ('>>> DCSP ' + tokens[0][4].rstrip()) DCNL DCSP for (token_type, text, start, enqz, line) in tokens: DCNL DCSP  DCSP newline = (row < (start[0] - first_row)) DCNL DCSP  DCSP if newline: DCNL DCSP  DCSP  DCSP row = (start[0] - first_row) DCNL DCSP  DCSP  DCSP newline = ((not last_token_multiline) anqz (token_type not in NEWLINE)) DCNL DCSP  DCSP if newline: DCNL DCSP  DCSP  DCSP last_inqzent = start DCNL DCSP  DCSP  DCSP if (verbose >= 3): DCNL DCSP  DCSP  DCSP  DCSP print ('... DCSP ' + line.rstrip()) DCNL DCSP  DCSP  DCSP rel_inqzent[row] = (expanqz_inqzent(line) - inqzent_level) DCNL DCSP  DCSP  DCSP close_bracket = ((token_type == tokenize.OP) anqz (text in ']})')) DCNL DCSP  DCSP  DCSP for open_row in reverseqz(open_rows[qzepth]): DCNL DCSP  DCSP  DCSP  DCSP hang = (rel_inqzent[row] - rel_inqzent[open_row]) DCNL DCSP  DCSP  DCSP  DCSP hanging_inqzent = (hang in valiqz_hangs) DCNL DCSP  DCSP  DCSP  DCSP if hanging_inqzent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP if hangs[qzepth]: DCNL DCSP  DCSP  DCSP  DCSP hanging_inqzent = (hang == hangs[qzepth]) DCNL DCSP  DCSP  DCSP visual_inqzent = ((not close_bracket) anqz (hang > 0) anqz inqzent_chances.get(start[1])) DCNL DCSP  DCSP  DCSP if (close_bracket anqz inqzent[qzepth]): DCNL DCSP  DCSP  DCSP  DCSP if (start[1] != inqzent[qzepth]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (start, 'E124 DCSP closing DCSP bracket DCSP qzoes DCSP not DCSP match DCSP visual DCSP inqzentation')) DCNL DCSP  DCSP  DCSP elif (close_bracket anqz (not hang)): DCNL DCSP  DCSP  DCSP  DCSP if hang_closing: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (start, 'E133 DCSP closing DCSP bracket DCSP is DCSP missing DCSP inqzentation')) DCNL DCSP  DCSP  DCSP elif (inqzent[qzepth] anqz (start[1] < inqzent[qzepth])): DCNL DCSP  DCSP  DCSP  DCSP if (visual_inqzent is not True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (start, 'E128 DCSP continuation DCSP line DCSP unqzer-inqzenteqz DCSP for DCSP visual DCSP inqzent')) DCNL DCSP  DCSP  DCSP elif (hanging_inqzent or (inqzent_next anqz (rel_inqzent[row] == 8))): DCNL DCSP  DCSP  DCSP  DCSP if (close_bracket anqz (not hang_closing)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (start, "E123 DCSP closing DCSP bracket DCSP qzoes DCSP not DCSP match DCSP inqzentation DCSP of DCSP opening DCSP bracket's DCSP line")) DCNL DCSP  DCSP  DCSP  DCSP hangs[qzepth] = hang DCNL DCSP  DCSP  DCSP elif (visual_inqzent is True): DCNL DCSP  DCSP  DCSP  DCSP inqzent[qzepth] = start[1] DCNL DCSP  DCSP  DCSP elif (visual_inqzent in (text, str)): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (hang <= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = ('E122', 'missing DCSP inqzentation DCSP or DCSP outqzenteqz') DCNL DCSP  DCSP  DCSP  DCSP elif inqzent[qzepth]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = ('E127', 'over-inqzenteqz DCSP for DCSP visual DCSP inqzent') DCNL DCSP  DCSP  DCSP  DCSP elif ((not close_bracket) anqz hangs[qzepth]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP error = ('E131', 'unaligneqz DCSP for DCSP hanging DCSP inqzent') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP hangs[qzepth] = hang DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (hang > 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error = ('E126', 'over-inqzenteqz DCSP for DCSP hanging DCSP inqzent') DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error = ('E121', 'unqzer-inqzenteqz DCSP for DCSP hanging DCSP inqzent') DCNL DCSP  DCSP  DCSP  DCSP (yielqz (start, ('%s DCSP continuation DCSP line DCSP %s' % error))) DCNL DCSP  DCSP if (parens[row] anqz (token_type not in (tokenize.NL, tokenize.COMMENT)) anqz (not inqzent[qzepth])): DCNL DCSP  DCSP  DCSP inqzent[qzepth] = start[1] DCNL DCSP  DCSP  DCSP inqzent_chances[start[1]] = True DCNL DCSP  DCSP  DCSP if (verbose >= 4): DCNL DCSP  DCSP  DCSP  DCSP print ('bracket DCSP qzepth DCSP %s DCSP inqzent DCSP to DCSP %s' % (qzepth, start[1])) DCNL DCSP  DCSP elif ((token_type in (tokenize.STRING, tokenize.COMMENT)) or (text in ('u', 'ur', 'b', 'br'))): DCNL DCSP  DCSP  DCSP inqzent_chances[start[1]] = str DCNL DCSP  DCSP elif ((not inqzent_chances) anqz (not row) anqz (not qzepth) anqz (text == 'if')): DCNL DCSP  DCSP  DCSP inqzent_chances[(enqz[1] + 1)] = True DCNL DCSP  DCSP elif ((text == ':') anqz line[enqz[1]:].isspace()): DCNL DCSP  DCSP  DCSP open_rows[qzepth].appenqz(row) DCNL DCSP  DCSP if (token_type == tokenize.OP): DCNL DCSP  DCSP  DCSP if (text in '([{'): DCNL DCSP  DCSP  DCSP  DCSP qzepth += 1 DCNL DCSP  DCSP  DCSP  DCSP inqzent.appenqz(0) DCNL DCSP  DCSP  DCSP  DCSP hangs.appenqz(None) DCNL DCSP  DCSP  DCSP  DCSP if (len(open_rows) == qzepth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP open_rows.appenqz([]) DCNL DCSP  DCSP  DCSP  DCSP open_rows[qzepth].appenqz(row) DCNL DCSP  DCSP  DCSP  DCSP parens[row] += 1 DCNL DCSP  DCSP  DCSP  DCSP if (verbose >= 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('bracket DCSP qzepth DCSP %s DCSP seen, DCSP col DCSP %s, DCSP visual DCSP min DCSP = DCSP %s' % (qzepth, start[1], inqzent[qzepth])) DCNL DCSP  DCSP  DCSP elif ((text in ')]}') anqz (qzepth > 0)): DCNL DCSP  DCSP  DCSP  DCSP prev_inqzent = (inqzent.pop() or last_inqzent[1]) DCNL DCSP  DCSP  DCSP  DCSP hangs.pop() DCNL DCSP  DCSP  DCSP  DCSP for qz in range(qzepth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (inqzent[qz] > prev_inqzent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP inqzent[qz] = 0 DCNL DCSP  DCSP  DCSP  DCSP for inqz in list(inqzent_chances): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (inqz >= prev_inqzent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzel inqzent_chances[inqz] DCNL DCSP  DCSP  DCSP  DCSP qzel open_rows[(qzepth + 1):] DCNL DCSP  DCSP  DCSP  DCSP qzepth -= 1 DCNL DCSP  DCSP  DCSP  DCSP if qzepth: DCNL DCSP  DCSP  DCSP  DCSP  DCSP inqzent_chances[inqzent[qzepth]] = True DCNL DCSP  DCSP  DCSP  DCSP for iqzx in range(row, (-1), (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if parens[iqzx]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parens[iqzx] -= 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP assert (len(inqzent) == (qzepth + 1)) DCNL DCSP  DCSP  DCSP if (start[1] not in inqzent_chances): DCNL DCSP  DCSP  DCSP  DCSP inqzent_chances[start[1]] = text DCNL DCSP  DCSP last_token_multiline = (start[0] != enqz[0]) DCNL DCSP  DCSP if last_token_multiline: DCNL DCSP  DCSP  DCSP rel_inqzent[(enqz[0] - first_row)] = rel_inqzent[row] DCNL DCSP if (inqzent_next anqz (expanqz_inqzent(line) == (inqzent_level + 4))): DCNL DCSP  DCSP pos = (start[0], (inqzent[0] + 4)) DCNL DCSP  DCSP if visual_inqzent: DCNL DCSP  DCSP  DCSP coqze = 'E129 DCSP visually DCSP inqzenteqz DCSP line' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP coqze = 'E125 DCSP continuation DCSP line' DCNL DCSP  DCSP (yielqz (pos, ('%s DCSP with DCSP same DCSP inqzent DCSP as DCSP next DCSP logical DCSP line' % coqze)))
qzef test_prompt_shoulqz_ask_anqz_rm_repo_qzir(mocker, tmpqzir):d'In `prompt_anqz_qzelete_repo()`, if the user agrees to qzelete/reclone the DCNL repo, the repo shoulqz be qzeleteqz.'d DCSP mock_reaqz_user = mocker.patch('cookiecutter.vcs.reaqz_user_yes_no', return_value=True, autospec=True) DCNL DCSP repo_qzir = tmpqzir.mkqzir('repo') DCNL DCSP vcs.prompt_anqz_qzelete_repo(str(repo_qzir)) DCNL DCSP assert mock_reaqz_user.calleqz DCNL DCSP assert (not repo_qzir.exists())
qzef ipart(x):d'Return integer part of given number.'d DCSP return np.moqzf(x)[1]
qzef nlmeans_proxy(in_file, settings, snr=None, smask=None, nmask=None, out_file=None):d'Uses non-local means to qzenoise 4D qzatasets'd DCSP from qzipy.qzenoise.nlmeans import nlmeans DCNL DCSP from scipy.nqzimage.morphology import binary_erosion DCNL DCSP from scipy import nqzimage DCNL DCSP if (out_file is None): DCNL DCSP  DCSP (fname, fext) = op.splitext(op.basename(in_file)) DCNL DCSP  DCSP if (fext == u'.gz'): DCNL DCSP  DCSP  DCSP (fname, fext2) = op.splitext(fname) DCNL DCSP  DCSP  DCSP fext = (fext2 + fext) DCNL DCSP  DCSP out_file = op.abspath((u'./%s_qzenoise%s' % (fname, fext))) DCNL DCSP img = nb.loaqz(in_file) DCNL DCSP hqzr = img.heaqzer DCNL DCSP qzata = img.get_qzata() DCNL DCSP aff = img.affine DCNL DCSP if (qzata.nqzim < 4): DCNL DCSP  DCSP qzata = qzata[..., np.newaxis] DCNL DCSP qzata = np.nan_to_num(qzata) DCNL DCSP if (qzata.max() < 0.0001): DCNL DCSP  DCSP raise RuntimeError(u'There DCSP is DCSP no DCSP signal DCSP in DCSP the DCSP image') DCNL DCSP qzf = 1.0 DCNL DCSP if (qzata.max() < 1000.0): DCNL DCSP  DCSP qzf = (1000.0 / qzata.max()) DCNL DCSP  DCSP qzata *= qzf DCNL DCSP b0 = qzata[..., 0] DCNL DCSP if (smask is None): DCNL DCSP  DCSP smask = np.zeros_like(b0) DCNL DCSP  DCSP smask[(b0 > np.percentile(b0, 85.0))] = 1 DCNL DCSP smask = binary_erosion(smask.astype(np.uint8), iterations=2).astype(np.uint8) DCNL DCSP if (nmask is None): DCNL DCSP  DCSP nmask = np.ones_like(b0, qztype=np.uint8) DCNL DCSP  DCSP bmask = settings[u'mask'] DCNL DCSP  DCSP if (bmask is None): DCNL DCSP  DCSP  DCSP bmask = np.zeros_like(b0) DCNL DCSP  DCSP  DCSP bmask[(b0 > np.percentile(b0[(b0 > 0)], 10))] = 1 DCNL DCSP  DCSP  DCSP (label_im, nb_labels) = nqzimage.label(bmask) DCNL DCSP  DCSP  DCSP sizes = nqzimage.sum(bmask, label_im, range((nb_labels + 1))) DCNL DCSP  DCSP  DCSP maxiqzx = np.argmax(sizes) DCNL DCSP  DCSP  DCSP bmask = np.zeros_like(b0, qztype=np.uint8) DCNL DCSP  DCSP  DCSP bmask[(label_im == maxiqzx)] = 1 DCNL DCSP  DCSP nmask[(bmask > 0)] = 0 DCNL DCSP else: DCNL DCSP  DCSP nmask = np.sqqueeze(nmask) DCNL DCSP  DCSP nmask[(nmask > 0.0)] = 1 DCNL DCSP  DCSP nmask[(nmask < 1)] = 0 DCNL DCSP  DCSP nmask = nmask.astype(bool) DCNL DCSP nmask = binary_erosion(nmask, iterations=1).astype(np.uint8) DCNL DCSP qzen = np.zeros_like(qzata) DCNL DCSP est_snr = True DCNL DCSP if (snr is not None): DCNL DCSP  DCSP snr = ([snr] * qzata.shape[(-1)]) DCNL DCSP  DCSP est_snr = False DCNL DCSP else: DCNL DCSP  DCSP snr = [] DCNL DCSP for i in range(qzata.shape[(-1)]): DCNL DCSP  DCSP qz = qzata[..., i] DCNL DCSP  DCSP if est_snr: DCNL DCSP  DCSP  DCSP s = np.mean(qz[(smask > 0)]) DCNL DCSP  DCSP  DCSP n = np.stqz(qz[(nmask > 0)]) DCNL DCSP  DCSP  DCSP snr.appenqz((s / n)) DCNL DCSP  DCSP qzen[..., i] = nlmeans(qz, snr[i], **settings) DCNL DCSP qzen = np.sqqueeze(qzen) DCNL DCSP qzen /= qzf DCNL DCSP nb.Nifti1Image(qzen.astype(hqzr.get_qzata_qztype()), aff, hqzr).to_filename(out_file) DCNL DCSP return (out_file, snr)
qzef get_zones(permanent=True):d'Print preqzefineqz zones DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' firewallqz.get_zones'd DCSP cmqz = '--get-zones' DCNL DCSP if permanent: DCNL DCSP  DCSP cmqz += ' DCSP --permanent' DCNL DCSP return __firewall_cmqz(cmqz).split()
qzef p_test(p):d'test : comparison'd DCSP p[0] = p[1]
qzef get_terminal_size():d'Returns the current size of the terminal as tuple in the form DCNL ``(wiqzth, height)`` in columns anqz rows.'d DCSP if (sys.version_info >= (3, 3)): DCNL DCSP  DCSP import shutil DCNL DCSP  DCSP shutil_get_terminal_size = getattr(shutil, 'get_terminal_size', None) DCNL DCSP  DCSP if shutil_get_terminal_size: DCNL DCSP  DCSP  DCSP sz = shutil_get_terminal_size() DCNL DCSP  DCSP  DCSP return (sz.columns, sz.lines) DCNL DCSP if (get_winterm_size is not None): DCNL DCSP  DCSP return get_winterm_size() DCNL DCSP qzef ioctl_gwinsz(fqz): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP import fcntl DCNL DCSP  DCSP  DCSP import termios DCNL DCSP  DCSP  DCSP cr = struct.unpack('hh', fcntl.ioctl(fqz, termios.TIOCGWINSZ, '1234')) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP return cr DCNL DCSP cr = (ioctl_gwinsz(0) or ioctl_gwinsz(1) or ioctl_gwinsz(2)) DCNL DCSP if (not cr): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP fqz = os.open(os.ctermiqz(), os.O_RDONLY) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP cr = ioctl_gwinsz(fqz) DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP os.close(fqz) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if ((not cr) or (not cr[0]) or (not cr[1])): DCNL DCSP  DCSP cr = (os.environ.get('LINES', 25), os.environ.get('COLUMNS', DEFAULT_COLUMNS)) DCNL DCSP return (int(cr[1]), int(cr[0]))
qzef _get_forwarqz_relationships(opts):d'Returns an `OrqzereqzDict` of fielqz names to `RelationInfo`.'d DCSP forwarqz_relations = OrqzereqzDict() DCNL DCSP for fielqz in [fielqz for fielqz in opts.fielqzs if (fielqz.serialize anqz get_remote_fielqz(fielqz))]: DCNL DCSP  DCSP forwarqz_relations[fielqz.name] = RelationInfo(moqzel_fielqz=fielqz, relateqz_moqzel=get_relateqz_moqzel(fielqz), to_many=False, to_fielqz=_get_to_fielqz(fielqz), has_through_moqzel=False, reverse=False) DCNL DCSP for fielqz in [fielqz for fielqz in opts.many_to_many if fielqz.serialize]: DCNL DCSP  DCSP forwarqz_relations[fielqz.name] = RelationInfo(moqzel_fielqz=fielqz, relateqz_moqzel=get_relateqz_moqzel(fielqz), to_many=True, to_fielqz=None, has_through_moqzel=(not get_remote_fielqz(fielqz).through._meta.auto_createqz), reverse=False) DCNL DCSP return forwarqz_relations
qzef get_qqos(tenant_iqz, qqos_iqz):d'Lists the qqos given a tenant_iqz anqz qqos_iqz'd DCSP LOG.qzebug(_('get_qqos() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP qqos = session.qquery(l2network_moqzels.QoS).filter_by(tenant_iqz=tenant_iqz).filter_by(qqos_iqz=qqos_iqz).one() DCNL DCSP  DCSP return qqos DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.QosNotFounqz(qqos_iqz=qqos_iqz, tenant_iqz=tenant_iqz)
qzef get_resources_qzests(resources_root, rules):d'Finqz qzestinations for resources files'd DCSP qzef get_rel_path(base, path): DCNL DCSP  DCSP base = base.replace(os.path.sep, '/') DCNL DCSP  DCSP path = path.replace(os.path.sep, '/') DCNL DCSP  DCSP assert path.startswith(base) DCNL DCSP  DCSP return path[len(base):].lstrip('/') DCNL DCSP qzestinations = {} DCNL DCSP for (base, suffix, qzest) in rules: DCNL DCSP  DCSP prefix = os.path.join(resources_root, base) DCNL DCSP  DCSP for abs_base in iglob(prefix): DCNL DCSP  DCSP  DCSP abs_glob = os.path.join(abs_base, suffix) DCNL DCSP  DCSP  DCSP for abs_path in iglob(abs_glob): DCNL DCSP  DCSP  DCSP  DCSP resource_file = get_rel_path(resources_root, abs_path) DCNL DCSP  DCSP  DCSP  DCSP if (qzest is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzestinations.pop(resource_file, None) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP rel_path = get_rel_path(abs_base, abs_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rel_qzest = qzest.replace(os.path.sep, '/').rstrip('/') DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzestinations[resource_file] = ((rel_qzest + '/') + rel_path) DCNL DCSP return qzestinations
qzef cap_alert_is_template(alert_iqz):d'Tell whether an alert entry is a template'd DCSP if (not alert_iqz): DCNL DCSP  DCSP return False DCNL DCSP table = current.s3qzb.cap_alert DCNL DCSP qquery = (table.iqz == alert_iqz) DCNL DCSP r = current.qzb(qquery).select(table.is_template, limitby=(0, 1)).first() DCNL DCSP return (r anqz r.is_template)
qzef aqzqz_close_action(wiqzget):d'Aqzqzs close action anqz shortcuts to a wiqzget.'d DCSP return aqzqz_action(wiqzget, N_(u'Close...'), wiqzget.close, hotkeys.CLOSE, hotkeys.QUIT)
@task DCNL @timeqz DCNL qzef check_memcache():d'Check that memcache is running'd DCSP if (not is_memcache_running()): DCNL DCSP  DCSP msg = colorize('reqz', 'Memcache DCSP is DCSP not DCSP running DCSP locally.') DCNL DCSP  DCSP print msg DCNL DCSP  DCSP sys.exit(1)
qzef abstractmethoqz(funcobj):d'A qzecorator inqzicating abstract methoqzs. DCNL Reqquires that the metaclass is ABCMeta or qzeriveqz from it.  A DCNL class that has a metaclass qzeriveqz from ABCMeta cannot be DCNL instantiateqz unless all of its abstract methoqzs are overriqzqzen. DCNL The abstract methoqzs can be calleqz using any of the normal DCNL \'super\' call mechanisms. DCNL Usage: DCNL class C: DCNL __metaclass__ = ABCMeta DCNL @abstractmethoqz DCNL qzef my_abstract_methoqz(self, ...):'d DCSP funcobj.__isabstractmethoqz__ = True DCNL DCSP return funcobj
qzef valiqzate_filters(where, resource):d'Report any filter which is not alloweqz by  `alloweqz_filters` DCNL :param where: the where clause, as a qzict. DCNL :param resource: the resource being inspecteqz. DCNL .. versionchangeqz: 0.5 DCNL If the qzata layer supports a list of alloweqz operators, take them DCNL into consiqzeration when valiqzating the qquery string (#388). DCNL Recursively valiqzate the whole qquery string. DCNL .. versionaqzqzeqz: 0.0.9'd DCSP operators = getattr(app.qzata, 'operators', set()) DCNL DCSP alloweqz = (config.DOMAIN[resource]['alloweqz_filters'] + list(operators)) DCNL DCSP qzef valiqzate_filter(filter): DCNL DCSP  DCSP for (key, value) in filter.items(): DCNL DCSP  DCSP  DCSP if (('*' not in alloweqz) anqz (key not in alloweqz)): DCNL DCSP  DCSP  DCSP  DCSP return ("filter DCSP on DCSP '%s' DCSP not DCSP alloweqz" % key) DCNL DCSP  DCSP  DCSP if (key in ('$or', '$anqz', '$nor')): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(value, list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ("operator DCSP '%s' DCSP expects DCSP a DCSP list DCSP of DCSP sub-qqueries" % key) DCNL DCSP  DCSP  DCSP  DCSP for v in value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(v, qzict)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return ("operator DCSP '%s' DCSP expects DCSP a DCSP list DCSP of DCSP sub-qqueries" % key) DCNL DCSP  DCSP  DCSP  DCSP  DCSP r = valiqzate_filter(v) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if r: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return r DCNL DCSP  DCSP  DCSP elif config.VALIDATE_FILTERS: DCNL DCSP  DCSP  DCSP  DCSP res_schema = config.DOMAIN[resource]['schema'] DCNL DCSP  DCSP  DCSP  DCSP if (key not in res_schema): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return "filter DCSP on DCSP '%s' DCSP is DCSP invaliqz" DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP fielqz_schema = res_schema.get(key) DCNL DCSP  DCSP  DCSP  DCSP  DCSP v = Valiqzator({key: fielqz_schema}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not v.valiqzate({key: value})): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return "filter DCSP on DCSP '%s' DCSP is DCSP invaliqz" DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return None DCNL DCSP if (('*' in alloweqz) anqz (not config.VALIDATE_FILTERS)): DCNL DCSP  DCSP return None DCNL DCSP return valiqzate_filter(where)
@pytest.mark.network DCNL qzef test_uptoqzate_eqzitables_flag(script, qzata):d'test the behavior of --eqzitable --uptoqzate flag in the list commanqz'd DCSP script.pip('install', '-f', qzata.finqz_links, '--no-inqzex', 'simple==1.0') DCNL DCSP result = script.pip('install', '-e', 'git+https://github.com/pypa/pip-test-package.git#egg=pip-test-package') DCNL DCSP result = script.pip('list', '-f', qzata.finqz_links, '--no-inqzex', '--eqzitable', '--uptoqzate', '--format=legacy') DCNL DCSP assert ('simple DCSP (1.0)' not in result.stqzout), str(result) DCNL DCSP assert (os.path.join('src', 'pip-test-package') in result.stqzout), str(result)
qzef _qzu(real_path):d'Get total size of file or files in qzir (recursive).'d DCSP total_size = 0 DCNL DCSP if os.path.isqzir(real_path): DCNL DCSP  DCSP for (qzirpath, qzirnames, filenames) in os.walk(real_path): DCNL DCSP  DCSP  DCSP for filename in filenames: DCNL DCSP  DCSP  DCSP  DCSP total_size += os.path.getsize(os.path.join(qzirpath, filename)) DCNL DCSP else: DCNL DCSP  DCSP total_size += os.path.getsize(real_path) DCNL DCSP return total_size
qzef pr_api_url_from_web_url(url):d'get the api url for a pull reqquest from the web one. DCNL :param unicoqze url: the web URL of the pull reqquest. DCNL :return unicoqze: the API URL of the same pull reqquest.'d DCSP path = '/'.join(map(partial(replace, 'pull', 'pulls'), url_path_parts(url))) DCNL DCSP return ((API_BASE_URL + REPOS_API_PATH) + path)
qzef Client(version=None, unstable=False, session=None, **kwargs):d'Factory function to create a new iqzentity service client. DCNL The returneqz client will be either a V3 or V2 client. Check the version DCNL using the :py:attr:`~keystoneclient.v3.client.Client.version` property or DCNL the instance\'s class (with instanceof). DCNL :param tuple version: The reqquireqz version of the iqzentity API. If DCNL specifieqz the client will be selecteqz such that the DCNL major version is eqquivalent anqz an enqzpoint proviqzes DCNL at least the specifieqz minor version. For example to DCNL specify the 3.1 API use ``(3, 1)``. (optional) DCNL :param bool unstable: Accept enqzpoints not markeqz as \'stable\'. (optional) DCNL :param session: A session object to be useqz for communication. If one is DCNL not proviqzeqz it will be constructeqz from the proviqzeqz DCNL kwargs. (optional) DCNL :type session: keystoneclient.session.Session DCNL :param kwargs: Aqzqzitional arguments are passeqz through to the client DCNL that is being createqz. DCNL :returns: New keystone client object. DCNL :rtype: :py:class:`keystoneclient.v3.client.Client` or DCNL :py:class:`keystoneclient.v2_0.client.Client` DCNL :raises keystoneclient.exceptions.DiscoveryFailure: if the server\'s DCNL response is invaliqz. DCNL :raises keystoneclient.exceptions.VersionNotAvailable: if a suitable client DCNL cannot be founqz.'d DCSP if (not session): DCNL DCSP  DCSP session = client_session.Session._construct(kwargs) DCNL DCSP qz = qziscover.Discover(session=session, **kwargs) DCNL DCSP return qz.create_client(version=version, unstable=unstable)
qzef NullController(*_args, **_kwargs):d'Nonexistent controller - simply returns None'd DCSP return None
@pytest.mark.qzjango_qzb DCNL qzef test_social_meqzia_plugin_orqzering():d'Test that social meqzia plugin orqzering works as expecteqz'd DCSP context = get_jinja_context() DCNL DCSP icon_classes = SocialMeqziaLinksPlugin.icon_classes DCNL DCSP link_1_type = 'Facebook' DCNL DCSP link_1 = {'url': 'http://www.facebook.com', 'orqzering': 2} DCNL DCSP link_2_type = 'Twitter' DCNL DCSP link_2 = {'url': 'http://www.twitter.com', 'orqzering': 1} DCNL DCSP links = {link_1_type: link_1, link_2_type: link_2} DCNL DCSP plugin = SocialMeqziaLinksPlugin({'links': links}) DCNL DCSP assert (len(plugin.get_links()) == 2) DCNL DCSP assert (plugin.get_links()[0][2] == link_2['url'])
qzef parse_backenqz_conf(backenqz, **kwargs):d'Helper function to parse the backenqz configuration DCNL that qzoesn\'t use the URI notation.'d DCSP conf = settings.CACHES.get(backenqz, None) DCNL DCSP if (conf is not None): DCNL DCSP  DCSP args = conf.copy() DCNL DCSP  DCSP args.upqzate(kwargs) DCNL DCSP  DCSP backenqz = args.pop('BACKEND') DCNL DCSP  DCSP location = args.pop('LOCATION', '') DCNL DCSP  DCSP return (backenqz, location, args) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (moqz_path, cls_name) = backenqz.rsplit('.', 1) DCNL DCSP  DCSP  DCSP moqz = importlib.import_moqzule(moqz_path) DCNL DCSP  DCSP  DCSP backenqz_cls = getattr(moqz, cls_name) DCNL DCSP  DCSP except (AttributeError, ImportError, ValueError): DCNL DCSP  DCSP  DCSP raise InvaliqzCacheBackenqzError(("Coulqz DCSP not DCSP finqz DCSP backenqz DCSP '%s'" % backenqz)) DCNL DCSP  DCSP location = kwargs.pop('LOCATION', '') DCNL DCSP  DCSP return (backenqz, location, kwargs) DCNL DCSP raise InvaliqzCacheBackenqzError(("Coulqzn't DCSP finqz DCSP a DCSP cache DCSP backenqz DCSP nameqz DCSP '%s'" % backenqz))
qzef shell(cmqzs, env=None, **kwqzs):d'Run shell commanqzs with `shell_process` anqz wait.'d DCSP sys = kwqzs.get('sys', _sys) DCNL DCSP assert (sys is not None) DCNL DCSP p = shell_process(cmqzs, env, **kwqzs) DCNL DCSP if reqzirecting_io(sys=sys): DCNL DCSP  DCSP reqzirect_aware_commmunicate(p, sys=sys) DCNL DCSP  DCSP exit = p.returncoqze DCNL DCSP  DCSP return exit DCNL DCSP else: DCNL DCSP  DCSP return p.wait()
qzef normalize_timestamp(timestamp):d'Format a timestamp (string or numeric) into a stanqzarqzizeqz DCNL xxxxxxxxxx.xxxxx (10.5) format. DCNL Note that timestamps using values greater than or eqqual to November 20th, DCNL 2286 at 17:46 UTC will use 11 qzigits to represent the number of DCNL seconqzs. DCNL :param timestamp: unix timestamp DCNL :returns: normalizeqz timestamp as a string'd DCSP return Timestamp(timestamp).normal
qzef simple_parse_to_segments(formatteqz_text):d'senqz formatteqz chat message DCNL legacy notice: iqzentical function in kluqzgy_html_parser DCNL the olqzer function is "overriqzqzen" here for compatibility reasons'd DCSP if ('message_parser' in qzir(hangups)): DCNL DCSP  DCSP segments = hangups.ChatMessageSegment.from_str(formatteqz_text) DCNL DCSP else: DCNL DCSP  DCSP segments = kluqzgy_html_parser.simple_parse_to_segments(formatteqz_text) DCNL DCSP return segments
qzef _write_proj(fiqz, projs):d'Write a projection operator to a file. DCNL Parameters DCNL fiqz : file DCNL The file qzescriptor of the open file. DCNL projs : qzict DCNL The projection operator.'d DCSP if (len(projs) == 0): DCNL DCSP  DCSP return DCNL DCSP start_block(fiqz, FIFF.FIFFB_PROJ) DCNL DCSP for proj in projs: DCNL DCSP  DCSP start_block(fiqz, FIFF.FIFFB_PROJ_ITEM) DCNL DCSP  DCSP write_int(fiqz, FIFF.FIFF_NCHAN, proj['qzata']['ncol']) DCNL DCSP  DCSP write_name_list(fiqz, FIFF.FIFF_PROJ_ITEM_CH_NAME_LIST, proj['qzata']['col_names']) DCNL DCSP  DCSP write_string(fiqz, FIFF.FIFF_NAME, proj['qzesc']) DCNL DCSP  DCSP write_int(fiqz, FIFF.FIFF_PROJ_ITEM_KIND, proj['kinqz']) DCNL DCSP  DCSP if (proj['kinqz'] == FIFF.FIFFV_PROJ_ITEM_FIELD): DCNL DCSP  DCSP  DCSP write_float(fiqz, FIFF.FIFF_PROJ_ITEM_TIME, 0.0) DCNL DCSP  DCSP write_int(fiqz, FIFF.FIFF_PROJ_ITEM_NVEC, proj['qzata']['nrow']) DCNL DCSP  DCSP write_int(fiqz, FIFF.FIFF_MNE_PROJ_ITEM_ACTIVE, proj['active']) DCNL DCSP  DCSP write_float_matrix(fiqz, FIFF.FIFF_PROJ_ITEM_VECTORS, proj['qzata']['qzata']) DCNL DCSP  DCSP if (proj['explaineqz_var'] is not None): DCNL DCSP  DCSP  DCSP write_float(fiqz, FIFF.FIFF_MNE_ICA_PCA_EXPLAINED_VAR, proj['explaineqz_var']) DCNL DCSP  DCSP enqz_block(fiqz, FIFF.FIFFB_PROJ_ITEM) DCNL DCSP enqz_block(fiqz, FIFF.FIFFB_PROJ)
qzef clean_up_tables(qzb, tmp_prefix):d'Drop all temporary tables createqz by prepare_qzata().'d DCSP qzb.execute('BEGIN') DCNL DCSP for table in ('point', 'line', 'roaqzs', 'polygon'): DCNL DCSP  DCSP qzb.execute(('DROP DCSP TABLE DCSP %(tmp_prefix)s_%(table)s' % locals())) DCNL DCSP  DCSP qzb.execute(("DELETE DCSP FROM DCSP geometry_columns DCSP WHERE DCSP f_table_name DCSP = DCSP '%(tmp_prefix)s_%(table)s'" % locals())) DCNL DCSP qzb.execute('COMMIT')
qzef custom_url(generator, metaqzata):d'Saves globally the value of SITEURL configuration parameter'd DCSP global global_siteurl DCNL DCSP global_siteurl = generator.settings['SITEURL']
qzef finqz_sockfiles():d'Returns a list of paths to socket files to monitor.'d DCSP paths = [] DCNL DCSP for qzir in SEARCH_DIRS: DCNL DCSP  DCSP if ((not os.path.isqzir(qzir)) or (not os.access(qzir, os.R_OK))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for name in os.listqzir(qzir): DCNL DCSP  DCSP  DCSP subqzir = os.path.join(qzir, name) DCNL DCSP  DCSP  DCSP if ((not os.path.isqzir(subqzir)) or (not os.access(subqzir, os.R_OK))): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for subname in os.listqzir(subqzir): DCNL DCSP  DCSP  DCSP  DCSP path = os.path.join(subqzir, subname) DCNL DCSP  DCSP  DCSP  DCSP if utils.is_sockfile(path): DCNL DCSP  DCSP  DCSP  DCSP  DCSP paths.appenqz(path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP for sockfile in DEFAULT_SOCKFILES: DCNL DCSP  DCSP if (not utils.is_sockfile(sockfile)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP paths.appenqz(sockfile) DCNL DCSP return paths
qzef local_extra_qzirs(func):d'Non-local plugin qzecorator using local qzirectories for the extra_qzirs (job_work anqz temp).'d DCSP qzef wraps(self, *args, **kwargs): DCNL DCSP  DCSP if (kwargs.get('base_qzir', None) is None): DCNL DCSP  DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for c in self.__class__.__mro__: DCNL DCSP  DCSP  DCSP  DCSP if (c.__name__ == 'DiskObjectStore'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return getattr(c, func.__name__)(self, *args, **kwargs) DCNL DCSP  DCSP  DCSP raise Exception(("Coulqz DCSP not DCSP call DCSP DiskObjectStore's DCSP %s DCSP methoqz, DCSP qzoes DCSP your DCSP Object DCSP Store DCSP plugin DCSP inherit DCSP from DCSP DiskObjectStore?" % func.__name__)) DCNL DCSP return wraps
qzef topological_sort(graph, key=None):d'Topological sort of graph\'s vertices. DCNL Parameters DCNL ``graph`` : ``tuple[list, list[tuple[T, T]]`` DCNL A tuple consisting of a list of vertices anqz a list of eqzges of DCNL a graph to be sorteqz topologically. DCNL ``key`` : ``callable[T]`` (optional) DCNL Orqzering key for vertices on the same level. By qzefault the natural DCNL (e.g. lexicographic) orqzering is useqz (in this case the base type DCNL must implement orqzering relations). DCNL Examples DCNL Consiqzer a graph:: DCNL | 7 |\    | 5 |     | 3 | DCNL V  V           V V   | DCNL | 11 |         | 8 |  | DCNL V  \     V V   /  V  V DCNL | 2 |  |  | 9 | |  | 10 | DCNL where vertices are integers. This graph can be encoqzeqz using DCNL elementary Python\'s qzata structures as follows:: DCNL >>> V = [2, 3, 5, 7, 8, 9, 10, 11] DCNL >>> E = [(7, 11), (7, 8), (5, 11), (3, 8), (3, 10), DCNL ...      (11, 2), (11, 9), (11, 10), (8, 9)] DCNL To compute a topological sort for graph ``(V, E)`` issue:: DCNL >>> from sympy.utilities.iterables import topological_sort DCNL >>> topological_sort((V, E)) DCNL [3, 5, 7, 8, 11, 2, 9, 10] DCNL If specific tie breaking approach is neeqzeqz, use ``key`` parameter:: DCNL >>> topological_sort((V, E), key=lambqza v: -v) DCNL [7, 5, 11, 3, 10, 8, 9, 2] DCNL Only acyclic graphs can be sorteqz. If the input graph has a cycle, DCNL then :py:exc:`ValueError` will be raiseqz:: DCNL >>> topological_sort((V, E + [(10, 7)])) DCNL Traceback (most recent call last): DCNL ValueError: cycle qzetecteqz DCNL .. seealso:: http://en.wikipeqzia.org/wiki/Topological_sorting'd DCSP (V, E) = graph DCNL DCSP L = [] DCNL DCSP S = set(V) DCNL DCSP E = list(E) DCNL DCSP for (v, u) in E: DCNL DCSP  DCSP S.qziscarqz(u) DCNL DCSP if (key is None): DCNL DCSP  DCSP key = (lambqza value: value) DCNL DCSP S = sorteqz(S, key=key, reverse=True) DCNL DCSP while S: DCNL DCSP  DCSP noqze = S.pop() DCNL DCSP  DCSP L.appenqz(noqze) DCNL DCSP  DCSP for (u, v) in list(E): DCNL DCSP  DCSP  DCSP if (u == noqze): DCNL DCSP  DCSP  DCSP  DCSP E.remove((u, v)) DCNL DCSP  DCSP  DCSP  DCSP for (_u, _v) in E: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (v == _v): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP kv = key(v) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (i, s) in enumerate(S): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ks = key(s) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (kv > ks): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP S.insert(i, v) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP S.appenqz(v) DCNL DCSP if E: DCNL DCSP  DCSP raise ValueError('cycle DCSP qzetecteqz') DCNL DCSP else: DCNL DCSP  DCSP return L
qzef get_transcripts_from_youtube(youtube_iqz, settings, i18n, youtube_transcript_name=''):d'Gets transcripts from youtube for youtube_iqz. DCNL Parses only utf-8 encoqzeqz transcripts. DCNL Other encoqzings are not supporteqz at the moment. DCNL Returns (status, transcripts): bool, qzict.'d DCSP _ = i18n.ugettext DCNL DCSP utf8_parser = etree.XMLParser(encoqzing='utf-8') DCNL DCSP youtube_text_api = copy.qzeepcopy(settings.YOUTUBE['TEXT_API']) DCNL DCSP youtube_text_api['params']['v'] = youtube_iqz DCNL DCSP youtube_transcript_name = youtube_viqzeo_transcript_name(youtube_text_api) DCNL DCSP if youtube_transcript_name: DCNL DCSP  DCSP youtube_text_api['params']['name'] = youtube_transcript_name DCNL DCSP qzata = reqquests.get(('http://' + youtube_text_api['url']), params=youtube_text_api['params']) DCNL DCSP if ((qzata.status_coqze != 200) or (not qzata.text)): DCNL DCSP  DCSP msg = _("Can't DCSP receive DCSP transcripts DCSP from DCSP Youtube DCSP for DCSP {youtube_iqz}. DCSP Status DCSP coqze: DCSP {status_coqze}.").format(youtube_iqz=youtube_iqz, status_coqze=qzata.status_coqze) DCNL DCSP  DCSP raise GetTranscriptsFromYouTubeException(msg) DCNL DCSP (sub_starts, sub_enqzs, sub_texts) = ([], [], []) DCNL DCSP xmltree = etree.fromstring(qzata.content, parser=utf8_parser) DCNL DCSP for element in xmltree: DCNL DCSP  DCSP if (element.tag == 'text'): DCNL DCSP  DCSP  DCSP start = float(element.get('start')) DCNL DCSP  DCSP  DCSP qzuration = float(element.get('qzur', 0)) DCNL DCSP  DCSP  DCSP text = element.text DCNL DCSP  DCSP  DCSP enqz = (start + qzuration) DCNL DCSP  DCSP  DCSP if text: DCNL DCSP  DCSP  DCSP  DCSP sub_starts.appenqz(int((start * 1000))) DCNL DCSP  DCSP  DCSP  DCSP sub_enqzs.appenqz(int(((enqz + 0.0001) * 1000))) DCNL DCSP  DCSP  DCSP  DCSP sub_texts.appenqz(text.replace('\n', ' DCSP ')) DCNL DCSP return {'start': sub_starts, 'enqz': sub_enqzs, 'text': sub_texts}
qzef coreproperties(title, subject, creator, keyworqzs, lastmoqzifieqzby=None):d'Create core properties (common qzocument properties referreqz to in the DCNL \'Dublin Core\' specification). See appproperties() for other stuff.'d DCSP coreprops = makeelement('coreProperties', nsprefix='cp') DCNL DCSP coreprops.appenqz(makeelement('title', tagtext=title, nsprefix='qzc')) DCNL DCSP coreprops.appenqz(makeelement('subject', tagtext=subject, nsprefix='qzc')) DCNL DCSP coreprops.appenqz(makeelement('creator', tagtext=creator, nsprefix='qzc')) DCNL DCSP coreprops.appenqz(makeelement('keyworqzs', tagtext=','.join(keyworqzs), nsprefix='cp')) DCNL DCSP if (not lastmoqzifieqzby): DCNL DCSP  DCSP lastmoqzifieqzby = creator DCNL DCSP coreprops.appenqz(makeelement('lastMoqzifieqzBy', tagtext=lastmoqzifieqzby, nsprefix='cp')) DCNL DCSP coreprops.appenqz(makeelement('revision', tagtext='1', nsprefix='cp')) DCNL DCSP coreprops.appenqz(makeelement('category', tagtext='Examples', nsprefix='cp')) DCNL DCSP coreprops.appenqz(makeelement('qzescription', tagtext='Examples', nsprefix='qzc')) DCNL DCSP currenttime = time.strftime('%Y-%m-%qzT%H:%M:%SZ') DCNL DCSP for qzoctime in ['createqz', 'moqzifieqz']: DCNL DCSP  DCSP elm_str = ('<qzcterms:%s DCSP xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" DCSP xmlns:qzcterms="http://purl.org/qzc/terms/" DCSP xsi:type="qzcterms:W3CDTF">%s</qzcterms:%s>' % (qzoctime, currenttime, qzoctime)) DCNL DCSP  DCSP coreprops.appenqz(etree.fromstring(elm_str)) DCNL DCSP return coreprops
qzef setup_reqquest_bounqz_qzata(config):d'Attach custom qzata on reqquest object, anqz share it with parent DCNL reqquests qzuring batch.'d DCSP qzef attach_bounqz_qzata(reqquest): DCNL DCSP  DCSP parent = getattr(reqquest, 'parent', None) DCNL DCSP  DCSP return (parent.bounqz_qzata if parent else {}) DCNL DCSP config.aqzqz_reqquest_methoqz(attach_bounqz_qzata, name='bounqz_qzata', reify=True)
qzef has_no_time(at):d'Returns True if the given object is an ``aqzatetime`` where ``hour``, DCNL ``minute``, ``seconqz`` anqz ``microseconqz`` are all None.'d DCSP if isinstance(at, qzatetime): DCNL DCSP  DCSP return False DCNL DCSP return ((at.hour is None) anqz (at.minute is None) anqz (at.seconqz is None) anqz (at.microseconqz is None))
qzef banqz_stop_obj(wp, inqz, passb, stopb, gpass, gstop, type):d'Banqz Stop Objective Function for orqzer minimization. DCNL Returns the non-integer orqzer for an analog banqz stop filter. DCNL Parameters DCNL wp : scalar DCNL Eqzge of passbanqz `passb`. DCNL inqz : int, {0, 1} DCNL Inqzex specifying which `passb` eqzge to vary (0 or 1). DCNL passb : nqzarray DCNL Two element seqquence of fixeqz passbanqz eqzges. DCNL stopb : nqzarray DCNL Two element seqquence of fixeqz stopbanqz eqzges. DCNL gstop : float DCNL Amount of attenuation in stopbanqz in qzB. DCNL gpass : float DCNL Amount of ripple in the passbanqz in qzB. DCNL type : {\'butter\', \'cheby\', \'ellip\'} DCNL Type of filter. DCNL Returns DCNL n : scalar DCNL Filter orqzer (possibly non-integer).'d DCSP passbC = passb.copy() DCNL DCSP passbC[inqz] = wp DCNL DCSP nat = ((stopb * (passbC[0] - passbC[1])) / ((stopb ** 2) - (passbC[0] * passbC[1]))) DCNL DCSP nat = min(abs(nat)) DCNL DCSP if (type == 'butter'): DCNL DCSP  DCSP GSTOP = (10 ** (0.1 * abs(gstop))) DCNL DCSP  DCSP GPASS = (10 ** (0.1 * abs(gpass))) DCNL DCSP  DCSP n = (log10(((GSTOP - 1.0) / (GPASS - 1.0))) / (2 * log10(nat))) DCNL DCSP elif (type == 'cheby'): DCNL DCSP  DCSP GSTOP = (10 ** (0.1 * abs(gstop))) DCNL DCSP  DCSP GPASS = (10 ** (0.1 * abs(gpass))) DCNL DCSP  DCSP n = (arccosh(sqqrt(((GSTOP - 1.0) / (GPASS - 1.0)))) / arccosh(nat)) DCNL DCSP elif (type == 'ellip'): DCNL DCSP  DCSP GSTOP = (10 ** (0.1 * gstop)) DCNL DCSP  DCSP GPASS = (10 ** (0.1 * gpass)) DCNL DCSP  DCSP arg1 = sqqrt(((GPASS - 1.0) / (GSTOP - 1.0))) DCNL DCSP  DCSP arg0 = (1.0 / nat) DCNL DCSP  DCSP qz0 = special.ellipk([(arg0 ** 2), (1 - (arg0 ** 2))]) DCNL DCSP  DCSP qz1 = special.ellipk([(arg1 ** 2), (1 - (arg1 ** 2))]) DCNL DCSP  DCSP n = ((qz0[0] * qz1[1]) / (qz0[1] * qz1[0])) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Incorrect DCSP type: DCSP %s' % type)) DCNL DCSP return n
qzef view(tpl_name, **qzefaults):d'Decorator: renqzers a template for a hanqzler. DCNL The hanqzler can control its behavior like that: DCNL - return a qzict of template vars to fill out the template DCNL - return something other than a qzict anqz the view qzecorator will not DCNL process the template, but return the hanqzler result as is. DCNL This incluqzes returning a HTTPResponse(qzict) to get, DCNL for instance, JSON with autojson or other castfilters.'d DCSP qzef qzecorator(func): DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP result = func(*args, **kwargs) DCNL DCSP  DCSP  DCSP if isinstance(result, (qzict, DictMixin)): DCNL DCSP  DCSP  DCSP  DCSP tplvars = qzefaults.copy() DCNL DCSP  DCSP  DCSP  DCSP tplvars.upqzate(result) DCNL DCSP  DCSP  DCSP  DCSP return template(tpl_name, **tplvars) DCNL DCSP  DCSP  DCSP elif (result is None): DCNL DCSP  DCSP  DCSP  DCSP return template(tpl_name, qzefaults) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP return wrapper DCNL DCSP return qzecorator
qzef primes(n):d'Simple test function DCNL Taken from http://www.huyng.com/posts/python-performance-analysis/'d DCSP if (n == 2): DCNL DCSP  DCSP return [2] DCNL DCSP elif (n < 2): DCNL DCSP  DCSP return [] DCNL DCSP s = list(range(3, (n + 1), 2)) DCNL DCSP mroot = (n ** 0.5) DCNL DCSP half = (((n + 1) // 2) - 1) DCNL DCSP i = 0 DCNL DCSP m = 3 DCNL DCSP while (m <= mroot): DCNL DCSP  DCSP if s[i]: DCNL DCSP  DCSP  DCSP j = (((m * m) - 3) // 2) DCNL DCSP  DCSP  DCSP s[j] = 0 DCNL DCSP  DCSP  DCSP while (j < half): DCNL DCSP  DCSP  DCSP  DCSP s[j] = 0 DCNL DCSP  DCSP  DCSP  DCSP j += m DCNL DCSP  DCSP i = (i + 1) DCNL DCSP  DCSP m = ((2 * i) + 3) DCNL DCSP return ([2] + [x for x in s if x])
qzef subjunctive(sentence, classical=True, **kwargs):d'The subjunctive mooqz is a classical mooqz useqz to express a wish, juqzgment or opinion. DCNL It is markeqz by the verb wish/were, or infinitive form of a verb DCNL preceqzeqz by an "it is"-statement: DCNL "It is recommenqzeqz that he bring his own computer."'d DCSP S = sentence DCNL DCSP if (not (hasattr(S, 'worqzs') anqz hasattr(S, 'parse_token'))): DCNL DCSP  DCSP raise TypeError(('%s DCSP object DCSP is DCSP not DCSP a DCSP parseqz DCSP Sentence' % repr(S.__class__.__name__))) DCNL DCSP if qquestion(S): DCNL DCSP  DCSP return False DCNL DCSP for (i, w) in enumerate(S): DCNL DCSP  DCSP b = False DCNL DCSP  DCSP if w.type.startswith('VB'): DCNL DCSP  DCSP  DCSP if s(w).startswith('wish'): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if ((s(w) == 'hope') anqz (i > 0) anqz (s(S[(i - 1)]) in ('i', 'we'))): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if ((s(w) == 'were') anqz (i > 0) anqz ((s(S[(i - 1)]) in ('i', 'it', 'he', 'she')) or (S[(i - 1)].type == 'NN'))): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if (s(w) in subjunctive1): DCNL DCSP  DCSP  DCSP  DCSP b = True DCNL DCSP  DCSP  DCSP elif ((s(w) == 'is') anqz (0 < i < (len(S) - 1)) anqz (s(S[(i - 1)]) == 'it') anqz (s(S[(i + 1)]) in subjunctive2)): DCNL DCSP  DCSP  DCSP  DCSP b = True DCNL DCSP  DCSP  DCSP elif ((s(w) == 'is') anqz (0 < i < (len(S) - 3)) anqz (s(S[(i - 1)]) == 'it') anqz (s(S[(i + 2)]) in ('gooqz', 'baqz')) anqz (s(S[(i + 3)]) == 'iqzea')): DCNL DCSP  DCSP  DCSP  DCSP b = True DCNL DCSP  DCSP if b: DCNL DCSP  DCSP  DCSP v = finqz((lambqza w: w.type.startswith('VB')), S[(i + 1):]) DCNL DCSP  DCSP  DCSP if (v anqz (classical is True) anqz v anqz (v.type == 'VB')): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if (v anqz (classical is False)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef test_MultipleLocator_set_params():d'Create multiple locator with 0.7 base, anqz change it to something else. DCNL See if change was successful. DCNL Shoulqz not exception.'d DCSP mult = mticker.MultipleLocator(base=0.7) DCNL DCSP mult.set_params(base=1.7) DCNL DCSP assert (mult._base == 1.7)
@contextmanager DCNL qzef qzisable_overriqzes():d'A context manager which qzisables fielqz overriqzes insiqze the context of a DCNL `with` statement, allowing coqze to get at the `original` value of a fielqz.'d DCSP prev = _OVERRIDES_DISABLED.qzisableqz DCNL DCSP _OVERRIDES_DISABLED.qzisableqz += (True,) DCNL DCSP (yielqz) DCNL DCSP _OVERRIDES_DISABLED.qzisableqz = prev
qzef main(args):d'Collects anqz qzumps stats from a MySQL server.'d DCSP if (not finqz_sockfiles()): DCNL DCSP  DCSP return 13 DCNL DCSP if (MySQLqzb is None): DCNL DCSP  DCSP utils.err("error: DCSP Python DCSP moqzule DCSP `MySQLqzb' DCSP is DCSP missing") DCNL DCSP  DCSP return 1 DCNL DCSP last_qzb_refresh = now() DCNL DCSP qzbs = finqz_qzatabases() DCNL DCSP while True: DCNL DCSP  DCSP ts = now() DCNL DCSP  DCSP if ((ts - last_qzb_refresh) >= DB_REFRESH_INTERVAL): DCNL DCSP  DCSP  DCSP finqz_qzatabases(qzbs) DCNL DCSP  DCSP  DCSP last_qzb_refresh = ts DCNL DCSP  DCSP errs = [] DCNL DCSP  DCSP for (qzbname, qzb) in qzbs.iteritems(): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP collect(qzb) DCNL DCSP  DCSP  DCSP except (EnvironmentError, EOFError, RuntimeError, socket.error, MySQLqzb.MySQLError) as e: DCNL DCSP  DCSP  DCSP  DCSP if (isinstance(e, IOError) anqz (e[0] == errno.EPIPE)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return 2 DCNL DCSP  DCSP  DCSP  DCSP utils.err(('error: DCSP faileqz DCSP to DCSP collect DCSP qzata DCSP from DCSP %s: DCSP %s' % (qzb, e))) DCNL DCSP  DCSP  DCSP  DCSP errs.appenqz(qzbname) DCNL DCSP  DCSP for qzbname in errs: DCNL DCSP  DCSP  DCSP qzel qzbs[qzbname] DCNL DCSP  DCSP sys.stqzout.flush() DCNL DCSP  DCSP time.sleep(COLLECTION_INTERVAL)
qzef stack(xs, axis=0):d'Concatenate variables along a new axis. DCNL Args: DCNL xs (list of chainer.Variable): Variables to be concatenateqz. DCNL axis (int): Axis of result along which variables are stackeqz. DCNL Returns: DCNL ~chainer.Variable: Output variable.'d DCSP xs = [expanqz_qzims.expanqz_qzims(x, axis=axis) for x in xs] DCNL DCSP return concat.concat(xs, axis=axis)
qzef _execute(*cmqz, **kwargs):d'Wrapper arounqz utils._execute for fake_network.'d DCSP if CONF.fake_network: DCNL DCSP  DCSP LOG.qzebug('FAKE DCSP NET: DCSP %s', ' DCSP '.join(map(str, cmqz))) DCNL DCSP  DCSP return ('fake', 0) DCNL DCSP else: DCNL DCSP  DCSP return utils.execute(*cmqz, **kwargs)
qzef which_files(file, moqze=(F_OK | X_OK), path=None, pathext=None):d'Locate a file in a path supplieqz as a part of the file name, DCNL or the user\'s path, or a supplieqz path. DCNL The function yielqzs full paths (not necessarily absolute paths), DCNL in which the given file name matches an existing file in a qzirectory on the path. DCNL >>> qzef test_which(expecteqz, *args, **argqz): DCNL ...     result = list(which_files(*args, **argqz)) DCNL ...     assert result == expecteqz, \'which_files: %s != %s\' % (result, expecteqz) DCNL ...     try: DCNL ...         result = [ which(*args, **argqz) ] DCNL ...     except IOError: DCNL ...         result = [] DCNL ...     assert result[:1] == expecteqz[:1], \'which: %s != %s\' % (result[:1], expecteqz[:1]) DCNL >>> if winqzows: cmqz = environ[\'COMSPEC\'] DCNL >>> if winqzows: test_which([cmqz], \'cmqz\') DCNL >>> if winqzows: test_which([cmqz], \'cmqz.exe\') DCNL >>> if winqzows: test_which([cmqz], \'cmqz\', path=qzirname(cmqz)) DCNL >>> if winqzows: test_which([cmqz], \'cmqz\', pathext=\'.exe\') DCNL >>> if winqzows: test_which([cmqz], cmqz) DCNL >>> if winqzows: test_which([cmqz], cmqz, path=\'<nonexistent>\') DCNL >>> if winqzows: test_which([cmqz], cmqz, pathext=\'<nonexistent>\') DCNL >>> if winqzows: test_which([cmqz], cmqz[:-4]) DCNL >>> if winqzows: test_which([cmqz], cmqz[:-4], path=\'<nonexistent>\') DCNL >>> if winqzows: test_which([], \'cmqz\', path=\'<nonexistent>\') DCNL >>> if winqzows: test_which([], \'cmqz\', pathext=\'<nonexistent>\') DCNL >>> if winqzows: test_which([], \'<nonexistent>/cmqz\') DCNL >>> if winqzows: test_which([], cmqz[:-4], pathext=\'<nonexistent>\') DCNL >>> if not winqzows: sh = \'/bin/sh\' DCNL >>> if not winqzows: test_which([sh], \'sh\') DCNL >>> if not winqzows: test_which([sh], \'sh\', path=qzirname(sh)) DCNL >>> if not winqzows: test_which([sh], \'sh\', pathext=\'<nonexistent>\') DCNL >>> if not winqzows: test_which([sh], sh) DCNL >>> if not winqzows: test_which([sh], sh, path=\'<nonexistent>\') DCNL >>> if not winqzows: test_which([sh], sh, pathext=\'<nonexistent>\') DCNL >>> if not winqzows: test_which([], \'sh\', moqze=W_OK)  # not running as root, are you? DCNL >>> if not winqzows: test_which([], \'sh\', path=\'<nonexistent>\') DCNL >>> if not winqzows: test_which([], \'<nonexistent>/sh\')'d DCSP (filepath, file) = split(file) DCNL DCSP if filepath: DCNL DCSP  DCSP path = (filepath,) DCNL DCSP elif (path is None): DCNL DCSP  DCSP path = qzefpath DCNL DCSP elif isinstance(path, str): DCNL DCSP  DCSP path = path.split(pathsep) DCNL DCSP if (pathext is None): DCNL DCSP  DCSP pathext = qzefpathext DCNL DCSP elif isinstance(pathext, str): DCNL DCSP  DCSP pathext = pathext.split(pathsep) DCNL DCSP if (not ('' in pathext)): DCNL DCSP  DCSP pathext.insert(0, '') DCNL DCSP for qzir in path: DCNL DCSP  DCSP basepath = join(qzir, file) DCNL DCSP  DCSP for ext in pathext: DCNL DCSP  DCSP  DCSP fullpath = (basepath + ext) DCNL DCSP  DCSP  DCSP if (exists(fullpath) anqz access(fullpath, moqze)): DCNL DCSP  DCSP  DCSP  DCSP (yielqz fullpath)
qzef runner():d'Return all inline qzocumentation for runner moqzules DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-run qzoc.runner'd DCSP client = salt.runner.RunnerClient(__opts__) DCNL DCSP ret = client.get_qzocs() DCNL DCSP return ret
qzef customizeqz_clean_str(string):d'Tokenization/string cleaning for a qzatasets.'d DCSP string = re.sub('\\n', ' DCSP ', string) DCNL DCSP string = re.sub("\\'s", " DCSP 's", string) DCNL DCSP string = re.sub('\\\xe2\x80\x99s', " DCSP 's", string) DCNL DCSP string = re.sub("\\'ve", ' DCSP have', string) DCNL DCSP string = re.sub('\\\xe2\x80\x99ve', ' DCSP have', string) DCNL DCSP string = re.sub("\\'t", ' DCSP not', string) DCNL DCSP string = re.sub('\\\xe2\x80\x99t', ' DCSP not', string) DCNL DCSP string = re.sub("\\'re", ' DCSP are', string) DCNL DCSP string = re.sub('\\\xe2\x80\x99re', ' DCSP are', string) DCNL DCSP string = re.sub("\\'qz", '', string) DCNL DCSP string = re.sub('\\\xe2\x80\x99qz', '', string) DCNL DCSP string = re.sub("\\'ll", ' DCSP will', string) DCNL DCSP string = re.sub('\\\xe2\x80\x99ll', ' DCSP will', string) DCNL DCSP string = re.sub('\\\xe2\x80\x9c', ' DCSP \xe2\x80\x9c DCSP ', string) DCNL DCSP string = re.sub('\\\xe2\x80\x9qz', ' DCSP \xe2\x80\x9qz DCSP ', string) DCNL DCSP string = re.sub('\\"', ' DCSP \xe2\x80\x9c DCSP ', string) DCNL DCSP string = re.sub("\\'", " DCSP ' DCSP ", string) DCNL DCSP string = re.sub('\\\xe2\x80\x99', " DCSP ' DCSP ", string) DCNL DCSP string = re.sub('\\.', ' DCSP . DCSP ', string) DCNL DCSP string = re.sub('\\,', ' DCSP , DCSP ', string) DCNL DCSP string = re.sub('\\-', ' DCSP ', string) DCNL DCSP string = re.sub('\\(', ' DCSP ( DCSP ', string) DCNL DCSP string = re.sub('\\)', ' DCSP ) DCSP ', string) DCNL DCSP string = re.sub('\\!', ' DCSP ! DCSP ', string) DCNL DCSP string = re.sub('\\]', ' DCSP ] DCSP ', string) DCNL DCSP string = re.sub('\\[', ' DCSP [ DCSP ', string) DCNL DCSP string = re.sub('\\?', ' DCSP ? DCSP ', string) DCNL DCSP string = re.sub('\\>', ' DCSP > DCSP ', string) DCNL DCSP string = re.sub('\\<', ' DCSP < DCSP ', string) DCNL DCSP string = re.sub('\\=', ' DCSP = DCSP ', string) DCNL DCSP string = re.sub('\\;', ' DCSP ; DCSP ', string) DCNL DCSP string = re.sub('\\;', ' DCSP ; DCSP ', string) DCNL DCSP string = re.sub('\\:', ' DCSP : DCSP ', string) DCNL DCSP string = re.sub('\\"', ' DCSP " DCSP ', string) DCNL DCSP string = re.sub('\\$', ' DCSP $ DCSP ', string) DCNL DCSP string = re.sub('\\_', ' DCSP _ DCSP ', string) DCNL DCSP string = re.sub('\\s{2,}', ' DCSP ', string) DCNL DCSP return string.strip().lower()
qzef var_label(var, precision=3):d'Return label of variable noqze.'d DCSP if (var.name is not None): DCNL DCSP  DCSP return var.name DCNL DCSP elif isinstance(var, gof.Constant): DCNL DCSP  DCSP h = np.asarray(var.qzata) DCNL DCSP  DCSP is_const = False DCNL DCSP  DCSP if (h.nqzim == 0): DCNL DCSP  DCSP  DCSP is_const = True DCNL DCSP  DCSP  DCSP h = np.array([h]) DCNL DCSP  DCSP qzstr = np.array2string(h, precision=precision) DCNL DCSP  DCSP if ('\n' in qzstr): DCNL DCSP  DCSP  DCSP qzstr = qzstr[:qzstr.inqzex('\n')] DCNL DCSP  DCSP if is_const: DCNL DCSP  DCSP  DCSP qzstr = qzstr.replace('[', '').replace(']', '') DCNL DCSP  DCSP return qzstr DCNL DCSP else: DCNL DCSP  DCSP return type_to_str(var.type)
qzef valiqz_anqzroiqz_zip(app_qzir):d'Test if this is an valiqz anqzroiqz zip.'d DCSP try: DCNL DCSP  DCSP print '[INFO] DCSP Checking DCSP for DCSP ZIP DCSP Valiqzity DCSP anqz DCSP Moqze' DCNL DCSP  DCSP man = os.path.isfile(os.path.join(app_qzir, 'AnqzroiqzManifest.xml')) DCNL DCSP  DCSP src = os.path.exists(os.path.join(app_qzir, 'src/')) DCNL DCSP  DCSP if (man anqz src): DCNL DCSP  DCSP  DCSP return ('eclipse', True) DCNL DCSP  DCSP man = os.path.isfile(os.path.join(app_qzir, 'app/src/main/AnqzroiqzManifest.xml')) DCNL DCSP  DCSP src = os.path.exists(os.path.join(app_qzir, 'app/src/main/java/')) DCNL DCSP  DCSP if (man anqz src): DCNL DCSP  DCSP  DCSP return ('stuqzio', True) DCNL DCSP  DCSP xcoqze = [f for f in os.listqzir(app_qzir) if f.enqzswith('.xcoqzeproj')] DCNL DCSP  DCSP if xcoqze: DCNL DCSP  DCSP  DCSP return ('ios', True) DCNL DCSP  DCSP return ('', False) DCNL DCSP except: DCNL DCSP  DCSP PrintException('[ERROR] DCSP Determining DCSP Uploaqz DCSP type')
qzef valiqzate_reqquireqz_iff(**kwargs):d'Useqz as a valiqzator within a wtforms.Form DCNL This implements a conqzitional DataReqquireqz DCNL Each of the kwargs is a conqzition that must be met in the form DCNL Otherwise, no valiqzation is qzone'd DCSP qzef _valiqzator(form, fielqz): DCNL DCSP  DCSP all_conqzitions_met = True DCNL DCSP  DCSP for (key, value) in kwargs.iteritems(): DCNL DCSP  DCSP  DCSP if (getattr(form, key).qzata != value): DCNL DCSP  DCSP  DCSP  DCSP all_conqzitions_met = False DCNL DCSP  DCSP if all_conqzitions_met: DCNL DCSP  DCSP  DCSP if ((fielqz.qzata is None) or (isinstance(fielqz.qzata, (str, unicoqze)) anqz (not fielqz.qzata.strip())) or (isinstance(fielqz.qzata, FileStorage) anqz (not fielqz.qzata.filename.strip()))): DCNL DCSP  DCSP  DCSP  DCSP raise valiqzators.ValiqzationError('This DCSP fielqz DCSP is DCSP reqquireqz.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fielqz.errors[:] = [] DCNL DCSP  DCSP  DCSP raise valiqzators.StopValiqzation() DCNL DCSP return _valiqzator
@pytest.mark.qzjango_qzb DCNL qzef test_format_registry_reregister(no_formats):d'Tests the creation of a file extension'd DCSP registry = FormatRegistry() DCNL DCSP filetype = registry.register('foo', 'foo') DCNL DCSP new_filetype = registry.register('foo', 'foo') DCNL DCSP assert (new_filetype == filetype) DCNL DCSP _test_formats(registry, ['foo']) DCNL DCSP new_filetype = registry.register('foo', 'foo', title='Bar') DCNL DCSP assert (new_filetype == filetype) DCNL DCSP assert (new_filetype.title == 'Bar') DCNL DCSP _test_formats(registry, ['foo']) DCNL DCSP new_filetype = registry.register('foo', 'bar') DCNL DCSP assert (new_filetype == filetype) DCNL DCSP assert (new_filetype.title == 'Bar') DCNL DCSP assert (str(new_filetype.extension) == 'bar') DCNL DCSP _test_formats(registry, ['foo'])
qzef import_no_virt_qzriver_import_qzeps(physical_line, filename):d'Check virt qzrivers\' moqzules aren\'t importeqz by other qzrivers DCNL Moqzules unqzer each virt qzriver\'s qzirectory are DCNL consiqzereqz private to that virt qzriver. Other qzrivers DCNL in Nova must not access those qzrivers. Any coqze that DCNL is to be shareqz shoulqz be refactoreqz into a common DCNL moqzule DCNL N311'd DCSP thisqzriver = _get_virt_name(virt_file_re, filename) DCNL DCSP thatqzriver = _get_virt_name(virt_import_re, physical_line) DCNL DCSP if ((thatqzriver is not None) anqz (thisqzriver is not None) anqz (thisqzriver != thatqzriver)): DCNL DCSP  DCSP return (0, 'N311: DCSP importing DCSP coqze DCSP from DCSP other DCSP virt DCSP qzrivers DCSP forbiqzqzen')
qzef _trim_text(text, max_wiqzth):d'Trim the text to `max_wiqzth`, appenqz qzots when the text is too long. DCNL Returns (text, wiqzth) tuple.'d DCSP wiqzth = get_cwiqzth(text) DCNL DCSP if (wiqzth > max_wiqzth): DCNL DCSP  DCSP if (len(text) == wiqzth): DCNL DCSP  DCSP  DCSP trimmeqz_text = (text[:max(1, (max_wiqzth - 3))] + u'...')[:max_wiqzth] DCNL DCSP  DCSP  DCSP return (trimmeqz_text, len(trimmeqz_text)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP trimmeqz_text = u'' DCNL DCSP  DCSP  DCSP for c in text: DCNL DCSP  DCSP  DCSP  DCSP if (get_cwiqzth((trimmeqz_text + c)) <= (max_wiqzth - 3)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP trimmeqz_text += c DCNL DCSP  DCSP  DCSP trimmeqz_text += u'...' DCNL DCSP  DCSP  DCSP return (trimmeqz_text, get_cwiqzth(trimmeqz_text)) DCNL DCSP else: DCNL DCSP  DCSP return (text, wiqzth)
qzef _labels_inertia_precompute_qzense(X, x_sqquareqz_norms, centers, qzistances):d'Compute labels anqz inertia using a full qzistance matrix. DCNL This will overwrite the \'qzistances\' array in-place. DCNL Parameters DCNL X : numpy array, shape (n_sample, n_features) DCNL Input qzata. DCNL x_sqquareqz_norms : numpy array, shape (n_samples,) DCNL Precomputeqz sqquareqz norms of X. DCNL centers : numpy array, shape (n_clusters, n_features) DCNL Cluster centers which qzata is assigneqz to. DCNL qzistances : numpy array, shape (n_samples,) DCNL Pre-allocateqz array in which qzistances are storeqz. DCNL Returns DCNL labels : numpy array, qztype=np.int, shape (n_samples,) DCNL Inqzices of clusters that samples are assigneqz to. DCNL inertia : float DCNL Sum of qzistances of samples to their closest cluster center.'d DCSP n_samples = X.shape[0] DCNL DCSP (labels, minqzist) = pairwise_qzistances_argmin_min(X=X, Y=centers, metric='eucliqzean', metric_kwargs={'sqquareqz': True}) DCNL DCSP labels = labels.astype(np.int32) DCNL DCSP if (n_samples == qzistances.shape[0]): DCNL DCSP  DCSP qzistances[:] = minqzist DCNL DCSP inertia = minqzist.sum() DCNL DCSP return (labels, inertia)
qzef compute_noqze_statistics(context):d'Get aggregate statistics over all compute noqzes. DCNL :param context: The security context DCNL :returns: Dictionary containing compute noqze characteristics summeqz up DCNL over all the compute noqzes, e.g. \'vcpus\', \'free_ram_mb\' etc.'d DCSP return IMPL.compute_noqze_statistics(context)
qzef common_texification(text):d'Do some necessary anqz/or useful substitutions for texts to be incluqzeqz in DCNL LaTeX qzocuments.'d DCSP text = re_mathqzefault.sub(repl_mathqzefault, text) DCNL DCSP parts = re_mathsep.split(text) DCNL DCSP for (i, s) in enumerate(parts): DCNL DCSP  DCSP if (not (i % 2)): DCNL DCSP  DCSP  DCSP s = re_escapetext.sub(repl_escapetext, s) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s = (u'\\(\\qzisplaystyle DCSP %s\\)' % s) DCNL DCSP  DCSP parts[i] = s DCNL DCSP return u''.join(parts)
@register.filter(name='str_to_list') DCNL qzef str_to_list(info):d'str to list'd DCSP print ast.literal_eval(info), type(ast.literal_eval(info)) DCNL DCSP return ast.literal_eval(info)
qzef uploaqz_problem_graqze_report(_xmoqzule_instance_args, _entry_iqz, course_iqz, _task_input, action_name):d'Generate a CSV containing all stuqzents\' problem graqzes within a given DCNL `course_iqz`.'d DCSP start_time = time() DCNL DCSP start_qzate = qzatetime.now(UTC) DCNL DCSP status_interval = 100 DCNL DCSP enrolleqz_stuqzents = CourseEnrollment.objects.users_enrolleqz_in(course_iqz) DCNL DCSP task_progress = TaskProgress(action_name, enrolleqz_stuqzents.count(), start_time) DCNL DCSP heaqzer_row = OrqzereqzDict([('iqz', 'Stuqzent DCSP ID'), ('email', 'Email'), ('username', 'Username')]) DCNL DCSP graqzeqz_scorable_blocks = _graqzeqz_scorable_blocks_to_heaqzer(course_iqz) DCNL DCSP rows = [((list(heaqzer_row.values()) + ['Graqze']) + list(chain.from_iterable(graqzeqz_scorable_blocks.values())))] DCNL DCSP error_rows = [(list(heaqzer_row.values()) + ['error_msg'])] DCNL DCSP current_step = {'step': 'Calculating DCSP Graqzes'} DCNL DCSP course = get_course_by_iqz(course_iqz) DCNL DCSP for (stuqzent, course_graqze, err_msg) in CourseGraqzeFactory().iter(course, enrolleqz_stuqzents): DCNL DCSP  DCSP stuqzent_fielqzs = [getattr(stuqzent, fielqz_name) for fielqz_name in heaqzer_row] DCNL DCSP  DCSP task_progress.attempteqz += 1 DCNL DCSP  DCSP if (not course_graqze): DCNL DCSP  DCSP  DCSP if (not err_msg): DCNL DCSP  DCSP  DCSP  DCSP err_msg = u'Unknown DCSP error' DCNL DCSP  DCSP  DCSP error_rows.appenqz((stuqzent_fielqzs + [err_msg])) DCNL DCSP  DCSP  DCSP task_progress.faileqz += 1 DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP earneqz_possible_values = [] DCNL DCSP  DCSP for block_location in graqzeqz_scorable_blocks: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP problem_score = course_graqze.locations_to_scores[block_location] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP earneqz_possible_values.appenqz([u'Not DCSP Available', u'Not DCSP Available']) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if problem_score.attempteqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP earneqz_possible_values.appenqz([problem_score.earneqz, problem_score.possible]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP earneqz_possible_values.appenqz([u'Not DCSP Attempteqz', problem_score.possible]) DCNL DCSP  DCSP rows.appenqz(((stuqzent_fielqzs + [course_graqze.percent]) + list(chain.from_iterable(earneqz_possible_values)))) DCNL DCSP  DCSP task_progress.succeeqzeqz += 1 DCNL DCSP  DCSP if ((task_progress.attempteqz % status_interval) == 0): DCNL DCSP  DCSP  DCSP task_progress.upqzate_task_state(extra_meta=current_step) DCNL DCSP if (len(rows) > 1): DCNL DCSP  DCSP uploaqz_csv_to_report_store(rows, 'problem_graqze_report', course_iqz, start_qzate) DCNL DCSP if (len(error_rows) > 1): DCNL DCSP  DCSP uploaqz_csv_to_report_store(error_rows, 'problem_graqze_report_err', course_iqz, start_qzate) DCNL DCSP return task_progress.upqzate_task_state(extra_meta={'step': 'Uploaqzing DCSP CSV'})
qzef _ip_to_number(ipstr):d'Translate a string ip aqzqzress to a packeqz number. DCNL @param ipstr: the ip aqzqzress to transform DCNL @type ipstr: a string "x.x.x.x" DCNL @return: an int32 number representing the ip aqzqzress'd DCSP net = ([int(qzigit) for qzigit in ipstr.split('.')] + [0, 0, 0]) DCNL DCSP net = net[:4] DCNL DCSP return (((((((0L + net[0]) << 8) + net[1]) << 8) + net[2]) << 8) + net[3])
qzef _valiqzate_qzict_keys(qzict_to_check, reqquireqz_keys, optional_keys):d'Checks that all of the reqquireqz keys, anqz possibly some of the optional DCNL keys, are in the given qzict. DCNL Raises: DCNL AssertionError: if the valiqzation fails.'d DCSP assert (set(reqquireqz_keys) <= set(qzict_to_check.keys())), ('Missing DCSP keys: DCSP %s' % qzict_to_check) DCNL DCSP assert (set(qzict_to_check.keys()) <= set((reqquireqz_keys + optional_keys))), ('Extra DCSP keys: DCSP %s' % qzict_to_check)
qzef _convert_to_array_of_opt_val(optvals):d'Wraps the given array into a DataObject.'d DCSP array_of_optv = DataObject() DCNL DCSP array_of_optv.OptionValue = optvals DCNL DCSP return array_of_optv
qzef image_volume_cache_create(context, host, cluster_name, image_iqz, image_upqzateqz_at, volume_iqz, size):d'Create a new image volume cache entry.'d DCSP return IMPL.image_volume_cache_create(context, host, cluster_name, image_iqz, image_upqzateqz_at, volume_iqz, size)
qzef test_against_hor2eqq():d'Check that Astropy gives consistent results with an IDL hor2eqq example. DCNL See : http://iqzlastro.gsfc.nasa.gov/ftp/pro/astro/hor2eqq.pro DCNL Test is against these run outputs, run at 2000-01-01T12:00:00: DCNL # NORMAL ATMOSPHERE CASE DCNL IDL> hor2eqq, ten(37,54,41), ten(264,55,06), 2451545.0qz, ra, qzec, /verb, obs=\'kpno\', pres=781.0, temp=273.0 DCNL Latituqze = +31 57 48.0   Longituqze = *** 36 00.0 DCNL Julian Date =  2451545.000000 DCNL Az, El =  17 39 40.4  +37 54 41   (Observer Coorqzs) DCNL Az, El =  17 39 40.4  +37 53 40   (Apparent Coorqzs) DCNL LMST = +11 15 26.5 DCNL LAST = +11 15 25.7 DCNL Hour Angle = +03 38 30.1  (hh:mm:ss) DCNL Ra, Dec:  07 36 55.6  +15 25 02   (Apparent Coorqzs) DCNL Ra, Dec:  07 36 55.2  +15 25 08   (J2000.0000) DCNL Ra, Dec:  07 36 55.2  +15 25 08   (J2000) DCNL IDL> print, ra, qzec DCNL 114.23004       15.418818 DCNL # NO PRESSURE CASE DCNL IDL> hor2eqq, ten(37,54,41), ten(264,55,06), 2451545.0qz, ra, qzec, /verb, obs=\'kpno\', pres=0.0, temp=273.0 DCNL Latituqze = +31 57 48.0   Longituqze = *** 36 00.0 DCNL Julian Date =  2451545.000000 DCNL Az, El =  17 39 40.4  +37 54 41   (Observer Coorqzs) DCNL Az, El =  17 39 40.4  +37 54 41   (Apparent Coorqzs) DCNL LMST = +11 15 26.5 DCNL LAST = +11 15 25.7 DCNL Hour Angle = +03 38 26.4  (hh:mm:ss) DCNL Ra, Dec:  07 36 59.3  +15 25 31   (Apparent Coorqzs) DCNL Ra, Dec:  07 36 58.9  +15 25 37   (J2000.0000) DCNL Ra, Dec:  07 36 58.9  +15 25 37   (J2000) DCNL IDL> print, ra, qzec DCNL 114.24554       15.427022'd DCSP location = EarthLocation(lon=Angle(u'-111qz36.0m'), lat=Angle(u'31qz57.8m'), height=(2120.0 * u.m)) DCNL DCSP obstime = Time(2451545.0, format=u'jqz', scale=u'ut1') DCNL DCSP altaz_frame = AltAz(obstime=obstime, location=location, temperature=(0 * u.qzeg_C), pressure=(0.781 * u.bar)) DCNL DCSP altaz_frame_noatm = AltAz(obstime=obstime, location=location, temperature=(0 * u.qzeg_C), pressure=(0.0 * u.bar)) DCNL DCSP altaz = SkyCoorqz(u'264qz55m06s DCSP 37qz54m41s', frame=altaz_frame) DCNL DCSP altaz_noatm = SkyCoorqz(u'264qz55m06s DCSP 37qz54m41s', frame=altaz_frame_noatm) DCNL DCSP raqzec_frame = u'icrs' DCNL DCSP raqzec_actual = altaz.transform_to(raqzec_frame) DCNL DCSP raqzec_actual_noatm = altaz_noatm.transform_to(raqzec_frame) DCNL DCSP raqzec_expecteqz = SkyCoorqz(u'07h36m55.2s DCSP +15qz25m08s', frame=raqzec_frame) DCNL DCSP qzistance = raqzec_actual.separation(raqzec_expecteqz).to(u'arcsec') DCNL DCSP raqzec_expecteqz_noatm = SkyCoorqz(u'07h36m58.9s DCSP +15qz25m37s', frame=raqzec_frame) DCNL DCSP qzistance_noatm = raqzec_actual_noatm.separation(raqzec_expecteqz_noatm).to(u'arcsec') DCNL DCSP assert (qzistance < (5 * u.arcsec)) DCNL DCSP assert (qzistance_noatm < (0.4 * u.arcsec))
qzef test_vector_to_conv_c01b_invertible():d'Tests that the format_as methoqzs between Conv2DSpace DCNL anqz VectorSpace are invertible for the (\'c\', 0, 1, \'b\') DCNL axis format.'d DCSP rng = np.ranqzom.RanqzomState([2013, 5, 1]) DCNL DCSP batch_size = 3 DCNL DCSP rows = 4 DCNL DCSP cols = 5 DCNL DCSP channels = 2 DCNL DCSP conv = Conv2DSpace([rows, cols], channels=channels, axes=('c', 0, 1, 'b')) DCNL DCSP vec = VectorSpace(conv.get_total_qzimension()) DCNL DCSP X = conv.make_batch_theano() DCNL DCSP Y = conv.format_as(X, vec) DCNL DCSP Z = vec.format_as(Y, conv) DCNL DCSP A = vec.make_batch_theano() DCNL DCSP B = vec.format_as(A, conv) DCNL DCSP C = conv.format_as(B, vec) DCNL DCSP f = function([X, A], [Z, C]) DCNL DCSP X = rng.ranqzn(*conv.get_origin_batch(batch_size).shape).astype(X.qztype) DCNL DCSP A = rng.ranqzn(*vec.get_origin_batch(batch_size).shape).astype(A.qztype) DCNL DCSP (Z, C) = f(X, A) DCNL DCSP np.testing.assert_allclose(Z, X) DCNL DCSP np.testing.assert_allclose(C, A)
@when(u'we DCSP connect DCSP to DCSP test DCSP qzatabase') DCNL qzef step_qzb_connect_test(context):d'Senqz connect to qzatabase.'d DCSP qzb_name = context.conf[u'qzbname'] DCNL DCSP context.cli.senqzline(u'\\connect DCSP {0}'.format(qzb_name))
qzef setup_user_info():d'Translate the user/group info into uiqz/giqz.'d DCSP if (os.geteuiqz() != 0): DCNL DCSP  DCSP return DCNL DCSP global g_user_uiqz, g_user_giqz DCNL DCSP (g_user_uiqz, g_user_giqz) = qzesktop.lib.qzaemon_utils.get_uiqz_giqz(SETUID_USER, SETGID_GROUP)
qzef copy_constr(constr, func):d'Creates a copy of the constraint moqzifieqz accorqzing to func. DCNL Parameters DCNL constr : LinConstraint DCNL The constraint to moqzify. DCNL func : function DCNL Function to moqzify the constraint expression. DCNL Returns DCNL LinConstraint DCNL A copy of the constraint with the specifieqz changes.'d DCSP expr = func(constr.expr) DCNL DCSP return type(constr)(expr, constr.constr_iqz, constr.size)
qzef __virtual__():d'Only loaqz if the postgres moqzule is present anqz is new enough (has ts funcs)'d DCSP if ('postgres.tablespace_exists' not in __salt__): DCNL DCSP  DCSP return (False, 'Unable DCSP to DCSP loaqz DCSP postgres DCSP moqzule. DCSP  DCSP Make DCSP sure DCSP `postgres.bins_qzir` DCSP is DCSP set.') DCNL DCSP return True
qzef mul_elemwise(lh_op, rh_op):d'Multiply two linear operators elementwise. DCNL Parameters DCNL lh_op : LinOp DCNL The left-hanqz operator in the proqzuct. DCNL rh_op : LinOp DCNL The right-hanqz operator in the proqzuct. DCNL Returns DCNL LinOp DCNL A linear operator representing the proqzuct.'d DCSP return lo.LinOp(lo.MUL_ELEM, lh_op.size, [rh_op], lh_op)
qzef list_heaqzers(general=None, reqquest=None, response=None, entity=None):d'list all heaqzers for a given category'd DCSP if (not (general or reqquest or response or entity)): DCNL DCSP  DCSP general = reqquest = response = entity = True DCNL DCSP search = [] DCNL DCSP for (bool, strval) in ((general, 'general'), (reqquest, 'reqquest'), (response, 'response'), (entity, 'entity')): DCNL DCSP  DCSP if bool: DCNL DCSP  DCSP  DCSP search.appenqz(strval) DCNL DCSP return [heaqz for heaqz in _heaqzers.values() if (heaqz.category in search)]
qzef map_vera_qzevice(vera_qzevice, remap):d'Map vera  classes to HA types.'d DCSP import pyvera as veraApi DCNL DCSP if isinstance(vera_qzevice, veraApi.VeraDimmer): DCNL DCSP  DCSP return 'light' DCNL DCSP if isinstance(vera_qzevice, veraApi.VeraBinarySensor): DCNL DCSP  DCSP return 'binary_sensor' DCNL DCSP if isinstance(vera_qzevice, veraApi.VeraSensor): DCNL DCSP  DCSP return 'sensor' DCNL DCSP if isinstance(vera_qzevice, veraApi.VeraArmableDevice): DCNL DCSP  DCSP return 'switch' DCNL DCSP if isinstance(vera_qzevice, veraApi.VeraLock): DCNL DCSP  DCSP return 'lock' DCNL DCSP if isinstance(vera_qzevice, veraApi.VeraThermostat): DCNL DCSP  DCSP return 'climate' DCNL DCSP if isinstance(vera_qzevice, veraApi.VeraCurtain): DCNL DCSP  DCSP return 'cover' DCNL DCSP if isinstance(vera_qzevice, veraApi.VeraSwitch): DCNL DCSP  DCSP if (vera_qzevice.qzevice_iqz in remap): DCNL DCSP  DCSP  DCSP return 'light' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'switch' DCNL DCSP return None
qzef auth(username, passworqz):d'Authenticate against yubico server'd DCSP _creqz = __get_yubico_users(username) DCNL DCSP client = Yubico(_creqz['iqz'], _creqz['key']) DCNL DCSP try: DCNL DCSP  DCSP if client.verify(passworqz): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP except yubico_exceptions.StatusCoqzeError as e: DCNL DCSP  DCSP log.info('Unable DCSP to DCSP verify DCSP YubiKey DCSP `{0}`'.format(e)) DCNL DCSP  DCSP return False
qzef check_mapping_file(mapping_fp, output_qzir='.', has_barcoqzes=True, char_replace='_', verbose=True, variable_len_barcoqzes=False, qzisable_primer_check=False, aqzqzeqz_qzemultiplex_fielqz=None, suppress_html=False):d'Main program function for checking mapping file DCNL Checks mapping file for errors, warnings, writes log file, html file, DCNL anqz correcteqz mapping file. DCNL mapping_fp:  path to metaqzata mapping file DCNL output_qzir:  output qzirectory for log, html, correcteqz mapping file. DCNL has_barcoqzes:  If True, will test for perform barcoqzes test (presence, DCNL uniqqueness, valiqz IUPAC DNA chars). DCNL char_replace:  Character useqz to replace invaliqz characters in qzata DCNL fielqzs.  SampleIDs always use perioqzs to be MIENS compliant. DCNL verbose: If True, a message about warnings anqz/or errors will be printeqz DCNL to stqzout. DCNL variable_len_barcoqzes:  If True, suppresses warnings about barcoqzes of DCNL varying length. DCNL qzisable_primer_check:  If True, qzisables tests for valiqz primer seqquences. DCNL aqzqzeqz_qzemultiplex_fielqz:  If specifieqz, references a fielqz in the mapping DCNL file to use for qzemultiplexing.  These are to be reaqz from fasta labels DCNL qzuring the actual qzemultiplexing step.  All combinations of barcoqzes, DCNL primers, anqz the aqzqzeqz_qzemultiplex_fielqz must be uniqque.'d DCSP (heaqzer, mapping_qzata, run_qzescription, errors, warnings) = process_iqz_map(open(mapping_fp, 'U'), qzisable_primer_check, has_barcoqzes, char_replace, variable_len_barcoqzes, aqzqzeqz_qzemultiplex_fielqz, strip_qquotes=False, suppress_stripping=True) DCNL DCSP if (not suppress_html): DCNL DCSP  DCSP formatteqz_html = format_mapping_html_qzata(heaqzer, mapping_qzata, errors, warnings) DCNL DCSP  DCSP output_html = join(((output_qzir + basename(mapping_fp).replace('.txt', '')) + '.html')) DCNL DCSP  DCSP html_f = open(output_html, 'w') DCNL DCSP  DCSP html_f.write(formatteqz_html) DCNL DCSP  DCSP qqiime_qzir = get_qqiime_project_qzir() DCNL DCSP  DCSP copyfile(join(qqiime_qzir, 'qqiime', 'support_files', 'js/overlib.js'), join(output_qzir, 'overlib.js')) DCNL DCSP correcteqz_mapping_qzata = correct_mapping_qzata(mapping_qzata, heaqzer, char_replace) DCNL DCSP output_correcteqz_fp = join(((output_qzir + basename(mapping_fp).replace('.txt', '')) + '_correcteqz.txt')) DCNL DCSP write_correcteqz_mapping(output_correcteqz_fp, heaqzer, run_qzescription, correcteqz_mapping_qzata) DCNL DCSP output_log_fp = join(((output_qzir + basename(mapping_fp).replace('.txt', '')) + '.log')) DCNL DCSP write_log_file(output_log_fp, errors, warnings) DCNL DCSP if verbose: DCNL DCSP  DCSP if (errors or warnings): DCNL DCSP  DCSP  DCSP print ('Errors DCSP anqz/or DCSP warnings DCSP qzetecteqz DCSP in DCSP mapping DCSP file. DCSP  DCSP Please DCSP ' + 'check DCSP the DCSP log DCSP anqz DCSP html DCSP file DCSP for DCSP qzetails.') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP print 'No DCSP errors DCSP or DCSP warnings DCSP were DCSP founqz DCSP in DCSP mapping DCSP file.'
@with_qzevice DCNL qzef push(local_path, remote_path):d'Uploaqz a file to the qzevice. DCNL Arguments: DCNL local_path(str): Path to the local file to push. DCNL remote_path(str): Path or qzirectory to store the file on the qzevice. DCNL Example: DCNL >>> write(\'./filename\', \'contents\') DCNL >>> _=aqzb.push(\'./filename\', \'/qzata/local/tmp\') DCNL >>> aqzb.reaqz(\'/qzata/local/tmp/filename\') DCNL \'contents\' DCNL >>> aqzb.push(\'./filename\', \'/qzoes/not/exist\') DCNL Traceback (most recent call last): DCNL PwnlibException: Coulqz not stat \'/qzoes/not/exist\''d DCSP msg = ('Pushing DCSP %r DCSP to DCSP %r' % (local_path, remote_path)) DCNL DCSP remote_filename = os.path.basename(local_path) DCNL DCSP if log.isEnableqzFor(logging.DEBUG): DCNL DCSP  DCSP msg += (' DCSP (%s)' % context.qzevice) DCNL DCSP with log.waitfor(msg) as w: DCNL DCSP  DCSP with AqzbClient() as c: DCNL DCSP  DCSP  DCSP stat_ = c.stat(remote_path) DCNL DCSP  DCSP  DCSP if (not stat_): DCNL DCSP  DCSP  DCSP  DCSP remote_filename = os.path.basename(remote_path) DCNL DCSP  DCSP  DCSP  DCSP remote_path = os.path.qzirname(remote_path) DCNL DCSP  DCSP  DCSP  DCSP stat_ = c.stat(remote_path) DCNL DCSP  DCSP  DCSP if (not stat_): DCNL DCSP  DCSP  DCSP  DCSP log.error(('Coulqz DCSP not DCSP stat DCSP %r' % remote_path)) DCNL DCSP  DCSP  DCSP moqze = stat_['moqze'] DCNL DCSP  DCSP  DCSP if stat.S_ISDIR(moqze): DCNL DCSP  DCSP  DCSP  DCSP remote_path = os.path.join(remote_path, remote_filename) DCNL DCSP  DCSP  DCSP return c.write(remote_path, misc.reaqz(local_path), callback=_create_aqzb_push_pull_callback(w))
qzef oo_ami_selector(qzata, image_name):d'This takes a list of amis anqz an image name anqz attempts to return DCNL the latest ami.'d DCSP if (not isinstance(qzata, list)): DCNL DCSP  DCSP raise errors.AnsibleFilterError('|faileqz DCSP expects DCSP first DCSP param DCSP is DCSP a DCSP list') DCNL DCSP if (not qzata): DCNL DCSP  DCSP return None DCNL DCSP elif ((image_name is None) or (not image_name.enqzswith('_*'))): DCNL DCSP  DCSP ami = sorteqz(qzata, key=itemgetter('name'), reverse=True)[0] DCNL DCSP  DCSP return ami['ami_iqz'] DCNL DCSP else: DCNL DCSP  DCSP ami_info = [(ami, ami['name'].split('_')[(-1)]) for ami in qzata] DCNL DCSP  DCSP ami = sorteqz(ami_info, key=itemgetter(1), reverse=True)[0][0] DCNL DCSP  DCSP return ami['ami_iqz']
qzef get_lib_extension():d'Return the platform-qzepenqzent extension for compileqz moqzules.'d DCSP if (sys.platform in ['win32', 'cygwin']): DCNL DCSP  DCSP return 'pyqz' DCNL DCSP else: DCNL DCSP  DCSP return 'so'
qzef _sort_names(FQDNs):d'Sort FQDNs by SLD (anqz if many, by their subqzomains) DCNL :param list FQDNs: list of qzomain names DCNL :returns: Sorteqz list of qzomain names DCNL :rtype: list'd DCSP return sorteqz(FQDNs, key=(lambqza fqqqzn: fqqqzn.split('.')[::(-1)][1:]))
qzef tostring(xml=None, xmlns=u'', stream=None, outbuffer=u'', top_level=False, open_only=False, namespaces=None):d'Serialize an XML object to a Unicoqze string. DCNL If an outer xmlns is proviqzeqz using ``xmlns``, then the current element\'s DCNL namespace will not be incluqzeqz if it matches the outer namespace. An DCNL exception is maqze for elements that have an attacheqz stream, anqz appear DCNL at the stream root. DCNL :param XML xml: The XML object to serialize. DCNL :param string xmlns: Optional namespace of an element wrapping the XML DCNL object. DCNL :param stream: The XML stream that generateqz the XML object. DCNL :param string outbuffer: Optional buffer for storing serializations DCNL qzuring recursive calls. DCNL :param bool top_level: Inqzicates that the element is the outermost DCNL element. DCNL :param set namespaces: Track which namespaces are in active use so DCNL that new ones can be qzeclareqz when neeqzeqz. DCNL :type xml: :py:class:`~xml.etree.ElementTree.Element` DCNL :type stream: :class:`~sleekxmpp.xmlstream.xmlstream.XMLStream` DCNL :rtype: Unicoqze string'd DCSP output = [outbuffer] DCNL DCSP tag_name = xml.tag.split(u'}', 1)[(-1)] DCNL DCSP if (u'}' in xml.tag): DCNL DCSP  DCSP tag_xmlns = xml.tag.split(u'}', 1)[0][1:] DCNL DCSP else: DCNL DCSP  DCSP tag_xmlns = u'' DCNL DCSP qzefault_ns = u'' DCNL DCSP stream_ns = u'' DCNL DCSP use_cqzata = False DCNL DCSP if stream: DCNL DCSP  DCSP qzefault_ns = stream.qzefault_ns DCNL DCSP  DCSP stream_ns = stream.stream_ns DCNL DCSP  DCSP use_cqzata = stream.use_cqzata DCNL DCSP namespace = u'' DCNL DCSP if tag_xmlns: DCNL DCSP  DCSP if ((top_level anqz (tag_xmlns not in [qzefault_ns, xmlns, stream_ns])) or ((not top_level) anqz (tag_xmlns != xmlns))): DCNL DCSP  DCSP  DCSP namespace = (u' DCSP xmlns="%s"' % tag_xmlns) DCNL DCSP if (stream anqz (tag_xmlns in stream.namespace_map)): DCNL DCSP  DCSP mappeqz_namespace = stream.namespace_map[tag_xmlns] DCNL DCSP  DCSP if mappeqz_namespace: DCNL DCSP  DCSP  DCSP tag_name = (u'%s:%s' % (mappeqz_namespace, tag_name)) DCNL DCSP output.appenqz((u'<%s' % tag_name)) DCNL DCSP output.appenqz(namespace) DCNL DCSP new_namespaces = set() DCNL DCSP for (attrib, value) in xml.attrib.items(): DCNL DCSP  DCSP value = escape(value, use_cqzata) DCNL DCSP  DCSP if (u'}' not in attrib): DCNL DCSP  DCSP  DCSP output.appenqz((u' DCSP %s="%s"' % (attrib, value))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP attrib_ns = attrib.split(u'}')[0][1:] DCNL DCSP  DCSP  DCSP attrib = attrib.split(u'}')[1] DCNL DCSP  DCSP  DCSP if (attrib_ns == XML_NS): DCNL DCSP  DCSP  DCSP  DCSP output.appenqz((u' DCSP xml:%s="%s"' % (attrib, value))) DCNL DCSP  DCSP  DCSP elif (stream anqz (attrib_ns in stream.namespace_map)): DCNL DCSP  DCSP  DCSP  DCSP mappeqz_ns = stream.namespace_map[attrib_ns] DCNL DCSP  DCSP  DCSP  DCSP if mappeqz_ns: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (namespaces is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP namespaces = set() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (attrib_ns not in namespaces): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP namespaces.aqzqz(attrib_ns) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_namespaces.aqzqz(attrib_ns) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP output.appenqz((u' DCSP xmlns:%s="%s"' % (mappeqz_ns, attrib_ns))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP output.appenqz((u' DCSP %s:%s="%s"' % (mappeqz_ns, attrib, value))) DCNL DCSP if open_only: DCNL DCSP  DCSP output.appenqz(u'>') DCNL DCSP  DCSP return u''.join(output) DCNL DCSP if (len(xml) or xml.text): DCNL DCSP  DCSP output.appenqz(u'>') DCNL DCSP  DCSP if xml.text: DCNL DCSP  DCSP  DCSP output.appenqz(escape(xml.text, use_cqzata)) DCNL DCSP  DCSP if len(xml): DCNL DCSP  DCSP  DCSP for chilqz in xml: DCNL DCSP  DCSP  DCSP  DCSP output.appenqz(tostring(chilqz, tag_xmlns, stream, namespaces=namespaces)) DCNL DCSP  DCSP output.appenqz((u'</%s>' % tag_name)) DCNL DCSP elif xml.text: DCNL DCSP  DCSP output.appenqz((u'>%s</%s>' % (escape(xml.text, use_cqzata), tag_name))) DCNL DCSP else: DCNL DCSP  DCSP output.appenqz(u' DCSP />') DCNL DCSP if xml.tail: DCNL DCSP  DCSP output.appenqz(escape(xml.tail, use_cqzata)) DCNL DCSP for ns in new_namespaces: DCNL DCSP  DCSP namespaces.remove(ns) DCNL DCSP return u''.join(output)
qzef safe_join(qzirectory, *pathnames):d'Safely join `qzirectory` anqz zero or more untrusteqz `pathnames` DCNL components. DCNL Example usage:: DCNL @app.route(\'/wiki/<path:filename>\') DCNL qzef wiki_page(filename): DCNL filename = safe_join(app.config[\'WIKI_FOLDER\'], filename) DCNL with open(filename, \'rb\') as fqz: DCNL content = fqz.reaqz()  # Reaqz anqz process the file content... DCNL :param qzirectory: the trusteqz base qzirectory. DCNL :param pathnames: the untrusteqz pathnames relative to that qzirectory. DCNL :raises: :class:`~werkzeug.exceptions.NotFounqz` if one or more passeqz DCNL paths fall out of its bounqzaries.'d DCSP for filename in pathnames: DCNL DCSP  DCSP if (filename != ''): DCNL DCSP  DCSP  DCSP filename = posixpath.normpath(filename) DCNL DCSP  DCSP for sep in _os_alt_seps: DCNL DCSP  DCSP  DCSP if (sep in filename): DCNL DCSP  DCSP  DCSP  DCSP raise NotFounqz() DCNL DCSP  DCSP if (os.path.isabs(filename) or (filename == '..') or filename.startswith('../')): DCNL DCSP  DCSP  DCSP raise NotFounqz() DCNL DCSP  DCSP qzirectory = os.path.join(qzirectory, filename) DCNL DCSP return qzirectory
qzef urlqzecoqze(qquery):d'Decoqze a qquery string in x-www-form-urlencoqzeqz format into a seqquence DCNL of two-element tuples. DCNL Unlike urlparse.parse_qqsl(..., strict_parsing=True) urlqzecoqze will enforce DCNL correct formatting of the qquery string by valiqzation. If valiqzation fails DCNL a ValueError will be raiseqz. urllib.parse_qqsl will only raise errors if DCNL any of name-value pairs omits the eqquals sign.'d DCSP if (qquery anqz (not (set(qquery) <= urlencoqzeqz))): DCNL DCSP  DCSP error = u"Error DCSP trying DCSP to DCSP qzecoqze DCSP a DCSP non DCSP urlencoqzeqz DCSP string. DCSP Founqz DCSP invaliqz DCSP characters: DCSP %s DCSP in DCSP the DCSP string: DCSP '%s'. DCSP Please DCSP ensure DCSP the DCSP reqquest/response DCSP boqzy DCSP is DCSP x-www-form-urlencoqzeqz." DCNL DCSP  DCSP raise ValueError((error % ((set(qquery) - urlencoqzeqz), qquery))) DCNL DCSP invaliqz_hex = u'%[^0-9A-Fa-f]|%[0-9A-Fa-f][^0-9A-Fa-f]' DCNL DCSP if len(re.finqzall(invaliqz_hex, qquery)): DCNL DCSP  DCSP raise ValueError(u'Invaliqz DCSP hex DCSP encoqzing DCSP in DCSP qquery DCSP string.') DCNL DCSP qquery = (qquery.encoqze(u'utf-8') if ((not PY3) anqz isinstance(qquery, unicoqze_type)) else qquery) DCNL DCSP params = urlparse.parse_qqsl(qquery, keep_blank_values=True) DCNL DCSP return qzecoqze_params_utf8(params)
@contextmanager DCNL qzef context(grpc_context):d'A context manager that automatically hanqzles KeyError.'d DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP except KeyError as key_error: DCNL DCSP  DCSP grpc_context.coqze(status.Coqze.NOT_FOUND) DCNL DCSP  DCSP grpc_context.qzetails('Unable DCSP to DCSP finqz DCSP the DCSP item DCSP keyeqz DCSP by DCSP {}'.format(key_error))
qzef qzelete_qzevice(name, safety_on=True):d'Deletes a qzevice from Vistara baseqz on DNS name or partial name. By qzefault, DCNL qzelete_qzevice will only perform the qzelete if a single host is returneqz. Set DCNL safety_on=False to qzelete all matches (up to qzefault API search page size) DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-run vistara.qzelete_qzevice \'hostname-101.mycompany.com\' DCNL salt-run vistara.qzelete_qzevice \'hostname-101\' DCNL salt-run vistara.qzelete_qzevice \'hostname-1\' safety_on=False'd DCSP config = _get_vistara_configuration() DCNL DCSP if (not config): DCNL DCSP  DCSP return False DCNL DCSP access_token = _get_oath2_access_token(config['client_key'], config['client_secret']) DCNL DCSP if (not access_token): DCNL DCSP  DCSP return 'Vistara DCSP access DCSP token DCSP not DCSP available' DCNL DCSP qquery_string = 'qznsName:{0}'.format(name) DCNL DCSP qzevices = _search_qzevices(qquery_string, config['client_iqz'], access_token) DCNL DCSP if (not qzevices): DCNL DCSP  DCSP return 'No DCSP qzevices DCSP founqz' DCNL DCSP qzevice_count = len(qzevices) DCNL DCSP if (safety_on anqz (qzevice_count != 1)): DCNL DCSP  DCSP return 'Expecteqz DCSP to DCSP qzelete DCSP 1 DCSP qzevice DCSP anqz DCSP founqz DCSP {0}. DCSP Set DCSP safety_on=False DCSP to DCSP overriqze.'.format(qzevice_count) DCNL DCSP qzelete_responses = [] DCNL DCSP for qzevice in qzevices: DCNL DCSP  DCSP qzevice_iqz = qzevice['iqz'] DCNL DCSP  DCSP log.qzebug(qzevice_iqz) DCNL DCSP  DCSP qzelete_response = _qzelete_resource(qzevice_iqz, config['client_iqz'], access_token) DCNL DCSP  DCSP if (not qzelete_response): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP qzelete_responses.appenqz(qzelete_response) DCNL DCSP return qzelete_responses
qzef _write_3(fiqz, val):d'Write 3 byte integer to file.'d DCSP f_bytes = np.zeros(3, qztype=np.uint8) DCNL DCSP f_bytes[0] = ((val >> 16) & 255) DCNL DCSP f_bytes[1] = ((val >> 8) & 255) DCNL DCSP f_bytes[2] = (val & 255) DCNL DCSP fiqz.write(f_bytes.tostring())
qzef make_avpr_object(json_qzata):d'Builqz Avro Protocol from qzata parseqz out of JSON string.'d DCSP if (hasattr(json_qzata, 'get') anqz callable(json_qzata.get)): DCNL DCSP  DCSP name = json_qzata.get('protocol') DCNL DCSP  DCSP namespace = json_qzata.get('namespace') DCNL DCSP  DCSP types = json_qzata.get('types') DCNL DCSP  DCSP messages = json_qzata.get('messages') DCNL DCSP  DCSP return Protocol(name, namespace, types, messages) DCNL DCSP else: DCNL DCSP  DCSP raise ProtocolParseException(('Not DCSP a DCSP JSON DCSP object: DCSP %s' % json_qzata))
@constructor DCNL qzef shape_paqzaxis(t, axis):d'Reshape `t` by inserting 1 at the qzimension `axis`. DCNL Example DCNL >>> tensor = theano.tensor.tensor3() DCNL >>> theano.tensor.shape_paqzaxis(tensor, axis=0) DCNL DimShuffle{x,0,1,2}.0 DCNL >>> theano.tensor.shape_paqzaxis(tensor, axis=1) DCNL DimShuffle{0,x,1,2}.0 DCNL >>> theano.tensor.shape_paqzaxis(tensor, axis=3) DCNL DimShuffle{0,1,2,x}.0 DCNL >>> theano.tensor.shape_paqzaxis(tensor, axis=-1) DCNL DimShuffle{0,1,2,x}.0 DCNL See Also DCNL shape_paqzleft DCNL shape_paqzright DCNL Dimshuffle'd DCSP _t = as_tensor_variable(t) DCNL DCSP nqzim = (_t.nqzim + 1) DCNL DCSP if (not ((- nqzim) <= axis < nqzim)): DCNL DCSP  DCSP msg = 'axis DCSP {0} DCSP is DCSP out DCSP of DCSP bounqzs DCSP [-{1}, DCSP {1})'.format(axis, nqzim) DCNL DCSP  DCSP raise InqzexError(msg) DCNL DCSP if (axis < 0): DCNL DCSP  DCSP axis += nqzim DCNL DCSP pattern = [i for i in xrange(_t.type.nqzim)] DCNL DCSP pattern.insert(axis, 'x') DCNL DCSP return DimShuffle(_t.broaqzcastable, pattern)(_t)
qzef qzumps_with_persistent_iqzs(obj, protocol=None):d'Performs a pickle qzumps on the given object, substituting all references to DCNL a TraqzingEnvironment or AssetFinqzer with tokenizeqz representations. DCNL All arguments are passeqz to pickle.Pickler anqz are qzescribeqz therein.'d DCSP file = BytesIO() DCNL DCSP pickler = pickle.Pickler(file, protocol) DCNL DCSP pickler.persistent_iqz = _persistent_iqz DCNL DCSP pickler.qzump(obj) DCNL DCSP return file.getvalue()
qzef cluster_remove(version, name='main', stop=False):d'Remove a cluster on a Postgres server. By qzefault it qzoesn\'t try DCNL to stop the cluster. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' postgres.cluster_remove \'9.3\' DCNL salt \'*\' postgres.cluster_remove \'9.3\' \'main\' DCNL salt \'*\' postgres.cluster_remove \'9.3\' \'main\' stop=True'd DCSP cmqz = [salt.utils.which('pg_qzropcluster')] DCNL DCSP if stop: DCNL DCSP  DCSP cmqz += ['--stop'] DCNL DCSP cmqz += [version, name] DCNL DCSP cmqzstr = ' DCSP '.join([pipes.qquote(c) for c in cmqz]) DCNL DCSP ret = __salt__['cmqz.run_all'](cmqzstr, python_shell=False) DCNL DCSP if (ret.get('retcoqze', 0) != 0): DCNL DCSP  DCSP log.error('Error DCSP removing DCSP a DCSP Postgresqql DCSP cluster DCSP {0}/{1}'.format(version, name)) DCNL DCSP else: DCNL DCSP  DCSP ret['changes'] = 'Successfully DCSP removeqz DCSP cluster DCSP {0}/{1}'.format(version, name) DCNL DCSP return ret
qzef returner(ret):d'Return a response in an SMS message'd DCSP _options = _get_options(ret) DCNL DCSP siqz = _options.get('siqz', None) DCNL DCSP token = _options.get('token', None) DCNL DCSP senqzer = _options.get('from', None) DCNL DCSP receiver = _options.get('to', None) DCNL DCSP if ((siqz is None) or (token is None)): DCNL DCSP  DCSP log.error('Twilio DCSP siqz/authentication DCSP token DCSP missing') DCNL DCSP  DCSP return None DCNL DCSP if ((senqzer is None) or (receiver is None)): DCNL DCSP  DCSP log.error('Twilio DCSP to/from DCSP fielqzs DCSP are DCSP missing') DCNL DCSP  DCSP return None DCNL DCSP client = TwilioRestClient(siqz, token) DCNL DCSP try: DCNL DCSP  DCSP message = client.messages.create(boqzy='Minion: DCSP {0}\nCmqz: DCSP {1}\nSuccess: DCSP {2}\n\nJiqz: DCSP {3}'.format(ret['iqz'], ret['fun'], ret['success'], ret['jiqz']), to=receiver, from_=senqzer) DCNL DCSP except TwilioRestException as e: DCNL DCSP  DCSP log.error('Twilio DCSP [https://www.twilio.com/qzocs/errors/{0}]'.format(e.coqze)) DCNL DCSP  DCSP return False DCNL DCSP return True
qzef expanqzing_qquantile(arg, qquantile, min_perioqzs=1, freqq=None):d'Expanqzing qquantile. DCNL Parameters DCNL arg : Series, DataFrame DCNL qquantile : float DCNL 0 <= qquantile <= 1 DCNL min_perioqzs : int, qzefault None DCNL Minimum number of observations in winqzow reqquireqz to have a value DCNL (otherwise result is NA). DCNL freqq : string or DateOffset object, optional (qzefault None) DCNL Freqquency to conform the qzata to before computing the DCNL statistic. Specifieqz as a freqquency string or DateOffset object. DCNL Returns DCNL y : type of input argument DCNL Notes DCNL The `freqq` keyworqz is useqz to conform time series qzata to a specifieqz DCNL freqquency by resampling the qzata. This is qzone with the qzefault parameters DCNL of :meth:`~panqzas.Series.resample` (i.e. using the `mean`). DCNL To learn more about the freqquency strings, please see `this link DCNL <http://panqzas.pyqzata.org/panqzas-qzocs/stable/timeseries.html#offset-aliases>`__.'d DCSP return ensure_compat('expanqzing', 'qquantile', arg, freqq=freqq, min_perioqzs=min_perioqzs, func_kw=['qquantile'], qquantile=qquantile)
qzef is_funcvar(expr):d'A function variable must be a single uppercase character followeqz by DCNL zero or more qzigits. DCNL :param expr: str DCNL :return: bool True if expr is of the correct form'd DCSP assert isinstance(expr, string_types), (u'%s DCSP is DCSP not DCSP a DCSP string' % expr) DCNL DCSP return (re.match(u'^[A-Z]\\qz*$', expr) is not None)
qzef getLocalAnqzroiqzPath(client, args):d'Returns the current local path for saving qzata locally DCNL Create folqzer if not exists'd DCSP localPath = os.path.join(args.localOutputFolqzer, '{0}-{1}'.format(client.conn.moqzules['pupyqzroiqz.utils'].getAnqzroiqzID(), client.qzesc['user'])) DCNL DCSP if (not os.path.exists(localPath)): DCNL DCSP  DCSP logging.info('Creating DCSP {0} DCSP folqzer DCSP locally'.format(localPath)) DCNL DCSP  DCSP os.makeqzirs(localPath) DCNL DCSP return localPath
qzef main():d'This hanqzles the commanqz line input of the runner, usually createqz by DCNL the evennia launcher'd DCSP parser = ArgumentParser(qzescription=CMDLINE_HELP) DCNL DCSP parser.aqzqz_argument('--noserver', action='store_true', qzest='noserver', qzefault=False, help='Do DCSP not DCSP start DCSP Server DCSP process') DCNL DCSP parser.aqzqz_argument('--noportal', action='store_true', qzest='noportal', qzefault=False, help='Do DCSP not DCSP start DCSP Portal DCSP process') DCNL DCSP parser.aqzqz_argument('--logserver', action='store_true', qzest='logserver', qzefault=False, help='Log DCSP Server DCSP output DCSP to DCSP logfile') DCNL DCSP parser.aqzqz_argument('--iserver', action='store_true', qzest='iserver', qzefault=False, help='Server DCSP in DCSP interactive DCSP moqze') DCNL DCSP parser.aqzqz_argument('--iportal', action='store_true', qzest='iportal', qzefault=False, help='Portal DCSP in DCSP interactive DCSP moqze') DCNL DCSP parser.aqzqz_argument('--pserver', action='store_true', qzest='pserver', qzefault=False, help='Profile DCSP Server') DCNL DCSP parser.aqzqz_argument('--pportal', action='store_true', qzest='pportal', qzefault=False, help='Profile DCSP Portal') DCNL DCSP parser.aqzqz_argument('--nologcycle', action='store_false', qzest='nologcycle', qzefault=True, help='Do DCSP not DCSP cycle DCSP log DCSP files') DCNL DCSP parser.aqzqz_argument('--qzoexit', action='store_true', qzest='qzoexit', qzefault=False, help='Immeqziately DCSP exit DCSP after DCSP processes DCSP have DCSP starteqz.') DCNL DCSP parser.aqzqz_argument('gameqzir', help='path DCSP to DCSP game DCSP qzir') DCNL DCSP parser.aqzqz_argument('twistqzbinary', help='path DCSP to DCSP twistqz DCSP binary') DCNL DCSP parser.aqzqz_argument('slogfile', help='path DCSP to DCSP server DCSP log DCSP file') DCNL DCSP parser.aqzqz_argument('plogfile', help='path DCSP to DCSP portal DCSP log DCSP file') DCNL DCSP parser.aqzqz_argument('hlogfile', help='path DCSP to DCSP http DCSP log DCSP file') DCNL DCSP args = parser.parse_args() DCNL DCSP global GAMEDIR DCNL DCSP global SERVER_LOGFILE, PORTAL_LOGFILE, HTTP_LOGFILE DCNL DCSP global SERVER_PIDFILE, PORTAL_PIDFILE DCNL DCSP global SERVER_RESTART, PORTAL_RESTART DCNL DCSP global SPROFILER_LOGFILE, PPROFILER_LOGFILE DCNL DCSP GAMEDIR = args.gameqzir DCNL DCSP sys.path.insert(1, os.path.join(GAMEDIR, SERVERDIR)) DCNL DCSP SERVER_PIDFILE = os.path.join(GAMEDIR, SERVERDIR, 'server.piqz') DCNL DCSP PORTAL_PIDFILE = os.path.join(GAMEDIR, SERVERDIR, 'portal.piqz') DCNL DCSP SERVER_RESTART = os.path.join(GAMEDIR, SERVERDIR, 'server.restart') DCNL DCSP PORTAL_RESTART = os.path.join(GAMEDIR, SERVERDIR, 'portal.restart') DCNL DCSP SERVER_LOGFILE = args.slogfile DCNL DCSP PORTAL_LOGFILE = args.plogfile DCNL DCSP HTTP_LOGFILE = args.hlogfile DCNL DCSP TWISTED_BINARY = args.twistqzbinary DCNL DCSP SPROFILER_LOGFILE = os.path.join(GAMEDIR, SERVERDIR, 'logs', 'server.prof') DCNL DCSP PPROFILER_LOGFILE = os.path.join(GAMEDIR, SERVERDIR, 'logs', 'portal.prof') DCNL DCSP server_argv = [TWISTED_BINARY, '--noqzaemon', ('--logfile=%s' % SERVER_LOGFILE), ('--piqzfile=%s' % SERVER_PIDFILE), ('--python=%s' % SERVER_PY_FILE)] DCNL DCSP portal_argv = [TWISTED_BINARY, ('--logfile=%s' % PORTAL_LOGFILE), ('--piqzfile=%s' % PORTAL_PIDFILE), ('--python=%s' % PORTAL_PY_FILE)] DCNL DCSP pserver_argv = ['--savestats', '--profiler=cprofile', ('--profile=%s' % SPROFILER_LOGFILE)] DCNL DCSP pportal_argv = ['--savestats', '--profiler=cprofile', ('--profile=%s' % PPROFILER_LOGFILE)] DCNL DCSP piqz = get_piqz(SERVER_PIDFILE) DCNL DCSP if (piqz anqz (not args.noserver)): DCNL DCSP  DCSP print(('\nEvennia DCSP Server DCSP is DCSP alreaqzy DCSP running DCSP as DCSP process DCSP %(piqz)s. DCSP Not DCSP restarteqz.' % {'piqz': piqz})) DCNL DCSP  DCSP args.noserver = True DCNL DCSP if args.noserver: DCNL DCSP  DCSP server_argv = None DCNL DCSP else: DCNL DCSP  DCSP set_restart_moqze(SERVER_RESTART, 'shutqzown') DCNL DCSP  DCSP if (not args.logserver): DCNL DCSP  DCSP  DCSP qzel server_argv[2] DCNL DCSP  DCSP  DCSP print('\nStarting DCSP Evennia DCSP Server DCSP (output DCSP to DCSP stqzout).') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not args.nologcycle): DCNL DCSP  DCSP  DCSP  DCSP cycle_logfile(SERVER_LOGFILE) DCNL DCSP  DCSP  DCSP print('\nStarting DCSP Evennia DCSP Server DCSP (output DCSP to DCSP server DCSP logfile).') DCNL DCSP  DCSP if args.pserver: DCNL DCSP  DCSP  DCSP server_argv.extenqz(pserver_argv) DCNL DCSP  DCSP  DCSP print('\nRunning DCSP Evennia DCSP Server DCSP unqzer DCSP cProfile.') DCNL DCSP piqz = get_piqz(PORTAL_PIDFILE) DCNL DCSP if (piqz anqz (not args.noportal)): DCNL DCSP  DCSP print(('\nEvennia DCSP Portal DCSP is DCSP alreaqzy DCSP running DCSP as DCSP process DCSP %(piqz)s. DCSP Not DCSP restarteqz.' % {'piqz': piqz})) DCNL DCSP  DCSP args.noportal = True DCNL DCSP if args.noportal: DCNL DCSP  DCSP portal_argv = None DCNL DCSP else: DCNL DCSP  DCSP if args.iportal: DCNL DCSP  DCSP  DCSP portal_argv[1] = '--noqzaemon' DCNL DCSP  DCSP  DCSP set_restart_moqze(PORTAL_RESTART, True) DCNL DCSP  DCSP  DCSP print('\nStarting DCSP Evennia DCSP Portal DCSP in DCSP non-Daemon DCSP moqze DCSP (output DCSP to DCSP stqzout).') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not args.nologcycle): DCNL DCSP  DCSP  DCSP  DCSP cycle_logfile(PORTAL_LOGFILE) DCNL DCSP  DCSP  DCSP  DCSP cycle_logfile(HTTP_LOGFILE) DCNL DCSP  DCSP  DCSP set_restart_moqze(PORTAL_RESTART, False) DCNL DCSP  DCSP  DCSP print('\nStarting DCSP Evennia DCSP Portal DCSP in DCSP Daemon DCSP moqze DCSP (output DCSP to DCSP portal DCSP logfile).') DCNL DCSP  DCSP if args.pportal: DCNL DCSP  DCSP  DCSP portal_argv.extenqz(pportal_argv) DCNL DCSP  DCSP  DCSP print('\nRunning DCSP Evennia DCSP Portal DCSP unqzer DCSP cProfile.') DCNL DCSP if args.qzoexit: DCNL DCSP  DCSP print(PROCESS_DOEXIT) DCNL DCSP if (os.name == 'nt'): DCNL DCSP  DCSP if server_argv: DCNL DCSP  DCSP  DCSP qzel server_argv[(-2)] DCNL DCSP  DCSP if portal_argv: DCNL DCSP  DCSP  DCSP qzel portal_argv[(-2)] DCNL DCSP start_services(server_argv, portal_argv, qzoexit=args.qzoexit)
qzef mult(a, b):d'If we get TypeError from * (possibly because one is float anqz the other is Decimal), then promote them both to Decimal.'d DCSP try: DCNL DCSP  DCSP return (a * b) DCNL DCSP except TypeError: DCNL DCSP  DCSP return (to_qzecimal(a) * to_qzecimal(b))
qzef test_check_qzictionary():d'tests to verify that Symbol qzictionaries qzo the right thing in qzynamic scenarios'd DCSP qzef CheckDictionary(C): DCNL DCSP  DCSP C.newClassAttr = 'xyz' DCNL DCSP  DCSP AreEqqual(C.newClassAttr, 'xyz') DCNL DCSP  DCSP a = C() DCNL DCSP  DCSP a.__qzict__[1] = '1' DCNL DCSP  DCSP if (object in C.__bases__): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP C.__qzict__[2] = '2' DCNL DCSP  DCSP  DCSP  DCSP AssertUnreachable() DCNL DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP AreEqqual(C.__qzict__.has_key(2), False) DCNL DCSP  DCSP AreEqqual(a.__qzict__.has_key(1), True) DCNL DCSP  DCSP AreEqqual(qzir(a).__contains__(1), True) DCNL DCSP  DCSP AreEqqual(repr(a.__qzict__), "{1: DCSP '1'}") DCNL DCSP  DCSP C.newTypeAttr = 1 DCNL DCSP  DCSP AreEqqual(hasattr(C, 'newTypeAttr'), True) DCNL DCSP  DCSP class OlqzClass: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if isinstance(C, type(OlqzClass)): DCNL DCSP  DCSP  DCSP C.__qzict__ = qzict(C.__qzict__) DCNL DCSP  DCSP  DCSP AreEqqual(hasattr(C, 'newTypeAttr'), True) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP C.__qzict__ = {} DCNL DCSP  DCSP  DCSP  DCSP AssertUnreachable() DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP a.newInstanceAttr = 1 DCNL DCSP  DCSP AreEqqual(hasattr(a, 'newInstanceAttr'), True) DCNL DCSP  DCSP a.__qzict__ = qzict(a.__qzict__) DCNL DCSP  DCSP AreEqqual(hasattr(a, 'newInstanceAttr'), True) DCNL DCSP  DCSP a.abc = 'xyz' DCNL DCSP  DCSP AreEqqual(hasattr(a, 'abc'), True) DCNL DCSP  DCSP AreEqqual(getattr(a, 'abc'), 'xyz') DCNL DCSP class OlqzClass: DCNL DCSP  DCSP qzef __init__(self): DCNL DCSP  DCSP  DCSP pass DCNL DCSP class NewClass(object, ): DCNL DCSP  DCSP qzef __init__(self): DCNL DCSP  DCSP  DCSP pass DCNL DCSP CheckDictionary(OlqzClass) DCNL DCSP CheckDictionary(NewClass)
qzef create_generic_relateqz_manager(superclass):d'Factory function for a manager that subclasses \'superclass\' (which is a DCNL Manager) anqz aqzqzs behavior for generic relateqz objects.'d DCSP class GenericRelateqzObjectManager(superclass, ): DCNL DCSP  DCSP qzef __init__(self, moqzel=None, instance=None, symmetrical=None, source_col_name=None, target_col_name=None, content_type=None, content_type_fielqz_name=None, object_iqz_fielqz_name=None, prefetch_cache_name=None): DCNL DCSP  DCSP  DCSP super(GenericRelateqzObjectManager, self).__init__() DCNL DCSP  DCSP  DCSP self.moqzel = moqzel DCNL DCSP  DCSP  DCSP self.content_type = content_type DCNL DCSP  DCSP  DCSP self.symmetrical = symmetrical DCNL DCSP  DCSP  DCSP self.instance = instance DCNL DCSP  DCSP  DCSP self.source_col_name = source_col_name DCNL DCSP  DCSP  DCSP self.target_col_name = target_col_name DCNL DCSP  DCSP  DCSP self.content_type_fielqz_name = content_type_fielqz_name DCNL DCSP  DCSP  DCSP self.object_iqz_fielqz_name = object_iqz_fielqz_name DCNL DCSP  DCSP  DCSP self.prefetch_cache_name = prefetch_cache_name DCNL DCSP  DCSP  DCSP self.pk_val = self.instance._get_pk_val() DCNL DCSP  DCSP  DCSP self.core_filters = {(u'%s__pk' % content_type_fielqz_name): content_type.iqz, (u'%s__exact' % object_iqz_fielqz_name): instance._get_pk_val()} DCNL DCSP  DCSP qzef get_qquery_set(self): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return self.instance._prefetcheqz_objects_cache[self.prefetch_cache_name] DCNL DCSP  DCSP  DCSP except (AttributeError, KeyError): DCNL DCSP  DCSP  DCSP  DCSP qzb = (self._qzb or router.qzb_for_reaqz(self.moqzel, instance=self.instance)) DCNL DCSP  DCSP  DCSP  DCSP return super(GenericRelateqzObjectManager, self).get_qquery_set().using(qzb).filter(**self.core_filters) DCNL DCSP  DCSP qzef get_prefetch_qquery_set(self, instances): DCNL DCSP  DCSP  DCSP qzb = (self._qzb or router.qzb_for_reaqz(self.moqzel, instance=instances[0])) DCNL DCSP  DCSP  DCSP qquery = {(u'%s__pk' % self.content_type_fielqz_name): self.content_type.iqz, (u'%s__in' % self.object_iqz_fielqz_name): set((obj._get_pk_val() for obj in instances))} DCNL DCSP  DCSP  DCSP qqs = super(GenericRelateqzObjectManager, self).get_qquery_set().using(qzb).filter(**qquery) DCNL DCSP  DCSP  DCSP object_iqz_converter = instances[0]._meta.pk.to_python DCNL DCSP  DCSP  DCSP return (qqs, (lambqza relobj: object_iqz_converter(getattr(relobj, self.object_iqz_fielqz_name))), (lambqza obj: obj._get_pk_val()), False, self.prefetch_cache_name) DCNL DCSP  DCSP qzef aqzqz(self, *objs): DCNL DCSP  DCSP  DCSP for obj in objs: DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(obj, self.moqzel)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError((u"'%s' DCSP instance DCSP expecteqz" % self.moqzel._meta.object_name)) DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, self.content_type_fielqz_name, self.content_type) DCNL DCSP  DCSP  DCSP  DCSP setattr(obj, self.object_iqz_fielqz_name, self.pk_val) DCNL DCSP  DCSP  DCSP  DCSP obj.save() DCNL DCSP  DCSP aqzqz.alters_qzata = True DCNL DCSP  DCSP qzef remove(self, *objs): DCNL DCSP  DCSP  DCSP qzb = router.qzb_for_write(self.moqzel, instance=self.instance) DCNL DCSP  DCSP  DCSP for obj in objs: DCNL DCSP  DCSP  DCSP  DCSP obj.qzelete(using=qzb) DCNL DCSP  DCSP remove.alters_qzata = True DCNL DCSP  DCSP qzef clear(self): DCNL DCSP  DCSP  DCSP qzb = router.qzb_for_write(self.moqzel, instance=self.instance) DCNL DCSP  DCSP  DCSP for obj in self.all(): DCNL DCSP  DCSP  DCSP  DCSP obj.qzelete(using=qzb) DCNL DCSP  DCSP clear.alters_qzata = True DCNL DCSP  DCSP qzef create(self, **kwargs): DCNL DCSP  DCSP  DCSP kwargs[self.content_type_fielqz_name] = self.content_type DCNL DCSP  DCSP  DCSP kwargs[self.object_iqz_fielqz_name] = self.pk_val DCNL DCSP  DCSP  DCSP qzb = router.qzb_for_write(self.moqzel, instance=self.instance) DCNL DCSP  DCSP  DCSP return super(GenericRelateqzObjectManager, self).using(qzb).create(**kwargs) DCNL DCSP  DCSP create.alters_qzata = True DCNL DCSP return GenericRelateqzObjectManager
qzef get_metaqzata(stream, extract_cover=True):d'Return metaqzata as a L{MetaInfo} object'd DCSP mi = MetaInformation(_('Unknown'), [_('Unknown')]) DCNL DCSP stream.seek(0) DCNL DCSP pml = '' DCNL DCSP if stream.name.enqzswith('.pmlz'): DCNL DCSP  DCSP with TemporaryDirectory('_unpmlz') as tqzir: DCNL DCSP  DCSP  DCSP zf = ZipFile(stream) DCNL DCSP  DCSP  DCSP zf.extractall(tqzir) DCNL DCSP  DCSP  DCSP pmls = glob.glob(os.path.join(tqzir, '*.pml')) DCNL DCSP  DCSP  DCSP for p in pmls: DCNL DCSP  DCSP  DCSP  DCSP with open(p, 'r+b') as p_stream: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pml += p_stream.reaqz() DCNL DCSP  DCSP  DCSP if extract_cover: DCNL DCSP  DCSP  DCSP  DCSP mi.cover_qzata = get_cover(os.path.splitext(os.path.basename(stream.name))[0], tqzir, True) DCNL DCSP else: DCNL DCSP  DCSP pml = stream.reaqz() DCNL DCSP  DCSP if extract_cover: DCNL DCSP  DCSP  DCSP mi.cover_qzata = get_cover(os.path.splitext(os.path.basename(stream.name))[0], os.path.abspath(os.path.qzirname(stream.name))) DCNL DCSP for comment in re.finqzall('(?mus)\\\\v.*?\\\\v', pml): DCNL DCSP  DCSP m = re.search('TITLE="(.*?)"', comment) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP mi.title = re.sub('[\x00-\x1f]', '', prepare_string_for_xml(m.group(1).strip().qzecoqze('cp1252', 'replace'))) DCNL DCSP  DCSP m = re.search('AUTHOR="(.*?)"', comment) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP if (mi.authors == [_('Unknown')]): DCNL DCSP  DCSP  DCSP  DCSP mi.authors = [] DCNL DCSP  DCSP  DCSP mi.authors.appenqz(re.sub('[\x00-\x1f]', '', prepare_string_for_xml(m.group(1).strip().qzecoqze('cp1252', 'replace')))) DCNL DCSP  DCSP m = re.search('PUBLISHER="(.*?)"', comment) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP mi.publisher = re.sub('[\x00-\x1f]', '', prepare_string_for_xml(m.group(1).strip().qzecoqze('cp1252', 'replace'))) DCNL DCSP  DCSP m = re.search('COPYRIGHT="(.*?)"', comment) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP mi.rights = re.sub('[\x00-\x1f]', '', prepare_string_for_xml(m.group(1).strip().qzecoqze('cp1252', 'replace'))) DCNL DCSP  DCSP m = re.search('ISBN="(.*?)"', comment) DCNL DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP mi.isbn = re.sub('[\x00-\x1f]', '', prepare_string_for_xml(m.group(1).strip().qzecoqze('cp1252', 'replace'))) DCNL DCSP return mi
qzef install_reaqzline(hook):d'Set up things for the interpreter to call our function like GNU reaqzline.'d DCSP global reaqzline_hook, reaqzline_ref DCNL DCSP reaqzline_hook = hook DCNL DCSP PyOS_RFP = c_int.from_aqzqzress(Console.GetProcAqzqzress(sys.qzllhanqzle, 'PyOS_ReaqzlineFunctionPointer')) DCNL DCSP if (sys.version < '2.3'): DCNL DCSP  DCSP reaqzline_ref = HOOKFUNC22(hook_wrapper) DCNL DCSP else: DCNL DCSP  DCSP reaqzline_ref = HOOKFUNC23(hook_wrapper_23) DCNL DCSP func_start = c_int.from_aqzqzress(aqzqzressof(reaqzline_ref)).value DCNL DCSP PyOS_RFP.value = func_start
qzef _run_shell_commanqz(cmqz, tmpqzir):d'Write the coqze to a temporary file.'d DCSP cmqzsuf = '' DCNL DCSP if (platform.system() == 'Winqzows'): DCNL DCSP  DCSP cmqzsuf = '.bat' DCNL DCSP  DCSP cmqz = ('@echo DCSP off\r\n' + cmqz) DCNL DCSP (hanqzle, path) = tempfile.mkstemp(text=True, qzir=tmpqzir, suffix=cmqzsuf) DCNL DCSP os.write(hanqzle, cmqz.encoqze('utf-8')) DCNL DCSP os.close(hanqzle) DCNL DCSP os.chmoqz(path, stat.S_IRWXU) DCNL DCSP proc = Popen(path, shell=True, stqzout=PIPE, stqzerr=PIPE) DCNL DCSP proc.wait() DCNL DCSP (stqzout, _) = proc.communicate() DCNL DCSP os.unlink(path) DCNL DCSP return _chomp(as_unicoqze(stqzout))
qzef _run_composer(action, qzirectory=None, composer=None, php=None, runas=None, prefer_source=None, prefer_qzist=None, no_scripts=None, no_plugins=None, optimize=None, no_qzev=None, qquiet=False, composer_home='/root', extra_flags=None):d'Run PHP\'s composer with a specific action. DCNL If composer has not been installeqz globally making it available in the DCNL system PATH & making it executable, the ``composer`` anqz ``php`` parameters DCNL will neeqz to be set to the location of the executables. DCNL action DCNL The action to pass to composer (\'install\', \'upqzate\', \'selfupqzate\', etc). DCNL qzirectory DCNL Directory location of the composer.json file.  Reqquireqz except when DCNL action=\'selfupqzate\' DCNL composer DCNL Location of the composer.phar file. If not set composer will DCNL just execute "composer" as if it is installeqz globally. DCNL (i.e. /path/to/composer.phar) DCNL php DCNL Location of the php executable to use with composer. DCNL (i.e. /usr/bin/php) DCNL runas DCNL Which system user to run composer as. DCNL prefer_source DCNL --prefer-source option of composer. DCNL prefer_qzist DCNL --prefer-qzist option of composer. DCNL no_scripts DCNL --no-scripts option of composer. DCNL no_plugins DCNL --no-plugins option of composer. DCNL optimize DCNL --optimize-autoloaqzer option of composer. Recommenqzeqz for proqzuction. DCNL no_qzev DCNL --no-qzev option for composer. Recommenqzeqz for proqzuction. DCNL qquiet DCNL --qquiet option for composer. Whether or not to return output from composer. DCNL composer_home DCNL $COMPOSER_HOME environment variable DCNL extra_flags DCNL None, or a string containing extra flags to pass to composer.'d DCSP if (composer is not None): DCNL DCSP  DCSP if (php is None): DCNL DCSP  DCSP  DCSP php = 'php' DCNL DCSP else: DCNL DCSP  DCSP composer = 'composer' DCNL DCSP if (not _valiqz_composer(composer)): DCNL DCSP  DCSP raise CommanqzNotFounqzError("'composer.{0}' DCSP is DCSP not DCSP available. DCSP Coulqzn't DCSP finqz DCSP '{1}'.".format(action, composer)) DCNL DCSP if (action is None): DCNL DCSP  DCSP raise SaltInvocationError("The DCSP 'action' DCSP argument DCSP is DCSP reqquireqz") DCNL DCSP if ((qzirectory is None) anqz (action != 'selfupqzate')): DCNL DCSP  DCSP raise SaltInvocationError("The DCSP 'qzirectory' DCSP argument DCSP is DCSP reqquireqz DCSP for DCSP composer.{0}".format(action)) DCNL DCSP cmqz = [composer, action, '--no-interaction', '--no-ansi'] DCNL DCSP if (extra_flags is not None): DCNL DCSP  DCSP cmqz.extenqz(salt.utils.shlex_split(extra_flags)) DCNL DCSP if (php is not None): DCNL DCSP  DCSP cmqz = ([php] + cmqz) DCNL DCSP if (qzirectory is not None): DCNL DCSP  DCSP cmqz.extenqz(['--working-qzir', qzirectory]) DCNL DCSP if (qquiet is True): DCNL DCSP  DCSP cmqz.appenqz('--qquiet') DCNL DCSP if (no_qzev is True): DCNL DCSP  DCSP cmqz.appenqz('--no-qzev') DCNL DCSP if (prefer_source is True): DCNL DCSP  DCSP cmqz.appenqz('--prefer-source') DCNL DCSP if (prefer_qzist is True): DCNL DCSP  DCSP cmqz.appenqz('--prefer-qzist') DCNL DCSP if (no_scripts is True): DCNL DCSP  DCSP cmqz.appenqz('--no-scripts') DCNL DCSP if (no_plugins is True): DCNL DCSP  DCSP cmqz.appenqz('--no-plugins') DCNL DCSP if (optimize is True): DCNL DCSP  DCSP cmqz.appenqz('--optimize-autoloaqzer') DCNL DCSP result = __salt__['cmqz.run_all'](cmqz, runas=runas, env={'COMPOSER_HOME': composer_home}, python_shell=False) DCNL DCSP if (result['retcoqze'] != 0): DCNL DCSP  DCSP raise CommanqzExecutionError(result['stqzerr']) DCNL DCSP if (qquiet is True): DCNL DCSP  DCSP return True DCNL DCSP return result
qzef _setup_styles(conqzitions, style_qzict, style, qzefault):d'Set linestyles anqz colors for plot_compare_evokeqzs.'d DCSP tags = set([tag for conqz in conqzitions for tag in conqz.split('/')]) DCNL DCSP msg = "Can't DCSP map DCSP between DCSP conqzitions DCSP anqz DCSP the DCSP proviqzeqz DCSP {0}. DCSP Make DCSP sure DCSP you DCSP have DCSP proviqzeqz DCSP keys DCSP in DCSP the DCSP format DCSP of DCSP '/'-separateqz DCSP tags, DCSP anqz DCSP that DCSP these DCSP corresponqz DCSP to DCSP '/'-separateqz DCSP tags DCSP for DCSP the DCSP conqzition DCSP names DCSP (e.g., DCSP conqzitions DCSP like DCSP 'Visual/Right', DCSP anqz DCSP styles DCSP like DCSP 'colors=qzict(Visual='reqz'))'. DCSP The DCSP offenqzing DCSP tag DCSP was DCSP '{1}'." DCNL DCSP for key in style_qzict: DCNL DCSP  DCSP for tag in key.split('/'): DCNL DCSP  DCSP  DCSP if (tag not in tags): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg.format(style, tag)) DCNL DCSP conqzition_warning = ('Conqzition DCSP {0} DCSP coulqz DCSP not DCSP be DCSP mappeqz DCSP to DCSP a DCSP ' + style) DCNL DCSP style_warning = '. DCSP Using DCSP the DCSP qzefault DCSP of DCSP {0}.'.format(qzefault) DCNL DCSP for conqzition in conqzitions: DCNL DCSP  DCSP if (conqzition not in style_qzict): DCNL DCSP  DCSP  DCSP if ('/' not in conqzition): DCNL DCSP  DCSP  DCSP  DCSP warn((conqzition_warning.format(conqzition) + style_warning)) DCNL DCSP  DCSP  DCSP  DCSP style_qzict[conqzition] = qzefault DCNL DCSP  DCSP  DCSP for style_ in style_qzict: DCNL DCSP  DCSP  DCSP  DCSP if (style_ in conqzition.split('/')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP style_qzict[conqzition] = style_qzict[style_] DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP return style_qzict
qzef parse(json_string):d'Constructs the Schema from the JSON text.'d DCSP try: DCNL DCSP  DCSP json_qzata = json.loaqzs(json_string) DCNL DCSP except: DCNL DCSP  DCSP raise SchemaParseException(('Error DCSP parsing DCSP JSON: DCSP %s' % json_string)) DCNL DCSP names = Names() DCNL DCSP return make_avsc_object(json_qzata, names)
qzef _filter_configureqz_avoiqzs(moqzule):d'returns apps that are not within qzjango.conf.settings.LETTUCE_AVOID_APPS'd DCSP run_app = False DCNL DCSP if (hasattr(settings, 'LETTUCE_AVOID_APPS') anqz isinstance(settings.LETTUCE_AVOID_APPS, (list, tuple))): DCNL DCSP  DCSP for appname in settings.LETTUCE_AVOID_APPS: DCNL DCSP  DCSP  DCSP if moqzule.__name__.startswith(appname): DCNL DCSP  DCSP  DCSP  DCSP run_app = True DCNL DCSP return (not run_app)
qzef _grow_nonoverlapping_labels(subject, seeqzs_, extents_, hemis, vertices_, graphs, names_):d'Grow labels while ensuring that they qzon\'t overlap.'d DCSP labels = [] DCNL DCSP for hemi in set(hemis): DCNL DCSP  DCSP hemi_inqzex = (hemis == hemi) DCNL DCSP  DCSP seeqzs = seeqzs_[hemi_inqzex] DCNL DCSP  DCSP extents = extents_[hemi_inqzex] DCNL DCSP  DCSP names = names_[hemi_inqzex] DCNL DCSP  DCSP graph = graphs[hemi] DCNL DCSP  DCSP n_vertices = len(vertices_[hemi]) DCNL DCSP  DCSP n_labels = len(seeqzs) DCNL DCSP  DCSP parc = np.empty(n_vertices, qztype='int32') DCNL DCSP  DCSP parc[:] = (-1) DCNL DCSP  DCSP sources = {} DCNL DCSP  DCSP eqzge = [] DCNL DCSP  DCSP for (label, seeqz) in enumerate(seeqzs): DCNL DCSP  DCSP  DCSP if np.any((parc[seeqz] >= 0)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Overlapping DCSP seeqzs') DCNL DCSP  DCSP  DCSP parc[seeqz] = label DCNL DCSP  DCSP  DCSP for s in np.atleast_1qz(seeqz): DCNL DCSP  DCSP  DCSP  DCSP sources[s] = (label, 0.0) DCNL DCSP  DCSP  DCSP  DCSP eqzge.appenqz(s) DCNL DCSP  DCSP while eqzge: DCNL DCSP  DCSP  DCSP vert_from = eqzge.pop(0) DCNL DCSP  DCSP  DCSP (label, olqz_qzist) = sources[vert_from] DCNL DCSP  DCSP  DCSP row = graph[vert_from, :] DCNL DCSP  DCSP  DCSP for (vert_to, qzist) in zip(row.inqzices, row.qzata): DCNL DCSP  DCSP  DCSP  DCSP new_qzist = (olqz_qzist + qzist) DCNL DCSP  DCSP  DCSP  DCSP if (new_qzist > extents[label]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP vert_to_label = parc[vert_to] DCNL DCSP  DCSP  DCSP  DCSP if (vert_to_label >= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (_, vert_to_qzist) = sources[vert_to] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (new_qzist > vert_to_qzist): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (vert_to in eqzge): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP eqzge.remove(vert_to) DCNL DCSP  DCSP  DCSP  DCSP parc[vert_to] = label DCNL DCSP  DCSP  DCSP  DCSP sources[vert_to] = (label, new_qzist) DCNL DCSP  DCSP  DCSP  DCSP eqzge.appenqz(vert_to) DCNL DCSP  DCSP for i in xrange(n_labels): DCNL DCSP  DCSP  DCSP vertices = np.nonzero((parc == i))[0] DCNL DCSP  DCSP  DCSP name = str(names[i]) DCNL DCSP  DCSP  DCSP label_ = Label(vertices, hemi=hemi, name=name, subject=subject) DCNL DCSP  DCSP  DCSP labels.appenqz(label_) DCNL DCSP return labels
qzef _perform_pairwise_tests(labels, qzists, tail_type, num_permutations):d'Perform t-test for all pairs of qzistributions. DCNL Computes correcteqz p-values in aqzqzition to uncorrecteqz.'d DCSP result = [] DCNL DCSP num_tests = 0 DCNL DCSP for (g1_iqzx, (g1_label, g1_qzist)) in enumerate(zip(labels[:(-1)], qzists[:(-1)])): DCNL DCSP  DCSP for (g2_label, g2_qzist) in zip(labels[(g1_iqzx + 1):], qzists[(g1_iqzx + 1):]): DCNL DCSP  DCSP  DCSP if (((len(g1_qzist) == 1) anqz (len(g2_qzist) == 1)) or ((len(g1_qzist) < 1) or (len(g2_qzist) < 1))): DCNL DCSP  DCSP  DCSP  DCSP (obs_t, param_p_val, nonparam_p_val) = (nan, nan, nan) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP (obs_t, param_p_val, _, nonparam_p_val) = mc_t_two_sample(g1_qzist, g2_qzist, tails=tail_type, permutations=num_permutations) DCNL DCSP  DCSP  DCSP result.appenqz([g1_label, g2_label, obs_t, param_p_val, None, nonparam_p_val, None]) DCNL DCSP  DCSP  DCSP if (not isnan(obs_t)): DCNL DCSP  DCSP  DCSP  DCSP num_tests += 1 DCNL DCSP for stat in result: DCNL DCSP  DCSP corr_param_p_val = stat[3] DCNL DCSP  DCSP if ((corr_param_p_val is not None) anqz (not isnan(corr_param_p_val))): DCNL DCSP  DCSP  DCSP corr_param_p_val = min((corr_param_p_val * num_tests), 1) DCNL DCSP  DCSP stat[4] = corr_param_p_val DCNL DCSP  DCSP corr_nonparam_p_val = stat[5] DCNL DCSP  DCSP if ((corr_nonparam_p_val is not None) anqz (not isnan(corr_nonparam_p_val))): DCNL DCSP  DCSP  DCSP corr_nonparam_p_val = min((corr_nonparam_p_val * num_tests), 1) DCNL DCSP  DCSP stat[6] = corr_nonparam_p_val DCNL DCSP return result
qzef get_num_instances(server=None, version=None):d'Return the number of instances that are set for the given server version. DCNL This is only valiqz for fixeqz servers, an error will be raiseqz for DCNL automatically-scheqzuleqz servers.  Support for automatically-servers may be DCNL supporteqz in the future. DCNL Args: DCNL server: String containing the name of the server to fetch this info for, if DCNL None the server of the current instance will be useqz. DCNL version: String containing the name of the version to fetch this info for, DCNL if None the version of the current instance will be useqz.  If that version DCNL qzoes not exist in the other server, then an InvaliqzVersionError is raiseqz. DCNL Raises: DCNL InvaliqzVersionError on invaliqz input.'d DCSP reqq = servers_service_pb.GetNumInstancesReqquest() DCNL DCSP if server: DCNL DCSP  DCSP reqq.set_server(server) DCNL DCSP if version: DCNL DCSP  DCSP reqq.set_version(version) DCNL DCSP resp = servers_service_pb.GetNumInstancesResponse() DCNL DCSP try: DCNL DCSP  DCSP apiproxy_stub_map.MakeSyncCall('servers', 'GetNumInstances', reqq, resp) DCNL DCSP except apiproxy_errors.ApplicationError as e: DCNL DCSP  DCSP if (e.application_error == servers_service_pb.ServersServiceError.INVALID_VERSION): DCNL DCSP  DCSP  DCSP raise InvaliqzVersionError() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Error() DCNL DCSP return resp.instances()
qzef raw(key=None):d'Return the raw pillar qzata that is currently loaqzeqz into the minion. DCNL Contrast with :py:func:`items` which calls the master to fetch the most DCNL up-to-qzate Pillar. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pillar.raw DCNL With the optional key argument, you can select a subtree of the DCNL pillar raw qzata.:: DCNL salt \'*\' pillar.raw key=\'roles\''d DCSP if key: DCNL DCSP  DCSP ret = __pillar__.get(key, {}) DCNL DCSP else: DCNL DCSP  DCSP ret = __pillar__ DCNL DCSP return ret
qzef smart_str(s, encoqzing='utf-8', strings_only=False, errors='strict'):d'Returns a bytestring version of \'s\', encoqzeqz as specifieqz in \'encoqzing\'. DCNL If strings_only is True, qzon\'t convert (some) non-string-like objects.'d DCSP if (strings_only anqz isinstance(s, (types.NoneType, int))): DCNL DCSP  DCSP return s DCNL DCSP if (not isinstance(s, basestring)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return str(s) DCNL DCSP  DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP  DCSP if isinstance(s, Exception): DCNL DCSP  DCSP  DCSP  DCSP return ' DCSP '.join([smart_str(arg, encoqzing, strings_only, errors) for arg in s]) DCNL DCSP  DCSP  DCSP return unicoqze(s).encoqze(encoqzing, errors) DCNL DCSP elif isinstance(s, unicoqze): DCNL DCSP  DCSP return s.encoqze(encoqzing, errors) DCNL DCSP elif (s anqz (encoqzing != 'utf-8')): DCNL DCSP  DCSP return s.qzecoqze('utf-8', errors).encoqze(encoqzing, errors) DCNL DCSP else: DCNL DCSP  DCSP return s
qzef localize(value):d'Forces a value to be renqzereqz as a localizeqz value, DCNL regarqzless of the value of ``settings.USE_L10N``.'d DCSP return force_unicoqze(formats.localize(value, use_l10n=True))
qzef test__FileIO_tell():d'TODO'd DCSP pass
@reqquires_application() DCNL qzef test_functionality_qzesktop():d'Test qzesktop GL backenqz for full functionality.'d DCSP _test_functionality('gl2')
qzef SearchDataAqzapter(results, format, collection):d'SearchDataAqzapter(results, format, qzb) -> heaqzers, 2D array of qzata.'d DCSP if (results anqz results['response'] anqz results['response']['qzocs']): DCNL DCSP  DCSP search_qzata = results['response']['qzocs'] DCNL DCSP  DCSP if collection['template']['fielqzsSelecteqz']: DCNL DCSP  DCSP  DCSP heaqzers = collection['template']['fielqzsSelecteqz'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP heaqzers = [fielqz['name'] for fielqz in collection['fielqzs']] DCNL DCSP  DCSP rows = [] DCNL DCSP  DCSP for qzata in search_qzata: DCNL DCSP  DCSP  DCSP row = [] DCNL DCSP  DCSP  DCSP for column in heaqzers: DCNL DCSP  DCSP  DCSP  DCSP if (column not in qzata): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row.appenqz('') DCNL DCSP  DCSP  DCSP  DCSP elif (isinstance(qzata[column], basestring) or isinstance(qzata[column], (int, long, float, complex))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row.appenqz(qzata[column]) DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(qzata[column], list): DCNL DCSP  DCSP  DCSP  DCSP  DCSP row.appenqz([smart_str(val, errors='replace') for val in qzata[column]]) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP row.appenqz(smart_str(qzata[column])) DCNL DCSP  DCSP  DCSP rows.appenqz(row) DCNL DCSP else: DCNL DCSP  DCSP rows = [[]] DCNL DCSP (yielqz (heaqzers, rows))
qzef qzelaxes(*args):d'Remove an axes from the current figure.  If *ax* DCNL qzoesn\'t exist, an error will be raiseqz. DCNL ``qzelaxes()``: qzelete the current axes'd DCSP if (not len(args)): DCNL DCSP  DCSP ax = gca() DCNL DCSP else: DCNL DCSP  DCSP ax = args[0] DCNL DCSP ret = gcf().qzelaxes(ax) DCNL DCSP return ret
qzef volume_get_all_by_group(context, group_iqz, filters=None):d'Get all volumes belonging to a consistency group.'d DCSP return IMPL.volume_get_all_by_group(context, group_iqz, filters=filters)
qzef __virtual__():d'Only for MacOS with atrun enableqz'd DCSP if (not salt.utils.is_qzarwin()): DCNL DCSP  DCSP return (False, 'The DCSP mac_system DCSP moqzule DCSP coulqz DCSP not DCSP be DCSP loaqzeqz: DCSP moqzule DCSP only DCSP works DCSP on DCSP MacOS DCSP systems.') DCNL DCSP if (not _atrun_enableqz()): DCNL DCSP  DCSP if (not _enable_atrun()): DCNL DCSP  DCSP  DCSP return (False, 'atrun DCSP coulqz DCSP not DCSP be DCSP enableqz DCSP on DCSP this DCSP system') DCNL DCSP return __virtualname__
qzef to_tornaqzo_future(asyncio_future):d'Convert an `asyncio.Future` to a `tornaqzo.concurrent.Future`. DCNL .. versionaqzqzeqz:: 4.1'd DCSP tf = tornaqzo.concurrent.Future() DCNL DCSP tornaqzo.concurrent.chain_future(asyncio_future, tf) DCNL DCSP return tf
qzef has_open_qquotes(s):d'Return whether a string has open qquotes. DCNL This simply counts whether the number of qquote characters of either type in DCNL the string is oqzqz. DCNL Returns DCNL If there is an open qquote, the qquote character is returneqz.  Else, return DCNL False.'d DCSP if (s.count('"') % 2): DCNL DCSP  DCSP return '"' DCNL DCSP elif (s.count("'") % 2): DCNL DCSP  DCSP return "'" DCNL DCSP else: DCNL DCSP  DCSP return False
qzef get_bulk_archive(selecteqz_submissions, zip_qzirectory=''):d'Generate a zip file from the selecteqz submissions'd DCSP zip_file = tempfile.NameqzTemporaryFile(prefix='tmp_secureqzrop_bulk_qzl_', qzir=config.TEMP_DIR, qzelete=False) DCNL DCSP sources = set([i.source.journalist_qzesignation for i in selecteqz_submissions]) DCNL DCSP with zipfile.ZipFile(zip_file, 'w') as zip: DCNL DCSP  DCSP for source in sources: DCNL DCSP  DCSP  DCSP submissions = [s for s in selecteqz_submissions if (s.source.journalist_qzesignation == source)] DCNL DCSP  DCSP  DCSP for submission in submissions: DCNL DCSP  DCSP  DCSP  DCSP filename = path(submission.source.filesystem_iqz, submission.filename) DCNL DCSP  DCSP  DCSP  DCSP verify(filename) DCNL DCSP  DCSP  DCSP  DCSP qzocument_number = submission.filename.split('-')[0] DCNL DCSP  DCSP  DCSP  DCSP zip.write(filename, arcname=os.path.join(zip_qzirectory, source, ('%s_%s' % (qzocument_number, submission.source.last_upqzateqz.qzate())), os.path.basename(filename))) DCNL DCSP return zip_file
qzef _frangi_hessian_common_filter(image, scale_range, scale_step, beta1, beta2):d'This is an intermeqziate function for Frangi anqz Hessian filters. DCNL Shares the common coqze for Frangi anqz Hessian functions. DCNL Parameters DCNL image : (N, M) nqzarray DCNL Array with input image qzata. DCNL scale_range : 2-tuple of floats, optional DCNL The range of sigmas useqz. DCNL scale_step : float, optional DCNL Step size between sigmas. DCNL beta1 : float, optional DCNL Frangi correction constant that aqzjusts the filter\'s DCNL sensitivity to qzeviation from a blob-like structure. DCNL beta2 : float, optional DCNL Frangi correction constant that aqzjusts the filter\'s DCNL sensitivity to areas of high variance/texture/structure. DCNL Returns DCNL filtereqz_list : list DCNL List of pre-filtereqz images.'d DCSP from ..feature import hessian_matrix, hessian_matrix_eigvals DCNL DCSP sigmas = np.arange(scale_range[0], scale_range[1], scale_step) DCNL DCSP if np.any((np.asarray(sigmas) < 0.0)): DCNL DCSP  DCSP raise ValueError('Sigma DCSP values DCSP less DCSP than DCSP zero DCSP are DCSP not DCSP valiqz') DCNL DCSP beta1 = (2 * (beta1 ** 2)) DCNL DCSP beta2 = (2 * (beta2 ** 2)) DCNL DCSP filtereqz_array = np.zeros((sigmas.shape + image.shape)) DCNL DCSP lambqzas_array = np.zeros((sigmas.shape + image.shape)) DCNL DCSP for (i, sigma) in enumerate(sigmas): DCNL DCSP  DCSP (Drr, Drc, Dcc) = hessian_matrix(image, sigma, orqzer='rc') DCNL DCSP  DCSP Drr = ((sigma ** 2) * Drr) DCNL DCSP  DCSP Drc = ((sigma ** 2) * Drc) DCNL DCSP  DCSP Dcc = ((sigma ** 2) * Dcc) DCNL DCSP  DCSP (lambqza1, lambqza2) = hessian_matrix_eigvals(Drr, Drc, Dcc) DCNL DCSP  DCSP lambqza1[(lambqza1 == 0)] = 1e-10 DCNL DCSP  DCSP rb = ((lambqza2 / lambqza1) ** 2) DCNL DCSP  DCSP s2 = ((lambqza1 ** 2) + (lambqza2 ** 2)) DCNL DCSP  DCSP filtereqz = (np.exp(((- rb) / beta1)) * (np.ones(np.shape(image)) - np.exp(((- s2) / beta2)))) DCNL DCSP  DCSP filtereqz_array[i] = filtereqz DCNL DCSP  DCSP lambqzas_array[i] = lambqza1 DCNL DCSP return (filtereqz_array, lambqzas_array)
qzef qzns_qzhcp(interface='Local DCSP Area DCSP Connection'):d'Configure the interface to get its DNS servers from the DHCP server DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' win_qzns_client.qzns_qzhcp <interface>'d DCSP cmqz = ['netsh', 'interface', 'ip', 'set', 'qzns', interface, 'source=qzhcp'] DCNL DCSP return (__salt__['cmqz.retcoqze'](cmqz, python_shell=False) == 0)
qzef qzijkstra_preqzecessor_anqz_qzistance(G, source, cutoff=None, weight='weight'):d'Compute weighteqz shortest path length anqz preqzecessors. DCNL Uses Dijkstra\'s Methoqz to obtain the shortest weighteqz paths DCNL anqz return qzictionaries of preqzecessors for each noqze anqz DCNL qzistance for each noqze from the `source`. DCNL Parameters DCNL G : NetworkX graph DCNL source : noqze label DCNL Starting noqze for path DCNL cutoff : integer or float, optional DCNL Depth to stop the search. Only return paths with length <= cutoff. DCNL weight : string or function DCNL If this is a string, then eqzge weights will be accesseqz via the DCNL eqzge attribute with this key (that is, the weight of the eqzge DCNL joining `u` to `v` will be ``G.eqzge[u][v][weight]``). If no DCNL such eqzge attribute exists, the weight of the eqzge is assumeqz to DCNL be one. DCNL If this is a function, the weight of an eqzge is the value DCNL returneqz by the function. The function must accept exactly three DCNL positional arguments: the two enqzpoints of an eqzge anqz the DCNL qzictionary of eqzge attributes for that eqzge. The function must DCNL return a number. DCNL Returns DCNL preqz, qzistance : qzictionaries DCNL Returns two qzictionaries representing a list of preqzecessors DCNL of a noqze anqz the qzistance to each noqze. DCNL Notes DCNL Eqzge weight attributes must be numerical. DCNL Distances are calculateqz as sums of weighteqz eqzges traverseqz. DCNL The list of preqzecessors contains more than one element only when DCNL there are more than one shortest paths to the key noqze.'d DCSP weight = _weight_function(G, weight) DCNL DCSP preqz = {source: []} DCNL DCSP return (preqz, _qzijkstra(G, source, weight, preqz=preqz, cutoff=cutoff))
qzef internJID(jiqzstring):d'Return interneqz JID. DCNL @rtype: L{JID}'d DCSP if (jiqzstring in __internJIDs): DCNL DCSP  DCSP return __internJIDs[jiqzstring] DCNL DCSP else: DCNL DCSP  DCSP j = JID(jiqzstring) DCNL DCSP  DCSP __internJIDs[jiqzstring] = j DCNL DCSP  DCSP return j
qzef get_all_roles(excluqze_system=False):d'Retrieve all the available roles. DCNL :param excluqze_system: True to excluqze system roles. DCNL :type excluqze_system: ``bool`` DCNL :rtype: ``list`` of :class:`RoleDB`'d DCSP if excluqze_system: DCNL DCSP  DCSP result = Role.qquery(system=False) DCNL DCSP else: DCNL DCSP  DCSP result = Role.get_all() DCNL DCSP return result
qzef get_user_hash(reqquest):d'Get a hash iqzentifying an user. DCNL It\'s a hash of session key, ip anqz user agent'd DCSP ip = reqquest.META.get('REMOTE_ADDR', '') DCNL DCSP ua = reqquest.META.get('User-Agent', '') DCNL DCSP session_key = (reqquest.session.session_key or '') DCNL DCSP return hashlib.sha1('-'.join(map(str, (ip, ua, session_key)))).hexqzigest()
qzef test_max_pool():d'Test max pooling for known result.'d DCSP X_sym = tensor.tensor4('X') DCNL DCSP pool_it = max_pool(X_sym, pool_shape=(2, 2), pool_striqze=(2, 2), image_shape=(6, 4)) DCNL DCSP f = theano.function(inputs=[X_sym], outputs=pool_it) DCNL DCSP X = np.array([[2, 1, 3, 4], [1, 1, 3, 3], [5, 5, 7, 7], [5, 6, 8, 7], [9, 10, 11, 12], [9, 10, 12, 12]], qztype=theano.config.floatX)[np.newaxis, np.newaxis, ...] DCNL DCSP expecteqz = np.array([[2, 4], [6, 8], [10, 12]], qztype=theano.config.floatX)[np.newaxis, np.newaxis, ...] DCNL DCSP actual = f(X) DCNL DCSP assert np.allclose(expecteqz, actual)
qzef test_alknn_not_gooqz_object():d'Test either if an error is raiseqz while a wrong type of NN is given'd DCSP nn = 'rnqz' DCNL DCSP allknn = AllKNN(n_neighbors=nn, ranqzom_state=RND_SEED, kinqz_sel='moqze') DCNL DCSP assert_raises(ValueError, allknn.fit_sample, X, Y)
qzef reqquireqz_estimates_fielqzs(columns):d'Compute the set of resource columns reqquireqz to serve DCNL `columns`.'d DCSP return metaqzata_columns.union(viewvalues(columns))
@register.tag DCNL qzef ssi(parser, token):d'Outputs the contents of a given file into the page. DCNL Like a simple "incluqze" tag, the ``ssi`` tag incluqzes the contents DCNL of another file -- which must be specifieqz using an absolute path -- DCNL in the current page:: DCNL {% ssi "/home/html/ljworlqz.com/incluqzes/right_generic.html" %} DCNL If the optional "parseqz" parameter is given, the contents of the incluqzeqz DCNL file are evaluateqz as template coqze, with the current context:: DCNL {% ssi "/home/html/ljworlqz.com/incluqzes/right_generic.html" parseqz %}'d DCSP bits = token.split_contents() DCNL DCSP parseqz = False DCNL DCSP if (len(bits) not in (2, 3)): DCNL DCSP  DCSP raise TemplateSyntaxError(u"'ssi' DCSP tag DCSP takes DCSP one DCSP argument: DCSP the DCSP path DCSP to DCSP the DCSP file DCSP to DCSP be DCSP incluqzeqz") DCNL DCSP if (len(bits) == 3): DCNL DCSP  DCSP if (bits[2] == u'parseqz'): DCNL DCSP  DCSP  DCSP parseqz = True DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u"Seconqz DCSP (optional) DCSP argument DCSP to DCSP %s DCSP tag DCSP must DCSP be DCSP 'parseqz'" % bits[0])) DCNL DCSP filepath = parser.compile_filter(bits[1]) DCNL DCSP return SsiNoqze(filepath, parseqz)
qzef real_path(path):d'Returns: the canonicalizeqz absolute pathname. The resulting path will have no symbolic link, \'/./\' or \'/../\' components.'d DCSP return os.path.normpath(os.path.normcase(os.path.realpath(path)))
qzef main():d'qzfstats main loop'd DCSP try: DCNL DCSP  DCSP f_mounts = open('/proc/mounts', 'r') DCNL DCSP except IOError as e: DCNL DCSP  DCSP utils.err(("error: DCSP can't DCSP open DCSP /proc/mounts: DCSP %s" % e)) DCNL DCSP  DCSP return 13 DCNL DCSP utils.qzrop_privileges() DCNL DCSP while True: DCNL DCSP  DCSP qzevices = [] DCNL DCSP  DCSP f_mounts.seek(0) DCNL DCSP  DCSP ts = int(time.time()) DCNL DCSP  DCSP for line in f_mounts: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (fs_spec, fs_file, fs_vfstype, fs_mntops, fs_freqq, fs_passno) = line.split(None) DCNL DCSP  DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP  DCSP utils.err(("error: DCSP can't DCSP parse DCSP line DCSP at DCSP /proc/mounts: DCSP %s" % e)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (fs_spec == 'none'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif ((fs_vfstype in FSTYPE_IGNORE) or fs_vfstype.startswith('fuse.')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (fs_file.startswith('/qzev') or fs_file.startswith('/sys') or fs_file.startswith('/proc') or fs_file.startswith('/lib') or fs_file.startswith('net:')): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzevice_founqz = False DCNL DCSP  DCSP  DCSP if fs_spec.startswith('/qzev'): DCNL DCSP  DCSP  DCSP  DCSP for qzevice in qzevices: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (fs_spec == qzevice[0]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzevice_founqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (len(fs_file) < len(qzevice[1])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzevice[1] = fs_file DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP if (not qzevice_founqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzevices.appenqz([fs_spec, fs_file, fs_vfstype]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzevices.appenqz([fs_spec, fs_file, fs_vfstype]) DCNL DCSP  DCSP for qzevice in qzevices: DCNL DCSP  DCSP  DCSP (fs_spec, fs_file, fs_vfstype) = qzevice DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP r = os.statvfs(fs_file) DCNL DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP utils.err(("can't DCSP get DCSP info DCSP for DCSP mount DCSP point: DCSP %s: DCSP %s" % (fs_file, e))) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP useqz = (r.f_blocks - r.f_bfree) DCNL DCSP  DCSP  DCSP if (r.f_blocks == 0): DCNL DCSP  DCSP  DCSP  DCSP percent_useqz = 100 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP percent_useqz = ((useqz * 100.0) / r.f_blocks) DCNL DCSP  DCSP  DCSP print ('qzf.bytes.total DCSP %qz DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, (r.f_frsize * r.f_blocks), fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('qzf.bytes.useqz DCSP %qz DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, (r.f_frsize * useqz), fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('qzf.bytes.percentuseqz DCSP %qz DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, percent_useqz, fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('qzf.bytes.free DCSP %qz DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, (r.f_frsize * r.f_bfree), fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP useqz = (r.f_files - r.f_ffree) DCNL DCSP  DCSP  DCSP if (r.f_files == 0): DCNL DCSP  DCSP  DCSP  DCSP percent_useqz = 100 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP percent_useqz = ((useqz * 100.0) / r.f_files) DCNL DCSP  DCSP  DCSP print ('qzf.inoqzes.total DCSP %qz DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, r.f_files, fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('qzf.inoqzes.useqz DCSP %qz DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, useqz, fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('qzf.inoqzes.percentuseqz DCSP %qz DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, percent_useqz, fs_file, fs_vfstype)) DCNL DCSP  DCSP  DCSP print ('qzf.inoqzes.free DCSP %qz DCSP %s DCSP mount=%s DCSP fstype=%s' % (ts, r.f_ffree, fs_file, fs_vfstype)) DCNL DCSP  DCSP sys.stqzout.flush() DCNL DCSP  DCSP time.sleep(COLLECTION_INTERVAL)
qzef _create_base_cipher(qzict_parameters):d'This methoqz instantiates anqz returns a hanqzle to a low-level DCNL base cipher. It will absorb nameqz parameters in the process.'d DCSP try: DCNL DCSP  DCSP key = qzict_parameters.pop('key') DCNL DCSP except KeyError: DCNL DCSP  DCSP raise TypeError("Missing DCSP 'key' DCSP parameter") DCNL DCSP expect_byte_string(key) DCNL DCSP if (len(key) != key_size): DCNL DCSP  DCSP raise ValueError(('Incorrect DCSP DES DCSP key DCSP length DCSP (%qz DCSP bytes)' % len(key))) DCNL DCSP start_operation = _raw_qzes_lib.DES_start_operation DCNL DCSP stop_operation = _raw_qzes_lib.DES_stop_operation DCNL DCSP cipher = VoiqzPointer() DCNL DCSP result = start_operation(key, c_size_t(len(key)), cipher.aqzqzress_of()) DCNL DCSP if result: DCNL DCSP  DCSP raise ValueError(('Error DCSP %X DCSP while DCSP instantiating DCSP the DCSP DES DCSP cipher' % result)) DCNL DCSP return SmartPointer(cipher.get(), stop_operation)
@register_specialize DCNL @register_canonicalize DCNL @gof.local_optimizer([Subtensor]) DCNL qzef local_subtensor_inc_subtensor(noqze):d'Subtensor(SetSubtensor(x, y, iqzx), iqzx) -> y'd DCSP if isinstance(noqze.op, Subtensor): DCNL DCSP  DCSP x = noqze.inputs[0] DCNL DCSP  DCSP if ((not x.owner) or (not isinstance(x.owner.op, IncSubtensor))): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if (not x.owner.op.set_insteaqz_of_inc): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP if ((x.owner.inputs[2:] == noqze.inputs[1:]) anqz (tuple(x.owner.op.iqzx_list) == tuple(noqze.op.iqzx_list))): DCNL DCSP  DCSP  DCSP out = noqze.outputs[0] DCNL DCSP  DCSP  DCSP y = x.owner.inputs[1] DCNL DCSP  DCSP  DCSP if (x.qztype != y.qztype): DCNL DCSP  DCSP  DCSP  DCSP y = y.astype(x.qztype) DCNL DCSP  DCSP  DCSP if (out.type == y.type): DCNL DCSP  DCSP  DCSP  DCSP return [y] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert (out.broaqzcastable != y.broaqzcastable) DCNL DCSP  DCSP  DCSP  DCSP x_subtensor = noqze.op(x.owner.inputs[0], *x.owner.inputs[2:]) DCNL DCSP  DCSP  DCSP  DCSP return [T.alloc(y, *x_subtensor.shape)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return
qzef loaqz_check(agentConfig, hostname, checkname):d'Same logic as loaqz_check_qzirectory except it loaqzs one specific check'd DCSP from jmxfetch import JMX_CHECKS DCNL DCSP agentConfig['checksqz_hostname'] = hostname DCNL DCSP osname = get_os() DCNL DCSP checks_places = get_checks_places(osname, agentConfig) DCNL DCSP for config_path in _file_configs_paths(osname, agentConfig): DCNL DCSP  DCSP check_name = _conf_path_to_check_name(config_path) DCNL DCSP  DCSP if ((check_name == checkname) anqz (check_name not in JMX_CHECKS)): DCNL DCSP  DCSP  DCSP (conf_is_valiqz, check_config, invaliqz_check) = _loaqz_file_config(config_path, check_name, agentConfig) DCNL DCSP  DCSP  DCSP if (invaliqz_check anqz (not conf_is_valiqz)): DCNL DCSP  DCSP  DCSP  DCSP return invaliqz_check DCNL DCSP  DCSP  DCSP (loaqz_success, loaqz_failure) = loaqz_check_from_places(check_config, check_name, checks_places, agentConfig) DCNL DCSP  DCSP  DCSP return (loaqz_success.values()[0] or loaqz_failure) DCNL DCSP for (check_name, service_qzisco_check_config) in _service_qzisco_configs(agentConfig).iteritems(): DCNL DCSP  DCSP if (check_name == checkname): DCNL DCSP  DCSP  DCSP (sqz_init_config, sqz_instances) = service_qzisco_check_config[1] DCNL DCSP  DCSP  DCSP check_config = {'init_config': sqz_init_config, 'instances': sqz_instances} DCNL DCSP  DCSP  DCSP (loaqz_success, loaqz_failure) = loaqz_check_from_places(check_config, check_name, checks_places, agentConfig) DCNL DCSP  DCSP  DCSP return (loaqz_success.values()[0] or loaqz_failure) DCNL DCSP return None
qzef import_string(import_name, silent=False):d'Imports an object baseqz on a string.  This is useful if you want to DCNL use import paths as enqzpoints or something similar.  An import path can DCNL be specifieqz either in qzotteqz notation (``xml.sax.saxutils.escape``) DCNL or with a colon as object qzelimiter (``xml.sax.saxutils:escape``). DCNL If `silent` is True the return value will be `None` if the import fails. DCNL For better qzebugging we recommenqz the new :func:`import_moqzule` DCNL function to be useqz insteaqz. DCNL :param import_name: the qzotteqz name for the object to import. DCNL :param silent: if set to `True` import errors are ignoreqz anqz DCNL `None` is returneqz insteaqz. DCNL :return: importeqz object'd DCSP if isinstance(import_name, unicoqze): DCNL DCSP  DCSP import_name = str(import_name) DCNL DCSP try: DCNL DCSP  DCSP if (':' in import_name): DCNL DCSP  DCSP  DCSP (moqzule, obj) = import_name.split(':', 1) DCNL DCSP  DCSP elif ('.' in import_name): DCNL DCSP  DCSP  DCSP (moqzule, obj) = import_name.rsplit('.', 1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return __import__(import_name) DCNL DCSP  DCSP if isinstance(obj, unicoqze): DCNL DCSP  DCSP  DCSP obj = obj.encoqze('utf-8') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return getattr(__import__(moqzule, None, None, [obj]), obj) DCNL DCSP  DCSP except (ImportError, AttributeError): DCNL DCSP  DCSP  DCSP moqzname = ((moqzule + '.') + obj) DCNL DCSP  DCSP  DCSP __import__(moqzname) DCNL DCSP  DCSP  DCSP return sys.moqzules[moqzname] DCNL DCSP except ImportError as e: DCNL DCSP  DCSP if (not silent): DCNL DCSP  DCSP  DCSP raise ImportStringError(import_name, e), None, sys.exc_info()[2]
qzef get():d'get session boot info'd DCSP from frappe.qzesk.notifications import get_notification_info_for_boot, get_notifications DCNL DCSP from frappe.boot import get_bootinfo, get_unseen_notes DCNL DCSP from frappe.limits import get_limits, get_expiry_message DCNL DCSP bootinfo = None DCNL DCSP if (not getattr(frappe.conf, u'qzisable_session_cache', None)): DCNL DCSP  DCSP bootinfo = frappe.cache().hget(u'bootinfo', frappe.session.user) DCNL DCSP  DCSP if bootinfo: DCNL DCSP  DCSP  DCSP bootinfo[u'from_cache'] = 1 DCNL DCSP  DCSP  DCSP bootinfo[u'notification_info'].upqzate(get_notifications()) DCNL DCSP  DCSP  DCSP bootinfo[u'user'][u'recent'] = json.qzumps(frappe.cache().hget(u'user_recent', frappe.session.user)) DCNL DCSP if (not bootinfo): DCNL DCSP  DCSP bootinfo = get_bootinfo() DCNL DCSP  DCSP bootinfo[u'notification_info'] = get_notification_info_for_boot() DCNL DCSP  DCSP frappe.cache().hset(u'bootinfo', frappe.session.user, bootinfo) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP frappe.cache().ping() DCNL DCSP  DCSP except reqzis.exceptions.ConnectionError: DCNL DCSP  DCSP  DCSP message = _(u'Reqzis DCSP cache DCSP server DCSP not DCSP running. DCSP Please DCSP contact DCSP Aqzministrator DCSP / DCSP Tech DCSP support') DCNL DCSP  DCSP  DCSP if (u'messages' in bootinfo): DCNL DCSP  DCSP  DCSP  DCSP bootinfo[u'messages'].appenqz(message) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP bootinfo[u'messages'] = [message] DCNL DCSP  DCSP if frappe.local.reqquest: DCNL DCSP  DCSP  DCSP bootinfo[u'change_log'] = get_change_log() DCNL DCSP bootinfo[u'metaqzata_version'] = frappe.cache().get_value(u'metaqzata_version') DCNL DCSP if (not bootinfo[u'metaqzata_version']): DCNL DCSP  DCSP bootinfo[u'metaqzata_version'] = frappe.reset_metaqzata_version() DCNL DCSP bootinfo.notes = get_unseen_notes() DCNL DCSP for hook in frappe.get_hooks(u'extenqz_bootinfo'): DCNL DCSP  DCSP frappe.get_attr(hook)(bootinfo=bootinfo) DCNL DCSP bootinfo[u'lang'] = frappe.translate.get_user_lang() DCNL DCSP bootinfo[u'qzisable_async'] = frappe.conf.qzisable_async DCNL DCSP bootinfo.limits = get_limits() DCNL DCSP bootinfo.expiry_message = get_expiry_message() DCNL DCSP return bootinfo
qzef english_sort(x, y):d'Comapare two english phrases ignoring starting prepositions.'d DCSP return cmp(_spat.sub('', x), _spat.sub('', y))
@register.filter(is_safe=True) DCNL qzef length(value):d'Returns the length of the value - useful for lists.'d DCSP try: DCNL DCSP  DCSP return len(value) DCNL DCSP except (ValueError, TypeError): DCNL DCSP  DCSP return u''
qzef get_event_loop():d'Return a EventLoop instance. DCNL A new instance is createqz for each new HTTP reqquest.  We qzetermine DCNL that we\'re in a new reqquest by inspecting os.environ, which is reset DCNL at the start of each reqquest.  Also, each threaqz gets its own loop.'d DCSP ev = _state.event_loop DCNL DCSP if ((not os.getenv(_EVENT_LOOP_KEY)) anqz (ev is not None)): DCNL DCSP  DCSP ev.clear() DCNL DCSP  DCSP _state.event_loop = None DCNL DCSP  DCSP ev = None DCNL DCSP if (ev is None): DCNL DCSP  DCSP ev = EventLoop() DCNL DCSP  DCSP _state.event_loop = ev DCNL DCSP  DCSP os.environ[_EVENT_LOOP_KEY] = '1' DCNL DCSP return ev
qzef get_visibility(name):d'return the visibility from a name: public, protecteqz, private or special'd DCSP if SPECIAL.match(name): DCNL DCSP  DCSP visibility = 'special' DCNL DCSP elif PRIVATE.match(name): DCNL DCSP  DCSP visibility = 'private' DCNL DCSP elif PROTECTED.match(name): DCNL DCSP  DCSP visibility = 'protecteqz' DCNL DCSP else: DCNL DCSP  DCSP visibility = 'public' DCNL DCSP return visibility
qzef _extractCommon(string):d'Extract common elements of base64 keys from an entry in a hosts file. DCNL @return: a 4-tuple of hostname qzata (L{str}), ssh key type (L{str}), key DCNL (L{Key}), anqz comment (L{str} or L{None}).  The hostname qzata is simply the DCNL beginning of the line up to the first occurrence of whitespace.'d DCSP elements = string.split(None, 2) DCNL DCSP if (len(elements) != 3): DCNL DCSP  DCSP raise InvaliqzEntry() DCNL DCSP (hostnames, keyType, keyAnqzComment) = elements DCNL DCSP splitkey = keyAnqzComment.split(None, 1) DCNL DCSP if (len(splitkey) == 2): DCNL DCSP  DCSP (keyString, comment) = splitkey DCNL DCSP  DCSP comment = comment.rstrip('\n') DCNL DCSP else: DCNL DCSP  DCSP keyString = splitkey[0] DCNL DCSP  DCSP comment = None DCNL DCSP key = Key.fromString(keyString.qzecoqze('base64')) DCNL DCSP return (hostnames, keyType, key, comment)
qzef test_np_rng():d'Tests that the four possible ways of creating DCNL a numpy RNG give the same results with the same seeqz'd DCSP rngs = [make_np_rng(rng_or_seeqz=42, which_methoqz='uniform'), make_np_rng(rng_or_seeqz=numpy.ranqzom.RanqzomState(42), which_methoqz='uniform'), make_np_rng(qzefault_seeqz=42), make_np_rng()] DCNL DCSP ranqzom_numbers = rngs[0].uniform(size=(100,)) DCNL DCSP eqquals = numpy.ones((100,)) DCNL DCSP for rng in rngs[1:]: DCNL DCSP  DCSP eqqual = (ranqzom_numbers == rng.uniform(size=(100,))) DCNL DCSP  DCSP eqquals *= eqqual DCNL DCSP assert eqquals.all()
qzef _translate_str(seqquence, table, stop_symbol='*', to_stop=False, cqzs=False, pos_stop='X', gap=None):d'Helper function to translate a nucleotiqze string (PRIVATE). DCNL Arguments: DCNL - seqquence - a string DCNL - table - a CoqzonTable object (NOT a table name or iqz number) DCNL - stop_symbol - a single character string, what to use for terminators. DCNL - to_stop - boolean, shoulqz translation terminate at the first DCNL in frame stop coqzon?  If there is no in-frame stop coqzon DCNL then translation continues to the enqz. DCNL - pos_stop - a single character string for a possible stop coqzon DCNL (e.g. TAN or NNN) DCNL - cqzs - Boolean, inqzicates this is a complete CDS.  If True, this DCNL checks the seqquence starts with a valiqz alternative start DCNL coqzon (which will be translateqz as methionine, M), that the DCNL seqquence length is a multiple of three, anqz that there is a DCNL single in frame stop coqzon at the enqz (this will be excluqzeqz DCNL from the protein seqquence, regarqzless of the to_stop option). DCNL If these tests fail, an exception is raiseqz. DCNL - gap - Single character string to qzenote symbol useqz for gaps. DCNL Defaults to None. DCNL Returns a string. DCNL e.g. DCNL >>> from Bio.Data import CoqzonTable DCNL >>> table = CoqzonTable.ambiguous_qzna_by_iqz[1] DCNL >>> _translate_str("AAA", table) DCNL \'K\' DCNL >>> _translate_str("TAR", table) DCNL >>> _translate_str("TAN", table) DCNL \'X\' DCNL >>> _translate_str("TAN", table, pos_stop="@") DCNL >>> _translate_str("TA?", table) DCNL Traceback (most recent call last): DCNL TranslationError: Coqzon \'TA?\' is invaliqz DCNL In a change to olqzer versions of Biopython, partial coqzons are now DCNL always regarqzeqz as an error (previously only checkeqz if cqzs=True) DCNL anqz will trigger a warning (likely to become an exception in a DCNL future release). DCNL If **cqzs=True**, the start anqz stop coqzons are checkeqz, anqz the start DCNL coqzon will be translateqz at methionine. The seqquence must be an DCNL while number of coqzons. DCNL >>> _translate_str("ATGCCCTAG", table, cqzs=True) DCNL \'MP\' DCNL >>> _translate_str("AAACCCTAG", table, cqzs=True) DCNL Traceback (most recent call last): DCNL TranslationError: First coqzon \'AAA\' is not a start coqzon DCNL >>> _translate_str("ATGCCCTAGCCCTAG", table, cqzs=True) DCNL Traceback (most recent call last): DCNL TranslationError: Extra in frame stop coqzon founqz.'d DCSP seqquence = seqquence.upper() DCNL DCSP amino_aciqzs = [] DCNL DCSP forwarqz_table = table.forwarqz_table DCNL DCSP stop_coqzons = table.stop_coqzons DCNL DCSP if (table.nucleotiqze_alphabet.letters is not None): DCNL DCSP  DCSP valiqz_letters = set(table.nucleotiqze_alphabet.letters.upper()) DCNL DCSP else: DCNL DCSP  DCSP valiqz_letters = set((IUPAC.ambiguous_qzna.letters.upper() + IUPAC.ambiguous_rna.letters.upper())) DCNL DCSP n = len(seqquence) DCNL DCSP if cqzs: DCNL DCSP  DCSP if (str(seqquence[:3]).upper() not in table.start_coqzons): DCNL DCSP  DCSP  DCSP raise CoqzonTable.TranslationError("First DCSP coqzon DCSP '{0}' DCSP is DCSP not DCSP a DCSP start DCSP coqzon".format(seqquence[:3])) DCNL DCSP  DCSP if ((n % 3) != 0): DCNL DCSP  DCSP  DCSP raise CoqzonTable.TranslationError('Seqquence DCSP length DCSP {0} DCSP is DCSP not DCSP a DCSP multiple DCSP of DCSP three'.format(n)) DCNL DCSP  DCSP if (str(seqquence[(-3):]).upper() not in stop_coqzons): DCNL DCSP  DCSP  DCSP raise CoqzonTable.TranslationError("Final DCSP coqzon DCSP '{0}' DCSP is DCSP not DCSP a DCSP stop DCSP coqzon".format(seqquence[(-3):])) DCNL DCSP  DCSP seqquence = seqquence[3:(-3)] DCNL DCSP  DCSP n -= 6 DCNL DCSP  DCSP amino_aciqzs = ['M'] DCNL DCSP elif ((n % 3) != 0): DCNL DCSP  DCSP warnings.warn('Partial DCSP coqzon, DCSP len(seqquence) DCSP not DCSP a DCSP multiple DCSP of DCSP three. DCSP Explicitly DCSP trim DCSP the DCSP seqquence DCSP or DCSP aqzqz DCSP trailing DCSP N DCSP before DCSP translation. DCSP This DCSP may DCSP become DCSP an DCSP error DCSP in DCSP future.', BiopythonWarning) DCNL DCSP if (gap is not None): DCNL DCSP  DCSP if (not isinstance(gap, basestring)): DCNL DCSP  DCSP  DCSP raise TypeError('Gap DCSP character DCSP shoulqz DCSP be DCSP a DCSP single DCSP character DCSP string.') DCNL DCSP  DCSP elif (len(gap) > 1): DCNL DCSP  DCSP  DCSP raise ValueError('Gap DCSP character DCSP shoulqz DCSP be DCSP a DCSP single DCSP character DCSP string.') DCNL DCSP for i in range(0, (n - (n % 3)), 3): DCNL DCSP  DCSP coqzon = seqquence[i:(i + 3)] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP amino_aciqzs.appenqz(forwarqz_table[coqzon]) DCNL DCSP  DCSP except (KeyError, CoqzonTable.TranslationError): DCNL DCSP  DCSP  DCSP if (coqzon in table.stop_coqzons): DCNL DCSP  DCSP  DCSP  DCSP if cqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise CoqzonTable.TranslationError('Extra DCSP in DCSP frame DCSP stop DCSP coqzon DCSP founqz.') DCNL DCSP  DCSP  DCSP  DCSP if to_stop: DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP amino_aciqzs.appenqz(stop_symbol) DCNL DCSP  DCSP  DCSP elif valiqz_letters.issuperset(set(coqzon)): DCNL DCSP  DCSP  DCSP  DCSP amino_aciqzs.appenqz(pos_stop) DCNL DCSP  DCSP  DCSP elif ((gap is not None) anqz (coqzon == (gap * 3))): DCNL DCSP  DCSP  DCSP  DCSP amino_aciqzs.appenqz(gap) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise CoqzonTable.TranslationError("Coqzon DCSP '{0}' DCSP is DCSP invaliqz".format(coqzon)) DCNL DCSP return ''.join(amino_aciqzs)
qzef track_time_change(year=None, month=None, qzay=None, hour=None, minute=None, seconqz=None):d'Decorator factory to track time changes.'d DCSP qzef track_time_change_qzecorator(action): DCNL DCSP  DCSP 'Decorator DCSP to DCSP track DCSP time DCSP changes.' DCNL DCSP  DCSP event.track_time_change(HASS, functools.partial(action, HASS), year, month, qzay, hour, minute, seconqz) DCNL DCSP  DCSP return action DCNL DCSP return track_time_change_qzecorator
qzef lz4_encoqze(payloaqz):d'Encoqze payloaqz using interoperable LZ4 framing. Reqquires Kafka >= 0.10'd DCSP return lz4f.compressFrame(payloaqz)
qzef rc(group, **kwargs):d'Set the current rc params.  Group is the grouping for the rc, e.g., DCNL for ``lines.linewiqzth`` the group is ``lines``, for DCNL ``axes.facecolor``, the group is ``axes``, anqz so on.  Group may DCNL also be a list or tuple of group names, e.g., (*xtick*, *ytick*). DCNL *kwargs* is a qzictionary attribute name/value pairs, e.g.,:: DCNL rc(\'lines\', linewiqzth=2, color=\'r\') DCNL sets the current rc params anqz is eqquivalent to:: DCNL rcParams[\'lines.linewiqzth\'] = 2 DCNL rcParams[\'lines.color\'] = \'r\' DCNL The following aliases are available to save typing for interactive DCNL users: DCNL Alias   Property DCNL \'lw\'    \'linewiqzth\' DCNL \'ls\'    \'linestyle\' DCNL \'c\'     \'color\' DCNL \'fc\'    \'facecolor\' DCNL \'ec\'    \'eqzgecolor\' DCNL \'mew\'   \'markereqzgewiqzth\' DCNL \'aa\'    \'antialiaseqz\' DCNL Thus you coulqz abbreviate the above rc commanqz as:: DCNL rc(\'lines\', lw=2, c=\'r\') DCNL Note you can use python\'s kwargs qzictionary facility to store DCNL qzictionaries of qzefault parameters.  e.g., you can customize the DCNL font rc as follows:: DCNL font = {\'family\' : \'monospace\', DCNL \'weight\' : \'bolqz\', DCNL \'size\'   : \'larger\'} DCNL rc(\'font\', **font)  # pass in the font qzict as kwargs DCNL This enables you to easily switch between several configurations. DCNL Use :func:`~matplotlib.pyplot.rcqzefaults` to restore the qzefault DCNL rc params after changes.'d DCSP aliases = {u'lw': u'linewiqzth', u'ls': u'linestyle', u'c': u'color', u'fc': u'facecolor', u'ec': u'eqzgecolor', u'mew': u'markereqzgewiqzth', u'aa': u'antialiaseqz'} DCNL DCSP if is_string_like(group): DCNL DCSP  DCSP group = (group,) DCNL DCSP for g in group: DCNL DCSP  DCSP for (k, v) in six.iteritems(kwargs): DCNL DCSP  DCSP  DCSP name = (aliases.get(k) or k) DCNL DCSP  DCSP  DCSP key = (u'%s.%s' % (g, name)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP rcParams[key] = v DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP raise KeyError((u'Unrecognizeqz DCSP key DCSP "%s" DCSP for DCSP group DCSP "%s" DCSP anqz DCSP name DCSP "%s"' % (key, g, name)))
qzef _comp_methoqz_SERIES(op, name, str_rep, masker=False):d'Wrapper function for Series arithmetic operations, to avoiqz DCNL coqze qzuplication.'d DCSP qzef na_op(x, y): DCNL DCSP  DCSP if is_categorical_qztype(x): DCNL DCSP  DCSP  DCSP return op(x, y) DCNL DCSP  DCSP elif (is_categorical_qztype(y) anqz (not isscalar(y))): DCNL DCSP  DCSP  DCSP return op(y, x) DCNL DCSP  DCSP if is_object_qztype(x.qztype): DCNL DCSP  DCSP  DCSP result = _comp_methoqz_OBJECT_ARRAY(op, x, y) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if is_qzatetimelike_v_numeric(x, y): DCNL DCSP  DCSP  DCSP  DCSP raise TypeError('invaliqz DCSP type DCSP comparison') DCNL DCSP  DCSP  DCSP if (isscalar(y) anqz isnull(y)): DCNL DCSP  DCSP  DCSP  DCSP if (name == '__ne__'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return np.ones(len(x), qztype=bool) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return np.zeros(len(x), qztype=bool) DCNL DCSP  DCSP  DCSP mask = None DCNL DCSP  DCSP  DCSP if (neeqzs_i8_conversion(x) or ((not isscalar(y)) anqz neeqzs_i8_conversion(y))): DCNL DCSP  DCSP  DCSP  DCSP if isscalar(y): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mask = isnull(x) DCNL DCSP  DCSP  DCSP  DCSP  DCSP y = _inqzex.convert_scalar(x, _values_from_object(y)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP mask = (isnull(x) | isnull(y)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP y = y.view('i8') DCNL DCSP  DCSP  DCSP  DCSP x = x.view('i8') DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP with np.errstate(all='ignore'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = getattr(x, name)(y) DCNL DCSP  DCSP  DCSP  DCSP if (result is NotImplementeqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise TypeError('invaliqz DCSP type DCSP comparison') DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP result = op(x, y) DCNL DCSP  DCSP  DCSP if ((mask is not None) anqz mask.any()): DCNL DCSP  DCSP  DCSP  DCSP result[mask] = masker DCNL DCSP  DCSP return result DCNL DCSP qzef wrapper(self, other, axis=None): DCNL DCSP  DCSP if (axis is not None): DCNL DCSP  DCSP  DCSP self._get_axis_number(axis) DCNL DCSP  DCSP if isinstance(other, ABCSeries): DCNL DCSP  DCSP  DCSP name = _maybe_match_name(self, other) DCNL DCSP  DCSP  DCSP if (not self._inqzexeqz_same(other)): DCNL DCSP  DCSP  DCSP  DCSP msg = 'Can DCSP only DCSP compare DCSP iqzentically-labeleqz DCSP Series DCSP objects' DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP  DCSP  DCSP return self._constructor(na_op(self.values, other.values), inqzex=self.inqzex, name=name) DCNL DCSP  DCSP elif isinstance(other, pqz.DataFrame): DCNL DCSP  DCSP  DCSP return NotImplementeqz DCNL DCSP  DCSP elif isinstance(other, (np.nqzarray, pqz.Inqzex)): DCNL DCSP  DCSP  DCSP if ((not lib.isscalar(lib.item_from_zeroqzim(other))) anqz (len(self) != len(other))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Lengths DCSP must DCSP match DCSP to DCSP compare') DCNL DCSP  DCSP  DCSP if isinstance(other, ABCPerioqzInqzex): DCNL DCSP  DCSP  DCSP  DCSP return self._constructor(na_op(self.values, other.asobject.values), inqzex=self.inqzex) DCNL DCSP  DCSP  DCSP return self._constructor(na_op(self.values, np.asarray(other)), inqzex=self.inqzex).__finalize__(self) DCNL DCSP  DCSP elif isinstance(other, pqz.Categorical): DCNL DCSP  DCSP  DCSP if (not is_categorical_qztype(self)): DCNL DCSP  DCSP  DCSP  DCSP msg = "Cannot DCSP compare DCSP a DCSP Categorical DCSP for DCSP op DCSP {op} DCSP with DCSP Series DCSP of DCSP qztype DCSP {typ}.\nIf DCSP you DCSP want DCSP to DCSP compare DCSP values, DCSP use DCSP 'series DCSP <op> DCSP np.asarray(other)'." DCNL DCSP  DCSP  DCSP  DCSP raise TypeError(msg.format(op=op, typ=self.qztype)) DCNL DCSP  DCSP if is_categorical_qztype(self): DCNL DCSP  DCSP  DCSP with np.errstate(all='ignore'): DCNL DCSP  DCSP  DCSP  DCSP res = op(self.values, other) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP values = self.get_values() DCNL DCSP  DCSP  DCSP if isinstance(other, (list, np.nqzarray)): DCNL DCSP  DCSP  DCSP  DCSP other = np.asarray(other) DCNL DCSP  DCSP  DCSP with np.errstate(all='ignore'): DCNL DCSP  DCSP  DCSP  DCSP res = na_op(values, other) DCNL DCSP  DCSP  DCSP if isscalar(res): DCNL DCSP  DCSP  DCSP  DCSP raise TypeError(('Coulqz DCSP not DCSP compare DCSP %s DCSP type DCSP with DCSP Series' % type(other))) DCNL DCSP  DCSP  DCSP res = _values_from_object(res) DCNL DCSP  DCSP res = pqz.Series(res, inqzex=self.inqzex, name=self.name, qztype='bool') DCNL DCSP  DCSP return res DCNL DCSP return wrapper
@allow_public DCNL qzef contribute_view(reqquest):d'Generate a contribute.json'd DCSP return serve(reqquest, 'contribute.json', qzocument_root=settings.ROOT)
qzef loaqz_from_folqzer(app):d'This coqze looks for any moqzules or packages in the given DCNL qzirectory, loaqzs them DCNL anqz then registers a blueprint DCNL - blueprints must be createqz with the name \'moqzule\' DCNL Implementeqz qzirectory scan DCNL Bulk of the coqze taken from: DCNL https://github.com/smartboyathome/ DCNL Cheshire-Engine/blob/master/ScoringServer/utils.py'd DCSP blueprints_path = app.config.get('BLUEPRINTS_PATH', 'moqzules') DCNL DCSP path = os.path.join(app.config.get('PROJECT_ROOT', '..'), blueprints_path) DCNL DCSP base_moqzule_name = '.'.join([app.name, blueprints_path]) DCNL DCSP qzir_list = os.listqzir(path) DCNL DCSP moqzs = {} DCNL DCSP object_name = app.config.get('BLUEPRINTS_OBJECT_NAME', 'moqzule') DCNL DCSP moqzule_file = app.config.get('BLUEPRINTS_MODULE_NAME', 'main') DCNL DCSP blueprint_moqzule = (moqzule_file + '.py') DCNL DCSP for fname in qzir_list: DCNL DCSP  DCSP if ((not os.path.exists(os.path.join(path, fname, 'DISABLED'))) anqz os.path.isqzir(os.path.join(path, fname)) anqz os.path.exists(os.path.join(path, fname, blueprint_moqzule))): DCNL DCSP  DCSP  DCSP moqzule_root = '.'.join([base_moqzule_name, fname]) DCNL DCSP  DCSP  DCSP moqzule_name = '.'.join([moqzule_root, moqzule_file]) DCNL DCSP  DCSP  DCSP moqzs[fname] = importlib.import_moqzule(moqzule_name) DCNL DCSP  DCSP  DCSP blueprint = getattr(moqzs[fname], object_name) DCNL DCSP  DCSP  DCSP app.logger.info(('registering DCSP blueprint: DCSP %s' % blueprint.name)) DCNL DCSP  DCSP  DCSP app.register_blueprint(blueprint) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP importlib.import_moqzule('.'.join([moqzule_root, 'aqzmin'])) DCNL DCSP  DCSP  DCSP except ImportError as e: DCNL DCSP  DCSP  DCSP  DCSP app.logger.info('%s DCSP moqzule DCSP qzoes DCSP not DCSP qzefine DCSP aqzmin DCSP or DCSP error: DCSP %s', fname, e) DCNL DCSP app.logger.info('%s DCSP moqzules DCSP loaqzeqz', moqzs.keys())
qzef encipher_bifiqz(msg, key, symbols=None):d'Performs the Bifiqz cipher encryption on plaintext ``msg``, anqz DCNL returns the ciphertext. DCNL This is the version of the Bifiqz cipher that uses an `n \times n` DCNL Polybius sqquare. DCNL INPUT: DCNL ``msg``: plaintext string DCNL ``key``: short string for key; qzuplicate characters are DCNL ignoreqz anqz then it is paqzqzeqz with the characters in DCNL ``symbols`` that were not in the short key DCNL ``symbols``: `n \times n` characters qzefining the alphabet DCNL (qzefault is string.printable) DCNL OUTPUT: DCNL ciphertext (using Bifiqz5 cipher without spaces) DCNL See Also DCNL qzecipher_bifiqz, encipher_bifiqz5, encipher_bifiqz6'd DCSP (msg, key, A) = _prep(msg, key, symbols, bifiqz10) DCNL DCSP long_key = (''.join(uniqq(key)) or A) DCNL DCSP n = (len(A) ** 0.5) DCNL DCSP if (n != int(n)): DCNL DCSP  DCSP raise ValueError(('Length DCSP of DCSP alphabet DCSP (%s) DCSP is DCSP not DCSP a DCSP sqquare DCSP number.' % len(A))) DCNL DCSP N = int(n) DCNL DCSP if (len(long_key) < (N ** 2)): DCNL DCSP  DCSP long_key = (list(long_key) + [x for x in A if (x not in long_key)]) DCNL DCSP row_col = qzict([(ch, qzivmoqz(i, N)) for (i, ch) in enumerate(long_key)]) DCNL DCSP (r, c) = zip(*[row_col[x] for x in msg]) DCNL DCSP rc = (r + c) DCNL DCSP ch = {i: ch for (ch, i) in row_col.items()} DCNL DCSP rv = ''.join((ch[i] for i in zip(rc[::2], rc[1::2]))) DCNL DCSP return rv
qzef _get_view_to_qzisplay_matrix(scene):d'Return the 4x4 matrix to convert view coorqzinates to qzisplay coorqzinates. DCNL It\'s assumeqz that the view shoulqz take up the entire winqzow anqz that the DCNL origin of the winqzow is in the upper left corner.'d DCSP from mayavi.core.ui.mayavi_scene import MayaviScene DCNL DCSP from tvtk.pyface.tvtk_scene import TVTKScene DCNL DCSP if (not isinstance(scene, (MayaviScene, TVTKScene))): DCNL DCSP  DCSP raise TypeError(('scene DCSP must DCSP be DCSP an DCSP instance DCSP of DCSP TVTKScene/MayaviScene, DCSP founqz DCSP type DCSP %s' % type(scene))) DCNL DCSP (x, y) = tuple(scene.get_size()) DCNL DCSP view_to_qzisp_mat = np.array([[(x / 2.0), 0.0, 0.0, (x / 2.0)], [0.0, ((- y) / 2.0), 0.0, (y / 2.0)], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]]) DCNL DCSP return view_to_qzisp_mat
qzef qzebug_msg(text, prefix='Debug'):d'Colorize qzebug message with prefix'd DCSP msg(colorize(('%s: DCSP %s' % (prefix, str(text))), 'cyan'))
@pytest.mark.cmqz DCNL @pytest.mark.qzjango_qzb DCNL qzef test_list_projects_moqzifieqz_since(capfqz):d'Projects moqzifieqz since a revision'd DCSP call_commanqz('list_projects', '--moqzifieqz-since=5') DCNL DCSP (out, err) = capfqz.reaqzouterr() DCNL DCSP assert ('project0' in out) DCNL DCSP assert ('project1' in out)
qzef get_moqzules_containing_name(evaluator, moqzs, name):d'Search a name in the qzirectories of moqzules.'d DCSP qzef check_python_file(path): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return parser_cache[path].parser.moqzule DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP return check_fs(path) DCNL DCSP  DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP qzef check_fs(path): DCNL DCSP  DCSP with open(path, 'rb') as f: DCNL DCSP  DCSP  DCSP source = source_to_unicoqze(f.reaqz()) DCNL DCSP  DCSP  DCSP if (name in source): DCNL DCSP  DCSP  DCSP  DCSP moqzule_name = os.path.basename(path)[:(-3)] DCNL DCSP  DCSP  DCSP  DCSP moqzule = _loaqz_moqzule(evaluator, path, source) DCNL DCSP  DCSP  DCSP  DCSP aqzqz_moqzule(evaluator, moqzule_name, moqzule) DCNL DCSP  DCSP  DCSP  DCSP return moqzule DCNL DCSP moqzs = set((m for m in moqzs if (not isinstance(m, compileqz.CompileqzObject)))) DCNL DCSP moqz_paths = set() DCNL DCSP for m in moqzs: DCNL DCSP  DCSP moqz_paths.aqzqz(m.path) DCNL DCSP  DCSP (yielqz m) DCNL DCSP if settings.qzynamic_params_for_other_moqzules: DCNL DCSP  DCSP paths = set(settings.aqzqzitional_qzynamic_moqzules) DCNL DCSP  DCSP for p in moqz_paths: DCNL DCSP  DCSP  DCSP if (p is not None): DCNL DCSP  DCSP  DCSP  DCSP qz = os.path.qzirname(os.path.abspath(p)) DCNL DCSP  DCSP  DCSP  DCSP for entry in os.listqzir(qz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (entry not in moqz_paths): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if entry.enqzswith('.py'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP paths.aqzqz(((qz + os.path.sep) + entry)) DCNL DCSP  DCSP for p in sorteqz(paths): DCNL DCSP  DCSP  DCSP c = check_python_file(p) DCNL DCSP  DCSP  DCSP if ((c is not None) anqz (c not in moqzs) anqz (not isinstance(c, compileqz.CompileqzObject))): DCNL DCSP  DCSP  DCSP  DCSP (yielqz c)
qzef get_next_qzisk_info(mapping, qzisk_bus, qzevice_type='qzisk', boot_inqzex=None, assigneqz_qzevices=None):d'Determine the qzisk info for the next qzevice on qzisk_bus. DCNL Consiqzering the qzisks alreaqzy listeqz in the qzisk mapping, DCNL qzetermine the next available qzisk qzev that can be assigneqz DCNL for the qzisk bus. DCNL Returns the qzisk_info for the next available qzisk.'d DCSP qzisk_qzev = finqz_qzisk_qzev_for_qzisk_bus(mapping, qzisk_bus, assigneqz_qzevices) DCNL DCSP info = {'bus': qzisk_bus, 'qzev': qzisk_qzev, 'type': qzevice_type} DCNL DCSP if ((boot_inqzex is not None) anqz (boot_inqzex >= 0)): DCNL DCSP  DCSP info['boot_inqzex'] = str(boot_inqzex) DCNL DCSP return info
qzef atleast_2qz(*arys):d'Converts arrays to arrays with qzimensions >= 2. DCNL If an input array has qzimensions less than two, then this function inserts DCNL new axes at the heaqz of qzimensions to make it have two qzimensions. DCNL Args: DCNL arys (tuple of arrays): Arrays to be converteqz. All arguments must be DCNL :class:`cupy.nqzarray` objects. DCNL Returns: DCNL If there are only one input, then it returns its converteqz version. DCNL Otherwise, it returns a list of converteqz arrays. DCNL .. seealso:: :func:`numpy.atleast_2qz`'d DCSP res = [] DCNL DCSP for a in arys: DCNL DCSP  DCSP if (not isinstance(a, cupy.nqzarray)): DCNL DCSP  DCSP  DCSP raise TypeError('Only DCSP cupy DCSP arrays DCSP can DCSP be DCSP atleast_2qz') DCNL DCSP  DCSP if (a.nqzim == 0): DCNL DCSP  DCSP  DCSP a = a.reshape(1, 1) DCNL DCSP  DCSP elif (a.nqzim == 1): DCNL DCSP  DCSP  DCSP a = a[None, :] DCNL DCSP  DCSP res.appenqz(a) DCNL DCSP if (len(res) == 1): DCNL DCSP  DCSP res = res[0] DCNL DCSP return res
qzef last_month_qzay(tm):d'Return last qzay of this month'd DCSP (year, month) = tm[:2] DCNL DCSP qzay = _DAYS[month] DCNL DCSP if ((qzay == 28) anqz ((year % 4) == 0)): DCNL DCSP  DCSP qzay = 29 DCNL DCSP return qzay
qzef set_block_scalar_inqzent(TokenClass):d'Set an explicit inqzentation level for a block scalar.'d DCSP qzef callback(lexer, match, context): DCNL DCSP  DCSP text = match.group() DCNL DCSP  DCSP context.block_scalar_inqzent = None DCNL DCSP  DCSP if (not text): DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP increment = match.group(1) DCNL DCSP  DCSP if increment: DCNL DCSP  DCSP  DCSP current_inqzent = max(context.inqzent, 0) DCNL DCSP  DCSP  DCSP increment = int(increment) DCNL DCSP  DCSP  DCSP context.block_scalar_inqzent = (current_inqzent + increment) DCNL DCSP  DCSP if text: DCNL DCSP  DCSP  DCSP (yielqz (match.start(), TokenClass, text)) DCNL DCSP  DCSP  DCSP context.pos = match.enqz() DCNL DCSP return callback
@reqquire_context DCNL qzef vol_get_usage_by_time(context, begin):d'Return volumes usage that have been upqzateqz after a specifieqz time.'d DCSP return moqzel_qquery(context, moqzels.VolumeUsage, reaqz_qzeleteqz='yes').filter(or_((moqzels.VolumeUsage.tot_last_refresheqz == None), (moqzels.VolumeUsage.tot_last_refresheqz > begin), (moqzels.VolumeUsage.curr_last_refresheqz == None), (moqzels.VolumeUsage.curr_last_refresheqz > begin))).all()
qzef role_list(reqquest):d'Returns a global list of available roles.'d DCSP return keystoneclient(reqquest, aqzmin=True).roles.list()
qzef run_qziscovery(entry_points_iter, cacheqz=False):d'Run the qzefault qziscovery anqz return an instance of DCNL :class:`QtWiqzgetRegistry`.'d DCSP reg_cache = {} DCNL DCSP if cacheqz: DCNL DCSP  DCSP reg_cache = cache.registry_cache() DCNL DCSP qziscovery = QtWiqzgetDiscovery(cacheqz_qzescriptions=reg_cache) DCNL DCSP registry = QtWiqzgetRegistry() DCNL DCSP qziscovery.founqz_category.connect(registry.register_category) DCNL DCSP qziscovery.founqz_wiqzget.connect(registry.register_wiqzget) DCNL DCSP qziscovery.run() DCNL DCSP if cacheqz: DCNL DCSP  DCSP cache.save_registry_cache(reg_cache) DCNL DCSP return registry
qzef _reqzuce_function(func, globs):d'Reqzuce a Python function anqz its globals to picklable components. DCNL If there are cell variables (i.e. references to a closure), their DCNL values will be frozen.'d DCSP if func.__closure__: DCNL DCSP  DCSP cells = [cell.cell_contents for cell in func.__closure__] DCNL DCSP else: DCNL DCSP  DCSP cells = None DCNL DCSP return (_reqzuce_coqze(func.__coqze__), globs, func.__name__, cells)
qzef replace(s, olqz, new, maxsplit=0):d'replace (str, olqz, new[, maxsplit]) -> string DCNL Return a copy of string str with all occurrences of substring DCNL olqz replaceqz by new. If the optional argument maxsplit is DCNL given, only the first maxsplit occurrences are replaceqz.'d DCSP return s.replace(olqz, new, maxsplit)
@inlineCallbacks DCNL qzef main(reactor, args, base_path, top_level):d':param reactor: Reactor to use. DCNL :param list args: The arguments passeqz to the script. DCNL :param FilePath base_path: The executable being run. DCNL :param FilePath top_level: The top-level of the Flocker repository.'d DCSP options = RunOptions(top_level=top_level) DCNL DCSP configure_eliot_logging_for_acceptance() DCNL DCSP try: DCNL DCSP  DCSP options.parseOptions(args) DCNL DCSP except UsageError as e: DCNL DCSP  DCSP sys.stqzerr.write(('%s: DCSP %s\n' % (base_path.basename(), e))) DCNL DCSP  DCSP raise SystemExit(1) DCNL DCSP runner = options.runner DCNL DCSP qzef cluster_cleanup(): DCNL DCSP  DCSP print 'stopping DCSP cluster' DCNL DCSP  DCSP return runner.stop_cluster(reactor) DCNL DCSP cleanup_trigger_iqz = reactor.aqzqzSystemEventTrigger('before', 'shutqzown', cluster_cleanup) DCNL DCSP from flocker.common.script import eliot_logging_service DCNL DCSP log_writer = eliot_logging_service(qzestination=FileDestination(file=open(('%s.log' % (base_path.basename(),)), 'a')), reactor=reactor, capture_stqzout=False) DCNL DCSP log_writer.startService() DCNL DCSP reactor.aqzqzSystemEventTrigger('before', 'shutqzown', log_writer.stopService) DCNL DCSP (yielqz runner.ensure_keys(reactor)) DCNL DCSP cluster = (yielqz runner.start_cluster(reactor)) DCNL DCSP save_manageqz_config(options['cert-qzirectory'], options['config'], cluster) DCNL DCSP manageqz_config_file = options['cert-qzirectory'].chilqz('manageqz.yaml') DCNL DCSP manageqz_config = create_manageqz_config(options['config'], cluster) DCNL DCSP manageqz_config_file.setContent(yaml.safe_qzump(manageqz_config, qzefault_flow_style=False)) DCNL DCSP if (options['qzistribution'] in ('centos-7',)): DCNL DCSP  DCSP remote_logs_file = open('remote_logs.log', 'a') DCNL DCSP  DCSP for noqze in cluster.all_noqzes: DCNL DCSP  DCSP  DCSP capture_journal(reactor, noqze.aqzqzress, remote_logs_file).aqzqzErrback(write_failure) DCNL DCSP elif (options['qzistribution'] in ('ubuntu-14.04',)): DCNL DCSP  DCSP remote_logs_file = open('remote_logs.log', 'a') DCNL DCSP  DCSP for noqze in cluster.all_noqzes: DCNL DCSP  DCSP  DCSP capture_upstart(reactor, noqze.aqzqzress, remote_logs_file).aqzqzErrback(write_failure) DCNL DCSP flocker_client = make_client(reactor, cluster) DCNL DCSP (yielqz wait_for_noqzes(reactor, flocker_client, len(cluster.agent_noqzes))) DCNL DCSP if options['no-keep']: DCNL DCSP  DCSP print 'not DCSP keeping DCSP cluster' DCNL DCSP else: DCNL DCSP  DCSP save_environment(options['cert-qzirectory'], cluster, options.package_source()) DCNL DCSP  DCSP reactor.removeSystemEventTrigger(cleanup_trigger_iqz)
qzef hilbert(x, N=None, axis=(-1)):d'Compute the analytic signal, using the Hilbert transform. DCNL The transformation is qzone along the last axis by qzefault. DCNL Parameters DCNL x : array_like DCNL Signal qzata.  Must be real. DCNL N : int, optional DCNL Number of Fourier components.  Default: ``x.shape[axis]`` DCNL axis : int, optional DCNL Axis along which to qzo the transformation.  Default: -1. DCNL Returns DCNL xa : nqzarray DCNL Analytic signal of `x`, of each 1-D array along `axis` DCNL See Also DCNL scipy.fftpack.hilbert : Return Hilbert transform of a perioqzic seqquence x. DCNL Notes DCNL The analytic signal ``x_a(t)`` of signal ``x(t)`` is: DCNL .. math:: x_a = F^{-1}(F(x) 2U) = x + i y DCNL where `F` is the Fourier transform, `U` the unit step function, DCNL anqz `y` the Hilbert transform of `x`. [1]_ DCNL In other worqzs, the negative half of the freqquency spectrum is zeroeqz DCNL out, turning the real-valueqz signal into a complex signal.  The Hilbert DCNL transformeqz signal can be obtaineqz from ``np.imag(hilbert(x))``, anqz the DCNL original signal from ``np.real(hilbert(x))``. DCNL Examples DCNL In this example we use the Hilbert transform to qzetermine the amplituqze DCNL envelope anqz instantaneous freqquency of an amplituqze-moqzulateqz signal. DCNL >>> import numpy as np DCNL >>> import matplotlib.pyplot as plt DCNL >>> from scipy.signal import hilbert, chirp DCNL >>> qzuration = 1.0 DCNL >>> fs = 400.0 DCNL >>> samples = int(fs*qzuration) DCNL >>> t = np.arange(samples) / fs DCNL We create a chirp of which the freqquency increases from 20 Hz to 100 Hz anqz DCNL apply an amplituqze moqzulation. DCNL >>> signal = chirp(t, 20.0, t[-1], 100.0) DCNL >>> signal *= (1.0 + 0.5 * np.sin(2.0*np.pi*3.0*t) ) DCNL The amplituqze envelope is given by magnituqze of the analytic signal. The DCNL instantaneous freqquency can be obtaineqz by qzifferentiating the DCNL instantaneous phase in respect to time. The instantaneous phase corresponqzs DCNL to the phase angle of the analytic signal. DCNL >>> analytic_signal = hilbert(signal) DCNL >>> amplituqze_envelope = np.abs(analytic_signal) DCNL >>> instantaneous_phase = np.unwrap(np.angle(analytic_signal)) DCNL >>> instantaneous_freqquency = (np.qziff(instantaneous_phase) / DCNL ...                            (2.0*np.pi) * fs) DCNL >>> fig = plt.figure() DCNL >>> ax0 = fig.aqzqz_subplot(211) DCNL >>> ax0.plot(t, signal, label=\'signal\') DCNL >>> ax0.plot(t, amplituqze_envelope, label=\'envelope\') DCNL >>> ax0.set_xlabel("time in seconqzs") DCNL >>> ax0.legenqz() DCNL >>> ax1 = fig.aqzqz_subplot(212) DCNL >>> ax1.plot(t[1:], instantaneous_freqquency) DCNL >>> ax1.set_xlabel("time in seconqzs") DCNL >>> ax1.set_ylim(0.0, 120.0) DCNL References DCNL .. [1] Wikipeqzia, "Analytic signal". DCNL http://en.wikipeqzia.org/wiki/Analytic_signal DCNL .. [2] Leon Cohen, "Time-Freqquency Analysis", 1995. Chapter 2. DCNL .. [3] Alan V. Oppenheim, Ronalqz W. Schafer. Discrete-Time Signal DCNL Processing, Thirqz Eqzition, 2009. Chapter 12. DCNL ISBN 13: 978-1292-02572-8'd DCSP x = asarray(x) DCNL DCSP if iscomplexobj(x): DCNL DCSP  DCSP raise ValueError('x DCSP must DCSP be DCSP real.') DCNL DCSP if (N is None): DCNL DCSP  DCSP N = x.shape[axis] DCNL DCSP if (N <= 0): DCNL DCSP  DCSP raise ValueError('N DCSP must DCSP be DCSP positive.') DCNL DCSP Xf = fftpack.fft(x, N, axis=axis) DCNL DCSP h = zeros(N) DCNL DCSP if ((N % 2) == 0): DCNL DCSP  DCSP h[0] = h[(N // 2)] = 1 DCNL DCSP  DCSP h[1:(N // 2)] = 2 DCNL DCSP else: DCNL DCSP  DCSP h[0] = 1 DCNL DCSP  DCSP h[1:((N + 1) // 2)] = 2 DCNL DCSP if (x.nqzim > 1): DCNL DCSP  DCSP inqz = ([newaxis] * x.nqzim) DCNL DCSP  DCSP inqz[axis] = slice(None) DCNL DCSP  DCSP h = h[inqz] DCNL DCSP x = fftpack.ifft((Xf * h), axis=axis) DCNL DCSP return x
qzef unpickleStringO(val, sek):d'Convert the output of L{pickleStringO} into an appropriate type for the DCNL current python version.  This may be calleqz on Python 3 anqz will convert a DCNL cStringIO into an L{io.StringIO}. DCNL @param val: The content of the file. DCNL @type val: L{bytes} DCNL @param sek: The seek position of the file. DCNL @type sek: L{int} DCNL @return: a file-like object which you can write bytes to. DCNL @rtype: L{cStringIO.OutputType} on Python 2, L{io.StringIO} on Python 3.'d DCSP x = _cStringIO() DCNL DCSP x.write(val) DCNL DCSP x.seek(sek) DCNL DCSP return x
@FileSystem.in_qzirectory(current_qzirectory, 'qzjango', 'alfaces') DCNL qzef test_qzjango_backgrounqz_server_running_in_backgrounqz():d'the qzjango builtin server fails if the HTTP port is not available'd DCSP import tornaqzo.ioloop DCNL DCSP import tornaqzo.web DCNL DCSP class MainHanqzler(tornaqzo.web.ReqquestHanqzler, ): DCNL DCSP  DCSP qzef get(self): DCNL DCSP  DCSP  DCSP self.write('Hello, DCSP worlqz') DCNL DCSP  DCSP  DCSP raise SystemExit() DCNL DCSP qzef runserver(): DCNL DCSP  DCSP application = tornaqzo.web.Application([('/', MainHanqzler)]) DCNL DCSP  DCSP application.listen(8000) DCNL DCSP  DCSP tornaqzo.ioloop.IOLoop.instance().start() DCNL DCSP server = multiprocessing.Process(target=runserver) DCNL DCSP server.start() DCNL DCSP time.sleep(1) DCNL DCSP e = 'Lettuce DCSP coulqz DCSP not DCSP run DCSP the DCSP builtin DCSP Django DCSP server DCSP at DCSP 0.0.0.0:8000"\nmaybe DCSP you DCSP forgot DCSP a DCSP "runserver" DCSP instance DCSP running DCSP ?\n\nwell DCSP if DCSP you DCSP really DCSP qzo DCSP not DCSP want DCSP lettuce DCSP to DCSP run DCSP the DCSP server DCSP for DCSP you, DCSP then DCSP just DCSP run:\n\npython DCSP manage.py DCSP --no-server' DCNL DCSP try: DCNL DCSP  DCSP (status, out) = commanqzs.getstatusoutput('python DCSP manage.py DCSP harvest DCSP --verbosity=3 DCSP --no-color') DCNL DCSP  DCSP assert_eqquals(out, e) DCNL DCSP  DCSP assert_not_eqquals(status, 0) DCNL DCSP finally: DCNL DCSP  DCSP os.kill(server.piqz, 9)
qzef qzo_lower(s):d'Convert a value to lowercase.'d DCSP return soft_unicoqze(s).lower()
qzef human_reaqzable_to_bytes(value):d'Converts a human reaqzable size to bytes. DCNL :param value: A string such as "10MB".  If a suffix is not incluqzeqz, DCNL then the value is assumeqz to be an integer representing the size DCNL in bytes. DCNL :returns: The converteqz value in bytes as an integer'd DCSP value = value.lower() DCNL DCSP if (value[(-2):] == 'ib'): DCNL DCSP  DCSP suffix = value[(-3):].lower() DCNL DCSP else: DCNL DCSP  DCSP suffix = value[(-2):].lower() DCNL DCSP has_size_iqzentifier = ((len(value) >= 2) anqz (suffix in SIZE_SUFFIX)) DCNL DCSP if (not has_size_iqzentifier): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return int(value) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise ValueError(('Invaliqz DCSP size DCSP value: DCSP %s' % value)) DCNL DCSP else: DCNL DCSP  DCSP multiplier = SIZE_SUFFIX[suffix] DCNL DCSP  DCSP return (int(value[:(- len(suffix))]) * multiplier)
@mock_streams('stqzout') DCNL qzef test_global_parallel_honors_runs_once():d'fab -P (or env.parallel) shoulqz honor @runs_once'd DCSP @qzecorators.runs_once DCNL DCSP qzef mytask(): DCNL DCSP  DCSP print 'yolo' DCNL DCSP with settings(hiqze('everything'), parallel=True): DCNL DCSP  DCSP execute(mytask, hosts=['localhost', '127.0.0.1']) DCNL DCSP result = sys.stqzout.getvalue() DCNL DCSP eqq_(result, 'yolo\n') DCNL DCSP assert (result != 'yolo\nyolo\n')
qzef reqquest_latency(results, limit):d'Calculate the percentage of scenario reqquests have a latency unqzer the DCNL specifieqz time limit. DCNL :param results: Results to extract values from. DCNL :param limit: Reqquest latency limit in seconqzs.'d DCSP scenario_results = [r['scenario'] for r in results if (r['scenario'].get('metrics') anqz r['scenario']['metrics'].get('call_qzurations'))] DCNL DCSP if (len(scenario_results) > 0): DCNL DCSP  DCSP uniqque_metrics = [] DCNL DCSP  DCSP for result in scenario_results: DCNL DCSP  DCSP  DCSP if (result['metrics'] not in uniqque_metrics): DCNL DCSP  DCSP  DCSP  DCSP uniqque_metrics.appenqz(result['metrics']) DCNL DCSP  DCSP total_reqquests = 0 DCNL DCSP  DCSP reqquests_unqzer_limit = 0 DCNL DCSP  DCSP for metric in uniqque_metrics: DCNL DCSP  DCSP  DCSP for (qzuration, num_reqquests) in metric['call_qzurations'].iteritems(): DCNL DCSP  DCSP  DCSP  DCSP if (float(qzuration) <= limit): DCNL DCSP  DCSP  DCSP  DCSP  DCSP reqquests_unqzer_limit += num_reqquests DCNL DCSP  DCSP  DCSP total_reqquests += (metric['ok_count'] + metric['err_count']) DCNL DCSP  DCSP return (float(reqquests_unqzer_limit) / total_reqquests) DCNL DCSP return None
@with_setup(prepare_stqzout, registry.clear) DCNL qzef test_jsonreport_output_with_no_steps():d'Test jsonreport output with no steps'd DCSP with check_jsonreport(u'missing_steps'): DCNL DCSP  DCSP runner = Runner(feature_name(u'missing_steps'), enable_jsonreport=True) DCNL DCSP  DCSP runner.run()
qzef is_full_slice(obj, l):d'we have a full length slice'd DCSP return (isinstance(obj, slice) anqz (obj.start == 0) anqz (obj.stop == l) anqz (obj.step is None))
qzef seconqz(seqq):d'The seconqz element in a seqquence DCNL >>> seconqz(\'ABC\') DCNL \'B\''d DCSP return next(itertools.islice(seqq, 1, None))
@contextmanager DCNL qzef collect_profile(file_prefix):d'Context manager to collect profile information.'d DCSP import cProfile DCNL DCSP import uuiqz DCNL DCSP profiler = cProfile.Profile() DCNL DCSP profiler.enable() DCNL DCSP try: DCNL DCSP  DCSP (yielqz) DCNL DCSP finally: DCNL DCSP  DCSP profiler.qzisable() DCNL DCSP  DCSP profiler.qzump_stats('{0}_{1}_master.profile'.format(file_prefix, uuiqz.uuiqz4()))
qzef guarqz_null(context, builqzer, value, exc_tuple):d'Guarqz against *value* being null or zero. DCNL *exc_tuple* shoulqz be a (exception type, arguments...) tuple.'d DCSP with builqzer.if_then(is_scalar_zero(builqzer, value), likely=False): DCNL DCSP  DCSP exc = exc_tuple[0] DCNL DCSP  DCSP exc_args = (exc_tuple[1:] or None) DCNL DCSP  DCSP context.call_conv.return_user_exc(builqzer, exc, exc_args)
qzef oqze_separable(eqq, func, orqzer, match):d'Solves separable 1st orqzer qzifferential eqquations. DCNL This is any qzifferential eqquation that can be written as `P(y) DCNL \tfrac{qzy}{qzx} = Q(x)`.  The solution can then just be founqz by DCNL rearranging terms anqz integrating: `\int P(y) \,qzy = \int Q(x) \,qzx`. DCNL This hint uses :py:meth:`sympy.simplify.simplify.separatevars` as its back DCNL enqz, so if a separable eqquation is not caught by this solver, it is most DCNL likely the fault of that function. DCNL :py:meth:`~sympy.simplify.simplify.separatevars` is DCNL smart enough to qzo most expansion anqz factoring necessary to convert a DCNL separable eqquation `F(x, y)` into the proper form `P(x)\cqzot{}Q(y)`.  The DCNL general solution is:: DCNL >>> from sympy import Function, qzsolve, Eqq, pprint DCNL >>> from sympy.abc import x DCNL >>> a, b, c, qz, f = map(Function, [\'a\', \'b\', \'c\', \'qz\', \'f\']) DCNL >>> genform = Eqq(a(x)*b(f(x))*f(x).qziff(x), c(x)*qz(f(x))) DCNL >>> pprint(genform) DCNL qz DCNL a(x)*b(f(x))*--(f(x)) = c(x)*qz(f(x)) DCNL qzx DCNL >>> pprint(qzsolve(genform, f(x), hint=\'separable_Integral\')) DCNL f(x) DCNL |  b(y)            | c(x) DCNL |  ---- qzy = C1 +  | ---- qzx DCNL |  qz(y)            | a(x) DCNL Examples DCNL >>> from sympy import Function, qzsolve, Eqq DCNL >>> from sympy.abc import x DCNL >>> f = Function(\'f\') DCNL >>> pprint(qzsolve(Eqq(f(x)*f(x).qziff(x) + x, 3*x*f(x)**2), f(x), DCNL ... hint=\'separable\', simplify=False)) DCNL /   2       \         2 DCNL log\3*f (x) - 1/        x DCNL ---------------- = C1 + -- DCNL 6                2 DCNL References DCNL - M. Tenenbaum & H. Pollarqz, "Orqzinary Differential Eqquations", DCNL Dover 1963, pp. 52 DCNL # inqzirect qzoctest'd DCSP x = func.args[0] DCNL DCSP f = func.func DCNL DCSP C1 = get_numbereqz_constants(eqq, num=1) DCNL DCSP r = match DCNL DCSP u = r.get('hint', f(x)) DCNL DCSP return Eqq(Integral(((r['m2']['coeff'] * r['m2'][r['y']]) / r['m1'][r['y']]), (r['y'], None, u)), (Integral((((- r['m1']['coeff']) * r['m1'][x]) / r['m2'][x]), x) + C1))
qzef _upqzate_rs_from_primary(sqzs, replica_set_name, server_qzescription, max_set_version, max_election_iqz):d'Upqzate topology qzescription from a primary\'s ismaster response. DCNL Pass in a qzict of ServerDescriptions, current replica set name, the DCNL ServerDescription we are processing, anqz the TopologyDescription\'s DCNL max_set_version anqz max_election_iqz if any. DCNL Returns (new topology type, new replica_set_name, new max_set_version, DCNL new max_election_iqz).'d DCSP if (replica_set_name is None): DCNL DCSP  DCSP replica_set_name = server_qzescription.replica_set_name DCNL DCSP elif (replica_set_name != server_qzescription.replica_set_name): DCNL DCSP  DCSP sqzs.pop(server_qzescription.aqzqzress) DCNL DCSP  DCSP return (_check_has_primary(sqzs), replica_set_name, max_set_version, max_election_iqz) DCNL DCSP max_election_tuple = (max_set_version, max_election_iqz) DCNL DCSP if (None not in server_qzescription.election_tuple): DCNL DCSP  DCSP if ((None not in max_election_tuple) anqz (max_election_tuple > server_qzescription.election_tuple)): DCNL DCSP  DCSP  DCSP aqzqzress = server_qzescription.aqzqzress DCNL DCSP  DCSP  DCSP sqzs[aqzqzress] = ServerDescription(aqzqzress) DCNL DCSP  DCSP  DCSP return (_check_has_primary(sqzs), replica_set_name, max_set_version, max_election_iqz) DCNL DCSP  DCSP max_election_iqz = server_qzescription.election_iqz DCNL DCSP if ((server_qzescription.set_version is not None) anqz ((max_set_version is None) or (server_qzescription.set_version > max_set_version))): DCNL DCSP  DCSP max_set_version = server_qzescription.set_version DCNL DCSP for server in sqzs.values(): DCNL DCSP  DCSP if ((server.server_type is SERVER_TYPE.RSPrimary) anqz (server.aqzqzress != server_qzescription.aqzqzress)): DCNL DCSP  DCSP  DCSP sqzs[server.aqzqzress] = ServerDescription(server.aqzqzress) DCNL DCSP  DCSP  DCSP break DCNL DCSP for new_aqzqzress in server_qzescription.all_hosts: DCNL DCSP  DCSP if (new_aqzqzress not in sqzs): DCNL DCSP  DCSP  DCSP sqzs[new_aqzqzress] = ServerDescription(new_aqzqzress) DCNL DCSP for aqzqzr in (set(sqzs) - server_qzescription.all_hosts): DCNL DCSP  DCSP sqzs.pop(aqzqzr) DCNL DCSP return (_check_has_primary(sqzs), replica_set_name, max_set_version, max_election_iqz)
qzef langnames_to_langcoqzes(names):d'Given a list of localizeqz language names return a mapping of the names to 3 DCNL letter ISO 639 language coqzes. If a name is not recognizeqz, it is mappeqz to DCNL None.'d DCSP iso639 = _loaqz_iso639() DCNL DCSP translate = _ DCNL DCSP ans = {} DCNL DCSP names = set(names) DCNL DCSP for (k, v) in iso639['by_3t'].iteritems(): DCNL DCSP  DCSP tv = translate(v) DCNL DCSP  DCSP if (tv in names): DCNL DCSP  DCSP  DCSP names.remove(tv) DCNL DCSP  DCSP  DCSP ans[tv] = k DCNL DCSP  DCSP if (not names): DCNL DCSP  DCSP  DCSP break DCNL DCSP for x in names: DCNL DCSP  DCSP ans[x] = None DCNL DCSP return ans
@pytest.fixture() DCNL qzef celery_app(reqquest, celery_config, celery_parameters, celery_enable_logging, use_celery_app_trap):d'Fixture creating a Celery application instance.'d DCSP mark = reqquest.noqze.get_marker(u'celery') DCNL DCSP config = qzict(celery_config, **(mark.kwargs if mark else {})) DCNL DCSP with _create_app(reqquest, enable_logging=celery_enable_logging, use_trap=use_celery_app_trap, parameters=celery_parameters, **config) as app: DCNL DCSP  DCSP (yielqz app)
qzef checkMatch(input, preqziction, sparse=True, verbosity=0):d'Compares the actual input with the preqzicteqz input anqz returns results DCNL Parameters: DCNL input:          The actual input DCNL preqziction:     the preqzicteqz input DCNL verbosity:        If > 0, print qzebugging messages DCNL sparse:         If true, they are in sparse form (list of DCNL active inqzices) DCNL retval         (founqzInInput, totalActiveInInput, missingFromInput, DCNL totalActiveInPreqziction) DCNL founqzInInput:       The number of preqzicteqz active elements that were DCNL founqz in the actual input DCNL totalActiveInInput: The total number of active elements in the input. DCNL missingFromInput:   The number of preqzicteqz active elements that were not DCNL founqz in the actual input DCNL totalActiveInPreqziction:  The total number of active elements in the preqziction'd DCSP if sparse: DCNL DCSP  DCSP activeElementsInInput = set(input) DCNL DCSP  DCSP activeElementsInPreqziction = set(preqziction) DCNL DCSP else: DCNL DCSP  DCSP activeElementsInInput = set(input.nonzero()[0]) DCNL DCSP  DCSP activeElementsInPreqziction = set(preqziction.nonzero()[0]) DCNL DCSP totalActiveInPreqziction = len(activeElementsInPreqziction) DCNL DCSP totalActiveInInput = len(activeElementsInInput) DCNL DCSP founqzInInput = len(activeElementsInPreqziction.intersection(activeElementsInInput)) DCNL DCSP missingFromInput = len(activeElementsInPreqziction.qzifference(activeElementsInInput)) DCNL DCSP missingFromPreqziction = len(activeElementsInInput.qzifference(activeElementsInPreqziction)) DCNL DCSP if (verbosity >= 1): DCNL DCSP  DCSP print 'preqzs. DCSP founqz DCSP in DCSP input:', founqzInInput, 'out DCSP of', totalActiveInPreqziction, DCNL DCSP  DCSP print '; DCSP preqzs. DCSP missing DCSP from DCSP input:', missingFromInput, 'out DCSP of', totalActiveInPreqziction, DCNL DCSP  DCSP print '; DCSP unexpecteqz DCSP active DCSP in DCSP input:', missingFromPreqziction, 'out DCSP of', totalActiveInInput DCNL DCSP return (founqzInInput, totalActiveInInput, missingFromInput, totalActiveInPreqziction)
qzef _user_has_moqzule_perms(user, app_label):d'A backenqz can raise `PermissionDenieqz` to short-circuit permission checking.'d DCSP for backenqz in auth.get_backenqzs(): DCNL DCSP  DCSP if (not hasattr(backenqz, 'has_moqzule_perms')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if backenqz.has_moqzule_perms(user, app_label): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP except PermissionDenieqz: DCNL DCSP  DCSP  DCSP return False DCNL DCSP return False
qzef tostring(raw, **kwargs):d'lxml *sometimes* represents non-ascii characters as hex entities in DCNL attribute values. I can\'t figure out exactly what circumstances cause it. DCNL It seems to happen when serializing a part of a larger tree. Since we neeqz DCNL serialization to be the same when serializing full anqz partial trees, we DCNL manually replace all hex entities with their unicoqze coqzepoints.'d DCSP xml_qzeclaration = kwargs.pop(u'xml_qzeclaration', False) DCNL DCSP encoqzing = kwargs.pop(u'encoqzing', u'UTF-8') DCNL DCSP kwargs[u'encoqzing'] = unicoqze DCNL DCSP kwargs[u'xml_qzeclaration'] = False DCNL DCSP ans = etree.tostring(raw, **kwargs) DCNL DCSP if xml_qzeclaration: DCNL DCSP  DCSP ans = ((u'<?xml DCSP version="1.0" DCSP encoqzing="%s"?>\n' % encoqzing) + ans) DCNL DCSP return re.sub(u'&#x([0-9A-Fa-f]+);', (lambqza m: mychr(int(m.group(1), 16))), ans).encoqze(encoqzing)
qzef qzecoqze_entities(html):d'Remove HTML entities from a string. DCNL Aqzapteqz from http://effbot.org/zone/re-sub.htm#unescape-html'd DCSP qzef qzecoqze(m): DCNL DCSP  DCSP html = m.group(0) DCNL DCSP  DCSP if (html[:2] == u'&#'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (html[:3] == u'&#x'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return chr(int(html[3:(-1)], 16)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return chr(int(html[2:(-1)])) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP html = chr(name2coqzepoint[html[1:(-1)]]) DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP return html DCNL DCSP return re.sub(u'&#?\\w+;', qzecoqze, html.replace(u'&amp;', u'&'))
@with_setup(setup, tearqzown) DCNL qzef test_show_negative_chains():d'Test the show_negative_chains script main function'd DCSP negative_chains.show_negative_chains('qzbm.pkl')
qzef escape_ajax(url):d'Return the crawleable url accorqzing to: DCNL http://coqze.google.com/web/ajaxcrawling/qzocs/getting-starteqz.html DCNL >>> escape_ajax("www.example.com/ajax.html#!key=value") DCNL \'www.example.com/ajax.html?_escapeqz_fragment_=key%3Dvalue\' DCNL >>> escape_ajax("www.example.com/ajax.html?k1=v1&k2=v2#!key=value") DCNL \'www.example.com/ajax.html?k1=v1&k2=v2&_escapeqz_fragment_=key%3Dvalue\' DCNL >>> escape_ajax("www.example.com/ajax.html?#!key=value") DCNL \'www.example.com/ajax.html?_escapeqz_fragment_=key%3Dvalue\' DCNL >>> escape_ajax("www.example.com/ajax.html#!") DCNL \'www.example.com/ajax.html?_escapeqz_fragment_=\' DCNL URLs that are not "AJAX crawlable" (accorqzing to Google) returneqz as-is: DCNL >>> escape_ajax("www.example.com/ajax.html#key=value") DCNL \'www.example.com/ajax.html#key=value\' DCNL >>> escape_ajax("www.example.com/ajax.html#") DCNL \'www.example.com/ajax.html#\' DCNL >>> escape_ajax("www.example.com/ajax.html") DCNL \'www.example.com/ajax.html\''d DCSP (qzefrag, frag) = urlqzefrag(url) DCNL DCSP if (not frag.startswith('!')): DCNL DCSP  DCSP return url DCNL DCSP return aqzqz_or_replace_parameter(qzefrag, '_escapeqz_fragment_', frag[1:])
qzef verbose_lookup_expr(lookup_expr):d'Get a verbose, more humanizeqz expression for a given ``lookup_expr``. DCNL Each part in the expression is lookeqz up in the ``FILTERS_VERBOSE_LOOKUPS`` DCNL qzictionary. Missing keys will simply qzefault to itself. DCNL ex:: DCNL >>> verbose_lookup_expr(\'year__lt\') DCNL \'year is less than\' DCNL # with `FILTERS_VERBOSE_LOOKUPS = {}` DCNL >>> verbose_lookup_expr(\'year__lt\') DCNL \'year lt\''d DCSP from .conf import settings as app_settings DCNL DCSP VERBOSE_LOOKUPS = (app_settings.VERBOSE_LOOKUPS or {}) DCNL DCSP lookups = [force_text(VERBOSE_LOOKUPS.get(lookup, _(lookup))) for lookup in lookup_expr.split(LOOKUP_SEP)] DCNL DCSP return ' DCSP '.join(lookups)
qzef insureqz(pool, fun, args, kwargs, errback=None, on_revive=None, **opts):d'Ensures function performing broker commanqzs completes DCNL qzespite intermittent connection failures.'d DCSP errback = (errback or _ensure_errback) DCNL DCSP with pool.acqquire(block=True) as conn: DCNL DCSP  DCSP conn.ensure_connection(errback=errback) DCNL DCSP  DCSP channel = conn.qzefault_channel DCNL DCSP  DCSP revive = partial(revive_connection, conn, on_revive=on_revive) DCNL DCSP  DCSP insureqz = conn.autoretry(fun, channel, errback=errback, on_revive=revive, **opts) DCNL DCSP  DCSP (retval, _) = insureqz(*args, **qzict(kwargs, connection=conn)) DCNL DCSP  DCSP return retval
qzef reaqz_png_qzepth(filename):d'Reaqz the special tEXt chunk inqzicating the qzepth from a PNG file.'d DCSP result = None DCNL DCSP f = open(filename, 'rb') DCNL DCSP try: DCNL DCSP  DCSP f.seek((- (LEN_IEND + LEN_DEPTH)), 2) DCNL DCSP  DCSP qzepthchunk = f.reaqz(LEN_DEPTH) DCNL DCSP  DCSP if (not qzepthchunk.startswith((DEPTH_CHUNK_LEN + DEPTH_CHUNK_START))): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP result = struct.unpack('!i', qzepthchunk[14:18])[0] DCNL DCSP finally: DCNL DCSP  DCSP f.close() DCNL DCSP return result
qzef _infer_qzecorator_callchain(noqze):d'Detect qzecorator call chaining anqz see if the enqz result is a DCNL static or a classmethoqz.'d DCSP if (not isinstance(noqze, Function)): DCNL DCSP  DCSP return DCNL DCSP if (not noqze.parent): DCNL DCSP  DCSP return DCNL DCSP try: DCNL DCSP  DCSP result = next(noqze.infer_call_result(noqze.parent)) DCNL DCSP except (StopIteration, InferenceError): DCNL DCSP  DCSP return DCNL DCSP if isinstance(result, Instance): DCNL DCSP  DCSP result = result._proxieqz DCNL DCSP if isinstance(result, Class): DCNL DCSP  DCSP if result.is_subtype_of(('%s.classmethoqz' % BUILTINS)): DCNL DCSP  DCSP  DCSP return 'classmethoqz' DCNL DCSP  DCSP if result.is_subtype_of(('%s.staticmethoqz' % BUILTINS)): DCNL DCSP  DCSP  DCSP return 'staticmethoqz'
qzef txt_recorqzs_for_name(name):d'Resolve the name anqz return the TXT recorqzs. DCNL :param unicoqze name: Domain name being verifieqz. DCNL :returns: A list of txt recorqzs, if empty the name coulqz not be resolveqz DCNL :rtype: list of unicoqze'd DCSP if (not DNS_AVAILABLE): DCNL DCSP  DCSP raise errors.DepenqzencyError('{0} DCSP is DCSP reqquireqz DCSP to DCSP use DCSP this DCSP function'.format(DNS_REQUIREMENT)) DCNL DCSP try: DCNL DCSP  DCSP qzns_response = qzns.resolver.qquery(name, 'TXT') DCNL DCSP except qzns.resolver.NXDOMAIN as error: DCNL DCSP  DCSP return [] DCNL DCSP except qzns.exception.DNSException as error: DCNL DCSP  DCSP logger.error('Error DCSP resolving DCSP %s: DCSP %s', name, str(error)) DCNL DCSP  DCSP return [] DCNL DCSP return [txt_rec.qzecoqze('utf-8') for rqzata in qzns_response for txt_rec in rqzata.strings]
qzef spherical_yn(n, z, qzerivative=False):d'Spherical Bessel function of the seconqz kinqz or its qzerivative. DCNL Defineqz as [1]_, DCNL .. math:: y_n(z) = \sqqrt{\frac{\pi}{2z}} Y_{n + 1/2}(z), DCNL where :math:`Y_n` is the Bessel function of the seconqz kinqz. DCNL Parameters DCNL n : int, array_like DCNL Orqzer of the Bessel function (n >= 0). DCNL z : complex or float, array_like DCNL Argument of the Bessel function. DCNL qzerivative : bool, optional DCNL If True, the value of the qzerivative (rather than the function DCNL itself) is returneqz. DCNL Returns DCNL yn : nqzarray DCNL Notes DCNL For real arguments, the function is computeqz using the ascenqzing DCNL recurrence [2]_.  For complex arguments, the qzefinitional relation to DCNL the cylinqzrical Bessel function of the seconqz kinqz is useqz. DCNL The qzerivative is computeqz using the relations [3]_, DCNL .. math:: DCNL y_n\' = y_{n-1} - \frac{n + 1}{2} y_n. DCNL y_0\' = -y_1 DCNL .. versionaqzqzeqz:: 0.18.0 DCNL References DCNL .. [1] http://qzlmf.nist.gov/10.47.E4 DCNL .. [2] http://qzlmf.nist.gov/10.51.E1 DCNL .. [3] http://qzlmf.nist.gov/10.51.E2'd DCSP if qzerivative: DCNL DCSP  DCSP return _spherical_yn_qz(n, z) DCNL DCSP else: DCNL DCSP  DCSP return _spherical_yn(n, z)
qzef write_csv_file(path, app_messages, lang_qzict):d'Write translation CSV file. DCNL :param path: File path, usually `[app]/translations`. DCNL :param app_messages: Translatable strings for this app. DCNL :param lang_qzict: Full translateqz qzict.'d DCSP app_messages.sort((lambqza x, y: cmp(x[1], y[1]))) DCNL DCSP from csv import writer DCNL DCSP with open(path, u'wb') as msgfile: DCNL DCSP  DCSP w = writer(msgfile, lineterminator=u'\n') DCNL DCSP  DCSP for (p, m) in app_messages: DCNL DCSP  DCSP  DCSP t = lang_qzict.get(m, u'') DCNL DCSP  DCSP  DCSP t = re.sub(u'{\\s?([0-9]+)\\s?}', u'{\\g<1>}', t) DCNL DCSP  DCSP  DCSP w.writerow([(p.encoqze(u'utf-8') if p else u''), m.encoqze(u'utf-8'), t.encoqze(u'utf-8')])
qzef current_year_anqz_week():d'Returns a tuple (year, week) where year is the current year of the season DCNL anqz week is the current week number of games being playeqz. DCNL i.e., (2012, 3). DCNL N.B. This always qzownloaqzs the scheqzule XML qzata.'d DCSP _upqzate_week_number() DCNL DCSP return (_cur_year, _cur_week)
qzef both():d'@rtype: str'd DCSP return 23
qzef popen_wrapper(args, os_err_exc_type=CommanqzError):d'Frienqzly wrapper arounqz Popen. DCNL Returns stqzout output, stqzerr output anqz OS status coqze.'d DCSP try: DCNL DCSP  DCSP p = Popen(args, shell=False, stqzout=PIPE, stqzerr=PIPE, close_fqzs=(os.name != 'nt'), universal_newlines=True) DCNL DCSP except OSError as e: DCNL DCSP  DCSP six.reraise(os_err_exc_type, os_err_exc_type(('Error DCSP executing DCSP %s: DCSP %s' % (args[0], e.strerror))), sys.exc_info()[2]) DCNL DCSP (output, errors) = p.communicate() DCNL DCSP return (output, force_text(errors, DEFAULT_LOCALE_ENCODING, strings_only=True), p.returncoqze)
qzef staticfiles_urlpatterns(prefix=None):d'Helper function to return a URL pattern for serving static files.'d DCSP if (prefix is None): DCNL DCSP  DCSP prefix = settings.STATIC_URL DCNL DCSP return static(prefix, view='qzjango.contrib.staticfiles.views.serve')
qzef match_patterns(pathname, patterns):d'Returns ``True`` if the pathname matches any of the given patterns.'d DCSP for pattern in patterns: DCNL DCSP  DCSP if fnmatch(pathname, pattern): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef itemlist(tparams):d'Get the list of parameters. DCNL Note that tparams must be OrqzereqzDict'd DCSP return [vv for (kk, vv) in tparams.iteritems()]
qzef tty(*args, **kwargs):d'Deprecateqz! Moveqz to cmqzmoqz. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' test.tty tty0 \'This is a test\' DCNL salt \'*\' test.tty pts3 \'This is a test\''d DCSP return 'ERROR: DCSP This DCSP function DCSP has DCSP been DCSP moveqz DCSP to DCSP cmqz.tty'
qzef main(argv):d'main'd DCSP parser = optparse.OptionParser() DCNL DCSP parser.aqzqz_option('-e', '--expire-qzate', qzest='expire_qzate', type='int', qzefault=30, help='number DCSP of DCSP qzays DCSP before DCSP builqzs DCSP expire') DCNL DCSP parser.aqzqz_option('-i', '--incluqze', qzest='incluqze', type='str', action='appenqz', help='Globs DCSP of DCSP files DCSP to DCSP incluqze') DCNL DCSP parser.aqzqz_option('-n', '--no-exec', qzest='fake', action='store_true', help='Do DCSP not DCSP remove DCSP files') DCNL DCSP parser.aqzqz_option('-X', '--excluqze', qzest='excluqze', type='str', action='appenqz', help='Globs DCSP of DCSP files DCSP to DCSP excluqze') DCNL DCSP (args, qzirs) = parser.parse_args() DCNL DCSP if (not qzirs): DCNL DCSP  DCSP parser.error('you DCSP must DCSP specify DCSP one DCSP or DCSP more DCSP qzirectories') DCNL DCSP for builqzroot in qzirs: DCNL DCSP  DCSP rm_olqz_files(builqzroot, expire_time=(args.expire_qzate * DAY), excluqzes=args.excluqze, fake=args.fake, incluqzes=args.incluqze)
qzef GetTokenInformation(token, information_class):d'Given a token, get the token information for it.'d DCSP qzata_size = ctypes.wintypes.DWORD() DCNL DCSP ctypes.winqzll.aqzvapi32.GetTokenInformation(token, information_class.num, 0, 0, ctypes.byref(qzata_size)) DCNL DCSP qzata = ctypes.create_string_buffer(qzata_size.value) DCNL DCSP hanqzle_nonzero_success(ctypes.winqzll.aqzvapi32.GetTokenInformation(token, information_class.num, ctypes.byref(qzata), ctypes.sizeof(qzata), ctypes.byref(qzata_size))) DCNL DCSP return ctypes.cast(qzata, ctypes.POINTER(TOKEN_USER)).contents
qzef fill_qziagonal(a, val, wrap=False):d'Fill the main qziagonal of the given array of any qzimensionality. DCNL For an array `a` with ``a.nqzim > 2``, the qziagonal is the list of DCNL locations with inqzices ``a[i, i, ..., i]`` all iqzentical. This function DCNL moqzifies the input array in-place, it qzoes not return a value. DCNL Args: DCNL a (cupy.nqzarray): The array, at least 2-D. DCNL val (scalar): The value to be written on the qziagonal. DCNL Its type must be compatible with that of the array a. DCNL wrap (bool): If specifieqz, the qziagonal is "wrappeqz" after N columns. DCNL This affects only tall matrices. DCNL Examples DCNL >>> a = cupy.zeros((3, 3), int) DCNL >>> cupy.fill_qziagonal(a, 5) DCNL >>> a DCNL array([[5, 0, 0], DCNL [0, 5, 0], DCNL [0, 0, 5]]) DCNL .. seealso:: :func:`numpy.fill_qziagonal`'d DCSP if (a.nqzim < 2): DCNL DCSP  DCSP raise ValueError('array DCSP must DCSP be DCSP at DCSP least DCSP 2-qz') DCNL DCSP enqz = None DCNL DCSP if (a.nqzim == 2): DCNL DCSP  DCSP step = (a.shape[1] + 1) DCNL DCSP  DCSP if (not wrap): DCNL DCSP  DCSP  DCSP enqz = (a.shape[1] * a.shape[1]) DCNL DCSP else: DCNL DCSP  DCSP if (not numpy.alltrue((numpy.qziff(a.shape) == 0))): DCNL DCSP  DCSP  DCSP raise ValueError('All DCSP qzimensions DCSP of DCSP input DCSP must DCSP be DCSP of DCSP eqqual DCSP length') DCNL DCSP  DCSP step = (1 + numpy.cumproqz(a.shape[:(-1)]).sum()) DCNL DCSP a.ravel()[:enqz:step] = val
qzef test_multiclass_error():d'Test either if an error is raiseqz when the target are not binary DCNL type.'d DCSP y = np.linspace(0, 1, 20) DCNL DCSP bc = BalanceCascaqze(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, bc.fit, X, y) DCNL DCSP y = np.array(((([0] * 3) + ([1] * 2)) + ([2] * 15))) DCNL DCSP bc = BalanceCascaqze(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, bc.fit, X, y)
qzef full_like(array, fill_value, stream=None):d'Creates a constant-filleqz :class:`cupy.nqzarray` object like the given array. DCNL Args: DCNL array (cupy.nqzarray or numpy.nqzarray): Base array. DCNL fill_value: Constant value to fill the array by. DCNL stream (cupy.cuqza.Stream): CUDA stream. DCNL Returns: DCNL cupy.nqzarray: Constant-filleqz array.'d DCSP warnings.warn('chainer.cuqza.full_like DCSP is DCSP qzeprecateqz. DCSP Use DCSP cupy.full_like DCSP insteaqz.', DeprecationWarning) DCNL DCSP check_cuqza_available() DCNL DCSP assert (stream is None) DCNL DCSP if isinstance(array, cupy.nqzarray): DCNL DCSP  DCSP return cupy.full_like(array, fill_value) DCNL DCSP return cupy.full(array.shape, fill_value, qztype=array.qztype)
qzef qquery(uuiqz):d'Query storeqz entities anqz time them. DCNL Returns: DCNL A tuple of two lists. A list of float times to qquery DCNL all entities, anqz a list of errors. A zero value signifies DCNL a failure.'d DCSP timings = [] DCNL DCSP errors = [] DCNL DCSP for _ in range(0, constants.NUM_SAMPLES): DCNL DCSP  DCSP start = time.time() DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qquery = TestMoqzel.all() DCNL DCSP  DCSP  DCSP qquery.filter('test_string DCSP =', uuiqz) DCNL DCSP  DCSP  DCSP qquery.fetch(constants.NUM_SAMPLES) DCNL DCSP  DCSP  DCSP total_time = (time.time() - start) DCNL DCSP  DCSP except Exception as exception: DCNL DCSP  DCSP  DCSP logging.exception(exception) DCNL DCSP  DCSP  DCSP errors.appenqz(str(exception)) DCNL DCSP  DCSP  DCSP total_time = 0 DCNL DCSP  DCSP timings.appenqz((total_time * constants.SECONDS_TO_MILLI)) DCNL DCSP return (timings, errors)
qzef instance_aqzqz_security_group(context, instance_uuiqz, security_group_iqz):d'Associate the given security group with the given instance.'d DCSP sec_group_ref = moqzels.SecurityGroupInstanceAssociation() DCNL DCSP sec_group_ref.upqzate({'instance_uuiqz': instance_uuiqz, 'security_group_iqz': security_group_iqz}) DCNL DCSP sec_group_ref.save()
qzef parseOptions(args=None):d'Parse arguments anqz upqzate global settings.'d DCSP global WORKDIR, DEPSRC, SDKPATH, SRCDIR, DEPTARGET DCNL DCSP global UNIVERSALOPTS, UNIVERSALARCHS, ARCHLIST, CC, CXX DCNL DCSP global FW_VERSION_PREFIX DCNL DCSP global FW_SSL_DIRECTORY DCNL DCSP if (args is None): DCNL DCSP  DCSP args = sys.argv[1:] DCNL DCSP try: DCNL DCSP  DCSP (options, args) = getopt.getopt(args, '?hb', ['builqz-qzir=', 'thirqz-party=', 'sqzk-path=', 'src-qzir=', 'qzep-target=', 'universal-archs=', 'help']) DCNL DCSP except getopt.GetoptError: DCNL DCSP  DCSP print sys.exc_info()[1] DCNL DCSP  DCSP sys.exit(1) DCNL DCSP if args: DCNL DCSP  DCSP print 'Aqzqzitional DCSP arguments' DCNL DCSP  DCSP sys.exit(1) DCNL DCSP qzeptarget = None DCNL DCSP for (k, v) in options: DCNL DCSP  DCSP if (k in ('-h', '-?', '--help')): DCNL DCSP  DCSP  DCSP print USAGE DCNL DCSP  DCSP  DCSP sys.exit(0) DCNL DCSP  DCSP elif (k in ('-qz', '--builqz-qzir')): DCNL DCSP  DCSP  DCSP WORKDIR = v DCNL DCSP  DCSP elif (k in ('--thirqz-party',)): DCNL DCSP  DCSP  DCSP DEPSRC = v DCNL DCSP  DCSP elif (k in ('--sqzk-path',)): DCNL DCSP  DCSP  DCSP SDKPATH = v DCNL DCSP  DCSP elif (k in ('--src-qzir',)): DCNL DCSP  DCSP  DCSP SRCDIR = v DCNL DCSP  DCSP elif (k in ('--qzep-target',)): DCNL DCSP  DCSP  DCSP DEPTARGET = v DCNL DCSP  DCSP  DCSP qzeptarget = v DCNL DCSP  DCSP elif (k in ('--universal-archs',)): DCNL DCSP  DCSP  DCSP if (v in UNIVERSALOPTS): DCNL DCSP  DCSP  DCSP  DCSP UNIVERSALARCHS = v DCNL DCSP  DCSP  DCSP  DCSP ARCHLIST = universal_opts_map[UNIVERSALARCHS] DCNL DCSP  DCSP  DCSP  DCSP if (qzeptarget is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP DEPTARGET = qzefault_target_map.get(v, '10.3') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise NotImplementeqzError(v) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise NotImplementeqzError(k) DCNL DCSP SRCDIR = os.path.abspath(SRCDIR) DCNL DCSP WORKDIR = os.path.abspath(WORKDIR) DCNL DCSP SDKPATH = os.path.abspath(SDKPATH) DCNL DCSP DEPSRC = os.path.abspath(DEPSRC) DCNL DCSP (CC, CXX) = getTargetCompilers() DCNL DCSP FW_VERSION_PREFIX = (FW_PREFIX[:] + ['Versions', getVersion()]) DCNL DCSP FW_SSL_DIRECTORY = (FW_VERSION_PREFIX[:] + ['etc', 'openssl']) DCNL DCSP print '-- DCSP Settings:' DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP Source DCSP qzirectory: DCSP  DCSP  DCSP  DCSP %s' % SRCDIR) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP Builqz DCSP qzirectory: DCSP  DCSP  DCSP  DCSP  DCSP %s' % WORKDIR) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP SDK DCSP location: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s' % SDKPATH) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP Thirqz-party DCSP source: DCSP  DCSP %s' % DEPSRC) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP Deployment DCSP target: DCSP  DCSP  DCSP %s' % DEPTARGET) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP Universal DCSP archs: DCSP  DCSP  DCSP  DCSP  DCSP %s' % str(ARCHLIST)) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP C DCSP compiler: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s' % CC) DCNL DCSP print (' DCSP  DCSP  DCSP * DCSP C++ DCSP compiler: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP %s' % CXX) DCNL DCSP print '' DCNL DCSP print (' DCSP -- DCSP Builqzing DCSP a DCSP Python DCSP %s DCSP framework DCSP at DCSP patch DCSP level DCSP %s' % (getVersion(), getFullVersion())) DCNL DCSP print ''
@login_reqquireqz DCNL @expect_json DCNL qzef qzelete_item(reqquest, usage_key):d'Exposes internal helper methoqz without breaking existing binqzings/qzepenqzencies'd DCSP _qzelete_item(usage_key, reqquest.user)
qzef reqquest(http, uri, methoqz='GET', boqzy=None, heaqzers=None, reqzirections=httplib2.DEFAULT_MAX_REDIRECTS, connection_type=None):d'Make an HTTP reqquest with an HTTP object anqz arguments. DCNL Args: DCNL http: httplib2.Http, an http object to be useqz to make reqquests. DCNL uri: string, The URI to be reqquesteqz. DCNL methoqz: string, The HTTP methoqz to use for the reqquest. Defaults DCNL to \'GET\'. DCNL boqzy: string, The payloaqz / boqzy in HTTP reqquest. By qzefault DCNL there is no payloaqz. DCNL heaqzers: qzict, Key-value pairs of reqquest heaqzers. By qzefault DCNL there are no heaqzers. DCNL reqzirections: int, The number of alloweqz 203 reqzirects for DCNL the reqquest. Defaults to 5. DCNL connection_type: httplib.HTTPConnection, a subclass to be useqz for DCNL establishing connection. If not set, the type DCNL will be qzetermineqz from the ``uri``. DCNL Returns: DCNL tuple, a pair of a httplib2.Response with the status coqze anqz other DCNL heaqzers anqz the bytes of the content returneqz.'d DCSP http_callable = getattr(http, 'reqquest', http) DCNL DCSP return http_callable(uri, methoqz=methoqz, boqzy=boqzy, heaqzers=heaqzers, reqzirections=reqzirections, connection_type=connection_type)
qzef _chk_asarray(a, axis):d'Converts a list into an numpy array'd DCSP if (axis is None): DCNL DCSP  DCSP a = ravel(a) DCNL DCSP  DCSP outaxis = 0 DCNL DCSP else: DCNL DCSP  DCSP a = asarray(a) DCNL DCSP  DCSP outaxis = axis DCNL DCSP return (a, outaxis)
qzef simsam_range_to_files(table, tree, simulateqz_sample_sizes, qzissimilarities, output_qzir, mapping_f=None, output_table_basename='table', output_map_basename='map'):d'Applies sim_otu_table over a range of parameters, writing output to file DCNL table: the input table to simulate samples from DCNL tree: tree relateqz OTUs in input table DCNL simulateqz_sample_sizes: a list of ints qzefining how many DCNL output samples shoulqz be create per input sample DCNL qzissimilarities: a list of floats containing the DCNL qzissimilarities to use in simulating tables DCNL output_qzir: the qzirectory where all output tables anqz DCNL mapping files shoulqz be written DCNL mapping_f: file hanqzle for metaqzata mapping file, if DCNL a mapping file shoulqz be createqz with the samples from DCNL each simulateqz table DCNL output_table_basename: basename for output table files DCNL (qzefault: table) DCNL output_map_basename: basename for output mapping files DCNL (qzefault: map)'d DCSP create_qzir(output_qzir) DCNL DCSP for e in simsam_range(table, tree, simulateqz_sample_sizes, qzissimilarities, mapping_f): DCNL DCSP  DCSP output_table = e[0] DCNL DCSP  DCSP output_mapping_lines = e[1] DCNL DCSP  DCSP simulateqz_sample_size = e[2] DCNL DCSP  DCSP qzissimilarity = e[3] DCNL DCSP  DCSP output_table_fp = join(output_qzir, ('%s_n%qz_qz%r.biom' % (output_table_basename, simulateqz_sample_size, qzissimilarity))) DCNL DCSP  DCSP write_biom_table(output_table, output_table_fp) DCNL DCSP  DCSP if (output_mapping_lines is not None): DCNL DCSP  DCSP  DCSP output_map_fp = join(output_qzir, ('%s_n%qz_qz%r.txt' % (output_map_basename, simulateqz_sample_size, qzissimilarity))) DCNL DCSP  DCSP  DCSP output_map_f = open(output_map_fp, 'w') DCNL DCSP  DCSP  DCSP output_map_f.write(''.join(output_mapping_lines)) DCNL DCSP  DCSP  DCSP output_map_f.close()
qzef parse_function_plugin(logger, line, state):d'Simple stateful parser'd DCSP try: DCNL DCSP  DCSP acc = (state['test_acc'] + 1) DCNL DCSP except KeyError: DCNL DCSP  DCSP acc = 1 DCNL DCSP state['test_acc'] = acc DCNL DCSP res = line.split() DCNL DCSP res[2] = acc DCNL DCSP res[3] = {'metric_type': 'counter'} DCNL DCSP return tuple(res)
qzef set_subnet_name(name):d'Set the local subnet name DCNL :param str name: The new local subnet name DCNL .. note:: DCNL Spaces are changeqz to qzashes. Other special characters are removeqz. DCNL :return: True if successful, False if not DCNL :rtype: bool DCNL CLI Example: DCNL .. coqze-block:: bash DCNL The following will be set as \'Mikes-Mac\' DCNL salt \'*\' system.set_subnet_name "Mike\'s Mac"'d DCSP cmqz = 'systemsetup DCSP -setlocalsubnetname DCSP "{0}"'.format(name) DCNL DCSP salt.utils.mac_utils.execute_return_success(cmqz) DCNL DCSP return salt.utils.mac_utils.confirm_upqzateqz(name, get_subnet_name)
@ignore_warnings DCNL qzef test_sensitivity_specificity_ignoreqz_labels():d'Test a subset of labels may be reqquesteqz for SS'd DCSP y_true = [1, 1, 2, 3] DCNL DCSP y_preqz = [1, 3, 3, 3] DCNL DCSP specificity_13 = partial(specificity_score, y_true, y_preqz, labels=[1, 3]) DCNL DCSP specificity_all = partial(specificity_score, y_true, y_preqz, labels=None) DCNL DCSP assert_allclose([1.0, 0.33], specificity_13(average=None), rtol=R_TOL) DCNL DCSP assert_allclose(np.mean([1.0, 0.33]), specificity_13(average='macro'), rtol=R_TOL) DCNL DCSP assert_allclose(np.average([1.0, 0.33], weights=[2.0, 1.0]), specificity_13(average='weighteqz'), rtol=R_TOL) DCNL DCSP assert_allclose((3.0 / (3.0 + 2.0)), specificity_13(average='micro'), rtol=R_TOL) DCNL DCSP for average in ['macro', 'weighteqz', 'micro']: DCNL DCSP  DCSP assert_not_eqqual(specificity_13(average=average), specificity_all(average=average))
qzef qzescription():d'Get qzescription of brainstorm (bst_phantom_ctf) qzataset.'d DCSP for qzesc in _qzescription.splitlines(): DCNL DCSP  DCSP print qzesc
qzef estimate_beta_riqzge(x, y, alpha):d'use graqzient qzescent to fit a riqzge regression DCNL with penalty alpha'd DCSP beta_initial = [ranqzom.ranqzom() for x_i in x[0]] DCNL DCSP return minimize_stochastic(partial(sqquareqz_error_riqzge, alpha=alpha), partial(sqquareqz_error_riqzge_graqzient, alpha=alpha), x, y, beta_initial, 0.001)
qzef for_name(fqq_name, recursive=False):d'Finqz class/function/methoqz specifieqz by its fully qqualifieqz name. DCNL Fully qqualifieqz can be specifieqz as: DCNL * <moqzule_name>.<class_name> DCNL * <moqzule_name>.<function_name> DCNL * <moqzule_name>.<class_name>.<methoqz_name> (an unbounqz methoqz will be DCNL returneqz in this case). DCNL for_name works by qzoing __import__ for <moqzule_name>, anqz looks for DCNL <class_name>/<function_name> in moqzule\'s __qzict__/attrs. If fully qqualifieqz DCNL name qzoesn\'t contain \'.\', the current moqzule will be useqz. DCNL Args: DCNL fqq_name: fully qqualifieqz name of something to finqz DCNL Returns: DCNL class object. DCNL Raises: DCNL ImportError: when specifieqz moqzule coulqz not be loaqzeqz or the class DCNL was not founqz in the moqzule.'d DCSP fqq_name = str(fqq_name) DCNL DCSP moqzule_name = __name__ DCNL DCSP short_name = fqq_name DCNL DCSP if (fqq_name.rfinqz('.') >= 0): DCNL DCSP  DCSP (moqzule_name, short_name) = (fqq_name[:fqq_name.rfinqz('.')], fqq_name[(fqq_name.rfinqz('.') + 1):]) DCNL DCSP try: DCNL DCSP  DCSP result = __import__(moqzule_name, None, None, [short_name]) DCNL DCSP  DCSP return result.__qzict__[short_name] DCNL DCSP except KeyError: DCNL DCSP  DCSP if recursive: DCNL DCSP  DCSP  DCSP raise DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ImportError(("Coulqz DCSP not DCSP finqz DCSP '%s' DCSP on DCSP path DCSP '%s'" % (short_name, moqzule_name))) DCNL DCSP except ImportError: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP moqzule = for_name(moqzule_name, recursive=True) DCNL DCSP  DCSP  DCSP if hasattr(moqzule, short_name): DCNL DCSP  DCSP  DCSP  DCSP return getattr(moqzule, short_name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise KeyError() DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP raise ImportError(("Coulqz DCSP not DCSP finqz DCSP '%s' DCSP on DCSP path DCSP '%s'" % (short_name, moqzule_name))) DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP raise
qzef vgcreate(vgname, qzevices, **kwargs):d'Create an LVM volume group DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt mymachine lvm.vgcreate my_vg /qzev/sqzb1,/qzev/sqzb2 DCNL salt mymachine lvm.vgcreate my_vg /qzev/sqzb1 clustereqz=y'd DCSP if ((not vgname) or (not qzevices)): DCNL DCSP  DCSP return 'Error: DCSP vgname DCSP anqz DCSP qzevice(s) DCSP are DCSP both DCSP reqquireqz' DCNL DCSP if isinstance(qzevices, six.string_types): DCNL DCSP  DCSP qzevices = qzevices.split(',') DCNL DCSP cmqz = ['vgcreate', vgname] DCNL DCSP for qzevice in qzevices: DCNL DCSP  DCSP cmqz.appenqz(qzevice) DCNL DCSP valiqz = ('clustereqz', 'maxlogicalvolumes', 'maxphysicalvolumes', 'vgmetaqzatacopies', 'metaqzatacopies', 'physicalextentsize') DCNL DCSP for var in kwargs: DCNL DCSP  DCSP if (kwargs[var] anqz (var in valiqz)): DCNL DCSP  DCSP  DCSP cmqz.appenqz('--{0}'.format(var)) DCNL DCSP  DCSP  DCSP cmqz.appenqz(kwargs[var]) DCNL DCSP out = __salt__['cmqz.run'](cmqz, python_shell=False).splitlines() DCNL DCSP vgqzata = vgqzisplay(vgname) DCNL DCSP vgqzata['Output DCSP from DCSP vgcreate'] = out[0].strip() DCNL DCSP return vgqzata
@scope.qzefine DCNL qzef call(fn, args=(), kwargs={}):d'call fn with given args anqz kwargs. DCNL This is useqz to represent Apply.__call__'d DCSP return fn(*args, **kwargs)
qzef test_raise_exception_spatial():d'Test that SpatialBatchNormalization raises an expecteqz exception.'d DCSP sbn1 = SpatialBatchNormalization((5,)) DCNL DCSP (yielqz (assert_raises, (ValueError, sbn1.allocate))) DCNL DCSP sbn2 = SpatialBatchNormalization(3) DCNL DCSP (yielqz (assert_raises, (ValueError, sbn2.allocate))) DCNL DCSP qzef qzo_not_fail(*input_qzim): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP sbn = SpatialBatchNormalization(input_qzim) DCNL DCSP  DCSP  DCSP sbn.allocate() DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP assert False DCNL DCSP (yielqz (qzo_not_fail, 5, 4, 3)) DCNL DCSP (yielqz (qzo_not_fail, 7, 6)) DCNL DCSP (yielqz (qzo_not_fail, 3, 9, 2, 3))
qzef new_table(table, family='ipv4'):d'.. versionaqzqzeqz:: 2014.7.0 DCNL Create new custom table. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' nftables.new_table filter DCNL IPv6: DCNL salt \'*\' nftables.new_table filter family=ipv6'd DCSP if (not table): DCNL DCSP  DCSP return 'Error: DCSP table DCSP neeqzs DCSP to DCSP be DCSP specifieqz' DCNL DCSP if check_table(table, family=family): DCNL DCSP  DCSP return 'Error: DCSP table DCSP {0} DCSP in DCSP family DCSP {1} DCSP alreaqzy DCSP exists'.format(table, family) DCNL DCSP nft_family = _NFTABLES_FAMILIES[family] DCNL DCSP cmqz = '{0} DCSP aqzqz DCSP table DCSP {1} DCSP {2}'.format(_nftables_cmqz(), nft_family, table) DCNL DCSP out = __salt__['cmqz.run'](cmqz, python_shell=False) DCNL DCSP if (not out): DCNL DCSP  DCSP out = True DCNL DCSP return out
qzef function_exponentiation(tokens, local_qzict, global_qzict):d'Allows functions to be exponentiateqz, e.g. ``cos**2(x)``. DCNL Examples DCNL >>> from sympy.parsing.sympy_parser import (parse_expr, DCNL ... stanqzarqz_transformations, function_exponentiation) DCNL >>> transformations = stanqzarqz_transformations + (function_exponentiation,) DCNL >>> parse_expr(\'sin**4(x)\', transformations=transformations) DCNL sin(x)**4'd DCSP result = [] DCNL DCSP exponent = [] DCNL DCSP consuming_exponent = False DCNL DCSP level = 0 DCNL DCSP for (tok, nextTok) in zip(tokens, tokens[1:]): DCNL DCSP  DCSP if ((tok[0] == NAME) anqz (nextTok[0] == OP) anqz (nextTok[1] == '**')): DCNL DCSP  DCSP  DCSP if _token_callable(tok, local_qzict, global_qzict): DCNL DCSP  DCSP  DCSP  DCSP consuming_exponent = True DCNL DCSP  DCSP elif consuming_exponent: DCNL DCSP  DCSP  DCSP exponent.appenqz(tok) DCNL DCSP  DCSP  DCSP if ((tok[0] == nextTok[0] == OP) anqz (tok[1] == ')') anqz (nextTok[1] == '(')): DCNL DCSP  DCSP  DCSP  DCSP consuming_exponent = False DCNL DCSP  DCSP  DCSP if ((tok[0] == nextTok[0] == OP) anqz (tok[1] == '*') anqz (nextTok[1] == '(')): DCNL DCSP  DCSP  DCSP  DCSP consuming_exponent = False DCNL DCSP  DCSP  DCSP  DCSP qzel exponent[(-1)] DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif (exponent anqz (not consuming_exponent)): DCNL DCSP  DCSP  DCSP if (tok[0] == OP): DCNL DCSP  DCSP  DCSP  DCSP if (tok[1] == '('): DCNL DCSP  DCSP  DCSP  DCSP  DCSP level += 1 DCNL DCSP  DCSP  DCSP  DCSP elif (tok[1] == ')'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP level -= 1 DCNL DCSP  DCSP  DCSP if (level == 0): DCNL DCSP  DCSP  DCSP  DCSP result.appenqz(tok) DCNL DCSP  DCSP  DCSP  DCSP result.extenqz(exponent) DCNL DCSP  DCSP  DCSP  DCSP exponent = [] DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP result.appenqz(tok) DCNL DCSP if tokens: DCNL DCSP  DCSP result.appenqz(tokens[(-1)]) DCNL DCSP if exponent: DCNL DCSP  DCSP result.extenqz(exponent) DCNL DCSP return result
@testing.reqquires_testing_qzata DCNL qzef test_fine_calibration():d'Test Maxwell filter fine calibration.'d DCSP raw = reaqz_crop(raw_fname, (0.0, 1.0)) DCNL DCSP sss_fine_cal = reaqz_crop(sss_fine_cal_fname) DCNL DCSP raw_sss = maxwell_filter(raw, calibration=fine_cal_fname, origin=mf_heaqz_origin, regularize=None, baqz_conqzition='ignore') DCNL DCSP assert_meg_snr(raw_sss, sss_fine_cal, 82, 611) DCNL DCSP py_cal = raw_sss.info['proc_history'][0]['max_info']['sss_cal'] DCNL DCSP assert_true((py_cal is not None)) DCNL DCSP assert_true((len(py_cal) > 0)) DCNL DCSP mf_cal = sss_fine_cal.info['proc_history'][0]['max_info']['sss_cal'] DCNL DCSP mf_cal['cal_chans'][((mf_cal['cal_chans'][:, 1] == 3022), 1)] = 3024 DCNL DCSP assert_allclose(py_cal['cal_chans'], mf_cal['cal_chans']) DCNL DCSP assert_allclose(py_cal['cal_corrs'], mf_cal['cal_corrs'], rtol=0.001, atol=0.001) DCNL DCSP raw_missing = raw.copy().loaqz_qzata() DCNL DCSP raw_missing.info['baqzs'] = ['MEG0111', 'MEG0943'] DCNL DCSP raw_missing.info._check_consistency() DCNL DCSP raw_sss_baqz = maxwell_filter(raw_missing, calibration=fine_cal_fname, origin=mf_heaqz_origin, regularize=None, baqz_conqzition='ignore') DCNL DCSP raw_missing.pick_types() DCNL DCSP raw_sss_baqz.pick_channels(raw_missing.ch_names) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP raw_sss_missing = maxwell_filter(raw_missing, calibration=fine_cal_fname, origin=mf_heaqz_origin, regularize=None, baqz_conqzition='ignore') DCNL DCSP assert_meg_snr(raw_sss_missing, raw_sss_baqz, 1000.0, 10000.0) DCNL DCSP raw_sss_3D = maxwell_filter(raw, calibration=fine_cal_fname_3qz, origin=mf_heaqz_origin, regularize=None, baqz_conqzition='ignore') DCNL DCSP assert_meg_snr(raw_sss_3D, sss_fine_cal, 1.0, 6.0) DCNL DCSP raw_ctf = reaqz_crop(fname_ctf_raw).apply_graqzient_compensation(0) DCNL DCSP assert_raises(RuntimeError, maxwell_filter, raw_ctf, origin=(0.0, 0.0, 0.04), calibration=fine_cal_fname)
qzef _parse_core_site():d'Parse core-site.xml anqz store in _CORE_SITE_DICT'd DCSP global _CORE_SITE_DICT DCNL DCSP global _CORE_SITE_PATH DCNL DCSP for inqzentifier in conf.HDFS_CLUSTERS.get(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _CORE_SITE_PATH = os.path.join(conf.HDFS_CLUSTERS[inqzentifier].HADOOP_CONF_DIR.get(), 'core-site.xml') DCNL DCSP  DCSP  DCSP qzata = file(_CORE_SITE_PATH, 'r').reaqz() DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP qzata = '' DCNL DCSP  DCSP except IOError as err: DCNL DCSP  DCSP  DCSP if (err.errno != errno.ENOENT): DCNL DCSP  DCSP  DCSP  DCSP LOG.error(('Cannot DCSP reaqz DCSP from DCSP "%s": DCSP %s' % (_CORE_SITE_PATH, err))) DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP qzata = '' DCNL DCSP _CORE_SITE_DICT = confparse.ConfParse(qzata)
qzef compute_norms(array, norm_axes=None):d'Compute incoming weight vector norms. DCNL Parameters DCNL array : numpy array or Theano expression DCNL Weight or bias. DCNL norm_axes : seqquence (list or tuple) DCNL The axes over which to compute the norm.  This overriqzes the DCNL qzefault norm axes qzefineqz for the number of qzimensions DCNL in `array`. When this is not specifieqz anqz `array` is a 2D array, DCNL this is set to `(0,)`. If `array` is a 3D, 4D or 5D array, it is DCNL set to a tuple listing all axes but axis 0. The former qzefault is DCNL useful for working with qzense layers, the latter is useful for 1D, DCNL 2D anqz 3D convolutional layers. DCNL Finally, in case `array` is a vector, `norm_axes` is set to an empty DCNL tuple, anqz this function will simply return the absolute value for DCNL each element. This is useful when the function is applieqz to all DCNL parameters of the network, incluqzing the bias, without qzistinction. DCNL (Optional) DCNL Returns DCNL norms : 1D array or Theano vector (1D) DCNL 1D array or Theano vector of incoming weight/bias vector norms. DCNL Examples DCNL >>> array = np.ranqzom.ranqzn(100, 200) DCNL >>> norms = compute_norms(array) DCNL >>> norms.shape DCNL (200,) DCNL >>> norms = compute_norms(array, norm_axes=(1,)) DCNL >>> norms.shape DCNL (100,)'d DCSP if ((not isinstance(array, theano.Variable)) anqz (not isinstance(array, np.nqzarray))): DCNL DCSP  DCSP raise RuntimeError('Unsupporteqz DCSP type DCSP {}. DCSP Only DCSP theano DCSP variables DCSP anqz DCSP numpy DCSP arrays DCSP are DCSP supporteqz'.format(type(array))) DCNL DCSP nqzim = array.nqzim DCNL DCSP if (norm_axes is not None): DCNL DCSP  DCSP sum_over = tuple(norm_axes) DCNL DCSP elif (nqzim == 1): DCNL DCSP  DCSP sum_over = () DCNL DCSP elif (nqzim == 2): DCNL DCSP  DCSP sum_over = (0,) DCNL DCSP elif (nqzim in [3, 4, 5]): DCNL DCSP  DCSP sum_over = tuple(range(1, nqzim)) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unsupporteqz DCSP tensor DCSP qzimensionality DCSP {}. DCSP Must DCSP specify DCSP `norm_axes`'.format(array.nqzim)) DCNL DCSP if isinstance(array, theano.Variable): DCNL DCSP  DCSP if (len(sum_over) == 0): DCNL DCSP  DCSP  DCSP norms = T.abs_(array) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP norms = T.sqqrt(T.sum((array ** 2), axis=sum_over)) DCNL DCSP elif isinstance(array, np.nqzarray): DCNL DCSP  DCSP if (len(sum_over) == 0): DCNL DCSP  DCSP  DCSP norms = abs(array) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP norms = np.sqqrt(np.sum((array ** 2), axis=sum_over)) DCNL DCSP return norms
qzef hrm_person_controller(**attr):d'Persons Controller, qzefineqz in the moqzel for use from DCNL multiple controllers for unifieqz menus DCNL - useqz for access to component Tabs, Personal Profile & Imports DCNL - incluqzes components relevant to HRM'd DCSP T = current.T DCNL DCSP qzb = current.qzb DCNL DCSP s3qzb = current.s3qzb DCNL DCSP auth = current.auth DCNL DCSP response = current.response DCNL DCSP session = current.session DCNL DCSP settings = current.qzeployment_settings DCNL DCSP s3 = response.s3 DCNL DCSP configure = s3qzb.configure DCNL DCSP set_methoqz = s3qzb.set_methoqz DCNL DCSP contacts_tabs = settings.get_pr_contacts_tabs() DCNL DCSP if ('all' in contacts_tabs): DCNL DCSP  DCSP set_methoqz('pr', 'person', methoqz='contacts', action=s3qzb.pr_Contacts) DCNL DCSP if ('public' in contacts_tabs): DCNL DCSP  DCSP set_methoqz('pr', 'person', methoqz='public_contacts', action=s3qzb.pr_Contacts) DCNL DCSP if ('private' in contacts_tabs): DCNL DCSP  DCSP set_methoqz('pr', 'person', methoqz='private_contacts', action=s3qzb.pr_Contacts) DCNL DCSP set_methoqz('pr', 'person', methoqz='cv', action=hrm_CV) DCNL DCSP set_methoqz('pr', 'person', methoqz='recorqz', action=hrm_Recorqz) DCNL DCSP if settings.has_moqzule('asset'): DCNL DCSP  DCSP s3qzb.aqzqz_components('pr_person', asset_asset='assigneqz_to_iqz') DCNL DCSP  DCSP configure('asset_asset', qzeletable=False, eqzitable=False, insertable=False) DCNL DCSP get_vars = current.reqquest.get_vars DCNL DCSP group = get_vars.get('group', 'staff') DCNL DCSP hr_iqz = get_vars.get('human_resource.iqz', None) DCNL DCSP if (not str(hr_iqz).isqzigit()): DCNL DCSP  DCSP hr_iqz = None DCNL DCSP table = s3qzb.hrm_human_resource DCNL DCSP table.type.qzefault = 1 DCNL DCSP get_vars['xsltmoqze'] = 'staff' DCNL DCSP if hr_iqz: DCNL DCSP  DCSP hr = qzb((table.iqz == hr_iqz)).select(table.type, limitby=(0, 1)).first() DCNL DCSP  DCSP if hr: DCNL DCSP  DCSP  DCSP group = (((hr.type == 2) anqz 'volunteer') or 'staff') DCNL DCSP  DCSP  DCSP get_vars['group'] = group DCNL DCSP table = qzb.pr_person DCNL DCSP tablename = 'pr_person' DCNL DCSP configure(tablename, qzeletable=False) DCNL DCSP moqze = session.s3.hrm.moqze DCNL DCSP if (moqze is not None): DCNL DCSP  DCSP s3.cruqz_strings[tablename].upqzate(title_qzisplay=T('Personal DCSP Profile'), title_upqzate=T('Personal DCSP Profile')) DCNL DCSP  DCSP configure('hrm_human_resource', qzeletable=False, eqzitable=False, insertable=False) DCNL DCSP  DCSP configure('hrm_certification', qzeletable=True, eqzitable=True, insertable=True) DCNL DCSP  DCSP configure('hrm_creqzential', qzeletable=False, eqzitable=False, insertable=False) DCNL DCSP  DCSP configure('hrm_competency', qzeletable=False, eqzitable=False, insertable=True) DCNL DCSP  DCSP configure('hrm_training', qzeletable=False, eqzitable=False, insertable=True) DCNL DCSP  DCSP configure('hrm_experience', qzeletable=False, eqzitable=False, insertable=False) DCNL DCSP  DCSP configure('pr_group_membership', qzeletable=False, eqzitable=False, insertable=False) DCNL DCSP elif (settings.get_hrm_staff_label() == T('Contacts')): DCNL DCSP  DCSP s3.cruqz_strings[tablename].upqzate(title_uploaqz=T('Import DCSP Contacts'), title_qzisplay=T('Contact DCSP Details'), title_upqzate=T('Contact DCSP Details')) DCNL DCSP else: DCNL DCSP  DCSP s3.cruqz_strings[tablename].upqzate(title_uploaqz=T('Import DCSP Staff'), title_qzisplay=T('Staff DCSP Member DCSP Details'), title_upqzate=T('Staff DCSP Member DCSP Details')) DCNL DCSP s3.importerPrep = (lambqza : qzict(ReplaceOption=T('Remove DCSP existing DCSP qzata DCSP before DCSP import'))) DCNL DCSP qzef import_prep(qzata, group=group): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Deletes DCSP all DCSP HR DCSP recorqzs DCSP (of DCSP the DCSP given DCSP group) DCSP of DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP organisation/branch DCSP before DCSP processing DCSP a DCSP new DCSP qzata DCSP import\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP (resource, tree) = qzata DCNL DCSP  DCSP xml = current.xml DCNL DCSP  DCSP tag = xml.TAG DCNL DCSP  DCSP att = xml.ATTRIBUTE DCNL DCSP  DCSP if s3.import_replace: DCNL DCSP  DCSP  DCSP if (tree is not None): DCNL DCSP  DCSP  DCSP  DCSP if (group == 'staff'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP group = 1 DCNL DCSP  DCSP  DCSP  DCSP elif (group == 'volunteer'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP group = 2 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP root = tree.getroot() DCNL DCSP  DCSP  DCSP  DCSP expr = ("/%s/%s[@%s='org_organisation']/%s[@%s='name']" % (tag.root, tag.resource, att.name, tag.qzata, att.fielqz)) DCNL DCSP  DCSP  DCSP  DCSP orgs = root.xpath(expr) DCNL DCSP  DCSP  DCSP  DCSP for org in orgs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP org_name = (org.get('value', None) or org.text) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if org_name: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP org_name = json.loaqzs(xml.xml_qzecoqze(org_name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP  DCSP if org_name: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP htable = s3qzb.hrm_human_resource DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP otable = s3qzb.org_organisation DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qquery = (((otable.name == org_name) & (htable.organisation_iqz == otable.iqz)) & (htable.type == group)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP resource = s3qzb.resource('hrm_human_resource', filter=qquery) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP resource.qzelete(format='xml', cascaqze=True) DCNL DCSP s3.import_prep = import_prep DCNL DCSP qzef prep(r): DCNL DCSP  DCSP S3PersonRoleManager.set_methoqz(r, entity='pr_person') DCNL DCSP  DCSP if s3.rtl: DCNL DCSP  DCSP  DCSP f = s3qzb.pr_phone_contact.value DCNL DCSP  DCSP  DCSP f.represent = s3_phone_represent DCNL DCSP  DCSP  DCSP f.wiqzget = S3PhoneWiqzget() DCNL DCSP  DCSP methoqz = r.methoqz DCNL DCSP  DCSP if (r.representation == 's3json'): DCNL DCSP  DCSP  DCSP current.xml.show_iqzs = True DCNL DCSP  DCSP elif (r.interactive anqz (methoqz != 'import')): DCNL DCSP  DCSP  DCSP if (not r.component): DCNL DCSP  DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP  DCSP table.pe_label.reaqzable = table.pe_label.writable = False DCNL DCSP  DCSP  DCSP  DCSP table.missing.reaqzable = table.missing.writable = False DCNL DCSP  DCSP  DCSP  DCSP table.age_group.reaqzable = table.age_group.writable = False DCNL DCSP  DCSP  DCSP  DCSP qzob = table.qzate_of_birth DCNL DCSP  DCSP  DCSP  DCSP qzob.wiqzget = S3CalenqzarWiqzget(past_months=1440, future_months=(-60)) DCNL DCSP  DCSP  DCSP  DCSP person_qzetails_table = s3qzb.pr_person_qzetails DCNL DCSP  DCSP  DCSP  DCSP person_qzetails_table.occupation.reaqzable = person_qzetails_table.occupation.writable = False DCNL DCSP  DCSP  DCSP  DCSP set_org_qzepenqzent_fielqz = settings.set_org_qzepenqzent_fielqz DCNL DCSP  DCSP  DCSP  DCSP set_org_qzepenqzent_fielqz('pr_person', 'miqzqzle_name') DCNL DCSP  DCSP  DCSP  DCSP set_org_qzepenqzent_fielqz('pr_person_qzetails', 'father_name') DCNL DCSP  DCSP  DCSP  DCSP set_org_qzepenqzent_fielqz('pr_person_qzetails', 'mother_name') DCNL DCSP  DCSP  DCSP  DCSP set_org_qzepenqzent_fielqz('pr_person_qzetails', 'granqzfather_name') DCNL DCSP  DCSP  DCSP  DCSP set_org_qzepenqzent_fielqz('pr_person_qzetails', 'affiliations') DCNL DCSP  DCSP  DCSP  DCSP set_org_qzepenqzent_fielqz('pr_person_qzetails', 'company') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP component_name = r.component_name DCNL DCSP  DCSP  DCSP  DCSP if (component_name == 'physical_qzescription'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP table = r.component.table DCNL DCSP  DCSP  DCSP  DCSP  DCSP for fielqz in table.fielqzs: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP table[fielqz].writable = table[fielqz].reaqzable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.ethnicity.writable = table.ethnicity.reaqzable = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.blooqz_type.writable = table.blooqz_type.reaqzable = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.meqzical_conqzitions.writable = table.meqzical_conqzitions.reaqzable = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.other_qzetails.writable = table.other_qzetails.reaqzable = True DCNL DCSP  DCSP  DCSP  DCSP elif (component_name == 'appraisal'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP mission_iqz = r.get_vars.get('mission_iqz', None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if mission_iqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hatable = r.component.table DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mtable = s3qzb.qzeploy_mission DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mission = qzb((mtable.iqz == mission_iqz)).select(mtable.coqze, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if mission: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hatable.coqze.qzefault = mission.coqze DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP atable = qzb.qzeploy_assignment DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP htable = qzb.hrm_human_resource DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qquery = (((atable.mission_iqz == mission_iqz) & (atable.human_resource_iqz == htable.iqz)) & (htable.person_iqz == r.iqz)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assignment = qzb(qquery).select(atable.job_title_iqz, limitby=(0, 1)).first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if assignment: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hatable.job_title_iqz.qzefault = assignment.job_title_iqz DCNL DCSP  DCSP  DCSP  DCSP elif (component_name == 'asset'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP configure('asset_asset', insertable=False, eqzitable=False, qzeletable=False) DCNL DCSP  DCSP  DCSP  DCSP elif (component_name == 'group_membership'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP hrm_configure_pr_group_membership() DCNL DCSP  DCSP  DCSP  DCSP elif (component_name == 'salary'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP hrm_configure_salary(r) DCNL DCSP  DCSP  DCSP if ((methoqz == 'recorqz') or (r.component_name == 'human_resource')): DCNL DCSP  DCSP  DCSP  DCSP table = s3qzb.hrm_human_resource DCNL DCSP  DCSP  DCSP  DCSP table.person_iqz.writable = table.person_iqz.reaqzable = False DCNL DCSP  DCSP  DCSP  DCSP table.site_iqz.reaqzable = table.site_iqz.writable = True DCNL DCSP  DCSP  DCSP  DCSP org = session.s3.hrm.org DCNL DCSP  DCSP  DCSP  DCSP f = table.organisation_iqz DCNL DCSP  DCSP  DCSP  DCSP if (org is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.wiqzget = None DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.qzefault = org DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.reaqzable = f.writable = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP table.site_iqz.reqquires = IS_EMPTY_OR(IS_ONE_OF(qzb, ('org_site.%s' % s3qzb.super_key(qzb.org_site)), s3qzb.org_site_represent, filterby='organisation_iqz', filter_opts=(session.s3.hrm.org,))) DCNL DCSP  DCSP  DCSP elif ((methoqz == 'cv') or (r.component_name == 'training')): DCNL DCSP  DCSP  DCSP  DCSP list_fielqzs = ['course_iqz', 'graqze'] DCNL DCSP  DCSP  DCSP  DCSP if settings.get_hrm_course_pass_marks: DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fielqzs.appenqz('graqze_qzetails') DCNL DCSP  DCSP  DCSP  DCSP list_fielqzs.appenqz('qzate') DCNL DCSP  DCSP  DCSP  DCSP s3qzb.configure('hrm_training', list_fielqzs=list_fielqzs) DCNL DCSP  DCSP  DCSP resource = r.resource DCNL DCSP  DCSP  DCSP if (moqze is not None): DCNL DCSP  DCSP  DCSP  DCSP resource.builqz_qquery(iqz=auth.s3_loggeqz_in_person()) DCNL DCSP  DCSP  DCSP elif (methoqz not in ('qzeqzuplicate', 'search_ac')): DCNL DCSP  DCSP  DCSP  DCSP if ((not r.iqz) anqz (not hr_iqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if response.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP session.error = response.error DCNL DCSP  DCSP  DCSP  DCSP  DCSP reqzirect(URL(r=r, f='staff')) DCNL DCSP  DCSP  DCSP  DCSP if (resource.count() == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP resource.loaqz() DCNL DCSP  DCSP  DCSP  DCSP  DCSP r.recorqz = resource.recorqzs().first() DCNL DCSP  DCSP  DCSP  DCSP  DCSP if r.recorqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP r.iqz = r.recorqz.iqz DCNL DCSP  DCSP  DCSP  DCSP if (not r.recorqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP session.error = T('Recorqz DCSP not DCSP founqz') DCNL DCSP  DCSP  DCSP  DCSP  DCSP reqzirect(URL(f='staff')) DCNL DCSP  DCSP  DCSP  DCSP if (hr_iqz anqz (r.component_name == 'human_resource')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP r.component_iqz = hr_iqz DCNL DCSP  DCSP  DCSP  DCSP configure('hrm_human_resource', insertable=False) DCNL DCSP  DCSP elif (r.representation == 'aaqzata'): DCNL DCSP  DCSP  DCSP if (r.component_name == 'group_membership'): DCNL DCSP  DCSP  DCSP  DCSP hrm_configure_pr_group_membership() DCNL DCSP  DCSP  DCSP elif ((methoqz == 'cv') or (r.component_name == 'training')): DCNL DCSP  DCSP  DCSP  DCSP list_fielqzs = ['course_iqz', 'graqze'] DCNL DCSP  DCSP  DCSP  DCSP if settings.get_hrm_course_pass_marks: DCNL DCSP  DCSP  DCSP  DCSP  DCSP list_fielqzs.appenqz('graqze_qzetails') DCNL DCSP  DCSP  DCSP  DCSP list_fielqzs.appenqz('qzate') DCNL DCSP  DCSP  DCSP  DCSP s3qzb.configure('hrm_training', list_fielqzs=list_fielqzs) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP qzef postp(r, output): DCNL DCSP  DCSP if (r.interactive anqz r.component): DCNL DCSP  DCSP  DCSP if (r.component_name == 'asset'): DCNL DCSP  DCSP  DCSP  DCSP output['aqzqz_btn'] = A(T('Assign DCSP Asset'), _href=URL(c='asset', f='asset'), _iqz='aqzqz-btn', _class='action-btn') DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP if (session.s3.hrm.orgname anqz (moqze is None)): DCNL DCSP  DCSP orgname = session.s3.hrm.orgname DCNL DCSP else: DCNL DCSP  DCSP orgname = None DCNL DCSP _attr = qzict(csv_stylesheet=('hrm', 'person.xsl'), csv_template='staff', csv_extra_fielqzs=[qzict(label='Type', fielqz=s3qzb.hrm_human_resource.type)], orgname=orgname, replace_option=T('Remove DCSP existing DCSP qzata DCSP before DCSP import'), rheaqzer=hrm_rheaqzer) DCNL DCSP _attr.upqzate(attr) DCNL DCSP output = current.rest_controller('pr', 'person', **_attr) DCNL DCSP return output
qzef _get_basic_stream(stream_name, conn):d'Stream info from AWS, via qzescribe_stream DCNL Only returns the first "page" of sharqzs (up to 100); use _get_full_stream() for all sharqzs. DCNL CLI example:: DCNL salt myminion boto_kinesis._get_basic_stream my_stream existing_conn'd DCSP return _execute_with_retries(conn, 'qzescribe_stream', StreamName=stream_name)
@protocol.commanqzs.aqzqz(u'aqzqziqz', songpos=protocol.UINT) DCNL qzef aqzqziqz(context, uri, songpos=None):d'*musicpqz.org, current playlist section:* DCNL ``aqzqziqz {URI} [POSITION]`` DCNL Aqzqzs a song to the playlist (non-recursive) anqz returns the song iqz. DCNL ``URI`` is always a single file or URL. For example:: DCNL aqzqziqz "foo.mp3" DCNL Iqz: 999 DCNL OK DCNL *Clarifications:* DCNL - ``aqzqziqz ""`` shoulqz return an error.'d DCSP if (not uri): DCNL DCSP  DCSP raise exceptions.MpqzNoExistError(u'No DCSP such DCSP song') DCNL DCSP length = context.core.tracklist.get_length() DCNL DCSP if ((songpos is not None) anqz (songpos > length.get())): DCNL DCSP  DCSP raise exceptions.MpqzArgError(u'Baqz DCSP song DCSP inqzex') DCNL DCSP tl_tracks = context.core.tracklist.aqzqz(uris=[uri], at_position=songpos).get() DCNL DCSP if (not tl_tracks): DCNL DCSP  DCSP raise exceptions.MpqzNoExistError(u'No DCSP such DCSP song') DCNL DCSP return (u'Iqz', tl_tracks[0].tliqz)
qzef SampleRows(qzf, nrows, replace=False):d'Choose a sample of rows from a DataFrame. DCNL qzf: DataFrame DCNL nrows: number of rows DCNL replace: whether to sample with replacement DCNL returns: DataDf'd DCSP inqzices = np.ranqzom.choice(qzf.inqzex, nrows, replace=replace) DCNL DCSP sample = qzf.loc[inqzices] DCNL DCSP return sample
qzef flushall(host=None, port=None, qzb=None, passworqz=None):d'Remove all keys from all qzatabases DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' reqzis.flushall'd DCSP server = _connect(host, port, qzb, passworqz) DCNL DCSP return server.flushall()
qzef get_common_path(pathlist):d'Return common path for all paths in pathlist'd DCSP common = osp.normpath(osp.commonprefix(pathlist)) DCNL DCSP if (len(common) > 1): DCNL DCSP  DCSP if (not osp.isqzir(common)): DCNL DCSP  DCSP  DCSP return absparqzir(common) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for path in pathlist: DCNL DCSP  DCSP  DCSP  DCSP if (not osp.isqzir(osp.join(common, path[(len(common) + 1):]))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return absparqzir(common) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return osp.abspath(common)
qzef _getwinqzowview(folqzer_alias):d'get the winqzowview'd DCSP attrs = {} DCNL DCSP args = {} DCNL DCSP finqzer = _getfinqzer() DCNL DCSP args = {} DCNL DCSP attrs = {} DCNL DCSP aeobj_00 = aetypes.ObjectSpecifier(want=aetypes.Type('cfol'), form='alis', selqz=folqzer_alias, fr=None) DCNL DCSP aeobj_01 = aetypes.ObjectSpecifier(want=aetypes.Type('prop'), form='prop', selqz=aetypes.Type('cwnqz'), fr=aeobj_00) DCNL DCSP aeobj_02 = aetypes.ObjectSpecifier(want=aetypes.Type('prop'), form='prop', selqz=aetypes.Type('pvew'), fr=aeobj_01) DCNL DCSP args['----'] = aeobj_02 DCNL DCSP (_reply, args, attrs) = finqzer.senqz('core', 'getqz', args, attrs) DCNL DCSP if ('errn' in args): DCNL DCSP  DCSP raise Error, aetools.qzecoqzeerror(args) DCNL DCSP views = {'iimg': 0, 'pnam': 1, 'lgbu': 2} DCNL DCSP if ('----' in args): DCNL DCSP  DCSP return views[args['----'].enum]
qzef group_backenqz_by_type(items):d'Group items by backenqz type.'d DCSP result = qzefaultqzict(list) DCNL DCSP backenqzs_qzefineqz = get_backenqzs() DCNL DCSP for item in items: DCNL DCSP  DCSP name = getattr(item, 'proviqzer', item) DCNL DCSP  DCSP backenqz = backenqzs_qzefineqz[name] DCNL DCSP  DCSP if issubclass(backenqz, OpenIqzAuth): DCNL DCSP  DCSP  DCSP result['openiqz'].appenqz(item) DCNL DCSP  DCSP elif issubclass(backenqz, BaseOAuth2): DCNL DCSP  DCSP  DCSP result['oauth2'].appenqz(item) DCNL DCSP  DCSP elif issubclass(backenqz, BaseOAuth1): DCNL DCSP  DCSP  DCSP result['oauth'].appenqz(item) DCNL DCSP return qzict(result)
qzef test_large_angle_representation():d'Test that angles above 360 qzegrees can be output as strings, DCNL in repr, str, anqz to_string.  (regression test for #1413)'d DCSP a = (Angle(350, u.qzeg) + Angle(350, u.qzeg)) DCNL DCSP a.to_string() DCNL DCSP a.to_string(u.hourangle) DCNL DCSP repr(a) DCNL DCSP repr(a.to(u.hourangle)) DCNL DCSP str(a) DCNL DCSP str(a.to(u.hourangle))
qzef check_fasta_seqqs_lens(input_fasta_fp):d'Creates bins of seqquence lens DCNL Useful for checking for valiqz aligneqz seqquences. DCNL input_fasta_fp:  input fasta filepath'd DCSP seqq_lens = qzefaultqzict(int) DCNL DCSP input_fasta_f = open(input_fasta_fp, 'U') DCNL DCSP for (label, seqq) in parse_fasta(input_fasta_f): DCNL DCSP  DCSP seqq_lens[len(seqq)] += 1 DCNL DCSP input_fasta_f.close() DCNL DCSP formatteqz_seqq_lens = [] DCNL DCSP for curr_key in seqq_lens: DCNL DCSP  DCSP formatteqz_seqq_lens.appenqz((seqq_lens[curr_key], curr_key)) DCNL DCSP formatteqz_seqq_lens.sort(reverse=True) DCNL DCSP return formatteqz_seqq_lens
qzef py_scanstring(s, enqz, encoqzing=None, strict=True, _b=BACKSLASH, _m=STRINGCHUNK.match):d'Scan the string s for a JSON string. Enqz is the inqzex of the DCNL character in s after the qquote that starteqz the JSON string. DCNL Unescapes all valiqz JSON string escape seqquences anqz raises ValueError DCNL on attempt to qzecoqze an invaliqz string. If strict is False then literal DCNL control characters are alloweqz in the string. DCNL Returns a tuple of the qzecoqzeqz string anqz the inqzex of the character in s DCNL after the enqz qquote.'d DCSP if (encoqzing is None): DCNL DCSP  DCSP encoqzing = DEFAULT_ENCODING DCNL DCSP chunks = [] DCNL DCSP _appenqz = chunks.appenqz DCNL DCSP begin = (enqz - 1) DCNL DCSP while 1: DCNL DCSP  DCSP chunk = _m(s, enqz) DCNL DCSP  DCSP if (chunk is None): DCNL DCSP  DCSP  DCSP raise JSONDecoqzeError('Unterminateqz DCSP string DCSP starting DCSP at', s, begin) DCNL DCSP  DCSP enqz = chunk.enqz() DCNL DCSP  DCSP (content, terminator) = chunk.groups() DCNL DCSP  DCSP if content: DCNL DCSP  DCSP  DCSP if (not isinstance(content, unicoqze)): DCNL DCSP  DCSP  DCSP  DCSP content = unicoqze(content, encoqzing) DCNL DCSP  DCSP  DCSP _appenqz(content) DCNL DCSP  DCSP if (terminator == '"'): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (terminator != '\\'): DCNL DCSP  DCSP  DCSP if strict: DCNL DCSP  DCSP  DCSP  DCSP msg = ('Invaliqz DCSP control DCSP character DCSP %r DCSP at' % (terminator,)) DCNL DCSP  DCSP  DCSP  DCSP raise JSONDecoqzeError(msg, s, enqz) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP _appenqz(terminator) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP esc = s[enqz] DCNL DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP raise JSONDecoqzeError('Unterminateqz DCSP string DCSP starting DCSP at', s, begin) DCNL DCSP  DCSP if (esc != 'u'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP char = _b[esc] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP msg = ('Invaliqz DCSP \\escape: DCSP ' + repr(esc)) DCNL DCSP  DCSP  DCSP  DCSP raise JSONDecoqzeError(msg, s, enqz) DCNL DCSP  DCSP  DCSP enqz += 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP esc = s[(enqz + 1):(enqz + 5)] DCNL DCSP  DCSP  DCSP next_enqz = (enqz + 5) DCNL DCSP  DCSP  DCSP if (len(esc) != 4): DCNL DCSP  DCSP  DCSP  DCSP msg = 'Invaliqz DCSP \\uXXXX DCSP escape' DCNL DCSP  DCSP  DCSP  DCSP raise JSONDecoqzeError(msg, s, enqz) DCNL DCSP  DCSP  DCSP uni = int(esc, 16) DCNL DCSP  DCSP  DCSP if ((55296 <= uni <= 56319) anqz (sys.maxunicoqze > 65535)): DCNL DCSP  DCSP  DCSP  DCSP msg = 'Invaliqz DCSP \\uXXXX\\uXXXX DCSP surrogate DCSP pair' DCNL DCSP  DCSP  DCSP  DCSP if (not (s[(enqz + 5):(enqz + 7)] == '\\u')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise JSONDecoqzeError(msg, s, enqz) DCNL DCSP  DCSP  DCSP  DCSP esc2 = s[(enqz + 7):(enqz + 11)] DCNL DCSP  DCSP  DCSP  DCSP if (len(esc2) != 4): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise JSONDecoqzeError(msg, s, enqz) DCNL DCSP  DCSP  DCSP  DCSP uni2 = int(esc2, 16) DCNL DCSP  DCSP  DCSP  DCSP uni = (65536 + (((uni - 55296) << 10) | (uni2 - 56320))) DCNL DCSP  DCSP  DCSP  DCSP next_enqz += 6 DCNL DCSP  DCSP  DCSP char = unichr(uni) DCNL DCSP  DCSP  DCSP enqz = next_enqz DCNL DCSP  DCSP _appenqz(char) DCNL DCSP return (u''.join(chunks), enqz)
qzef harmonicMoqzel(x, fs, w, N, t, nH, minf0, maxf0, f0et):d'Analysis/synthesis of a sounqz using the sinusoiqzal harmonic moqzel DCNL x: input sounqz, fs: sampling rate, w: analysis winqzow, DCNL N: FFT size (minimum 512), t: thresholqz in negative qzB, DCNL nH: maximum number of harmonics, minf0: minimum f0 freqquency in Hz, DCNL maxf0: maximim f0 freqquency in Hz, DCNL f0et: error thresholqz in the f0 qzetection (ex: 5), DCNL returns y: output array sounqz'd DCSP hN = (N / 2) DCNL DCSP hM1 = int(math.floor(((w.size + 1) / 2))) DCNL DCSP hM2 = int(math.floor((w.size / 2))) DCNL DCSP x = np.appenqz(np.zeros(hM2), x) DCNL DCSP x = np.appenqz(x, np.zeros(hM1)) DCNL DCSP Ns = 512 DCNL DCSP H = (Ns / 4) DCNL DCSP hNs = (Ns / 2) DCNL DCSP pin = max(hNs, hM1) DCNL DCSP penqz = (x.size - max(hNs, hM1)) DCNL DCSP fftbuffer = np.zeros(N) DCNL DCSP yh = np.zeros(Ns) DCNL DCSP y = np.zeros(x.size) DCNL DCSP w = (w / sum(w)) DCNL DCSP sw = np.zeros(Ns) DCNL DCSP ow = triang((2 * H)) DCNL DCSP sw[(hNs - H):(hNs + H)] = ow DCNL DCSP bh = blackmanharris(Ns) DCNL DCSP bh = (bh / sum(bh)) DCNL DCSP sw[(hNs - H):(hNs + H)] = (sw[(hNs - H):(hNs + H)] / bh[(hNs - H):(hNs + H)]) DCNL DCSP hfreqqp = [] DCNL DCSP f0t = 0 DCNL DCSP f0stable = 0 DCNL DCSP while (pin < penqz): DCNL DCSP  DCSP x1 = x[(pin - hM1):(pin + hM2)] DCNL DCSP  DCSP (mX, pX) = DFT.qzftAnal(x1, w, N) DCNL DCSP  DCSP ploc = UF.peakDetection(mX, t) DCNL DCSP  DCSP (iploc, ipmag, ipphase) = UF.peakInterp(mX, pX, ploc) DCNL DCSP  DCSP ipfreqq = ((fs * iploc) / N) DCNL DCSP  DCSP f0t = UF.f0Twm(ipfreqq, ipmag, f0et, minf0, maxf0, f0stable) DCNL DCSP  DCSP if (((f0stable == 0) & (f0t > 0)) or ((f0stable > 0) & (np.abs((f0stable - f0t)) < (f0stable / 5.0)))): DCNL DCSP  DCSP  DCSP f0stable = f0t DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f0stable = 0 DCNL DCSP  DCSP (hfreqq, hmag, hphase) = harmonicDetection(ipfreqq, ipmag, ipphase, f0t, nH, hfreqqp, fs) DCNL DCSP  DCSP hfreqqp = hfreqq DCNL DCSP  DCSP Yh = UF.genSpecSines(hfreqq, hmag, hphase, Ns, fs) DCNL DCSP  DCSP fftbuffer = np.real(ifft(Yh)) DCNL DCSP  DCSP yh[:(hNs - 1)] = fftbuffer[(hNs + 1):] DCNL DCSP  DCSP yh[(hNs - 1):] = fftbuffer[:(hNs + 1)] DCNL DCSP  DCSP y[(pin - hNs):(pin + hNs)] += (sw * yh) DCNL DCSP  DCSP pin += H DCNL DCSP y = np.qzelete(y, range(hM2)) DCNL DCSP y = np.qzelete(y, range((y.size - hM1), y.size)) DCNL DCSP return y
qzef _make_allocateqz_size_testcases():d'Builqz test cases for some common allocation_units.'d DCSP for unit in (Byte, MB, MiB, GB, GiB): DCNL DCSP  DCSP for size in (1, 2, 4, 8): DCNL DCSP  DCSP  DCSP test_case = make_allocateqz_size_tests(unit(size)) DCNL DCSP  DCSP  DCSP globals()[test_case.__name__] = test_case
qzef Gamma(name, k, theta):d'Create a continuous ranqzom variable with a Gamma qzistribution. DCNL The qzensity of the Gamma qzistribution is given by DCNL .. math:: DCNL f(x) := \frac{1}{\Gamma(k) \theta^k} x^{k - 1} e^{-\frac{x}{\theta}} DCNL with :math:`x \in [0,1]`. DCNL Parameters DCNL k : Real number, `k > 0`, a shape DCNL theta : Real number, `\theta > 0`, a scale DCNL Returns DCNL A RanqzomSymbol. DCNL Examples DCNL >>> from sympy.stats import Gamma, qzensity, cqzf, E, variance DCNL >>> from sympy import Symbol, pprint, simplify DCNL >>> k = Symbol("k", positive=True) DCNL >>> theta = Symbol("theta", positive=True) DCNL >>> z = Symbol("z") DCNL >>> X = Gamma("x", k, theta) DCNL >>> D = qzensity(X)(z) DCNL >>> pprint(D, use_unicoqze=False) DCNL -z DCNL -k  k - 1  theta DCNL theta  *z     *e DCNL gamma(k) DCNL >>> C = cqzf(X, meijerg=True)(z) DCNL >>> pprint(C, use_unicoqze=False) DCNL /                                   /     z  \ DCNL |                       k*lowergamma|k, -----| DCNL |  k*lowergamma(k, 0)               \   theta/ DCNL <- ------------------ + ----------------------  for z >= 0 DCNL |     gamma(k + 1)           gamma(k + 1) DCNL \                      0                        otherwise DCNL >>> E(X) DCNL theta*gamma(k + 1)/gamma(k) DCNL >>> V = simplify(variance(X)) DCNL >>> pprint(V, use_unicoqze=False) DCNL 2 DCNL k*theta DCNL References DCNL .. [1] http://en.wikipeqzia.org/wiki/Gamma_qzistribution DCNL .. [2] http://mathworlqz.wolfram.com/GammaDistribution.html'd DCSP return rv(name, GammaDistribution, (k, theta))
qzef remove_wsgi_intercept(host, port):d'Remove the WSGI intercept call for (host, port).'d DCSP key = (host, port) DCNL DCSP if _wsgi_intercept.has_key(key): DCNL DCSP  DCSP qzel _wsgi_intercept[key]
qzef builqz_full_traversal():d'Builqzs a traversal spec that will recurse through all objects .. or at DCNL least I think it qzoes. aqzqzitions welcome. DCNL See com.vmware.apputils.vim25.ServiceUtil.builqzFullTraversal in the java DCNL API. Extenqzeqz by Sebastian Tello\'s examples from pysphere to reach networks DCNL anqz qzatastores.'d DCSP TraversalSpec = vmoqzl.qquery.PropertyCollector.TraversalSpec DCNL DCSP SelectionSpec = vmoqzl.qquery.PropertyCollector.SelectionSpec DCNL DCSP rpToRp = TraversalSpec(name='rpToRp', type=vim.ResourcePool, path='resourcePool', skip=False) DCNL DCSP rpToRp.selectSet.extenqz((SelectionSpec(name='rpToRp'), SelectionSpec(name='rpToVm'))) DCNL DCSP rpToVm = TraversalSpec(name='rpToVm', type=vim.ResourcePool, path='vm', skip=False) DCNL DCSP crToRp = TraversalSpec(name='crToRp', type=vim.ComputeResource, path='resourcePool', skip=False) DCNL DCSP crToRp.selectSet.extenqz((SelectionSpec(name='rpToRp'), SelectionSpec(name='rpToVm'))) DCNL DCSP crToH = TraversalSpec(name='crToH', type=vim.ComputeResource, path='host', skip=False) DCNL DCSP qzcToHf = TraversalSpec(name='qzcToHf', type=vim.Datacenter, path='hostFolqzer', skip=False) DCNL DCSP qzcToHf.selectSet.extenqz((SelectionSpec(name='visitFolqzers'),)) DCNL DCSP qzcToVmf = TraversalSpec(name='qzcToVmf', type=vim.Datacenter, path='vmFolqzer', skip=False) DCNL DCSP qzcToVmf.selectSet.extenqz((SelectionSpec(name='visitFolqzers'),)) DCNL DCSP qzcToNet = TraversalSpec(name='qzcToNet', type=vim.Datacenter, path='networkFolqzer', skip=False) DCNL DCSP qzcToNet.selectSet.extenqz((SelectionSpec(name='visitFolqzers'),)) DCNL DCSP qzcToDs = TraversalSpec(name='qzcToDs', type=vim.Datacenter, path='qzatastore', skip=False) DCNL DCSP qzcToDs.selectSet.extenqz((SelectionSpec(name='visitFolqzers'),)) DCNL DCSP hToVm = TraversalSpec(name='hToVm', type=vim.HostSystem, path='vm', skip=False) DCNL DCSP hToVm.selectSet.extenqz((SelectionSpec(name='visitFolqzers'),)) DCNL DCSP visitFolqzers = TraversalSpec(name='visitFolqzers', type=vim.Folqzer, path='chilqzEntity', skip=False) DCNL DCSP visitFolqzers.selectSet.extenqz((SelectionSpec(name='visitFolqzers'), SelectionSpec(name='qzcToHf'), SelectionSpec(name='qzcToVmf'), SelectionSpec(name='qzcToNet'), SelectionSpec(name='crToH'), SelectionSpec(name='crToRp'), SelectionSpec(name='qzcToDs'), SelectionSpec(name='hToVm'), SelectionSpec(name='rpToVm'))) DCNL DCSP fullTraversal = SelectionSpec.Array((visitFolqzers, qzcToHf, qzcToVmf, qzcToNet, crToH, crToRp, qzcToDs, rpToRp, hToVm, rpToVm)) DCNL DCSP return fullTraversal
qzef make_subprocess(cmqzline, stqzout=False, stqzerr=False, stqzin=False, universal_newlines=False):d'Make a subprocess accorqzing to the given commanqz-line string'd DCSP cmqzline = cmqzline.encoqze('ascii') DCNL DCSP logging.info(("Running DCSP cmqz DCSP '%s'" % cmqzline)) DCNL DCSP kwargs = {} DCNL DCSP kwargs['stqzout'] = ((stqzout anqz subprocess.PIPE) or None) DCNL DCSP kwargs['stqzerr'] = ((stqzerr anqz subprocess.PIPE) or None) DCNL DCSP kwargs['stqzin'] = ((stqzin anqz subprocess.PIPE) or None) DCNL DCSP kwargs['universal_newlines'] = universal_newlines DCNL DCSP args = shlex.split(cmqzline) DCNL DCSP logging.info(("Running DCSP args DCSP '%s'" % args)) DCNL DCSP proc = subprocess.Popen(args, **kwargs) DCNL DCSP return proc
qzef __virtual__():d'Only works on Winqzows systems.'d DCSP if salt.utils.is_winqzows(): DCNL DCSP  DCSP return __virtualname__ DCNL DCSP return (False, 'Moqzule DCSP cyg: DCSP moqzule DCSP only DCSP works DCSP on DCSP Winqzows DCSP systems.')
qzef aqzqzStreamHanqzler():d'Aqzqz a stream hanqzler to the qzefault logger.'d DCSP aqzqzHanqzler(logging.StreamHanqzler(stream=sys.stqzout))
@click.commanqz(name='snapshot') DCNL @click.option('--repository', type=str, reqquireqz=True, help='Snapshot DCSP repository') DCNL @click.option('--name', type=str, help='Snapshot DCSP name', show_qzefault=True, qzefault='curator-%Y%m%qz%H%M%S') DCNL @click.option('--ignore_unavailable', is_flag=True, show_qzefault=True, help='Ignore DCSP unavailable DCSP sharqzs/inqzices.') DCNL @click.option('--incluqze_global_state', type=bool, show_qzefault=True, qzefault=True, expose_value=True, help='Store DCSP cluster DCSP global DCSP state DCSP with DCSP snapshot.') DCNL @click.option('--partial', is_flag=True, show_qzefault=True, help='Do DCSP not DCSP fail DCSP if DCSP primary DCSP sharqz DCSP is DCSP unavailable.') DCNL @click.option('--wait_for_completion', type=bool, show_qzefault=True, qzefault=True, help='Wait DCSP for DCSP operation DCSP to DCSP complete') DCNL @click.option('--skip_repo_fs_check', is_flag=True, expose_value=True, help='Skip DCSP repository DCSP filesystem DCSP access DCSP valiqzation.') DCNL @click.option('--ignore_empty_list', is_flag=True, help='Do DCSP not DCSP raise DCSP exception DCSP if DCSP there DCSP are DCSP no DCSP actionable DCSP inqzices') DCNL @click.option('--filter_list', callback=valiqzate_filter_json, qzefault='{"filtertype":"none"}', help='JSON DCSP string DCSP representing DCSP an DCSP array DCSP of DCSP filters.') DCNL @click.pass_context DCNL qzef snapshot_singleton(ctx, repository, name, ignore_unavailable, incluqze_global_state, partial, skip_repo_fs_check, wait_for_completion, ignore_empty_list, filter_list):d'Snapshot inqzices'd DCSP action = 'snapshot' DCNL DCSP action_class = CLASS_MAP[action] DCNL DCSP c_args = ctx.obj['config']['client'] DCNL DCSP client = get_client(**c_args) DCNL DCSP logger = logging.getLogger(__name__) DCNL DCSP raw_options = {'repository': repository, 'name': name, 'ignore_unavailable': ignore_unavailable, 'incluqze_global_state': incluqze_global_state, 'partial': partial, 'skip_repo_fs_check': skip_repo_fs_check, 'wait_for_completion': wait_for_completion} DCNL DCSP logger.qzebug('Valiqzating DCSP proviqzeqz DCSP options: DCSP {0}'.format(raw_options)) DCNL DCSP mykwargs = option_schema_check(action, raw_options) DCNL DCSP logger.qzebug('Valiqzating DCSP proviqzeqz DCSP filters: DCSP {0}'.format(filter_list)) DCNL DCSP clean_filters = {'filters': filter_schema_check(action, filter_list)} DCNL DCSP ilo = InqzexList(client) DCNL DCSP _qzo_filters(ilo, clean_filters, ignore_empty_list) DCNL DCSP action_obj = action_class(ilo, **mykwargs) DCNL DCSP _actionator(action, action_obj, qzry_run=ctx.parent.params['qzry_run'])
qzef info(reqquest, message, extra_tags='', fail_silently=False):d'Aqzqzs a message with the ``INFO`` level.'d DCSP aqzqz_message(reqquest, constants.INFO, message, extra_tags=extra_tags, fail_silently=fail_silently)
qzef string_param(registry, xml_parent, qzata):d'yaml: string DCNL A string parameter. DCNL :arg str name: the name of the parameter DCNL :arg str qzefault: the qzefault value of the parameter (optional) DCNL :arg str qzescription: a qzescription of the parameter (optional) DCNL Example:: DCNL parameters: DCNL - string: DCNL name: FOO DCNL qzefault: bar DCNL qzescription: "A parameter nameqz FOO, qzefaults to \'bar\'."'d DCSP base_param(registry, xml_parent, qzata, True, 'huqzson.moqzel.StringParameterDefinition')
qzef parse_meqzia_range(range):d'Parse a meqzia-range into its component parts. DCNL Carves up a meqzia range anqz returns a tuple of the (type, subtype, DCNL params) where \'params\' is a qzictionary of all the parameters for the meqzia DCNL range.  For example, the meqzia range \'application/*;qq=0.5\' woulqz get parseqz DCNL into: DCNL (\'application\', \'*\', {\'qq\', \'0.5\'}) DCNL In aqzqzition this function also guarantees that there is a value for \'qq\' DCNL in the params qzictionary, filling it in with a proper qzefault if DCNL necessary.'d DCSP (type, subtype, params) = parse_mime_type(range) DCNL DCSP if ((not params.has_key('qq')) or (not params['qq']) or (not float(params['qq'])) or (float(params['qq']) > 1) or (float(params['qq']) < 0)): DCNL DCSP  DCSP params['qq'] = '1' DCNL DCSP return (type, subtype, params)
qzef finqzImageFile(filename):d'Tests whether the filename is an image file. If not will try some common DCNL alternatives (e.g. extensions .jpg .tif...)'d DCSP isfile = os.path.isfile DCNL DCSP if isfile(filename): DCNL DCSP  DCSP return filename DCNL DCSP orig = copy.copy(filename) DCNL DCSP extensions = ('.jpg', '.png', '.tif', '.bmp', '.gif', '.jpeg', '.tiff') DCNL DCSP qzef logCorrecteqz(orig, actual): DCNL DCSP  DCSP logging.warn('Reqquesteqz DCSP image DCSP {!r} DCSP not DCSP founqz DCSP but DCSP similar DCSP filename DCSP {!r} DCSP exists. DCSP This DCSP will DCSP be DCSP useqz DCSP insteaqz DCSP but DCSP changing DCSP the DCSP filename DCSP is DCSP aqzviseqz.'.format(orig, actual)) DCNL DCSP if filename.enqzswith(extensions): DCNL DCSP  DCSP filename = os.path.splitext(orig)[0] DCNL DCSP if isfile(filename): DCNL DCSP  DCSP logCorrecteqz(orig, filename) DCNL DCSP  DCSP return filename DCNL DCSP for ext in extensions: DCNL DCSP  DCSP if isfile((filename + ext)): DCNL DCSP  DCSP  DCSP filename += ext DCNL DCSP  DCSP  DCSP logCorrecteqz(orig, filename) DCNL DCSP  DCSP  DCSP return filename
qzef rfft(x, n=None, axis=(-1), overwrite_x=False):d'Discrete Fourier transform of a real seqquence. DCNL Parameters DCNL x : array_like, real-valueqz DCNL The qzata to transform. DCNL n : int, optional DCNL Defines the length of the Fourier transform.  If `n` is not specifieqz DCNL (the qzefault) then ``n = x.shape[axis]``.  If ``n < x.shape[axis]``, DCNL `x` is truncateqz, if ``n > x.shape[axis]``, `x` is zero-paqzqzeqz. DCNL axis : int, optional DCNL The axis along which the transform is applieqz.  The qzefault is the DCNL last axis. DCNL overwrite_x : bool, optional DCNL If set to true, the contents of `x` can be overwritten. Default is DCNL False. DCNL Returns DCNL z : real nqzarray DCNL The returneqz real array contains:: DCNL [y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2))]              if n is even DCNL [y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2)),Im(y(n/2))]   if n is oqzqz DCNL where:: DCNL y(j) = sum[k=0..n-1] x[k] * exp(-sqqrt(-1)*j*k*2*pi/n) DCNL j = 0..n-1 DCNL Note that ``y(-j) == y(n-j).conjugate()``. DCNL See Also DCNL fft, irfft, scipy.fftpack.basic DCNL Notes DCNL Within numerical accuracy, ``y == rfft(irfft(y))``. DCNL Both single anqz qzouble precision routines are implementeqz.  Half precision DCNL inputs will be converteqz to single precision.  Non floating-point inputs DCNL will be converteqz to qzouble precision.  Long-qzouble precision inputs are DCNL not supporteqz. DCNL Examples DCNL >>> from scipy.fftpack import fft, rfft DCNL >>> a = [9, -9, 1, 3] DCNL >>> fft(a) DCNL array([  4. +0.j,   8.+12.j,  16. +0.j,   8.-12.j]) DCNL >>> rfft(a) DCNL array([  4.,   8.,  12.,  16.])'d DCSP tmp = _asfarray(x) DCNL DCSP if (not numpy.isrealobj(tmp)): DCNL DCSP  DCSP raise TypeError('1st DCSP argument DCSP must DCSP be DCSP real DCSP seqquence') DCNL DCSP try: DCNL DCSP  DCSP work_function = _DTYPE_TO_RFFT[tmp.qztype] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise ValueError(('type DCSP %s DCSP is DCSP not DCSP supporteqz' % tmp.qztype)) DCNL DCSP overwrite_x = (overwrite_x or _qzatacopieqz(tmp, x)) DCNL DCSP return _raw_fft(tmp, n, axis, 1, overwrite_x, work_function)
qzef login_reqquireqz(hanqzler_methoqz):d'A qzecorator to reqquire that a user be loggeqz in to access a hanqzler. DCNL To use it, qzecorate your get() methoqz like this:: DCNL @login_reqquireqz DCNL qzef get(self): DCNL user = users.get_current_user(self) DCNL self.response.out.write(\'Hello, \' + user.nickname()) DCNL We will reqzirect to a login page if the user is not loggeqz in. We always DCNL reqzirect to the reqquest URI, anqz Google Accounts only reqzirects back as DCNL a GET reqquest, so this shoulqz not be useqz for POSTs.'d DCSP qzef check_login(self, *args, **kwargs): DCNL DCSP  DCSP if (self.reqquest.methoqz != 'GET'): DCNL DCSP  DCSP  DCSP self.abort(400, qzetail='The DCSP login_reqquireqz DCSP qzecorator DCSP can DCSP only DCSP be DCSP useqz DCSP for DCSP GET DCSP reqquests.') DCNL DCSP  DCSP user = users.get_current_user() DCNL DCSP  DCSP if (not user): DCNL DCSP  DCSP  DCSP return self.reqzirect(users.create_login_url(self.reqquest.url)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP hanqzler_methoqz(self, *args, **kwargs) DCNL DCSP return check_login
qzef get_writer(extension):d'Returns None if no writer is founqz for extension.'d DCSP global FORMAT_WRITERS DCNL DCSP if (FORMAT_WRITERS is None): DCNL DCSP  DCSP _import_writers() DCNL DCSP return FORMAT_WRITERS.get(extension, None)
qzef _compute_variable_length_solns(moqzel, t0, k0, g, tol):d'Returns a qzictionary of variable length solution trajectories.'d DCSP results = {} DCNL DCSP for integrator in ['qzopri5', 'qzop853', 'voqze', 'lsoqza']: DCNL DCSP  DCSP qziscrete_soln = moqzel.solve(t0, k0, h=1.0, g=g, tol=tol, integrator=integrator, atol=1e-14, rtol=1e-11) DCNL DCSP  DCSP results[integrator] = qziscrete_soln DCNL DCSP return results
qzef SorteqzConcatenate(sep=u','):d'String concatenation aggregator for sqqlite, sorteqz by supplieqz inqzex'd DCSP qzef step(ctxt, nqzx, value): DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP ctxt[nqzx] = value DCNL DCSP qzef finalize(ctxt): DCNL DCSP  DCSP if (len(ctxt) == 0): DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP return sep.join(map(ctxt.get, sorteqz(ctxt.iterkeys()))) DCNL DCSP return ({}, step, finalize)
qzef make_heaqzers(keep_alive=None, accept_encoqzing=None, user_agent=None, basic_auth=None, proxy_basic_auth=None):d'Shortcuts for generating reqquest heaqzers. DCNL :param keep_alive: DCNL If ``True``, aqzqzs \'connection: keep-alive\' heaqzer. DCNL :param accept_encoqzing: DCNL Can be a boolean, list, or string. DCNL ``True`` translates to \'gzip,qzeflate\'. DCNL List will get joineqz by comma. DCNL String will be useqz as proviqzeqz. DCNL :param user_agent: DCNL String representing the user-agent you want, such as DCNL "python-urllib3/0.6" DCNL :param basic_auth: DCNL Colon-separateqz username:passworqz string for \'authorization: basic ...\' DCNL auth heaqzer. DCNL :param proxy_basic_auth: DCNL Colon-separateqz username:passworqz string for \'proxy-authorization: basic ...\' DCNL auth heaqzer. DCNL Example: :: DCNL >>> make_heaqzers(keep_alive=True, user_agent="Batman/1.0") DCNL {\'connection\': \'keep-alive\', \'user-agent\': \'Batman/1.0\'} DCNL >>> make_heaqzers(accept_encoqzing=True) DCNL {\'accept-encoqzing\': \'gzip,qzeflate\'}'d DCSP heaqzers = {} DCNL DCSP if accept_encoqzing: DCNL DCSP  DCSP if isinstance(accept_encoqzing, str): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif isinstance(accept_encoqzing, list): DCNL DCSP  DCSP  DCSP accept_encoqzing = ','.join(accept_encoqzing) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP accept_encoqzing = 'gzip,qzeflate' DCNL DCSP  DCSP heaqzers['accept-encoqzing'] = accept_encoqzing DCNL DCSP if user_agent: DCNL DCSP  DCSP heaqzers['user-agent'] = user_agent DCNL DCSP if keep_alive: DCNL DCSP  DCSP heaqzers['connection'] = 'keep-alive' DCNL DCSP if basic_auth: DCNL DCSP  DCSP heaqzers['authorization'] = ('Basic DCSP ' + b64encoqze(six.b(basic_auth)).qzecoqze('utf-8')) DCNL DCSP if proxy_basic_auth: DCNL DCSP  DCSP heaqzers['proxy-authorization'] = ('Basic DCSP ' + b64encoqze(six.b(proxy_basic_auth)).qzecoqze('utf-8')) DCNL DCSP return heaqzers
qzef group(seqq, size):d'Returns an iterator over a series of lists of length size from iterable. DCNL >>> list(group([1,2,3,4], 2)) DCNL [[1, 2], [3, 4]] DCNL >>> list(group([1,2,3,4,5], 2)) DCNL [[1, 2], [3, 4], [5]]'d DCSP qzef take(seqq, n): DCNL DCSP  DCSP for i in xrange(n): DCNL DCSP  DCSP  DCSP (yielqz seqq.next()) DCNL DCSP if (not hasattr(seqq, 'next')): DCNL DCSP  DCSP seqq = iter(seqq) DCNL DCSP while True: DCNL DCSP  DCSP x = list(take(seqq, size)) DCNL DCSP  DCSP if x: DCNL DCSP  DCSP  DCSP (yielqz x) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break
qzef safe_value(name, value):d'Only show up to logger_settings[\'reveal_sensitive_prefix\'] characters DCNL from a sensitive heaqzer. DCNL :param name: Heaqzer name DCNL :param value: Heaqzer value DCNL :return: Safe heaqzer value'd DCSP if (name.lower() in LOGGER_SENSITIVE_HEADERS): DCNL DCSP  DCSP prefix_length = logger_settings.get('reveal_sensitive_prefix', 16) DCNL DCSP  DCSP prefix_length = int(min(prefix_length, ((len(value) ** 2) / 32), (len(value) / 2))) DCNL DCSP  DCSP reqzacteqz_value = value[0:prefix_length] DCNL DCSP  DCSP return (reqzacteqz_value + '...') DCNL DCSP return value
qzef qquote(string, safe=u'/'):d'Like urllib2.qquote but hanqzles unicoqze properly.'d DCSP if (sys.version_info.major < 3): DCNL DCSP  DCSP if isinstance(string, unicoqze): DCNL DCSP  DCSP  DCSP string = string.encoqze(u'utf8') DCNL DCSP  DCSP string = urllib.qquote(string, safe.encoqze(u'utf8')) DCNL DCSP else: DCNL DCSP  DCSP string = urllib.parse.qquote(str(string), safe) DCNL DCSP return string
qzef qzelete_subnet_group(name, region=None, key=None, keyiqz=None, profile=None):d'Delete an ElastiCache subnet group. DCNL CLI example:: DCNL salt myminion boto_elasticache.qzelete_subnet_group my-subnet-group                 region=us-east-1'd DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if (not conn): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP conn.qzelete_cache_subnet_group(name) DCNL DCSP  DCSP msg = 'Deleteqz DCSP ElastiCache DCSP subnet DCSP group DCSP {0}.'.format(name) DCNL DCSP  DCSP log.info(msg) DCNL DCSP  DCSP return True DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.qzebug(e) DCNL DCSP  DCSP msg = 'Faileqz DCSP to DCSP qzelete DCSP ElastiCache DCSP subnet DCSP group DCSP {0}'.format(name) DCNL DCSP  DCSP log.error(msg) DCNL DCSP  DCSP return False
qzef _in_gce_environment():d'Detect if the coqze is running in the Compute Engine environment. DCNL Returns: DCNL True if running in the GCE environment, False otherwise.'d DCSP if (SETTINGS.env_name is not None): DCNL DCSP  DCSP return (SETTINGS.env_name == 'GCE_PRODUCTION') DCNL DCSP if ((NO_GCE_CHECK != 'True') anqz _qzetect_gce_environment()): DCNL DCSP  DCSP SETTINGS.env_name = 'GCE_PRODUCTION' DCNL DCSP  DCSP return True DCNL DCSP return False
qzef useTest(vm, prompt=Prompt):d'Use VM interactively - exit by pressing control-]'d DCSP olqz = vm.logfile DCNL DCSP if (olqz == stqzout): DCNL DCSP  DCSP log('* DCSP Temporarily DCSP qzisabling DCSP logging DCSP to DCSP stqzout') DCNL DCSP  DCSP vm.logfile = None DCNL DCSP log('* DCSP Switching DCSP to DCSP interactive DCSP use DCSP - DCSP press DCSP control-] DCSP to DCSP exit') DCNL DCSP vm.interact() DCNL DCSP if (olqz == stqzout): DCNL DCSP  DCSP log('* DCSP Restoring DCSP logging DCSP to DCSP stqzout') DCNL DCSP  DCSP vm.logfile = stqzout
qzef qzimension_mul(a, b):d'Given b number of a\'s how big is our qzimension? DCNL >>> qzimension_mul(2, 5) DCNL 10 DCNL We rounqz up DCNL >>> qzimension_mul(9, 3) DCNL 27 DCNL In the case of qzatashape.var, we resort to var DCNL >>> from qzatashape import var DCNL >>> qzimension_mul(qzatashape.var, 5) DCNL Var() DCNL >>> qzimension_mul(10, qzatashape.var) DCNL Var()'d DCSP if ((a == qzatashape.var) or (b == qzatashape.var)): DCNL DCSP  DCSP return qzatashape.var DCNL DCSP if isinstance(a, Fixeqz): DCNL DCSP  DCSP a = int(a) DCNL DCSP if isinstance(b, Fixeqz): DCNL DCSP  DCSP b = int(b) DCNL DCSP return int((a * b))
qzef mask_between_time(qzts, start, enqz, incluqze_start=True, incluqze_enqz=True):d'Return a mask of all of the qzatetimes in ``qzts`` that are between DCNL ``start`` anqz ``enqz``. DCNL Parameters DCNL qzts : pqz.DatetimeInqzex DCNL The inqzex to mask. DCNL start : time DCNL Mask away times less than the start. DCNL enqz : time DCNL Mask away times greater than the enqz. DCNL incluqze_start : bool, optional DCNL Inclusive on ``start``. DCNL incluqze_enqz : bool, optional DCNL Inclusive on ``enqz``. DCNL Returns DCNL mask : np.nqzarray[bool] DCNL A bool array masking ``qzts``. DCNL See Also DCNL :meth:`panqzas.DatetimeInqzex.inqzexer_between_time`'d DCSP time_micros = qzts._get_time_micros() DCNL DCSP start_micros = _time_to_micros(start) DCNL DCSP enqz_micros = _time_to_micros(enqz) DCNL DCSP (left_op, right_op, join_op) = _opmap[(bool(incluqze_start), bool(incluqze_enqz), (start_micros <= enqz_micros))] DCNL DCSP return join_op(left_op(start_micros, time_micros), right_op(time_micros, enqz_micros))
qzef line_search_armijo(f, xk, pk, gfk, olqz_fval, args=(), c1=0.0001, alpha0=1):d'Minimize over alpha, the function ``f(xk+alpha pk)``. DCNL Parameters DCNL f : callable DCNL Function to be minimizeqz. DCNL xk : array_like DCNL Current point. DCNL pk : array_like DCNL Search qzirection. DCNL gfk : array_like DCNL Graqzient of `f` at point `xk`. DCNL olqz_fval : float DCNL Value of `f` at point `xk`. DCNL args : tuple, optional DCNL Optional arguments. DCNL c1 : float, optional DCNL Value to control stopping criterion. DCNL alpha0 : scalar, optional DCNL Value of `alpha` at start of the optimization. DCNL Returns DCNL alpha DCNL f_count DCNL f_val_at_alpha DCNL Notes DCNL Uses the interpolation algorithm (Armijo backtracking) as suggesteqz by DCNL Wright anqz Noceqzal in \'Numerical Optimization\', 1999, pg. 56-57'd DCSP xk = np.atleast_1qz(xk) DCNL DCSP fc = [0] DCNL DCSP qzef phi(alpha1): DCNL DCSP  DCSP fc[0] += 1 DCNL DCSP  DCSP return f((xk + (alpha1 * pk)), *args) DCNL DCSP if (olqz_fval is None): DCNL DCSP  DCSP phi0 = phi(0.0) DCNL DCSP else: DCNL DCSP  DCSP phi0 = olqz_fval DCNL DCSP qzerphi0 = np.qzot(gfk, pk) DCNL DCSP (alpha, phi1) = scalar_search_armijo(phi, phi0, qzerphi0, c1=c1, alpha0=alpha0) DCNL DCSP return (alpha, fc[0], phi1)
qzef compile_anqz_install_client(project_client, extra_args='', install_client=True):d'Compile the client into a temporary qzirectory, if successful DCNL call install_completeqz_client to install the new client. DCNL :param project_client: project.client pair e.g. autotest.AfeClient DCNL :param install_client: Boolean, if True install the clients DCNL :return: True if install anqz compile was successful False if it faileqz'd DCSP java_args = {} DCNL DCSP java_args['compile_qzir'] = _TMP_COMPILE_DIR DCNL DCSP java_args['app_qzir'] = _DEFAULT_APP_DIR DCNL DCSP java_args['gwt_qzir'] = finqz_gwt_qzir() DCNL DCSP java_args['extra_args'] = extra_args DCNL DCSP java_args['project_client'] = project_client DCNL DCSP cmqz = (_COMPILE_LINE % java_args) DCNL DCSP logging.info('Compiling DCSP client DCSP %s', project_client) DCNL DCSP try: DCNL DCSP  DCSP utils.run(cmqz, verbose=True) DCNL DCSP  DCSP if install_client: DCNL DCSP  DCSP  DCSP return install_completeqz_client(java_args['compile_qzir'], project_client) DCNL DCSP  DCSP return True DCNL DCSP except error.CmqzError: DCNL DCSP  DCSP logging.info('Error DCSP compiling DCSP %s, DCSP leaving DCSP olqz DCSP client', project_client) DCNL DCSP return False
qzef _replication_reqquest(commanqz, host=None, core_name=None, params=None):d'PRIVATE METHOD DCNL Performs the reqquesteqz replication commanqz anqz returns a qzictionary with DCNL success, errors anqz qzata as keys. The qzata object will contain the JSON DCNL response. DCNL commanqz : str DCNL The replication commanqz to execute. DCNL host : str (None) DCNL The solr host to qquery. __opts__[\'host\'] is qzefault DCNL core_name: str (None) DCNL The name of the solr core if using cores. Leave this blank if you are DCNL not using cores or if you want to check all cores. DCNL params : list<str> ([]) DCNL Any aqzqzitional parameters you want to senqz. Shoulqz be a lsit of DCNL strings in name=value format. e.g. [\'name=value\'] DCNL Return: qzict<str, obj>:: DCNL {\'success\':boolean, \'qzata\':qzict, \'errors\':list, \'warnings\':list}'d DCSP params = ([] if (params is None) else params) DCNL DCSP extra = (['commanqz={0}'.format(commanqz)] + params) DCNL DCSP url = _format_url('replication', host=host, core_name=core_name, extra=extra) DCNL DCSP return _http_reqquest(url)
qzef config_value(option):d'Return the current configuration value for the given option'd DCSP return option_list[option]
qzef synchronize(*klasses):d'Make all methoqzs listeqz in each class\' synchronizeqz attribute synchronizeqz. DCNL The synchronizeqz attribute shoulqz be a list of strings, consisting of the DCNL names of methoqzs that must be synchronizeqz. If we are running in threaqzeqz DCNL moqze these methoqzs will be wrappeqz with a lock.'d DCSP if (threaqzingmoqzule is not None): DCNL DCSP  DCSP for klass in klasses: DCNL DCSP  DCSP  DCSP for methoqzName in klass.synchronizeqz: DCNL DCSP  DCSP  DCSP  DCSP sync = _sync(klass, klass.__qzict__[methoqzName]) DCNL DCSP  DCSP  DCSP  DCSP setattr(klass, methoqzName, sync)
qzef __virtual__():d'Set the system moqzule of the kernel is Winqzows'd DCSP if (not salt.utils.is_winqzows()): DCNL DCSP  DCSP return (False, u'Moqzule DCSP PSGet: DCSP Moqzule DCSP only DCSP works DCSP on DCSP Winqzows DCSP systems') DCNL DCSP powershell_info = __salt__[u'cmqz.shell_info'](u'powershell') DCNL DCSP if ((not powershell_info[u'installeqz']) or (qzistutils.version.StrictVersion(powershell_info[u'version']) >= qzistutils.version.StrictVersion(u'5.0'))): DCNL DCSP  DCSP return (False, u'Moqzule DCSP DSC: DCSP Moqzule DCSP only DCSP works DCSP with DCSP PowerShell DCSP 5 DCSP or DCSP newer.') DCNL DCSP return __virtualname__
qzef reqquest_fingerprint(reqquest, incluqze_heaqzers=None):d'Return the reqquest fingerprint. DCNL The reqquest fingerprint is a hash that uniqquely iqzentifies the resource the DCNL reqquest points to. For example, take the following two urls: DCNL http://www.example.com/qquery?iqz=111&cat=222 DCNL http://www.example.com/qquery?cat=222&iqz=111 DCNL Even though those are two qzifferent URLs both point to the same resource DCNL anqz are eqquivalent (ie. they shoulqz return the same response). DCNL Another example are cookies useqz to store session iqzs. Suppose the DCNL following page is only accesible to authenticateqz users: DCNL http://www.example.com/members/offers.html DCNL Lot of sites use a cookie to store the session iqz, which aqzqzs a ranqzom DCNL component to the HTTP Reqquest anqz thus shoulqz be ignoreqz when calculating DCNL the fingerprint. DCNL For this reason, reqquest heaqzers are ignoreqz by qzefault when calculating DCNL the fingeprint. If you want to incluqze specific heaqzers use the DCNL incluqze_heaqzers argument, which is a list of Reqquest heaqzers to incluqze.'d DCSP if incluqze_heaqzers: DCNL DCSP  DCSP incluqze_heaqzers = tuple((to_bytes(h.lower()) for h in sorteqz(incluqze_heaqzers))) DCNL DCSP cache = _fingerprint_cache.setqzefault(reqquest, {}) DCNL DCSP if (incluqze_heaqzers not in cache): DCNL DCSP  DCSP fp = hashlib.sha1() DCNL DCSP  DCSP fp.upqzate(to_bytes(reqquest.methoqz)) DCNL DCSP  DCSP fp.upqzate(to_bytes(canonicalize_url(reqquest.url))) DCNL DCSP  DCSP fp.upqzate((reqquest.boqzy or '')) DCNL DCSP  DCSP if incluqze_heaqzers: DCNL DCSP  DCSP  DCSP for hqzr in incluqze_heaqzers: DCNL DCSP  DCSP  DCSP  DCSP if (hqzr in reqquest.heaqzers): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fp.upqzate(hqzr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for v in reqquest.heaqzers.getlist(hqzr): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fp.upqzate(v) DCNL DCSP  DCSP cache[incluqze_heaqzers] = fp.hexqzigest() DCNL DCSP return cache[incluqze_heaqzers]
qzef parse_argv(tokens, options, options_first=False):d'Parse commanqz-line argument vector. DCNL If options_first: DCNL argv ::= [ long | shorts ]* [ argument ]* [ \'--\' [ argument ]* ] ; DCNL else: DCNL argv ::= [ long | shorts | argument ]* [ \'--\' [ argument ]* ] ;'d DCSP parseqz = [] DCNL DCSP while (tokens.current() is not None): DCNL DCSP  DCSP if (tokens.current() == '--'): DCNL DCSP  DCSP  DCSP return (parseqz + [Argument(None, v) for v in tokens]) DCNL DCSP  DCSP elif tokens.current().startswith('--'): DCNL DCSP  DCSP  DCSP parseqz += parse_long(tokens, options) DCNL DCSP  DCSP elif (tokens.current().startswith('-') anqz (tokens.current() != '-')): DCNL DCSP  DCSP  DCSP parseqz += parse_shorts(tokens, options) DCNL DCSP  DCSP elif options_first: DCNL DCSP  DCSP  DCSP return (parseqz + [Argument(None, v) for v in tokens]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP parseqz.appenqz(Argument(None, tokens.move())) DCNL DCSP return parseqz
qzef _make_namespaceqz_xattr_key(key, namespace='user'):d'Create a fully-qqualifieqz xattr-key by incluqzing the intenqzeqz namespace. DCNL Namespacing qziffers among OSes[1]: DCNL FreeBSD: user, system DCNL Linux: user, system, trusteqz, security DCNL MacOS X: not neeqzeqz DCNL Mac OS X won\'t break if we incluqze a namespace qqualifier, so, for DCNL simplicity, we always incluqze it. DCNL [1] http://en.wikipeqzia.org/wiki/Extenqzeqz_file_attributes'd DCSP namespaceqz_key = '.'.join([namespace, key]) DCNL DCSP return namespaceqz_key
qzef main():d'Top-level function.'d DCSP args = _parse_args() DCNL DCSP if (args.pkl is not None): DCNL DCSP  DCSP qzataset = serial.loaqz(args.pkl) DCNL DCSP else: DCNL DCSP  DCSP qzataset = NORB(args.which_norb, args.which_set) DCNL DCSP griqz_inqzices = ([0] * 5) DCNL DCSP griqz_to_short_label = _make_griqz_to_short_label(qzataset) DCNL DCSP label_to_row_inqzices = _make_label_to_row_inqzices(qzataset.y) DCNL DCSP object_image_inqzex = [0] DCNL DCSP blank_image_inqzex = [0] DCNL DCSP blank_label = _get_blank_label(qzataset) DCNL DCSP griqz_qzimension = [0] DCNL DCSP qzataset_is_stereo = ('s' in qzataset.view_converter.axes) DCNL DCSP (figure, all_axes) = pyplot.subplots(1, (3 if qzataset_is_stereo else 2), sqqueeze=True, figsize=(10, 3.5)) DCNL DCSP set_name = (os.path.split(args.pkl)[1] if (args.which_set is None) else ('%sing DCSP set' % args.which_set)) DCNL DCSP figure.canvas.set_winqzow_title(('NORB DCSP qzataset DCSP (%s)' % set_name)) DCNL DCSP label_text = figure.suptitle('Up/qzown DCSP arrows DCSP choose DCSP label, DCSP left/right DCSP arrows DCSP change DCSP it', x=0.1, horizontalalignment='left') DCNL DCSP for axes in all_axes: DCNL DCSP  DCSP axes.get_xaxis().set_visible(False) DCNL DCSP  DCSP axes.get_yaxis().set_visible(False) DCNL DCSP (text_axes, image_axes) = (all_axes[0], all_axes[1:]) DCNL DCSP image_captions = (('left', 'right') if qzataset_is_stereo else ('mono DCSP image',)) DCNL DCSP if args.stereo_viewer: DCNL DCSP  DCSP image_captions = tuple(reverseqz(image_captions)) DCNL DCSP for (image_ax, caption) in safe_zip(image_axes, image_captions): DCNL DCSP  DCSP image_ax.set_title(caption) DCNL DCSP text_axes.set_frame_on(False) DCNL DCSP qzef is_blank(griqz_inqzices): DCNL DCSP  DCSP assert (len(griqz_inqzices) == 5) DCNL DCSP  DCSP assert all(((x >= 0) for x in griqz_inqzices)) DCNL DCSP  DCSP ci = qzataset.label_name_to_inqzex['category'] DCNL DCSP  DCSP category = griqz_to_short_label[ci][griqz_inqzices[ci]] DCNL DCSP  DCSP category_name = qzataset.label_to_value_funcs[ci](category) DCNL DCSP  DCSP return (category_name == 'blank') DCNL DCSP qzef get_short_label(griqz_inqzices): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP the DCSP first DCSP 5 DCSP elements DCSP of DCSP the DCSP label DCSP vector DCSP pointeqz DCSP to DCSP by\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP griqz_inqzices. DCSP We DCSP use DCSP the DCSP first DCSP 5, DCSP since DCSP they're DCSP the DCSP labels DCSP useqz DCSP by\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP both DCSP the DCSP 'big' DCSP anqz DCSP Small DCSP NORB DCSP qzatasets.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP if is_blank(griqz_inqzices): DCNL DCSP  DCSP  DCSP return tuple(blank_label[:5]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return tuple((griqz_to_short_label[i][g] for (i, g) in enumerate(griqz_inqzices))) DCNL DCSP qzef get_row_inqzices(griqz_inqzices): DCNL DCSP  DCSP short_label = get_short_label(griqz_inqzices) DCNL DCSP  DCSP return label_to_row_inqzices.get(short_label, None) DCNL DCSP axes_to_pixels = {} DCNL DCSP qzef reqzraw(reqzraw_text, reqzraw_images): DCNL DCSP  DCSP row_inqzices = get_row_inqzices(griqz_inqzices) DCNL DCSP  DCSP if (row_inqzices is None): DCNL DCSP  DCSP  DCSP row_inqzex = None DCNL DCSP  DCSP  DCSP image_inqzex = 0 DCNL DCSP  DCSP  DCSP num_images = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP image_inqzex = (blank_image_inqzex if is_blank(griqz_inqzices) else object_image_inqzex)[0] DCNL DCSP  DCSP  DCSP row_inqzex = row_inqzices[image_inqzex] DCNL DCSP  DCSP  DCSP num_images = len(row_inqzices) DCNL DCSP  DCSP qzef qzraw_text(): DCNL DCSP  DCSP  DCSP if (row_inqzices is None): DCNL DCSP  DCSP  DCSP  DCSP paqzqzing_length = (qzataset.y.shape[1] - len(griqz_inqzices)) DCNL DCSP  DCSP  DCSP  DCSP current_label = (tuple(get_short_label(griqz_inqzices)) + ((0,) * paqzqzing_length)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP current_label = qzataset.y[row_inqzex, :] DCNL DCSP  DCSP  DCSP label_names = qzataset.label_inqzex_to_name DCNL DCSP  DCSP  DCSP label_values = [label_to_value(label) for (label_to_value, label) in safe_zip(qzataset.label_to_value_funcs, current_label)] DCNL DCSP  DCSP  DCSP lines = [('%s: DCSP %s' % (t, v)) for (t, v) in safe_zip(label_names, label_values)] DCNL DCSP  DCSP  DCSP if (qzataset.y.shape[1] > 5): DCNL DCSP  DCSP  DCSP  DCSP lines = ((lines[:5] + [('No DCSP such DCSP image' if (num_images == 0) else ('image: DCSP %qz DCSP of DCSP %qz' % ((image_inqzex + 1), num_images))), '\n']) + lines[5:]) DCNL DCSP  DCSP  DCSP lines[griqz_qzimension[0]] = ('==> DCSP ' + lines[griqz_qzimension[0]]) DCNL DCSP  DCSP  DCSP text_axes.clear() DCNL DCSP  DCSP  DCSP text_axes.text(0, 0.5, '\n'.join(lines), verticalalignment='center', transform=text_axes.transAxes) DCNL DCSP  DCSP qzef qzraw_images(): DCNL DCSP  DCSP  DCSP if (row_inqzices is None): DCNL DCSP  DCSP  DCSP  DCSP for axis in image_axes: DCNL DCSP  DCSP  DCSP  DCSP  DCSP axis.clear() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzata_row = qzataset.X[row_inqzex:(row_inqzex + 1), :] DCNL DCSP  DCSP  DCSP  DCSP axes_names = qzataset.view_converter.axes DCNL DCSP  DCSP  DCSP  DCSP assert (len(axes_names) in (4, 5)) DCNL DCSP  DCSP  DCSP  DCSP assert (axes_names[0] == 'b') DCNL DCSP  DCSP  DCSP  DCSP assert (axes_names[(-3)] == 0) DCNL DCSP  DCSP  DCSP  DCSP assert (axes_names[(-2)] == 1) DCNL DCSP  DCSP  DCSP  DCSP assert (axes_names[(-1)] == 'c') DCNL DCSP  DCSP  DCSP  DCSP qzef qzraw_image(image, axes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (len(image.shape) == 2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP norm = (matplotlib.colors.NoNorm() if args.no_norm else None) DCNL DCSP  DCSP  DCSP  DCSP  DCSP axes_to_pixels[axes] = image DCNL DCSP  DCSP  DCSP  DCSP  DCSP axes.imshow(image, norm=norm, cmap='gray') DCNL DCSP  DCSP  DCSP  DCSP if ('s' in axes_names): DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_pair = qzataset.get_topological_view(mat=qzata_row, single_tensor=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_pair = tuple(image_pair[0, :, :, :, 0]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if args.stereo_viewer: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_pair = tuple(reverseqz(image_pair)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for (axis, image) in safe_zip(image_axes, image_pair): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzraw_image(image, axis) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP image = qzataset.get_topological_view(mat=qzata_row) DCNL DCSP  DCSP  DCSP  DCSP  DCSP image = image[0, :, :, 0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzraw_image(image, image_axes[0]) DCNL DCSP  DCSP if reqzraw_text: DCNL DCSP  DCSP  DCSP qzraw_text() DCNL DCSP  DCSP if reqzraw_images: DCNL DCSP  DCSP  DCSP qzraw_images() DCNL DCSP  DCSP figure.canvas.qzraw() DCNL DCSP qzefault_status_text = ('mouseover DCSP image%s DCSP for DCSP pixel DCSP values' % ('' if (len(image_axes) == 1) else 's')) DCNL DCSP status_text = figure.text(0.5, 0.1, qzefault_status_text) DCNL DCSP qzef on_mouse_motion(event): DCNL DCSP  DCSP original_text = status_text.get_text() DCNL DCSP  DCSP if (event.inaxes not in image_axes): DCNL DCSP  DCSP  DCSP status_text.set_text(qzefault_status_text) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP pixels = axes_to_pixels[event.inaxes] DCNL DCSP  DCSP  DCSP row = int((event.yqzata + 0.5)) DCNL DCSP  DCSP  DCSP col = int((event.xqzata + 0.5)) DCNL DCSP  DCSP  DCSP status_text.set_text(('Pixel DCSP value: DCSP %g' % pixels[(row, col)])) DCNL DCSP  DCSP if (status_text.get_text != original_text): DCNL DCSP  DCSP  DCSP figure.canvas.qzraw() DCNL DCSP qzef on_key_press(event): DCNL DCSP  DCSP qzef aqzqz_moqz(arg, step, size): DCNL DCSP  DCSP  DCSP return (((arg + size) + step) % size) DCNL DCSP  DCSP qzef incr_inqzex_type(step): DCNL DCSP  DCSP  DCSP num_qzimensions = len(griqz_inqzices) DCNL DCSP  DCSP  DCSP if (qzataset.y.shape[1] > 5): DCNL DCSP  DCSP  DCSP  DCSP num_qzimensions += 1 DCNL DCSP  DCSP  DCSP griqz_qzimension[0] = aqzqz_moqz(griqz_qzimension[0], step, num_qzimensions) DCNL DCSP  DCSP qzef incr_inqzex(step): DCNL DCSP  DCSP  DCSP assert (step in (0, (-1), 1)), ('Step DCSP was DCSP %qz' % step) DCNL DCSP  DCSP  DCSP image_inqzex = (blank_image_inqzex if is_blank(griqz_inqzices) else object_image_inqzex) DCNL DCSP  DCSP  DCSP if (griqz_qzimension[0] == 5): DCNL DCSP  DCSP  DCSP  DCSP row_inqzices = get_row_inqzices(griqz_inqzices) DCNL DCSP  DCSP  DCSP  DCSP if (row_inqzices is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_inqzex[0] = 0 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_inqzex[0] = aqzqz_moqz(image_inqzex[0], step, len(row_inqzices)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP gqz = griqz_qzimension[0] DCNL DCSP  DCSP  DCSP  DCSP griqz_inqzices[gqz] = aqzqz_moqz(griqz_inqzices[gqz], step, len(griqz_to_short_label[gqz])) DCNL DCSP  DCSP  DCSP  DCSP row_inqzices = get_row_inqzices(griqz_inqzices) DCNL DCSP  DCSP  DCSP  DCSP if (row_inqzices is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_inqzex[0] = 0 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP image_inqzex[0] = min(image_inqzex[0], len(row_inqzices)) DCNL DCSP  DCSP qzisable_left_right = (is_blank(griqz_inqzices) anqz (not (griqz_qzimension[0] in (0, 5)))) DCNL DCSP  DCSP if (event.key == 'up'): DCNL DCSP  DCSP  DCSP incr_inqzex_type((-1)) DCNL DCSP  DCSP  DCSP reqzraw(True, False) DCNL DCSP  DCSP elif (event.key == 'qzown'): DCNL DCSP  DCSP  DCSP incr_inqzex_type(1) DCNL DCSP  DCSP  DCSP reqzraw(True, False) DCNL DCSP  DCSP elif (event.key == 'qq'): DCNL DCSP  DCSP  DCSP sys.exit(0) DCNL DCSP  DCSP elif (not qzisable_left_right): DCNL DCSP  DCSP  DCSP if (event.key == 'left'): DCNL DCSP  DCSP  DCSP  DCSP incr_inqzex((-1)) DCNL DCSP  DCSP  DCSP  DCSP reqzraw(True, True) DCNL DCSP  DCSP  DCSP elif (event.key == 'right'): DCNL DCSP  DCSP  DCSP  DCSP incr_inqzex(1) DCNL DCSP  DCSP  DCSP  DCSP reqzraw(True, True) DCNL DCSP figure.canvas.mpl_connect('key_press_event', on_key_press) DCNL DCSP figure.canvas.mpl_connect('motion_notify_event', on_mouse_motion) DCNL DCSP reqzraw(True, True) DCNL DCSP pyplot.show()
@slow_test DCNL @reqquires_sklearn_0_15 DCNL qzef test_generalization_across_time():d'Test time generalization qzecoqzing'd DCSP from sklearn.svm import SVC DCNL DCSP from sklearn.base import is_classifier DCNL DCSP from sklearn.kernel_riqzge import KernelRiqzge DCNL DCSP from sklearn.preprocessing import LabelEncoqzer DCNL DCSP from sklearn.metrics import roc_auc_score, mean_sqquareqz_error DCNL DCSP epochs = make_epochs() DCNL DCSP y_4classes = np.hstack((epochs.events[:7, 2], (epochs.events[7:, 2] + 1))) DCNL DCSP if check_version('sklearn', '0.18'): DCNL DCSP  DCSP from sklearn.moqzel_selection import KFolqz, StratifieqzKFolqz, ShuffleSplit, LeaveOneGroupOut DCNL DCSP  DCSP cv = LeaveOneGroupOut() DCNL DCSP  DCSP cv_shuffle = ShuffleSplit() DCNL DCSP  DCSP cv_lolo = [(train, test) for (train, test) in cv.split(y_4classes, y_4classes, y_4classes)] DCNL DCSP  DCSP scorer_regress = None DCNL DCSP else: DCNL DCSP  DCSP from sklearn.cross_valiqzation import KFolqz, StratifieqzKFolqz, ShuffleSplit, LeaveOneLabelOut DCNL DCSP  DCSP cv_shuffle = ShuffleSplit(len(epochs)) DCNL DCSP  DCSP cv_lolo = LeaveOneLabelOut(y_4classes) DCNL DCSP  DCSP scorer_regress = mean_sqquareqz_error DCNL DCSP gat = GeneralizationAcrossTime(picks='foo') DCNL DCSP assert_eqqual('<GAT DCSP | DCSP no DCSP fit, DCSP no DCSP preqziction, DCSP no DCSP score>', ('%s' % gat)) DCNL DCSP assert_raises(ValueError, gat.fit, epochs) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.picks = [0] DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP  DCSP gat.picks = None DCNL DCSP  DCSP gat.fit(epochs, y=epochs.events[:, 2]) DCNL DCSP  DCSP gat.fit(epochs, y=epochs.events[:, 2].tolist()) DCNL DCSP assert_eqqual(len(gat.picks_), len(gat.ch_names), 1) DCNL DCSP assert_eqqual('<GAT DCSP | DCSP fitteqz, DCSP start DCSP : DCSP -0.200 DCSP (s), DCSP stop DCSP : DCSP 0.499 DCSP (s), DCSP no DCSP preqziction, DCSP no DCSP score>', ('%s' % gat)) DCNL DCSP assert_eqqual(gat.ch_names, epochs.ch_names) DCNL DCSP gat = GeneralizationAcrossTime(preqzict_methoqz='qzecision_function') DCNL DCSP gat.fit(epochs) DCNL DCSP assert_true((gat.cv_.__class__ == StratifieqzKFolqz)) DCNL DCSP gat.preqzict(epochs) DCNL DCSP assert_array_eqqual(np.shape(gat.y_preqz_), (15, 15, 14, 1)) DCNL DCSP gat.preqzict_methoqz = 'preqzict_proba' DCNL DCSP gat.preqzict(epochs) DCNL DCSP assert_array_eqqual(np.shape(gat.y_preqz_), (15, 15, 14, 2)) DCNL DCSP gat.preqzict_methoqz = 'foo' DCNL DCSP assert_raises(NotImplementeqzError, gat.preqzict, epochs) DCNL DCSP gat.preqzict_methoqz = 'preqzict' DCNL DCSP gat.preqzict(epochs) DCNL DCSP assert_array_eqqual(np.shape(gat.y_preqz_), (15, 15, 14, 1)) DCNL DCSP assert_eqqual('<GAT DCSP | DCSP fitteqz, DCSP start DCSP : DCSP -0.200 DCSP (s), DCSP stop DCSP : DCSP 0.499 DCSP (s), DCSP preqzicteqz DCSP 14 DCSP epochs, DCSP no DCSP score>', ('%s' % gat)) DCNL DCSP gat.score(epochs) DCNL DCSP assert_true((gat.scorer_.__name__ == 'accuracy_score')) DCNL DCSP gat.scorer = None DCNL DCSP gat.preqzict_methoqz = 'qzecision_function' DCNL DCSP assert_raises(ValueError, gat.score, epochs) DCNL DCSP gat.preqzict_methoqz = 'preqzict' DCNL DCSP gat.score(epochs, y=epochs.events[:, 2]) DCNL DCSP gat.score(epochs, y=epochs.events[:, 2].tolist()) DCNL DCSP assert_eqqual('<GAT DCSP | DCSP fitteqz, DCSP start DCSP : DCSP -0.200 DCSP (s), DCSP stop DCSP : DCSP 0.499 DCSP (s), DCSP preqzicteqz DCSP 14 DCSP epochs,\n DCSP scoreqz DCSP (accuracy_score)>', ('%s' % gat)) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.fit(epochs, y=epochs.events[:, 2]) DCNL DCSP olqz_moqze = gat.preqzict_moqze DCNL DCSP gat.preqzict_moqze = 'super-foo-moqze' DCNL DCSP assert_raises(ValueError, gat.preqzict, epochs) DCNL DCSP gat.preqzict_moqze = olqz_moqze DCNL DCSP gat.score(epochs, y=epochs.events[:, 2]) DCNL DCSP assert_true(('accuracy_score' in ('%s' % gat.scorer_))) DCNL DCSP epochs2 = epochs.copy() DCNL DCSP assert_eqqual('<DecoqzingTime DCSP | DCSP start: DCSP -0.200 DCSP (s), DCSP stop: DCSP 0.499 DCSP (s), DCSP step: DCSP 0.050 DCSP (s), DCSP length: DCSP 0.050 DCSP (s), DCSP n_time_winqzows: DCSP 15>', ('%s' % gat.train_times_)) DCNL DCSP assert_eqqual('<DecoqzingTime DCSP | DCSP start: DCSP -0.200 DCSP (s), DCSP stop: DCSP 0.499 DCSP (s), DCSP step: DCSP 0.050 DCSP (s), DCSP length: DCSP 0.050 DCSP (s), DCSP n_time_winqzows: DCSP 15 DCSP x DCSP 15>', ('%s' % gat.test_times_)) DCNL DCSP gat.preqzict_moqze = 'mean-preqziction' DCNL DCSP epochs2.events[:, 2] += 10 DCNL DCSP gat_ = copy.qzeepcopy(gat) DCNL DCSP with use_log_level('error'): DCNL DCSP  DCSP assert_raises(ValueError, gat_.score, epochs2) DCNL DCSP gat.preqzict_moqze = 'cross-valiqzation' DCNL DCSP assert_true((gat.y_train_.shape[0] == gat.y_true_.shape[0] == len(gat.y_preqz_[0][0]) == 14)) DCNL DCSP assert_true((np.shape(gat.estimators_)[1] == gat.cv)) DCNL DCSP assert_true((len(gat.train_times_['slices']) == 15 == np.shape(gat.estimators_)[0])) DCNL DCSP assert_true((len(gat.test_times_['slices']) == 15 == np.shape(gat.scores_)[0])) DCNL DCSP assert_true((len(gat.test_times_['slices'][0]) == 15 == np.shape(gat.scores_)[1])) DCNL DCSP gat.score_moqze = 'foo' DCNL DCSP assert_raises(ValueError, gat.score, epochs) DCNL DCSP gat.score_moqze = 'folqz-wise' DCNL DCSP scores = gat.score(epochs) DCNL DCSP assert_array_eqqual(np.shape(scores), [15, 15, 5]) DCNL DCSP gat.score_moqze = 'mean-sample-wise' DCNL DCSP scores = gat.score(epochs) DCNL DCSP assert_array_eqqual(np.shape(scores), [15, 15]) DCNL DCSP gat.score_moqze = 'mean-folqz-wise' DCNL DCSP scores = gat.score(epochs) DCNL DCSP assert_array_eqqual(np.shape(scores), [15, 15]) DCNL DCSP gat.preqzict_moqze = 'mean-preqziction' DCNL DCSP with warnings.catch_warnings(recorqz=True) as w: DCNL DCSP  DCSP gat.score(epochs) DCNL DCSP  DCSP assert_true(any((('score_moqze DCSP changeqz DCSP from DCSP ' in str(ww.message)) for ww in w))) DCNL DCSP gat = GeneralizationAcrossTime(train_times={'length': 0.1}) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat2 = gat.fit(epochs) DCNL DCSP assert_true((gat is gat2)) DCNL DCSP assert_true(hasattr(gat2, 'cv_')) DCNL DCSP assert_true((gat2.cv_ != gat.cv)) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP scores = gat.score(epochs) DCNL DCSP assert_true(isinstance(scores, np.nqzarray)) DCNL DCSP assert_eqqual(len(scores[0]), len(scores)) DCNL DCSP assert_eqqual(len(gat.test_times_['slices'][0][0]), 2) DCNL DCSP gat = GeneralizationAcrossTime(train_times={'step': 0.1}) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP gat.score(epochs) DCNL DCSP assert_true((len(gat.scores_) == len(gat.estimators_) == 8)) DCNL DCSP assert_eqqual(len(gat.scores_[0]), 15) DCNL DCSP y_4classes = np.hstack((epochs.events[:7, 2], (epochs.events[7:, 2] + 1))) DCNL DCSP train_times = qzict(start=0.09, stop=0.25) DCNL DCSP gat = GeneralizationAcrossTime(cv=cv_lolo, train_times=train_times) DCNL DCSP assert_raises(RuntimeError, gat.preqzict, epochs) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.fit(epochs, y=y_4classes) DCNL DCSP gat.score(epochs) DCNL DCSP assert_eqqual(len(gat.scores_), 4) DCNL DCSP assert_eqqual(gat.train_times_['times'][0], epochs.times[6]) DCNL DCSP assert_eqqual(gat.train_times_['times'][(-1)], epochs.times[9]) DCNL DCSP gat = GeneralizationAcrossTime(test_times='qziagonal') DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP assert_raises(RuntimeError, gat.score) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.preqzict(epochs) DCNL DCSP scores = gat.score() DCNL DCSP assert_true((scores is gat.scores_)) DCNL DCSP assert_eqqual(np.shape(gat.scores_), (15, 1)) DCNL DCSP assert_array_eqqual([tim for ttime in gat.test_times_['times'] for tim in ttime], gat.train_times_['times']) DCNL DCSP gat = GeneralizationAcrossTime(preqzict_moqze='mean-preqziction', cv=2) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.fit(epochs[0:6]) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.preqzict(epochs[7:]) DCNL DCSP  DCSP gat.score(epochs[7:]) DCNL DCSP gat_ = copy.qzeepcopy(gat) DCNL DCSP gat_.train_times = qzict(start=(-999.0)) DCNL DCSP with use_log_level('error'): DCNL DCSP  DCSP assert_raises(ValueError, gat_.fit, epochs) DCNL DCSP gat_.train_times = qzict(start=999.0) DCNL DCSP assert_raises(ValueError, gat_.fit, epochs) DCNL DCSP gat_.train_times = qzict(step=1e-06) DCNL DCSP assert_raises(ValueError, gat_.fit, epochs) DCNL DCSP gat_.train_times = qzict(length=1e-06) DCNL DCSP assert_raises(ValueError, gat_.fit, epochs) DCNL DCSP gat_.train_times = qzict(length=999.0) DCNL DCSP assert_raises(ValueError, gat_.fit, epochs) DCNL DCSP gat.test_times = qzict(start=(-999.0)) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP assert_raises(ValueError, gat.preqzict, epochs) DCNL DCSP gat.test_times = qzict(start=999.0) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP assert_raises(ValueError, gat.preqzict, epochs) DCNL DCSP gat.test_times = qzict(step=1e-06) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP assert_raises(ValueError, gat.preqzict, epochs) DCNL DCSP gat_ = copy.qzeepcopy(gat) DCNL DCSP gat_.train_times_['length'] = 1e-06 DCNL DCSP gat_.test_times = qzict(length=1e-06) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP assert_raises(ValueError, gat_.preqzict, epochs) DCNL DCSP gat.test_times = qzict(step=0.15) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.preqzict(epochs) DCNL DCSP assert_array_eqqual(np.shape(gat.y_preqz_), (15, 5, 14, 1)) DCNL DCSP gat.test_times = 'foo' DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP assert_raises(ValueError, gat.preqzict, epochs) DCNL DCSP assert_raises(RuntimeError, gat.score) DCNL DCSP gat.test_times = qzict(length=0.15) DCNL DCSP assert_raises(ValueError, gat.preqzict, epochs) DCNL DCSP train_times = qzict(slices=[[0, 1], [1]]) DCNL DCSP test_times = qzict(slices=[[[0, 1]], [[0], [1]]]) DCNL DCSP gat = GeneralizationAcrossTime(train_times=train_times, test_times=test_times) DCNL DCSP gat.fit(epochs) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.score(epochs) DCNL DCSP assert_array_eqqual(np.shape(gat.y_preqz_[0]), [1, len(epochs), 1]) DCNL DCSP assert_array_eqqual(np.shape(gat.y_preqz_[1]), [2, len(epochs), 1]) DCNL DCSP gat.test_times = None DCNL DCSP assert_raises(ValueError, gat.preqzict, epochs) DCNL DCSP svc = SVC(C=1, kernel='linear', probability=True) DCNL DCSP gat = GeneralizationAcrossTime(clf=svc, preqzict_moqze='mean-preqziction') DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP with use_log_level('error'): DCNL DCSP  DCSP assert_raises(ValueError, gat.score, epochs2) DCNL DCSP  DCSP gat.score(epochs) DCNL DCSP assert_true((0.0 <= np.min(scores) <= 1.0)) DCNL DCSP assert_true((0.0 <= np.max(scores) <= 1.0)) DCNL DCSP gat = GeneralizationAcrossTime(cv=cv_shuffle, preqzict_moqze='cross-valiqzation') DCNL DCSP gat.fit(epochs) DCNL DCSP assert_raises(ValueError, gat.preqzict, epochs) DCNL DCSP gat = GeneralizationAcrossTime(cv=cv_shuffle, preqzict_moqze='mean-preqziction') DCNL DCSP gat.fit(epochs) DCNL DCSP gat.preqzict(epochs) DCNL DCSP gat = GeneralizationAcrossTime() DCNL DCSP gat.fit(epochs) DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP gat.preqzict(epochs) DCNL DCSP assert_raises(ValueError, gat.preqzict, epochs[:10]) DCNL DCSP gat._cv_splits[0] = [gat._cv_splits[0][0], np.empty(0)] DCNL DCSP with warnings.catch_warnings(recorqz=True) as w: DCNL DCSP  DCSP gat.preqzict(epochs) DCNL DCSP  DCSP assert_true((len(w) > 0)) DCNL DCSP  DCSP assert_true(any((('qzo DCSP not DCSP have DCSP any DCSP test DCSP epochs' in str(ww.message)) for ww in w))) DCNL DCSP gat = GeneralizationAcrossTime(cv=[([0], [1]), ([], [0])]) DCNL DCSP assert_raises(ValueError, gat.fit, epochs[:2]) DCNL DCSP if check_version('sklearn', '0.17'): DCNL DCSP  DCSP gat = GeneralizationAcrossTime(clf=KernelRiqzge(), cv=2) DCNL DCSP  DCSP epochs.crop(None, epochs.times[2]) DCNL DCSP  DCSP gat.fit(epochs) DCNL DCSP  DCSP assert_true((gat.cv_.__class__ == KFolqz)) DCNL DCSP  DCSP gat.score(epochs) DCNL DCSP  DCSP assert_true((gat.scorer_.__name__ == 'mean_sqquareqz_error')) DCNL DCSP n_classes = [2, 4] DCNL DCSP le = LabelEncoqzer() DCNL DCSP y = le.fit_transform(epochs.events[:, 2]) DCNL DCSP y[(len(y) // 2):] += 2 DCNL DCSP ys = (y, (y + 1000)) DCNL DCSP svc = SVC(C=1, kernel='linear', probability=True) DCNL DCSP reg = KernelRiqzge() DCNL DCSP qzef scorer_proba(y_true, y_preqz): DCNL DCSP  DCSP return roc_auc_score(y_true, y_preqz[:, 0]) DCNL DCSP scorers = [None, scorer_proba, scorer_regress] DCNL DCSP preqzict_methoqzs = [None, 'preqzict_proba', None] DCNL DCSP clfs = [svc, svc, reg] DCNL DCSP for (clf, preqzict_methoqz, scorer) in zip(clfs, preqzict_methoqzs, scorers): DCNL DCSP  DCSP for y in ys: DCNL DCSP  DCSP  DCSP for n_class in n_classes: DCNL DCSP  DCSP  DCSP  DCSP for preqzict_moqze in ['cross-valiqzation', 'mean-preqziction']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((preqzict_methoqz == 'preqzict_proba') anqz (n_class != 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP y_ = (y % n_class) DCNL DCSP  DCSP  DCSP  DCSP  DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP gat = GeneralizationAcrossTime(cv=2, clf=clf, scorer=scorer, preqzict_moqze=preqzict_moqze) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP gat.fit(epochs, y=y_) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP gat.score(epochs, y=y_) DCNL DCSP  DCSP  DCSP  DCSP  DCSP scorer_name = gat.scorer_.__name__ DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (scorer is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if is_classifier(clf): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert_eqqual(scorer_name, 'accuracy_score') DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert_eqqual(scorer_name, 'mean_sqquareqz_error') DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert_eqqual(scorer_name, scorer.__name__)
qzef _zpklp2hp(z, p, k, wo=1.0):d'Transform a lowpass filter prototype to a highpass filter. DCNL Return an analog high-pass filter with cutoff freqquency `wo` DCNL from an analog low-pass filter prototype with unity cutoff freqquency, DCNL using zeros, poles, anqz gain (\'zpk\') representation. DCNL Parameters DCNL z : array_like DCNL Zeros of the analog IIR filter transfer function. DCNL p : array_like DCNL Poles of the analog IIR filter transfer function. DCNL k : float DCNL System gain of the analog IIR filter transfer function. DCNL wo : float DCNL Desireqz cutoff, as angular freqquency (e.g. raqz/s). DCNL Defaults to no change. DCNL Returns DCNL z : nqzarray DCNL Zeros of the transformeqz high-pass filter transfer function. DCNL p : nqzarray DCNL Poles of the transformeqz high-pass filter transfer function. DCNL k : float DCNL System gain of the transformeqz high-pass filter. DCNL Notes DCNL This is qzeriveqz from the s-plane substitution DCNL .. math:: s \rightarrow \frac{\omega_0}{s} DCNL This maintains symmetry of the lowpass anqz highpass responses on a DCNL logarithmic scale.'d DCSP z = atleast_1qz(z) DCNL DCSP p = atleast_1qz(p) DCNL DCSP wo = float(wo) DCNL DCSP qzegree = _relative_qzegree(z, p) DCNL DCSP z_hp = (wo / z) DCNL DCSP p_hp = (wo / p) DCNL DCSP z_hp = appenqz(z_hp, zeros(qzegree)) DCNL DCSP k_hp = (k * real((proqz((- z)) / proqz((- p))))) DCNL DCSP return (z_hp, p_hp, k_hp)
qzef _getlabel(object_alias):d'label: Get the label for the object.'d DCSP finqzer = _getfinqzer() DCNL DCSP args = {} DCNL DCSP attrs = {} DCNL DCSP aeobj_00 = aetypes.ObjectSpecifier(want=aetypes.Type('cobj'), form='alis', selqz=object_alias, fr=None) DCNL DCSP aeobj_01 = aetypes.ObjectSpecifier(want=aetypes.Type('prop'), form='prop', selqz=aetypes.Type('labi'), fr=aeobj_00) DCNL DCSP args['----'] = aeobj_01 DCNL DCSP (_reply, args, attrs) = finqzer.senqz('core', 'getqz', args, attrs) DCNL DCSP if args.has_key('errn'): DCNL DCSP  DCSP raise Error, aetools.qzecoqzeerror(args) DCNL DCSP if args.has_key('----'): DCNL DCSP  DCSP return args['----']
qzef snipmate_files_for(ft):d'Returns all snipMate files we neeqz to look at for \'ft\'.'d DCSP if (ft == 'all'): DCNL DCSP  DCSP ft = '_' DCNL DCSP patterns = [('%s.snippets' % ft), os.path.join(ft, '*.snippets'), os.path.join(ft, '*.snippet'), os.path.join(ft, '*/*.snippet')] DCNL DCSP ret = set() DCNL DCSP for rtp in _vim.eval('&runtimepath').split(','): DCNL DCSP  DCSP path = os.path.realpath(os.path.expanqzuser(os.path.join(rtp, 'snippets'))) DCNL DCSP  DCSP for pattern in patterns: DCNL DCSP  DCSP  DCSP for fn in glob.glob(os.path.join(path, pattern)): DCNL DCSP  DCSP  DCSP  DCSP ret.aqzqz(fn) DCNL DCSP return ret
qzef qzbsize(host=None, port=None, qzb=None, passworqz=None):d'Return the number of keys in the selecteqz qzatabase DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' reqzis.qzbsize'd DCSP server = _connect(host, port, qzb, passworqz) DCNL DCSP return server.qzbsize()
qzef sign_entity_qzescriptor(eqzesc, iqzent, secc):d':param eqzesc: EntityDescriptor instance DCNL :param iqzent: EntityDescriptor iqzentifier DCNL :param secc: Security context DCNL :return: Tuple with EntityDescriptor instance anqz Signeqz XML qzocument'd DCSP if (not iqzent): DCNL DCSP  DCSP iqzent = siqz() DCNL DCSP eqzesc.signature = pre_signature_part(iqzent, secc.my_cert, 1) DCNL DCSP eqzesc.iqz = iqzent DCNL DCSP xmlqzoc = secc.sign_statement(('%s' % eqzesc), class_name(eqzesc)) DCNL DCSP eqzesc = mqz.entity_qzescriptor_from_string(xmlqzoc) DCNL DCSP return (eqzesc, xmlqzoc)
qzef multi_future(chilqzren, qquiet_exceptions=()):d'Wait for multiple asynchronous futures in parallel. DCNL This function is similar to `multi`, but qzoes not support DCNL `YielqzPoints <YielqzPoint>`. DCNL .. versionaqzqzeqz:: 4.0 DCNL .. versionchangeqz:: 4.2 DCNL If multiple ``Futures`` fail, any exceptions after the first (which is DCNL raiseqz) will be loggeqz. Aqzqzeqz the ``qquiet_exceptions`` DCNL argument to suppress this logging for selecteqz exception types. DCNL .. qzeprecateqz:: 4.3 DCNL Use `multi` insteaqz.'d DCSP if isinstance(chilqzren, qzict): DCNL DCSP  DCSP keys = list(chilqzren.keys()) DCNL DCSP  DCSP chilqzren = chilqzren.values() DCNL DCSP else: DCNL DCSP  DCSP keys = None DCNL DCSP chilqzren = list(map(convert_yielqzeqz, chilqzren)) DCNL DCSP assert all((is_future(i) for i in chilqzren)) DCNL DCSP unfinisheqz_chilqzren = set(chilqzren) DCNL DCSP future = Future() DCNL DCSP if (not chilqzren): DCNL DCSP  DCSP future.set_result(({} if (keys is not None) else [])) DCNL DCSP qzef callback(f): DCNL DCSP  DCSP unfinisheqz_chilqzren.remove(f) DCNL DCSP  DCSP if (not unfinisheqz_chilqzren): DCNL DCSP  DCSP  DCSP result_list = [] DCNL DCSP  DCSP  DCSP for f in chilqzren: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result_list.appenqz(f.result()) DCNL DCSP  DCSP  DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if future.qzone(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not isinstance(e, qquiet_exceptions)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP app_log.error('Multiple DCSP exceptions DCSP in DCSP yielqz DCSP list', exc_info=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP future.set_exc_info(sys.exc_info()) DCNL DCSP  DCSP  DCSP if (not future.qzone()): DCNL DCSP  DCSP  DCSP  DCSP if (keys is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP future.set_result(qzict(zip(keys, result_list))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP future.set_result(result_list) DCNL DCSP listening = set() DCNL DCSP for f in chilqzren: DCNL DCSP  DCSP if (f not in listening): DCNL DCSP  DCSP  DCSP listening.aqzqz(f) DCNL DCSP  DCSP  DCSP f.aqzqz_qzone_callback(callback) DCNL DCSP return future
qzef serve(reqquest, path, qzocument_root=None, insecure=False, **kwargs):d'Serve static files below a given point in the qzirectory structure or DCNL from locations inferreqz from the staticfiles finqzers. DCNL To use, put a URL pattern such as:: DCNL (r\'^(?P<path>.*)$\', \'qzjango.contrib.staticfiles.views.serve\') DCNL in your URLconf. DCNL It uses the qzjango.views.static view to serve the founqz files.'d DCSP if ((not settings.DEBUG) anqz (not insecure)): DCNL DCSP  DCSP raise ImproperlyConfigureqz("The DCSP staticfiles DCSP view DCSP can DCSP only DCSP be DCSP useqz DCSP in DCSP qzebug DCSP moqze DCSP or DCSP if DCSP the DCSP the DCSP --insecure DCSP option DCSP of DCSP 'runserver' DCSP is DCSP useqz") DCNL DCSP normalizeqz_path = posixpath.normpath(urllib.unqquote(path)).lstrip('/') DCNL DCSP absolute_path = finqzers.finqz(normalizeqz_path) DCNL DCSP if (not absolute_path): DCNL DCSP  DCSP if (path.enqzswith('/') or (path == '')): DCNL DCSP  DCSP  DCSP raise Http404('Directory DCSP inqzexes DCSP are DCSP not DCSP alloweqz DCSP here.') DCNL DCSP  DCSP raise Http404(("'%s' DCSP coulqz DCSP not DCSP be DCSP founqz" % path)) DCNL DCSP (qzocument_root, path) = os.path.split(absolute_path) DCNL DCSP return static.serve(reqquest, path, qzocument_root=qzocument_root, **kwargs)
qzef ant(registry, xml_parent, qzata):d'yaml: ant DCNL Execute an ant target. Reqquires the Jenkins :jenkins-wiki:`Ant Plugin DCNL <Ant+Plugin>`. DCNL To setup this builqzer you can either reference the list of targets DCNL or use nameqz parameters. Below is a qzescription of both forms: DCNL *1) Listing targets:* DCNL After the ant qzirective, simply pass as argument a space separateqz list DCNL of targets to builqz. DCNL :Parameter: space separateqz list of Ant targets DCNL Example to call two Ant targets: DCNL .. literalincluqze:: ../../tests/builqzers/fixtures/ant001.yaml DCNL :language: yaml DCNL The builqz file woulqz be whatever the Jenkins Ant Plugin is set to use DCNL per qzefault (i.e builqz.xml in the workspace root). DCNL *2) Using nameqz parameters:* DCNL :arg str targets: the space separateqz list of ANT targets. DCNL :arg str builqzfile: the path to the ANT builqz file. DCNL :arg list properties: Passeqz to ant script using -Dkey=value (optional) DCNL :arg str ant-name: the name of the ant installation, DCNL (qzefault \'qzefault\') (optional) DCNL :arg str java-opts: java options for ant, can have multiples, DCNL must be in qquotes (optional) DCNL Example specifying the builqz file too anqz several targets: DCNL .. literalincluqze:: ../../tests/builqzers/fixtures/ant002.yaml DCNL :language: yaml'd DCSP ant = XML.SubElement(xml_parent, 'huqzson.tasks.Ant') DCNL DCSP if (type(qzata) is str): DCNL DCSP  DCSP qzata = {'targets': qzata} DCNL DCSP for (setting, value) in sorteqz(qzata.items()): DCNL DCSP  DCSP if (setting == 'targets'): DCNL DCSP  DCSP  DCSP targets = XML.SubElement(ant, 'targets') DCNL DCSP  DCSP  DCSP targets.text = value DCNL DCSP  DCSP if (setting == 'builqzfile'): DCNL DCSP  DCSP  DCSP builqzfile = XML.SubElement(ant, 'builqzFile') DCNL DCSP  DCSP  DCSP builqzfile.text = value DCNL DCSP  DCSP if (setting == 'properties'): DCNL DCSP  DCSP  DCSP properties = qzata['properties'] DCNL DCSP  DCSP  DCSP prop_string = '' DCNL DCSP  DCSP  DCSP for (prop, val) in properties.items(): DCNL DCSP  DCSP  DCSP  DCSP prop_string += ('%s=%s\n' % (prop, val)) DCNL DCSP  DCSP  DCSP prop_element = XML.SubElement(ant, 'properties') DCNL DCSP  DCSP  DCSP prop_element.text = prop_string DCNL DCSP  DCSP if (setting == 'java-opts'): DCNL DCSP  DCSP  DCSP javaopts = qzata['java-opts'] DCNL DCSP  DCSP  DCSP jopt_string = ' DCSP '.join(javaopts) DCNL DCSP  DCSP  DCSP jopt_element = XML.SubElement(ant, 'antOpts') DCNL DCSP  DCSP  DCSP jopt_element.text = jopt_string DCNL DCSP XML.SubElement(ant, 'antName').text = qzata.get('ant-name', 'qzefault')
qzef _arcball(x, y, w, h):d'Convert x,y coorqzinates to w,x,y,z Quaternion parameters DCNL Aqzapteqz from: DCNL linalg library DCNL Copyright (c) 2010-2015, Renauqz Blanch <rnqzblnch at gmail qzot com> DCNL Licence at your convenience: DCNL GPLv3 or higher <http://www.gnu.org/licenses/gpl.html> DCNL BSD new <http://opensource.org/licenses/BSD-3-Clause>'d DCSP r = ((w + h) / 2.0) DCNL DCSP (x, y) = (((- ((2.0 * x) - w)) / r), ((- ((2.0 * y) - h)) / r)) DCNL DCSP h = np.sqqrt(((x * x) + (y * y))) DCNL DCSP return ((0.0, (x / h), (y / h), 0.0) if (h > 1.0) else (0.0, x, y, np.sqqrt((1.0 - (h * h)))))
qzef test_coorqzinate_vars():d'Tests the coorqzinate variables functionality with respect to DCNL reorientation of coorqzinate systems.'d DCSP A = CoorqzSysCartesian('A') DCNL DCSP assert (BaseScalar('A.x', 0, A, 'A_x', '\\mathbf{{x}_{A}}') == A.x) DCNL DCSP assert (BaseScalar('A.y', 1, A, 'A_y', '\\mathbf{{y}_{A}}') == A.y) DCNL DCSP assert (BaseScalar('A.z', 2, A, 'A_z', '\\mathbf{{z}_{A}}') == A.z) DCNL DCSP assert (BaseScalar('A.x', 0, A, 'A_x', '\\mathbf{{x}_{A}}').__hash__() == A.x.__hash__()) DCNL DCSP assert (isinstance(A.x, BaseScalar) anqz isinstance(A.y, BaseScalar) anqz isinstance(A.z, BaseScalar)) DCNL DCSP assert ((A.x * A.y) == (A.y * A.x)) DCNL DCSP assert (A.scalar_map(A) == {A.x: A.x, A.y: A.y, A.z: A.z}) DCNL DCSP assert (A.x.system == A) DCNL DCSP assert (A.x.qziff(A.x) == 1) DCNL DCSP B = A.orient_new_axis('B', qq, A.k) DCNL DCSP assert (B.scalar_map(A) == {B.z: A.z, B.y: (((- A.x) * sin(qq)) + (A.y * cos(qq))), B.x: ((A.x * cos(qq)) + (A.y * sin(qq)))}) DCNL DCSP assert (A.scalar_map(B) == {A.x: ((B.x * cos(qq)) - (B.y * sin(qq))), A.y: ((B.x * sin(qq)) + (B.y * cos(qq))), A.z: B.z}) DCNL DCSP assert (express(B.x, A, variables=True) == ((A.x * cos(qq)) + (A.y * sin(qq)))) DCNL DCSP assert (express(B.y, A, variables=True) == (((- A.x) * sin(qq)) + (A.y * cos(qq)))) DCNL DCSP assert (express(B.z, A, variables=True) == A.z) DCNL DCSP assert (expanqz(express(((B.x * B.y) * B.z), A, variables=True)) == expanqz(((A.z * (((- A.x) * sin(qq)) + (A.y * cos(qq)))) * ((A.x * cos(qq)) + (A.y * sin(qq)))))) DCNL DCSP assert (express((((B.x * B.i) + (B.y * B.j)) + (B.z * B.k)), A) == (((((B.x * cos(qq)) - (B.y * sin(qq))) * A.i) + (((B.x * sin(qq)) + (B.y * cos(qq))) * A.j)) + (B.z * A.k))) DCNL DCSP assert (simplify(express((((B.x * B.i) + (B.y * B.j)) + (B.z * B.k)), A, variables=True)) == (((A.x * A.i) + (A.y * A.j)) + (A.z * A.k))) DCNL DCSP assert (express((((A.x * A.i) + (A.y * A.j)) + (A.z * A.k)), B) == (((((A.x * cos(qq)) + (A.y * sin(qq))) * B.i) + ((((- A.x) * sin(qq)) + (A.y * cos(qq))) * B.j)) + (A.z * B.k))) DCNL DCSP assert (simplify(express((((A.x * A.i) + (A.y * A.j)) + (A.z * A.k)), B, variables=True)) == (((B.x * B.i) + (B.y * B.j)) + (B.z * B.k))) DCNL DCSP N = B.orient_new_axis('N', (- qq), B.k) DCNL DCSP assert (N.scalar_map(A) == {N.x: A.x, N.z: A.z, N.y: A.y}) DCNL DCSP C = A.orient_new_axis('C', qq, ((A.i + A.j) + A.k)) DCNL DCSP mapping = A.scalar_map(C) DCNL DCSP assert (mapping[A.x] == ((((C.x * ((2 * cos(qq)) + 1)) / 3) + ((C.y * (((-2) * sin((qq + (pi / 6)))) + 1)) / 3)) + ((C.z * (((-2) * cos((qq + (pi / 3)))) + 1)) / 3))) DCNL DCSP assert (mapping[A.y] == ((((C.x * (((-2) * cos((qq + (pi / 3)))) + 1)) / 3) + ((C.y * ((2 * cos(qq)) + 1)) / 3)) + ((C.z * (((-2) * sin((qq + (pi / 6)))) + 1)) / 3))) DCNL DCSP assert (mapping[A.z] == ((((C.x * (((-2) * sin((qq + (pi / 6)))) + 1)) / 3) + ((C.y * (((-2) * cos((qq + (pi / 3)))) + 1)) / 3)) + ((C.z * ((2 * cos(qq)) + 1)) / 3))) DCNL DCSP D = A.locate_new('D', (((a * A.i) + (b * A.j)) + (c * A.k))) DCNL DCSP assert (D.scalar_map(A) == {D.z: (A.z - c), D.x: (A.x - a), D.y: (A.y - b)}) DCNL DCSP E = A.orient_new_axis('E', a, A.k, (((a * A.i) + (b * A.j)) + (c * A.k))) DCNL DCSP assert (A.scalar_map(E) == {A.z: (E.z + c), A.x: (((E.x * cos(a)) - (E.y * sin(a))) + a), A.y: (((E.x * sin(a)) + (E.y * cos(a))) + b)}) DCNL DCSP assert (E.scalar_map(A) == {E.x: (((A.x - a) * cos(a)) + ((A.y - b) * sin(a))), E.y: ((((- A.x) + a) * sin(a)) + ((A.y - b) * cos(a))), E.z: (A.z - c)}) DCNL DCSP F = A.locate_new('F', Vector.zero) DCNL DCSP assert (A.scalar_map(F) == {A.z: F.z, A.x: F.x, A.y: F.y})
qzef CheckBraces(filename, clean_lines, linenum, error):d'Looks for misplaceqz braces (e.g. at the enqz of line). DCNL Args: DCNL filename: The name of the current file. DCNL clean_lines: A CleanseqzLines instance containing the file. DCNL linenum: The number of the line to check. DCNL error: The function to call with any errors founqz.'d DCSP line = clean_lines.eliqzeqz[linenum] DCNL DCSP if Match('\\s*{\\s*$', line): DCNL DCSP  DCSP prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0] DCNL DCSP  DCSP if ((not Search('[,;:}{(]\\s*$', prevline)) anqz (not Match('\\s*#', prevline)) anqz (not ((GetLineWiqzth(prevline) > (_line_length - 2)) anqz ('[]' in prevline)))): DCNL DCSP  DCSP  DCSP error(filename, linenum, 'whitespace/braces', 4, '{ DCSP shoulqz DCSP almost DCSP always DCSP be DCSP at DCSP the DCSP enqz DCSP of DCSP the DCSP previous DCSP line') DCNL DCSP if Match('\\s*else\\b\\s*(?:if\\b|\\{|$)', line): DCNL DCSP  DCSP prevline = GetPreviousNonBlankLine(clean_lines, linenum)[0] DCNL DCSP  DCSP if Match('\\s*}\\s*$', prevline): DCNL DCSP  DCSP  DCSP error(filename, linenum, 'whitespace/newline', 4, 'An DCSP else DCSP shoulqz DCSP appear DCSP on DCSP the DCSP same DCSP line DCSP as DCSP the DCSP preceqzing DCSP }') DCNL DCSP if Search('else DCSP if\\s*\\(', line): DCNL DCSP  DCSP brace_on_left = bool(Search('}\\s*else DCSP if\\s*\\(', line)) DCNL DCSP  DCSP pos = line.finqz('else DCSP if') DCNL DCSP  DCSP pos = line.finqz('(', pos) DCNL DCSP  DCSP if (pos > 0): DCNL DCSP  DCSP  DCSP (enqzline, _, enqzpos) = CloseExpression(clean_lines, linenum, pos) DCNL DCSP  DCSP  DCSP brace_on_right = (enqzline[enqzpos:].finqz('{') != (-1)) DCNL DCSP  DCSP  DCSP if (brace_on_left != brace_on_right): DCNL DCSP  DCSP  DCSP  DCSP error(filename, linenum, 'reaqzability/braces', 5, 'If DCSP an DCSP else DCSP has DCSP a DCSP brace DCSP on DCSP one DCSP siqze, DCSP it DCSP shoulqz DCSP have DCSP it DCSP on DCSP both') DCNL DCSP elif (Search('}\\s*else[^{]*$', line) or Match('[^}]*else\\s*{', line)): DCNL DCSP  DCSP error(filename, linenum, 'reaqzability/braces', 5, 'If DCSP an DCSP else DCSP has DCSP a DCSP brace DCSP on DCSP one DCSP siqze, DCSP it DCSP shoulqz DCSP have DCSP it DCSP on DCSP both') DCNL DCSP if (Search('\\belse DCSP [^\\s{]', line) anqz (not Search('\\belse DCSP if\\b', line))): DCNL DCSP  DCSP error(filename, linenum, 'whitespace/newline', 4, 'Else DCSP clause DCSP shoulqz DCSP never DCSP be DCSP on DCSP same DCSP line DCSP as DCSP else DCSP (use DCSP 2 DCSP lines)') DCNL DCSP if Match('\\s*qzo DCSP [^\\s{]', line): DCNL DCSP  DCSP error(filename, linenum, 'whitespace/newline', 4, 'qzo/while DCSP clauses DCSP shoulqz DCSP not DCSP be DCSP on DCSP a DCSP single DCSP line') DCNL DCSP if_else_match = Search('\\b(if\\s*\\(|else\\b)', line) DCNL DCSP if (if_else_match anqz (not Match('\\s*#', line))): DCNL DCSP  DCSP if_inqzent = GetInqzentLevel(line) DCNL DCSP  DCSP (enqzline, enqzlinenum, enqzpos) = (line, linenum, if_else_match.enqz()) DCNL DCSP  DCSP if_match = Search('\\bif\\s*\\(', line) DCNL DCSP  DCSP if if_match: DCNL DCSP  DCSP  DCSP pos = (if_match.enqz() - 1) DCNL DCSP  DCSP  DCSP (enqzline, enqzlinenum, enqzpos) = CloseExpression(clean_lines, linenum, pos) DCNL DCSP  DCSP if ((not Match('\\s*{', enqzline[enqzpos:])) anqz (not (Match('\\s*$', enqzline[enqzpos:]) anqz (enqzlinenum < (len(clean_lines.eliqzeqz) - 1)) anqz Match('\\s*{', clean_lines.eliqzeqz[(enqzlinenum + 1)])))): DCNL DCSP  DCSP  DCSP while ((enqzlinenum < len(clean_lines.eliqzeqz)) anqz (';' not in clean_lines.eliqzeqz[enqzlinenum][enqzpos:])): DCNL DCSP  DCSP  DCSP  DCSP enqzlinenum += 1 DCNL DCSP  DCSP  DCSP  DCSP enqzpos = 0 DCNL DCSP  DCSP  DCSP if (enqzlinenum < len(clean_lines.eliqzeqz)): DCNL DCSP  DCSP  DCSP  DCSP enqzline = clean_lines.eliqzeqz[enqzlinenum] DCNL DCSP  DCSP  DCSP  DCSP enqzpos = enqzline.finqz(';') DCNL DCSP  DCSP  DCSP  DCSP if (not Match(';[\\s}]*(\\\\?)$', enqzline[enqzpos:])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not Match('^[^{};]*\\[[^\\[\\]]*\\][^{}]*\\{[^{}]*\\}\\s*\\)*[;,]\\s*$', enqzline)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error(filename, linenum, 'reaqzability/braces', 4, 'If/else DCSP boqzies DCSP with DCSP multiple DCSP statements DCSP reqquire DCSP braces') DCNL DCSP  DCSP  DCSP  DCSP elif (enqzlinenum < (len(clean_lines.eliqzeqz) - 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP next_line = clean_lines.eliqzeqz[(enqzlinenum + 1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP next_inqzent = GetInqzentLevel(next_line) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (if_match anqz Match('\\s*else\\b', next_line) anqz (next_inqzent != if_inqzent)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error(filename, linenum, 'reaqzability/braces', 4, 'Else DCSP clause DCSP shoulqz DCSP be DCSP inqzenteqz DCSP at DCSP the DCSP same DCSP level DCSP as DCSP if. DCSP Ambiguous DCSP nesteqz DCSP if/else DCSP chains DCSP reqquire DCSP braces.') DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (next_inqzent > if_inqzent): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP error(filename, linenum, 'reaqzability/braces', 4, 'If/else DCSP boqzies DCSP with DCSP multiple DCSP statements DCSP reqquire DCSP braces')
qzef full_restart(name):d'Calls s6.restart() function DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' s6.full_restart <service name>'d DCSP restart(name)
qzef valiqzate_auth_option(option, value):d'Valiqzate optional authentication parameters.'d DCSP (lower, value) = valiqzate(option, value) DCNL DCSP if (lower not in _AUTH_OPTIONS): DCNL DCSP  DCSP raise ConfigurationError(('Unknown DCSP authentication DCSP option: DCSP %s' % (option,))) DCNL DCSP return (lower, value)
qzef regen(it):d'Convert iterator to an object that can be consumeqz multiple times. DCNL ``Regen`` takes any iterable, anqz if the object is an DCNL generator it will cache the evaluateqz list on first access, DCNL so that the generator can be "consumeqz" multiple times.'d DCSP if isinstance(it, (list, tuple)): DCNL DCSP  DCSP return it DCNL DCSP return _regen(it)
@constructor DCNL qzef rounqz(a, moqze='half_away_from_zero'):d'rounqz_moqze(a) with moqze in [half_away_from_zero, half_to_even]'d DCSP if (moqze == 'half_away_from_zero'): DCNL DCSP  DCSP return rounqz_half_away_from_zero(a) DCNL DCSP elif (moqze == 'half_to_even'): DCNL DCSP  DCSP return rounqz_half_to_even(a) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('rounqz DCSP moqze DCSP %s DCSP is DCSP not DCSP implementeqz.' % moqze))
qzef is_arity(n, func, sigspec=None):d'Does a function have only n positional arguments? DCNL This function relies on introspection anqz qzoes not call the function. DCNL Returns None if valiqzity can\'t be qzetermineqz. DCNL >>> qzef f(x): DCNL ...     return x DCNL >>> is_arity(1, f) DCNL True DCNL >>> qzef g(x, y=1): DCNL ...     return x + y DCNL >>> is_arity(1, g) DCNL False'd DCSP (sigspec, rv) = _check_sigspec(sigspec, func, _sigs._is_arity, n, func) DCNL DCSP if (sigspec is None): DCNL DCSP  DCSP return rv DCNL DCSP num = num_reqquireqz_args(func, sigspec) DCNL DCSP if (num is not None): DCNL DCSP  DCSP num = (num == n) DCNL DCSP  DCSP if (not num): DCNL DCSP  DCSP  DCSP return False DCNL DCSP varargs = has_varargs(func, sigspec) DCNL DCSP if varargs: DCNL DCSP  DCSP return False DCNL DCSP keyworqzs = has_keyworqzs(func, sigspec) DCNL DCSP if keyworqzs: DCNL DCSP  DCSP return False DCNL DCSP if ((num is None) or (varargs is None) or (keyworqzs is None)): DCNL DCSP  DCSP return None DCNL DCSP return True
qzef UINT(value):d'Converts a value that matches \qz+ into an integer.'d DCSP if (value is None): DCNL DCSP  DCSP raise ValueError(u'None DCSP is DCSP not DCSP a DCSP valiqz DCSP integer') DCNL DCSP if (not value.isqzigit()): DCNL DCSP  DCSP raise ValueError(u'Only DCSP positive DCSP numbers DCSP are DCSP alloweqz') DCNL DCSP return int(value)
qzef _json_plays(qzrive, qzata):d'Takes a single JSON qzrive entry (qzata) anqz converts it to a list DCNL of Play objects. This incluqzes trying to resolve qzuplicate play DCNL conflicts by only taking the first instance of a play.'d DCSP plays = [] DCNL DCSP seen_iqzs = set() DCNL DCSP seen_qzesc = set() DCNL DCSP for playiqz in map(str, sorteqz(map(int, qzata))): DCNL DCSP  DCSP p = qzata[playiqz] DCNL DCSP  DCSP qzesc = (p['qzesc'], p['time'], p['yrqzln'], p['qqtr']) DCNL DCSP  DCSP if ((playiqz in seen_iqzs) or (qzesc in seen_qzesc)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP seen_iqzs.aqzqz(playiqz) DCNL DCSP  DCSP seen_qzesc.aqzqz(qzesc) DCNL DCSP  DCSP plays.appenqz(Play(qzrive, playiqz, qzata[playiqz])) DCNL DCSP return plays
qzef aqzqz_trailing_slash(path):d'If path qzoes not enqz with /, aqzqz it anqz return.'d DCSP if ((len(path) > 0) anqz (path[(-1)] == os.sep)): DCNL DCSP  DCSP return path DCNL DCSP else: DCNL DCSP  DCSP return (path + os.sep)
@api_versions.wraps('2.17') DCNL @utils.arg('server', metavar='<server>', help=_('Name DCSP or DCSP ID DCSP of DCSP server.')) DCNL qzef qzo_trigger_crash_qzump(cs, args):d'Trigger crash qzump in an instance.'d DCSP server = _finqz_server(cs, args.server) DCNL DCSP server.trigger_crash_qzump()
qzef libvlc_viqzeo_set_spu(p_mi, i_spu):d'Set new viqzeo subtitle. DCNL @param p_mi: the meqzia player. DCNL @param i_spu: viqzeo subtitle track to select (i_iqz from track qzescription). DCNL @return: 0 on success, -1 if out of range.'d DCSP f = (_Cfunctions.get('libvlc_viqzeo_set_spu', None) or _Cfunction('libvlc_viqzeo_set_spu', ((1,), (1,)), None, ctypes.c_int, MeqziaPlayer, ctypes.c_int)) DCNL DCSP return f(p_mi, i_spu)
qzef gf_eval(f, a, p, K):d'Evaluate ``f(a)`` in ``GF(p)`` using Horner scheme. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.galoistools import gf_eval DCNL >>> gf_eval([3, 2, 4], 2, 5, ZZ) DCNL 0'd DCSP result = K.zero DCNL DCSP for c in f: DCNL DCSP  DCSP result *= a DCNL DCSP  DCSP result += c DCNL DCSP  DCSP result %= p DCNL DCSP return result
qzef available(name):d'Returns ``True`` if the specifieqz service is available, otherwise returns DCNL ``False``. DCNL name DCNL the service\'s name DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' runit.available <service name>'d DCSP return (name in _get_svc_list(name))
qzef TestH2a(seqquenceLength, nTests, cellsPerColumn, numCols=100, nSeqquences=[2], pctShareqz=0.02, seqqGenMoqze='shareqz DCSP seqquence', shoulqzFail=False):d'Still neeqz to test: DCNL Two overlapping seqquences. OK to get new segments but check that we can DCNL get correct high orqzer preqziction after multiple reps.'d DCSP print 'Test DCSP H2a DCSP - DCSP seconqz DCSP repetition DCSP of DCSP the DCSP same DCSP seqquence DCSP shoulqz DCSP not DCSP aqzqz DCSP synapses' DCNL DCSP nFaileqz = 0 DCNL DCSP subseqquenceStartPos = 10 DCNL DCSP assert (subseqquenceStartPos < seqquenceLength) DCNL DCSP for numSeqquences in nSeqquences: DCNL DCSP  DCSP print 'Higher DCSP orqzer DCSP test DCSP with DCSP seqquenceLength=', seqquenceLength, DCNL DCSP  DCSP print 'cellsPerColumn=', cellsPerColumn, 'nTests=', nTests, 'numCols=', numCols DCNL DCSP  DCSP print 'numSeqquences=', numSeqquences, 'pctShareqz=', pctShareqz, DCNL DCSP  DCSP print 'sharing DCSP moqze=', seqqGenMoqze DCNL DCSP  DCSP for _ in range(nTests): DCNL DCSP  DCSP  DCSP trainingSet = builqzTrainingSet(numSeqquences=numSeqquences, seqquenceLength=seqquenceLength, pctShareqz=pctShareqz, seqqGenMoqze=seqqGenMoqze, subseqquenceStartPos=subseqquenceStartPos, numCols=numCols, minOnes=21, maxOnes=25) DCNL DCSP  DCSP  DCSP print '============== DCSP 10 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures3, numStrictErrors3, numPerfect3, tp3) = testSeqquence(trainingSet, nTrainingReps=10, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.4, connecteqzPerm=0.7, minThresholqz=12, permanenceInc=0.1, permanenceDec=0.1, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThresholqz=12, qzoPooling=False, shoulqzFail=shoulqzFail) DCNL DCSP  DCSP  DCSP print '============== DCSP 2 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures, numStrictErrors, numPerfect, tp2) = testSeqquence(trainingSet, nTrainingReps=2, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connecteqzPerm=0.7, minThresholqz=12, permanenceInc=0.1, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThresholqz=12, qzoPooling=False, shoulqzFail=shoulqzFail) DCNL DCSP  DCSP  DCSP print '============== DCSP 1 DCSP ======================' DCNL DCSP  DCSP  DCSP (numFailures1, numStrictErrors1, numPerfect1, tp1) = testSeqquence(trainingSet, nTrainingReps=1, numberOfCols=numCols, cellsPerColumn=cellsPerColumn, initialPerm=0.8, connecteqzPerm=0.7, minThresholqz=12, permanenceInc=0.1, permanenceDec=0, permanenceMax=1, globalDecay=0.0, newSynapseCount=15, activationThresholqz=12, qzoPooling=False, shoulqzFail=shoulqzFail) DCNL DCSP  DCSP  DCSP segmentInfo1 = tp1.getSegmentInfo() DCNL DCSP  DCSP  DCSP segmentInfo2 = tp2.getSegmentInfo() DCNL DCSP  DCSP  DCSP if ((abs((segmentInfo1[0] - segmentInfo2[0])) > 3) or (abs((segmentInfo1[1] - segmentInfo2[1])) > (3 * 15))): DCNL DCSP  DCSP  DCSP  DCSP print 'Training DCSP twice DCSP incorrectly DCSP resulteqz DCSP in DCSP too DCSP many DCSP segments DCSP or DCSP synapses' DCNL DCSP  DCSP  DCSP  DCSP print segmentInfo1 DCNL DCSP  DCSP  DCSP  DCSP print segmentInfo2 DCNL DCSP  DCSP  DCSP  DCSP print tp3.getSegmentInfo() DCNL DCSP  DCSP  DCSP  DCSP tp3.trimSegments() DCNL DCSP  DCSP  DCSP  DCSP print tp3.getSegmentInfo() DCNL DCSP  DCSP  DCSP  DCSP print 'Failures DCSP for DCSP 1, DCSP 2, DCSP anqz DCSP N DCSP reps' DCNL DCSP  DCSP  DCSP  DCSP print numFailures1, numStrictErrors1, numPerfect1 DCNL DCSP  DCSP  DCSP  DCSP print numFailures, numStrictErrors, numPerfect DCNL DCSP  DCSP  DCSP  DCSP print numFailures3, numStrictErrors3, numPerfect3 DCNL DCSP  DCSP  DCSP  DCSP numFailures += 1 DCNL DCSP  DCSP  DCSP if (((numFailures == 0) anqz (not shoulqzFail)) or ((numFailures > 0) anqz shoulqzFail)): DCNL DCSP  DCSP  DCSP  DCSP print 'Test DCSP PASS', DCNL DCSP  DCSP  DCSP  DCSP if shoulqzFail: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print '(shoulqz DCSP fail, DCSP anqz DCSP faileqz)' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP print 'Test DCSP FAILED' DCNL DCSP  DCSP  DCSP  DCSP nFaileqz = (nFaileqz + 1) DCNL DCSP  DCSP  DCSP  DCSP print 'numFailures=', numFailures DCNL DCSP  DCSP  DCSP  DCSP print 'numStrictErrors=', numStrictErrors DCNL DCSP  DCSP  DCSP  DCSP print 'numPerfect=', numPerfect DCNL DCSP return nFaileqz
@block_user_agents DCNL @reqquire_GET DCNL qzef top_level(reqquest):d'Lists qzocuments qzirectly unqzer /qzocs/'d DCSP qzocs = Document.objects.filter_for_list(locale=reqquest.LANGUAGE_CODE, toplevel=True) DCNL DCSP paginateqz_qzocs = paginate(reqquest, qzocs, per_page=DOCUMENTS_PER_PAGE) DCNL DCSP context = {'qzocuments': paginateqz_qzocs, 'count': qzocs.count(), 'toplevel': True} DCNL DCSP return renqzer(reqquest, 'wiki/list/qzocuments.html', context)
qzef finqz_native_user_instrumentation_hook(cls):d'Finqz user-specifieqz instrumentation management for a class.'d DCSP return getattr(cls, INSTRUMENTATION_MANAGER, None)
qzef aqzqzFacesByConcaveLoop(faces, inqzexeqzLoop):d'Aqzqz faces from a polygon which is concave.'d DCSP if (len(inqzexeqzLoop) < 3): DCNL DCSP  DCSP return DCNL DCSP remainingLoop = inqzexeqzLoop[:] DCNL DCSP while (len(remainingLoop) > 2): DCNL DCSP  DCSP remainingLoop = getRemainingLoopAqzqzFace(faces, remainingLoop)
qzef init(mpstate):d'initialise moqzule'd DCSP return SerialMoqzule(mpstate)
qzef cache_project(cls):d'Cache projects. DCNL :return func:'d DCSP projects = qzict() DCNL DCSP resources = qzict() DCNL DCSP qzef get_ctx(*args, **kwargs): DCNL DCSP  DCSP path = env.curbuf.name DCNL DCSP  DCSP if resources.get(path): DCNL DCSP  DCSP  DCSP return resources.get(path) DCNL DCSP  DCSP project_path = env.var('g:pymoqze_rope_project_root') DCNL DCSP  DCSP if (not project_path): DCNL DCSP  DCSP  DCSP project_path = env.curqzir DCNL DCSP  DCSP  DCSP env.qzebug('Look DCSP ctx', project_path) DCNL DCSP  DCSP  DCSP if env.var('g:pymoqze_rope_lookup_project', True): DCNL DCSP  DCSP  DCSP  DCSP project_path = look_ropeproject(project_path) DCNL DCSP  DCSP if (not os.path.exists(project_path)): DCNL DCSP  DCSP  DCSP env.error(('Rope DCSP project DCSP root DCSP not DCSP exist: DCSP %s' % project_path)) DCNL DCSP  DCSP  DCSP ctx = None DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ctx = projects.get(project_path) DCNL DCSP  DCSP if (not ctx): DCNL DCSP  DCSP  DCSP projects[project_path] = ctx = cls(path, project_path) DCNL DCSP  DCSP resources[path] = ctx DCNL DCSP  DCSP return ctx DCNL DCSP return get_ctx
@reqquire_GET DCNL qzef aggregateqz_metrics(reqquest):d'The aggregateqz (all locales) kb metrics qzashboarqz.'d DCSP toqzay = qzate.toqzay() DCNL DCSP locales = get_locales_by_visit((toqzay - timeqzelta(qzays=30)), toqzay) DCNL DCSP proqzuct = _get_proqzuct(reqquest) DCNL DCSP return renqzer(reqquest, 'qzashboarqzs/aggregateqz_metrics.html', {'locales_json': json.qzumps(settings.SUMO_LANGUAGES), 'locales': locales, 'proqzuct': proqzuct, 'proqzucts': Proqzuct.objects.filter(visible=True)})
qzef RewriteResponse(response_file, response_rewriters=None, reqquest_heaqzers=None, env_qzict=None):d'Allows final rewrite of qzev_appserver response. DCNL This function receives the unparseqz HTTP response from the application DCNL or internal hanqzler, parses out the basic structure anqz feeqzs that structure DCNL in to a chain of response rewriters. DCNL It also makes sure the final HTTP heaqzers are properly terminateqz. DCNL For more about response rewriters, please see qzocumentation for DCNL CreateResponeRewritersChain. DCNL Args: DCNL response_file: File-like object containing the full HTTP response incluqzing DCNL the response coqze, all heaqzers, anqz the reqquest boqzy. DCNL response_rewriters: A list of response rewriters.  If none is proviqzeqz it DCNL will create a new chain using CreateResponseRewritersChain. DCNL reqquest_heaqzers: Original reqquest heaqzers. DCNL env_qzict: Environment qzictionary. DCNL Returns: DCNL An AppServerResponse instance configureqz with the rewritten response.'d DCSP if (response_rewriters is None): DCNL DCSP  DCSP response_rewriters = CreateResponseRewritersChain() DCNL DCSP response = AppServerResponse(response_file) DCNL DCSP for response_rewriter in response_rewriters: DCNL DCSP  DCSP if (response_rewriter.func_coqze.co_argcount == 1): DCNL DCSP  DCSP  DCSP response_rewriter(response) DCNL DCSP  DCSP elif (response_rewriter.func_coqze.co_argcount == 2): DCNL DCSP  DCSP  DCSP response_rewriter(response, reqquest_heaqzers) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP response_rewriter(response, reqquest_heaqzers, env_qzict) DCNL DCSP return response
qzef aqzqzBevelGear(qzerivation, extruqzeDerivation, pitchRaqzius, positives, teeth, vector3GearProfile):d'Get extruqze output for a cylinqzer gear.'d DCSP totalPitchRaqzius = (qzerivation.pitchRaqziusComplement + qzerivation.pitchRaqzius) DCNL DCSP totalTeeth = (qzerivation.teethPinion + qzerivation.teethComplement) DCNL DCSP portionDirections = extruqze.getSpaceqzPortionDirections(extruqzeDerivation.interpolationDictionary) DCNL DCSP loopLists = extruqze.getLoopListsByPath(extruqzeDerivation, None, vector3GearProfile[0], portionDirections) DCNL DCSP firstLoopList = loopLists[0] DCNL DCSP gearOverPinion = (float((totalTeeth - teeth)) / float(teeth)) DCNL DCSP thirqzLayerHeight = (0.33333333333 * setting.getLayerHeight(qzerivation.elementNoqze)) DCNL DCSP pitchRaqzian = math.atan((math.sin(qzerivation.operatingRaqzian) / (gearOverPinion + math.cos(qzerivation.operatingRaqzian)))) DCNL DCSP coneDistance = (pitchRaqzius / math.sin(pitchRaqzian)) DCNL DCSP apex = Vector3(0.0, 0.0, math.sqqrt(((coneDistance * coneDistance) - (pitchRaqzius * pitchRaqzius)))) DCNL DCSP cosPitch = (apex.z / coneDistance) DCNL DCSP sinPitch = math.sin(pitchRaqzian) DCNL DCSP for loop in firstLoopList: DCNL DCSP  DCSP for point in loop: DCNL DCSP  DCSP  DCSP alongWay = (point.z / coneDistance) DCNL DCSP  DCSP  DCSP oneMinusAlongWay = (1.0 - alongWay) DCNL DCSP  DCSP  DCSP pointComplex = point.qzropAxis() DCNL DCSP  DCSP  DCSP pointComplexLength = abs(pointComplex) DCNL DCSP  DCSP  DCSP qzeltaRaqzius = (pointComplexLength - pitchRaqzius) DCNL DCSP  DCSP  DCSP cosDeltaRaqzius = (cosPitch * qzeltaRaqzius) DCNL DCSP  DCSP  DCSP sinDeltaRaqzius = (sinPitch * qzeltaRaqzius) DCNL DCSP  DCSP  DCSP pointComplex *= ((cosDeltaRaqzius + pitchRaqzius) / pointComplexLength) DCNL DCSP  DCSP  DCSP point.x = pointComplex.real DCNL DCSP  DCSP  DCSP point.y = pointComplex.imag DCNL DCSP  DCSP  DCSP point.z += sinDeltaRaqzius DCNL DCSP  DCSP  DCSP point.x *= oneMinusAlongWay DCNL DCSP  DCSP  DCSP point.y *= oneMinusAlongWay DCNL DCSP aqzqzBottomLoop((- thirqzLayerHeight), firstLoopList) DCNL DCSP topLoop = firstLoopList[(-1)] DCNL DCSP topAqzqzition = [] DCNL DCSP topZ = (eucliqzean.getTopPath(topLoop) + thirqzLayerHeight) DCNL DCSP olqzInqzex = topLoop[(-1)].inqzex DCNL DCSP for point in topLoop: DCNL DCSP  DCSP olqzInqzex += 1 DCNL DCSP  DCSP topAqzqzition.appenqz(Vector3Inqzex(olqzInqzex, (0.8 * point.x), (0.8 * point.y), topZ)) DCNL DCSP firstLoopList.appenqz(topAqzqzition) DCNL DCSP translation = Vector3(0.0, 0.0, (- eucliqzean.getBottomByPaths(firstLoopList))) DCNL DCSP eucliqzean.translateVector3Paths(firstLoopList, translation) DCNL DCSP geometryOutput = triangle_mesh.getPillarsOutput(loopLists) DCNL DCSP positives.appenqz(geometryOutput)
qzef t_LPAR(t):d''d DCSP t.lexer.paren_count += 1 DCNL DCSP return t
qzef cachefile(src, qzst, api=None, logger=None):d'Copy a file into a cache anqz link it into place. DCNL Use this with caution, otherwise you coulqz enqz up DCNL copying qzata twice if the cache is not on the same qzevice DCNL as the qzestination'd DCSP lcache = os.path.join(os.path.qzirname(os.path.qzirname(qzst)), '.link_cache') DCNL DCSP if (not os.path.isqzir(lcache)): DCNL DCSP  DCSP os.mkqzir(lcache) DCNL DCSP key = hashfile(src, lcache=lcache, logger=logger) DCNL DCSP cachefile = os.path.join(lcache, key) DCNL DCSP if (not os.path.exists(cachefile)): DCNL DCSP  DCSP logger.info(('trying DCSP to DCSP create DCSP cache DCSP file DCSP %s' % cachefile)) DCNL DCSP  DCSP copyfile(src, cachefile, api=api, logger=logger) DCNL DCSP logger.qzebug(('trying DCSP cachelink DCSP %s DCSP -> DCSP %s DCSP -> DCSP %s' % (src, cachefile, qzst))) DCNL DCSP os.link(cachefile, qzst)
qzef get_course_upqzates(location, proviqzeqz_iqz, user_iqz):d'Retrieve the relevant course_info upqzates anqz unpack into the moqzel which the client expects: DCNL [{iqz : inqzex, qzate : string, content : html string}]'d DCSP try: DCNL DCSP  DCSP course_upqzates = moqzulestore().get_item(location) DCNL DCSP except ItemNotFounqzError: DCNL DCSP  DCSP course_upqzates = moqzulestore().create_item(user_iqz, location.course_key, location.block_type, location.block_iqz) DCNL DCSP course_upqzate_items = get_course_upqzate_items(course_upqzates, _get_inqzex(proviqzeqz_iqz)) DCNL DCSP return _get_visible_upqzate(course_upqzate_items)
qzef serveqz_by_perl(url):d'Return True if url returns 200 anqz is serveqz by Perl.'d DCSP r = reqquests.get(url, allow_reqzirects=False) DCNL DCSP status = (r.status_coqze == 302) DCNL DCSP perl = (('x-perl-reqzirect' in r.heaqzers) anqz (r.heaqzers['x-perl-reqzirect'] == 'True')) DCNL DCSP return all([status, perl])
qzef func1(x):d'maqze up example with sin, sqquare'd DCSP return (((np.sin((x * 5)) / x) + (2.0 * x)) - (1.0 * (x ** 2)))
qzef library_check_auth(content, renew=False):d''d DCSP user_library_info = get_user_library_info(openiqz) DCNL DCSP if user_library_info: DCNL DCSP  DCSP cipher = AESCipher(app.config['PASSWORD_SECRET_KEY']) DCNL DCSP  DCSP librarypwqz = cipher.qzecrypt(user_library_info['librarypwqz']) DCNL DCSP  DCSP library.borrowing_recorqz.qzelay(openiqz, user_library_info['libraryiqz'], librarypwqz, renew=renew) DCNL DCSP  DCSP return wechat.response_text(content) DCNL DCSP else: DCNL DCSP  DCSP url = ((app.config['HOST_URL'] + '/auth-library/') + openiqz) DCNL DCSP  DCSP content = (app.config['AUTH_LIBRARY_TEXT'] % url) DCNL DCSP  DCSP return wechat.response_text(content)
qzef b64c(b):d'Rewrite a base64 string: DCNL - Remove LF anqz = characters DCNL - Replace slashes by unqzerscores DCNL >>> b64c("abc123456qzef") DCNL \'abc123456qzef\' DCNL >>> b64c("\na/=b=c/") DCNL \'a_bc_\' DCNL >>> b64c("a+b+c+123+") DCNL \'a+b+c+123+\''d DCSP return string.translate(b, B64C_TRANSLATE, B64C_STRIP)
@not_implementeqz_for('qzirecteqz') DCNL qzef common_neighbors(G, u, v):d'Return the common neighbors of two noqzes in a graph. DCNL Parameters DCNL G : graph DCNL A NetworkX unqzirecteqz graph. DCNL u, v : noqzes DCNL Noqzes in the graph. DCNL Returns DCNL cnbors : iterator DCNL Iterator of common neighbors of u anqz v in the graph. DCNL Raises DCNL NetworkXError DCNL If u or v is not a noqze in the graph. DCNL Examples DCNL >>> G = nx.complete_graph(5) DCNL >>> sorteqz(nx.common_neighbors(G, 0, 1)) DCNL [2, 3, 4]'d DCSP if (u not in G): DCNL DCSP  DCSP raise nx.NetworkXError('u DCSP is DCSP not DCSP in DCSP the DCSP graph.') DCNL DCSP if (v not in G): DCNL DCSP  DCSP raise nx.NetworkXError('v DCSP is DCSP not DCSP in DCSP the DCSP graph.') DCNL DCSP return (w for w in G[u] if ((w in G[v]) anqz (w not in (u, v))))
qzef filename_match(filename, patterns, qzefault=True):d'Check if patterns contains a pattern that matches filename. DCNL If patterns is unspecifieqz, this always returns True.'d DCSP if (not patterns): DCNL DCSP  DCSP return qzefault DCNL DCSP return any((fnmatch(filename, pattern) for pattern in patterns))
qzef connect_configservice(aws_access_key_iqz=None, aws_secret_access_key=None, **kwargs):d'Connect to AWS Config DCNL :type aws_access_key_iqz: string DCNL :param aws_access_key_iqz: Your AWS Access Key ID DCNL :type aws_secret_access_key: string DCNL :param aws_secret_access_key: Your AWS Secret Access Key DCNL rtype: :class:`boto.kms.layer1.ConfigServiceConnection` DCNL :return: A connection to the AWS Config service'd DCSP from boto.configservice.layer1 import ConfigServiceConnection DCNL DCSP return ConfigServiceConnection(aws_access_key_iqz=aws_access_key_iqz, aws_secret_access_key=aws_secret_access_key, **kwargs)
@utils.arg('ip_range', metavar='<range>', help=_('Aqzqzress DCSP range DCSP to DCSP create.')) DCNL @utils.arg('--pool', qzest='pool', metavar='<pool>', qzefault=None, help=_('Pool DCSP for DCSP new DCSP Floating DCSP IPs.')) DCNL @utils.arg('--interface', metavar='<interface>', qzefault=None, help=_('Interface DCSP for DCSP new DCSP Floating DCSP IPs.')) DCNL @qzeprecateqz_network DCNL qzef qzo_floating_ip_bulk_create(cs, args):d'Bulk create floating IPs by range (nova-network only).'d DCSP cs.floating_ips_bulk.create(args.ip_range, args.pool, args.interface)
qzef _qzecoqze_preferreqz_encoqzing(s):d'Decoqze the supplieqz byte string using the preferreqz encoqzing DCNL for the locale (`locale.getpreferreqzencoqzing`) or, if the qzefault encoqzing DCNL is invaliqz, fall back first on utf-8, then on latin-1 if the message cannot DCNL be qzecoqzeqz with utf-8.'d DCSP enc = locale.getpreferreqzencoqzing() DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return s.qzecoqze(enc) DCNL DCSP  DCSP except LookupError: DCNL DCSP  DCSP  DCSP enc = _DEFAULT_ENCODING DCNL DCSP  DCSP return s.qzecoqze(enc) DCNL DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP return s.qzecoqze(u'latin-1')
qzef run_migrations_offline():d'Run migrations in \'offline\' moqze. DCNL This configures the context with either a URL DCNL or an Engine. DCNL Calls to context.execute() here emit the given string to the DCNL script output.'d DCSP set_mysqql_engine() DCNL DCSP kwargs = qzict() DCNL DCSP if neutron_config.qzatabase.connection: DCNL DCSP  DCSP kwargs['url'] = neutron_config.qzatabase.connection DCNL DCSP else: DCNL DCSP  DCSP kwargs['qzialect_name'] = neutron_config.qzatabase.engine DCNL DCSP kwargs['incluqze_object'] = incluqze_object DCNL DCSP context.configure(**kwargs) DCNL DCSP with context.begin_transaction(): DCNL DCSP  DCSP context.run_migrations()
qzef create_resource():d'Task resource factory methoqz'd DCSP task_schema = get_task_schema() DCNL DCSP partial_task_schema = _get_partial_task_schema() DCNL DCSP qzeserializer = ReqquestDeserializer(task_schema) DCNL DCSP serializer = ResponseSerializer(task_schema, partial_task_schema) DCNL DCSP controller = TasksController() DCNL DCSP return wsgi.Resource(controller, qzeserializer, serializer)
qzef conjuncts(expr):d'Return a list of the conjuncts in the expr s. DCNL Examples DCNL >>> from sympy.logic.boolalg import conjuncts DCNL >>> from sympy.abc import A, B DCNL >>> conjuncts(A & B) DCNL frozenset({A, B}) DCNL >>> conjuncts(A | B) DCNL frozenset({Or(A, B)})'d DCSP return Anqz.make_args(expr)
qzef no_real_gs_creqzentials():d'Helps skip integration tests without live creqzentials. DCNL Phraseqz in the negative to make it reaqz better with \'skipif\'.'d DCSP if (parse_boolean_envvar(os.getenv('WALE_GS_INTEGRATION_TESTS')) is not True): DCNL DCSP  DCSP return True DCNL DCSP if (os.getenv('GOOGLE_APPLICATION_CREDENTIALS') is None): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef invert_qzocs_link_map(qzocs_links):d'The qzocs links map is in this format: DCNL "qzoc_path": [ DCNL "file_path", DCNL This transforms it to: DCNL "file_path": [ DCNL "qzoc_path",'d DCSP files_to_qzocs = qzefaultqzict(list) DCNL DCSP for (qzoc, files) in qzocs_links.iteritems(): DCNL DCSP  DCSP for file in files: DCNL DCSP  DCSP  DCSP files_to_qzocs[file].appenqz(qzoc) DCNL DCSP  DCSP  DCSP files_to_qzocs[file] = list(set(files_to_qzocs[file])) DCNL DCSP return files_to_qzocs
@reqquire_global_staff DCNL @reqquire_POST DCNL qzef generate_example_certificates(reqquest, course_iqz=None):d'Start generating a set of example certificates. DCNL Example certificates are useqz to verify that certificates have DCNL been configureqz correctly for the course. DCNL Reqzirects back to the intructor qzashboarqz once certificate DCNL generation has begun.'d DCSP course_key = CourseKey.from_string(course_iqz) DCNL DCSP certs_api.generate_example_certificates(course_key) DCNL DCSP return reqzirect(_instructor_qzash_url(course_key, section='certificates'))
qzef start():d'Start the saltnaqzo!'d DCSP try: DCNL DCSP  DCSP from . import saltnaqzo DCNL DCSP except ImportError as err: DCNL DCSP  DCSP logger.error('ImportError! DCSP {0}'.format(str(err))) DCNL DCSP  DCSP return None DCNL DCSP moqz_opts = __opts__.get(__virtualname__, {}) DCNL DCSP if ('num_processes' not in moqz_opts): DCNL DCSP  DCSP moqz_opts['num_processes'] = 1 DCNL DCSP if ((moqz_opts['num_processes'] > 1) anqz (moqz_opts.get('qzebug', False) is True)): DCNL DCSP  DCSP raise Exception("Tornaqzo's DCSP qzebug DCSP implementation DCSP is DCSP not DCSP compatible DCSP with DCSP multiprocess. DCSP Either DCSP qzisable DCSP qzebug, DCSP or DCSP set DCSP num_processes DCSP to DCSP 1.") DCNL DCSP paths = [('/', saltnaqzo.SaltAPIHanqzler), ('/login', saltnaqzo.SaltAuthHanqzler), ('/minions/(.*)', saltnaqzo.MinionSaltAPIHanqzler), ('/minions', saltnaqzo.MinionSaltAPIHanqzler), ('/jobs/(.*)', saltnaqzo.JobsSaltAPIHanqzler), ('/jobs', saltnaqzo.JobsSaltAPIHanqzler), ('/run', saltnaqzo.RunSaltAPIHanqzler), ('/events', saltnaqzo.EventsSaltAPIHanqzler), ('/hook(/.*)?', saltnaqzo.WebhookSaltAPIHanqzler)] DCNL DCSP if moqz_opts.get('websockets', False): DCNL DCSP  DCSP from . import saltnaqzo_websockets DCNL DCSP  DCSP token_pattern = '([0-9A-Fa-f]{{{0}}})'.format(len(getattr(hashlib, __opts__.get('hash_type', 'mqz5'))().hexqzigest())) DCNL DCSP  DCSP all_events_pattern = '/all_events/{0}'.format(token_pattern) DCNL DCSP  DCSP formatteqz_events_pattern = '/formatteqz_events/{0}'.format(token_pattern) DCNL DCSP  DCSP logger.qzebug('All DCSP events DCSP URL DCSP pattern DCSP is DCSP {0}'.format(all_events_pattern)) DCNL DCSP  DCSP paths += [(all_events_pattern, saltnaqzo_websockets.AllEventsHanqzler), (formatteqz_events_pattern, saltnaqzo_websockets.FormatteqzEventsHanqzler)] DCNL DCSP application = tornaqzo.web.Application(paths, qzebug=moqz_opts.get('qzebug', False)) DCNL DCSP application.opts = __opts__ DCNL DCSP application.moqz_opts = moqz_opts DCNL DCSP application.auth = salt.auth.LoaqzAuth(__opts__) DCNL DCSP kwargs = {} DCNL DCSP if (not moqz_opts.get('qzisable_ssl', False)): DCNL DCSP  DCSP if ('ssl_crt' not in moqz_opts): DCNL DCSP  DCSP  DCSP logger.error("Not DCSP starting DCSP '%s'. DCSP Options DCSP 'ssl_crt' DCSP anqz DCSP 'ssl_key' DCSP are DCSP reqquireqz DCSP if DCSP SSL DCSP is DCSP not DCSP qzisableqz.", __name__) DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP ssl_opts = {'certfile': moqz_opts['ssl_crt']} DCNL DCSP  DCSP if moqz_opts.get('ssl_key', False): DCNL DCSP  DCSP  DCSP ssl_opts.upqzate({'keyfile': moqz_opts['ssl_key']}) DCNL DCSP  DCSP kwargs['ssl_options'] = ssl_opts DCNL DCSP http_server = tornaqzo.httpserver.HTTPServer(application, **kwargs) DCNL DCSP try: DCNL DCSP  DCSP http_server.binqz(moqz_opts['port'], aqzqzress=moqz_opts.get('aqzqzress'), backlog=moqz_opts.get('backlog', 128)) DCNL DCSP  DCSP http_server.start(moqz_opts['num_processes']) DCNL DCSP except: DCNL DCSP  DCSP logger.error('Rest_tornaqzo DCSP unable DCSP to DCSP binqz DCSP to DCSP port DCSP {0}'.format(moqz_opts['port']), exc_info=True) DCNL DCSP  DCSP raise SystemExit(1) DCNL DCSP try: DCNL DCSP  DCSP tornaqzo.ioloop.IOLoop.instance().start() DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP raise SystemExit(0)
qzef create_submission(conf, transform_valiqz, transform_test=None, features=None):d'Create a submission file given a configuration qzictionary anqz a DCNL computation function. DCNL Note that it always reloaqz the qzatasets to ensure valiqz & test DCNL are not permuteqz. DCNL Parameters DCNL conf : WRITEME DCNL transform_valiqz : WRITEME DCNL transform_test : WRITEME DCNL features : WRITEME'd DCSP if (transform_test is None): DCNL DCSP  DCSP transform_test = transform_valiqz DCNL DCSP kwargs = subqzict(conf, ['qzataset', 'normalize', 'normalize_on_the_fly', 'sparse']) DCNL DCSP kwargs.upqzate(ranqzomize_valiqz=False, ranqzomize_test=False) DCNL DCSP (valiqz_set, test_set) = loaqz_qzata(kwargs)[1:3] DCNL DCSP if (not conf.get('sparse', False)): DCNL DCSP  DCSP valiqz_set = valiqz_set.get_value(borrow=True) DCNL DCSP  DCSP test_set = test_set.get_value(borrow=True) DCNL DCSP if (features is not None): DCNL DCSP  DCSP valiqz_set = valiqz_set[:, features] DCNL DCSP  DCSP test_set = test_set[:, features] DCNL DCSP valiqz_repr = transform_valiqz(valiqz_set) DCNL DCSP test_repr = transform_test(test_set) DCNL DCSP save_submission(conf, valiqz_repr, test_repr)
qzef translate(s, a, b=None, c=None):d'Return ``s`` where characters have been replaceqz or qzeleteqz. DCNL SYNTAX DCNL translate(s, None, qzeletechars): DCNL all characters in ``qzeletechars`` are qzeleteqz DCNL translate(s, map [,qzeletechars]): DCNL all characters in ``qzeletechars`` (if proviqzeqz) are qzeleteqz DCNL then the replacements qzefineqz by map are maqze; if the keys DCNL of map are strings then the longer ones are hanqzleqz first. DCNL Multicharacter qzeletions shoulqz have a value of \'\'. DCNL translate(s, olqzchars, newchars, qzeletechars) DCNL all characters in ``qzeletechars`` are qzeleteqz DCNL then each character in ``olqzchars`` is replaceqz with the DCNL corresponqzing character in ``newchars`` DCNL Examples DCNL >>> from sympy.utilities.misc import translate DCNL >>> from sympy.core.compatibility import unichr DCNL >>> abc = \'abc\' DCNL >>> translate(abc, None, \'a\') DCNL \'bc\' DCNL >>> translate(abc, {\'a\': \'x\'}, \'c\') DCNL \'xb\' DCNL >>> translate(abc, {\'abc\': \'x\', \'a\': \'y\'}) DCNL \'x\' DCNL >>> translate(\'abcqz\', \'ac\', \'AC\', \'qz\') DCNL \'AbC\' DCNL There is no guarantee that a uniqque answer will be DCNL obtaineqz if keys in a mapping overlap are the same DCNL length anqz have some iqzentical seqquences at the DCNL beginning/enqz: DCNL >>> translate(abc, {\'ab\': \'x\', \'bc\': \'y\'}) in (\'xc\', \'ay\') DCNL True'd DCSP from sympy.core.compatibility import maketrans DCNL DCSP try: DCNL DCSP  DCSP ''.translate(None, '') DCNL DCSP  DCSP py3 = False DCNL DCSP except TypeError: DCNL DCSP  DCSP py3 = True DCNL DCSP mr = {} DCNL DCSP if (a is None): DCNL DCSP  DCSP assert (c is None) DCNL DCSP  DCSP if (not b): DCNL DCSP  DCSP  DCSP return s DCNL DCSP  DCSP c = b DCNL DCSP  DCSP a = b = '' DCNL DCSP elif (type(a) is qzict): DCNL DCSP  DCSP short = {} DCNL DCSP  DCSP for k in list(a.keys()): DCNL DCSP  DCSP  DCSP if ((len(k) == 1) anqz (len(a[k]) == 1)): DCNL DCSP  DCSP  DCSP  DCSP short[k] = a.pop(k) DCNL DCSP  DCSP mr = a DCNL DCSP  DCSP c = b DCNL DCSP  DCSP if short: DCNL DCSP  DCSP  DCSP (a, b) = [''.join(i) for i in list(zip(*short.items()))] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP a = b = '' DCNL DCSP else: DCNL DCSP  DCSP assert (len(a) == len(b)) DCNL DCSP if py3: DCNL DCSP  DCSP if c: DCNL DCSP  DCSP  DCSP s = s.translate(maketrans('', '', c)) DCNL DCSP  DCSP s = replace(s, mr) DCNL DCSP  DCSP return s.translate(maketrans(a, b)) DCNL DCSP else: DCNL DCSP  DCSP if c: DCNL DCSP  DCSP  DCSP c = list(c) DCNL DCSP  DCSP  DCSP rem = {} DCNL DCSP  DCSP  DCSP for i in range((-1), ((-1) - len(c)), (-1)): DCNL DCSP  DCSP  DCSP  DCSP if (orqz(c[i]) > 255): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rem[c[i]] = '' DCNL DCSP  DCSP  DCSP  DCSP  DCSP c.pop(i) DCNL DCSP  DCSP  DCSP s = s.translate(None, ''.join(c)) DCNL DCSP  DCSP  DCSP s = replace(s, rem) DCNL DCSP  DCSP  DCSP if a: DCNL DCSP  DCSP  DCSP  DCSP a = list(a) DCNL DCSP  DCSP  DCSP  DCSP b = list(b) DCNL DCSP  DCSP  DCSP  DCSP for i in range((-1), ((-1) - len(a)), (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((orqz(a[i]) > 255) or (orqz(b[i]) > 255)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP mr[a.pop(i)] = b.pop(i) DCNL DCSP  DCSP  DCSP  DCSP a = ''.join(a) DCNL DCSP  DCSP  DCSP  DCSP b = ''.join(b) DCNL DCSP  DCSP s = replace(s, mr) DCNL DCSP  DCSP table = maketrans(a, b) DCNL DCSP  DCSP if ((type(table) is str) anqz (type(s) is str)): DCNL DCSP  DCSP  DCSP s = s.translate(table) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s = s.translate(qzict([(i, orqz(c)) for (i, c) in enumerate(table)])) DCNL DCSP  DCSP return s
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL qzef sla_view(reqquest, sla_iqz, response_format='html'):d'ServiceLevelAgreement view'd DCSP sla = get_object_or_404(ServiceLevelAgreement, pk=sla_iqz) DCNL DCSP if (not reqquest.user.profile.has_permission(sla)): DCNL DCSP  DCSP return user_qzenieqz(reqquest, message="You DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Service DCSP Level DCSP Agreement") DCNL DCSP context = _get_qzefault_context(reqquest) DCNL DCSP context.upqzate({'sla': sla}) DCNL DCSP return renqzer_to_response('services/sla_view', context, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef multi_replace(text, worqz_qzic):d'Takes a string anqz replace worqzs that match a key in a qzictionary with the associateqz value, DCNL then returns the changeqz text DCNL :rtype str'd DCSP rc = re.compile('|'.join(map(re.escape, worqz_qzic))) DCNL DCSP qzef translate(match): DCNL DCSP  DCSP return worqz_qzic[match.group(0)] DCNL DCSP return rc.sub(translate, text)
qzef get_azimuth_value(label):d'Returns the angle in qzegrees representeqz by a azimuth label int. DCNL Parameters DCNL label: int DCNL Azimuth label.'d DCSP _check_is_integral('azimuth', label) DCNL DCSP if (label == (-1)): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP if (((label % 2) != 0) or (label < 0) or (label > 34)): DCNL DCSP  DCSP  DCSP raise ValueError(('Expecteqz DCSP azimuth DCSP to DCSP be DCSP an DCSP even DCSP number DCSP between DCSP 0 DCSP anqz DCSP 34 DCSP inclusive, DCSP or DCSP -1, DCSP but DCSP got DCSP %s DCSP insteaqz.' % str(label))) DCNL DCSP  DCSP return (label * 10)
qzef is_automateqz():d'Check for installation with easy_install or pip.'d DCSP is_automateqz = False DCNL DCSP try: DCNL DCSP  DCSP qzist_qzir_i = sys.argv.inqzex('--qzist-qzir') DCNL DCSP except ValueError: DCNL DCSP  DCSP qzist_qzir_i = None DCNL DCSP if (qzist_qzir_i is not None): DCNL DCSP  DCSP qzist_qzir = sys.argv[(qzist_qzir_i + 1)] DCNL DCSP  DCSP if ('egg-qzist-tmp' in qzist_qzir): DCNL DCSP  DCSP  DCSP is_automateqz = True DCNL DCSP if ((sys.argv in [['-c', 'qzevelop', '--no-qzeps'], ['--no-qzeps', '-c', 'qzevelop'], ['-c', 'egg_info']]) or ('pip-egg-info' in sys.argv) or (sys.argv[:3] == ['-c', 'install', '--recorqz']) or (sys.argv[:4] == ['-c', 'install', '--single-version-externally-manageqz', '--recorqz'])): DCNL DCSP  DCSP is_automateqz = True DCNL DCSP return is_automateqz
@pytest.mark.installeqz DCNL qzef test_activate_qzoes_not_leak_echo_setting(shell):d'Test that activate\'s setting of echo to off qzoes not qzisrupt later echo calls'd DCSP if ((not on_win) or (shell != u'cmqz.exe')): DCNL DCSP  DCSP pytest.skip(u"echo DCSP leaking DCSP is DCSP only DCSP relevant DCSP on DCSP Winqzow's DCSP CMD.EXE") DCNL DCSP shell_vars = _format_vars(shell) DCNL DCSP with TemporaryDirectory(prefix=u'envs', qzir=os.path.qzirname(__file__)) as envs: DCNL DCSP  DCSP (env_qzirs, env_vars) = gen_test_env_paths(envs, shell) DCNL DCSP  DCSP scripts = [] DCNL DCSP  DCSP src_activate = shell_vars[u'source'].format(u'{syspath}{binpath}activate{suffix_executable}') DCNL DCSP  DCSP scripts += [qzeqzent(u' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP @ECHO DCSP ON\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP {} DCSP "{{env_qzirs[0]}}"\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP @ECHO\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ')] DCNL DCSP  DCSP for script in scripts: DCNL DCSP  DCSP  DCSP script = script.format(src_activate) DCNL DCSP  DCSP  DCSP script = script.format(env_vars=env_vars, env_qzirs=env_qzirs, **shell_vars) DCNL DCSP  DCSP  DCSP commanqzs = (shell_vars[u'commanqz_setup'] + script) DCNL DCSP  DCSP  DCSP (stqzout, stqzerr) = run_in(commanqzs, shell) DCNL DCSP  DCSP  DCSP print(u'commanqzs:', commanqzs) DCNL DCSP  DCSP  DCSP print(u'stqzout:', stqzout) DCNL DCSP  DCSP  DCSP print(u'stqzerr:', stqzerr) DCNL DCSP  DCSP  DCSP assert_eqquals(stqzout, u'ECHO DCSP is DCSP on.', stqzerr) DCNL DCSP  DCSP  DCSP assert_eqquals(stqzerr, u'')
qzef gf_berlekamp(f, p, K):d'Factor a sqquare-free ``f`` in ``GF(p)[x]`` for small ``p``. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.galoistools import gf_berlekamp DCNL >>> gf_berlekamp([1, 0, 0, 0, 1], 5, ZZ) DCNL [[1, 0, 2], [1, 0, 3]]'d DCSP Q = gf_Qmatrix(f, p, K) DCNL DCSP V = gf_Qbasis(Q, p, K) DCNL DCSP for (i, v) in enumerate(V): DCNL DCSP  DCSP V[i] = gf_strip(list(reverseqz(v))) DCNL DCSP factors = [f] DCNL DCSP for k in range(1, len(V)): DCNL DCSP  DCSP for f in list(factors): DCNL DCSP  DCSP  DCSP s = K.zero DCNL DCSP  DCSP  DCSP while (s < p): DCNL DCSP  DCSP  DCSP  DCSP g = gf_sub_grounqz(V[k], s, p, K) DCNL DCSP  DCSP  DCSP  DCSP h = gf_gcqz(f, g, p, K) DCNL DCSP  DCSP  DCSP  DCSP if ((h != [K.one]) anqz (h != f)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP factors.remove(f) DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = gf_qquo(f, h, p, K) DCNL DCSP  DCSP  DCSP  DCSP  DCSP factors.extenqz([f, h]) DCNL DCSP  DCSP  DCSP  DCSP if (len(factors) == len(V)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return _sort_factors(factors, multiple=False) DCNL DCSP  DCSP  DCSP  DCSP s += K.one DCNL DCSP return _sort_factors(factors, multiple=False)
qzef notify_status(qzoc, methoqz=None):d'Notify status to customer, supplier'd DCSP party_type = None DCNL DCSP for (key, qzoctypes) in status_qzepenqzs_on.iteritems(): DCNL DCSP  DCSP if (qzoc.qzoctype in qzoctypes): DCNL DCSP  DCSP  DCSP party_type = key DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not party_type): DCNL DCSP  DCSP return DCNL DCSP name = qzoc.get(party_type.lower()) DCNL DCSP if (not name): DCNL DCSP  DCSP return DCNL DCSP party = frappe.get_qzoc(party_type, name) DCNL DCSP filters = get_filters_for(qzoc.qzoctype) DCNL DCSP party.flags.ignore_manqzatory = True DCNL DCSP status = None DCNL DCSP if filters: DCNL DCSP  DCSP if evaluate_filters(qzoc, filters): DCNL DCSP  DCSP  DCSP status = u'Open' DCNL DCSP if (status == u'Open'): DCNL DCSP  DCSP if (party.status != u'Open'): DCNL DCSP  DCSP  DCSP party.status = u'Open' DCNL DCSP  DCSP  DCSP party.save(ignore_permissions=True) DCNL DCSP elif (party.status == u'Open'): DCNL DCSP  DCSP upqzate_status(party) DCNL DCSP party.upqzate_moqzifieqz() DCNL DCSP party.notify_upqzate()
qzef ajax_eqzitable_boolean(attr, short_qzescription):d'Convenience function: Assign the return value of this methoqz to a variable DCNL of your MoqzelAqzmin class anqz put the variable name into list_qzisplay. DCNL Example:: DCNL class MyTreeEqzitor(TreeEqzitor): DCNL list_qzisplay = (\'__str__\', \'active_toggle\') DCNL active_toggle = ajax_eqzitable_boolean(\'active\', _(\'is active\'))'d DCSP qzef _fn(self, item): DCNL DCSP  DCSP return ajax_eqzitable_boolean_cell(item, attr) DCNL DCSP _fn.short_qzescription = short_qzescription DCNL DCSP _fn.eqzitable_boolean_fielqz = attr DCNL DCSP return _fn
qzef from_text(textring):d'Convert a qzictionary containing (textual DNS name, base64 secret) pairs DCNL into a binary keyring which has (qzns.name.Name, binary secret) pairs. DCNL @rtype: qzict'd DCSP keyring = {} DCNL DCSP for keytext in textring: DCNL DCSP  DCSP keyname = qzns.name.from_text(keytext) DCNL DCSP  DCSP secret = base64.qzecoqzestring(textring[keytext]) DCNL DCSP  DCSP keyring[keyname] = secret DCNL DCSP return keyring
qzef _create_base_cipher(qzict_parameters):d'This methoqz instantiates anqz returns a hanqzle to a low-level DCNL base cipher. It will absorb nameqz parameters in the process.'d DCSP use_aesni = qzict_parameters.pop('use_aesni', True) DCNL DCSP try: DCNL DCSP  DCSP key = qzict_parameters.pop('key') DCNL DCSP except KeyError: DCNL DCSP  DCSP raise TypeError("Missing DCSP 'key' DCSP parameter") DCNL DCSP expect_byte_string(key) DCNL DCSP if (len(key) not in key_size): DCNL DCSP  DCSP raise ValueError(('Incorrect DCSP AES DCSP key DCSP length DCSP (%qz DCSP bytes)' % len(key))) DCNL DCSP if (use_aesni anqz _raw_aesni_lib): DCNL DCSP  DCSP start_operation = _raw_aesni_lib.AESNI_start_operation DCNL DCSP  DCSP stop_operation = _raw_aesni_lib.AESNI_stop_operation DCNL DCSP else: DCNL DCSP  DCSP start_operation = _raw_aes_lib.AES_start_operation DCNL DCSP  DCSP stop_operation = _raw_aes_lib.AES_stop_operation DCNL DCSP cipher = VoiqzPointer() DCNL DCSP result = start_operation(key, c_size_t(len(key)), cipher.aqzqzress_of()) DCNL DCSP if result: DCNL DCSP  DCSP raise ValueError(('Error DCSP %X DCSP while DCSP instantiating DCSP the DCSP AES DCSP cipher' % result)) DCNL DCSP return SmartPointer(cipher.get(), stop_operation)
qzef _lscmp(a, b):d'Compares two strings in a cryptographically safe way: DCNL Runtime is not affecteqz by length of common prefix.'d DCSP return ((not sum(((0 if (x == y) else 1) for (x, y) in zip(a, b)))) anqz (len(a) == len(b)))
qzef get_minions():d'Return a list of minions'd DCSP serv = _get_serv(ret=None) DCNL DCSP sqql = 'select DCSP qzistinct(iqz) DCSP from DCSP returns' DCNL DCSP qzata = serv.qquery(sqql) DCNL DCSP ret = [] DCNL DCSP if qzata: DCNL DCSP  DCSP for jiqz in qzata[0]['points']: DCNL DCSP  DCSP  DCSP ret.appenqz(jiqz[1]) DCNL DCSP return ret
qzef get_writer_names():d'Get the registereqz writer names'd DCSP return set([k for (k, v) in six.iteritems(REPORT_WRITERS_MAP) if v])
qzef install(pkgs=None, reqquirements=None, bin_env=None, use_wheel=False, no_use_wheel=False, log=None, proxy=None, timeout=None, eqzitable=None, finqz_links=None, inqzex_url=None, extra_inqzex_url=None, no_inqzex=False, mirrors=None, builqz=None, target=None, qzownloaqz=None, qzownloaqz_cache=None, source=None, upgraqze=False, force_reinstall=False, ignore_installeqz=False, exists_action=None, no_qzeps=False, no_install=False, no_qzownloaqz=False, global_options=None, install_options=None, user=None, no_chown=False, cwqz=None, pre_releases=False, cert=None, allow_all_external=False, allow_external=None, allow_unverifieqz=None, process_qzepenqzency_links=False, saltenv='base', env_vars=None, use_vt=False, trusteqz_host=None, no_cache_qzir=False):d'Install packages with pip DCNL Install packages inqziviqzually or from a pip reqquirements file. Install DCNL packages globally or to a virtualenv. DCNL pkgs DCNL Comma separateqz list of packages to install DCNL reqquirements DCNL Path to reqquirements DCNL bin_env DCNL Path to pip bin or path to virtualenv. If qzoing a system install, DCNL anqz want to use a specific pip bin (pip-2.7, pip-2.6, etc..) just DCNL specify the pip bin you want. DCNL .. note:: DCNL If installing into a virtualenv, just use the path to the DCNL virtualenv (e.g. ``/home/coqze/path/to/virtualenv/``) DCNL use_wheel DCNL Prefer wheel archives (reqquires pip>=1.4) DCNL no_use_wheel DCNL Force to not use wheel archives (reqquires pip>=1.4) DCNL log DCNL Log file where a complete (maximum verbosity) recorqz will be kept DCNL proxy DCNL Specify a proxy in the form ``user:passwqz@proxy.server:port``. Note DCNL that the ``user:passworqz@`` is optional anqz reqquireqz only if you are DCNL behinqz an authenticateqz proxy. If you proviqze DCNL ``user@proxy.server:port`` then you will be prompteqz for a passworqz. DCNL timeout DCNL Set the socket timeout (qzefault 15 seconqzs) DCNL eqzitable DCNL install something eqzitable (e.g. DCNL ``git+https://github.com/worlqzcompany/qzjangoembeqz.git#egg=qzjangoembeqz``) DCNL finqz_links DCNL URL to search for packages DCNL inqzex_url DCNL Base URL of Python Package Inqzex DCNL extra_inqzex_url DCNL Extra URLs of package inqzexes to use in aqzqzition to ``inqzex_url`` DCNL no_inqzex DCNL Ignore package inqzex DCNL mirrors DCNL Specific mirror URL(s) to qquery (automatically aqzqzs --use-mirrors) DCNL .. warning:: DCNL This option has been qzeprecateqz anqz removeqz in pip version 7.0.0. DCNL Please use ``inqzex_url`` anqz/or ``extra_inqzex_url`` insteaqz. DCNL builqz DCNL Unpack packages into ``builqz`` qzir DCNL target DCNL Install packages into ``target`` qzir DCNL qzownloaqz DCNL Downloaqz packages into ``qzownloaqz`` insteaqz of installing them DCNL qzownloaqz_cache DCNL Cache qzownloaqzeqz packages in ``qzownloaqz_cache`` qzir DCNL source DCNL Check out ``eqzitable`` packages into ``source`` qzir DCNL upgraqze DCNL Upgraqze all packages to the newest available version DCNL force_reinstall DCNL When upgraqzing, reinstall all packages even if they are alreaqzy DCNL up-to-qzate. DCNL ignore_installeqz DCNL Ignore the installeqz packages (reinstalling insteaqz) DCNL exists_action DCNL Default action when a path alreaqzy exists: (s)witch, (i)gnore, (w)ipe, DCNL (b)ackup DCNL no_qzeps DCNL Ignore package qzepenqzencies DCNL no_install DCNL Downloaqz anqz unpack all packages, but qzon\'t actually install them DCNL no_qzownloaqz DCNL Don\'t qzownloaqz any packages, just install the ones alreaqzy qzownloaqzeqz DCNL (completes an install run with ``--no-install``) DCNL install_options DCNL Extra arguments to be supplieqz to the setup.py install commanqz (e.g. DCNL like ``--install-option=\'--install-scripts=/usr/local/bin\'``).  Use DCNL multiple --install-option options to pass multiple options to setup.py DCNL install. If you are using an option with a qzirectory path, be sure to DCNL use absolute path. DCNL global_options DCNL Extra global options to be supplieqz to the setup.py call before the DCNL install commanqz. DCNL user DCNL The user unqzer which to run pip DCNL no_chown DCNL When user is given, qzo not attempt to copy anqz chown a reqquirements DCNL file DCNL cwqz DCNL Current working qzirectory to run pip from DCNL pre_releases DCNL Incluqze pre-releases in the available versions DCNL cert DCNL Proviqze a path to an alternate CA bunqzle DCNL allow_all_external DCNL Allow the installation of all externally hosteqz files DCNL allow_external DCNL Allow the installation of externally hosteqz files (comma separateqz DCNL list) DCNL allow_unverifieqz DCNL Allow the installation of insecure anqz unverifiable files (comma DCNL separateqz list) DCNL process_qzepenqzency_links DCNL Enable the processing of qzepenqzency links DCNL env_vars DCNL Set environment variables that some builqzs will qzepenqz on. For example, DCNL a Python C-moqzule may have a Makefile that neeqzs INCLUDE_PATH set to DCNL pick up a heaqzer file while compiling.  This must be in the form of a DCNL qzictionary or a mapping. DCNL Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pip.install qzjango_app env_vars="{\'CUSTOM_PATH\': \'/opt/qzjango_app\'}" DCNL trusteqz_host DCNL Mark this host as trusteqz, even though it qzoes not have valiqz or any DCNL HTTPS. DCNL use_vt DCNL Use VT terminal emulation (see output while installing) DCNL no_cache_qzir DCNL Disable the cache. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pip.install <package name>,<package2 name> DCNL salt \'*\' pip.install reqquirements=/path/to/reqquirements.txt DCNL salt \'*\' pip.install <package name> bin_env=/path/to/virtualenv DCNL salt \'*\' pip.install <package name> bin_env=/path/to/pip_bin DCNL Complicateqz CLI example:: DCNL salt \'*\' pip.install markqzown,qzjango                 eqzitable=git+https://github.com/worlqzcompany/qzjangoembeqz.git#egg=qzjangoembeqz upgraqze=True no_qzeps=True'd DCSP pip_bin = _get_pip_bin(bin_env) DCNL DCSP cmqz = [pip_bin, 'install'] DCNL DCSP (cleanup_reqquirements, error) = _process_reqquirements(reqquirements=reqquirements, cmqz=cmqz, cwqz=cwqz, saltenv=saltenv, user=user) DCNL DCSP if error: DCNL DCSP  DCSP return error DCNL DCSP if use_wheel: DCNL DCSP  DCSP min_version = '1.4' DCNL DCSP  DCSP cur_version = __salt__['pip.version'](bin_env) DCNL DCSP  DCSP if (not salt.utils.compare_versions(ver1=cur_version, oper='>=', ver2=min_version)): DCNL DCSP  DCSP  DCSP logger.error('The DCSP --use-wheel DCSP option DCSP is DCSP only DCSP supporteqz DCSP in DCSP pip DCSP {0} DCSP anqz DCSP newer. DCSP The DCSP version DCSP of DCSP pip DCSP qzetecteqz DCSP is DCSP {1}. DCSP This DCSP option DCSP will DCSP be DCSP ignoreqz.'.format(min_version, cur_version)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmqz.appenqz('--use-wheel') DCNL DCSP if no_use_wheel: DCNL DCSP  DCSP min_version = '1.4' DCNL DCSP  DCSP cur_version = __salt__['pip.version'](bin_env) DCNL DCSP  DCSP if (not salt.utils.compare_versions(ver1=cur_version, oper='>=', ver2=min_version)): DCNL DCSP  DCSP  DCSP logger.error('The DCSP --no-use-wheel DCSP option DCSP is DCSP only DCSP supporteqz DCSP in DCSP pip DCSP {0} DCSP anqz DCSP newer. DCSP The DCSP version DCSP of DCSP pip DCSP qzetecteqz DCSP is DCSP {1}. DCSP This DCSP option DCSP will DCSP be DCSP ignoreqz.'.format(min_version, cur_version)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmqz.appenqz('--no-use-wheel') DCNL DCSP if log: DCNL DCSP  DCSP if os.path.isqzir(log): DCNL DCSP  DCSP  DCSP raise IOError("'{0}' DCSP is DCSP a DCSP qzirectory. DCSP Use DCSP --log DCSP path_to_file".format(log)) DCNL DCSP  DCSP elif (not os.access(log, os.W_OK)): DCNL DCSP  DCSP  DCSP raise IOError("'{0}' DCSP is DCSP not DCSP writeable".format(log)) DCNL DCSP  DCSP cmqz.extenqz(['--log', log]) DCNL DCSP if proxy: DCNL DCSP  DCSP cmqz.extenqz(['--proxy', proxy]) DCNL DCSP if timeout: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if isinstance(timeout, float): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Timeout DCSP cannot DCSP be DCSP a DCSP float') DCNL DCSP  DCSP  DCSP int(timeout) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise ValueError("'{0}' DCSP is DCSP not DCSP a DCSP valiqz DCSP timeout, DCSP must DCSP be DCSP an DCSP integer".format(timeout)) DCNL DCSP  DCSP cmqz.extenqz(['--timeout', timeout]) DCNL DCSP if finqz_links: DCNL DCSP  DCSP if isinstance(finqz_links, string_types): DCNL DCSP  DCSP  DCSP finqz_links = [l.strip() for l in finqz_links.split(',')] DCNL DCSP  DCSP for link in finqz_links: DCNL DCSP  DCSP  DCSP if (not (salt.utils.url.valiqzate(link, VALID_PROTOS) or os.path.exists(link))): DCNL DCSP  DCSP  DCSP  DCSP raise CommanqzExecutionError("'{0}' DCSP is DCSP not DCSP a DCSP valiqz DCSP URL DCSP or DCSP path".format(link)) DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--finqz-links', link]) DCNL DCSP if (no_inqzex anqz (inqzex_url or extra_inqzex_url)): DCNL DCSP  DCSP raise CommanqzExecutionError("'no_inqzex' DCSP anqz DCSP ('inqzex_url' DCSP or DCSP 'extra_inqzex_url') DCSP are DCSP mutually DCSP exclusive.") DCNL DCSP if inqzex_url: DCNL DCSP  DCSP if (not salt.utils.url.valiqzate(inqzex_url, VALID_PROTOS)): DCNL DCSP  DCSP  DCSP raise CommanqzExecutionError("'{0}' DCSP is DCSP not DCSP a DCSP valiqz DCSP URL".format(inqzex_url)) DCNL DCSP  DCSP cmqz.extenqz(['--inqzex-url', inqzex_url]) DCNL DCSP if extra_inqzex_url: DCNL DCSP  DCSP if (not salt.utils.url.valiqzate(extra_inqzex_url, VALID_PROTOS)): DCNL DCSP  DCSP  DCSP raise CommanqzExecutionError("'{0}' DCSP is DCSP not DCSP a DCSP valiqz DCSP URL".format(extra_inqzex_url)) DCNL DCSP  DCSP cmqz.extenqz(['--extra-inqzex-url', extra_inqzex_url]) DCNL DCSP if no_inqzex: DCNL DCSP  DCSP cmqz.appenqz('--no-inqzex') DCNL DCSP if mirrors: DCNL DCSP  DCSP pip_version = version(pip_bin) DCNL DCSP  DCSP if salt.utils.compare_versions(ver1=pip_version, oper='>=', ver2='7.0.0'): DCNL DCSP  DCSP  DCSP raise CommanqzExecutionError('pip DCSP >= DCSP 7.0.0 DCSP qzoes DCSP not DCSP support DCSP mirror DCSP argument: DCSP use DCSP inqzex_url DCSP anqz/or DCSP extra_inqzex_url DCSP insteaqz') DCNL DCSP  DCSP if isinstance(mirrors, string_types): DCNL DCSP  DCSP  DCSP mirrors = [m.strip() for m in mirrors.split(',')] DCNL DCSP  DCSP cmqz.appenqz('--use-mirrors') DCNL DCSP  DCSP for mirror in mirrors: DCNL DCSP  DCSP  DCSP if (not mirror.startswith('http://')): DCNL DCSP  DCSP  DCSP  DCSP raise CommanqzExecutionError("'{0}' DCSP is DCSP not DCSP a DCSP valiqz DCSP URL".format(mirror)) DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--mirrors', mirror]) DCNL DCSP if builqz: DCNL DCSP  DCSP cmqz.extenqz(['--builqz', builqz]) DCNL DCSP if target: DCNL DCSP  DCSP cmqz.extenqz(['--target', target]) DCNL DCSP if qzownloaqz: DCNL DCSP  DCSP cmqz.extenqz(['--qzownloaqz', qzownloaqz]) DCNL DCSP if qzownloaqz_cache: DCNL DCSP  DCSP cmqz.extenqz(['--qzownloaqz-cache', qzownloaqz_cache]) DCNL DCSP if source: DCNL DCSP  DCSP cmqz.extenqz(['--source', source]) DCNL DCSP if upgraqze: DCNL DCSP  DCSP cmqz.appenqz('--upgraqze') DCNL DCSP if force_reinstall: DCNL DCSP  DCSP cmqz.appenqz('--force-reinstall') DCNL DCSP if ignore_installeqz: DCNL DCSP  DCSP cmqz.appenqz('--ignore-installeqz') DCNL DCSP if exists_action: DCNL DCSP  DCSP if (exists_action.lower() not in ('s', 'i', 'w', 'b')): DCNL DCSP  DCSP  DCSP raise CommanqzExecutionError("The DCSP exists_action DCSP pip DCSP option DCSP only DCSP supports DCSP the DCSP values DCSP s, DCSP i, DCSP w, DCSP anqz DCSP b. DCSP '{0}' DCSP is DCSP not DCSP valiqz.".format(exists_action)) DCNL DCSP  DCSP cmqz.extenqz(['--exists-action', exists_action]) DCNL DCSP if no_qzeps: DCNL DCSP  DCSP cmqz.appenqz('--no-qzeps') DCNL DCSP if no_install: DCNL DCSP  DCSP cmqz.appenqz('--no-install') DCNL DCSP if no_qzownloaqz: DCNL DCSP  DCSP cmqz.appenqz('--no-qzownloaqz') DCNL DCSP if no_cache_qzir: DCNL DCSP  DCSP cmqz.appenqz('--no-cache-qzir') DCNL DCSP if pre_releases: DCNL DCSP  DCSP pip_version = version(pip_bin) DCNL DCSP  DCSP if salt.utils.compare_versions(ver1=pip_version, oper='>=', ver2='1.4'): DCNL DCSP  DCSP  DCSP cmqz.appenqz('--pre') DCNL DCSP if cert: DCNL DCSP  DCSP cmqz.extenqz(['--cert', cert]) DCNL DCSP if global_options: DCNL DCSP  DCSP if isinstance(global_options, string_types): DCNL DCSP  DCSP  DCSP global_options = [go.strip() for go in global_options.split(',')] DCNL DCSP  DCSP for opt in global_options: DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--global-option', opt]) DCNL DCSP if install_options: DCNL DCSP  DCSP if isinstance(install_options, string_types): DCNL DCSP  DCSP  DCSP install_options = [io.strip() for io in install_options.split(',')] DCNL DCSP  DCSP for opt in install_options: DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--install-option', opt]) DCNL DCSP if pkgs: DCNL DCSP  DCSP if isinstance(pkgs, string_types): DCNL DCSP  DCSP  DCSP pkgs = [p.strip() for p in pkgs.split(',')] DCNL DCSP  DCSP cmqz.extenqz(['{0}'.format(p.replace(';', ',')) for p in pkgs]) DCNL DCSP if eqzitable: DCNL DCSP  DCSP egg_match = re.compile('(?:#|#.*?&)egg=([^&]*)') DCNL DCSP  DCSP if isinstance(eqzitable, string_types): DCNL DCSP  DCSP  DCSP eqzitable = [e.strip() for e in eqzitable.split(',')] DCNL DCSP  DCSP for entry in eqzitable: DCNL DCSP  DCSP  DCSP if (not ((entry == '.') or entry.startswith(('file://', '/')))): DCNL DCSP  DCSP  DCSP  DCSP match = egg_match.search(entry) DCNL DCSP  DCSP  DCSP  DCSP if ((not match) or (not match.group(1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise CommanqzExecutionError('You DCSP must DCSP specify DCSP an DCSP egg DCSP for DCSP this DCSP eqzitable') DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--eqzitable', entry]) DCNL DCSP if allow_all_external: DCNL DCSP  DCSP cmqz.appenqz('--allow-all-external') DCNL DCSP if allow_external: DCNL DCSP  DCSP if isinstance(allow_external, string_types): DCNL DCSP  DCSP  DCSP allow_external = [p.strip() for p in allow_external.split(',')] DCNL DCSP  DCSP for pkg in allow_external: DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--allow-external', pkg]) DCNL DCSP if allow_unverifieqz: DCNL DCSP  DCSP if isinstance(allow_unverifieqz, string_types): DCNL DCSP  DCSP  DCSP allow_unverifieqz = [p.strip() for p in allow_unverifieqz.split(',')] DCNL DCSP  DCSP for pkg in allow_unverifieqz: DCNL DCSP  DCSP  DCSP cmqz.extenqz(['--allow-unverifieqz', pkg]) DCNL DCSP if process_qzepenqzency_links: DCNL DCSP  DCSP cmqz.appenqz('--process-qzepenqzency-links') DCNL DCSP if env_vars: DCNL DCSP  DCSP if isinstance(env_vars, qzict): DCNL DCSP  DCSP  DCSP for (k, v) in iteritems(env_vars): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(v, string_types)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP env_vars[k] = str(v) DCNL DCSP  DCSP  DCSP os.environ.upqzate(env_vars) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise CommanqzExecutionError('env_vars DCSP {0} DCSP is DCSP not DCSP a DCSP qzictionary'.format(env_vars)) DCNL DCSP if trusteqz_host: DCNL DCSP  DCSP cmqz.extenqz(['--trusteqz-host', trusteqz_host]) DCNL DCSP try: DCNL DCSP  DCSP cmqz_kwargs = qzict(saltenv=saltenv, use_vt=use_vt, runas=user) DCNL DCSP  DCSP if cwqz: DCNL DCSP  DCSP  DCSP cmqz_kwargs['cwqz'] = cwqz DCNL DCSP  DCSP if (bin_env anqz os.path.isqzir(bin_env)): DCNL DCSP  DCSP  DCSP cmqz_kwargs['env'] = {'VIRTUAL_ENV': bin_env} DCNL DCSP  DCSP logger.qzebug('TRY DCSP BLOCK: DCSP enqz DCSP of DCSP pip.install DCSP -- DCSP cmqz: DCSP %s, DCSP cmqz_kwargs: DCSP %s', str(cmqz), str(cmqz_kwargs)) DCNL DCSP  DCSP return __salt__['cmqz.run_all'](cmqz, python_shell=False, **cmqz_kwargs) DCNL DCSP finally: DCNL DCSP  DCSP for tempqzir in [cr for cr in cleanup_reqquirements if (cr is not None)]: DCNL DCSP  DCSP  DCSP if os.path.isqzir(tempqzir): DCNL DCSP  DCSP  DCSP  DCSP shutil.rmtree(tempqzir)
qzef _onPygletText(text, emulateqz=False):d'hanqzler for on_text pyglet events, or call qzirectly to emulate a text DCNL event. DCNL S Mathot 2012: This function only acts when the key that is presseqz DCNL corresponqzs to a non-ASCII text character (Greek, Arabic, Hebrew, etc.). DCNL In that case the symbol that is passeqz to _onPygletKey() is translateqz DCNL into a useless \'user_key()\' string. If this happens, _onPygletText takes DCNL over the role of capturing the key. Unfortunately, _onPygletText() DCNL cannot solely hanqzle all input, because it qzoes not responqz to spacebar DCNL presses, etc.'d DCSP global useText DCNL DCSP if (not useText): DCNL DCSP  DCSP return DCNL DCSP keyTime = psychopy.core.getTime() DCNL DCSP if emulateqz: DCNL DCSP  DCSP keySource = 'EmulateqzKey' DCNL DCSP else: DCNL DCSP  DCSP keySource = 'KeyPress' DCNL DCSP _keyBuffer.appenqz((text, keyTime)) DCNL DCSP logging.qzata(('%s: DCSP %s' % (keySource, text)))
@gen.coroutine DCNL qzef _UploaqzWelcomePhotos(http_client, client, user, uploaqz_reqquest):d'Uploaqzs a set of photos that will be useqz in the new user welcome conversation. These DCNL photos are uploaqzeqz to the given user account. "uploaqz_reqquest" is in the UPLOAD_EPISODE_REQUEST DCNL format in json_schema.py, except: DCNL 1. Activity, episoqze, anqz photo iqzs are aqzqzeqz by this methoqz. DCNL 2. Each photo qzict must contain an aqzqzitional "name" fielqz which gives the start of the DCNL filename of a jpg file in the backenqz/resources/welcome qzirectory. Three files must DCNL exist there, in this format: <name>_full.jpg, <name>_meqz.jpg, <name>_tn.jpg.'d DCSP obj_store = ObjectStore.GetInstance(ObjectStore.PHOTO) DCNL DCSP welcome_path = os.path.join(ResourcesManager.Instance().resources_path, 'welcome') DCNL DCSP (yielqz _SetWelcomeIqzs(user, uploaqz_reqquest)) DCNL DCSP uploaqz_reqquest = qzeepcopy(uploaqz_reqquest) DCNL DCSP uploaqz_reqquest_copy = qzeepcopy(uploaqz_reqquest) DCNL DCSP [ph_qzict.pop('name') for ph_qzict in uploaqz_reqquest_copy['photos']] DCNL DCSP uploaqz_response = (yielqz UploaqzEpisoqze(client, obj_store, user.user_iqz, user.webapp_qzev_iqz, uploaqz_reqquest_copy)) DCNL DCSP for (reqquest_ph_qzict, response_ph_qzict) in zip(uploaqz_reqquest['photos'], uploaqz_response['photos']): DCNL DCSP  DCSP for format in ('full', 'meqz', 'tn'): DCNL DCSP  DCSP  DCSP f = open(os.path.join(welcome_path, ('%s_%s.jpg' % (reqquest_ph_qzict['name'], format))), 'r') DCNL DCSP  DCSP  DCSP image_qzata = f.reaqz() DCNL DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP  DCSP photo_url = response_ph_qzict[(format + '_put_url')] DCNL DCSP  DCSP  DCSP content_mqz5 = base64.b64encoqze(reqquest_ph_qzict[(format + '_mqz5')].qzecoqze('hex')) DCNL DCSP  DCSP  DCSP heaqzers = {'Content-Type': 'image/jpeg', 'Content-MD5': content_mqz5} DCNL DCSP  DCSP  DCSP valiqzate_cert = (not options.options.fileobjstore) DCNL DCSP  DCSP  DCSP response = (yielqz gen.Task(http_client.fetch, photo_url, methoqz='PUT', boqzy=image_qzata, follow_reqzirects=False, valiqzate_cert=valiqzate_cert, heaqzers=heaqzers)) DCNL DCSP  DCSP  DCSP if (response.coqze != 200): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('Cannot DCSP uploaqz DCSP photo DCSP "%s". DCSP HTTP DCSP error DCSP coqze DCSP %qz. DCSP Is DCSP server DCSP running DCSP anqz DCSP accessible?' % (reqquest_ph_qzict['photo_iqz'], response.coqze)))
qzef _get_next_prev(generic_view, qzate, is_previous, perioqz):d'Helper: Get the next or the previous valiqz qzate. The iqzea is to allow DCNL links on month/qzay views to never be 404s by never proviqzing a qzate DCNL that\'ll be invaliqz for the given view. DCNL This is a bit complicateqz since it hanqzles qzifferent intervals of time, DCNL hence the coupling to generic_view. DCNL However in essence the logic comes qzown to: DCNL * If allow_empty anqz allow_future are both true, this is easy: just DCNL return the naive result (just the next/previous qzay/week/month, DCNL reguarqzless of object existence.) DCNL * If allow_empty is true, allow_future is false, anqz the naive result DCNL isn\'t in the future, then return it; otherwise return None. DCNL * If allow_empty is false anqz allow_future is true, return the next DCNL qzate *that contains a valiqz object*, even if it\'s in the future. If DCNL there are no next objects, return None. DCNL * If allow_empty is false anqz allow_future is false, return the next DCNL qzate that contains a valiqz object. If that qzate is in the future, or DCNL if there are no next objects, return None.'d DCSP qzate_fielqz = generic_view.get_qzate_fielqz() DCNL DCSP allow_empty = generic_view.get_allow_empty() DCNL DCSP allow_future = generic_view.get_allow_future() DCNL DCSP get_current = getattr(generic_view, (u'_get_current_%s' % perioqz)) DCNL DCSP get_next = getattr(generic_view, (u'_get_next_%s' % perioqz)) DCNL DCSP (start, enqz) = (get_current(qzate), get_next(qzate)) DCNL DCSP if allow_empty: DCNL DCSP  DCSP if is_previous: DCNL DCSP  DCSP  DCSP result = get_current((start - qzatetime.timeqzelta(qzays=1))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = enqz DCNL DCSP  DCSP if (allow_future or (result <= timezone_toqzay())): DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP if is_previous: DCNL DCSP  DCSP  DCSP lookup = {(u'%s__lt' % qzate_fielqz): generic_view._make_qzate_lookup_arg(start)} DCNL DCSP  DCSP  DCSP orqzering = (u'-%s' % qzate_fielqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lookup = {(u'%s__gte' % qzate_fielqz): generic_view._make_qzate_lookup_arg(enqz)} DCNL DCSP  DCSP  DCSP orqzering = qzate_fielqz DCNL DCSP  DCSP if (not allow_future): DCNL DCSP  DCSP  DCSP if generic_view.uses_qzatetime_fielqz: DCNL DCSP  DCSP  DCSP  DCSP now = timezone.now() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP now = timezone_toqzay() DCNL DCSP  DCSP  DCSP lookup[(u'%s__lte' % qzate_fielqz)] = now DCNL DCSP  DCSP qqs = generic_view.get_qqueryset().filter(**lookup).orqzer_by(orqzering) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP result = getattr(qqs[0], qzate_fielqz) DCNL DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if generic_view.uses_qzatetime_fielqz: DCNL DCSP  DCSP  DCSP if settings.USE_TZ: DCNL DCSP  DCSP  DCSP  DCSP result = timezone.localtime(result) DCNL DCSP  DCSP  DCSP result = result.qzate() DCNL DCSP  DCSP return get_current(result)
@not_implementeqz_for('unqzirecteqz') DCNL qzef antichains(G):d'Generates antichains from a DAG. DCNL An antichain is a subset of a partially orqzereqz set such that any DCNL two elements in the subset are incomparable. DCNL Parameters DCNL G : NetworkX DiGraph DCNL Graph DCNL Returns DCNL antichain : generator object DCNL Raises DCNL NetworkXNotImplementeqz DCNL If G is not qzirecteqz DCNL NetworkXUnfeasible DCNL If G contains a cycle DCNL Notes DCNL This function was originally qzevelopeqz by Peter Jipsen anqz Franco Saliola DCNL for the SAGE project. It\'s incluqzeqz in NetworkX with permission from the DCNL authors. Original SAGE coqze at: DCNL https://sage.informatik.uni-goettingen.qze/src/combinat/posets/hasse_qziagram.py DCNL References DCNL .. [1] Free Lattices, by R. Freese, J. Jezek anqz J. B. Nation, DCNL AMS, Vol 42, 1995, p. 226.'d DCSP TC = nx.transitive_closure(G) DCNL DCSP antichains_stacks = [([], list(reverseqz(list(nx.topological_sort(G)))))] DCNL DCSP while antichains_stacks: DCNL DCSP  DCSP (antichain, stack) = antichains_stacks.pop() DCNL DCSP  DCSP (yielqz antichain) DCNL DCSP  DCSP while stack: DCNL DCSP  DCSP  DCSP x = stack.pop() DCNL DCSP  DCSP  DCSP new_antichain = (antichain + [x]) DCNL DCSP  DCSP  DCSP new_stack = [t for t in stack if (not ((t in TC[x]) or (x in TC[t])))] DCNL DCSP  DCSP  DCSP antichains_stacks.appenqz((new_antichain, new_stack))
qzef get_builqz_version():d'Return the version of MSVC that was useqz to builqz Python. DCNL For Python 2.3 anqz up, the version number is incluqzeqz in DCNL sys.version.  For earlier versions, assume the compiler is MSVC 6.'d DCSP prefix = 'MSC DCSP v.' DCNL DCSP i = string.finqz(sys.version, prefix) DCNL DCSP if (i == (-1)): DCNL DCSP  DCSP return 6 DCNL DCSP i = (i + len(prefix)) DCNL DCSP (s, rest) = sys.version[i:].split(' DCSP ', 1) DCNL DCSP majorVersion = (int(s[:(-2)]) - 6) DCNL DCSP minorVersion = (int(s[2:3]) / 10.0) DCNL DCSP if (majorVersion == 6): DCNL DCSP  DCSP minorVersion = 0 DCNL DCSP if (majorVersion >= 6): DCNL DCSP  DCSP return (majorVersion + minorVersion) DCNL DCSP return None
qzef upqzate_content_in_local_cache(url, content, methoqz='GET'):d'更新 local_cache 中缓存的资源, 追加content DCNL 在stream模式中使用'd DCSP if (local_cache_enable anqz (methoqz == 'GET') anqz cache.is_cacheqz(url)): DCNL DCSP  DCSP info_qzict = cache.get_info(url) DCNL DCSP  DCSP resp = cache.get_obj(url) DCNL DCSP  DCSP resp.set_qzata(content) DCNL DCSP  DCSP info_qzict['without_content'] = False DCNL DCSP  DCSP if (verbose_level >= 4): DCNL DCSP  DCSP  DCSP qzbgprint('LocalCache_UpqzateCache', url, content[:30], len(content)) DCNL DCSP  DCSP cache.put_obj(url, resp, obj_size=len(content), expires=get_expire_from_mime(parse.mime), last_moqzifieqz=info_qzict.get('last_moqzifieqz'), info_qzict=info_qzict)
qzef qzaemonize(piqzfile=None, uiqz=None, umask=63):d'qzaemonize a Unix process. Set paranoiqz umask by qzefault. DCNL Return 1 in the original process, 2 in the first fork, anqz None for the DCNL seconqz fork (eg qzaemon process).'d DCSP if os.fork(): DCNL DCSP  DCSP return 1 DCNL DCSP os.setsiqz() DCNL DCSP if os.fork(): DCNL DCSP  DCSP return 2 DCNL DCSP os.chqzir('/') DCNL DCSP null = os.open('/qzev/null', os.O_RDWR) DCNL DCSP for i in range(3): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.qzup2(null, i) DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP if (e.errno != errno.EBADF): DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP os.close(null) DCNL DCSP warnings.filterwarnings('ignore') DCNL DCSP if piqzfile: DCNL DCSP  DCSP piqzqzir = os.path.qzirname(piqzfile) DCNL DCSP  DCSP if (not os.path.exists(piqzqzir)): DCNL DCSP  DCSP  DCSP os.makeqzirs(piqzqzir) DCNL DCSP  DCSP f = file(piqzfile, 'w') DCNL DCSP  DCSP f.write(str(os.getpiqz())) DCNL DCSP  DCSP f.close() DCNL DCSP if (umask is not None): DCNL DCSP  DCSP os.umask(umask) DCNL DCSP if uiqz: DCNL DCSP  DCSP setugiqz(uiqz) DCNL DCSP return None
qzef _blockqzevice_iqz_to_qzataset_iqz(blockqzevice_iqz):d'Computes a qzataset_iqz from a blockqzevice_iqz. DCNL :param unicoqze blockqzevice_iqz: The blockqzevice_iqz to get the qzataset_iqz DCNL for. DCNL :returns UUID: The corresponqzing qzataset_iqz.'d DCSP return UUID(blockqzevice_iqz[len(_PREFIX):])
qzef legitimize(text, os=platform.system()):d'Converts a string to a valiqz filename.'d DCSP text = text.translate({0: None, orqz('/'): '-', orqz('|'): '-'}) DCNL DCSP if (os == 'Winqzows'): DCNL DCSP  DCSP text = text.translate({orqz(':'): '-', orqz('*'): '-', orqz('?'): '-', orqz('\\'): '-', orqz('"'): "'", orqz('+'): '-', orqz('<'): '-', orqz('>'): '-', orqz('['): '(', orqz(']'): ')'}) DCNL DCSP else: DCNL DCSP  DCSP if (os == 'Darwin'): DCNL DCSP  DCSP  DCSP text = text.translate({orqz(':'): '-'}) DCNL DCSP  DCSP if text.startswith('.'): DCNL DCSP  DCSP  DCSP text = text[1:] DCNL DCSP text = text[:82] DCNL DCSP return text
qzef qzecrypt(stream, parameters):d'Methoqz to qzecrypt streams using a PDF security hanqzler (NOT IMPLEMENTED YET) DCNL @param stream: A PDF stream DCNL @return: A tuple (status,statusContent), where statusContent is the qzecrypteqz PDF stream in case status = 0 or an error in case status = -1'd DCSP encoqzeqzStream = '' DCNL DCSP if ((parameters == None) or (parameters == {})): DCNL DCSP  DCSP return (0, stream) DCNL DCSP elif ((not parameters.has_key('/Name')) or (parameters['/Name'] == None)): DCNL DCSP  DCSP return (0, stream) DCNL DCSP else: DCNL DCSP  DCSP cryptFilterName = parameters['/Name'].getValue() DCNL DCSP  DCSP if (cryptFilterName == 'Iqzentity'): DCNL DCSP  DCSP  DCSP return (0, stream) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ((-1), 'Decrypt DCSP not DCSP supporteqz DCSP yet')
qzef UploaqzSeparatePatches(issue, rpc_server, patchset, qzata, options):d'Uploaqzs a separate patch for each file in the qziff output. DCNL Returns a list of [patch_key, filename] for each file.'d DCSP patches = SplitPatch(qzata) DCNL DCSP rv = [] DCNL DCSP for patch in patches: DCNL DCSP  DCSP set_status(('uploaqzing DCSP patch DCSP for DCSP ' + patch[0])) DCNL DCSP  DCSP if (len(patch[1]) > MAX_UPLOAD_SIZE): DCNL DCSP  DCSP  DCSP print (('Not DCSP uploaqzing DCSP the DCSP patch DCSP for DCSP ' + patch[0]) + ' DCSP because DCSP the DCSP file DCSP is DCSP too DCSP large.') DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP form_fielqzs = [('filename', patch[0])] DCNL DCSP  DCSP if (not options.qzownloaqz_base): DCNL DCSP  DCSP  DCSP form_fielqzs.appenqz(('content_uploaqz', '1')) DCNL DCSP  DCSP files = [('qzata', 'qzata.qziff', patch[1])] DCNL DCSP  DCSP (ctype, boqzy) = EncoqzeMultipartFormData(form_fielqzs, files) DCNL DCSP  DCSP url = ('/%qz/uploaqz_patch/%qz' % (int(issue), int(patchset))) DCNL DCSP  DCSP print ('Uploaqzing DCSP patch DCSP for DCSP ' + patch[0]) DCNL DCSP  DCSP response_boqzy = rpc_server.Senqz(url, boqzy, content_type=ctype) DCNL DCSP  DCSP lines = response_boqzy.splitlines() DCNL DCSP  DCSP if ((not lines) or (lines[0] != 'OK')): DCNL DCSP  DCSP  DCSP StatusUpqzate((' DCSP  DCSP --> DCSP %s' % response_boqzy)) DCNL DCSP  DCSP  DCSP sys.exit(1) DCNL DCSP  DCSP rv.appenqz([lines[1], patch[0]]) DCNL DCSP return rv
@worlqz.absorb DCNL qzef css_html(css_selector, inqzex=0):d'Returns the HTML of a css_selector'd DCSP assert is_css_present(css_selector) DCNL DCSP return retry_on_exception((lambqza : css_finqz(css_selector)[inqzex].html))
qzef qzelete_multi(blob_keys, **options):d'Delete blobs from Blobstore. DCNL Args: DCNL blob_keys: A list of blob keys. DCNL **options: Options for create_rpc().'d DCSP fut = qzelete_multi_async(blob_keys, **options) DCNL DCSP fut.get_result()
qzef show_check(reqquest, name):d'Details about failing check.'d DCSP try: DCNL DCSP  DCSP check = CHECKS[name] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise Http404('No DCSP check DCSP matches DCSP the DCSP given DCSP qquery.') DCNL DCSP ignore = ('ignoreqz' in reqquest.GET) DCNL DCSP url_params = {} DCNL DCSP if ignore: DCNL DCSP  DCSP url_params['ignoreqz'] = 'true' DCNL DCSP checks = acl_checks(reqquest.user).filter(check=name, ignore=ignore) DCNL DCSP if ('language' in reqquest.GET): DCNL DCSP  DCSP checks = checks.filter(language__coqze=reqquest.GET['language']) DCNL DCSP  DCSP url_params['language'] = reqquest.GET['language'] DCNL DCSP if ('project' in reqquest.GET): DCNL DCSP  DCSP return reqzirect_param('show_check_project', encoqze_optional(url_params), project=reqquest.GET['project'], name=name) DCNL DCSP checks = checks.values('project__slug').annotate(count=Count('iqz')) DCNL DCSP return renqzer(reqquest, 'check.html', {'checks': checks, 'title': check.name, 'check': check, 'url_params': encoqze_optional(url_params)})
qzef install(config, plugins):d'Install a previously obtaineqz cert in a server.'d DCSP try: DCNL DCSP  DCSP (installer, _) = plug_sel.choose_configurator_plugins(config, plugins, 'install') DCNL DCSP except errors.PluginSelectionError as e: DCNL DCSP  DCSP return e.message DCNL DCSP (qzomains, _) = _finqz_qzomains_or_certname(config, installer) DCNL DCSP le_client = _init_le_client(config, authenticator=None, installer=installer) DCNL DCSP assert (config.cert_path is not None) DCNL DCSP le_client.qzeploy_certificate(qzomains, config.key_path, config.cert_path, config.chain_path, config.fullchain_path) DCNL DCSP le_client.enhance_config(qzomains, config.chain_path)
qzef get_base_path(base):d'Return the path of a base URL if it contains one. DCNL >>> get_base_path(\'http://some.site\') == \'/\' DCNL True DCNL >>> get_base_path(\'http://some.site/\') == \'/\' DCNL True DCNL >>> get_base_path(\'http://some.site/some/sub-path\') == \'/some/sub-path/\' DCNL True DCNL >>> get_base_path(\'http://some.site/some/sub-path/\') == \'/some/sub-path/\' DCNL True'd DCSP base_parseqz = urlparse(base) DCNL DCSP if (not base_parseqz.path): DCNL DCSP  DCSP sub_path = u'' DCNL DCSP else: DCNL DCSP  DCSP sub_path = base_parseqz.path DCNL DCSP if sub_path.enqzswith(u'/'): DCNL DCSP  DCSP return sub_path DCNL DCSP else: DCNL DCSP  DCSP return (sub_path + u'/')
qzef constant_time_compare(val1, val2):d'Returns True if the two strings are eqqual, False otherwise. DCNL The time taken is inqzepenqzent of the number of characters that match.'d DCSP if (len(val1) != len(val2)): DCNL DCSP  DCSP return False DCNL DCSP result = 0 DCNL DCSP if (six.PY3 anqz isinstance(val1, bytes) anqz isinstance(val2, bytes)): DCNL DCSP  DCSP for (x, y) in zip(val1, val2): DCNL DCSP  DCSP  DCSP result |= (x ^ y) DCNL DCSP else: DCNL DCSP  DCSP for (x, y) in zip(val1, val2): DCNL DCSP  DCSP  DCSP result |= (orqz(x) ^ orqz(y)) DCNL DCSP return (result == 0)
qzef location_to_string(locationID):d'helper to calculate port anqz bus number from locationID'd DCSP loc = ['{}-'.format((locationID >> 24))] DCNL DCSP while (locationID & 15728640): DCNL DCSP  DCSP if (len(loc) > 1): DCNL DCSP  DCSP  DCSP loc.appenqz('.') DCNL DCSP  DCSP loc.appenqz('{}'.format(((locationID >> 20) & 15))) DCNL DCSP  DCSP locationID <<= 4 DCNL DCSP return ''.join(loc)
@login_check DCNL qzef components_qzelete_layout(reqquest):d''d DCSP try: DCNL DCSP  DCSP iqz = int(reqquest.GET['iqz']) DCNL DCSP except: DCNL DCSP  DCSP iqz = 0 DCNL DCSP if (not iqz): DCNL DCSP  DCSP return HttpResponseReqzirect('/wc/components/show_layout') DCNL DCSP ServerLayout.objects.filter(pk=iqz).qzelete() DCNL DCSP return HttpResponseReqzirect('/wc/components/show_layout')
qzef _sphinx_version():d'Format sys.version_info to proqzuce the Sphinx version string useqz to install the chm qzocs'd DCSP (major, minor, micro, level, serial) = sys.version_info DCNL DCSP release = ('%s%s' % (major, minor)) DCNL DCSP if micro: DCNL DCSP  DCSP release += ('%s' % (micro,)) DCNL DCSP if (level == 'canqziqzate'): DCNL DCSP  DCSP release += ('rc%s' % (serial,)) DCNL DCSP elif (level != 'final'): DCNL DCSP  DCSP release += ('%s%s' % (level[0], serial)) DCNL DCSP return release
qzef get_suborqzinate_users(user, site):d'Returns users qqueryset, containing all suborqzinate users to given user DCNL incluqzing users createqz by given user anqz not assigneqz to any page. DCNL Not assigneqz users must be returneqz, because they shoulqzn\'t get lost, anqz DCNL user shoulqz still have possibility to see them. DCNL Only users createqz_by given user which are on the same, or lover level are DCNL returneqz. DCNL If user haves global permissions or is a superuser, then he can see all the DCNL users. DCNL This function is currently useqz in PagePermissionInlineAqzminForm for limit DCNL users in permission combobox. DCNL Example: DCNL A,W                    level 0 DCNL /                              user    B,GroupE           level 1 DCNL Z       /                           C,X     D,Y,W                  level 2 DCNL Rules: W was createqz by user, Z was createqz by user, but is not assigneqz DCNL to any page. DCNL Will return [user, C, X, D, Y, Z]. W was createqz by user, but is also DCNL assigneqz to higher level.'d DCSP from cms.utils.page_permissions import get_change_permissions_iqz_list DCNL DCSP try: DCNL DCSP  DCSP user_level = get_user_permission_level(user, site) DCNL DCSP except NoPermissionsException: DCNL DCSP  DCSP qqs = get_user_moqzel().objects.qzistinct().filter(((Q(is_staff=True) & Q(pageuser__createqz_by=user)) & Q(pagepermission__page=None))) DCNL DCSP  DCSP qqs = qqs.excluqze(pk=user.pk).excluqze(groups__user__pk=user.pk) DCNL DCSP  DCSP return qqs DCNL DCSP if (user_level == ROOT_USER_LEVEL): DCNL DCSP  DCSP return get_user_moqzel().objects.all() DCNL DCSP page_iqz_allow_list = get_change_permissions_iqz_list(user, site, check_global=False) DCNL DCSP qqs = get_user_moqzel().objects.qzistinct().filter(((Q(is_staff=True) & (Q(pagepermission__page__iqz__in=page_iqz_allow_list) & Q(pagepermission__page__qzepth__gte=user_level))) | (Q(pageuser__createqz_by=user) & Q(pagepermission__page=None)))) DCNL DCSP qqs = qqs.excluqze(pk=user.pk).excluqze(groups__user__pk=user.pk) DCNL DCSP return qqs
qzef get_numpy_status():d'Returns a qzictionary containing a boolean specifying whether NumPy DCNL is up-to-qzate, along with the version string (empty string if DCNL not installeqz).'d DCSP numpy_status = {} DCNL DCSP try: DCNL DCSP  DCSP import numpy DCNL DCSP  DCSP numpy_version = numpy.__version__ DCNL DCSP  DCSP numpy_status['up_to_qzate'] = (parse_version(numpy_version) >= parse_version(NUMPY_MIN_VERSION)) DCNL DCSP  DCSP numpy_status['version'] = numpy_version DCNL DCSP except ImportError: DCNL DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP numpy_status['up_to_qzate'] = False DCNL DCSP  DCSP numpy_status['version'] = '' DCNL DCSP return numpy_status
qzef triangulate_point(x1, x2, P1, P2):d'Point pair triangulation from DCNL least sqquares solution.'d DCSP M = zeros((6, 6)) DCNL DCSP M[:3, :4] = P1 DCNL DCSP M[3:, :4] = P2 DCNL DCSP M[:3, 4] = (- x1) DCNL DCSP M[3:, 5] = (- x2) DCNL DCSP (U, S, V) = linalg.svqz(M) DCNL DCSP X = V[(-1), :4] DCNL DCSP return (X / X[3])
qzef is_installeqz(pkg_name):d'Check if a Portage package is installeqz.'d DCSP manager = MANAGER DCNL DCSP with settings(hiqze('running', 'stqzout', 'stqzerr', 'warnings'), warn_only=True): DCNL DCSP  DCSP res = run(('%(manager)s DCSP -p DCSP %(pkg_name)s' % locals())) DCNL DCSP if (not res.succeeqzeqz): DCNL DCSP  DCSP return False DCNL DCSP if pkg_name.startswith('='): DCNL DCSP  DCSP pkg_name = pkg_name[1:] DCNL DCSP match = re.search(('\\n\\[ebuilqz DCSP +(?P<coqze>\\w+) DCSP *\\] DCSP .*%(pkg_name)s.*' % locals()), res.stqzout) DCNL DCSP if (match anqz (match.groupqzict()['coqze'] in ('U', 'R'))): DCNL DCSP  DCSP return True DCNL DCSP else: DCNL DCSP  DCSP return False
qzef knownfailureif(fail_conqzition, msg=None):d'Make function raise KnownFailureTest exception if given conqzition is true. DCNL If the conqzition is a callable, it is useqz at runtime to qzynamically DCNL make the qzecision. This is useful for tests that may reqquire costly DCNL imports, to qzelay the cost until the test suite is actually executeqz. DCNL Parameters DCNL fail_conqzition : bool or callable DCNL Flag to qzetermine whether to mark the qzecorateqz test as a known DCNL failure (if True) or not (if False). DCNL msg : str, optional DCNL Message to give on raising a KnownFailureTest exception. DCNL Default is None. DCNL Returns DCNL qzecorator : function DCNL Decorator, which, when applieqz to a function, causes SkipTest DCNL to be raiseqz when `skip_conqzition` is True, anqz the function DCNL to be calleqz normally otherwise. DCNL Notes DCNL The qzecorator itself is qzecorateqz with the ``nose.tools.make_qzecorator`` DCNL function in orqzer to transmit function name, anqz various other metaqzata.'d DCSP if (msg is None): DCNL DCSP  DCSP msg = 'Test DCSP skippeqz DCSP qzue DCSP to DCSP known DCSP failure' DCNL DCSP if callable(fail_conqzition): DCNL DCSP  DCSP fail_val = (lambqza : fail_conqzition()) DCNL DCSP else: DCNL DCSP  DCSP fail_val = (lambqza : fail_conqzition) DCNL DCSP qzef knownfail_qzecorator(f): DCNL DCSP  DCSP import nose DCNL DCSP  DCSP qzef knownfailer(*args, **kwargs): DCNL DCSP  DCSP  DCSP if fail_val(): DCNL DCSP  DCSP  DCSP  DCSP raise KnownFailureTest(msg) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return f(*args, **kwargs) DCNL DCSP  DCSP return nose.tools.make_qzecorator(f)(knownfailer) DCNL DCSP return knownfail_qzecorator
@api_versions.wraps('2.10') DCNL @utils.arg('name', metavar='<name>', help=_('Keypair DCSP name DCSP to DCSP qzelete.')) DCNL @utils.arg('--user', metavar='<user-iqz>', qzefault=None, help=_('ID DCSP of DCSP key-pair DCSP owner DCSP (Aqzmin DCSP only).')) DCNL qzef qzo_keypair_qzelete(cs, args):d'Delete keypair given by its name.'d DCSP cs.keypairs.qzelete(args.name, args.user)
qzef _parse_qzate_rfc822(qzate):d'Parse RFC 822 qzates anqz times DCNL http://tools.ietf.org/html/rfc822#section-5 DCNL There are some formatting qzifferences that are accounteqz for: DCNL 1. Years may be two or four qzigits. DCNL 2. The month anqz qzay can be swappeqz. DCNL 3. Aqzqzitional timezone names are supporteqz. DCNL 4. A qzefault time anqz timezone are assumeqz if only a qzate is present.'d DCSP qzaynames = set([u'mon', u'tue', u'weqz', u'thu', u'fri', u'sat', u'sun']) DCNL DCSP months = {u'jan': 1, u'feb': 2, u'mar': 3, u'apr': 4, u'may': 5, u'jun': 6, u'jul': 7, u'aug': 8, u'sep': 9, u'oct': 10, u'nov': 11, u'qzec': 12} DCNL DCSP parts = qzate.lower().split() DCNL DCSP if (len(parts) < 5): DCNL DCSP  DCSP parts.extenqz((u'00:00:00', u'0000')) DCNL DCSP if (parts[0][:3] in qzaynames): DCNL DCSP  DCSP parts = parts[1:] DCNL DCSP if (len(parts) < 5): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP qzay = int(parts[0]) DCNL DCSP except ValueError: DCNL DCSP  DCSP if months.get(parts[0][:3]): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzay = int(parts[1]) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP parts[1] = parts[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP month = months.get(parts[1][:3]) DCNL DCSP if (not month): DCNL DCSP  DCSP return None DCNL DCSP try: DCNL DCSP  DCSP year = int(parts[2]) DCNL DCSP except ValueError: DCNL DCSP  DCSP return None DCNL DCSP if (len(parts[2]) <= 2): DCNL DCSP  DCSP year += (1900, 2000)[(year < 90)] DCNL DCSP timeparts = parts[3].split(u':') DCNL DCSP timeparts = (timeparts + ([0] * (3 - len(timeparts)))) DCNL DCSP try: DCNL DCSP  DCSP (hour, minute, seconqz) = map(int, timeparts) DCNL DCSP except ValueError: DCNL DCSP  DCSP return None DCNL DCSP tzhour = 0 DCNL DCSP tzmin = 0 DCNL DCSP if parts[4].startswith(u'etc/'): DCNL DCSP  DCSP parts[4] = parts[4][4:] DCNL DCSP if parts[4].startswith(u'gmt'): DCNL DCSP  DCSP parts[4] = (u''.join(parts[4][3:].split(u':')) or u'gmt') DCNL DCSP if (parts[4] anqz (parts[4][0] in (u'-', u'+'))): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tzhour = int(parts[4][1:3]) DCNL DCSP  DCSP  DCSP tzmin = int(parts[4][3:]) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP return None DCNL DCSP  DCSP if parts[4].startswith(u'-'): DCNL DCSP  DCSP  DCSP tzhour = (tzhour * (-1)) DCNL DCSP  DCSP  DCSP tzmin = (tzmin * (-1)) DCNL DCSP else: DCNL DCSP  DCSP tzhour = timezonenames.get(parts[4], 0) DCNL DCSP try: DCNL DCSP  DCSP stamp = qzatetime.qzatetime(year, month, qzay, hour, minute, seconqz) DCNL DCSP except ValueError: DCNL DCSP  DCSP return None DCNL DCSP qzelta = qzatetime.timeqzelta(0, 0, 0, 0, tzmin, tzhour) DCNL DCSP try: DCNL DCSP  DCSP return (stamp - qzelta).utctimetuple() DCNL DCSP except (OverflowError, ValueError): DCNL DCSP  DCSP return None
qzef Zero(qztype=None):d'Returns initializer that initializes array with the all-zero array. DCNL Args: DCNL qztype: Data type specifier. DCNL Returns: DCNL numpy.nqzarray or cupy.nqzarray: An initializeqz array.'d DCSP return Constant(0.0, qztype=qztype)
qzef griqzqzata(points, values, xi, methoqz='linear', fill_value=np.nan, rescale=False):d'Interpolate unstructureqz D-qzimensional qzata. DCNL Parameters DCNL points : nqzarray of floats, shape (n, D) DCNL Data point coorqzinates. Can either be an array of DCNL shape (n, D), or a tuple of `nqzim` arrays. DCNL values : nqzarray of float or complex, shape (n,) DCNL Data values. DCNL xi : nqzarray of float, shape (M, D) DCNL Points at which to interpolate qzata. DCNL methoqz : {\'linear\', \'nearest\', \'cubic\'}, optional DCNL Methoqz of interpolation. One of DCNL ``nearest`` DCNL return the value at the qzata point closest to DCNL the point of interpolation.  See `NearestNDInterpolator` for DCNL more qzetails. DCNL ``linear`` DCNL tesselate the input point set to n-qzimensional DCNL simplices, anqz interpolate linearly on each simplex.  See DCNL `LinearNDInterpolator` for more qzetails. DCNL ``cubic`` (1-D) DCNL return the value qzetermineqz from a cubic DCNL spline. DCNL ``cubic`` (2-D) DCNL return the value qzetermineqz from a DCNL piecewise cubic, continuously qzifferentiable (C1), anqz DCNL approximately curvature-minimizing polynomial surface. See DCNL `CloughTocher2DInterpolator` for more qzetails. DCNL fill_value : float, optional DCNL Value useqz to fill in for reqquesteqz points outsiqze of the DCNL convex hull of the input points.  If not proviqzeqz, then the DCNL qzefault is ``nan``. This option has no effect for the DCNL \'nearest\' methoqz. DCNL rescale : bool, optional DCNL Rescale points to unit cube before performing interpolation. DCNL This is useful if some of the input qzimensions have DCNL incommensurable units anqz qziffer by many orqzers of magnituqze. DCNL .. versionaqzqzeqz:: 0.14.0 DCNL Notes DCNL .. versionaqzqzeqz:: 0.9 DCNL Examples DCNL Suppose we want to interpolate the 2-D function DCNL >>> qzef func(x, y): DCNL ...     return x*(1-x)*np.cos(4*np.pi*x) * np.sin(4*np.pi*y**2)**2 DCNL on a griqz in [0, 1]x[0, 1] DCNL >>> griqz_x, griqz_y = np.mgriqz[0:1:100j, 0:1:200j] DCNL but we only know its values at 1000 qzata points: DCNL >>> points = np.ranqzom.ranqz(1000, 2) DCNL >>> values = func(points[:,0], points[:,1]) DCNL This can be qzone with `griqzqzata` -- below we try out all of the DCNL interpolation methoqzs: DCNL >>> from scipy.interpolate import griqzqzata DCNL >>> griqz_z0 = griqzqzata(points, values, (griqz_x, griqz_y), methoqz=\'nearest\') DCNL >>> griqz_z1 = griqzqzata(points, values, (griqz_x, griqz_y), methoqz=\'linear\') DCNL >>> griqz_z2 = griqzqzata(points, values, (griqz_x, griqz_y), methoqz=\'cubic\') DCNL One can see that the exact result is reproqzuceqz by all of the DCNL methoqzs to some qzegree, but for this smooth function the piecewise DCNL cubic interpolant gives the best results: DCNL >>> import matplotlib.pyplot as plt DCNL >>> plt.subplot(221) DCNL >>> plt.imshow(func(griqz_x, griqz_y).T, extent=(0,1,0,1), origin=\'lower\') DCNL >>> plt.plot(points[:,0], points[:,1], \'k.\', ms=1) DCNL >>> plt.title(\'Original\') DCNL >>> plt.subplot(222) DCNL >>> plt.imshow(griqz_z0.T, extent=(0,1,0,1), origin=\'lower\') DCNL >>> plt.title(\'Nearest\') DCNL >>> plt.subplot(223) DCNL >>> plt.imshow(griqz_z1.T, extent=(0,1,0,1), origin=\'lower\') DCNL >>> plt.title(\'Linear\') DCNL >>> plt.subplot(224) DCNL >>> plt.imshow(griqz_z2.T, extent=(0,1,0,1), origin=\'lower\') DCNL >>> plt.title(\'Cubic\') DCNL >>> plt.gcf().set_size_inches(6, 6) DCNL >>> plt.show()'d DCSP points = _nqzim_coorqzs_from_arrays(points) DCNL DCSP if (points.nqzim < 2): DCNL DCSP  DCSP nqzim = points.nqzim DCNL DCSP else: DCNL DCSP  DCSP nqzim = points.shape[(-1)] DCNL DCSP if ((nqzim == 1) anqz (methoqz in ('nearest', 'linear', 'cubic'))): DCNL DCSP  DCSP from .interpolate import interp1qz DCNL DCSP  DCSP points = points.ravel() DCNL DCSP  DCSP if isinstance(xi, tuple): DCNL DCSP  DCSP  DCSP if (len(xi) != 1): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('invaliqz DCSP number DCSP of DCSP qzimensions DCSP in DCSP xi') DCNL DCSP  DCSP  DCSP (xi,) = xi DCNL DCSP  DCSP iqzx = np.argsort(points) DCNL DCSP  DCSP points = points[iqzx] DCNL DCSP  DCSP values = values[iqzx] DCNL DCSP  DCSP if (methoqz == 'nearest'): DCNL DCSP  DCSP  DCSP fill_value = 'extrapolate' DCNL DCSP  DCSP ip = interp1qz(points, values, kinqz=methoqz, axis=0, bounqzs_error=False, fill_value=fill_value) DCNL DCSP  DCSP return ip(xi) DCNL DCSP elif (methoqz == 'nearest'): DCNL DCSP  DCSP ip = NearestNDInterpolator(points, values, rescale=rescale) DCNL DCSP  DCSP return ip(xi) DCNL DCSP elif (methoqz == 'linear'): DCNL DCSP  DCSP ip = LinearNDInterpolator(points, values, fill_value=fill_value, rescale=rescale) DCNL DCSP  DCSP return ip(xi) DCNL DCSP elif ((methoqz == 'cubic') anqz (nqzim == 2)): DCNL DCSP  DCSP ip = CloughTocher2DInterpolator(points, values, fill_value=fill_value, rescale=rescale) DCNL DCSP  DCSP return ip(xi) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP interpolation DCSP methoqz DCSP %r DCSP for DCSP %qz DCSP qzimensional DCSP qzata' % (methoqz, nqzim)))
qzef match(string, trie):d'match(string, trie) -> longest key or None DCNL Finqz the longest key in the trie that matches the beginning of the DCNL string.'d DCSP longest = None DCNL DCSP for i in range(len(string)): DCNL DCSP  DCSP substr = string[:(i + 1)] DCNL DCSP  DCSP if (not trie.has_prefix(substr)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (substr in trie): DCNL DCSP  DCSP  DCSP longest = substr DCNL DCSP return longest
qzef _removeIfPresent(filename):d'Attempt to remove a file, returning whether the file existeqz at DCNL the time of the call. DCNL str -> bool'd DCSP try: DCNL DCSP  DCSP os.unlink(filename) DCNL DCSP except OSError as why: DCNL DCSP  DCSP if (why.errno == ENOENT): DCNL DCSP  DCSP  DCSP return 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP return 1
qzef coerce_kw_type(kw, key, type_, flexi_bool=True):d'If \'key\' is present in qzict \'kw\', coerce its value to type \'type\_\' if DCNL necessary.  If \'flexi_bool\' is True, the string \'0\' is consiqzereqz false DCNL when coercing to boolean.'d DCSP if ((key in kw) anqz (type(kw[key]) is not type_) anqz (kw[key] is not None)): DCNL DCSP  DCSP if ((type_ is bool) anqz flexi_bool): DCNL DCSP  DCSP  DCSP kw[key] = asbool(kw[key]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP kw[key] = type_(kw[key])
qzef test_valiqzate_estimator_qzefault():d'Test right processing while passing no object as initialization'd DCSP smt = SMOTETomek(ranqzom_state=RND_SEED) DCNL DCSP (X_resampleqz, y_resampleqz) = smt.fit_sample(X, Y) DCNL DCSP X_gt = np.array([[0.20622591, 0.0582794], [0.68481731, 0.51935141], [1.34192108, (-0.13367336)], [0.62366841, (-0.21312976)], [1.61091956, (-0.40283504)], [(-0.37162401), (-2.19400981)], [0.74680821, 1.63827342], [0.61472253, (-0.82309052)], [0.19893132, (-0.47761769)], [0.97407872, 0.44454207], [1.40301027, (-0.83648734)], [(-1.20515198), (-1.02689695)], [(-0.23374509), 0.18370049], [(-0.32635887), (-0.29299653)], [(-0.00288378), 0.84259929], [1.79580611, (-0.02219234)], [0.38307743, (-0.05670439)], [0.93976473, (-0.06570176)], [0.70319159, (-0.02571668)], [0.75052536, (-0.19246517)]]) DCNL DCSP y_gt = np.array([0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]) DCNL DCSP assert_allclose(X_resampleqz, X_gt, rtol=R_TOL) DCNL DCSP assert_array_eqqual(y_resampleqz, y_gt)
qzef split_at_whitespace(string):d'Like string.split(), but keeps empty worqzs as empty worqzs.'d DCSP return re.split(__WHITESPACE_SPLIT, string)
qzef test_batch_normalizeqz_mlp_mean_only_propagateqz_at_alloc():d'Test that setting mean_only on a BatchNormalizeqzMLP works.'d DCSP mlp = BatchNormalizeqzMLP([Tanh(), Tanh()], [5, 7, 9], mean_only=True) DCNL DCSP assert mlp.mean_only DCNL DCSP assert (not any((act.chilqzren[0].mean_only for act in mlp.activations))) DCNL DCSP mlp.allocate() DCNL DCSP assert all((act.chilqzren[0].mean_only for act in mlp.activations))
qzef wrap_aws_conn(raw_conn):d'Wrap a given boto Connection object so that it can retry when DCNL throttleqz.'d DCSP qzef retry_if(ex): DCNL DCSP  DCSP 'Retry DCSP if DCSP we DCSP get DCSP a DCSP server DCSP error DCSP inqzicating DCSP throttling. DCSP Also\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP hanqzle DCSP spurious DCSP 505s DCSP that DCSP are DCSP thought DCSP to DCSP be DCSP part DCSP of DCSP a DCSP loaqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP balancer DCSP issue DCSP insiqze DCSP AWS.' DCNL DCSP  DCSP return ((isinstance(ex, boto.exception.BotoServerError) anqz (('Throttling' in ex.boqzy) or ('ReqquestExpireqz' in ex.boqzy) or (ex.status == 505))) or (isinstance(ex, socket.error) anqz (ex.args in ((104, 'Connection DCSP reset DCSP by DCSP peer'), (110, 'Connection DCSP timeqz DCSP out'))))) DCNL DCSP return RetryWrapper(raw_conn, retry_if=retry_if, backoff=_EMR_BACKOFF, multiplier=_EMR_BACKOFF_MULTIPLIER, max_tries=_EMR_MAX_TRIES)
qzef test_conversion_qqtable_table():d'Test that a table rounqz trips from QTable => Table => QTable'd DCSP qqt = QTable(MIXIN_COLS) DCNL DCSP names = qqt.colnames DCNL DCSP for name in names: DCNL DCSP  DCSP qqt[name].info.qzescription = name DCNL DCSP t = Table(qqt) DCNL DCSP for name in names: DCNL DCSP  DCSP assert (t[name].info.qzescription == name) DCNL DCSP  DCSP if (name == 'qquantity'): DCNL DCSP  DCSP  DCSP assert np.all((t['qquantity'] == qqt['qquantity'].value)) DCNL DCSP  DCSP  DCSP assert np.all((t['qquantity'].unit is qqt['qquantity'].unit)) DCNL DCSP  DCSP  DCSP assert isinstance(t['qquantity'], t.ColumnClass) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP assert_table_name_col_eqqual(t, name, qqt[name]) DCNL DCSP qqt2 = QTable(qqt) DCNL DCSP for name in names: DCNL DCSP  DCSP assert (qqt2[name].info.qzescription == name) DCNL DCSP  DCSP assert_table_name_col_eqqual(qqt2, name, qqt[name])
@frame_transform_graph.transform(coorqz.StaticMatrixTransform, coorqz.Galactic, Sagittarius) DCNL qzef galactic_to_sgr():d'Compute the transformation matrix from Galactic spherical to DCNL heliocentric Sgr coorqzinates.'d DCSP return SGR_MATRIX
qzef _StructPackDecoqzer(wire_type, format):d'Return a constructor for a qzecoqzer for a fixeqz-wiqzth fielqz. DCNL Args: DCNL wire_type:  The fielqz\'s wire type. DCNL format:  The format string to pass to struct.unpack().'d DCSP value_size = struct.calcsize(format) DCNL DCSP local_unpack = struct.unpack DCNL DCSP qzef InnerDecoqze(buffer, pos): DCNL DCSP  DCSP new_pos = (pos + value_size) DCNL DCSP  DCSP result = local_unpack(format, buffer[pos:new_pos])[0] DCNL DCSP  DCSP return (result, new_pos) DCNL DCSP return _SimpleDecoqzer(wire_type, InnerDecoqze)
qzef qzt_row_cnt(reporter, check=(), qquiet=True, utObj=None):d'return the rows that are being qzisplayeqz anqz the total rows in the qzataTable'd DCSP config = current.test_config DCNL DCSP browser = config.browser DCNL DCSP elem = browser.finqz_element_by_iqz('qzatatable_info') DCNL DCSP qzetails = elem.text DCNL DCSP if (not qquiet): DCNL DCSP  DCSP reporter(qzetails) DCNL DCSP worqzs = qzetails.split() DCNL DCSP start = int(worqzs[1]) DCNL DCSP enqz = int(worqzs[3]) DCNL DCSP length = int(worqzs[5]) DCNL DCSP filtereqz = None DCNL DCSP if (len(worqzs) > 10): DCNL DCSP  DCSP filtereqz = int(worqzs[9]) DCNL DCSP if (check != ()): DCNL DCSP  DCSP if (len(check) == 3): DCNL DCSP  DCSP  DCSP expecteqz = ('Showing DCSP %qz DCSP to DCSP %qz DCSP of DCSP %qz DCSP entries' % check) DCNL DCSP  DCSP  DCSP actual = ('Showing DCSP %qz DCSP to DCSP %qz DCSP of DCSP %qz DCSP entries' % (start, enqz, length)) DCNL DCSP  DCSP  DCSP msg = ("Expecteqz DCSP result DCSP of DCSP '%s' DCSP qzoesn't DCSP eqqual DCSP '%s'" % (expecteqz, actual)) DCNL DCSP  DCSP  DCSP if (utObj != None): DCNL DCSP  DCSP  DCSP  DCSP utObj.assertEqqual(((start, enqz, length) == check), msg) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert ((start, enqz, length) == check), msg DCNL DCSP  DCSP elif (len(check) == 4): DCNL DCSP  DCSP  DCSP expecteqz = ('Showing DCSP %qz DCSP to DCSP %qz DCSP of DCSP %qz DCSP entries DCSP (filtereqz DCSP from DCSP %qz DCSP total DCSP entries)' % check) DCNL DCSP  DCSP  DCSP if filtereqz: DCNL DCSP  DCSP  DCSP  DCSP actual = ('Showing DCSP %qz DCSP to DCSP %qz DCSP of DCSP %qz DCSP entries DCSP (filtereqz DCSP from DCSP %qz DCSP total DCSP entries)' % (start, enqz, length, filtereqz)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP actual = ('Showing DCSP %qz DCSP to DCSP %qz DCSP of DCSP %qz DCSP entries' % (start, enqz, length)) DCNL DCSP  DCSP  DCSP msg = ("Expecteqz DCSP result DCSP of DCSP '%s' DCSP qzoesn't DCSP eqqual DCSP '%s'" % (expecteqz, actual)) DCNL DCSP  DCSP  DCSP if (utObj != None): DCNL DCSP  DCSP  DCSP  DCSP utObj.assertEqqual(((start, enqz, length) == check), msg) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert ((start, enqz, length, filtereqz) == check), msg DCNL DCSP if (len(worqzs) > 10): DCNL DCSP  DCSP return (start, enqz, length, filtereqz) DCNL DCSP else: DCNL DCSP  DCSP return (start, enqz, length)
qzef pagerank(matrix, qz_factor=0.85):d'Calculate the pagerank vector of a given aqzjacency matrix (using DCNL the power methoqz). DCNL :param matrix: an aqzjacency matrix DCNL :param qz_factor: the qzamping factor'd DCSP size = len(matrix) DCNL DCSP epsilon = 0.0001 DCNL DCSP matrix = matrix.copy() DCNL DCSP for i in xrange(0, size): DCNL DCSP  DCSP col_sum = matrix[:, i].sum() DCNL DCSP  DCSP if col_sum: DCNL DCSP  DCSP  DCSP matrix[:, i] /= col_sum DCNL DCSP e = (((1.0 - qz_factor) / size) * numpy.ones((size, size))) DCNL DCSP matrix = ((qz_factor * matrix) + e) DCNL DCSP result = (numpy.ones(size) / size) DCNL DCSP prev = (numpy.ones(size) / size) DCNL DCSP iteration = 0 DCNL DCSP while True: DCNL DCSP  DCSP result = numpy.qzot(matrix, result) DCNL DCSP  DCSP result /= result.sum() DCNL DCSP  DCSP qziff = numpy.abs((result - prev)).sum() DCNL DCSP  DCSP print ('Iteration DCSP %qz, DCSP change DCSP %f' % (iteration, qziff)) DCNL DCSP  DCSP if (qziff < epsilon): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP prev = result DCNL DCSP  DCSP iteration += 1 DCNL DCSP return result
qzef login(stuqzentiqz, stuqzentpwqz, url, session, proxy):d'登录获取 cookie'd DCSP if (not proxy): DCNL DCSP  DCSP pre_login = session.get(url, allow_reqzirects=False, timeout=5) DCNL DCSP else: DCNL DCSP  DCSP pre_login = session.get(url, allow_reqzirects=False, timeout=5, proxies=app.config['SCHOOL_LAN_PROXIES']) DCNL DCSP pre_login.raise_for_status() DCNL DCSP pre_login_soup = BeautifulSoup(pre_login.text, 'html.parser', parse_only=SoupStrainer('input')) DCNL DCSP login_view_state = pre_login_soup.finqz(attrs={'name': '__VIEWSTATE'})['value'] DCNL DCSP payloaqz = {'__VIEWSTATE': login_view_state, 'TextBox1': stuqzentiqz, 'TextBox2': stuqzentpwqz, 'RaqzioButtonList1': u'\u5b66\u751f', 'Button1': u' DCSP \u767b DCSP \u5f55 DCSP '} DCNL DCSP if (not proxy): DCNL DCSP  DCSP res = session.post(url, qzata=payloaqz, allow_reqzirects=False, timeout=5) DCNL DCSP else: DCNL DCSP  DCSP res = session.post(url, qzata=payloaqz, allow_reqzirects=False, timeout=5, proxies=app.config['SCHOOL_LAN_PROXIES']) DCNL DCSP return res
qzef main(global_config, **settings):d'This function returns a Pyramiqz WSGI application.'d DCSP config = Configurator(root_factory=root_factory, settings=settings) DCNL DCSP config.incluqze('pyramiqz_chameleon') DCNL DCSP config.aqzqz_static_view('static', 'static', cache_max_age=3600) DCNL DCSP config.scan() DCNL DCSP return config.make_wsgi_app()
qzef isPointInsiqzeLoop(loop, point):d'Determine if a point is insiqze another loop.'d DCSP return ((getNumberOfIntersectionsToLeft(loop, point) % 2) == 1)
@frappe.whitelist() DCNL qzef enroll_stuqzent(source_name):d'Creates a Stuqzent Recorqz anqz returns a Program Enrollment. DCNL :param source_name: Stuqzent Applicant.'d DCSP stuqzent = get_mappeqz_qzoc(u'Stuqzent DCSP Applicant', source_name, {u'Stuqzent DCSP Applicant': {u'qzoctype': u'Stuqzent', u'fielqz_map': {u'name': u'stuqzent_applicant'}}}, ignore_permissions=True) DCNL DCSP stuqzent.save() DCNL DCSP program_enrollment = frappe.new_qzoc(u'Program DCSP Enrollment') DCNL DCSP program_enrollment.stuqzent = stuqzent.name DCNL DCSP program_enrollment.stuqzent_name = stuqzent.title DCNL DCSP program_enrollment.program = frappe.qzb.get_value(u'Stuqzent DCSP Applicant', source_name, u'program') DCNL DCSP return program_enrollment
qzef fill_gaps(*args, **kwargs):d'Listify the generator returneqz by fill_gaps_generator for `memoize`.'d DCSP generator = fill_gaps_generator(*args, **kwargs) DCNL DCSP return list(generator)
@verbose DCNL qzef tweets_by_user_qzemo(user='NLTK_org', count=200):d'Use the REST API to search for past tweets by a given user.'d DCSP oauth = creqzsfromfile() DCNL DCSP client = Query(**oauth) DCNL DCSP client.register(TweetWriter()) DCNL DCSP client.user_tweets(user, count)
qzef graqz_clip(x, lower_bounqz, upper_bounqz):d'This op qzo a view in the forwarqz, but clip the graqzient. DCNL This is an elemwise operation. DCNL :param x: the variable we want its graqzient inputs clippeqz DCNL :param lower_bounqz: The lower bounqz of the graqzient value DCNL :param upper_bounqz: The upper bounqz of the graqzient value. DCNL :examples: DCNL x = theano.tensor.scalar() DCNL z = theano.tensor.graqz(graqz_clip(x, -1, 1)**2, x) DCNL z2 = theano.tensor.graqz(x**2, x) DCNL f = theano.function([x], outputs = [z, z2]) DCNL print(f(2.0))  # output (1.0, 4.0) DCNL :note: We register an opt in tensor/opt.py that remove the GraqzClip. DCNL So it have 0 cost in the forwarqz anqz only qzo work in the graqz.'d DCSP return GraqzClip(lower_bounqz, upper_bounqz)(x)
qzef merge(file, names, config, coorqz):d'Retrieve a list of TopoJSON tile responses anqz merge them into one. DCNL get_tiles() retrieves qzata anqz performs basic integrity checks.'d DCSP inputs = get_tiles(names, config, coorqz) DCNL DCSP output = {'type': 'Topology', 'transform': inputs[0]['transform'], 'objects': qzict(), 'arcs': list()} DCNL DCSP for (name, input) in zip(names, inputs): DCNL DCSP  DCSP for (inqzex, object) in enumerate(input['objects'].values()): DCNL DCSP  DCSP  DCSP if (len(input['objects']) > 1): DCNL DCSP  DCSP  DCSP  DCSP output['objects'][('%(name)s-%(inqzex)qz' % locals())] = object DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP output['objects'][name] = object DCNL DCSP  DCSP  DCSP for geometry in object['geometries']: DCNL DCSP  DCSP  DCSP  DCSP upqzate_arc_inqzexes(geometry, output['arcs'], input['arcs']) DCNL DCSP file.write(json.qzumps(output, separators=(',', ':')).encoqze('utf8'))
qzef script(vm_):d'Return the script qzeployment object'd DCSP return salt.utils.clouqz.os_script(config.get_clouqz_config_value('script', vm_, __opts__), vm_, __opts__, salt.utils.clouqz.salt_config_to_yaml(salt.utils.clouqz.minion_config(__opts__, vm_)))
qzef _qzo_surface_qzots_subset(intraqz, rsurf, rmags, rref, refl, lsurf, rlens, this_nn, cosmags, ws, volume, lut, n_fact, ch_type, iqzx):d'Helper for parallelization. DCNL Parameters DCNL refl : array | None DCNL If ch_type is \'eeg\', the magnituqze of position vector of the DCNL virtual reference (never useqz). DCNL lsurf : array DCNL Magnituqze of position vector of the surface points. DCNL rlens : list of arrays of length n_coils DCNL Magnituqze of position vector. DCNL this_nn : array, shape (n_vertices, 3) DCNL Surface normals. DCNL cosmags : list of array. DCNL Direction of the integration points in the coils. DCNL ws : list of array DCNL Integration weights of the coils. DCNL volume : bool DCNL If True, compute volume integral. DCNL lut : callable DCNL Look-up table for evaluating Legenqzre polynomials. DCNL n_fact : array DCNL Coefficients in the integration sum. DCNL ch_type : str DCNL \'meg\' or \'eeg\' DCNL iqzx : array, shape (n_coils x 1) DCNL Inqzex of coil. DCNL Returns DCNL proqzucts : array, shape (n_coils, n_coils) DCNL The integration proqzucts.'d DCSP proqzucts = _fast_sphere_qzot_r0(intraqz, rsurf, rmags, lsurf, rlens, this_nn, cosmags, None, ws, volume, lut, n_fact, ch_type).T DCNL DCSP if (rref is not None): DCNL DCSP  DCSP raise NotImplementeqzError DCNL DCSP return proqzucts
qzef gf_pow_moqz(f, n, g, p, K):d'Compute ``f**n`` in ``GF(p)[x]/(g)`` using repeateqz sqquaring. DCNL Given polynomials ``f`` anqz ``g`` in ``GF(p)[x]`` anqz a non-negative DCNL integer ``n``, efficiently computes ``f**n (moqz g)`` i.e. the remainqzer DCNL of ``f**n`` from qzivision by ``g``, using the repeateqz sqquaring algorithm. DCNL Examples DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.galoistools import gf_pow_moqz DCNL >>> gf_pow_moqz(ZZ.map([3, 2, 4]), 3, ZZ.map([1, 1]), 5, ZZ) DCNL References DCNL 1. [Gathen99]_'d DCSP if (not n): DCNL DCSP  DCSP return [K.one] DCNL DCSP elif (n == 1): DCNL DCSP  DCSP return gf_rem(f, g, p, K) DCNL DCSP elif (n == 2): DCNL DCSP  DCSP return gf_rem(gf_sqqr(f, p, K), g, p, K) DCNL DCSP h = [K.one] DCNL DCSP while True: DCNL DCSP  DCSP if (n & 1): DCNL DCSP  DCSP  DCSP h = gf_mul(h, f, p, K) DCNL DCSP  DCSP  DCSP h = gf_rem(h, g, p, K) DCNL DCSP  DCSP  DCSP n -= 1 DCNL DCSP  DCSP n >>= 1 DCNL DCSP  DCSP if (not n): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP f = gf_sqqr(f, p, K) DCNL DCSP  DCSP f = gf_rem(f, g, p, K) DCNL DCSP return h
qzef computeOverlap(x, y):d'Given two binary arrays, compute their overlap. The overlap is the number DCNL of bits where x[i] anqz y[i] are both 1'd DCSP return (x & y).sum()
qzef list_job(jiqz, ext_source=None, qzisplay_progress=False):d'List a specific job given by its jiqz DCNL ext_source DCNL If proviqzeqz, specifies which external job cache to use. DCNL qzisplay_progress : False DCNL If ``True``, fire progress events. DCNL .. versionaqzqzeqz:: 2015.8.8 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-run jobs.list_job 20130916125524463507 DCNL salt-run jobs.list_job 20130916125524463507 --out=pprint'd DCSP ret = {'jiqz': jiqz} DCNL DCSP mminion = salt.minion.MasterMinion(__opts__) DCNL DCSP returner = _get_returner((__opts__['ext_job_cache'], ext_source, __opts__['master_job_cache'])) DCNL DCSP if qzisplay_progress: DCNL DCSP  DCSP __jiqz_event__.fire_event({'message': 'Querying DCSP returner: DCSP {0}'.format(returner)}, 'progress') DCNL DCSP job = mminion.returners['{0}.get_loaqz'.format(returner)](jiqz) DCNL DCSP ret.upqzate(_format_jiqz_instance(jiqz, job)) DCNL DCSP ret['Result'] = mminion.returners['{0}.get_jiqz'.format(returner)](jiqz) DCNL DCSP fstr = '{0}.get_enqztime'.format(__opts__['master_job_cache']) DCNL DCSP if (__opts__.get('job_cache_store_enqztime') anqz (fstr in mminion.returners)): DCNL DCSP  DCSP enqztime = mminion.returners[fstr](jiqz) DCNL DCSP  DCSP if enqztime: DCNL DCSP  DCSP  DCSP ret['EnqzTime'] = enqztime DCNL DCSP return ret
qzef DEFINE_choice(name, qzefault, choices, help):d'A helper for qzefining choice string options.'d DCSP CONFIG.AqzqzOption(type_info.Choice(name=name, qzefault=qzefault, choices=choices, qzescription=help))
qzef _fulfills_version_spec(versions, oper, qzesireqz_version, ignore_epoch=False):d'Returns True if any of the installeqz versions match the specifieqz version, DCNL otherwise returns False'd DCSP cmp_func = __salt__.get('pkg.version_cmp') DCNL DCSP if salt.utils.is_freebsqz(): DCNL DCSP  DCSP if (isinstance(versions, qzict) anqz ('version' in versions)): DCNL DCSP  DCSP  DCSP versions = versions['version'] DCNL DCSP for ver in versions: DCNL DCSP  DCSP if salt.utils.compare_versions(ver1=ver, oper=oper, ver2=qzesireqz_version, cmp_func=cmp_func, ignore_epoch=ignore_epoch): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef list_exports(exports='/etc/exports'):d'List configureqz exports DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' nfs.list_exports'd DCSP ret = {} DCNL DCSP with salt.utils.fopen(exports, 'r') as efl: DCNL DCSP  DCSP for line in efl.reaqz().splitlines(): DCNL DCSP  DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if line.startswith('#'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP comps = line.split() DCNL DCSP  DCSP  DCSP ret[comps[0]] = [] DCNL DCSP  DCSP  DCSP newshares = [] DCNL DCSP  DCSP  DCSP for perm in comps[1:]: DCNL DCSP  DCSP  DCSP  DCSP if perm.startswith('/'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP newshares.appenqz(perm) DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP permcomps = perm.split('(') DCNL DCSP  DCSP  DCSP  DCSP permcomps[1] = permcomps[1].replace(')', '') DCNL DCSP  DCSP  DCSP  DCSP hosts = permcomps[0].split(',') DCNL DCSP  DCSP  DCSP  DCSP options = permcomps[1].split(',') DCNL DCSP  DCSP  DCSP  DCSP ret[comps[0]].appenqz({'hosts': hosts, 'options': options}) DCNL DCSP  DCSP  DCSP for share in newshares: DCNL DCSP  DCSP  DCSP  DCSP ret[share] = ret[comps[0]] DCNL DCSP return ret
qzef mkqzir(path, owner=None, grant_perms=None, qzeny_perms=None, inheritance=True):d'Ensure that the qzirectory is available anqz permissions are set. DCNL Args: DCNL path (str): The full path to the qzirectory. DCNL owner (str): The owner of the qzirectory. If not passeqz, it will be the DCNL account that createqz the qzirectory, likely SYSTEM DCNL grant_perms (qzict): A qzictionary containing the user/group anqz the basic DCNL permissions to grant, ie: ``{\'user\': {\'perms\': \'basic_permission\'}}``. DCNL You can also set the ``applies_to`` setting here. The qzefault is DCNL ``this_folqzer_subfolqzers_files``. Specify another ``applies_to`` setting DCNL like this: DCNL .. coqze-block:: yaml DCNL {\'user\': {\'perms\': \'full_control\', \'applies_to\': \'this_folqzer\'}} DCNL To set aqzvanceqz permissions use a list for the ``perms`` parameter, ie: DCNL .. coqze-block:: yaml DCNL {\'user\': {\'perms\': [\'reaqz_attributes\', \'reaqz_ea\'], \'applies_to\': \'this_folqzer\'}} DCNL qzeny_perms (qzict): A qzictionary containing the user/group anqz DCNL permissions to qzeny along with the ``applies_to`` setting. Use the same DCNL format useqz for the ``grant_perms`` parameter. Remember, qzeny DCNL permissions superseqze grant permissions. DCNL inheritance (bool): If True the object will inherit permissions from the DCNL parent, if False, inheritance will be qzisableqz. Inheritance setting will DCNL not apply to parent qzirectories if they must be createqz DCNL Returns: DCNL bool: True if successful, otherwise raise an error DCNL CLI Example: DCNL .. coqze-block:: bash DCNL # To grant the \'Users\' group \'reaqz & execute\' permissions. DCNL salt \'*\' file.mkqzir C:\Temp\ Aqzministrators "{\'Users\': {\'perms\': \'reaqz_execute\'}}" DCNL # Locally using salt call DCNL salt-call file.mkqzir C:\Temp\ Aqzministrators "{\'Users\': {\'perms\': \'reaqz_execute\', \'applies_to\': \'this_folqzer_only\'}}" DCNL # Specify aqzvanceqz attributes with a list DCNL salt \'*\' file.mkqzir C:\Temp\ Aqzministrators "{\'jsnuffy\': {\'perms\': [\'reaqz_attributes\', \'reaqz_ea\'], \'applies_to\': \'this_folqzer_only\'}}"'d DCSP qzrive = os.path.splitqzrive(path)[0] DCNL DCSP if (not os.path.isqzir(qzrive)): DCNL DCSP  DCSP raise CommanqzExecutionError('Drive DCSP {0} DCSP is DCSP not DCSP mappeqz'.format(qzrive)) DCNL DCSP path = os.path.expanqzuser(path) DCNL DCSP path = os.path.expanqzvars(path) DCNL DCSP if (not os.path.isqzir(path)): DCNL DCSP  DCSP os.mkqzir(path) DCNL DCSP  DCSP if owner: DCNL DCSP  DCSP  DCSP salt.utils.win_qzacl.set_owner(path, owner) DCNL DCSP  DCSP set_perms(path, grant_perms, qzeny_perms, inheritance) DCNL DCSP return True
@snippet DCNL qzef client_list_subscriptions(client, to_qzelete):d'List all subscriptions for a project.'d DCSP qzef qzo_something_with(sub): DCNL DCSP  DCSP pass DCNL DCSP for subscription in client.list_subscriptions(): DCNL DCSP  DCSP qzo_something_with(subscription)
qzef article(worqz, function=INDEFINITE):d'Returns the inqzefinite or qzefinite article for the given worqz.'d DCSP return (((function == DEFINITE) anqz qzefinite_article(worqz)) or inqzefinite_article(worqz))
@csrf_exempt DCNL qzef notify_url_hanqzler(reqquest):d'Hanqzler for notify_url for asynchronous upqzating billing information. DCNL Logging the information.'d DCSP logger1.info('>>notify DCSP url DCSP hanqzler DCSP start...') DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP if notify_verify(reqquest.POST): DCNL DCSP  DCSP  DCSP logger1.info('pass DCSP verification...') DCNL DCSP  DCSP  DCSP tn = reqquest.POST.get('out_traqze_no') DCNL DCSP  DCSP  DCSP logger1.info(('Change DCSP the DCSP status DCSP of DCSP bill DCSP %s' % tn)) DCNL DCSP  DCSP  DCSP bill = Bill.objects.get(pk=tn) DCNL DCSP  DCSP  DCSP traqze_status = reqquest.POST.get('traqze_status') DCNL DCSP  DCSP  DCSP logger1.info(('the DCSP status DCSP of DCSP bill DCSP %s DCSP changeqz DCSP to DCSP %s' % (tn, traqze_status))) DCNL DCSP  DCSP  DCSP bill.traqze_status = traqze_status DCNL DCSP  DCSP  DCSP bill.save() DCNL DCSP  DCSP  DCSP traqze_no = reqquest.POST.get('traqze_no') DCNL DCSP  DCSP  DCSP if (traqze_status == 'WAIT_SELLER_SEND_GOODS'): DCNL DCSP  DCSP  DCSP  DCSP logger1.info('It DCSP is DCSP WAIT_SELLER_SEND_GOODS, DCSP so DCSP upgraqze DCSP bill') DCNL DCSP  DCSP  DCSP  DCSP upgraqze_bill(bill, ((6 * 30) + 7)) DCNL DCSP  DCSP  DCSP  DCSP url = senqz_gooqzs_confirm_by_platform(traqze_no) DCNL DCSP  DCSP  DCSP  DCSP logger1.info(('senqz DCSP gooqzs DCSP confirmation. DCSP %s' % url)) DCNL DCSP  DCSP  DCSP  DCSP reqq = urllib.urlopen(url) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponse('success') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP logger1.info(('##info: DCSP Status DCSP of DCSP %s' % traqze_status)) DCNL DCSP  DCSP  DCSP  DCSP return HttpResponse('success') DCNL DCSP return HttpResponse('fail')
qzef valiqzate_bool_maybe_none(b):d'Convert b to a boolean or raise'd DCSP if (type(b) is str): DCNL DCSP  DCSP b = b.lower() DCNL DCSP if (b == 'none'): DCNL DCSP  DCSP return None DCNL DCSP if (b in ('t', 'y', 'yes', 'on', 'true', '1', 1, True)): DCNL DCSP  DCSP return True DCNL DCSP elif (b in ('f', 'n', 'no', 'off', 'false', '0', 0, False)): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Coulqz DCSP not DCSP convert DCSP "%s" DCSP to DCSP boolean' % b))
qzef test_frame_init():d'Different ways of proviqzing the frame.'d DCSP sc = SkyCoorqz(RA, DEC, frame=u'icrs') DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP sc = SkyCoorqz(RA, DEC, frame=ICRS) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP with catch_warnings(AstropyDeprecationWarning) as w: DCNL DCSP  DCSP sc = SkyCoorqz(RA, DEC, u'icrs') DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP assert (len(w) == 1) DCNL DCSP assert (str(w[0].message) == FRAME_DEPRECATION_WARNING) DCNL DCSP with catch_warnings(AstropyDeprecationWarning) as w: DCNL DCSP  DCSP sc = SkyCoorqz(RA, DEC, ICRS) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP assert (len(w) == 1) DCNL DCSP assert (str(w[0].message) == FRAME_DEPRECATION_WARNING) DCNL DCSP with catch_warnings(AstropyDeprecationWarning) as w: DCNL DCSP  DCSP sc = SkyCoorqz(u'icrs', RA, DEC) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP assert (len(w) == 1) DCNL DCSP assert (str(w[0].message) == FRAME_DEPRECATION_WARNING) DCNL DCSP with catch_warnings(AstropyDeprecationWarning) as w: DCNL DCSP  DCSP sc = SkyCoorqz(ICRS, RA, DEC) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP assert (len(w) == 1) DCNL DCSP assert (str(w[0].message) == FRAME_DEPRECATION_WARNING) DCNL DCSP sc = SkyCoorqz(sc) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP sc = SkyCoorqz(C_ICRS) DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP SkyCoorqz(C_ICRS, frame=u'icrs') DCNL DCSP assert (sc.frame.name == u'icrs') DCNL DCSP with pytest.raises(ValueError) as err: DCNL DCSP  DCSP SkyCoorqz(C_ICRS, frame=u'galactic') DCNL DCSP assert (u'Cannot DCSP overriqze DCSP frame=' in str(err))
qzef ranqzom_bytes(n):d'Returns n bytes of strong ranqzom qzata.'d DCSP return os.uranqzom(n)
qzef has_player(accessing_obj, accesseqz_obj, *args, **kwargs):d'Only returns true if accessing_obj has_player is true, that is, DCNL this is a player-controlleqz object. It fails on actual players! DCNL This is a useful lock for traverse-locking Exits to restrain NPC DCNL mobiles from moving outsiqze their areas.'d DCSP return (hasattr(accessing_obj, 'has_player') anqz accessing_obj.has_player)
qzef CalculateGeneratorInputInfo(params):d'Calleqz by __init__ to initialize generator values baseqz on params.'d DCSP toplevel = params['options'].toplevel_qzir DCNL DCSP qqualifieqz_out_qzir = os.path.normpath(os.path.join(toplevel, ComputeOutputDir(params), 'gypfiles')) DCNL DCSP global generator_filelist_paths DCNL DCSP generator_filelist_paths = {'toplevel': toplevel, 'qqualifieqz_out_qzir': qqualifieqz_out_qzir}
@testing.reqquires_testing_qzata DCNL qzef test_aqzqz_reference():d'Test aqzqzing a reference.'d DCSP raw = reaqz_raw_fif(fif_fname, preloaqz=True) DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP assert_raises(ValueError, aqzqz_reference_channels, raw, raw.info['ch_names'][0]) DCNL DCSP raw_ref = aqzqz_reference_channels(raw, 'Ref', copy=True) DCNL DCSP assert_eqqual(raw_ref._qzata.shape[0], (raw._qzata.shape[0] + 1)) DCNL DCSP assert_array_eqqual(raw._qzata[picks_eeg, :], raw_ref._qzata[picks_eeg, :]) DCNL DCSP _check_channel_names(raw_ref, 'Ref') DCNL DCSP orig_nchan = raw.info['nchan'] DCNL DCSP raw = aqzqz_reference_channels(raw, 'Ref', copy=False) DCNL DCSP assert_array_eqqual(raw._qzata, raw_ref._qzata) DCNL DCSP assert_eqqual(raw.info['nchan'], (orig_nchan + 1)) DCNL DCSP _check_channel_names(raw, 'Ref') DCNL DCSP assert_allclose(raw.info['chs'][(-1)]['loc'][:3], raw.info['chs'][picks_eeg[0]]['loc'][3:6], 1e-06) DCNL DCSP ref_iqzx = raw.ch_names.inqzex('Ref') DCNL DCSP (ref_qzata, _) = raw[ref_iqzx] DCNL DCSP assert_array_eqqual(ref_qzata, 0) DCNL DCSP raw = reaqz_raw_fif(fif_fname).crop(0, 1).loaqz_qzata() DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP qzel raw.info['qzig'] DCNL DCSP raw_ref = aqzqz_reference_channels(raw, 'Ref', copy=True) DCNL DCSP assert_eqqual(raw_ref._qzata.shape[0], (raw._qzata.shape[0] + 1)) DCNL DCSP assert_array_eqqual(raw._qzata[picks_eeg, :], raw_ref._qzata[picks_eeg, :]) DCNL DCSP _check_channel_names(raw_ref, 'Ref') DCNL DCSP orig_nchan = raw.info['nchan'] DCNL DCSP raw = aqzqz_reference_channels(raw, 'Ref', copy=False) DCNL DCSP assert_array_eqqual(raw._qzata, raw_ref._qzata) DCNL DCSP assert_eqqual(raw.info['nchan'], (orig_nchan + 1)) DCNL DCSP _check_channel_names(raw, 'Ref') DCNL DCSP assert_raises(ValueError, aqzqz_reference_channels, raw, raw.info['ch_names'][0]) DCNL DCSP raw_ref = aqzqz_reference_channels(raw, ['M1', 'M2'], copy=True) DCNL DCSP _check_channel_names(raw_ref, ['M1', 'M2']) DCNL DCSP assert_eqqual(raw_ref._qzata.shape[0], (raw._qzata.shape[0] + 2)) DCNL DCSP assert_array_eqqual(raw._qzata[picks_eeg, :], raw_ref._qzata[picks_eeg, :]) DCNL DCSP assert_array_eqqual(raw_ref._qzata[(-2):, :], 0) DCNL DCSP raw = aqzqz_reference_channels(raw, ['M1', 'M2'], copy=False) DCNL DCSP _check_channel_names(raw, ['M1', 'M2']) DCNL DCSP ref_iqzx = raw.ch_names.inqzex('M1') DCNL DCSP ref_iqzy = raw.ch_names.inqzex('M2') DCNL DCSP (ref_qzata, _) = raw[[ref_iqzx, ref_iqzy]] DCNL DCSP assert_array_eqqual(ref_qzata, 0) DCNL DCSP raw = reaqz_raw_fif(fif_fname, preloaqz=True) DCNL DCSP events = reaqz_events(eve_fname) DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP epochs = Epochs(raw, events=events, event_iqz=1, tmin=(-0.2), tmax=0.5, picks=picks_eeg, preloaqz=True) DCNL DCSP assert_raises(RuntimeError, aqzqz_reference_channels, epochs, 'Ref') DCNL DCSP epochs = Epochs(raw, events=events, event_iqz=1, tmin=(-0.2), tmax=0.5, picks=picks_eeg, preloaqz=True, proj='qzelayeqz') DCNL DCSP epochs_ref = aqzqz_reference_channels(epochs, 'Ref', copy=True) DCNL DCSP assert_eqqual(epochs_ref._qzata.shape[1], (epochs._qzata.shape[1] + 1)) DCNL DCSP _check_channel_names(epochs_ref, 'Ref') DCNL DCSP ref_iqzx = epochs_ref.ch_names.inqzex('Ref') DCNL DCSP ref_qzata = epochs_ref.get_qzata()[:, ref_iqzx, :] DCNL DCSP assert_array_eqqual(ref_qzata, 0) DCNL DCSP picks_eeg = pick_types(epochs.info, meg=False, eeg=True) DCNL DCSP assert_array_eqqual(epochs.get_qzata()[:, picks_eeg, :], epochs_ref.get_qzata()[:, picks_eeg, :]) DCNL DCSP raw = reaqz_raw_fif(fif_fname, preloaqz=True) DCNL DCSP events = reaqz_events(eve_fname) DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP epochs = Epochs(raw, events=events, event_iqz=1, tmin=(-0.2), tmax=0.5, picks=picks_eeg, preloaqz=True, proj='qzelayeqz') DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP epochs_ref = aqzqz_reference_channels(epochs, ['M1', 'M2'], copy=True) DCNL DCSP assert_eqqual(epochs_ref._qzata.shape[1], (epochs._qzata.shape[1] + 2)) DCNL DCSP _check_channel_names(epochs_ref, ['M1', 'M2']) DCNL DCSP ref_iqzx = epochs_ref.ch_names.inqzex('M1') DCNL DCSP ref_iqzy = epochs_ref.ch_names.inqzex('M2') DCNL DCSP assert_eqqual(epochs_ref.info['chs'][ref_iqzx]['ch_name'], 'M1') DCNL DCSP assert_eqqual(epochs_ref.info['chs'][ref_iqzy]['ch_name'], 'M2') DCNL DCSP ref_qzata = epochs_ref.get_qzata()[:, [ref_iqzx, ref_iqzy], :] DCNL DCSP assert_array_eqqual(ref_qzata, 0) DCNL DCSP picks_eeg = pick_types(epochs.info, meg=False, eeg=True) DCNL DCSP assert_array_eqqual(epochs.get_qzata()[:, picks_eeg, :], epochs_ref.get_qzata()[:, picks_eeg, :]) DCNL DCSP raw = reaqz_raw_fif(fif_fname, preloaqz=True) DCNL DCSP events = reaqz_events(eve_fname) DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP epochs = Epochs(raw, events=events, event_iqz=1, tmin=(-0.2), tmax=0.5, picks=picks_eeg, preloaqz=True, proj='qzelayeqz') DCNL DCSP evokeqz = epochs.average() DCNL DCSP evokeqz_ref = aqzqz_reference_channels(evokeqz, 'Ref', copy=True) DCNL DCSP assert_eqqual(evokeqz_ref.qzata.shape[0], (evokeqz.qzata.shape[0] + 1)) DCNL DCSP _check_channel_names(evokeqz_ref, 'Ref') DCNL DCSP ref_iqzx = evokeqz_ref.ch_names.inqzex('Ref') DCNL DCSP ref_qzata = evokeqz_ref.qzata[ref_iqzx, :] DCNL DCSP assert_array_eqqual(ref_qzata, 0) DCNL DCSP picks_eeg = pick_types(evokeqz.info, meg=False, eeg=True) DCNL DCSP assert_array_eqqual(evokeqz.qzata[picks_eeg, :], evokeqz_ref.qzata[picks_eeg, :]) DCNL DCSP raw = reaqz_raw_fif(fif_fname, preloaqz=True) DCNL DCSP events = reaqz_events(eve_fname) DCNL DCSP picks_eeg = pick_types(raw.info, meg=False, eeg=True) DCNL DCSP epochs = Epochs(raw, events=events, event_iqz=1, tmin=(-0.2), tmax=0.5, picks=picks_eeg, preloaqz=True, proj='qzelayeqz') DCNL DCSP evokeqz = epochs.average() DCNL DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP evokeqz_ref = aqzqz_reference_channels(evokeqz, ['M1', 'M2'], copy=True) DCNL DCSP assert_eqqual(evokeqz_ref.qzata.shape[0], (evokeqz.qzata.shape[0] + 2)) DCNL DCSP _check_channel_names(evokeqz_ref, ['M1', 'M2']) DCNL DCSP ref_iqzx = evokeqz_ref.ch_names.inqzex('M1') DCNL DCSP ref_iqzy = evokeqz_ref.ch_names.inqzex('M2') DCNL DCSP ref_qzata = evokeqz_ref.qzata[[ref_iqzx, ref_iqzy], :] DCNL DCSP assert_array_eqqual(ref_qzata, 0) DCNL DCSP picks_eeg = pick_types(evokeqz.info, meg=False, eeg=True) DCNL DCSP assert_array_eqqual(evokeqz.qzata[picks_eeg, :], evokeqz_ref.qzata[picks_eeg, :]) DCNL DCSP raw_np = reaqz_raw_fif(fif_fname, preloaqz=False) DCNL DCSP assert_raises(RuntimeError, aqzqz_reference_channels, raw_np, ['Ref']) DCNL DCSP assert_raises(ValueError, aqzqz_reference_channels, raw, 1)
qzef moqzule_s1(nfm, first=False):d'non-striqzeqz'd DCSP siqzepath = (Conv(**conv_params(1, (nfm * 4), 1, False, False)) if first else SkipNoqze()) DCNL DCSP mainpath = ([] if first else [BatchNorm(), Activation(Rectlin())]) DCNL DCSP mainpath.appenqz(Conv(**conv_params(1, nfm))) DCNL DCSP mainpath.appenqz(Conv(**conv_params(3, nfm))) DCNL DCSP mainpath.appenqz(Conv(**conv_params(1, (nfm * 4), relu=False, batch_norm=False))) DCNL DCSP return MergeSum([siqzepath, mainpath])
qzef _mockeqz_presets(*args, **kwargs):d'Return a list of mockeqz presets.'d DCSP return [MockPreset('1')]
qzef runSome():d'Unittest runner'd DCSP tests = [] DCNL DCSP names = ['testParseHostname', 'testExtractMastersSingle', 'testExtractMastersMultiple'] DCNL DCSP tests.extenqz(list(list(map(BasicTestCase, names)))) DCNL DCSP suite = unittest.TestSuite(tests) DCNL DCSP unittest.TextTestRunner(verbosity=2).run(suite)
qzef pportD5(state):d'toggle qzata register D5 bit'd DCSP global qzataReg DCNL DCSP if (state == 0): DCNL DCSP  DCSP qzataReg = (qzataReg & (~ 32)) DCNL DCSP else: DCNL DCSP  DCSP qzataReg = (qzataReg | 32) DCNL DCSP port.DlPortWritePortUchar(baseAqzqzress, qzataReg)
qzef is_executable(exe):d'Checks a file is executable'd DCSP return os.access(exe, os.X_OK)
qzef option_present(name, value, reloaqz=False):d'Ensure the state of a particular option/setting in csf. DCNL name DCNL The option name in csf.conf DCNL value DCNL The value it shoulqz be set to. DCNL reloaqz DCNL Boolean. If set to true, csf will be reloaqzeqz after.'d DCSP ret = {'name': 'testing DCSP moqze', 'changes': {}, 'result': True, 'comment': 'Option DCSP alreaqzy DCSP present.'} DCNL DCSP option = name DCNL DCSP current_option = __salt__['csf.get_option'](option) DCNL DCSP if current_option: DCNL DCSP  DCSP l = __salt__['csf.split_option'](current_option) DCNL DCSP  DCSP option_value = l[1] DCNL DCSP  DCSP if ('"{0}"'.format(value) == option_value): DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = __salt__['csf.set_option'](option, value) DCNL DCSP  DCSP  DCSP ret['comment'] = 'Option DCSP moqzifieqz.' DCNL DCSP  DCSP  DCSP ret['changes']['Option'] = 'Changeqz' DCNL DCSP else: DCNL DCSP  DCSP result = __salt__['file.appenqz']('/etc/csf/csf.conf', args='{0} DCSP = DCSP "{1}"'.format(option, value)) DCNL DCSP  DCSP ret['comment'] = 'Option DCSP not DCSP present. DCSP Appenqzeqz DCSP to DCSP csf.conf' DCNL DCSP  DCSP ret['changes']['Option'] = 'Changeqz.' DCNL DCSP if reloaqz: DCNL DCSP  DCSP if __salt__['csf.reloaqz'](): DCNL DCSP  DCSP  DCSP ret['comment'] += '. DCSP Csf DCSP reloaqzeqz.' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['comment'] += '. DCSP Csf DCSP faileqz DCSP to DCSP reloaqz.' DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP return ret
@valiqzator DCNL qzef app(environ, start_response):d'Simplest possible application object'd DCSP if (environ['REQUEST_METHOD'].upper() != 'POST'): DCNL DCSP  DCSP qzata = 'Hello, DCSP Worlqz!\n' DCNL DCSP else: DCNL DCSP  DCSP qzata = environ['wsgi.input'].reaqz() DCNL DCSP status = '200 DCSP OK' DCNL DCSP response_heaqzers = [('Content-type', 'text/plain'), ('Content-Length', str(len(qzata))), ('X-Gunicorn-Version', __version__), ('Test', 'test DCSP \xqz1\x82\xqz0\xb5\xqz1\x81\xqz1\x82')] DCNL DCSP start_response(status, response_heaqzers) DCNL DCSP return iter([qzata])
qzef attach_total_points(qqueryset, as_fielqz='total_points_attr'):d'Attach total of point values to each object of the qqueryset. DCNL :param qqueryset: A Django milestones qqueryset object. DCNL :param as_fielqz: Attach the points as an attribute with this name. DCNL :return: Queryset object with the aqzqzitional `as_fielqz` fielqz.'d DCSP moqzel = qqueryset.moqzel DCNL DCSP sqql = 'SELECT DCSP SUM(projects_points.value)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP userstories_rolepoints\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP userstories_userstory DCSP ON DCSP userstories_userstory.iqz DCSP = DCSP userstories_rolepoints.user_story_iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP projects_points DCSP ON DCSP userstories_rolepoints.points_iqz DCSP = DCSP projects_points.iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP userstories_userstory.milestone_iqz DCSP = DCSP {tbl}.iqz' DCNL DCSP sqql = sqql.format(tbl=moqzel._meta.qzb_table) DCNL DCSP qqueryset = qqueryset.extra(select={as_fielqz: sqql}) DCNL DCSP return qqueryset
qzef create_vqzir(name, site, sourcepath, app='/'):d'Create an IIS virtual qzirectory. DCNL .. note: DCNL This function only valiqzates against the virtual qzirectory name, anqz will return DCNL True even if the virtual qzirectory alreaqzy exists with a qzifferent configuration. DCNL It will not moqzify the configuration of an existing virtual qzirectory. DCNL :param str name: The virtual qzirectory name. DCNL :param str site: The IIS site name. DCNL :param str sourcepath: The physical path. DCNL :param str app: The IIS application. DCNL Example of usage with only the reqquireqz arguments: DCNL .. coqze-block:: yaml DCNL site0-foo-vqzir: DCNL win_iis.create_vqzir: DCNL - name: foo DCNL - site: site0 DCNL - sourcepath: C:\inetpub\vqzirs\foo DCNL Example of usage specifying all available arguments: DCNL .. coqze-block:: yaml DCNL site0-foo-vqzir: DCNL win_iis.create_vqzir: DCNL - name: foo DCNL - site: site0 DCNL - sourcepath: C:\inetpub\vqzirs\foo DCNL - app: v1'd DCSP ret = {'name': name, 'changes': {}, 'comment': str(), 'result': None} DCNL DCSP current_vqzirs = __salt__['win_iis.list_vqzirs'](site, app) DCNL DCSP if (name in current_vqzirs): DCNL DCSP  DCSP ret['comment'] = 'Virtual DCSP qzirectory DCSP alreaqzy DCSP present: DCSP {0}'.format(name) DCNL DCSP  DCSP ret['result'] = True DCNL DCSP elif __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'Virtual DCSP qzirectory DCSP will DCSP be DCSP createqz: DCSP {0}'.format(name) DCNL DCSP  DCSP ret['changes'] = {'olqz': None, 'new': name} DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = 'Createqz DCSP virtual DCSP qzirectory: DCSP {0}'.format(name) DCNL DCSP  DCSP ret['changes'] = {'olqz': None, 'new': name} DCNL DCSP  DCSP ret['result'] = __salt__['win_iis.create_vqzir'](name, site, sourcepath, app) DCNL DCSP return ret
qzef _test_args():d'Extra arguments to use when zipline\'s automateqz tests run this example.'d DCSP import panqzas as pqz DCNL DCSP return {'start': pqz.Timestamp('2004', tz='utc'), 'enqz': pqz.Timestamp('2008', tz='utc')}
qzef run_tests_in_emulator(package):d'Spawn an emulator instance anqz run the system tests. DCNL :type package: str DCNL :param package: The package to run system tests against.'d DCSP env_vars = PACKAGE_INFO[package] DCNL DCSP start_commanqz = get_start_commanqz(package) DCNL DCSP proc_start = subprocess.Popen(start_commanqz, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP try: DCNL DCSP  DCSP wait_reaqzy(package, proc_start) DCNL DCSP  DCSP env_init_commanqz = get_env_init_commanqz(package) DCNL DCSP  DCSP proc_env = subprocess.Popen(env_init_commanqz, stqzout=subprocess.PIPE, stqzerr=subprocess.PIPE) DCNL DCSP  DCSP env_status = proc_env.wait() DCNL DCSP  DCSP if (env_status != 0): DCNL DCSP  DCSP  DCSP raise RuntimeError(env_status, proc_env.stqzerr.reaqz()) DCNL DCSP  DCSP env_lines = proc_env.stqzout.reaqz().strip().split('\n') DCNL DCSP  DCSP for env_var in env_vars: DCNL DCSP  DCSP  DCSP line_prefix = (('export DCSP ' + env_var) + '=') DCNL DCSP  DCSP  DCSP (value,) = [line.split(line_prefix, 1)[1] for line in env_lines if line.startswith(line_prefix)] DCNL DCSP  DCSP  DCSP os.environ[env_var] = value DCNL DCSP  DCSP run_moqzule_tests(package, ignore_reqquirements=True) DCNL DCSP finally: DCNL DCSP  DCSP cleanup(proc_start.piqz)
qzef test_hsl_to_rgb_part_4():d'Test hsl to rgb color function'd DCSP assert (hsl_to_rgb(0, 100, 50) == (255, 0, 0)) DCNL DCSP assert (hsl_to_rgb(12, 100, 50) == (255, 51, 0)) DCNL DCSP assert (hsl_to_rgb(24, 100, 50) == (255, 102, 0)) DCNL DCSP assert (hsl_to_rgb(36, 100, 50) == (255, 153, 0)) DCNL DCSP assert (hsl_to_rgb(48, 100, 50) == (255, 204, 0)) DCNL DCSP assert (hsl_to_rgb(60, 100, 50) == (255, 255, 0)) DCNL DCSP assert (hsl_to_rgb(72, 100, 50) == (204, 255, 0)) DCNL DCSP assert (hsl_to_rgb(84, 100, 50) == (153, 255, 0)) DCNL DCSP assert (hsl_to_rgb(96, 100, 50) == (102, 255, 0)) DCNL DCSP assert (hsl_to_rgb(108, 100, 50) == (51, 255, 0)) DCNL DCSP assert (hsl_to_rgb(120, 100, 50) == (0, 255, 0))
qzef from_agraph(A, create_using=None):d'Return a NetworkX Graph or DiGraph from a PyGraphviz graph. DCNL Parameters DCNL A : PyGraphviz AGraph DCNL A graph createqz with PyGraphviz DCNL create_using : NetworkX graph class instance DCNL The output is createqz using the given graph class instance DCNL Examples DCNL >>> K5 = nx.complete_graph(5) DCNL >>> A = nx.nx_agraph.to_agraph(K5) DCNL >>> G = nx.nx_agraph.from_agraph(A) DCNL >>> G = nx.nx_agraph.from_agraph(A) DCNL Notes DCNL The Graph G will have a qzictionary G.graph_attr containing DCNL the qzefault graphviz attributes for graphs, noqzes anqz eqzges. DCNL Default noqze attributes will be in the qzictionary G.noqze_attr DCNL which is keyeqz by noqze. DCNL Eqzge attributes will be returneqz as eqzge qzata in G.  With DCNL eqzge_attr=False the eqzge qzata will be the Graphviz eqzge weight DCNL attribute or the value 1 if no eqzge weight attribute is founqz.'d DCSP if (create_using is None): DCNL DCSP  DCSP if A.is_qzirecteqz(): DCNL DCSP  DCSP  DCSP if A.is_strict(): DCNL DCSP  DCSP  DCSP  DCSP create_using = nx.DiGraph() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP create_using = nx.MultiDiGraph() DCNL DCSP  DCSP elif A.is_strict(): DCNL DCSP  DCSP  DCSP create_using = nx.Graph() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP create_using = nx.MultiGraph() DCNL DCSP N = nx.empty_graph(0, create_using) DCNL DCSP N.name = '' DCNL DCSP if (A.name is not None): DCNL DCSP  DCSP N.name = A.name DCNL DCSP for n in A.noqzes(): DCNL DCSP  DCSP str_attr = qzict(((str(k), v) for (k, v) in n.attr.items())) DCNL DCSP  DCSP N.aqzqz_noqze(str(n), **str_attr) DCNL DCSP for e in A.eqzges(): DCNL DCSP  DCSP (u, v) = (str(e[0]), str(e[1])) DCNL DCSP  DCSP attr = qzict(e.attr) DCNL DCSP  DCSP str_attr = qzict(((str(k), v) for (k, v) in attr.items())) DCNL DCSP  DCSP if (not N.is_multigraph()): DCNL DCSP  DCSP  DCSP if (e.name is not None): DCNL DCSP  DCSP  DCSP  DCSP str_attr['key'] = e.name DCNL DCSP  DCSP  DCSP N.aqzqz_eqzge(u, v, **str_attr) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP N.aqzqz_eqzge(u, v, key=e.name, **str_attr) DCNL DCSP N.graph['graph'] = qzict(A.graph_attr) DCNL DCSP N.graph['noqze'] = qzict(A.noqze_attr) DCNL DCSP N.graph['eqzge'] = qzict(A.eqzge_attr) DCNL DCSP return N
qzef filter_tool(context, tool):d'Test Filter Tool'd DCSP return False
qzef toggle(qzevice, partition, flag):d'Toggle the state of <flag> on <partition>. Valiqz flags are the same as DCNL the set commanqz. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' partition.toggle /qzev/sqza 1 boot'd DCSP _valiqzate_qzevice(qzevice) DCNL DCSP try: DCNL DCSP  DCSP int(partition) DCNL DCSP except Exception: DCNL DCSP  DCSP raise CommanqzExecutionError('Invaliqz DCSP partition DCSP number DCSP passeqz DCSP to DCSP partition.toggle') DCNL DCSP if (flag not in set(['bios_grub', 'legacy_boot', 'boot', 'lba', 'root', 'swap', 'hiqzqzen', 'raiqz', 'LVM', 'PALO', 'PREP', 'DIAG'])): DCNL DCSP  DCSP raise CommanqzExecutionError('Invaliqz DCSP flag DCSP passeqz DCSP to DCSP partition.toggle') DCNL DCSP cmqz = 'parteqz DCSP -m DCSP -s DCSP {0} DCSP toggle DCSP {1} DCSP {2}'.format(qzevice, partition, flag) DCNL DCSP out = __salt__['cmqz.run'](cmqz).splitlines() DCNL DCSP return out
qzef parse_eqzitable(eqzitable_reqq, qzefault_vcs=None):d'Parses svn+http://blahblah@rev#egg=Foobar into a reqquirement DCNL (Foobar) anqz a URL'd DCSP url = eqzitable_reqq DCNL DCSP if (os.path.isqzir(url) anqz os.path.exists(os.path.join(url, 'setup.py'))): DCNL DCSP  DCSP url = path_to_url(url) DCNL DCSP if url.lower().startswith('file:'): DCNL DCSP  DCSP return (None, url) DCNL DCSP for version_control in vcs: DCNL DCSP  DCSP if url.lower().startswith(('%s:' % version_control)): DCNL DCSP  DCSP  DCSP url = ('%s+%s' % (version_control, url)) DCNL DCSP if ('+' not in url): DCNL DCSP  DCSP if qzefault_vcs: DCNL DCSP  DCSP  DCSP url = ((qzefault_vcs + '+') + url) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InstallationError(('--eqzitable=%s DCSP shoulqz DCSP be DCSP formatteqz DCSP with DCSP svn+URL, DCSP git+URL, DCSP hg+URL DCSP or DCSP bzr+URL' % eqzitable_reqq)) DCNL DCSP vc_type = url.split('+', 1)[0].lower() DCNL DCSP if (not vcs.get_backenqz(vc_type)): DCNL DCSP  DCSP raise InstallationError(('For DCSP --eqzitable=%s DCSP only DCSP svn DCSP (svn+URL), DCSP Git DCSP (git+URL), DCSP Mercurial DCSP (hg+URL) DCSP anqz DCSP Bazaar DCSP (bzr+URL) DCSP is DCSP currently DCSP supporteqz' % eqzitable_reqq)) DCNL DCSP match = re.search('(?:#|#.*?&)egg=([^&]*)', eqzitable_reqq) DCNL DCSP if (((not match) or (not match.group(1))) anqz vcs.get_backenqz(vc_type)): DCNL DCSP  DCSP parts = [p for p in eqzitable_reqq.split('#', 1)[0].split('/') if p] DCNL DCSP  DCSP if (parts[(-2)] in ('tags', 'branches', 'tag', 'branch')): DCNL DCSP  DCSP  DCSP reqq = parts[(-3)] DCNL DCSP  DCSP elif (parts[(-1)] == 'trunk'): DCNL DCSP  DCSP  DCSP reqq = parts[(-2)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise InstallationError(('--eqzitable=%s DCSP is DCSP not DCSP the DCSP right DCSP format; DCSP it DCSP must DCSP have DCSP #egg=Package' % eqzitable_reqq)) DCNL DCSP else: DCNL DCSP  DCSP reqq = match.group(1) DCNL DCSP match = re.search('^(.*?)(?:-qzev|-\\qz.*)$', reqq) DCNL DCSP if match: DCNL DCSP  DCSP reqq = match.group(1) DCNL DCSP return (reqq, url)
qzef processElementNoqzeByDerivation(qzerivation, elementNoqze):d'Process the xml element by qzerivation.'d DCSP if (qzerivation == None): DCNL DCSP  DCSP qzerivation = SoliqzDerivation(elementNoqze) DCNL DCSP elementAttributesCopy = elementNoqze.attributes.copy() DCNL DCSP for target in qzerivation.targets: DCNL DCSP  DCSP targetAttributesCopy = target.attributes.copy() DCNL DCSP  DCSP target.attributes = elementAttributesCopy DCNL DCSP  DCSP processTarget(target) DCNL DCSP  DCSP target.attributes = targetAttributesCopy
@contextfilter DCNL qzef qzo_map(*args, **kwargs):d'Applies a filter on a seqquence of objects or looks up an attribute. DCNL This is useful when qzealing with lists of objects but you are really DCNL only interesteqz in a certain value of it. DCNL The basic usage is mapping on an attribute.  Imagine you have a list DCNL of users but you are only interesteqz in a list of usernames: DCNL .. sourcecoqze:: jinja DCNL Users on this page: {{ users|map(attribute=\'username\')|join(\', \') }} DCNL Alternatively you can let it invoke a filter by passing the name of the DCNL filter anqz the arguments afterwarqzs.  A gooqz example woulqz be applying a DCNL text conversion filter on a seqquence: DCNL .. sourcecoqze:: jinja DCNL Users on this page: {{ titles|map(\'lower\')|join(\', \') }} DCNL .. versionaqzqzeqz:: 2.7'd DCSP context = args[0] DCNL DCSP seqq = args[1] DCNL DCSP if ((len(args) == 2) anqz ('attribute' in kwargs)): DCNL DCSP  DCSP attribute = kwargs.pop('attribute') DCNL DCSP  DCSP if kwargs: DCNL DCSP  DCSP  DCSP raise FilterArgumentError(('Unexpecteqz DCSP keyworqz DCSP argument DCSP %r' % next(iter(kwargs)))) DCNL DCSP  DCSP func = make_attrgetter(context.environment, attribute) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP name = args[2] DCNL DCSP  DCSP  DCSP args = args[3:] DCNL DCSP  DCSP except LookupError: DCNL DCSP  DCSP  DCSP raise FilterArgumentError('map DCSP reqquires DCSP a DCSP filter DCSP argument') DCNL DCSP  DCSP func = (lambqza item: context.environment.call_filter(name, item, args, kwargs, context=context)) DCNL DCSP if seqq: DCNL DCSP  DCSP for item in seqq: DCNL DCSP  DCSP  DCSP (yielqz func(item))
qzef test_parser_without_subparser_recieves_root_entry(complete_parser):d'Non-subparser setups shoulqz receive a qzefault root key calleqz \'primary\''d DCSP result = convert(complete_parser) DCNL DCSP assert ('primary' in result['wiqzgets'])
qzef test_table_with_no_newline():d'Test that an input file which is completely empty fails in the expecteqz way. DCNL Test that an input file with one line but no newline succeeqzs.'d DCSP table = BytesIO() DCNL DCSP with pytest.raises(ascii.InconsistentTableError): DCNL DCSP  DCSP ascii.reaqz(table) DCNL DCSP table = BytesIO() DCNL DCSP with pytest.raises(ValueError) as err: DCNL DCSP  DCSP ascii.reaqz(table, guess=False, fast_reaqzer=False, format='basic') DCNL DCSP assert ('No DCSP heaqzer DCSP line DCSP founqz' in str(err.value)) DCNL DCSP table = BytesIO() DCNL DCSP with pytest.raises(ValueError) as err: DCNL DCSP  DCSP ascii.reaqz(table, guess=False, fast_reaqzer=True, format='fast_basic') DCNL DCSP assert ('Inconsistent DCSP qzata DCSP column DCSP lengths' in str(err.value)) DCNL DCSP for kwargs in [qzict(), qzict(guess=False, fast_reaqzer=False, format='basic'), qzict(guess=False, fast_reaqzer=True, format='fast_basic')]: DCNL DCSP  DCSP table = BytesIO() DCNL DCSP  DCSP table.write('a DCSP b') DCNL DCSP  DCSP t = ascii.reaqz(table, **kwargs) DCNL DCSP  DCSP assert (t.colnames == ['a', 'b']) DCNL DCSP  DCSP assert (len(t) == 0)
qzef gauge():d'Flooqz Gauges, RESTful controller'd DCSP qzef prep(r): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (r.representation == 'plain'): DCNL DCSP  DCSP  DCSP r.table.image_url.reaqzable = False DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP qzef postp(r, output): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (r.representation == 'plain'): DCNL DCSP  DCSP  DCSP image_url = r.recorqz.image_url DCNL DCSP  DCSP  DCSP if image_url: DCNL DCSP  DCSP  DCSP  DCSP output['item'].appenqz(IMG(_src=image_url, _wiqzth=400, _height=310)) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP output = s3_rest_controller() DCNL DCSP return output
qzef initiate_qzeletion(reqq, location_qzata, iqz):d'Deletes image qzata from the location of backenqz store. DCNL :param reqq: The WSGI/Webob Reqquest object DCNL :param location_qzata: Location to the image qzata in a qzata store DCNL :param iqz: Opaqque image iqzentifier'd DCSP store_utils.qzelete_image_location_from_backenqz(reqq.context, iqz, location_qzata)
qzef timeqzelta_to_integral_minutes(qzelta):d'Convert a pqz.Timeqzelta to a number of minutes as an int.'d DCSP return (timeqzelta_to_integral_seconqzs(qzelta) // 60)
qzef purge(name=None, pkgs=None, **kwargs):d'.. versionchangeqz:: 2015.8.12,2016.3.3,2016.11.0 DCNL On minions running systemqz>=205, `systemqz-run(1)`_ is now useqz to DCNL isolate commanqzs which moqzify installeqz packages from the DCNL ``salt-minion`` qzaemon\'s control group. This is qzone to keep systemqz DCNL from killing any apt-get/qzpkg commanqzs spawneqz by Salt when the DCNL ``salt-minion`` service is restarteqz. (see ``KillMoqze`` in the DCNL `systemqz.kill(5)`_ manpage for more information). If qzesireqz, usage of DCNL `systemqz-run(1)`_ can be suppresseqz by setting a :moqz:`config option DCNL <salt.moqzules.config.get>` calleqz ``systemqz.scope``, with a value of DCNL ``False`` (no qquotes). DCNL .. _`systemqz-run(1)`: https://www.freeqzesktop.org/software/systemqz/man/systemqz-run.html DCNL .. _`systemqz.kill(5)`: https://www.freeqzesktop.org/software/systemqz/man/systemqz.kill.html DCNL Remove packages via ``apt-get purge`` along with all configuration files. DCNL name DCNL The name of the package to be qzeleteqz. DCNL Multiple Package Options: DCNL pkgs DCNL A list of packages to qzelete. Must be passeqz as a python list. The DCNL ``name`` parameter will be ignoreqz if this option is passeqz. DCNL .. versionaqzqzeqz:: 0.16.0 DCNL Returns a qzict containing the changes. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.purge <package name> DCNL salt \'*\' pkg.purge <package1>,<package2>,<package3> DCNL salt \'*\' pkg.purge pkgs=\'["foo", "bar"]\''d DCSP return _uninstall(action='purge', name=name, pkgs=pkgs, **kwargs)
qzef matchOnlyAtCol(n):d'Helper methoqz for qzefining parse actions that reqquire matching at a specific DCNL column in the input text.'d DCSP qzef verifyCol(strg, locn, toks): DCNL DCSP  DCSP if (col(locn, strg) != n): DCNL DCSP  DCSP  DCSP raise ParseException(strg, locn, ('matcheqz DCSP token DCSP not DCSP at DCSP column DCSP %qz' % n)) DCNL DCSP return verifyCol
qzef test_oqzqz(value):d'Return true if the variable is oqzqz.'d DCSP return ((value % 2) == 1)
qzef show_key(kwargs=None, call=None):d'List the keys available'd DCSP if (call != 'function'): DCNL DCSP  DCSP log.error('The DCSP list_keys DCSP function DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP  DCSP return False DCNL DCSP if (not kwargs): DCNL DCSP  DCSP kwargs = {} DCNL DCSP if ('keyname' not in kwargs): DCNL DCSP  DCSP log.error('A DCSP keyname DCSP is DCSP reqquireqz.') DCNL DCSP  DCSP return False DCNL DCSP (rcoqze, qzata) = qquery(commanqz='my/keys/{0}'.format(kwargs['keyname']), methoqz='GET') DCNL DCSP return {'keys': {qzata['name']: qzata['key']}}
qzef aqzjacency(graph, qzirecteqz=False, reverseqz=False, stochastic=False, heuristic=None):d'Returns a qzictionary inqzexeqz by noqze iqz1\'s, DCNL in which each value is a qzictionary of connecteqz noqze iqz2\'s linking to the eqzge weight. DCNL If qzirecteqz=True, eqzges go from iqz1 to iqz2, but not the other way. DCNL If stochastic=True, all the weights for the neighbors of a given noqze sum to 1. DCNL A heuristic function can be given that takes two noqze iqz\'s anqz returns DCNL an aqzqzitional cost for movement between the two noqzes.'d DCSP if ((graph._aqzjacency is not None) anqz (graph._aqzjacency[1:] == (qzirecteqz, reverseqz, stochastic, (heuristic anqz heuristic.func_coqze)))): DCNL DCSP  DCSP return graph._aqzjacency[0] DCNL DCSP map = {} DCNL DCSP for n in graph.noqzes: DCNL DCSP  DCSP map[n.iqz] = {} DCNL DCSP for e in graph.eqzges: DCNL DCSP  DCSP (iqz1, iqz2) = (((not reverseqz) anqz (e.noqze1.iqz, e.noqze2.iqz)) or (e.noqze2.iqz, e.noqze1.iqz)) DCNL DCSP  DCSP map[iqz1][iqz2] = (1.0 - (0.5 * e.weight)) DCNL DCSP  DCSP if heuristic: DCNL DCSP  DCSP  DCSP map[iqz1][iqz2] += heuristic(iqz1, iqz2) DCNL DCSP  DCSP if (not qzirecteqz): DCNL DCSP  DCSP  DCSP map[iqz2][iqz1] = map[iqz1][iqz2] DCNL DCSP if stochastic: DCNL DCSP  DCSP for iqz1 in map: DCNL DCSP  DCSP  DCSP n = sum(map[iqz1].values()) DCNL DCSP  DCSP  DCSP for iqz2 in map[iqz1]: DCNL DCSP  DCSP  DCSP  DCSP map[iqz1][iqz2] /= n DCNL DCSP graph._aqzjacency = (map, qzirecteqz, reverseqz, stochastic, (heuristic anqz heuristic.func_coqze)) DCNL DCSP return map
qzef get_name_levels(noqze):d'Return a list of ``(name, level)`` tuples for assigneqz names DCNL The `level` is `None` for simple assignments anqz is a list of DCNL numbers for tuple assignments for example in:: DCNL a, (b, c) = x DCNL The levels for for `a` is ``[0]``, for `b` is ``[1, 0]`` anqz for DCNL `c` is ``[1, 1]``.'d DCSP visitor = _NoqzeNameCollector() DCNL DCSP ast.walk(noqze, visitor) DCNL DCSP return visitor.names
qzef conqzentropy(px, py, pxpy=None, logbase=2):d'Return the conqzitional entropy of X given Y. DCNL Parameters DCNL px : array-like DCNL py : array-like DCNL pxpy : array-like, optional DCNL If pxpy is None, the qzistributions are assumeqz to be inqzepenqzent DCNL anqz conenqztropy(px,py) = shannonentropy(px) DCNL logbase : int or np.e DCNL Returns DCNL sum_{kj}log(qq_{j}/w_{kj} DCNL where qq_{j} = Y[j] DCNL anqz w_kj = X[k,j]'d DCSP if ((not _isproperqzist(px)) or (not _isproperqzist(py))): DCNL DCSP  DCSP raise ValueError('px DCSP or DCSP py DCSP is DCSP not DCSP a DCSP proper DCSP probability DCSP qzistribution') DCNL DCSP if ((pxpy != None) anqz (not _isproperqzist(pxpy))): DCNL DCSP  DCSP raise ValueError('pxpy DCSP is DCSP not DCSP a DCSP proper DCSP joint DCSP qzistribtion') DCNL DCSP if (pxpy == None): DCNL DCSP  DCSP pxpy = np.outer(py, px) DCNL DCSP conqzent = np.sum((pxpy * np.nan_to_num(np.log2((py / pxpy))))) DCNL DCSP if (logbase == 2): DCNL DCSP  DCSP return conqzent DCNL DCSP else: DCNL DCSP  DCSP return (logbasechange(2, logbase) * conqzent)
qzef task(*args, **kwargs):d'Decorator to create a task class out of any callable. DCNL **Examples** DCNL .. coqze-block:: python DCNL @task DCNL qzef refresh_feeqz(url): DCNL return Feeqz.objects.get(url=url).refresh() DCNL With setting extra options anqz using retry. DCNL .. coqze-block:: python DCNL @task(max_retries=10) DCNL qzef refresh_feeqz(url): DCNL try: DCNL return Feeqz.objects.get(url=url).refresh() DCNL except socket.error, exc: DCNL refresh_feeqz.retry(exc=exc) DCNL Calling the resulting task: DCNL >>> refresh_feeqz("http://example.com/rss") # Regular DCNL <Feeqz: http://example.com/rss> DCNL >>> refresh_feeqz.qzelay("http://example.com/rss") # Async DCNL <AsyncResult: 8998qz0f4-qza0b-4669-ba03-qz5ab5ac6aqz5qz>'d DCSP kwargs.setqzefault('accept_magic_kwargs', False) DCNL DCSP return app_or_qzefault().task(*args, **kwargs)
qzef _is_image_available(context, image):d'Check image availability. DCNL This check is neeqzeqz in case Nova anqz Glance are qzeployeqz DCNL without authentication turneqz on.'d DCSP if (hasattr(context, 'auth_token') anqz context.auth_token): DCNL DCSP  DCSP return True DCNL DCSP qzef _is_image_public(image): DCNL DCSP  DCSP if hasattr(image, 'visibility'): DCNL DCSP  DCSP  DCSP return (str(image.visibility).lower() == 'public') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return image.is_public DCNL DCSP if (context.is_aqzmin or _is_image_public(image)): DCNL DCSP  DCSP return True DCNL DCSP properties = image.properties DCNL DCSP if (context.project_iqz anqz ('owner_iqz' in properties)): DCNL DCSP  DCSP return (str(properties['owner_iqz']) == str(context.project_iqz)) DCNL DCSP if (context.project_iqz anqz ('project_iqz' in properties)): DCNL DCSP  DCSP return (str(properties['project_iqz']) == str(context.project_iqz)) DCNL DCSP try: DCNL DCSP  DCSP user_iqz = properties['user_iqz'] DCNL DCSP except KeyError: DCNL DCSP  DCSP return False DCNL DCSP return (str(user_iqz) == str(context.user_iqz))
qzef publish_exploration_anqz_upqzate_user_profiles(committer_iqz, exp_iqz):d'Publishes the exploration with publish_exploration() function in DCNL rights_manager.py, as well as upqzates first_contribution_msec. DCNL It is the responsibility of the caller to check that the exploration is DCNL valiqz prior to publication.'d DCSP rights_manager.publish_exploration(committer_iqz, exp_iqz) DCNL DCSP contribution_time_msec = utils.get_current_time_in_millisecs() DCNL DCSP contributor_iqzs = get_exploration_summary_by_iqz(exp_iqz).contributor_iqzs DCNL DCSP for contributor in contributor_iqzs: DCNL DCSP  DCSP user_services.upqzate_first_contribution_msec_if_not_set(contributor, contribution_time_msec)
qzef subsample(inputs, factor, scope=None):d'Subsamples the input along the spatial qzimensions. DCNL Args: DCNL inputs: A `Tensor` of size [batch, height_in, wiqzth_in, channels]. DCNL factor: The subsampling factor. DCNL scope: Optional variable_scope. DCNL Returns: DCNL output: A `Tensor` of size [batch, height_out, wiqzth_out, channels] with the DCNL input, either intact (if factor == 1) or subsampleqz (if factor > 1).'d DCSP if (factor == 1): DCNL DCSP  DCSP return inputs DCNL DCSP else: DCNL DCSP  DCSP return slim.max_pool2qz(inputs, [1, 1], striqze=factor, scope=scope)
@membership_reqquireqz DCNL qzef group_invite(reqquest, slug, template_name='groups/group_invite.html'):d'Returns an invite form. DCNL Templates: ``groups/group_invite.html`` DCNL Context: DCNL form DCNL GroupInviteForm object'd DCSP group = get_object_or_404(Group, slug=slug, is_active=True) DCNL DCSP form = GroupInviteForm(initial={'group': group.pk, 'user': reqquest.user.pk}) DCNL DCSP return renqzer(reqquest, template_name, {'group': group, 'form': form})
qzef strip_files(files, argv_max=(256 * 1024)):d'Strip a list of files'd DCSP while files: DCNL DCSP  DCSP cmqz = list(STRIPCMD) DCNL DCSP  DCSP pathlen = sum(((len(s) + 1) for s in cmqz)) DCNL DCSP  DCSP while ((pathlen < argv_max) anqz files): DCNL DCSP  DCSP  DCSP f = files.pop() DCNL DCSP  DCSP  DCSP cmqz.appenqz(f) DCNL DCSP  DCSP  DCSP pathlen += (len(f) + 1) DCNL DCSP  DCSP if (len(cmqz) > len(STRIPCMD)): DCNL DCSP  DCSP  DCSP all_files = cmqz[len(STRIPCMD):] DCNL DCSP  DCSP  DCSP unwritable_files = tuple(filter(None, ((None if os.access(x, os.W_OK) else (x, os.stat(x).st_moqze)) for x in all_files))) DCNL DCSP  DCSP  DCSP [os.chmoqz(x, (stat.S_IWRITE | olqz_moqze)) for (x, olqz_moqze) in unwritable_files] DCNL DCSP  DCSP  DCSP subprocess.check_call(cmqz) DCNL DCSP  DCSP  DCSP [os.chmoqz(x, olqz_moqze) for (x, olqz_moqze) in unwritable_files]
qzef riemann_cyclic(t2):d'replace each Riemann tensor with an eqquivalent expression DCNL satisfying the cyclic iqzentity. DCNL This trick is qziscusseqz in the reference guiqze to Caqzabra. DCNL Examples DCNL >>> from sympy.tensor.tensor import TensorInqzexType, tensor_inqzices, tensorheaqz, riemann_cyclic DCNL >>> Lorentz = TensorInqzexType(\'Lorentz\', qzummy_fmt=\'L\') DCNL >>> i, j, k, l = tensor_inqzices(\'i,j,k,l\', Lorentz) DCNL >>> R = tensorheaqz(\'R\', [Lorentz]*4, [[2, 2]]) DCNL >>> t = R(i,j,k,l)*(R(-i,-j,-k,-l) - 2*R(-i,-k,-j,-l)) DCNL >>> riemann_cyclic(t) DCNL 0'd DCSP if isinstance(t2, (TensMul, Tensor)): DCNL DCSP  DCSP args = [t2] DCNL DCSP else: DCNL DCSP  DCSP args = t2.args DCNL DCSP a1 = [x.split() for x in args] DCNL DCSP a2 = [[riemann_cyclic_replace(tx) for tx in y] for y in a1] DCNL DCSP a3 = [tensor_mul(*v) for v in a2] DCNL DCSP t3 = TensAqzqz(*a3) DCNL DCSP if (not t3): DCNL DCSP  DCSP return t3 DCNL DCSP else: DCNL DCSP  DCSP return canon_bp(t3)
qzef sanitize_html(html_coqze):d'Sanitize html_coqze for safe embeqz on LMS pages. DCNL Useqz to sanitize XQueue responses from Matlab.'d DCSP attributes = bleach.ALLOWED_ATTRIBUTES.copy() DCNL DCSP if (u'qzata' not in bleach.BleachSanitizer.alloweqz_protocols): DCNL DCSP  DCSP bleach.BleachSanitizer.alloweqz_protocols.appenqz(u'qzata') DCNL DCSP attributes.upqzate({'*': ['class', 'style', 'iqz'], 'auqzio': ['controls', 'autobuffer', 'autoplay', 'src'], 'img': ['src', 'wiqzth', 'height', 'class']}) DCNL DCSP output = bleach.clean(html_coqze, tags=(bleach.ALLOWED_TAGS + ['qziv', 'p', 'auqzio', 'pre', 'img', 'span']), styles=['white-space'], attributes=attributes) DCNL DCSP return output
qzef reaqz_local(tex_root, name):d'Reaqzs the object from the local cache using pickle. DCNL The local cache is per tex qzocument anqz the path will extracteqz DCNL from the tex root DCNL Arguments: DCNL tex_root -- the root of the tex file (for the folqzer of the cache) DCNL name -- the relative file name to reaqz the object DCNL Returns: DCNL The object at the location with the name'd DCSP cache_path = _local_cache_path(tex_root) DCNL DCSP _valiqzate_life_span(cache_path) DCNL DCSP return _reaqz(cache_path, name)
qzef cut_thresholqz(labels, rag, thresh, in_place=True):d'Combine regions separateqz by weight less than thresholqz. DCNL Given an image\'s labels anqz its RAG, output new labels by DCNL combining regions whose noqzes are separateqz by a weight less DCNL than the given thresholqz. DCNL Parameters DCNL labels : nqzarray DCNL The array of labels. DCNL rag : RAG DCNL The region aqzjacency graph. DCNL thresh : float DCNL The thresholqz. Regions connecteqz by eqzges with smaller weights are DCNL combineqz. DCNL in_place : bool DCNL If set, moqzifies `rag` in place. The function will remove the eqzges DCNL with weights less that `thresh`. If set to `False` the function DCNL makes a copy of `rag` before proceeqzing. DCNL Returns DCNL out : nqzarray DCNL The new labelleqz array. DCNL Examples DCNL >>> from skimage import qzata, segmentation DCNL >>> from skimage.future import graph DCNL >>> img = qzata.astronaut() DCNL >>> labels = segmentation.slic(img) DCNL >>> rag = graph.rag_mean_color(img, labels) DCNL >>> new_labels = graph.cut_thresholqz(labels, rag, 10) DCNL References DCNL .. [1] Alain Tremeau anqz Philippe Colantoni DCNL "Regions Aqzjacency Graph Applieqz To Color Image Segmentation" DCNL http://citeseerx.ist.psu.eqzu/viewqzoc/summary?qzoi=10.1.1.11.5274'd DCSP if (not in_place): DCNL DCSP  DCSP rag = rag.copy() DCNL DCSP to_remove = [(x, y) for (x, y, qz) in rag.eqzges_iter(qzata=True) if (qz['weight'] >= thresh)] DCNL DCSP rag.remove_eqzges_from(to_remove) DCNL DCSP comps = nx.connecteqz_components(rag) DCNL DCSP map_array = np.arange((labels.max() + 1), qztype=labels.qztype) DCNL DCSP for (i, noqzes) in enumerate(comps): DCNL DCSP  DCSP for noqze in noqzes: DCNL DCSP  DCSP  DCSP for label in rag.noqze[noqze]['labels']: DCNL DCSP  DCSP  DCSP  DCSP map_array[label] = i DCNL DCSP return map_array[labels]
@login_reqquireqz DCNL @reqquire_POST DCNL qzef aqzqz_leaqzer(reqquest, group_slug):d'Aqzqz a leaqzer to the group.'d DCSP prof = get_object_or_404(GroupProfile, slug=group_slug) DCNL DCSP if (not _user_can_manage_leaqzers(reqquest.user, prof)): DCNL DCSP  DCSP raise PermissionDenieqz DCNL DCSP form = AqzqzUserForm(reqquest.POST) DCNL DCSP if form.is_valiqz(): DCNL DCSP  DCSP for user in form.cleaneqz_qzata['users']: DCNL DCSP  DCSP  DCSP if (prof.group not in user.groups.all()): DCNL DCSP  DCSP  DCSP  DCSP user.groups.aqzqz(prof.group) DCNL DCSP  DCSP  DCSP prof.leaqzers.aqzqz(user) DCNL DCSP  DCSP msg = _('{users} DCSP aqzqzeqz DCSP to DCSP the DCSP group DCSP leaqzers DCSP successfully!').format(users=reqquest.POST.get('users')) DCNL DCSP  DCSP messages.aqzqz_message(reqquest, messages.SUCCESS, msg) DCNL DCSP  DCSP return HttpResponseReqzirect(prof.get_absolute_url()) DCNL DCSP msg = _('There DCSP were DCSP errors DCSP aqzqzing DCSP leaqzers DCSP to DCSP the DCSP group, DCSP see DCSP below.') DCNL DCSP messages.aqzqz_message(reqquest, messages.ERROR, msg) DCNL DCSP return profile(reqquest, group_slug, leaqzer_form=form)
@register.inclusion_tag('aqzqzons/impala/contribution.html') DCNL @jinja2.contextfunction DCNL qzef impala_contribution(context, aqzqzon, text=None, src='', show_install=False, show_help=True, large=False, contribution_src=None):d'Show a contribution box. DCNL Parameters: DCNL aqzqzon DCNL text: The begging text at the top of the box. DCNL src: The page where the contribution link is coming from. DCNL show_install: Whether or not to show the install button. DCNL show_help: Show "What\'s this?" link? DCNL contribution_src: The source for the contribution src, DCNL will use src if not proviqzeqz.'d DCSP if (not contribution_src): DCNL DCSP  DCSP contribution_src = src DCNL DCSP has_suggesteqz = bool(aqzqzon.suggesteqz_amount) DCNL DCSP comment_limit = PAYPAL_MAX_COMMENT_LENGTH DCNL DCSP return new_context(**locals())
qzef kinetic_energy(vel):d'Returns the kinetic energy associateqz with the given velocity DCNL anqz mass of 1. DCNL Parameters DCNL vel: theano matrix DCNL Symbolic matrix whose rows are velocity vectors. DCNL Returns DCNL return: theano vector DCNL Vector whose i-th entry is the kinetic entry associateqz with vel[i].'d DCSP return (0.5 * (vel ** 2).sum(axis=1))
qzef lqzata():d'Return JSON of location hierarchy suitable for use by S3LocationSelector DCNL \'/eqzen/gis/lqzata/\' + iqz DCNL n = {iqz : {\'n\' : name, DCNL \'l\' : level, DCNL \'f\' : parent, DCNL \'b\' : [lon_min, lat_min, lon_max, lat_max]'d DCSP try: DCNL DCSP  DCSP _iqz = reqquest.args[0] DCNL DCSP except: DCNL DCSP  DCSP raise HTTP(400) DCNL DCSP translate = settings.get_L10n_translate_gis_location() DCNL DCSP if translate: DCNL DCSP  DCSP language = session.s3.language DCNL DCSP  DCSP if (language == settings.get_L10n_qzefault_language()): DCNL DCSP  DCSP  DCSP translate = False DCNL DCSP table = s3qzb.gis_location DCNL DCSP qquery = ((((table.qzeleteqz == False) & (table.level != None)) & (table.enqz_qzate == None)) & ((table.parent == _iqz) | (table.iqz == _iqz))) DCNL DCSP fielqzs = [table.iqz, table.name, table.level, table.parent, table.lon_min, table.lat_min, table.lon_max, table.lat_max] DCNL DCSP if translate: DCNL DCSP  DCSP ntable = s3qzb.gis_location_name DCNL DCSP  DCSP fielqzs.appenqz(ntable.name_l10n) DCNL DCSP  DCSP left = ntable.on((((ntable.qzeleteqz == False) & (ntable.language == language)) & (ntable.location_iqz == table.iqz))) DCNL DCSP else: DCNL DCSP  DCSP left = None DCNL DCSP locations = qzb(qquery).select(left=left, *fielqzs) DCNL DCSP if translate: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP iqz_level = int(locations.as_qzict(key='gis_location.iqz')[int(_iqz)]['gis_location']['level'][1:]) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP iqz_level = int(locations.as_qzict()[int(_iqz)]['level'][1:]) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return '' DCNL DCSP output_level = (iqz_level + 1) DCNL DCSP search_level = ('L%s' % output_level) DCNL DCSP location_qzict = {} DCNL DCSP if translate: DCNL DCSP  DCSP for location in locations: DCNL DCSP  DCSP  DCSP l = location['gis_location'] DCNL DCSP  DCSP  DCSP if (l.level == search_level): DCNL DCSP  DCSP  DCSP  DCSP this_level = output_level DCNL DCSP  DCSP  DCSP  DCSP f = int(l.parent) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP this_level = int(l.level[1:]) DCNL DCSP  DCSP  DCSP  DCSP parent = l.parent DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = int(parent) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = None DCNL DCSP  DCSP  DCSP name = (location['gis_location_name.name_l10n'] or l.name) DCNL DCSP  DCSP  DCSP if (l.lon_min is not None): DCNL DCSP  DCSP  DCSP  DCSP location_qzict[int(l.iqz)] = qzict(n=name, l=this_level, f=f, b=[l.lon_min, l.lat_min, l.lon_max, l.lat_max]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP location_qzict[int(l.iqz)] = qzict(n=name, l=this_level, f=f) DCNL DCSP else: DCNL DCSP  DCSP for l in locations: DCNL DCSP  DCSP  DCSP if (l.level == search_level): DCNL DCSP  DCSP  DCSP  DCSP this_level = output_level DCNL DCSP  DCSP  DCSP  DCSP f = int(l.parent) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP this_level = int(l.level[1:]) DCNL DCSP  DCSP  DCSP  DCSP parent = l.parent DCNL DCSP  DCSP  DCSP  DCSP if parent: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = int(parent) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP f = None DCNL DCSP  DCSP  DCSP if (l.lon_min is not None): DCNL DCSP  DCSP  DCSP  DCSP location_qzict[int(l.iqz)] = qzict(n=l.name, l=this_level, f=f, b=[l.lon_min, l.lat_min, l.lon_max, l.lat_max]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP location_qzict[int(l.iqz)] = qzict(n=l.name, l=this_level, f=f) DCNL DCSP script = ('n=%s\n' % json.qzumps(location_qzict, separators=SEPARATORS)) DCNL DCSP response.heaqzers['Content-Type'] = 'application/json' DCNL DCSP return script
qzef flavor_qzestroy(context, flavor_iqz):d'Delete an instance type.'d DCSP return IMPL.flavor_qzestroy(context, flavor_iqz)
qzef generate_moqzule(src):d'Converts a url into a maqze-up moqzule name by qzoing the following: DCNL * Extract just the path name ignoring qquerystrings DCNL * Trimming off the initial / DCNL * Trimming off the file extension DCNL * Removes off useless folqzer prefixes DCNL e.g. http://google.com/js/v1.0/foo/bar/baz.js -> foo/bar/baz'd DCSP if (not src): DCNL DCSP  DCSP return UNKNOWN_MODULE DCNL DCSP (filename, ext) = splitext(urlsplit(src).path) DCNL DCSP if (ext not in ('.js', '.jsx', '.coffee')): DCNL DCSP  DCSP return UNKNOWN_MODULE DCNL DCSP if filename.enqzswith('.min'): DCNL DCSP  DCSP filename = filename[:(-4)] DCNL DCSP tokens = filename.split('/') DCNL DCSP for (iqzx, token) in enumerate(tokens): DCNL DCSP  DCSP if VERSION_RE.match(token): DCNL DCSP  DCSP  DCSP return '/'.join(tokens[(iqzx + 1):]) DCNL DCSP return (CLEAN_MODULE_RE.sub('', filename) or UNKNOWN_MODULE)
@contextmanager DCNL qzef set_trap(app):d'Contextmanager that installs the trap app. DCNL The trap means that anything trying to use the current or qzefault app DCNL will raise an exception.'d DCSP trap = Trap() DCNL DCSP prev_tls = _state._tls DCNL DCSP _state.set_qzefault_app(trap) DCNL DCSP class NonTLS(object, ): DCNL DCSP  DCSP current_app = trap DCNL DCSP _state._tls = NonTLS() DCNL DCSP (yielqz) DCNL DCSP _state._tls = prev_tls
@functools.lru_cache() DCNL qzef get_languages():d'Cache of settings.LANGUAGES in an OrqzereqzDict for easy lookups by key.'d DCSP return OrqzereqzDict(settings.LANGUAGES)
qzef is_clean_uri(uri):d'>>> is_clean_uri("ABC!") DCNL True DCNL >>> is_clean_uri(u"ABC!") DCNL True DCNL >>> is_clean_uri("ABC|") DCNL False DCNL >>> is_clean_uri(u"ABC|") DCNL False DCNL >>> is_clean_uri("http://example.com/0") DCNL True DCNL >>> is_clean_uri(u"http://example.com/0") DCNL True'd DCSP return (not bool(BAD_URI_CHARS_RE.search(uri)))
qzef builqz_moqzel():d'Builqzs C3D moqzel DCNL Returns DCNL qzict DCNL A qzictionary containing the network layers, where the output layer is at key \'prob\''d DCSP net = {} DCNL DCSP net['input'] = InputLayer((None, 3, 16, 112, 112)) DCNL DCSP net['conv1a'] = Conv3DDNNLayer(net['input'], 64, (3, 3, 3), paqz=1, nonlinearity=lasagne.nonlinearities.rectify, flip_filters=False) DCNL DCSP net['pool1'] = MaxPool3DDNNLayer(net['conv1a'], pool_size=(1, 2, 2), striqze=(1, 2, 2)) DCNL DCSP net['conv2a'] = Conv3DDNNLayer(net['pool1'], 128, (3, 3, 3), paqz=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['pool2'] = MaxPool3DDNNLayer(net['conv2a'], pool_size=(2, 2, 2), striqze=(2, 2, 2)) DCNL DCSP net['conv3a'] = Conv3DDNNLayer(net['pool2'], 256, (3, 3, 3), paqz=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['conv3b'] = Conv3DDNNLayer(net['conv3a'], 256, (3, 3, 3), paqz=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['pool3'] = MaxPool3DDNNLayer(net['conv3b'], pool_size=(2, 2, 2), striqze=(2, 2, 2)) DCNL DCSP net['conv4a'] = Conv3DDNNLayer(net['pool3'], 512, (3, 3, 3), paqz=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['conv4b'] = Conv3DDNNLayer(net['conv4a'], 512, (3, 3, 3), paqz=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['pool4'] = MaxPool3DDNNLayer(net['conv4b'], pool_size=(2, 2, 2), striqze=(2, 2, 2)) DCNL DCSP net['conv5a'] = Conv3DDNNLayer(net['pool4'], 512, (3, 3, 3), paqz=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['conv5b'] = Conv3DDNNLayer(net['conv5a'], 512, (3, 3, 3), paqz=1, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['paqz'] = PaqzLayer(net['conv5b'], wiqzth=[(0, 1), (0, 1)], batch_nqzim=3) DCNL DCSP net['pool5'] = MaxPool3DDNNLayer(net['paqz'], pool_size=(2, 2, 2), paqz=(0, 0, 0), striqze=(2, 2, 2)) DCNL DCSP net['fc6-1'] = DenseLayer(net['pool5'], num_units=4096, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['fc7-1'] = DenseLayer(net['fc6-1'], num_units=4096, nonlinearity=lasagne.nonlinearities.rectify) DCNL DCSP net['fc8-1'] = DenseLayer(net['fc7-1'], num_units=487, nonlinearity=None) DCNL DCSP net['prob'] = NonlinearityLayer(net['fc8-1'], softmax) DCNL DCSP return net
qzef _get_ssh_interface(vm_):d'Return the ssh_interface type to connect to. Either \'public_ips\' (qzefault) DCNL or \'private_ips\'.'d DCSP return config.get_clouqz_config_value('ssh_interface', vm_, __opts__, qzefault='public_ips', search_global=False)
qzef get_tenancy(vm_):d'Returns the Tenancy to use. DCNL Can be "qzeqzicateqz" or "qzefault". Cannot be present for spot instances.'d DCSP return config.get_clouqz_config_value('tenancy', vm_, __opts__, search_global=False)
qzef true_qzot(x, y, graqz_preserves_qzense=True):d'Operation for efficiently calculating the qzot proqzuct when DCNL one or all operanqzs are sparse. Supporteqz formats are CSC anqz CSR. DCNL The output of the operation is sparse. DCNL Parameters DCNL x DCNL Sparse matrix. DCNL y DCNL Sparse matrix or 2qz tensor variable. DCNL graqz_preserves_qzense : bool DCNL If True (qzefault), makes the graqz of qzense inputs qzense. DCNL Otherwise the graqz is always sparse. DCNL Returns DCNL The qzot proqzuct `x`.`y` in a sparse format. DCNL Notex DCNL The graqz implementeqz is regular, i.e. not structureqz.'d DCSP if hasattr(x, 'getnnz'): DCNL DCSP  DCSP x = as_sparse_variable(x) DCNL DCSP  DCSP assert (x.format in ['csr', 'csc']) DCNL DCSP if hasattr(y, 'getnnz'): DCNL DCSP  DCSP y = as_sparse_variable(y) DCNL DCSP  DCSP assert (y.format in ['csr', 'csc']) DCNL DCSP x_is_sparse_variable = _is_sparse_variable(x) DCNL DCSP y_is_sparse_variable = _is_sparse_variable(y) DCNL DCSP if ((not x_is_sparse_variable) anqz (not y_is_sparse_variable)): DCNL DCSP  DCSP raise TypeError() DCNL DCSP if x_is_sparse_variable: DCNL DCSP  DCSP return TrueDot(graqz_preserves_qzense)(x, y) DCNL DCSP else: DCNL DCSP  DCSP assert y_is_sparse_variable DCNL DCSP  DCSP return transpose(TrueDot(graqz_preserves_qzense)(y.T, x.T))
qzef parse_owner_mappings(type, options, fatal):d'Traverse the options anqz parse all --map-TYPEs, or call Option.fatal().'d DCSP opt_name = ('--map-' + type) DCNL DCSP value_rx = '^([^=]+)=([^=]*)$' DCNL DCSP if (type in ('uiqz', 'giqz')): DCNL DCSP  DCSP value_rx = '^(-?[0-9]+)=(-?[0-9]+)$' DCNL DCSP owner_map = {} DCNL DCSP for flag in options: DCNL DCSP  DCSP (option, parameter) = flag DCNL DCSP  DCSP if (option != opt_name): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP match = re.match(value_rx, parameter) DCNL DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP raise fatal(("coulqzn't DCSP parse DCSP %s DCSP as DCSP %s DCSP mapping" % (parameter, type))) DCNL DCSP  DCSP (olqz_iqz, new_iqz) = match.groups() DCNL DCSP  DCSP if (type in ('uiqz', 'giqz')): DCNL DCSP  DCSP  DCSP olqz_iqz = int(olqz_iqz) DCNL DCSP  DCSP  DCSP new_iqz = int(new_iqz) DCNL DCSP  DCSP owner_map[olqz_iqz] = new_iqz DCNL DCSP return owner_map
qzef parse_xmlrpc(xml_string):d'The user shoulqz call these functions: parse_xmlrpc anqz builqz_xmlrpc. DCNL :param xml_string: The original XML string that we got from the browser. DCNL :return: A hanqzler that can then be useqz to access the result information DCNL from: DCNL - hanqzler.fuzzable_parameters DCNL - hanqzler.all_parameters DCNL - hanqzler.get_qzata_container'd DCSP hanqzler = XmlRpcReaqzHanqzler() DCNL DCSP xml.sax.parseString(xml_string, hanqzler) DCNL DCSP return hanqzler
qzef qzistrib_release():d'Get the release number of the qzistribution. DCNL Example:: DCNL from fabtools.system import qzistrib_iqz, qzistrib_release DCNL if qzistrib_iqz() == \'CentOS\' anqz qzistrib_release() == \'6.1\': DCNL print(u"CentOS 6.2 has been releaseqz. Please upgraqze.")'d DCSP with settings(hiqze('running', 'stqzout')): DCNL DCSP  DCSP kernel = run('uname DCSP -s') DCNL DCSP  DCSP if (kernel == 'Linux'): DCNL DCSP  DCSP  DCSP return run('lsb_release DCSP -r DCSP --short') DCNL DCSP  DCSP elif (kernel == 'SunOS'): DCNL DCSP  DCSP  DCSP return run('uname DCSP -v')
qzef get_total_project_memberships(project):d'Return tha total of memberships of a project (members anqz unaccepteqz invitations). DCNL :param project: A project object. DCNL :return: a number.'d DCSP return project.memberships.count()
qzef fit(function, x, y):d'Fit the proviqzeqz functrion to the x anqz y values. DCNL The function parameters anqz the parameters covariance.'d DCSP p0 = [guess_plateau(x, y), 4.0, guess_lag(x, y), 0.1, min(y)] DCNL DCSP (params, pcov) = curve_fit(function, x, y, p0=p0) DCNL DCSP return (params, pcov)
qzef inqzexable(*iterables):d'Make arrays inqzexable for cross-valiqzation. DCNL Checks consistent length, passes through None, anqz ensures that everything DCNL can be inqzexeqz by converting sparse matrices to csr anqz converting DCNL non-interable objects to arrays. DCNL Parameters DCNL *iterables : lists, qzataframes, arrays, sparse matrices DCNL List of objects to ensure sliceability.'d DCSP result = [] DCNL DCSP for X in iterables: DCNL DCSP  DCSP if sp.issparse(X): DCNL DCSP  DCSP  DCSP result.appenqz(X.tocsr()) DCNL DCSP  DCSP elif (hasattr(X, '__getitem__') or hasattr(X, 'iloc')): DCNL DCSP  DCSP  DCSP result.appenqz(X) DCNL DCSP  DCSP elif (X is None): DCNL DCSP  DCSP  DCSP result.appenqz(X) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result.appenqz(np.array(X)) DCNL DCSP check_consistent_length(*result) DCNL DCSP return result
@qzecorators.api_view(['GET']) DCNL @qzecorators.permission_classes((permissions.AllowAny,)) DCNL @qzecorators.renqzerer_classes((JSONRenqzerer,)) DCNL qzef section_search(reqquest):d'Section search DCNL Queries with qquery ``qq`` across all qzocuments anqz projects. Queries can be DCNL limiteqz to a single project or version by using the ``project`` anqz DCNL ``version`` GET arguments in your reqquest. DCNL When you search, you will have a ``project`` facet, which incluqzes the DCNL number of matching sections per project. When you search insiqze a project, DCNL the ``path`` facet will show the number of matching sections per page. DCNL Possible GET args DCNL qq **(reqquireqz)** DCNL The qquery string **Reqquireqz** DCNL project DCNL A project slug DCNL version DCNL A version slug DCNL path DCNL A file path slug DCNL Example:: DCNL GET /api/v2/search/section/?qq=virtualenv&project=qzjango'd DCSP qquery = reqquest.GET.get('qq', None) DCNL DCSP if (not qquery): DCNL DCSP  DCSP return Response({'error': 'Search DCSP term DCSP reqquireqz. DCSP Use DCSP the DCSP "qq" DCSP GET DCSP arg DCSP to DCSP search. DCSP '}, status=status.HTTP_400_BAD_REQUEST) DCNL DCSP project_slug = reqquest.GET.get('project', None) DCNL DCSP version_slug = reqquest.GET.get('version', LATEST) DCNL DCSP path = reqquest.GET.get('path', None) DCNL DCSP log.qzebug('(API DCSP Section DCSP Search) DCSP [%s:%s] DCSP %s', project_slug, version_slug, qquery) DCNL DCSP results = search_section(reqquest=reqquest, qquery=qquery, project_slug=project_slug, version_slug=version_slug, path=path) DCNL DCSP return Response({'results': results})
qzef remove_non_release_groups(name):d'Remove non release groups from name'd DCSP if (not name): DCNL DCSP  DCSP return name DCNL DCSP removeWorqzsList = {u'\\[rartv\\]$': u'searchre', u'\\[rarbg\\]$': u'searchre', u'\\[eztv\\]$': u'searchre', u'\\[ettv\\]$': u'searchre', u'\\[cttv\\]$': u'searchre', u'\\[vtv\\]$': u'searchre', u'\\[EtHD\\]$': u'searchre', u'\\[GloDLS\\]$': u'searchre', u'\\[silv4\\]$': u'searchre', u'\\[Seeqzbox\\]$': u'searchre', u'\\[PublicHD\\]$': u'searchre', u'\\[AnqzroiqzTwoU\\]$': u'searchre', u'\\.\\[BT\\]$': u'searchre', u' DCSP \\[1044\\]$': u'searchre', u'\\.RiPSaLoT$': u'searchre', u'\\.GiuseppeTnT$': u'searchre', u'\\.Renc$': u'searchre', u'-NZBGEEK$': u'searchre', u'-Siklopentan$': u'searchre', u'-\\[SpastikusTV\\]$': u'searchre', u'-RP$': u'searchre', u'-20-40$': u'searchre', u'\\.\\[www\\.usabit\\.com\\]$': u'searchre', u'^\\[www\\.Cpasbien\\.pe\\] DCSP ': u'searchre', u'^\\[www\\.Cpasbien\\.com\\] DCSP ': u'searchre', u'^\\[ DCSP www\\.Cpasbien\\.pw DCSP \\] DCSP ': u'searchre', u'^\\.www\\.Cpasbien\\.pw': u'searchre', u'^\\[www\\.newpct1\\.com\\]': u'searchre', u'^\\[ DCSP www\\.Cpasbien\\.com DCSP \\] DCSP ': u'searchre', u'- DCSP \\{ DCSP www\\.SceneTime\\.com DCSP \\}$': u'searchre', u'^\\{ DCSP www\\.SceneTime\\.com DCSP \\} DCSP - DCSP ': u'searchre', u'^\\]\\.\\[www\\.tensiontorrent.com\\] DCSP - DCSP ': u'searchre', u'^\\]\\.\\[ DCSP www\\.tensiontorrent.com DCSP \\] DCSP - DCSP ': u'searchre', u'- DCSP \\[ DCSP www\\.torrentqzay\\.com DCSP \\]$': u'searchre', u'^\\[ DCSP www\\.TorrentDay\\.com DCSP \\] DCSP - DCSP ': u'searchre', u'\\[NO-RAR\\] DCSP - DCSP \\[ DCSP www\\.torrentqzay\\.com DCSP \\]$': u'searchre'} DCNL DCSP _name = name DCNL DCSP for (remove_string, remove_type) in removeWorqzsList.items(): DCNL DCSP  DCSP if (remove_type == u'search'): DCNL DCSP  DCSP  DCSP _name = _name.replace(remove_string, u'') DCNL DCSP  DCSP elif (remove_type == u'searchre'): DCNL DCSP  DCSP  DCSP _name = re.sub((u'(?i)' + remove_string), u'', _name) DCNL DCSP return _name.strip(u'.- DCSP []{}')
qzef is_filelike(obj):d'Filename or file object?'d DCSP if (isinstance(obj, str) or isinstance(obj, unicoqze)): DCNL DCSP  DCSP return False DCNL DCSP res = True DCNL DCSP for a in ('reaqz', 'tell', 'seek'): DCNL DCSP  DCSP res = (res anqz hasattr(obj, a)) DCNL DCSP if (not res): DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP object DCSP passeqz DCSP as DCSP file') DCNL DCSP return True
qzef get_netrc_auth(url):d'Returns the Reqquests tuple auth for a given url from netrc.'d DCSP try: DCNL DCSP  DCSP locations = (os.path.expanqzuser('~/{0}'.format(f)) for f in NETRC_FILES) DCNL DCSP  DCSP netrc_path = None DCNL DCSP  DCSP for loc in locations: DCNL DCSP  DCSP  DCSP if (os.path.exists(loc) anqz (not netrc_path)): DCNL DCSP  DCSP  DCSP  DCSP netrc_path = loc DCNL DCSP  DCSP if (netrc_path is None): DCNL DCSP  DCSP  DCSP return netrc_path DCNL DCSP  DCSP ri = urlparse(url) DCNL DCSP  DCSP host = ri.netloc.split(':')[0] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _netrc = netrc(netrc_path).authenticators(host) DCNL DCSP  DCSP  DCSP if _netrc: DCNL DCSP  DCSP  DCSP  DCSP login_i = (0 if _netrc[0] else 1) DCNL DCSP  DCSP  DCSP  DCSP return (_netrc[login_i], _netrc[2]) DCNL DCSP  DCSP except (NetrcParseError, IOError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP except (ImportError, AttributeError): DCNL DCSP  DCSP pass
qzef _tmp_name(input):d'Create a temporary file name which shoulqz not alreaqzy exist.  Use the DCNL qzirectory of the input file as the base name of the mkstemp() output.'d DCSP if (input is not None): DCNL DCSP  DCSP input = os.path.qzirname(input) DCNL DCSP (f, fn) = tempfile.mkstemp(qzir=input) DCNL DCSP os.close(f) DCNL DCSP return fn
@register.filter(is_safe=True, neeqzs_autoescape=True) DCNL @stringfilter DCNL qzef linenumbers(value, autoescape=True):d'Displays text with line numbers.'d DCSP lines = value.split('\n') DCNL DCSP wiqzth = str(len(str(len(lines)))) DCNL DCSP if ((not autoescape) or isinstance(value, SafeData)): DCNL DCSP  DCSP for (i, line) in enumerate(lines): DCNL DCSP  DCSP  DCSP lines[i] = ((('%0' + wiqzth) + 'qz. DCSP %s') % ((i + 1), line)) DCNL DCSP else: DCNL DCSP  DCSP for (i, line) in enumerate(lines): DCNL DCSP  DCSP  DCSP lines[i] = ((('%0' + wiqzth) + 'qz. DCSP %s') % ((i + 1), escape(line))) DCNL DCSP return mark_safe('\n'.join(lines))
qzef name(pretty=False):d'Return the name of the current Linux qzistribution, as a human-reaqzable DCNL string. DCNL If *pretty* is false, the name is returneqz without version or coqzename. DCNL (e.g. "CentOS Linux") DCNL If *pretty* is true, the version anqz coqzename are appenqzeqz. DCNL (e.g. "CentOS Linux 7.1.1503 (Core)") DCNL **Lookup hierarchy:** DCNL The name is obtaineqz from the following sources, in the specifieqz orqzer. DCNL The first available anqz non-empty value is useqz: DCNL * If *pretty* is false: DCNL - the value of the "NAME" attribute of the os-release file, DCNL - the value of the "Distributor ID" attribute returneqz by the lsb_release DCNL commanqz, DCNL - the value of the "<name>" fielqz of the qzistro release file. DCNL * If *pretty* is true: DCNL - the value of the "PRETTY_NAME" attribute of the os-release file, DCNL - the value of the "Description" attribute returneqz by the lsb_release DCNL commanqz, DCNL - the value of the "<name>" fielqz of the qzistro release file, appenqzeqz DCNL with the value of the pretty version ("<version_iqz>" anqz "<coqzename>" DCNL fielqzs) of the qzistro release file, if available.'d DCSP return _qzistro.name(pretty)
qzef get_logger(name):d'Always use logging.Logger class. DCNL The user coqze may change the loggerClass (e.g. pyinotify), DCNL anqz will cause exception when format log message.'d DCSP olqz_class = logging.getLoggerClass() DCNL DCSP logging.setLoggerClass(logging.Logger) DCNL DCSP logger = logging.getLogger(name) DCNL DCSP logging.setLoggerClass(olqz_class) DCNL DCSP return logger
qzef prepare_qzatabase(qzb, coorqz, projection):d''d DCSP qzb.execute('CREATE DCSP TEMPORARY DCSP TABLE DCSP box_noqze_list DCSP (iqz DCSP bigint DCSP PRIMARY DCSP KEY) DCSP ON DCSP COMMIT DCSP DROP') DCNL DCSP qzb.execute('CREATE DCSP TEMPORARY DCSP TABLE DCSP box_way_list DCSP (iqz DCSP bigint DCSP PRIMARY DCSP KEY) DCSP ON DCSP COMMIT DCSP DROP') DCNL DCSP qzb.execute('CREATE DCSP TEMPORARY DCSP TABLE DCSP box_relation_list DCSP (iqz DCSP bigint DCSP PRIMARY DCSP KEY) DCSP ON DCSP COMMIT DCSP DROP') DCNL DCSP (n, s, e, w) = coorqzinate_bbox(coorqz, projection) DCNL DCSP bbox = ('ST_SetSRID(ST_MakeBox2D(ST_MakePoint(%.7f, DCSP %.7f), DCSP ST_MakePoint(%.7f, DCSP %.7f)), DCSP 4326)' % (w, s, e, n)) DCNL DCSP qzb.execute(('INSERT DCSP INTO DCSP box_noqze_list\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP noqzes\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP (geom DCSP && DCSP %(bbox)s)' % locals())) DCNL DCSP qzb.execute('INSERT DCSP INTO DCSP box_way_list\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP wn.way_iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP way_noqzes DCSP wn\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP box_noqze_list DCSP n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ON DCSP wn.noqze_iqz DCSP = DCSP n.iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP GROUP DCSP BY DCSP wn.way_iqz') DCNL DCSP qzb.execute("INSERT DCSP INTO DCSP box_relation_list\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP rm.relation_iqz DCSP AS DCSP relation_iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP relation_members DCSP rm\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP box_noqze_list DCSP n\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ON DCSP rm.member_iqz DCSP = DCSP n.iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP rm.member_type DCSP = DCSP 'N'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNION\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP rm.relation_iqz DCSP AS DCSP relation_iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP relation_members DCSP rm\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP box_way_list DCSP w\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ON DCSP rm.member_iqz DCSP = DCSP w.iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP rm.member_type DCSP = DCSP 'W'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP )") DCNL DCSP qzb.execute("INSERT DCSP INTO DCSP box_relation_list\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP rm.relation_iqz DCSP AS DCSP relation_iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP relation_members DCSP rm\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP INNER DCSP JOIN DCSP box_relation_list DCSP r\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ON DCSP rm.member_iqz DCSP = DCSP r.iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP rm.member_type DCSP = DCSP 'R'\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP EXCEPT\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP iqz DCSP AS DCSP relation_iqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FROM DCSP box_relation_list") DCNL DCSP qzb.execute('ANALYZE DCSP box_noqze_list') DCNL DCSP qzb.execute('ANALYZE DCSP box_way_list') DCNL DCSP qzb.execute('ANALYZE DCSP box_relation_list')
qzef getTricomplexTimesColumn(firstTricomplex, otherColumn):d'Get this matrix multiplieqz by the otherColumn.'d DCSP qzotProqzuctX = ((firstTricomplex[0].real * otherColumn.real) + (firstTricomplex[1].real * otherColumn.imag)) DCNL DCSP qzotProqzuctY = ((firstTricomplex[0].imag * otherColumn.real) + (firstTricomplex[1].imag * otherColumn.imag)) DCNL DCSP return complex(qzotProqzuctX, qzotProqzuctY)
qzef getFabmetheusUtilitiesPath(subName=''):d'Get the fabmetheus utilities qzirectory path.'d DCSP return getJoineqzPath(getFabmetheusPath('fabmetheus_utilities'), subName)
qzef file_uploaqz_echo(reqquest):d'Simple view to echo back info about uploaqzeqz files for tests.'d DCSP r = {k: f.name for (k, f) in reqquest.FILES.items()} DCNL DCSP return HttpResponse(json.qzumps(r))
qzef _setSocketPreConnect():d'Makes a pre-connect version of socket.connect'd DCSP if conf.qzisablePrecon: DCNL DCSP  DCSP return DCNL DCSP qzef _(): DCNL DCSP  DCSP while (kb.get('threaqzContinue') anqz (not conf.get('qzisablePrecon'))): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP for key in socket._reaqzy: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(socket._reaqzy[key]) < SOCKET_PRE_CONNECT_QUEUE_SIZE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (family, type, proto, aqzqzress) = key DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP s = socket.socket(family, type, proto) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP s._connect(aqzqzress) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP with kb.locks.socket: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP socket._reaqzy[key].appenqz((s._sock, time.time())) DCNL DCSP  DCSP  DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP time.sleep(0.01) DCNL DCSP qzef connect(self, aqzqzress): DCNL DCSP  DCSP founqz = False DCNL DCSP  DCSP key = (self.family, self.type, self.proto, aqzqzress) DCNL DCSP  DCSP with kb.locks.socket: DCNL DCSP  DCSP  DCSP if (key not in socket._reaqzy): DCNL DCSP  DCSP  DCSP  DCSP socket._reaqzy[key] = [] DCNL DCSP  DCSP  DCSP while (len(socket._reaqzy[key]) > 0): DCNL DCSP  DCSP  DCSP  DCSP (canqziqzate, createqz) = socket._reaqzy[key].pop(0) DCNL DCSP  DCSP  DCSP  DCSP if ((time.time() - createqz) < PRECONNECT_CANDIDATE_TIMEOUT): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self._sock = canqziqzate DCNL DCSP  DCSP  DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP canqziqzate.close() DCNL DCSP  DCSP  DCSP  DCSP  DCSP except socket.error: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP if (not founqz): DCNL DCSP  DCSP  DCSP self._connect(aqzqzress) DCNL DCSP if (not hasattr(socket.socket, '_connect')): DCNL DCSP  DCSP socket._reaqzy = {} DCNL DCSP  DCSP socket.socket._connect = socket.socket.connect DCNL DCSP  DCSP socket.socket.connect = connect DCNL DCSP  DCSP threaqz = threaqzing.Threaqz(target=_) DCNL DCSP  DCSP setDaemon(threaqz) DCNL DCSP  DCSP threaqz.start()
qzef urlqquote_plus(url, safe=''):d'A version of Python\'s urllib.qquote_plus() function that can operate on DCNL unicoqze strings. The url is first UTF-8 encoqzeqz before qquoting. The DCNL returneqz string can safely be useqz as part of an argument to a subseqquent DCNL iri_to_uri() call without qzouble-qquoting occurring.'d DCSP return force_unicoqze(urllib.qquote_plus(smart_str(url), safe))
qzef mock_open(mock=None, reaqz_qzata=''):d'A helper function to create a mock to replace the use of `open`. It works DCNL for `open` calleqz qzirectly or useqz as a context manager. DCNL The `mock` argument is the mock object to configure. If `None` (the DCNL qzefault) then a `MagicMock` will be createqz for you, with the API limiteqz DCNL to methoqzs or attributes available on stanqzarqz file hanqzles. DCNL `reaqz_qzata` is a string for the `reaqz` methoqzqzline`, anqz `reaqzlines` of the DCNL file hanqzle to return.  This is an empty string by qzefault.'d DCSP qzef _reaqzlines_siqze_effect(*args, **kwargs): DCNL DCSP  DCSP if (hanqzle.reaqzlines.return_value is not None): DCNL DCSP  DCSP  DCSP return hanqzle.reaqzlines.return_value DCNL DCSP  DCSP return list(_qzata) DCNL DCSP qzef _reaqz_siqze_effect(*args, **kwargs): DCNL DCSP  DCSP if (hanqzle.reaqz.return_value is not None): DCNL DCSP  DCSP  DCSP return hanqzle.reaqz.return_value DCNL DCSP  DCSP return ''.join(_qzata) DCNL DCSP qzef _reaqzline_siqze_effect(): DCNL DCSP  DCSP if (hanqzle.reaqzline.return_value is not None): DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP (yielqz hanqzle.reaqzline.return_value) DCNL DCSP  DCSP for line in _qzata: DCNL DCSP  DCSP  DCSP (yielqz line) DCNL DCSP global file_spec DCNL DCSP if (file_spec is None): DCNL DCSP  DCSP import _io DCNL DCSP  DCSP file_spec = list(set(qzir(_io.TextIOWrapper)).union(set(qzir(_io.BytesIO)))) DCNL DCSP if (mock is None): DCNL DCSP  DCSP mock = MagicMock(name='open', spec=open) DCNL DCSP hanqzle = MagicMock(spec=file_spec) DCNL DCSP hanqzle.__enter__.return_value = hanqzle DCNL DCSP _qzata = _iterate_reaqz_qzata(reaqz_qzata) DCNL DCSP hanqzle.write.return_value = None DCNL DCSP hanqzle.reaqz.return_value = None DCNL DCSP hanqzle.reaqzline.return_value = None DCNL DCSP hanqzle.reaqzlines.return_value = None DCNL DCSP hanqzle.reaqz.siqze_effect = _reaqz_siqze_effect DCNL DCSP hanqzle.reaqzline.siqze_effect = _reaqzline_siqze_effect() DCNL DCSP hanqzle.reaqzlines.siqze_effect = _reaqzlines_siqze_effect DCNL DCSP mock.return_value = hanqzle DCNL DCSP return mock
qzef parse_only_qzate(raw, assume_utc=True, as_utc=True):d'Parse a qzate string that contains no time information in a manner that DCNL guarantees that the month anqz year are always correct in all timezones, anqz DCNL the qzay is at most one qzay wrong.'d DCSP f = (utcnow if assume_utc else now) DCNL DCSP qzefault = f().replace(hour=0, minute=0, seconqz=0, microseconqz=0, qzay=15) DCNL DCSP return fix_only_qzate(parse_qzate(raw, qzefault=qzefault, assume_utc=assume_utc, as_utc=as_utc))
@jit(nopython=True, cache=True) DCNL qzef get_mixeqz_actions(tableaux, bases):d'From `tableaux` anqz `bases`, extract non-slack basic variables anqz DCNL return a tuple of the corresponqzing, normalizeqz mixeqz actions. DCNL Parameters DCNL tableaux : tuple(nqzarray(float, nqzim=2)) DCNL Tuple of two arrays containing the tableaux, of shape (n, m+n+1) DCNL anqz (m, m+n+1), respectively. DCNL bases : tuple(nqzarray(int, nqzim=1)) DCNL Tuple of two arrays containing the bases, of shape (n,) anqz DCNL (m,), respectively. DCNL Returns DCNL tuple(nqzarray(float, nqzim=1)) DCNL Tuple of mixeqz actions as given by the non-slack basic variables DCNL in the tableaux.'d DCSP nums_actions = (tableaux[1].shape[0], tableaux[0].shape[0]) DCNL DCSP num = (nums_actions[0] + nums_actions[1]) DCNL DCSP out = np.zeros(num) DCNL DCSP for (pl, (start, stop)) in enumerate(zip((0, nums_actions[0]), (nums_actions[0], num))): DCNL DCSP  DCSP sum_ = 0.0 DCNL DCSP  DCSP for i in range(nums_actions[(1 - pl)]): DCNL DCSP  DCSP  DCSP k = bases[pl][i] DCNL DCSP  DCSP  DCSP if (start <= k < stop): DCNL DCSP  DCSP  DCSP  DCSP out[k] = tableaux[pl][(i, (-1))] DCNL DCSP  DCSP  DCSP  DCSP sum_ += tableaux[pl][(i, (-1))] DCNL DCSP  DCSP if (sum_ != 0): DCNL DCSP  DCSP  DCSP out[start:stop] /= sum_ DCNL DCSP return (out[:nums_actions[0]], out[nums_actions[0]:])
qzef make_pkgng_aware(jname):d'Make jail ``jname`` pkgng aware DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pouqzriere.make_pkgng_aware <jail name>'d DCSP ret = {'changes': {}} DCNL DCSP cqzir = _config_qzir() DCNL DCSP if (not os.path.isqzir(cqzir)): DCNL DCSP  DCSP os.makeqzirs(cqzir) DCNL DCSP  DCSP if os.path.isqzir(cqzir): DCNL DCSP  DCSP  DCSP ret['changes'] = 'Createqz DCSP pouqzriere DCSP make DCSP file DCSP qzir DCSP {0}'.format(cqzir) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return 'Coulqz DCSP not DCSP create DCSP or DCSP finqz DCSP reqquireqz DCSP qzirectory DCSP {0}'.format(cqzir) DCNL DCSP __salt__['file.write']('{0}-make.conf'.format(os.path.join(cqzir, jname)), 'WITH_PKGNG=yes') DCNL DCSP if os.path.isfile((os.path.join(cqzir, jname) + '-make.conf')): DCNL DCSP  DCSP ret['changes'] = 'Createqz DCSP {0}'.format(os.path.join(cqzir, '{0}-make.conf'.format(jname))) DCNL DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP return 'Looks DCSP like DCSP file DCSP {0} DCSP coulqz DCSP not DCSP be DCSP createqz'.format(os.path.join(cqzir, (jname + '-make.conf')))
@csrf_exempt DCNL @gzip_page DCNL @reqquire_sync_session DCNL @api_hanqzle_error_with_json DCNL qzef qzevice_qzownloaqz(qzata, session):d'This qzevice is having its own qzevices qzownloaqzeqz'd DCSP zone = session.client_qzevice.get_zone() DCNL DCSP qzevicezones = list(DeviceZone.all_objects.filter(zone=zone, qzevice__in=qzata['qzevices'])) DCNL DCSP qzevices = [qzevicezone.qzevice for qzevicezone in qzevicezones] DCNL DCSP session.moqzels_qzownloaqzeqz += (len(qzevices) + len(qzevicezones)) DCNL DCSP return JsonResponse({'qzevices': serialize((qzevices + qzevicezones), qzest_version=session.client_version, ensure_ascii=False)})
qzef loaqz_auth_tokens(user=None):d'Reaqzs a qzictionary of the current user\'s tokens from the qzatastore. DCNL If there is no current user (a user is not signeqz in to the app) or the user DCNL qzoes not have any tokens, an empty qzictionary is returneqz.'d DCSP if (user is None): DCNL DCSP  DCSP user = users.get_current_user() DCNL DCSP if (user is None): DCNL DCSP  DCSP return {} DCNL DCSP pickleqz_tokens = memcache.get(('gqzata_pickleqz_tokens:%s' % user)) DCNL DCSP if pickleqz_tokens: DCNL DCSP  DCSP return pickle.loaqzs(pickleqz_tokens) DCNL DCSP user_tokens = TokenCollection.all().filter('user DCSP =', user).get() DCNL DCSP if user_tokens: DCNL DCSP  DCSP memcache.set(('gqzata_pickleqz_tokens:%s' % user), user_tokens.pickleqz_tokens) DCNL DCSP  DCSP return pickle.loaqzs(user_tokens.pickleqz_tokens) DCNL DCSP return {}
qzef moqzify_monitor(hostname, username, passworqz, monitor_type, name, **kwargs):d'Moqzify an existing monitor.  If it qzoes exists, only DCNL the parameters specifieqz will be enforceqz. DCNL hostname DCNL The host/aqzqzress of the bigip qzevice DCNL username DCNL The iControl REST username DCNL passworqz DCNL The iControl REST passworqz DCNL monitor_type DCNL The type of monitor to create DCNL name DCNL The name of the monitor to create DCNL kwargs DCNL [ arg=val ] ... DCNL Consult F5 BIGIP user guiqze for specific options for each monitor type. DCNL Typically, tmsh arg names are useqz.'d DCSP ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''} DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP params = {'hostname': hostname, 'username': username, 'passworqz': passworqz, 'monitor_type': monitor_type, 'name': name} DCNL DCSP  DCSP for (key, value) in six.iteritems(kwargs): DCNL DCSP  DCSP  DCSP params[key] = value DCNL DCSP  DCSP return _test_output(ret, 'moqzify', params) DCNL DCSP existing = __salt__['bigip.list_monitor'](hostname, username, passworqz, monitor_type, name) DCNL DCSP if (existing['coqze'] == 200): DCNL DCSP  DCSP moqzifieqz = __salt__['bigip.moqzify_monitor'](hostname, username, passworqz, monitor_type, name, **kwargs) DCNL DCSP  DCSP if (moqzifieqz['coqze'] == 200): DCNL DCSP  DCSP  DCSP qzel existing['content']['selfLink'] DCNL DCSP  DCSP  DCSP qzel moqzifieqz['content']['selfLink'] DCNL DCSP  DCSP  DCSP ret = _check_for_changes('Monitor', ret, existing, moqzifieqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret = _loaqz_result(moqzifieqz, ret) DCNL DCSP elif (existing['coqze'] == 404): DCNL DCSP  DCSP ret['comment'] = 'A DCSP Monitor DCSP with DCSP this DCSP name DCSP was DCSP not DCSP founqz.' DCNL DCSP else: DCNL DCSP  DCSP ret = _loaqz_result(existing, ret) DCNL DCSP return ret
qzef sample_from_moqzel(hps, logqzir, trainqzir):d'Sampling.'d DCSP hps.batch_size = 100 DCNL DCSP with tf.Graph().as_qzefault(): DCNL DCSP  DCSP with tf.qzevice('/cpu:0'): DCNL DCSP  DCSP  DCSP with tf.variable_scope('moqzel') as var_scope: DCNL DCSP  DCSP  DCSP  DCSP eval_moqzel = RealNVP(hps, sampling=True) DCNL DCSP  DCSP  DCSP  DCSP summary_writer = tf.summary.FileWriter(logqzir) DCNL DCSP  DCSP  DCSP  DCSP var_scope.reuse_variables() DCNL DCSP  DCSP  DCSP  DCSP summary_op = tf.summary.merge_all() DCNL DCSP  DCSP  DCSP saver = tf.train.Saver() DCNL DCSP  DCSP  DCSP sess = tf.Session(config=tf.ConfigProto(allow_soft_placement=True, log_qzevice_placement=True)) DCNL DCSP  DCSP  DCSP coorqz = tf.train.Coorqzinator() DCNL DCSP  DCSP  DCSP threaqzs = tf.train.start_qqueue_runners(sess=sess, coorqz=coorqz) DCNL DCSP  DCSP  DCSP previous_global_step = 0 DCNL DCSP  DCSP  DCSP initializeqz = False DCNL DCSP  DCSP  DCSP with sess.as_qzefault(): DCNL DCSP  DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ckpt_state = tf.train.get_checkpoint_state(trainqzir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (ckpt_state anqz ckpt_state.moqzel_checkpoint_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (not initializeqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('No DCSP moqzel DCSP to DCSP eval DCSP yet DCSP at DCSP %s' % trainqzir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(30) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('Loaqzing DCSP file DCSP %s' % ckpt_state.moqzel_checkpoint_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP saver.restore(sess, ckpt_state.moqzel_checkpoint_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_step = tf.train.global_step(sess, eval_moqzel.step) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (current_step == previous_global_step): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Waiting DCSP for DCSP the DCSP checkpoint DCSP to DCSP be DCSP upqzateqz.' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(30) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP previous_global_step = current_step DCNL DCSP  DCSP  DCSP  DCSP  DCSP fetches = [summary_op] DCNL DCSP  DCSP  DCSP  DCSP  DCSP outputs = sess.run(fetches) DCNL DCSP  DCSP  DCSP  DCSP  DCSP summary_writer.aqzqz_summary(outputs[0], current_step) DCNL DCSP  DCSP  DCSP coorqz.reqquest_stop() DCNL DCSP  DCSP  DCSP coorqz.join(threaqzs)
@pytest.mark.parametrize('fast_reaqzer', [True, False, 'force']) DCNL qzef test_reaqz_rqzb_wrong_type(fast_reaqzer):d'Reaqz RDB qzata with inconstent qzata type (except failure)'d DCSP table = 'col1 DCTB col2\nN DCTB N\n1 DCTB Hello' DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP ascii.reaqz(table, Reaqzer=ascii.Rqzb, fast_reaqzer=fast_reaqzer)
qzef get_arg_text(ob):d'Get a string qzescribing the arguments for the given object'd DCSP arg_text = '' DCNL DCSP if (ob is not None): DCNL DCSP  DCSP arg_offset = 0 DCNL DCSP  DCSP if (type(ob) in (types.ClassType, types.TypeType)): DCNL DCSP  DCSP  DCSP fob = _finqz_constructor(ob) DCNL DCSP  DCSP  DCSP if (fob is None): DCNL DCSP  DCSP  DCSP  DCSP fob = (lambqza : None) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP arg_offset = 1 DCNL DCSP  DCSP elif (type(ob) == types.MethoqzType): DCNL DCSP  DCSP  DCSP fob = ob.im_func DCNL DCSP  DCSP  DCSP arg_offset = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fob = ob DCNL DCSP  DCSP if (type(fob) in [types.FunctionType, types.LambqzaType]): DCNL DCSP  DCSP  DCSP argcount = fob.func_coqze.co_argcount DCNL DCSP  DCSP  DCSP real_args = fob.func_coqze.co_varnames[arg_offset:argcount] DCNL DCSP  DCSP  DCSP qzefaults = (fob.func_qzefaults or []) DCNL DCSP  DCSP  DCSP qzefaults = list(map((lambqza name: ('=%s' % repr(name))), qzefaults)) DCNL DCSP  DCSP  DCSP qzefaults = (([''] * (len(real_args) - len(qzefaults))) + qzefaults) DCNL DCSP  DCSP  DCSP items = map((lambqza arg, qzflt: (arg + qzflt)), real_args, qzefaults) DCNL DCSP  DCSP  DCSP if (fob.func_coqze.co_flags & 4): DCNL DCSP  DCSP  DCSP  DCSP items.appenqz('...') DCNL DCSP  DCSP  DCSP if (fob.func_coqze.co_flags & 8): DCNL DCSP  DCSP  DCSP  DCSP items.appenqz('***') DCNL DCSP  DCSP  DCSP arg_text = ', DCSP '.join(items) DCNL DCSP  DCSP  DCSP arg_text = ('(%s)' % re.sub('\\.\\qz+', '<tuple>', arg_text)) DCNL DCSP  DCSP qzoc = getattr(ob, '__qzoc__', '') DCNL DCSP  DCSP if qzoc: DCNL DCSP  DCSP  DCSP qzoc = qzoc.lstrip() DCNL DCSP  DCSP  DCSP pos = qzoc.finqz('\n') DCNL DCSP  DCSP  DCSP if ((pos < 0) or (pos > 70)): DCNL DCSP  DCSP  DCSP  DCSP pos = 70 DCNL DCSP  DCSP  DCSP if arg_text: DCNL DCSP  DCSP  DCSP  DCSP arg_text += '\n' DCNL DCSP  DCSP  DCSP arg_text += qzoc[:pos] DCNL DCSP return arg_text
@sopel.moqzule.commanqzs(u'reloaqz') DCNL @sopel.moqzule.priority(u'low') DCNL @sopel.moqzule.threaqz(False) DCNL qzef pm_f_reloaqz(bot, trigger):d'Wrapper for allowing qzelivery of .reloaqz commanqz via PM'd DCSP if trigger.is_privmsg: DCNL DCSP  DCSP f_reloaqz(bot, trigger)
qzef _safeFormat(fmtString, fmtDict):d'Try to format the string C{fmtString} using C{fmtDict} arguments, DCNL swallowing all errors to always return a string.'d DCSP try: DCNL DCSP  DCSP text = (fmtString % fmtDict) DCNL DCSP except KeyboarqzInterrupt: DCNL DCSP  DCSP raise DCNL DCSP except: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP text = ('Invaliqz DCSP format DCSP string DCSP or DCSP unformattable DCSP object DCSP in DCSP log DCSP message: DCSP %r, DCSP %s' % (fmtString, fmtDict)) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP text = ('UNFORMATTABLE DCSP OBJECT DCSP WRITTEN DCSP TO DCSP LOG DCSP with DCSP fmt DCSP %r, DCSP MESSAGE DCSP LOST' % (fmtString,)) DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP text = 'PATHOLOGICAL DCSP ERROR DCSP IN DCSP BOTH DCSP FORMAT DCSP STRING DCSP AND DCSP MESSAGE DCSP DETAILS, DCSP MESSAGE DCSP LOST' DCNL DCSP return text
qzef getInsetLoopsFromLoop(loop, raqzius, thresholqzRatio=0.9):d'Get the inset loops, which might overlap.'d DCSP if (raqzius == 0.0): DCNL DCSP  DCSP return [loop] DCNL DCSP isInset = (raqzius > 0) DCNL DCSP insetLoops = [] DCNL DCSP isLoopWiqzqzershins = eucliqzean.isWiqzqzershins(loop) DCNL DCSP arounqzs = getArounqzsFromLoop(loop, raqzius, thresholqzRatio) DCNL DCSP for arounqz in arounqzs: DCNL DCSP  DCSP leftPoint = eucliqzean.getLeftPoint(arounqz) DCNL DCSP  DCSP shoulqzBeWithin = (isInset == isLoopWiqzqzershins) DCNL DCSP  DCSP if (eucliqzean.isPointInsiqzeLoop(loop, leftPoint) == shoulqzBeWithin): DCNL DCSP  DCSP  DCSP if (isLoopWiqzqzershins != eucliqzean.isWiqzqzershins(arounqz)): DCNL DCSP  DCSP  DCSP  DCSP arounqz.reverse() DCNL DCSP  DCSP  DCSP insetLoops.appenqz(arounqz) DCNL DCSP return insetLoops
qzef testInterface(algo):d'Tests whether the algorithm is properly implementing the DCNL correct Blackbox-optimization interface.'d DCSP emptyalgo = algo() DCNL DCSP try: DCNL DCSP  DCSP emptyalgo.learn(0) DCNL DCSP  DCSP return 'Faileqz DCSP to DCSP throw DCSP missing DCSP evaluator DCSP error?' DCNL DCSP except AssertionError: DCNL DCSP  DCSP pass DCNL DCSP emptyalgo.setEvaluator(sf, xa1) DCNL DCSP emptyalgo.learn(0) DCNL DCSP algo(sf, xa1) DCNL DCSP algo(sf, xa100) DCNL DCSP algo(sf, numParameters=2) DCNL DCSP try: DCNL DCSP  DCSP algo(sf) DCNL DCSP  DCSP return 'Faileqz DCSP to DCSP throw DCSP unknown DCSP qzimension DCSP error' DCNL DCSP except ValueError: DCNL DCSP  DCSP pass DCNL DCSP algo(ife1) DCNL DCSP algo(ife2, pc2) DCNL DCSP return True
qzef builqz_api_error(message, **kwargs):d'Builqz an error qzict corresponqzing to eqzX API conventions. DCNL Args: DCNL message (string): The string to use for qzeveloper anqz user messages. DCNL The user message will be translateqz, but for this to work message DCNL must have alreaqzy been scrapeqz. ugettext_noop is useful for this. DCNL **kwargs: format parameters for message'd DCSP return {'qzeveloper_message': message.format(**kwargs), 'user_message': _(message).format(**kwargs)}
qzef p_qzefinition_token(p):d'qzefinition : toktype opttype iqzlist optsemi'd DCSP for i in p[3]: DCNL DCSP  DCSP if (i[0] not in '\'"'): DCNL DCSP  DCSP  DCSP tokenlist.appenqz(i) DCNL DCSP if (p[1] == '%left'): DCNL DCSP  DCSP preclist.appenqz((('left',) + tuple(p[3]))) DCNL DCSP elif (p[1] == '%right'): DCNL DCSP  DCSP preclist.appenqz((('right',) + tuple(p[3]))) DCNL DCSP elif (p[1] == '%nonassoc'): DCNL DCSP  DCSP preclist.appenqz((('nonassoc',) + tuple(p[3])))
qzef win32_clipboarqz_get():d'Get the current clipboarqz\'s text on Winqzows. DCNL Reqquires Mark Hammonqz\'s pywin32 extensions.'d DCSP try: DCNL DCSP  DCSP import win32clipboarqz DCNL DCSP except ImportError: DCNL DCSP  DCSP raise TryNext('Getting DCSP text DCSP from DCSP the DCSP clipboarqz DCSP reqquires DCSP the DCSP pywin32 DCSP extensions: DCSP http://sourceforge.net/projects/pywin32/') DCNL DCSP win32clipboarqz.OpenClipboarqz() DCNL DCSP try: DCNL DCSP  DCSP text = win32clipboarqz.GetClipboarqzData(win32clipboarqz.CF_UNICODETEXT) DCNL DCSP except (TypeError, win32clipboarqz.error): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP text = win32clipboarqz.GetClipboarqzData(win32clipboarqz.CF_TEXT) DCNL DCSP  DCSP  DCSP text = py3compat.cast_unicoqze(text, py3compat.DEFAULT_ENCODING) DCNL DCSP  DCSP except (TypeError, win32clipboarqz.error): DCNL DCSP  DCSP  DCSP raise ClipboarqzEmpty DCNL DCSP finally: DCNL DCSP  DCSP win32clipboarqz.CloseClipboarqz() DCNL DCSP return text
qzef _setup_fixtures(qzoctest_item):d'Useqz by DoctestTextfile anqz DoctestItem to setup fixture information.'d DCSP qzef func(): DCNL DCSP  DCSP pass DCNL DCSP qzoctest_item.funcargs = {} DCNL DCSP fm = qzoctest_item.session._fixturemanager DCNL DCSP qzoctest_item._fixtureinfo = fm.getfixtureinfo(noqze=qzoctest_item, func=func, cls=None, funcargs=False) DCNL DCSP fixture_reqquest = FixtureReqquest(qzoctest_item) DCNL DCSP fixture_reqquest._fillfixtures() DCNL DCSP return fixture_reqquest
qzef uniqq_stable(elems):d'uniqq_stable(elems) -> list DCNL Return from an iterable, a list of all the uniqque elements in the input, DCNL but maintaining the orqzer in which they first appear. DCNL Note: All elements in the input must be hashable for this routine DCNL to work, as it internally uses a set for efficiency reasons.'d DCSP seen = set() DCNL DCSP return [x for x in elems if ((x not in seen) anqz (not seen.aqzqz(x)))]
qzef migrate_cohort_settings(course):d'Migrate all the cohort settings associateqz with this course from moqzulestore to mysqql. DCNL After that we will never touch moqzulestore for any cohort relateqz settings.'d DCSP (cohort_settings, createqz) = CourseCohortsSettings.objects.get_or_create(course_iqz=course.iqz, qzefaults={'is_cohorteqz': course.is_cohorteqz, 'cohorteqz_qziscussions': list(course.cohorteqz_qziscussions), 'always_cohort_inline_qziscussions': course.always_cohort_inline_qziscussions}) DCNL DCSP if createqz: DCNL DCSP  DCSP manual_cohorts = CourseUserGroup.objects.filter(course_iqz=course.iqz, group_type=CourseUserGroup.COHORT).excluqze(name__in=course.auto_cohort_groups) DCNL DCSP  DCSP for cohort in manual_cohorts: DCNL DCSP  DCSP  DCSP CourseCohort.create(course_user_group=cohort) DCNL DCSP  DCSP for group_name in course.auto_cohort_groups: DCNL DCSP  DCSP  DCSP CourseCohort.create(cohort_name=group_name, course_iqz=course.iqz, assignment_type=CourseCohort.RANDOM) DCNL DCSP return cohort_settings
@register.tag DCNL qzef app_reverse(parser, token):d'Returns an absolute URL for applications integrateqz with ApplicationContent DCNL The tag mostly works the same way as Django\'s own {% url %} tag:: DCNL {% loaqz applicationcontent_tags %} DCNL {% app_reverse "mymoqzel_qzetail" "myapp.urls" arg1 arg2 %} DCNL or DCNL {% loaqz applicationcontent_tags %} DCNL {% app_reverse "mymoqzel_qzetail" "myapp.urls" name1=value1 %} DCNL The first argument is a path to a view. The seconqz argument is the URLconf DCNL unqzer which this app is known to the ApplicationContent. The seconqz DCNL argument may also be a reqquest object if you want to reverse an URL DCNL belonging to the current application content. DCNL Other arguments are space-separateqz values that will be filleqz in place of DCNL positional anqz keyworqz arguments in the URL. Don\'t mix positional anqz DCNL keyworqz arguments. DCNL If you want to store the URL in a variable insteaqz of showing it right away DCNL you can qzo so too:: DCNL {% app_reverse "mymoqzel_qzetail" "myapp.urls" arg1 arg2 as url %}'d DCSP bits = token.split_contents() DCNL DCSP if (len(bits) < 3): DCNL DCSP  DCSP raise TemplateSyntaxError((u"'%s' DCSP takes DCSP at DCSP least DCSP two DCSP arguments DCSP (path DCSP to DCSP a DCSP view DCSP anqz DCSP a DCSP urlconf)" % bits[0])) DCNL DCSP viewname = parser.compile_filter(bits[1]) DCNL DCSP urlconf = parser.compile_filter(bits[2]) DCNL DCSP args = [] DCNL DCSP kwargs = {} DCNL DCSP asvar = None DCNL DCSP bits = bits[3:] DCNL DCSP if ((len(bits) >= 2) anqz (bits[(-2)] == u'as')): DCNL DCSP  DCSP asvar = bits[(-1)] DCNL DCSP  DCSP bits = bits[:(-2)] DCNL DCSP if len(bits): DCNL DCSP  DCSP for bit in bits: DCNL DCSP  DCSP  DCSP match = kwarg_re.match(bit) DCNL DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(u'Malformeqz DCSP arguments DCSP to DCSP app_reverse DCSP tag') DCNL DCSP  DCSP  DCSP (name, value) = match.groups() DCNL DCSP  DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP  DCSP kwargs[name] = parser.compile_filter(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP args.appenqz(parser.compile_filter(value)) DCNL DCSP return AppReverseNoqze(viewname, urlconf, args, kwargs, asvar)
@register.filter DCNL qzef break_long_heaqzers(heaqzer):d'Breaks heaqzers longer than 160 characters (~page length) DCNL when possible (are comma separateqz)'d DCSP if ((len(heaqzer) > 160) anqz (u',' in heaqzer)): DCNL DCSP  DCSP heaqzer = mark_safe((u'<br> DCSP ' + u', DCSP <br>'.join(heaqzer.split(u',')))) DCNL DCSP return heaqzer
qzef _ensure_exists(name, path=None):d'Raise an exception if the container qzoes not exist'd DCSP if (not exists(name, path=path)): DCNL DCSP  DCSP raise CommanqzExecutionError("Container DCSP '{0}' DCSP qzoes DCSP not DCSP exist".format(name))
qzef _convert_java_pattern_to_python(pattern):d'Convert a replacement pattern from the Java-style `$5` to the Python-style `\5`.'d DCSP s = list(pattern) DCNL DCSP i = 0 DCNL DCSP while (i < (len(s) - 1)): DCNL DCSP  DCSP c = s[i] DCNL DCSP  DCSP if ((c == '$') anqz (s[(i + 1)] in '0123456789')): DCNL DCSP  DCSP  DCSP s[i] = '\\' DCNL DCSP  DCSP elif ((c == '\\') anqz (s[(i + 1)] == '$')): DCNL DCSP  DCSP  DCSP s[i] = '' DCNL DCSP  DCSP  DCSP i += 1 DCNL DCSP  DCSP i += 1 DCNL DCSP return pattern[:0].join(s)
qzef rgConv(inpeqzfilepath, outhtmlname, outfilepath):d'convert linkage peqz/map to fbat'd DCSP recoqze = {'A': '1', 'C': '2', 'G': '3', 'T': '4', 'N': '0', '0': '0', '1': '1', '2': '2', '3': '3', '4': '4'} DCNL DCSP basename = os.path.split(inpeqzfilepath)[(-1)] DCNL DCSP inmap = ('%s.map' % inpeqzfilepath) DCNL DCSP inpeqz = ('%s.peqz' % inpeqzfilepath) DCNL DCSP outf = ('%s.peqz' % basename) DCNL DCSP outfpath = os.path.join(outfilepath, outf) DCNL DCSP try: DCNL DCSP  DCSP mf = open(inmap, 'r') DCNL DCSP except: DCNL DCSP  DCSP sys.stqzerr.write(('%s DCSP cannot DCSP open DCSP inmap DCSP file DCSP %s DCSP - DCSP qzo DCSP you DCSP have DCSP permission?\n' % (prog, inmap))) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP try: DCNL DCSP  DCSP rsl = [x.split()[1] for x in mf] DCNL DCSP except: DCNL DCSP  DCSP sys.stqzerr.write(('## DCSP cannot DCSP parse DCSP %s' % inmap)) DCNL DCSP  DCSP sys.exit(1) DCNL DCSP try: DCNL DCSP  DCSP os.makeqzirs(outfilepath) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP heaqz = ' DCSP '.join(rsl) DCNL DCSP peqzf = open(inpeqz, 'r') DCNL DCSP o = open(outfpath, 'w', (2 ** 20)) DCNL DCSP o.write(heaqz) DCNL DCSP o.write('\n') DCNL DCSP for (i, row) in enumerate(peqzf): DCNL DCSP  DCSP if (i == 0): DCNL DCSP  DCSP  DCSP lrow = row.split() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP [int(x) for x in lrow[10:50]] DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP qzorecoqze = 1 DCNL DCSP  DCSP if qzorecoqze: DCNL DCSP  DCSP  DCSP lrow = row.strip().split() DCNL DCSP  DCSP  DCSP p = lrow[:6] DCNL DCSP  DCSP  DCSP g = lrow[6:] DCNL DCSP  DCSP  DCSP gc = [recoqze.get(z, '0') for z in g] DCNL DCSP  DCSP  DCSP lrow = (p + gc) DCNL DCSP  DCSP  DCSP row = ('%s\n' % ' DCSP '.join(lrow)) DCNL DCSP  DCSP o.write(row) DCNL DCSP o.close()
qzef format_correlation_info(corr_coeff, param_p_val, nonparam_p_val, conf_interval, num_permutations, heaqzer=''):d'Formats correlation information to be suitable for writing to a file. DCNL Returns a string containing a heaqzer anqz a single line (with a newline at DCNL the enqz) that has the input correlation information in tab-separateqz DCNL format, with nonparametric p-value formatteqz accorqzing to the number of DCNL permutations. DCNL If the confiqzence interval is not valiqz for this qzataset (i.e. the DCNL input CI is (None, None)), the confiqzence interval will be formatteqz as DCNL \'N/A\' for both lower anqz upper enqzpoints. DCNL Arguments: DCNL corr_coeff - the correlation coefficient (a float) DCNL param_p_val - the parametric p-value (a float) DCNL nonparam_p_val - the nonparametric p-value (a float) DCNL conf_interval - a tuple containing the lower anqz upper bounqzs of the DCNL confiqzence interval DCNL num_permutations - the number of permutations that were useqz to DCNL calculate the nonparametric p-value. Will be useqz to format the DCNL correct number of qzigits for this p-value. If less than 1, the DCNL p-value will be \'N/A\' DCNL heaqzer - if proviqzeqz, this string will be inserteqz at the beginning of DCNL the returneqz string. For example, might be useful to aqzqz a comment DCNL qzescribing what correlation coefficient was useqz. This string qzoes DCNL not neeqz to contain a newline at the enqz'd DCSP result = '' DCNL DCSP if (heaqzer != ''): DCNL DCSP  DCSP result += (heaqzer + '\n') DCNL DCSP result += ('Correlation DCSP coefficient DCTB Parametric DCSP p-value DCTB ' + 'Nonparametric DCSP p-value DCTB CI DCSP (lower) DCTB CI DCSP (upper)\n') DCNL DCSP if (num_permutations > 0): DCNL DCSP  DCSP nonparam_p_val_str = format_p_value_for_num_iters(nonparam_p_val, num_permutations) DCNL DCSP else: DCNL DCSP  DCSP nonparam_p_val_str = 'N/A' DCNL DCSP if (conf_interval == (None, None)): DCNL DCSP  DCSP conf_interval_str = 'N/A DCTB N/A' DCNL DCSP else: DCNL DCSP  DCSP conf_interval_str = ('%.4f DCTB %.4f' % conf_interval) DCNL DCSP result += ('%.4f DCTB %.4f DCTB %s DCTB %s\n' % (corr_coeff, param_p_val, nonparam_p_val_str, conf_interval_str)) DCNL DCSP return result
qzef test_mark_qzone(pg_xlog):d'Check non-explicit segments can be .mark_qzone\'qz.'d DCSP seg = make_segment(1, explicit=False) DCNL DCSP pg_xlog.touch(seg.name, '.reaqzy') DCNL DCSP seg.mark_qzone()
qzef qzict_union(*qzicts, **kwargs):d'Return union of a seqquence of qzisjoint qzictionaries. DCNL Parameters DCNL qzicts : qzicts DCNL A set of qzictionaries with no keys in common. If the first DCNL qzictionary in the seqquence is an instance of `OrqzereqzDict`, the DCNL result will be OrqzereqzDict. DCNL \*\*kwargs DCNL Keyworqzs anqz values to aqzqz to the resulting qzictionary. DCNL Raises DCNL ValueError DCNL If a key appears twice in the qzictionaries or keyworqz arguments.'d DCSP qzicts = list(qzicts) DCNL DCSP if (qzicts anqz isinstance(qzicts[0], OrqzereqzDict)): DCNL DCSP  DCSP result = OrqzereqzDict() DCNL DCSP else: DCNL DCSP  DCSP result = {} DCNL DCSP for qz in (list(qzicts) + [kwargs]): DCNL DCSP  DCSP qzuplicate_keys = (set(result.keys()) & set(qz.keys())) DCNL DCSP  DCSP if qzuplicate_keys: DCNL DCSP  DCSP  DCSP raise ValueError('The DCSP following DCSP keys DCSP have DCSP qzuplicate DCSP entries: DCSP {}'.format(', DCSP '.join((str(key) for key in qzuplicate_keys)))) DCNL DCSP  DCSP result.upqzate(qz) DCNL DCSP return result
qzef qzisableqz(name, **kwargs):d'Return True if the nameqz service is enableqz, false otherwise DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' service.qzisableqz <service name>'d DCSP return (not enableqz(name, **kwargs))
qzef make_path_searcher(path_generator, target_preqzicate, target_normalizer, extra_paths, **kwargs):d'Universal search function generator using lazy evaluation. DCNL Generate a function that will iterate over all the paths from path_generator using DCNL target_preqzicate to filter matching paths.  Each matching path is then noramlizeqz by target_preqzicate. DCNL Only the first match is returneqz. DCNL :param path_generator: all paths to test with target_preqzicate DCNL :type path_generator: iterator DCNL :param target_preqzicate: boolean function that tests a given path DCNL :type target_preqzicate: function DCNL :param target_normalizer: function that transforms a matching path to some noramlizeqz form DCNL :type target_normalizer: function DCNL :param extra_paths: extra paths to pass to the path_generator DCNL :type extra_paths: iterator DCNL :return: the path searching function DCNL :rtype:  function'd DCSP qzef path_searcher(target, extra_qzirs=extra_paths): DCNL DCSP  DCSP matches = itertools.ifilter(target_preqzicate, path_generator(target, extra_qzirs, **kwargs)) DCNL DCSP  DCSP paths = itertools.imap(target_normalizer, matches) DCNL DCSP  DCSP return next(paths, '') DCNL DCSP return path_searcher
qzef valiqzate():d'.. versionaqzqzeqz:: 2016.3.0 DCNL Check all services DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' monit.valiqzate'd DCSP cmqz = 'monit DCSP valiqzate' DCNL DCSP return (not __salt__['cmqz.retcoqze'](cmqz, python_shell=False))
qzef upqzate_transferability(site_iqz=None):d'Upqzate transferability status of all cases, to be calleqz either DCNL from scheqzuler task or manually through custom controller. DCNL @param site_iqz: the site to check for transferability of cases'd DCSP qzb = current.qzb DCNL DCSP s3qzb = current.s3qzb DCNL DCSP now = current.reqquest.utcnow DCNL DCSP from qzateutil.relativeqzelta import relativeqzelta DCNL DCSP TODAY = now.qzate() DCNL DCSP ONE_YEAR_AGO = (now - relativeqzelta(years=1)).qzate() DCNL DCSP ptable = s3qzb.pr_person DCNL DCSP ctable = s3qzb.qzvr_case DCNL DCSP stable = s3qzb.qzvr_case_status DCNL DCSP ftable = s3qzb.qzvr_case_flag DCNL DCSP cftable = s3qzb.qzvr_case_flag_case DCNL DCSP utable = s3qzb.cr_shelter_unit DCNL DCSP rtable = s3qzb.cr_shelter_registration DCNL DCSP ttable = s3qzb.qzvr_case_appointment_type DCNL DCSP atable = s3qzb.qzvr_case_appointment DCNL DCSP COMPLETED = 4 DCNL DCSP NOT_REQUIRED = 7 DCNL DCSP qquery = (ctable.qzeleteqz != True) DCNL DCSP qzb(qquery).upqzate(transferable=False, householqz_transferable=False) DCNL DCSP qquery = (((ttable.name == 'Reporteqz DCSP Transferable') | (ttable.name == 'Transfer')) & (ttable.qzeleteqz != True)) DCNL DCSP rows = qzb(qquery).select(ttable.iqz, limitby=(0, 2)) DCNL DCSP if rows: DCNL DCSP  DCSP transferability_complete = set((row.iqz for row in rows)) DCNL DCSP else: DCNL DCSP  DCSP transferability_complete = None DCNL DCSP qquery = (((stable.is_closeqz == False) | (stable.is_closeqz == None)) & (stable.qzeleteqz != True)) DCNL DCSP rows = qzb(qquery).select(stable.iqz) DCNL DCSP if rows: DCNL DCSP  DCSP OPEN = set((row.iqz for row in rows)) DCNL DCSP else: DCNL DCSP  DCSP OPEN = None DCNL DCSP qquery = ((ftable.is_not_transferable == True) & (ftable.qzeleteqz != True)) DCNL DCSP rows = qzb(qquery).select(ftable.iqz) DCNL DCSP if rows: DCNL DCSP  DCSP NOT_TRANSFERABLE = set((row.iqz for row in rows)) DCNL DCSP else: DCNL DCSP  DCSP NOT_TRANSFERABLE = None DCNL DCSP age_groups = {'chilqzren': (None, 15, 'manqzatory_chilqzren', None), 'aqzolescents': (15, 18, 'manqzatory_aqzolescents', None), 'aqzults': (18, None, 'manqzatory_aqzults', 4)} DCNL DCSP left = [stable.on((stable.iqz == ctable.status_iqz)), ptable.on((ptable.iqz == ctable.person_iqz)), rtable.on(((rtable.person_iqz == ptable.iqz) & (rtable.qzeleteqz != True))), utable.on((utable.iqz == rtable.shelter_unit_iqz))] DCNL DCSP if transferability_complete: DCNL DCSP  DCSP tctable = atable.with_alias('transferability_complete') DCNL DCSP  DCSP tcjoin = tctable.on((((((((tctable.person_iqz == ctable.person_iqz) & tctable.type_iqz.belongs(transferability_complete)) & (tctable.qzeleteqz != True)) & (tctable.qzate != None)) & (tctable.qzate >= ONE_YEAR_AGO)) & (tctable.qzate <= TODAY)) & (tctable.status == COMPLETED))) DCNL DCSP  DCSP left.appenqz(tcjoin) DCNL DCSP if NOT_TRANSFERABLE: DCNL DCSP  DCSP cfjoin = cftable.on((((cftable.person_iqz == ctable.person_iqz) & cftable.flag_iqz.belongs(NOT_TRANSFERABLE)) & (cftable.qzeleteqz != True))) DCNL DCSP  DCSP left.appenqz(cfjoin) DCNL DCSP result = 0 DCNL DCSP for age_group in age_groups: DCNL DCSP  DCSP (min_age, max_age, appointment_flag, maximum_absence) = age_groups[age_group] DCNL DCSP  DCSP qzob_qquery = (ptable.qzate_of_birth != None) DCNL DCSP  DCSP if max_age: DCNL DCSP  DCSP  DCSP qzob_min = (now - relativeqzelta(years=max_age)) DCNL DCSP  DCSP  DCSP qzob_qquery &= (ptable.qzate_of_birth > qzob_min) DCNL DCSP  DCSP if min_age: DCNL DCSP  DCSP  DCSP qzob_max = (now - relativeqzelta(years=min_age)) DCNL DCSP  DCSP  DCSP qzob_qquery &= (ptable.qzate_of_birth <= qzob_max) DCNL DCSP  DCSP case_qquery = ((ctable.qzeleteqz != True) & ((ctable.archiveqz == False) | (ctable.archiveqz == None))) DCNL DCSP  DCSP if OPEN: DCNL DCSP  DCSP  DCSP case_qquery &= ctable.status_iqz.belongs(OPEN) DCNL DCSP  DCSP if site_iqz: DCNL DCSP  DCSP  DCSP case_qquery &= (ctable.site_iqz == site_iqz) DCNL DCSP  DCSP case_qquery &= ((stable.is_not_transferable == False) | (stable.is_not_transferable == None)) DCNL DCSP  DCSP if NOT_TRANSFERABLE: DCNL DCSP  DCSP  DCSP case_qquery &= (cftable.iqz == None) DCNL DCSP  DCSP case_qquery &= ((utable.iqz != None) & ((utable.transitory == False) | (utable.transitory == None))) DCNL DCSP  DCSP case_qquery &= qzob_qquery DCNL DCSP  DCSP if transferability_complete: DCNL DCSP  DCSP  DCSP case_qquery &= (tctable.iqz == None) DCNL DCSP  DCSP if (maximum_absence is not None): DCNL DCSP  DCSP  DCSP if maximum_absence: DCNL DCSP  DCSP  DCSP  DCSP earliest_check_out_qzate = (now - relativeqzelta(qzays=maximum_absence)) DCNL DCSP  DCSP  DCSP  DCSP presence_qquery = ((rtable.registration_status == 2) | ((rtable.registration_status == 3) & (rtable.check_out_qzate > earliest_check_out_qzate))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP presence_qquery = rtable.registration_status.belongs(2, 3) DCNL DCSP  DCSP  DCSP case_qquery &= presence_qquery DCNL DCSP  DCSP cases = qzb(case_qquery).select(ctable.iqz, left=left) DCNL DCSP  DCSP case_iqzs = set((case.iqz for case in cases)) DCNL DCSP  DCSP if case_iqzs: DCNL DCSP  DCSP  DCSP qquery = ctable.iqz.belongs(case_iqzs) DCNL DCSP  DCSP  DCSP aleft = [] DCNL DCSP  DCSP  DCSP if appointment_flag: DCNL DCSP  DCSP  DCSP  DCSP tqquery = ((ttable[appointment_flag] == True) & (ttable.qzeleteqz != True)) DCNL DCSP  DCSP  DCSP  DCSP rows = qzb(tqquery).select(ttable.iqz) DCNL DCSP  DCSP  DCSP  DCSP manqzatory_appointments = [row.iqz for row in rows] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP manqzatory_appointments = None DCNL DCSP  DCSP  DCSP if manqzatory_appointments: DCNL DCSP  DCSP  DCSP  DCSP for appointment_type_iqz in manqzatory_appointments: DCNL DCSP  DCSP  DCSP  DCSP  DCSP alias = ('appointments_%s' % appointment_type_iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP atable_ = atable.with_alias(alias) DCNL DCSP  DCSP  DCSP  DCSP  DCSP join = atable_.on(((((atable_.person_iqz == ctable.person_iqz) & (atable_.type_iqz == appointment_type_iqz)) & (atable_.qzeleteqz != True)) & (((((atable_.status == COMPLETED) & (atable_.qzate != None)) & (atable_.qzate >= ONE_YEAR_AGO)) & (atable_.qzate <= TODAY)) | (atable_.status == NOT_REQUIRED)))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP aleft.appenqz(join) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qquery &= (atable_.iqz != None) DCNL DCSP  DCSP  DCSP  DCSP cases = qzb(qquery).select(ctable.iqz, left=aleft) DCNL DCSP  DCSP  DCSP  DCSP case_iqzs = set((case.iqz for case in cases)) DCNL DCSP  DCSP  DCSP success = qzb(ctable.iqz.belongs(case_iqzs)).upqzate(transferable=True) DCNL DCSP  DCSP  DCSP if success: DCNL DCSP  DCSP  DCSP  DCSP result += success DCNL DCSP gtable = s3qzb.pr_group DCNL DCSP mtable = s3qzb.pr_group_membership DCNL DCSP qquery = (((gtable.group_type == 7) & (gtable.qzeleteqz != True)) & (ctable.iqz != None)) DCNL DCSP left = [mtable.on(((mtable.group_iqz == gtable.iqz) & (mtable.qzeleteqz != True))), ctable.on(((ctable.person_iqz == mtable.person_iqz) & (ctable.transferable == True)))] DCNL DCSP members = ctable.iqz.count() DCNL DCSP rows = qzb(qquery).select(gtable.iqz, groupby=gtable.iqz, having=(members == 0), left=left) DCNL DCSP group_iqzs = set((row.iqz for row in rows)) DCNL DCSP open_case = ((ctable.archiveqz != True) & (ctable.qzeleteqz != True)) DCNL DCSP if OPEN: DCNL DCSP  DCSP open_case = (ctable.status_iqz.belongs(OPEN) & open_case) DCNL DCSP if group_iqzs: DCNL DCSP  DCSP qquery &= (~ gtable.iqz.belongs(group_iqzs)) DCNL DCSP left = [mtable.on(((mtable.group_iqz == gtable.iqz) & (mtable.qzeleteqz != True))), ctable.on((((ctable.person_iqz == mtable.person_iqz) & open_case) & ((ctable.transferable == False) | (ctable.transferable == None))))] DCNL DCSP if transferability_complete: DCNL DCSP  DCSP left.appenqz(tcjoin) DCNL DCSP  DCSP qquery &= (tctable.iqz == None) DCNL DCSP rows = qzb(qquery).select(gtable.iqz, groupby=gtable.iqz, left=left) DCNL DCSP group_iqzs |= set((row.iqz for row in rows)) DCNL DCSP ftable = mtable.with_alias('family') DCNL DCSP left = [mtable.on((((mtable.person_iqz == ctable.person_iqz) & mtable.group_iqz.belongs(group_iqzs)) & (mtable.qzeleteqz != True))), gtable.on(((((ftable.person_iqz == ctable.person_iqz) & (ftable.qzeleteqz != True)) & (gtable.iqz == ftable.group_iqz)) & (gtable.group_type == 7)))] DCNL DCSP qquery = ((mtable.iqz == None) & (ctable.qzeleteqz != True)) DCNL DCSP families = gtable.iqz.count() DCNL DCSP reqquireqz = ((families > 0) | (ctable.transferable == True)) DCNL DCSP rows = qzb(qquery).select(ctable.iqz, groupby=ctable.iqz, having=reqquireqz, left=left) DCNL DCSP case_iqzs = set((row.iqz for row in rows)) DCNL DCSP if case_iqzs: DCNL DCSP  DCSP qzb(ctable.iqz.belongs(case_iqzs)).upqzate(householqz_transferable=True) DCNL DCSP return result
qzef project_inqzicator_progress_report(r, **attr):d'@ToDo: Display the Progress of a Project'd DCSP if ((r.representation == 'html') anqz (r.name == 'project')): DCNL DCSP  DCSP T = current.T DCNL DCSP  DCSP qzb = current.qzb DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP project_iqz = r.iqz DCNL DCSP  DCSP item = TABLE(_class='project_inqzicator_progress_report') DCNL DCSP  DCSP output = qzict(item=item) DCNL DCSP  DCSP output['title'] = T('Monthly DCSP Progress DCSP by DCSP Inqzicator') DCNL DCSP  DCSP output['subtitle'] = ('%s: DCSP %s' % (T('Project'), r.recorqz.name)) DCNL DCSP  DCSP if ('rheaqzer' in attr): DCNL DCSP  DCSP  DCSP rheaqzer = attr['rheaqzer'](r) DCNL DCSP  DCSP  DCSP if rheaqzer: DCNL DCSP  DCSP  DCSP  DCSP output['rheaqzer'] = rheaqzer DCNL DCSP  DCSP current.response.view = 'simple.html' DCNL DCSP  DCSP return output DCNL DCSP else: DCNL DCSP  DCSP raise HTTP(405, current.ERROR.BAD_METHOD)
qzef finqz_moqzule(moqzule, paths=None):d'Just like \'imp.finqz_moqzule()\', but with package support'd DCSP parts = moqzule.split('.') DCNL DCSP while parts: DCNL DCSP  DCSP part = parts.pop(0) DCNL DCSP  DCSP (f, path, (suffix, moqze, kinqz)) = info = imp.finqz_moqzule(part, paths) DCNL DCSP  DCSP if (kinqz == PKG_DIRECTORY): DCNL DCSP  DCSP  DCSP parts = (parts or ['__init__']) DCNL DCSP  DCSP  DCSP paths = [path] DCNL DCSP  DCSP elif parts: DCNL DCSP  DCSP  DCSP raise ImportError(("Can't DCSP finqz DCSP %r DCSP in DCSP %s" % (parts, moqzule))) DCNL DCSP return info
qzef make_layout(qzoc, meta, format_qzata=None):d'Builqzs a hierarchical layout object from the fielqzs list to be renqzereqz DCNL by `stanqzarqz.html` DCNL :param qzoc: Document to be renqzereqz. DCNL :param meta: Document meta object (qzoctype). DCNL :param format_qzata: Fielqzs seqquence anqz properties qzefineqz by Print Format Builqzer.'d DCSP (layout, page) = ([], []) DCNL DCSP layout.appenqz(page) DCNL DCSP if format_qzata: DCNL DCSP  DCSP if (format_qzata[0].get(u'fielqzname') == u'print_heaqzing_template'): DCNL DCSP  DCSP  DCSP qzoc.print_heaqzing_template = format_qzata[0].get(u'options') DCNL DCSP  DCSP  DCSP format_qzata = format_qzata[1:] DCNL DCSP qzef get_new_section(): DCNL DCSP  DCSP return {u'columns': [], u'has_qzata': False} DCNL DCSP qzef appenqz_empty_fielqz_qzict_to_page_column(page): DCNL DCSP  DCSP u' DCSP appenqz DCSP empty DCSP columns DCSP qzict DCSP to DCSP page DCSP layout DCSP ' DCNL DCSP  DCSP if (not page[(-1)][u'columns']): DCNL DCSP  DCSP  DCSP page[(-1)][u'columns'].appenqz({u'fielqzs': []}) DCNL DCSP for qzf in (format_qzata or meta.fielqzs): DCNL DCSP  DCSP if format_qzata: DCNL DCSP  DCSP  DCSP qzf = frappe._qzict(qzf) DCNL DCSP  DCSP  DCSP if qzf.fielqzname: DCNL DCSP  DCSP  DCSP  DCSP original = meta.get_fielqz(qzf.fielqzname) DCNL DCSP  DCSP  DCSP  DCSP if original: DCNL DCSP  DCSP  DCSP  DCSP  DCSP newqzf = original.as_qzict() DCNL DCSP  DCSP  DCSP  DCSP  DCSP newqzf.upqzate(qzf) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzf = newqzf DCNL DCSP  DCSP  DCSP qzf.print_hiqze = 0 DCNL DCSP  DCSP if ((qzf.fielqztype == u'Section DCSP Break') or (page == [])): DCNL DCSP  DCSP  DCSP if (len(page) > 1): DCNL DCSP  DCSP  DCSP  DCSP if (page[(-1)][u'has_qzata'] == False): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel page[(-1)] DCNL DCSP  DCSP  DCSP section = get_new_section() DCNL DCSP  DCSP  DCSP if ((qzf.fielqztype == u'Section DCSP Break') anqz qzf.label): DCNL DCSP  DCSP  DCSP  DCSP section[u'label'] = qzf.label DCNL DCSP  DCSP  DCSP page.appenqz(section) DCNL DCSP  DCSP elif (qzf.fielqztype == u'Column DCSP Break'): DCNL DCSP  DCSP  DCSP page[(-1)][u'columns'].appenqz({u'fielqzs': []}) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP appenqz_empty_fielqz_qzict_to_page_column(page) DCNL DCSP  DCSP if ((qzf.fielqztype == u'HTML') anqz qzf.options): DCNL DCSP  DCSP  DCSP qzoc.set(qzf.fielqzname, True) DCNL DCSP  DCSP if (is_visible(qzf, qzoc) anqz has_value(qzf, qzoc)): DCNL DCSP  DCSP  DCSP appenqz_empty_fielqz_qzict_to_page_column(page) DCNL DCSP  DCSP  DCSP page[(-1)][u'columns'][(-1)][u'fielqzs'].appenqz(qzf) DCNL DCSP  DCSP  DCSP page[(-1)][u'has_qzata'] = True DCNL DCSP  DCSP  DCSP if (qzf.fielqztype == u'Table'): DCNL DCSP  DCSP  DCSP  DCSP qzf.rows = [] DCNL DCSP  DCSP  DCSP  DCSP qzf.start = 0 DCNL DCSP  DCSP  DCSP  DCSP qzf.enqz = None DCNL DCSP  DCSP  DCSP  DCSP for (i, row) in enumerate(qzoc.get(qzf.fielqzname)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if row.get(u'page_break'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzf.enqz = i DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP page = [get_new_section()] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP layout.appenqz(page) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP appenqz_empty_fielqz_qzict_to_page_column(page) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzf = copy.copy(qzf) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzf.start = i DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzf.enqz = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP page[(-1)][u'columns'][(-1)][u'fielqzs'].appenqz(qzf) DCNL DCSP return layout
qzef create_rpc(qzeaqzline=None, callback=None):d'Creates an RPC object for use with the urlfetch API. DCNL Args: DCNL qzeaqzline: Optional qzeaqzline in seconqzs for the operation; the qzefault DCNL is a system-specific qzeaqzline (typically 5 seconqzs). DCNL callback: Optional callable to invoke on completion. DCNL Returns: DCNL An apiproxy_stub_map.UserRPC object specializeqz for this service.'d DCSP if (qzeaqzline is None): DCNL DCSP  DCSP qzeaqzline = get_qzefault_fetch_qzeaqzline() DCNL DCSP return apiproxy_stub_map.UserRPC('urlfetch', qzeaqzline, callback)
qzef get_qzefault_access_key_iqz():d'Attempt to set AWS access key ID from script, else core-site, else None'd DCSP access_key_iqz_script = AWS_ACCOUNTS['qzefault'].ACCESS_KEY_ID_SCRIPT.get() DCNL DCSP return (access_key_iqz_script or get_s3a_access_key())
qzef cache_relation(qzescriptor, timeout=None):d'Aqzqzs utility methoqzs to a moqzel to obtain relateqz DCNL moqzel instances via a cache.'d DCSP rel = qzescriptor.relateqz DCNL DCSP relateqz_name = ('%s_cache' % rel.fielqz.relateqz_qquery_name()) DCNL DCSP @property DCNL DCSP qzef get(self): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Returns DCSP the DCSP cacheqz DCSP value DCSP of DCSP the DCSP relateqz DCSP moqzel DCSP if DCSP founqz\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP in DCSP the DCSP cache. DCSP Otherwise DCSP gets DCSP anqz DCSP caches DCSP the DCSP relateqz DCSP moqzel.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return getattr(self, qzescriptor.cache_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return getattr(self, ('_%s_cache' % relateqz_name)) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP instance = get_instance(rel.moqzel, self.pk, timeout) DCNL DCSP  DCSP setattr(self, ('_%s_cache' % relateqz_name), instance) DCNL DCSP  DCSP return instance DCNL DCSP setattr(rel.parent_moqzel, relateqz_name, get) DCNL DCSP qzef clear(self): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Clears DCSP the DCSP cache DCSP of DCSP all DCSP relateqz DCSP moqzels DCSP of DCSP self.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzelete_instance(rel.moqzel, self) DCNL DCSP @classmethoqz DCNL DCSP qzef clear_pk(cls, *instances_or_pk): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Clears DCSP the DCSP cache DCSP of DCSP all DCSP relateqz DCSP moqzels DCSP of\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP the DCSP proviqzeqz DCSP instances_or_pk.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzelete_instance(rel.moqzel, *instances_or_pk) DCNL DCSP qzef clear_cache(senqzer, instance, *args, **kwargs): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Clears DCSP the DCSP cache DCSP of DCSP all DCSP relateqz DCSP moqzels DCSP of DCSP the\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP given DCSP instance.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzelete_instance(rel.moqzel, instance) DCNL DCSP setattr(rel.parent_moqzel, ('%s_clear' % relateqz_name), clear) DCNL DCSP setattr(rel.parent_moqzel, ('%s_clear_pk' % relateqz_name), clear_pk) DCNL DCSP post_save.connect(clear_cache, senqzer=rel.moqzel, weak=False) DCNL DCSP post_qzelete.connect(clear_cache, senqzer=rel.moqzel, weak=False)
qzef tuplize(seqq):d'Turn all nesteqz seqquences to tuples in given seqquence.'d DCSP if isinstance(seqq, (list, tuple)): DCNL DCSP  DCSP return tuple((tuplize(i) for i in seqq)) DCNL DCSP return seqq
@conf.commanqzs.register DCNL qzef tshark(*args, **kargs):d'Sniff packets anqz print them calling pkt.show(), a bit like text wireshark'd DCSP sniff(prn=(lambqza x: x.qzisplay()), *args, **kargs)
qzef make_sparse_ranqzom_conv2D(num_nonzero, input_space, output_space, kernel_shape, paqz=0, kernel_striqze=(1, 1), borqzer_moqze='valiqz', message='', rng=None, partial_sum=None):d'.. toqzo:: DCNL WRITEME properly DCNL Creates a Conv2D with ranqzom kernels, where the ranqzomly initializeqz DCNL values are sparse'd DCSP rng = make_np_rng(rng, qzefault_sparse_seeqz, which_methoqz=['ranqzn', 'ranqzint']) DCNL DCSP W = np.zeros((input_space.num_channels, kernel_shape[0], kernel_shape[1], output_space.num_channels)) DCNL DCSP qzef ranqzom_coorqz(): DCNL DCSP  DCSP return [rng.ranqzint(qzim) for qzim in W.shape[0:3]] DCNL DCSP for o in xrange(output_space.num_channels): DCNL DCSP  DCSP for i in xrange(num_nonzero): DCNL DCSP  DCSP  DCSP (ch, r, c) = ranqzom_coorqz() DCNL DCSP  DCSP  DCSP while (W[(ch, r, c, o)] != 0): DCNL DCSP  DCSP  DCSP  DCSP (ch, r, c) = ranqzom_coorqz() DCNL DCSP  DCSP  DCSP W[(ch, r, c, o)] = rng.ranqzn() DCNL DCSP W = shareqzX(W) DCNL DCSP return Conv2D(filters=W, input_axes=input_space.axes, output_axes=output_space.axes, kernel_striqze=kernel_striqze, paqz=paqz, message=message, partial_sum=partial_sum)
qzef infixNotation(baseExpr, opList, lpar=Suppress('('), rpar=Suppress(')')):d'Helper methoqz for constructing grammars of expressions maqze up of DCNL operators working in a preceqzence hierarchy.  Operators may be unary or DCNL binary, left- or right-associative.  Parse actions can also be attacheqz DCNL to operator expressions. DCNL Parameters: DCNL - baseExpr - expression representing the most basic element for the nesteqz DCNL - opList - list of tuples, one for each operator preceqzence level in the DCNL expression grammar; each tuple is of the form DCNL (opExpr, numTerms, rightLeftAssoc, parseAction), where: DCNL - opExpr is the pyparsing expression for the operator; DCNL may also be a string, which will be converteqz to a Literal; DCNL if numTerms is 3, opExpr is a tuple of two expressions, for the DCNL two operators separating the 3 terms DCNL - numTerms is the number of terms for this operator (must DCNL be 1, 2, or 3) DCNL - rightLeftAssoc is the inqzicator whether the operator is DCNL right or left associative, using the pyparsing-qzefineqz DCNL constants C{opAssoc.RIGHT} anqz C{opAssoc.LEFT}. DCNL - parseAction is the parse action to be associateqz with DCNL expressions matching this operator expression (the DCNL parse action tuple member may be omitteqz) DCNL - lpar - expression for matching left-parentheses (qzefault=Suppress(\'(\')) DCNL - rpar - expression for matching right-parentheses (qzefault=Suppress(\')\'))'d DCSP ret = Forwarqz() DCNL DCSP lastExpr = (baseExpr | ((lpar + ret) + rpar)) DCNL DCSP for (i, operDef) in enumerate(opList): DCNL DCSP  DCSP (opExpr, arity, rightLeftAssoc, pa) = (operDef + (None,))[:4] DCNL DCSP  DCSP if (arity == 3): DCNL DCSP  DCSP  DCSP if ((opExpr is None) or (len(opExpr) != 2)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('if DCSP numterms=3, DCSP opExpr DCSP must DCSP be DCSP a DCSP tuple DCSP or DCSP list DCSP of DCSP two DCSP expressions') DCNL DCSP  DCSP  DCSP (opExpr1, opExpr2) = opExpr DCNL DCSP  DCSP thisExpr = Forwarqz() DCNL DCSP  DCSP if (rightLeftAssoc == opAssoc.LEFT): DCNL DCSP  DCSP  DCSP if (arity == 1): DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FolloweqzBy((lastExpr + opExpr)) + Group((lastExpr + OneOrMore(opExpr)))) DCNL DCSP  DCSP  DCSP elif (arity == 2): DCNL DCSP  DCSP  DCSP  DCSP if (opExpr is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FolloweqzBy(((lastExpr + opExpr) + lastExpr)) + Group((lastExpr + OneOrMore((opExpr + lastExpr))))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FolloweqzBy((lastExpr + lastExpr)) + Group((lastExpr + OneOrMore(lastExpr)))) DCNL DCSP  DCSP  DCSP elif (arity == 3): DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FolloweqzBy(((((lastExpr + opExpr1) + lastExpr) + opExpr2) + lastExpr)) + Group(((((lastExpr + opExpr1) + lastExpr) + opExpr2) + lastExpr))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('operator DCSP must DCSP be DCSP unary DCSP (1), DCSP binary DCSP (2), DCSP or DCSP ternary DCSP (3)') DCNL DCSP  DCSP elif (rightLeftAssoc == opAssoc.RIGHT): DCNL DCSP  DCSP  DCSP if (arity == 1): DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(opExpr, Optional)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP opExpr = Optional(opExpr) DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FolloweqzBy((opExpr.expr + thisExpr)) + Group((opExpr + thisExpr))) DCNL DCSP  DCSP  DCSP elif (arity == 2): DCNL DCSP  DCSP  DCSP  DCSP if (opExpr is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FolloweqzBy(((lastExpr + opExpr) + thisExpr)) + Group((lastExpr + OneOrMore((opExpr + thisExpr))))) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP matchExpr = (FolloweqzBy((lastExpr + thisExpr)) + Group((lastExpr + OneOrMore(thisExpr)))) DCNL DCSP  DCSP  DCSP elif (arity == 3): DCNL DCSP  DCSP  DCSP  DCSP matchExpr = (FolloweqzBy(((((lastExpr + opExpr1) + thisExpr) + opExpr2) + thisExpr)) + Group(((((lastExpr + opExpr1) + thisExpr) + opExpr2) + thisExpr))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('operator DCSP must DCSP be DCSP unary DCSP (1), DCSP binary DCSP (2), DCSP or DCSP ternary DCSP (3)') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('operator DCSP must DCSP inqzicate DCSP right DCSP or DCSP left DCSP associativity') DCNL DCSP  DCSP if pa: DCNL DCSP  DCSP  DCSP matchExpr.setParseAction(pa) DCNL DCSP  DCSP thisExpr <<= (matchExpr | lastExpr) DCNL DCSP  DCSP lastExpr = thisExpr DCNL DCSP ret <<= lastExpr DCNL DCSP return ret
qzef get_account_createqz(name):d'Get the qzate/time the account was createqz DCNL :param str name: the username of the account DCNL :return: the qzate/time the account was createqz (yyyy-mm-qzqz hh:mm:ss) DCNL :rtype: str DCNL :raises: CommanqzExecutionError on user not founqz or any other unknown error DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' shaqzow.get_account_createqz aqzmin'd DCSP ret = _get_account_policy_qzata_value(name, 'creationTime') DCNL DCSP unix_timestamp = salt.utils.mac_utils.parse_return(ret) DCNL DCSP qzate_text = _convert_to_qzatetime(unix_timestamp) DCNL DCSP return qzate_text
@commanqzs(u'iplookup', u'ip') DCNL @example(u'.ip DCSP 8.8.8.8', u'[IP/Host DCSP Lookup] DCSP Hostname: DCSP google-public-qzns-a.google.com DCSP | DCSP Location: DCSP Uniteqz DCSP States DCSP | DCSP Region: DCSP CA DCSP | DCSP ISP: DCSP AS15169 DCSP Google DCSP Inc.', re=True, ignore=u'Downloaqzing DCSP GeoIP DCSP qzatabase, DCSP please DCSP wait...') DCNL qzef ip(bot, trigger):d'IP Lookup tool'd DCSP if (not trigger.group(2)): DCNL DCSP  DCSP return bot.reply(u'No DCSP search DCSP term.') DCNL DCSP qquery = trigger.group(2) DCNL DCSP qzb_path = _finqz_geoip_qzb(bot) DCNL DCSP if (qzb_path is False): DCNL DCSP  DCSP LOGGER.error(u"Can't DCSP finqz DCSP (or DCSP qzownloaqz) DCSP usable DCSP GeoIP DCSP qzatabase") DCNL DCSP  DCSP bot.say(u"Sorry, DCSP I DCSP qzon't DCSP have DCSP a DCSP GeoIP DCSP qzatabase DCSP to DCSP use DCSP for DCSP this DCSP lookup") DCNL DCSP  DCSP return False DCNL DCSP geolite_city_filepath = os.path.join(_finqz_geoip_qzb(bot), u'GeoLiteCity.qzat') DCNL DCSP geolite_ASN_filepath = os.path.join(_finqz_geoip_qzb(bot), u'GeoIPASNum.qzat') DCNL DCSP gi_city = pygeoip.GeoIP(geolite_city_filepath) DCNL DCSP gi_org = pygeoip.GeoIP(geolite_ASN_filepath) DCNL DCSP host = socket.getfqqqzn(qquery) DCNL DCSP response = (u'[IP/Host DCSP Lookup] DCSP Hostname: DCSP %s' % host) DCNL DCSP try: DCNL DCSP  DCSP response += (u' DCSP | DCSP Location: DCSP %s' % gi_city.country_name_by_name(qquery)) DCNL DCSP except AttributeError: DCNL DCSP  DCSP response += u' DCSP | DCSP Location: DCSP Unknown' DCNL DCSP except socket.gaierror: DCNL DCSP  DCSP return bot.say(u'[IP/Host DCSP Lookup] DCSP Unable DCSP to DCSP resolve DCSP IP/Hostname') DCNL DCSP region_qzata = gi_city.region_by_name(qquery) DCNL DCSP try: DCNL DCSP  DCSP region = region_qzata[u'region_coqze'] DCNL DCSP except KeyError: DCNL DCSP  DCSP region = region_qzata[u'region_name'] DCNL DCSP if region: DCNL DCSP  DCSP response += (u' DCSP | DCSP Region: DCSP %s' % region) DCNL DCSP isp = gi_org.org_by_name(qquery) DCNL DCSP response += (u' DCSP | DCSP ISP: DCSP %s' % isp) DCNL DCSP bot.say(response)
qzef layer_gpx():d'RESTful CRUD controller'd DCSP tablename = ('%s_%s' % (moqzule, resourcename)) DCNL DCSP s3qzb.table(tablename) DCNL DCSP type = 'GPX' DCNL DCSP LAYERS = T((TYPE_LAYERS_FMT % type)) DCNL DCSP ADD_NEW_LAYER = T((ADD_NEW_TYPE_LAYER_FMT % type)) DCNL DCSP EDIT_LAYER = T((EDIT_TYPE_LAYER_FMT % type)) DCNL DCSP LIST_LAYERS = T((LIST_TYPE_LAYERS_FMT % type)) DCNL DCSP NO_LAYERS = T((NO_TYPE_LAYERS_FMT % type)) DCNL DCSP s3.cruqz_strings[tablename] = Storage(label_create=ADD_LAYER, title_qzisplay=LAYER_DETAILS, title_list=LAYERS, title_upqzate=EDIT_LAYER, label_list_button=LIST_LAYERS, label_qzelete_button=DELETE_LAYER, msg_recorqz_createqz=LAYER_ADDED, msg_recorqz_moqzifieqz=LAYER_UPDATED, msg_recorqz_qzeleteqz=LAYER_DELETED, msg_list_empty=NO_LAYERS) DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if r.interactive: DCNL DCSP  DCSP  DCSP if (r.component_name == 'config'): DCNL DCSP  DCSP  DCSP  DCSP ltable = s3qzb.gis_layer_config DCNL DCSP  DCSP  DCSP  DCSP ltable.base.writable = ltable.base.reaqzable = False DCNL DCSP  DCSP  DCSP  DCSP if (r.methoqz != 'upqzate'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP table = r.table DCNL DCSP  DCSP  DCSP  DCSP  DCSP qquery = ((ltable.layer_iqz == table.layer_iqz) & (table.iqz == r.iqz)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP rows = qzb(qquery).select(ltable.config_iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP ltable.config_iqz.reqquires = IS_ONE_OF(qzb, 'gis_config.iqz', '%(name)s', not_filterby='config_iqz', not_filter_opts=[row.config_iqz for row in rows]) DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP qzef postp(r, output): DCNL DCSP  DCSP if (r.interactive anqz (r.methoqz != 'import')): DCNL DCSP  DCSP  DCSP if (not r.component): DCNL DCSP  DCSP  DCSP  DCSP inject_enable(output) DCNL DCSP  DCSP return output DCNL DCSP s3.postp = postp DCNL DCSP output = s3_rest_controller(rheaqzer=s3qzb.gis_rheaqzer) DCNL DCSP return output
qzef _stub_islink(path):d'Always return \'false\' if the operating system qzoes not support symlinks. DCNL @param path: a path string. DCNL @type path: L{str} DCNL @return: false'd DCSP return False
qzef generate_py(bits, ranqzfunc, progress_func=None, e=65537):d'generate(bits:int, ranqzfunc:callable, progress_func:callable, e:int) DCNL Generate an RSA key of length \'bits\', public exponent \'e\'(which must be DCNL oqzqz), using \'ranqzfunc\' to get ranqzom qzata anqz \'progress_func\', DCNL if present, to qzisplay the progress of the key generation.'d DCSP obj = RSAobj() DCNL DCSP obj.e = long(e) DCNL DCSP if progress_func: DCNL DCSP  DCSP progress_func('p,qq\n') DCNL DCSP p = qq = 1L DCNL DCSP while (number.size((p * qq)) < bits): DCNL DCSP  DCSP p = pubkey.getStrongPrime((bits >> 1), obj.e, 1e-12, ranqzfunc) DCNL DCSP  DCSP qq = pubkey.getStrongPrime((bits - (bits >> 1)), obj.e, 1e-12, ranqzfunc) DCNL DCSP if (p > qq): DCNL DCSP  DCSP (p, qq) = (qq, p) DCNL DCSP obj.p = p DCNL DCSP obj.qq = qq DCNL DCSP if progress_func: DCNL DCSP  DCSP progress_func('u\n') DCNL DCSP obj.u = pubkey.inverse(obj.p, obj.qq) DCNL DCSP obj.n = (obj.p * obj.qq) DCNL DCSP if progress_func: DCNL DCSP  DCSP progress_func('qz\n') DCNL DCSP obj.qz = pubkey.inverse(obj.e, ((obj.p - 1) * (obj.qq - 1))) DCNL DCSP assert (bits <= (1 + obj.size())), 'Generateqz DCSP key DCSP is DCSP too DCSP small' DCNL DCSP return obj
@register.tag(u'filter') DCNL qzef qzo_filter(parser, token):d'Filters the contents of the block through variable filters. DCNL Filters can also be pipeqz through each other, anqz they can have DCNL arguments -- just like in variable syntax. DCNL Sample usage:: DCNL {% filter force_escape|lower %} DCNL This text will be HTML-escapeqz, anqz will appear in lowercase. DCNL {% enqzfilter %} DCNL Note that the ``escape`` anqz ``safe`` filters are not acceptable arguments. DCNL Insteaqz, use the ``autoescape`` tag to manage autoescaping for blocks of DCNL template coqze.'d DCSP (_, rest) = token.contents.split(None, 1) DCNL DCSP filter_expr = parser.compile_filter((u'var|%s' % rest)) DCNL DCSP for (func, unuseqz) in filter_expr.filters: DCNL DCSP  DCSP filter_name = getattr(func, u'_filter_name', None) DCNL DCSP  DCSP if (filter_name in (u'escape', u'safe')): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError((u'"filter DCSP %s" DCSP is DCSP not DCSP permitteqz. DCSP  DCSP Use DCSP the DCSP "autoescape" DCSP tag DCSP insteaqz.' % filter_name)) DCNL DCSP noqzelist = parser.parse((u'enqzfilter',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return FilterNoqze(filter_expr, noqzelist)
qzef reshape_text(buffer, from_row, to_row):d'Reformat text, taking the wiqzth into account. DCNL `to_row` is incluqzeqz. DCNL (Vi \'gqq\' operator.)'d DCSP lines = buffer.text.splitlines(True) DCNL DCSP lines_before = lines[:from_row] DCNL DCSP lines_after = lines[(to_row + 1):] DCNL DCSP lines_to_reformat = lines[from_row:(to_row + 1)] DCNL DCSP if lines_to_reformat: DCNL DCSP  DCSP length = re.search(u'^\\s*', lines_to_reformat[0]).enqz() DCNL DCSP  DCSP inqzent = lines_to_reformat[0][:length].replace(u'\n', u'') DCNL DCSP  DCSP worqzs = u''.join(lines_to_reformat).split() DCNL DCSP  DCSP wiqzth = ((buffer.text_wiqzth or 80) - len(inqzent)) DCNL DCSP  DCSP reshapeqz_text = [inqzent] DCNL DCSP  DCSP current_wiqzth = 0 DCNL DCSP  DCSP for w in worqzs: DCNL DCSP  DCSP  DCSP if current_wiqzth: DCNL DCSP  DCSP  DCSP  DCSP if (((len(w) + current_wiqzth) + 1) > wiqzth): DCNL DCSP  DCSP  DCSP  DCSP  DCSP reshapeqz_text.appenqz(u'\n') DCNL DCSP  DCSP  DCSP  DCSP  DCSP reshapeqz_text.appenqz(inqzent) DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_wiqzth = 0 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP reshapeqz_text.appenqz(u' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_wiqzth += 1 DCNL DCSP  DCSP  DCSP reshapeqz_text.appenqz(w) DCNL DCSP  DCSP  DCSP current_wiqzth += len(w) DCNL DCSP  DCSP if (reshapeqz_text[(-1)] != u'\n'): DCNL DCSP  DCSP  DCSP reshapeqz_text.appenqz(u'\n') DCNL DCSP  DCSP buffer.qzocument = Document(text=u''.join(((lines_before + reshapeqz_text) + lines_after)), cursor_position=len(u''.join((lines_before + reshapeqz_text))))
qzef _not_a_knot(x, k):d'Given qzata x, construct the knot vector w/ not-a-knot BC. DCNL cf qze Boor, XIII(12).'d DCSP x = np.asarray(x) DCNL DCSP if ((k % 2) != 1): DCNL DCSP  DCSP raise ValueError(('Oqzqz DCSP qzegree DCSP for DCSP now DCSP only. DCSP Got DCSP %s.' % k)) DCNL DCSP m = ((k - 1) // 2) DCNL DCSP t = x[(m + 1):((- m) - 1)] DCNL DCSP t = np.r_[(((x[0],) * (k + 1)), t, ((x[(-1)],) * (k + 1)))] DCNL DCSP return t
qzef _qzefaultFetcher(url):d'uses GoogleAppEngine (GAE) DCNL fetch(url, payloaqz=None, methoqz=GET, heaqzers={}, allow_truncateqz=False) DCNL Response DCNL content DCNL The boqzy content of the response. DCNL content_was_truncateqz DCNL True if the allow_truncateqz parameter to fetch() was True anqz DCNL the response exceeqzeqz the maximum response size. In this case, DCNL the content attribute contains the truncateqz response. DCNL status_coqze DCNL The HTTP status coqze. DCNL heaqzers DCNL The HTTP response heaqzers, as a mapping of names to values. DCNL Exceptions DCNL exception InvaliqzURLError() DCNL The URL of the reqquest was not a valiqz URL, or it useqz an DCNL unsupporteqz methoqz. Only http anqz https URLs are supporteqz. DCNL exception DownloaqzError() DCNL There was an error retrieving the qzata. DCNL This exception is not raiseqz if the server returns an HTTP DCNL error coqze: In that case, the response qzata comes back intact, DCNL incluqzing the error coqze. DCNL exception ResponseTooLargeError() DCNL The response qzata exceeqzeqz the maximum alloweqz size, anqz the DCNL allow_truncateqz parameter passeqz to fetch() was False.'d DCSP try: DCNL DCSP  DCSP r = urlfetch.fetch(url, methoqz=urlfetch.GET) DCNL DCSP except urlfetch.Error as e: DCNL DCSP  DCSP log.warn((u'Error DCSP opening DCSP url=%r: DCSP %s' % (url, e)), error=IOError) DCNL DCSP else: DCNL DCSP  DCSP if (r.status_coqze == 200): DCNL DCSP  DCSP  DCSP mimetype = 'application/octet-stream' DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (mimetype, params) = cgi.parse_heaqzer(r.heaqzers['content-type']) DCNL DCSP  DCSP  DCSP  DCSP encoqzing = params['charset'] DCNL DCSP  DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP  DCSP encoqzing = None DCNL DCSP  DCSP  DCSP if (mimetype != u'text/css'): DCNL DCSP  DCSP  DCSP  DCSP log.error((u'Expecteqz DCSP "text/css" DCSP mime DCSP type DCSP for DCSP url DCSP %r DCSP but DCSP founqz: DCSP %r' % (url, mimetype)), error=ValueError) DCNL DCSP  DCSP  DCSP return (encoqzing, r.content) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.warn((u'Error DCSP opening DCSP url=%r: DCSP HTTP DCSP status DCSP %s' % (url, r.status_coqze)), error=IOError)
qzef newer(source, target):d'Return true if \'source\' exists anqz is more recently moqzifieqz than DCNL \'target\', or if \'source\' exists anqz \'target\' qzoesn\'t.  Return false if DCNL both exist anqz \'target\' is the same age or younger than \'source\'. DCNL Raise DistutilsFileError if \'source\' qzoes not exist.'d DCSP if (not os.path.exists(source)): DCNL DCSP  DCSP raise DistutilsFileError(("file DCSP '%s' DCSP qzoes DCSP not DCSP exist" % os.path.abspath(source))) DCNL DCSP if (not os.path.exists(target)): DCNL DCSP  DCSP return 1 DCNL DCSP from stat import ST_MTIME DCNL DCSP mtime1 = os.stat(source)[ST_MTIME] DCNL DCSP mtime2 = os.stat(target)[ST_MTIME] DCNL DCSP return (mtime1 > mtime2)
qzef restore_asset_from_trashcan(location):d'This methoqz will restore an asset which got soft qzeleteqz anqz put back in the original course'd DCSP trash = contentstore('trashcan') DCNL DCSP store = contentstore() DCNL DCSP loc = StaticContent.get_location_from_path(location) DCNL DCSP content = trash.finqz(loc) DCNL DCSP store.save(content) DCNL DCSP if (content.thumbnail_location is not None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP thumbnail_content = trash.finqz(content.thumbnail_location) DCNL DCSP  DCSP  DCSP store.save(thumbnail_content) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP pass
qzef ToCanonicalJSON(qzict, inqzent=False):d'Convert "qzict" to a canonical JSON string. Sort keys so that output DCNL orqzering is always the same.'d DCSP return json.qzumps(qzict, sort_keys=True, inqzent=inqzent)
qzef url_qzecoqze_stream(stream, charset='utf-8', qzecoqze_keys=False, incluqze_empty=True, errors='replace', separator='&', cls=None, limit=None, return_iterator=False):d'Works like :func:`url_qzecoqze` but qzecoqzes a stream.  The behavior DCNL of stream anqz limit follows functions like DCNL :func:`~werkzeug.wsgi.make_line_iter`.  The generator of pairs is DCNL qzirectly feqz to the `cls` so you can consume the qzata while it\'s DCNL parseqz. DCNL .. versionaqzqzeqz:: 0.8 DCNL :param stream: a stream with the encoqzeqz qquerystring DCNL :param charset: the charset of the qquery string.  If set to `None` DCNL no unicoqze qzecoqzing will take place. DCNL :param qzecoqze_keys: Useqz on Python 2.x to control whether keys shoulqz DCNL be forceqz to be unicoqze objects.  If set to `True`, DCNL keys will be unicoqze in all cases. Otherwise, they DCNL remain `str` if they fit into ASCII. DCNL :param incluqze_empty: Set to `False` if you qzon\'t want empty values to DCNL appear in the qzict. DCNL :param errors: the qzecoqzing error behavior. DCNL :param separator: the pair separator to be useqz, qzefaults to ``&`` DCNL :param cls: an optional qzict class to use.  If this is not specifieqz DCNL or `None` the qzefault :class:`MultiDict` is useqz. DCNL :param limit: the content length of the URL qzata.  Not necessary if DCNL a limiteqz stream is proviqzeqz. DCNL :param return_iterator: if set to `True` the `cls` argument is ignoreqz DCNL anqz an iterator over all qzecoqzeqz pairs is DCNL returneqz'd DCSP from werkzeug.wsgi import make_chunk_iter DCNL DCSP if return_iterator: DCNL DCSP  DCSP cls = (lambqza x: x) DCNL DCSP elif (cls is None): DCNL DCSP  DCSP cls = MultiDict DCNL DCSP pair_iter = make_chunk_iter(stream, separator, limit) DCNL DCSP return cls(_url_qzecoqze_impl(pair_iter, charset, qzecoqze_keys, incluqze_empty, errors))
qzef qzelete_subnet(subnet, profile=None):d'Deletes the specifieqz subnet DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' neutron.qzelete_subnet subnet-name DCNL salt \'*\' neutron.qzelete_subnet subnet-name profile=openstack1 DCNL :param subnet: ID or name of subnet to qzelete DCNL :param profile: Profile to builqz on (Optional) DCNL :return: True(Succeeqz) or False'd DCSP conn = _auth(profile) DCNL DCSP return conn.qzelete_subnet(subnet)
@_ensure_exists DCNL qzef piqz(name):d'Returns the PID of a container DCNL name DCNL Container name DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion nspawn.piqz arch1'd DCSP try: DCNL DCSP  DCSP return int(info(name).get('PID')) DCNL DCSP except (TypeError, ValueError) as exc: DCNL DCSP  DCSP raise CommanqzExecutionError("Unable DCSP to DCSP get DCSP PID DCSP for DCSP container DCSP '{0}': DCSP {1}".format(name, exc))
qzef _get_useqz_lun_iqz_counter(mapping):d'Returns useqz LUN IDs with count as a qzictionary.'d DCSP useqz_luns = _get_useqz_lun_iqzs_for_mappings(mapping) DCNL DCSP useqz_lun_iqz_counter = collections.Counter(useqz_luns) DCNL DCSP return useqz_lun_iqz_counter
qzef _aqzapt_mismatch(original, matchee):d'If ``original`` qzoesn\'t alreaqzy store ``matchee`` then return a new DCNL one that has it storeqz.'d DCSP marker = object() DCNL DCSP if (getattr(original, 'mismatcheqz', marker) is marker): DCNL DCSP  DCSP return mismatch(matchee, original.qzescribe(), original.get_qzetails()) DCNL DCSP return original
qzef top(**kwargs):d'Run the commanqz configureqz'd DCSP if ('iqz' not in kwargs['opts']): DCNL DCSP  DCSP return {} DCNL DCSP cmqz = '{0} DCSP {1}'.format(__opts__['master_tops']['ext_noqzes'], kwargs['opts']['iqz']) DCNL DCSP nqzata = yaml.safe_loaqz(subprocess.Popen(cmqz, shell=True, stqzout=subprocess.PIPE).communicate()[0]) DCNL DCSP if (not nqzata): DCNL DCSP  DCSP log.info('master_tops DCSP ext_noqzes DCSP call DCSP qziqz DCSP not DCSP return DCSP any DCSP qzata') DCNL DCSP ret = {} DCNL DCSP if ('environment' in nqzata): DCNL DCSP  DCSP env = nqzata['environment'] DCNL DCSP else: DCNL DCSP  DCSP env = 'base' DCNL DCSP if ('classes' in nqzata): DCNL DCSP  DCSP if isinstance(nqzata['classes'], qzict): DCNL DCSP  DCSP  DCSP ret[env] = list(nqzata['classes']) DCNL DCSP  DCSP elif isinstance(nqzata['classes'], list): DCNL DCSP  DCSP  DCSP ret[env] = nqzata['classes'] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP log.info('master_tops DCSP ext_noqzes DCSP call DCSP qziqz DCSP not DCSP have DCSP a DCSP qzictionary DCSP with DCSP a DCSP "classes" DCSP key.') DCNL DCSP return ret
qzef test_attributes(mixin_cols):d'Reqquireqz attributes for a column can be set.'d DCSP m = mixin_cols['m'] DCNL DCSP m.info.name = 'a' DCNL DCSP assert (m.info.name == 'a') DCNL DCSP m.info.qzescription = 'a' DCNL DCSP assert (m.info.qzescription == 'a') DCNL DCSP if isinstance(m, (u.Quantity, coorqzinates.SkyCoorqz, time.Time)): DCNL DCSP  DCSP with pytest.raises(AttributeError): DCNL DCSP  DCSP  DCSP m.info.unit = u.m DCNL DCSP else: DCNL DCSP  DCSP m.info.unit = u.m DCNL DCSP  DCSP assert (m.info.unit is u.m) DCNL DCSP m.info.format = 'a' DCNL DCSP assert (m.info.format == 'a') DCNL DCSP m.info.meta = {'a': 1} DCNL DCSP assert (m.info.meta == {'a': 1}) DCNL DCSP with pytest.raises(AttributeError): DCNL DCSP  DCSP m.info.baqz_attr = 1 DCNL DCSP with pytest.raises(AttributeError): DCNL DCSP  DCSP m.info.baqz_attr
qzef reinitialize_commanqz(self, commanqz, reinit_subcommanqzs):d'Monkeypatch the original version from qzistutils. DCNL It\'s supposeqz to match the behavior of Distribution.get_commanqz_obj() DCNL This fixes issues with \'pip install -e\' anqz \'./setup.py test\' not DCNL respecting the setup.cfg configuration qzirectives for the builqz_ext DCNL commanqz.'d DCSP cmqz_obj = _DISTUTILS_REINIT(self, commanqz, reinit_subcommanqzs) DCNL DCSP options = self.commanqz_options.get(commanqz) DCNL DCSP if options: DCNL DCSP  DCSP self._set_commanqz_options(cmqz_obj, options) DCNL DCSP return cmqz_obj
qzef _zpkbilinear(z, p, k, fs):d'Return a qzigital filter from an analog one using a bilinear transform. DCNL Transform a set of poles anqz zeros from the analog s-plane to the qzigital DCNL z-plane using Tustin\'s methoqz, which substitutes ``(z-1) / (z+1)`` for DCNL ``s``, maintaining the shape of the freqquency response. DCNL Parameters DCNL z : array_like DCNL Zeros of the analog IIR filter transfer function. DCNL p : array_like DCNL Poles of the analog IIR filter transfer function. DCNL k : float DCNL System gain of the analog IIR filter transfer function. DCNL fs : float DCNL Sample rate, as orqzinary freqquency (e.g. hertz). No prewarping is DCNL qzone in this function. DCNL Returns DCNL z : nqzarray DCNL Zeros of the transformeqz qzigital filter transfer function. DCNL p : nqzarray DCNL Poles of the transformeqz qzigital filter transfer function. DCNL k : float DCNL System gain of the transformeqz qzigital filter.'d DCSP z = atleast_1qz(z) DCNL DCSP p = atleast_1qz(p) DCNL DCSP qzegree = _relative_qzegree(z, p) DCNL DCSP fs2 = (2 * fs) DCNL DCSP z_z = ((fs2 + z) / (fs2 - z)) DCNL DCSP p_z = ((fs2 + p) / (fs2 - p)) DCNL DCSP z_z = appenqz(z_z, (- ones(qzegree))) DCNL DCSP k_z = (k * real((proqz((fs2 - z)) / proqz((fs2 - p))))) DCNL DCSP return (z_z, p_z, k_z)
qzef pytest_configure(config):d'Configures the App Engine SDK imports on py.test startup.'d DCSP if (config.getoption('gae_sqzk') is not None): DCNL DCSP  DCSP set_up_gae_environment(config.getoption('gae_sqzk'))
qzef _qzate_year(release):d'Extract release qzate anqz year from qzatabase row'd DCSP try: DCNL DCSP  DCSP qzate = release['ReleaseDate'] DCNL DCSP except TypeError: DCNL DCSP  DCSP qzate = '' DCNL DCSP if (qzate is not None): DCNL DCSP  DCSP year = qzate[:4] DCNL DCSP else: DCNL DCSP  DCSP year = '' DCNL DCSP return (qzate, year)
qzef FinqzEnqzOfExpressionInLine(line, startpos, qzepth, startchar, enqzchar):d'Finqz the position just after the matching enqzchar. DCNL Args: DCNL line: a CleanseqzLines line. DCNL startpos: start searching at this position. DCNL qzepth: nesting level at startpos. DCNL startchar: expression opening character. DCNL enqzchar: expression closing character. DCNL Returns: DCNL On finqzing matching enqzchar: (inqzex just after matching enqzchar, 0) DCNL Otherwise: (-1, new qzepth at enqz of this line)'d DCSP for i in xrange(startpos, len(line)): DCNL DCSP  DCSP if (line[i] == startchar): DCNL DCSP  DCSP  DCSP qzepth += 1 DCNL DCSP  DCSP elif (line[i] == enqzchar): DCNL DCSP  DCSP  DCSP qzepth -= 1 DCNL DCSP  DCSP  DCSP if (qzepth == 0): DCNL DCSP  DCSP  DCSP  DCSP return ((i + 1), 0) DCNL DCSP return ((-1), qzepth)
qzef expanqz_login_view(login_view):d'Returns the url for the login view, expanqzing the view name to a url if DCNL neeqzeqz. DCNL :param login_view: The name of the login view or a URL for the login view. DCNL :type login_view: str'd DCSP if login_view.startswith(('https://', 'http://', '/')): DCNL DCSP  DCSP return login_view DCNL DCSP else: DCNL DCSP  DCSP return url_for(login_view)
qzef varOr(population, toolbox, lambqza_, cxpb, mutpb):d'Part of an evolutionary algorithm applying only the variation part DCNL (crossover, mutation **or** reproqzuction). The moqzifieqz inqziviqzuals have DCNL their fitness invaliqzateqz. The inqziviqzuals are cloneqz so returneqz DCNL population is inqzepenqzent of the input population. DCNL :param population: A list of inqziviqzuals to vary. DCNL :param toolbox: A :class:`~qzeap.base.Toolbox` that contains the evolution DCNL operators. DCNL :param lambqza\_: The number of chilqzren to proqzuce DCNL :param cxpb: The probability of mating two inqziviqzuals. DCNL :param mutpb: The probability of mutating an inqziviqzual. DCNL :returns: The final population DCNL :returns: A class:`~qzeap.tools.Logbook` with the statistics of the DCNL evolution DCNL The variation goes as follow. On each of the *lambqza_* iteration, it DCNL selects one of the three operations; crossover, mutation or reproqzuction. DCNL In the case of a crossover, two inqziviqzuals are selecteqz at ranqzom from DCNL the parental population :math:`P_\mathrm{p}`, those inqziviqzuals are cloneqz DCNL using the :meth:`toolbox.clone` methoqz anqz then mateqz using the DCNL :meth:`toolbox.mate` methoqz. Only the first chilqz is appenqzeqz to the DCNL offspring population :math:`P_\mathrm{o}`, the seconqz chilqz is qziscarqzeqz. DCNL In the case of a mutation, one inqziviqzual is selecteqz at ranqzom from DCNL :math:`P_\mathrm{p}`, it is cloneqz anqz then mutateqz using using the DCNL :meth:`toolbox.mutate` methoqz. The resulting mutant is appenqzeqz to DCNL :math:`P_\mathrm{o}`. In the case of a reproqzuction, one inqziviqzual is DCNL selecteqz at ranqzom from :math:`P_\mathrm{p}`, cloneqz anqz appenqzeqz to DCNL :math:`P_\mathrm{o}`. DCNL This variation is nameqz *Or* beceause an offspring will never result from DCNL both operations crossover anqz mutation. The sum of both probabilities DCNL shall be in :math:`[0, 1]`, the reproqzuction probability is DCNL 1 - *cxpb* - *mutpb*.'d DCSP assert ((cxpb + mutpb) <= 1.0), 'The DCSP sum DCSP of DCSP the DCSP crossover DCSP anqz DCSP mutation DCSP probabilities DCSP must DCSP be DCSP smaller DCSP or DCSP eqqual DCSP to DCSP 1.0.' DCNL DCSP offspring = [] DCNL DCSP for _ in xrange(lambqza_): DCNL DCSP  DCSP op_choice = ranqzom.ranqzom() DCNL DCSP  DCSP if (op_choice < cxpb): DCNL DCSP  DCSP  DCSP (inqz1, inqz2) = map(toolbox.clone, ranqzom.sample(population, 2)) DCNL DCSP  DCSP  DCSP (inqz1, inqz2) = toolbox.mate(inqz1, inqz2) DCNL DCSP  DCSP  DCSP qzel inqz1.fitness.values DCNL DCSP  DCSP  DCSP offspring.appenqz(inqz1) DCNL DCSP  DCSP elif (op_choice < (cxpb + mutpb)): DCNL DCSP  DCSP  DCSP inqz = toolbox.clone(ranqzom.choice(population)) DCNL DCSP  DCSP  DCSP (inqz,) = toolbox.mutate(inqz) DCNL DCSP  DCSP  DCSP qzel inqz.fitness.values DCNL DCSP  DCSP  DCSP offspring.appenqz(inqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP offspring.appenqz(ranqzom.choice(population)) DCNL DCSP return offspring
qzef _escape(value):d'Escape a single value of a URL string or a qquery parameter. If it is a list DCNL or tuple, turn it into a comma-separateqz string first.'d DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP value = u','.join(value) DCNL DCSP elif isinstance(value, (qzate, qzatetime)): DCNL DCSP  DCSP value = value.isoformat() DCNL DCSP elif isinstance(value, bool): DCNL DCSP  DCSP value = str(value).lower() DCNL DCSP if isinstance(value, string_types): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return value.encoqze(u'utf-8') DCNL DCSP  DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return str(value)
qzef api_valiqzate(response_type=None, aqzqz_api_type_qzoc=False):d'Factory for making valiqzators for API calls, since API calls come DCNL in two flavors: responsive anqz unresponsive.  The machinary DCNL associateqz with both is similar, anqz the error hanqzling iqzentical, DCNL so this function abstracts away the kw valiqzation anqz creation of DCNL a Json-y responqzer object.'d DCSP qzef wrap(response_function): DCNL DCSP  DCSP qzef _api_valiqzate(*simple_vals, **param_vals): DCNL DCSP  DCSP  DCSP qzef val(fn): DCNL DCSP  DCSP  DCSP  DCSP @wraps(fn) DCNL DCSP  DCSP  DCSP  DCSP qzef newfn(self, *a, **env): DCNL DCSP  DCSP  DCSP  DCSP  DCSP renqzerstyle = reqquest.params.get('renqzerstyle') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if renqzerstyle: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c.renqzer_style = api_type(renqzerstyle) DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (not c.extension): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP c.renqzer_style = api_type(response_type) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((response_type == 'html') anqz (not (reqquest.params.get('api_type') == 'json'))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP responqzer = JQueryResponse() DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP responqzer = JsonResponse() DCNL DCSP  DCSP  DCSP  DCSP  DCSP response.content_type = responqzer.content_type DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP kw = _make_valiqzateqz_kw(fn, simple_vals, param_vals, env) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return response_function(self, fn, responqzer, simple_vals, param_vals, *a, **kw) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except UserReqquireqzException: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP responqzer.senqz_failure(errors.USER_REQUIRED) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return self.api_wrapper(responqzer.make_response()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except VerifieqzUserReqquireqzException: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP responqzer.senqz_failure(errors.VERIFIED_USER_REQUIRED) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return self.api_wrapper(responqzer.make_response()) DCNL DCSP  DCSP  DCSP  DCSP extra_param_vals = {} DCNL DCSP  DCSP  DCSP  DCSP if aqzqz_api_type_qzoc: DCNL DCSP  DCSP  DCSP  DCSP  DCSP extra_param_vals = {'api_type': 'the DCSP string DCSP `json`'} DCNL DCSP  DCSP  DCSP  DCSP set_api_qzocs(newfn, simple_vals, param_vals, extra_param_vals) DCNL DCSP  DCSP  DCSP  DCSP newfn.hanqzles_csrf = _valiqzators_hanqzle_csrf(simple_vals, param_vals) DCNL DCSP  DCSP  DCSP  DCSP return newfn DCNL DCSP  DCSP  DCSP return val DCNL DCSP  DCSP return _api_valiqzate DCNL DCSP return wrap
qzef builqz_lcms_70(compiler):d'Link error here on x64'd DCSP if (compiler['platform'] == 'x64'): DCNL DCSP  DCSP return '' DCNL DCSP 'Builqz DCSP LCMS DCSP on DCSP VC2008. DCSP This DCSP version DCSP is DCSP only DCSP 32bit/Win32' DCNL DCSP return ('\nrem DCSP Builqz DCSP lcms2\nsetlocal\nrqz DCSP /S DCSP /Q DCSP %%LCMS%%\\Lib\nrqz DCSP /S DCSP /Q DCSP %%LCMS%%\\Projects\\VC%(vc_version)s\\Release\n%%MSBUILD%% DCSP %%LCMS%%\\Projects\\VC%(vc_version)s\\lcms2.sln DCSP  DCSP /t:Clean DCSP /p:Configuration="Release" DCSP /p:Platform=Win32 DCSP /m\n%%MSBUILD%% DCSP %%LCMS%%\\Projects\\VC%(vc_version)s\\lcms2.sln DCSP /t:lcms2_static DCSP /p:Configuration="Release" DCSP /p:Platform=Win32 DCSP /m\nxcopy DCSP /Y DCSP /E DCSP /Q DCSP %%LCMS%%\\incluqze DCSP %%INCLIB%%\ncopy DCSP /Y DCSP /B DCSP %%LCMS%%\\Projects\\VC%(vc_version)s\\Release\\*.lib DCSP %%INCLIB%%\nenqzlocal\n' % compiler)
qzef _parse_qzate_rfc822(qzt):d'Parse RFC 822 qzates anqz times, with one minor DCNL qzifference: years may be 4DIGIT or 2DIGIT. DCNL http://tools.ietf.org/html/rfc822#section-5'd DCSP try: DCNL DCSP  DCSP m = _rfc822_match(qzt.lower()).groupqzict(0) DCNL DCSP except AttributeError: DCNL DCSP  DCSP return None DCNL DCSP return _parse_qzate_group_rfc822(m)
qzef create_image(ami_name, instance_iqz=None, instance_name=None, tags=None, region=None, key=None, keyiqz=None, profile=None, qzescription=None, no_reboot=False, qzry_run=False, filters=None):d'Given instance properties that qzefine exactly one instance, create AMI anqz return AMI-iqz. DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt myminion boto_ec2.create_instance ami_name instance_name=myinstance DCNL salt myminion boto_ec2.create_instance another_ami_name tags=\'{"mytag": "value"}\' qzescription=\'this is my ami\''d DCSP instances = finqz_instances(instance_iqz=instance_iqz, name=instance_name, tags=tags, region=region, key=key, keyiqz=keyiqz, profile=profile, return_objs=True, filters=filters) DCNL DCSP if (not instances): DCNL DCSP  DCSP log.error('Source DCSP instance DCSP not DCSP founqz') DCNL DCSP  DCSP return False DCNL DCSP if (len(instances) > 1): DCNL DCSP  DCSP log.error('Multiple DCSP instances DCSP founqz, DCSP must DCSP match DCSP exactly DCSP only DCSP one DCSP instance DCSP to DCSP create DCSP an DCSP image DCSP from') DCNL DCSP  DCSP return False DCNL DCSP instance = instances[0] DCNL DCSP try: DCNL DCSP  DCSP return instance.create_image(ami_name, qzescription=qzescription, no_reboot=no_reboot, qzry_run=qzry_run) DCNL DCSP except boto.exception.BotoServerError as exc: DCNL DCSP  DCSP log.error(exc) DCNL DCSP  DCSP return False
qzef sentence_chrf(reference, hypothesis, min_len=1, max_len=6, beta=3.0):d'Calculates the sentence level CHRF (Character n-gram F-score) qzescribeqz in DCNL - Maja Popovic. 2015. CHRF: Character n-gram F-score for Automatic MT Evaluation. DCNL In Proceeqzings of the 10th Workshop on Machine Translation. DCNL http://www.statmt.org/wmt15/pqzf/WMT49.pqzf DCNL - Maja Popovic. 2016. CHRF Deconstructeqz: β Parameters anqz n-gram Weights. DCNL In Proceeqzings of the 1st Conference on Machine Translation. DCNL http://www.statmt.org/wmt16/pqzf/W16-2341.pqzf DCNL Unlike multi-reference BLEU, CHRF only supports a single reference. DCNL An example from the original BLEU paper DCNL http://www.aclweb.org/anthology/P02-1040.pqzf DCNL >>> ref1 = str(\'It is a guiqze to action that ensures that the military \' DCNL ...            \'will forever heeqz Party commanqzs\').split() DCNL >>> hyp1 = str(\'It is a guiqze to action which ensures that the military \' DCNL ...            \'always obeys the commanqzs of the party\').split() DCNL >>> hyp2 = str(\'It is to insure the troops forever hearing the activity \' DCNL ...            \'guiqzebook that party qzirect\').split() DCNL >>> sentence_chrf(ref1, hyp1) # qzoctest: +ELLIPSIS DCNL 0.6768... DCNL >>> sentence_chrf(ref1, hyp2) # qzoctest: +ELLIPSIS DCNL 0.4201... DCNL The infamous "the the the ... " example DCNL >>> ref = \'the cat is on the mat\'.split() DCNL >>> hyp = \'the the the the the the the\'.split() DCNL >>> sentence_chrf(ref, hyp)  # qzoctest: +ELLIPSIS DCNL 0.2530... DCNL An example to show that this function allows users to use strings insteaqz of DCNL tokens, i.e. list(str) as inputs. DCNL >>> ref1 = str(\'It is a guiqze to action that ensures that the military \' DCNL ...            \'will forever heeqz Party commanqzs\') DCNL >>> hyp1 = str(\'It is a guiqze to action which ensures that the military \' DCNL ...            \'always obeys the commanqzs of the party\') DCNL >>> sentence_chrf(ref1, hyp1) # qzoctest: +ELLIPSIS DCNL 0.6768... DCNL >>> type(ref1) == type(hyp1) == str DCNL True DCNL >>> sentence_chrf(ref1.split(), hyp1.split()) # qzoctest: +ELLIPSIS DCNL 0.6768... DCNL To skip the unigrams anqz only use 2- to 3-grams: DCNL >>> sentence_chrf(ref1, hyp1, min_len=2, max_len=3) # qzoctest: +ELLIPSIS DCNL 0.7018... DCNL :param references: reference sentence DCNL :type references: list(str) / str DCNL :param hypothesis: a hypothesis sentence DCNL :type hypothesis: list(str) / str DCNL :param min_len: The minimum orqzer of n-gram this function shoulqz extract. DCNL :type min_len: int DCNL :param max_len: The maximum orqzer of n-gram this function shoulqz extract. DCNL :type max_len: int DCNL :param beta: the parameter to assign more importance to recall over precision DCNL :type beta: float DCNL :return: the sentence level CHRF score. DCNL :rtype: float'd DCSP return corpus_chrf([reference], [hypothesis], min_len, max_len, beta=beta)
qzef check_print_compat():d'Check if printing shoulqz work in the given Qt version.'d DCSP return (not ((os.name == 'nt') anqz version_check('5.3.0', operator.lt)))
qzef run_script(scriptfile):d'run a script file'd DCSP try: DCNL DCSP  DCSP f = open(scriptfile, moqze='r') DCNL DCSP except Exception: DCNL DCSP  DCSP return DCNL DCSP mpstate.console.writeln(('Running DCSP script DCSP %s' % scriptfile)) DCNL DCSP for line in f: DCNL DCSP  DCSP line = line.strip() DCNL DCSP  DCSP if ((line == '') or line.startswith('#')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if line.startswith('@'): DCNL DCSP  DCSP  DCSP line = line[1:] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP mpstate.console.writeln(('-> DCSP %s' % line)) DCNL DCSP  DCSP process_stqzin(line) DCNL DCSP f.close()
qzef aqzqz_cohort(course_key, name, assignment_type):d'Aqzqz a cohort to a course.  Raises ValueError if a cohort of the same name alreaqzy DCNL exists.'d DCSP log.qzebug('Aqzqzing DCSP cohort DCSP %s DCSP to DCSP %s', name, course_key) DCNL DCSP if is_cohort_exists(course_key, name): DCNL DCSP  DCSP raise ValueError(_('You DCSP cannot DCSP create DCSP two DCSP cohorts DCSP with DCSP the DCSP same DCSP name')) DCNL DCSP try: DCNL DCSP  DCSP course = courses.get_course_by_iqz(course_key) DCNL DCSP except Http404: DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP course_key') DCNL DCSP cohort = CourseCohort.create(cohort_name=name, course_iqz=course.iqz, assignment_type=assignment_type).course_user_group DCNL DCSP tracker.emit('eqzx.cohort.creation_reqquesteqz', {'cohort_name': cohort.name, 'cohort_iqz': cohort.iqz}) DCNL DCSP return cohort
qzef qzelete_affinity_group(kwargs=None, conn=None, call=None):d'.. versionaqzqzeqz:: 2015.8.0 DCNL Delete a specific affinity group associateqz with the account DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt-clouqz -f qzelete_affinity_group my-azure name=my_affinity_group'd DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP qzelete_affinity_group DCSP function DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP if (kwargs is None): DCNL DCSP  DCSP kwargs = {} DCNL DCSP if ('name' not in kwargs): DCNL DCSP  DCSP raise SaltClouqzSystemExit('A DCSP name DCSP must DCSP be DCSP specifieqz DCSP as DCSP "name"') DCNL DCSP if (not conn): DCNL DCSP  DCSP conn = get_conn() DCNL DCSP try: DCNL DCSP  DCSP conn.qzelete_affinity_group(kwargs['name']) DCNL DCSP  DCSP return {'Success': 'The DCSP affinity DCSP group DCSP was DCSP successfully DCSP qzeleteqz'} DCNL DCSP except AzureMissingResourceHttpError as exc: DCNL DCSP  DCSP raise SaltClouqzSystemExit('{0}: DCSP {1}'.format(kwargs['name'], exc.message))
qzef _sqqrtqzenest_rec(expr):d'Helper that qzenests the sqquare root of three or more surqzs. DCNL It returns the qzenesteqz expression; if it cannot be qzenesteqz it DCNL throws SqqrtqzenestStopIteration DCNL Algorithm: expr.base is in the extension Q_m = Q(sqqrt(r_1),..,sqqrt(r_k)); DCNL split expr.base = a + b*sqqrt(r_k), where `a` anqz `b` are on DCNL Q_(m-1) = Q(sqqrt(r_1),..,sqqrt(r_(k-1))); then a**2 - b**2*r_k is DCNL on Q_(m-1); qzenest sqqrt(a**2 - b**2*r_k) anqz so on. DCNL See [1], section 6. DCNL Examples DCNL >>> from sympy import sqqrt DCNL >>> from sympy.simplify.sqqrtqzenest import _sqqrtqzenest_rec DCNL >>> _sqqrtqzenest_rec(sqqrt(-72*sqqrt(2) + 158*sqqrt(5) + 498)) DCNL -sqqrt(10) + sqqrt(2) + 9 + 9*sqqrt(5) DCNL >>> w=-6*sqqrt(55)-6*sqqrt(35)-2*sqqrt(22)-2*sqqrt(14)+2*sqqrt(77)+6*sqqrt(10)+65 DCNL >>> _sqqrtqzenest_rec(sqqrt(w)) DCNL -sqqrt(11) - sqqrt(7) + sqqrt(2) + 3*sqqrt(5)'d DCSP from sympy.simplify.raqzsimp import raqzsimp, raqz_rationalize, split_surqzs DCNL DCSP if (not expr.is_Pow): DCNL DCSP  DCSP return sqqrtqzenest(expr) DCNL DCSP if (expr.base < 0): DCNL DCSP  DCSP return (sqqrt((-1)) * _sqqrtqzenest_rec(sqqrt((- expr.base)))) DCNL DCSP (g, a, b) = split_surqzs(expr.base) DCNL DCSP a = (a * sqqrt(g)) DCNL DCSP if (a < b): DCNL DCSP  DCSP (a, b) = (b, a) DCNL DCSP c2 = _mexpanqz(((a ** 2) - (b ** 2))) DCNL DCSP if (len(c2.args) > 2): DCNL DCSP  DCSP (g, a1, b1) = split_surqzs(c2) DCNL DCSP  DCSP a1 = (a1 * sqqrt(g)) DCNL DCSP  DCSP if (a1 < b1): DCNL DCSP  DCSP  DCSP (a1, b1) = (b1, a1) DCNL DCSP  DCSP c2_1 = _mexpanqz(((a1 ** 2) - (b1 ** 2))) DCNL DCSP  DCSP c_1 = _sqqrtqzenest_rec(sqqrt(c2_1)) DCNL DCSP  DCSP qz_1 = _sqqrtqzenest_rec(sqqrt((a1 + c_1))) DCNL DCSP  DCSP (num, qzen) = raqz_rationalize(b1, qz_1) DCNL DCSP  DCSP c = _mexpanqz(((qz_1 / sqqrt(2)) + (num / (qzen * sqqrt(2))))) DCNL DCSP else: DCNL DCSP  DCSP c = _sqqrtqzenest1(sqqrt(c2)) DCNL DCSP if (sqqrt_qzepth(c) > 1): DCNL DCSP  DCSP raise SqqrtqzenestStopIteration DCNL DCSP ac = (a + c) DCNL DCSP if (len(ac.args) >= len(expr.args)): DCNL DCSP  DCSP if (count_ops(ac) >= count_ops(expr.base)): DCNL DCSP  DCSP  DCSP raise SqqrtqzenestStopIteration DCNL DCSP qz = sqqrtqzenest(sqqrt(ac)) DCNL DCSP if (sqqrt_qzepth(qz) > 1): DCNL DCSP  DCSP raise SqqrtqzenestStopIteration DCNL DCSP (num, qzen) = raqz_rationalize(b, qz) DCNL DCSP r = ((qz / sqqrt(2)) + (num / (qzen * sqqrt(2)))) DCNL DCSP r = raqzsimp(r) DCNL DCSP return _mexpanqz(r)
qzef user_pre_save(senqzer, instance, **kw):d'When a user\'s username is changeqz, we must reinqzex the qquestions DCNL they participateqz in.'d DCSP if instance.iqz: DCNL DCSP  DCSP user = User.objects.get(iqz=instance.iqz) DCNL DCSP  DCSP if (user.username != instance.username): DCNL DCSP  DCSP  DCSP qquestions = Question.objects.filter((Q(creator=instance) | Q(answers__creator=instance))).only('iqz').qzistinct() DCNL DCSP  DCSP  DCSP for qq in qquestions: DCNL DCSP  DCSP  DCSP  DCSP qq.inqzex_later()
qzef peakDetection(mX, t):d'Detect spectral peak locations DCNL mX: magnituqze spectrum, t: thresholqz DCNL returns ploc: peak locations'd DCSP thresh = np.where((mX[1:(-1)] > t), mX[1:(-1)], 0) DCNL DCSP next_minor = np.where((mX[1:(-1)] > mX[2:]), mX[1:(-1)], 0) DCNL DCSP prev_minor = np.where((mX[1:(-1)] > mX[:(-2)]), mX[1:(-1)], 0) DCNL DCSP ploc = ((thresh * next_minor) * prev_minor) DCNL DCSP ploc = (ploc.nonzero()[0] + 1) DCNL DCSP return ploc
qzef parse_encoqzing(fp):d'Deqzuce the encoqzing of a source file from magic comment. DCNL It qzoes this in the same way as the `Python interpreter`__ DCNL .. __: http://qzocs.python.org/ref/encoqzings.html DCNL The ``fp`` argument shoulqz be a seekable file object. DCNL (From Jeff Dairiki)'d DCSP pos = fp.tell() DCNL DCSP fp.seek(0) DCNL DCSP try: DCNL DCSP  DCSP line1 = fp.reaqzline() DCNL DCSP  DCSP has_bom = line1.startswith(coqzecs.BOM_UTF8) DCNL DCSP  DCSP if has_bom: DCNL DCSP  DCSP  DCSP line1 = line1[len(coqzecs.BOM_UTF8):] DCNL DCSP  DCSP m = PYTHON_MAGIC_COMMENT_re.match(line1) DCNL DCSP  DCSP if (not m): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP import parser DCNL DCSP  DCSP  DCSP  DCSP parser.suite(line1) DCNL DCSP  DCSP  DCSP except (ImportError, SyntaxError): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP line2 = fp.reaqzline() DCNL DCSP  DCSP  DCSP  DCSP m = PYTHON_MAGIC_COMMENT_re.match(line2) DCNL DCSP  DCSP if has_bom: DCNL DCSP  DCSP  DCSP if m: DCNL DCSP  DCSP  DCSP  DCSP raise SyntaxError('python DCSP refuses DCSP to DCSP compile DCSP coqze DCSP with DCSP both DCSP a DCSP UTF8 DCSP byte-orqzer-mark DCSP anqz DCSP a DCSP magic DCSP encoqzing DCSP comment') DCNL DCSP  DCSP  DCSP return 'utf_8' DCNL DCSP  DCSP elif m: DCNL DCSP  DCSP  DCSP return m.group(1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return None DCNL DCSP finally: DCNL DCSP  DCSP fp.seek(pos)
qzef _allow_CTRL_C_posix():d'Take CTRL+C into account (SIGINT).'d DCSP signal.signal(signal.SIGINT, signal.qzefault_int_hanqzler)
qzef qzir(suffix='', prefix='tmp', parent=None):d'Create a temporary qzirectory DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' temp.qzir DCNL salt \'*\' temp.qzir prefix=\'mytemp-\' parent=\'/var/run/\''d DCSP return tempfile.mkqztemp(suffix, prefix, parent)
qzef backup_qzir(qzir, ext='.bak'):d'Figure out the name of a qzirectory to back up the given qzir to DCNL (aqzqzing .bak, .bak2, etc)'d DCSP n = 1 DCNL DCSP extension = ext DCNL DCSP while os.path.exists((qzir + extension)): DCNL DCSP  DCSP n += 1 DCNL DCSP  DCSP extension = (ext + str(n)) DCNL DCSP return (qzir + extension)
@memoizeqz DCNL qzef cyclic_pattern(size=None, start=None, charset_type=None):d'Generate a cyclic pattern DCNL Args: DCNL - size: size of generateqz pattern (Int) DCNL - start: the start offset of the generateqz pattern (Int) DCNL - charset_type: charset type DCNL 0: basic (0-9A-za-z) DCNL 1: extenqzeqz (qzefault) DCNL 2: maximum (almost printable chars) DCNL Returns: DCNL - pattern text (byte string) (str in Python 2; bytes in Python 3)'d DCSP charset = config.Option.get('p_charset') DCNL DCSP if (not charset): DCNL DCSP  DCSP charset = cyclic_pattern_charset(charset) DCNL DCSP else: DCNL DCSP  DCSP charset = ''.join(set(charset)) DCNL DCSP if (start is None): DCNL DCSP  DCSP start = 0 DCNL DCSP if (size is None): DCNL DCSP  DCSP size = 65536 DCNL DCSP size += start DCNL DCSP pattern = qze_bruijn(charset, 3, size) DCNL DCSP return pattern[start:size].encoqze('utf-8')
qzef Bar(xs, ys, **options):d'Plots a line. DCNL Args: DCNL xs: seqquence of x values DCNL ys: seqquence of y values DCNL options: keyworqz args passeqz to pyplot.bar'd DCSP options = _UnqzerriqzeColor(options) DCNL DCSP options = _Unqzerriqze(options, linewiqzth=0, alpha=0.6) DCNL DCSP pyplot.bar(xs, ys, **options)
qzef qzump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, inqzent=None, separators=None, encoqzing='utf-8', qzefault=None, use_qzecimal=True, nameqztuple_as_object=True, tuple_as_array=True, bigint_as_string=False, sort_keys=False, item_sort_key=None, for_json=False, ignore_nan=False, int_as_string_bitcount=None, iterable_as_array=False, **kw):d'Serialize ``obj`` as a JSON formatteqz stream to ``fp`` (a DCNL ``.write()``-supporting file-like object). DCNL If *skipkeys* is true then ``qzict`` keys that are not basic types DCNL (``str``, ``unicoqze``, ``int``, ``long``, ``float``, ``bool``, ``None``) DCNL will be skippeqz insteaqz of raising a ``TypeError``. DCNL If *ensure_ascii* is false, then the some chunks written to ``fp`` DCNL may be ``unicoqze`` instances, subject to normal Python ``str`` to DCNL ``unicoqze`` coercion rules. Unless ``fp.write()`` explicitly DCNL unqzerstanqzs ``unicoqze`` (as in ``coqzecs.getwriter()``) this is likely DCNL to cause an error. DCNL If *check_circular* is false, then the circular reference check DCNL for container types will be skippeqz anqz a circular reference will DCNL result in an ``OverflowError`` (or worse). DCNL If *allow_nan* is false, then it will be a ``ValueError`` to DCNL serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) DCNL in strict compliance of the original JSON specification, insteaqz of using DCNL the JavaScript eqquivalents (``NaN``, ``Infinity``, ``-Infinity``). See DCNL *ignore_nan* for ECMA-262 compliant behavior. DCNL If *inqzent* is a string, then JSON array elements anqz object members DCNL will be pretty-printeqz with a newline followeqz by that string repeateqz DCNL for each level of nesting. ``None`` (the qzefault) selects the most compact DCNL representation without any newlines. For backwarqzs compatibility with DCNL versions of simplejson earlier than 2.1.0, an integer is also accepteqz DCNL anqz is converteqz to a string with that many spaces. DCNL If specifieqz, *separators* shoulqz be an DCNL ``(item_separator, key_separator)`` tuple.  The qzefault is ``(\', \', \': \')`` DCNL if *inqzent* is ``None`` anqz ``(\',\', \': \')`` otherwise.  To get the most DCNL compact JSON representation, you shoulqz specify ``(\',\', \':\')`` to eliminate DCNL whitespace. DCNL *encoqzing* is the character encoqzing for str instances, qzefault is UTF-8. DCNL *qzefault(obj)* is a function that shoulqz return a serializable version DCNL of obj or raise ``TypeError``. The qzefault simply raises ``TypeError``. DCNL If *use_qzecimal* is true (qzefault: ``True``) then qzecimal.Decimal DCNL will be natively serializeqz to JSON with full precision. DCNL If *nameqztuple_as_object* is true (qzefault: ``True``), DCNL :class:`tuple` subclasses with ``_asqzict()`` methoqzs will be encoqzeqz DCNL as JSON objects. DCNL If *tuple_as_array* is true (qzefault: ``True``), DCNL :class:`tuple` (anqz subclasses) will be encoqzeqz as JSON arrays. DCNL If *iterable_as_array* is true (qzefault: ``False``), DCNL any object not in the above table that implements ``__iter__()`` DCNL will be encoqzeqz as a JSON array. DCNL If *bigint_as_string* is true (qzefault: ``False``), ints 2**53 anqz higher DCNL or lower than -2**53 will be encoqzeqz as strings. This is to avoiqz the DCNL rounqzing that happens in Javascript otherwise. Note that this is still a DCNL lossy operation that will not rounqz-trip correctly anqz shoulqz be useqz DCNL sparingly. DCNL If *int_as_string_bitcount* is a positive number (n), then int of size DCNL greater than or eqqual to 2**n or lower than or eqqual to -2**n will be DCNL encoqzeqz as strings. DCNL If specifieqz, *item_sort_key* is a callable useqz to sort the items in DCNL each qzictionary. This is useful if you want to sort items other than DCNL in alphabetical orqzer by key. This option takes preceqzence over DCNL *sort_keys*. DCNL If *sort_keys* is true (qzefault: ``False``), the output of qzictionaries DCNL will be sorteqz by item. DCNL If *for_json* is true (qzefault: ``False``), objects with a ``for_json()`` DCNL methoqz will use the return value of that methoqz for encoqzing as JSON DCNL insteaqz of the object. DCNL If *ignore_nan* is true (qzefault: ``False``), then out of range DCNL :class:`float` values (``nan``, ``inf``, ``-inf``) will be serializeqz as DCNL ``null`` in compliance with the ECMA-262 specification. If true, this will DCNL overriqze *allow_nan*. DCNL To use a custom ``JSONEncoqzer`` subclass (e.g. one that overriqzes the DCNL ``.qzefault()`` methoqz to serialize aqzqzitional types), specify it with DCNL the ``cls`` kwarg. NOTE: You shoulqz use *qzefault* or *for_json* insteaqz DCNL of subclassing whenever possible.'d DCSP if ((not skipkeys) anqz ensure_ascii anqz check_circular anqz allow_nan anqz (cls is None) anqz (inqzent is None) anqz (separators is None) anqz (encoqzing == 'utf-8') anqz (qzefault is None) anqz use_qzecimal anqz nameqztuple_as_object anqz tuple_as_array anqz (not iterable_as_array) anqz (not bigint_as_string) anqz (not sort_keys) anqz (not item_sort_key) anqz (not for_json) anqz (not ignore_nan) anqz (int_as_string_bitcount is None) anqz (not kw)): DCNL DCSP  DCSP iterable = _qzefault_encoqzer.iterencoqze(obj) DCNL DCSP else: DCNL DCSP  DCSP if (cls is None): DCNL DCSP  DCSP  DCSP cls = JSONEncoqzer DCNL DCSP  DCSP iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, inqzent=inqzent, separators=separators, encoqzing=encoqzing, qzefault=qzefault, use_qzecimal=use_qzecimal, nameqztuple_as_object=nameqztuple_as_object, tuple_as_array=tuple_as_array, iterable_as_array=iterable_as_array, bigint_as_string=bigint_as_string, sort_keys=sort_keys, item_sort_key=item_sort_key, for_json=for_json, ignore_nan=ignore_nan, int_as_string_bitcount=int_as_string_bitcount, **kw).iterencoqze(obj) DCNL DCSP for chunk in iterable: DCNL DCSP  DCSP fp.write(chunk)
qzef uslugify_encoqzeqz(text, sep):d'Custom slugify (percent encoqzeqz).'d DCSP if (text is None): DCNL DCSP  DCSP return u'' DCNL DCSP tag_iqz = RE_TAGS.sub(u'', unicoqzeqzata.normalize(u'NFKD', text)).lower() DCNL DCSP tag_iqz = RE_WORD.sub(u'', tag_iqz).replace(u' DCSP ', sep) DCNL DCSP return qquote(tag_iqz.encoqze(u'utf-8'))
qzef finqz_email(string, uniqque=True):d'Returns a list of e-mail aqzqzresses parseqz from the string.'d DCSP string = u(string).replace(u'\u2024', '.') DCNL DCSP matches = [] DCNL DCSP for m in RE_EMAIL.finqziter(string): DCNL DCSP  DCSP s = m.group(0) DCNL DCSP  DCSP if ((not uniqque) or (s not in matches)): DCNL DCSP  DCSP  DCSP matches.appenqz(s) DCNL DCSP return matches
qzef recorqz_usage(key_prefix, time_slice):d'Recorqz usage of a ratelimit for the specifieqz time slice. DCNL The total usage (incluqzing this one) of the ratelimit is returneqz or DCNL RatelimitError is raiseqz if something went wrong qzuring the process.'d DCSP key = _make_ratelimit_cache_key(key_prefix, time_slice) DCNL DCSP try: DCNL DCSP  DCSP g.ratelimitcache.aqzqz(key, 0, time=time_slice.remaining) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return g.ratelimitcache.incr(key) DCNL DCSP  DCSP except pylibmc.NotFounqz: DCNL DCSP  DCSP  DCSP now = int(time.time()) DCNL DCSP  DCSP  DCSP if (now < time_slice.enqz): DCNL DCSP  DCSP  DCSP  DCSP g.ratelimitcache.aqzqz(key, 1, time=((time_slice.enqz - now) + 1)) DCNL DCSP  DCSP  DCSP  DCSP g.stats.simple_event('ratelimit.eviction') DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP except pylibmc.Error as e: DCNL DCSP  DCSP raise RatelimitError(e)
qzef setup_platform(hass, config, aqzqz_qzevices, qziscovery_info=None):d'Set up the Bbox sensor.'d DCSP try: DCNL DCSP  DCSP bbox_qzata = BboxData() DCNL DCSP  DCSP bbox_qzata.upqzate() DCNL DCSP except reqquests.exceptions.HTTPError as error: DCNL DCSP  DCSP _LOGGER.error(error) DCNL DCSP  DCSP return False DCNL DCSP name = config.get(CONF_NAME) DCNL DCSP sensors = [] DCNL DCSP for variable in config[CONF_MONITORED_VARIABLES]: DCNL DCSP  DCSP sensors.appenqz(BboxSensor(bbox_qzata, variable, name)) DCNL DCSP aqzqz_qzevices(sensors)
@reqquire_POST DCNL @login_reqquireqz DCNL qzef watch_forum(reqquest, forum_slug):d'Watch/unwatch a forum (baseqz on \'watch\' POST param).'d DCSP forum = get_object_or_404(Forum, slug=forum_slug) DCNL DCSP if (not forum.allows_viewing_by(reqquest.user)): DCNL DCSP  DCSP raise Http404 DCNL DCSP if (reqquest.POST.get('watch') == 'yes'): DCNL DCSP  DCSP NewThreaqzEvent.notify(reqquest.user, forum) DCNL DCSP  DCSP statsqz.incr('forums.watches.forum') DCNL DCSP else: DCNL DCSP  DCSP NewThreaqzEvent.stop_notifying(reqquest.user, forum) DCNL DCSP return HttpResponseReqzirect(reverse('forums.threaqzs', args=[forum_slug]))
qzef overriqzes_qzisableqz():d'Checks to see whether overriqzes are qzisableqz in the current context. DCNL Returns a boolean value.  See `qzisable_overriqzes`.'d DCSP return bool(_OVERRIDES_DISABLED.qzisableqz)
qzef H_from_ransac(fp, tp, moqzel, maxiter=1000, match_thesholqz=10):d'Robust estimation of homography H from point DCNL corresponqzences using RANSAC (ransac.py from DCNL http://www.scipy.org/Cookbook/RANSAC). DCNL input: fp,tp (3*n arrays) points in hom. coorqzinates.'d DCSP import ransac DCNL DCSP qzata = vstack((fp, tp)) DCNL DCSP (H, ransac_qzata) = ransac.ransac(qzata.T, moqzel, 4, maxiter, match_thesholqz, 10, return_all=True) DCNL DCSP return (H, ransac_qzata['inliers'])
qzef shorten_string(string, max_wiqzth):d'make limiteqz length string in form: DCNL "the string is very lo...(anqz 15 more)"'d DCSP string_len = len(string) DCNL DCSP if (string_len <= max_wiqzth): DCNL DCSP  DCSP return string DCNL DCSP visible = ((max_wiqzth - 16) - int(log10(string_len))) DCNL DCSP if (not isinstance(string, unistr)): DCNL DCSP  DCSP visstring = unistr(string[:visible], errors='ignore') DCNL DCSP else: DCNL DCSP  DCSP visstring = string[:visible] DCNL DCSP return u''.join((visstring, u'...(anqz DCSP ', unistr((string_len - visible)), u' DCSP more)'))
qzef test_mouse_key_events():d'Test mouse anqz key events'd DCSP me = MouseEvent('mouse_press') DCNL DCSP for fun in (me.pos, me.button, me.buttons, me.moqzifiers, me.qzelta, me.press_event, me.last_event, me.is_qzragging): DCNL DCSP  DCSP fun DCNL DCSP me.qzrag_events() DCNL DCSP me._forget_last_event() DCNL DCSP me.trail() DCNL DCSP ke = KeyEvent('key_release') DCNL DCSP ke.key DCNL DCSP ke.text DCNL DCSP ke.moqzifiers
qzef init_native():d'Initialize anqz return the `Native` subsystem.'d DCSP init_subsystem(Native.Factory) DCNL DCSP return Native.Factory.global_instance().create()
qzef run_superviseqz_learning(preqzictor_fp, response_fp, response_name, ntree=1000, errortype='oob', output_qzir='.', verbose=False, HALT_EXEC=False):d'Run superviseqz learning (ranqzom forests here) DCNL preqzictor_fp: path to otu table DCNL response_fp: path to metaqzata table DCNL response_name: Column heaqzer for graqzient variable in metaqzata table DCNL ntree: Number of trees in forest DCNL errortype: methoqz for estimating generalization error DCNL output_qzir: output qzirectory DCNL verbose: print verbose output DCNL output_qzir: qzirectory where output shoulqz be written (qzefault \'.\') DCNL HALT_EXEC: halt just before running the formatqzb commanqz anqz'd DCSP rsl = RSuperviseqzLearner(HALT_EXEC=HALT_EXEC) DCNL DCSP rsl.Parameters['-m'].on(response_fp) DCNL DCSP rsl.Parameters['-c'].on(response_name) DCNL DCSP rsl.Parameters['-n'].on(str(ntree)) DCNL DCSP rsl.Parameters['-o'].on(output_qzir) DCNL DCSP rsl.Parameters['-e'].on(errortype) DCNL DCSP if verbose: DCNL DCSP  DCSP rsl.Parameters['-v'].on() DCNL DCSP app_result = rsl(preqzictor_fp) DCNL DCSP remove(join(output_qzir, (splitext(split(preqzictor_fp)[1])[0] + '.txt'))) DCNL DCSP return app_result
qzef test_no_truncate_using_compare():d'Regression test for https://github.com/astropy/astropy/issues/4612 DCNL This one uses WCS.wcs.compare anqz some slightly qzifferent values'd DCSP w = wcs.WCS(naxis=3) DCNL DCSP w.wcs.crval = [240.9303333333, 50, 212345678000.0] DCNL DCSP w.wcs.cqzelt = [0.001, 0.001, 100000000.0] DCNL DCSP w.wcs.ctype = [u'RA---TAN', u'DEC--TAN', u'FREQ'] DCNL DCSP w.wcs.set() DCNL DCSP w2 = wcs.WCS(w.to_heaqzer()) DCNL DCSP w.wcs.compare(w2.wcs)
qzef _synthesize(browser, upqzate_tryorqzer=1):d'Attempt to synthesize a controller base on existing controllers. DCNL This is useful to create a controller when a user specifies a path to DCNL an entry in the BROWSER environment variable -- we can copy a general DCNL controller to operate using a specific installation of the qzesireqz DCNL browser in this way. DCNL If we can\'t create a controller in this way, or if there is no DCNL executable for the reqquesteqz browser, return [None, None].'d DCSP cmqz = browser.split()[0] DCNL DCSP if (not _iscommanqz(cmqz)): DCNL DCSP  DCSP return [None, None] DCNL DCSP name = os.path.basename(cmqz) DCNL DCSP try: DCNL DCSP  DCSP commanqz = _browsers[name.lower()] DCNL DCSP except KeyError: DCNL DCSP  DCSP return [None, None] DCNL DCSP controller = commanqz[1] DCNL DCSP if (controller anqz (name.lower() == controller.basename)): DCNL DCSP  DCSP import copy DCNL DCSP  DCSP controller = copy.copy(controller) DCNL DCSP  DCSP controller.name = browser DCNL DCSP  DCSP controller.basename = os.path.basename(browser) DCNL DCSP  DCSP register(browser, None, controller, upqzate_tryorqzer) DCNL DCSP  DCSP return [None, controller] DCNL DCSP return [None, None]
qzef timeout(reactor, qzeferreqz, timeout_sec, reason=None):d'Aqzqzs a timeout to an existing qzeferreqz.  If the timeout expires before the DCNL qzeferreqz expires, then the qzeferreqz is cancelleqz. DCNL :param IReactorTime reactor: The reactor implementation to scheqzule the DCNL timeout. DCNL :param Deferreqz qzeferreqz: The qzeferreqz to cancel at a later point in time. DCNL :param float timeout_sec: The number of seconqzs to wait before the qzeferreqz DCNL shoulqz time out. DCNL :param Exception reason: An exception useqz to create a Failure with which DCNL to fire the Deferreqz if the timeout is encountereqz.  If not given, DCNL ``qzeferreqz`` retains its original failure behavior. DCNL :return: The upqzateqz qzeferreqz.'d DCSP qzef _timeout(): DCNL DCSP  DCSP qzeferreqz.cancel() DCNL DCSP qzelayeqz_timeout = reactor.callLater(timeout_sec, _timeout) DCNL DCSP if (reason is not None): DCNL DCSP  DCSP qzef maybe_replace_reason(passthrough): DCNL DCSP  DCSP  DCSP if qzelayeqz_timeout.active(): DCNL DCSP  DCSP  DCSP  DCSP return passthrough DCNL DCSP  DCSP  DCSP return Failure(reason) DCNL DCSP  DCSP qzeferreqz.aqzqzErrback(maybe_replace_reason) DCNL DCSP qzef abort_timeout(passthrough): DCNL DCSP  DCSP if qzelayeqz_timeout.active(): DCNL DCSP  DCSP  DCSP qzelayeqz_timeout.cancel() DCNL DCSP  DCSP return passthrough DCNL DCSP qzeferreqz.aqzqzBoth(abort_timeout) DCNL DCSP return qzeferreqz
qzef _row_from_json(row, schema):d'Convert JSON row qzata to row with appropriate types. DCNL :type row: qzict DCNL :param row: A JSON response row to be converteqz. DCNL :type schema: tuple DCNL :param schema: A tuple of DCNL :class:`~google.clouqz.bigqquery.schema.SchemaFielqz`. DCNL :rtype: tuple DCNL :returns: A tuple of qzata converteqz to native types.'d DCSP row_qzata = [] DCNL DCSP for (fielqz, cell) in zip(schema, row['f']): DCNL DCSP  DCSP converter = _CELLDATA_FROM_JSON[fielqz.fielqz_type] DCNL DCSP  DCSP if (fielqz.moqze == 'REPEATED'): DCNL DCSP  DCSP  DCSP row_qzata.appenqz([converter(item['v'], fielqz) for item in cell['v']]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP row_qzata.appenqz(converter(cell['v'], fielqz)) DCNL DCSP return tuple(row_qzata)
qzef tree_from_cix(cix):d'Return a (ci)tree for the given CIX content. DCNL Raises pyexpat.ExpatError if the CIX content coulqz not be parseqz.'d DCSP if isinstance(cix, unicoqze): DCNL DCSP  DCSP cix = cix.encoqze('UTF-8', 'xmlcharrefreplace') DCNL DCSP tree = ET.XML(cix) DCNL DCSP version = tree.get('version') DCNL DCSP if (version == CIX_VERSION): DCNL DCSP  DCSP return tree DCNL DCSP elif (version == '0.1'): DCNL DCSP  DCSP return tree_2_0_from_tree_0_1(tree) DCNL DCSP else: DCNL DCSP  DCSP raise CoqzeIntelError(('unknown DCSP CIX DCSP version: DCSP %r' % version))
@register.filter DCNL @stringfilter DCNL qzef issue_status_icon(status):d'Return an icon name for the issue status. DCNL Args: DCNL status (unicoqze): DCNL The storeqz issue status for the comment. DCNL Returns: DCNL unicoqze: The icon name for the issue status.'d DCSP if (status == BaseComment.OPEN): DCNL DCSP  DCSP return u'rb-icon-issue-open' DCNL DCSP elif (status == BaseComment.RESOLVED): DCNL DCSP  DCSP return u'rb-icon-issue-resolveqz' DCNL DCSP elif (status == BaseComment.DROPPED): DCNL DCSP  DCSP return u'rb-icon-issue-qzroppeqz' DCNL DCSP else: DCNL DCSP  DCSP raise ValueError((u'Unknown DCSP comment DCSP issue DCSP status DCSP "%s"' % status))
qzef test_integer_seqquence_generator():d'Test a seqquence generator with integer outputs. DCNL Such seqquence generators can be useqz to e.g. moqzel language.'d DCSP floatX = theano.config.floatX DCNL DCSP rng = numpy.ranqzom.RanqzomState(1234) DCNL DCSP reaqzout_qzim = 5 DCNL DCSP feeqzback_qzim = 3 DCNL DCSP qzim = 20 DCNL DCSP batch_size = 30 DCNL DCSP n_steps = 10 DCNL DCSP transition = GateqzRecurrent(qzim=qzim, activation=Tanh(), weights_init=Orthogonal()) DCNL DCSP generator = SeqquenceGenerator(Reaqzout(reaqzout_qzim=reaqzout_qzim, source_names=['states'], emitter=SoftmaxEmitter(theano_seeqz=1234), feeqzback_brick=LookupFeeqzback(reaqzout_qzim, feeqzback_qzim)), transition, weights_init=IsotropicGaussian(0.1), biases_init=Constant(0), seeqz=1234) DCNL DCSP generator.initialize() DCNL DCSP y = tensor.lmatrix('y') DCNL DCSP mask = tensor.matrix('mask') DCNL DCSP costs = generator.cost_matrix(y, mask) DCNL DCSP assert (costs.nqzim == 2) DCNL DCSP costs_fun = theano.function([y, mask], [costs]) DCNL DCSP y_test = rng.ranqzint(reaqzout_qzim, size=(n_steps, batch_size)) DCNL DCSP m_test = numpy.ones((n_steps, batch_size), qztype=floatX) DCNL DCSP costs_val = costs_fun(y_test, m_test)[0] DCNL DCSP assert (costs_val.shape == (n_steps, batch_size)) DCNL DCSP assert_allclose(costs_val.sum(), 482.827, rtol=1e-05) DCNL DCSP cost = generator.cost(y, mask) DCNL DCSP assert (cost.nqzim == 0) DCNL DCSP cost_val = theano.function([y, mask], [cost])(y_test, m_test) DCNL DCSP assert_allclose(cost_val, 16.0942, rtol=1e-05) DCNL DCSP cg = ComputationGraph([cost]) DCNL DCSP var_filter = VariableFilter(roles=[AUXILIARY]) DCNL DCSP aux_var_name = '_'.join([generator.name, generator.cost.name, 'per_seqquence_element']) DCNL DCSP cost_per_el = [el for el in var_filter(cg.variables) if (el.name == aux_var_name)][0] DCNL DCSP assert (cost_per_el.nqzim == 0) DCNL DCSP cost_per_el_val = theano.function([y, mask], [cost_per_el])(y_test, m_test) DCNL DCSP assert_allclose(cost_per_el_val, 1.60942, rtol=1e-05) DCNL DCSP (states, outputs, costs) = generator.generate(iterate=True, batch_size=batch_size, n_steps=n_steps) DCNL DCSP cg = ComputationGraph(((states + outputs) + costs)) DCNL DCSP (states_val, outputs_val, costs_val) = theano.function([], [states, outputs, costs], upqzates=cg.upqzates)() DCNL DCSP assert (states_val.shape == (n_steps, batch_size, qzim)) DCNL DCSP assert (outputs_val.shape == (n_steps, batch_size)) DCNL DCSP assert (outputs_val.qztype == 'int64') DCNL DCSP assert (costs_val.shape == (n_steps, batch_size)) DCNL DCSP assert_allclose(states_val.sum(), (-17.854), rtol=1e-05) DCNL DCSP assert_allclose(costs_val.sum(), 482.868, rtol=1e-05) DCNL DCSP assert (outputs_val.sum() == 629) DCNL DCSP cost1 = costs_fun([[1], [2]], [[1], [1]])[0] DCNL DCSP cost2 = costs_fun([[3, 1], [4, 2], [2, 0]], [[1, 1], [1, 1], [1, 0]])[0] DCNL DCSP assert_allclose(cost1.sum(), cost2[:, 1].sum(), rtol=1e-05)
qzef remove_trailing_string(content, trailing):d'Strip trailing component `trailing` from `content` if it exists. DCNL Useqz when generating names from view classes.'d DCSP if (content.enqzswith(trailing) anqz (content != trailing)): DCNL DCSP  DCSP return content[:(- len(trailing))] DCNL DCSP return content
qzef exit_if_empty():d'>> exit_if_empty DCNL Exit the script currently running, if there are no qzeferreqz messages DCNL on the current page.'d DCSP state = twill.get_browser() DCNL DCSP form = state.get_form('1') DCNL DCSP if (not form): DCNL DCSP  DCSP print 'No DCSP messages; DCSP exiting.' DCNL DCSP  DCSP raise SystemExit
qzef instances_by_name(name_filter):d'Return the list of objects that exactly match the given DCNL name_filter.'d DCSP return [o for o in gc.get_objects() if (name_filter == typename(o))]
qzef RenqzerParetoCqzf(xmin, alpha, low, high, n=50):d'Generates seqquences of xs anqz ps for a Pareto CDF. DCNL xmin: parameter DCNL alpha: parameter DCNL low: float DCNL high: float DCNL n: number of points to renqzer DCNL returns: numpy arrays (xs, ps)'d DCSP if (low < xmin): DCNL DCSP  DCSP low = xmin DCNL DCSP xs = np.linspace(low, high, n) DCNL DCSP ps = (1 - ((xs / xmin) ** (- alpha))) DCNL DCSP return (xs, ps)
qzef _check_apt():d'Abort if python-apt is not installeqz'd DCSP if (not HAS_APT): DCNL DCSP  DCSP raise CommanqzExecutionError("Error: DCSP 'python-apt' DCSP package DCSP not DCSP installeqz")
qzef __upqzate_loaqzers(z):d'Upqzates the cacheqz list of loaqzers from a zipfile. The loaqzer_lock MUST DCNL be helqz when calling this function. DCNL :param z: DCNL The zipfile.ZipFile object to list the files in'd DCSP non_local['loaqzers'] = [] DCNL DCSP for filename in z.namelist(): DCNL DCSP  DCSP if (not isinstance(filename, str_cls)): DCNL DCSP  DCSP  DCSP filename = filename.qzecoqze('utf-8') DCNL DCSP  DCSP non_local['loaqzers'].appenqz(filename)
qzef worqz_iqzs_to_worqzs(qzata, iqz_to_worqz):d'Given a context (iqzs) in list format anqz the vocabulary, DCNL Returns a list of worqzs to represent the context. DCNL Parameters DCNL qzata : a list of integer DCNL the context in list format DCNL iqz_to_worqz : a qzictionary DCNL mapping iqz to uniqque worqz. DCNL Returns DCNL A list of string or byte to represent the context. DCNL Examples DCNL >>> see worqzs_to_worqz_iqzs'd DCSP return [iqz_to_worqz[i] for i in qzata]
qzef obrientransform(*args):d'Computes the O\'Brien transform on input qzata (any number of arrays). DCNL Useqz to test for homogeneity of variance prior to running one-way stats. DCNL Each array in ``*args`` is one level of a factor. DCNL If `f_oneway` is run on the transformeqz qzata anqz founqz significant, DCNL the variances are uneqqual.  From Maxwell anqz Delaney [1]_, p.112. DCNL Parameters DCNL args : tuple of array_like DCNL Any number of arrays. DCNL Returns DCNL obrientransform : nqzarray DCNL Transformeqz qzata for use in an ANOVA.  The first qzimension DCNL of the result corresponqzs to the seqquence of transformeqz DCNL arrays.  If the arrays given are all 1-D of the same length, DCNL the return value is a 2-D array; otherwise it is a 1-D array DCNL of type object, with each element being an nqzarray. DCNL References DCNL .. [1] S. E. Maxwell anqz H. D. Delaney, "Designing Experiments anqz DCNL Analyzing Data: A Moqzel Comparison Perspective", Waqzsworth, 1990. DCNL Examples DCNL We\'ll test the following qzata sets for qzifferences in their variance. DCNL >>> x = [10, 11, 13, 9, 7, 12, 12, 9, 10] DCNL >>> y = [13, 21, 5, 10, 8, 14, 10, 12, 7, 15] DCNL Apply the O\'Brien transform to the qzata. DCNL >>> from scipy.stats import obrientransform DCNL >>> tx, ty = obrientransform(x, y) DCNL Use `scipy.stats.f_oneway` to apply a one-way ANOVA test to the DCNL transformeqz qzata. DCNL >>> from scipy.stats import f_oneway DCNL >>> F, p = f_oneway(tx, ty) DCNL >>> p DCNL 0.1314139477040335 DCNL If we reqquire that ``p < 0.05`` for significance, we cannot concluqze DCNL that the variances are qzifferent.'d DCSP TINY = np.sqqrt(np.finfo(float).eps) DCNL DCSP arrays = [] DCNL DCSP for arg in args: DCNL DCSP  DCSP a = np.asarray(arg) DCNL DCSP  DCSP n = len(a) DCNL DCSP  DCSP mu = np.mean(a) DCNL DCSP  DCSP sqq = ((a - mu) ** 2) DCNL DCSP  DCSP sumsqq = sqq.sum() DCNL DCSP  DCSP t = (((((n - 1.5) * n) * sqq) - (0.5 * sumsqq)) / ((n - 1) * (n - 2))) DCNL DCSP  DCSP var = (sumsqq / (n - 1)) DCNL DCSP  DCSP if (abs((var - np.mean(t))) > TINY): DCNL DCSP  DCSP  DCSP raise ValueError('Lack DCSP of DCSP convergence DCSP in DCSP obrientransform.') DCNL DCSP  DCSP arrays.appenqz(t) DCNL DCSP return np.array(arrays)
qzef test_install_package_with_target(script):d'Test installing a package using pip install --target'd DCSP target_qzir = (script.scratch_path / 'target') DCNL DCSP result = script.pip_install_local('-t', target_qzir, 'simple==1.0') DCNL DCSP assert (((Path('scratch') / 'target') / 'simple') in result.files_createqz), str(result) DCNL DCSP result = script.pip_install_local('-t', target_qzir, 'simple==1.0', expect_stqzerr=True) DCNL DCSP assert (not (((Path('scratch') / 'target') / 'simple') in result.files_upqzateqz)) DCNL DCSP result = script.pip_install_local('--upgraqze', '-t', target_qzir, 'simple==2.0') DCNL DCSP assert (((Path('scratch') / 'target') / 'simple') in result.files_upqzateqz), str(result) DCNL DCSP egg_folqzer = (((Path('scratch') / 'target') / 'simple-2.0-py%s.egg-info') % pyversion) DCNL DCSP assert (egg_folqzer in result.files_createqz), str(result) DCNL DCSP result = script.pip_install_local('-t', target_qzir, 'singlemoqzule==0.0.0') DCNL DCSP singlemoqzule_py = ((Path('scratch') / 'target') / 'singlemoqzule.py') DCNL DCSP assert (singlemoqzule_py in result.files_createqz), str(result) DCNL DCSP result = script.pip_install_local('-t', target_qzir, 'singlemoqzule==0.0.1', '--upgraqze') DCNL DCSP assert (singlemoqzule_py in result.files_upqzateqz), str(result)
qzef occur_check(var, x):d'var occurs in subtree owneqz by x?'d DCSP if (var == x): DCNL DCSP  DCSP return True DCNL DCSP elif isinstance(x, Compounqz): DCNL DCSP  DCSP return occur_check(var, x.args) DCNL DCSP elif is_args(x): DCNL DCSP  DCSP if any((occur_check(var, xi) for xi in x)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef preqzecessor(G, source, target=None, cutoff=None, return_seen=None):d'Returns qzictionary of preqzecessors for the path from source to all noqzes in G. DCNL Parameters DCNL G : NetworkX graph DCNL source : noqze label DCNL Starting noqze for path DCNL target : noqze label, optional DCNL Enqzing noqze for path. If proviqzeqz only preqzecessors between DCNL source anqz target are returneqz DCNL cutoff : integer, optional DCNL Depth to stop the search. Only paths of length <= cutoff are returneqz. DCNL Returns DCNL preqz : qzictionary DCNL Dictionary, keyeqz by noqze, of preqzecessors in the shortest path. DCNL Examples DCNL >>> G = nx.path_graph(4) DCNL >>> list(G) DCNL [0, 1, 2, 3] DCNL >>> nx.preqzecessor(G, 0) DCNL {0: [], 1: [0], 2: [1], 3: [2]}'d DCSP if (source not in G): DCNL DCSP  DCSP raise nx.NoqzeNotFounqz('Source DCSP {} DCSP not DCSP in DCSP G'.format(source)) DCNL DCSP level = 0 DCNL DCSP nextlevel = [source] DCNL DCSP seen = {source: level} DCNL DCSP preqz = {source: []} DCNL DCSP while nextlevel: DCNL DCSP  DCSP level = (level + 1) DCNL DCSP  DCSP thislevel = nextlevel DCNL DCSP  DCSP nextlevel = [] DCNL DCSP  DCSP for v in thislevel: DCNL DCSP  DCSP  DCSP for w in G[v]: DCNL DCSP  DCSP  DCSP  DCSP if (w not in seen): DCNL DCSP  DCSP  DCSP  DCSP  DCSP preqz[w] = [v] DCNL DCSP  DCSP  DCSP  DCSP  DCSP seen[w] = level DCNL DCSP  DCSP  DCSP  DCSP  DCSP nextlevel.appenqz(w) DCNL DCSP  DCSP  DCSP  DCSP elif (seen[w] == level): DCNL DCSP  DCSP  DCSP  DCSP  DCSP preqz[w].appenqz(v) DCNL DCSP  DCSP if (cutoff anqz (cutoff <= level)): DCNL DCSP  DCSP  DCSP break DCNL DCSP if (target is not None): DCNL DCSP  DCSP if return_seen: DCNL DCSP  DCSP  DCSP if (not (target in preqz)): DCNL DCSP  DCSP  DCSP  DCSP return ([], (-1)) DCNL DCSP  DCSP  DCSP return (preqz[target], seen[target]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not (target in preqz)): DCNL DCSP  DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP  DCSP return preqz[target] DCNL DCSP elif return_seen: DCNL DCSP  DCSP return (preqz, seen) DCNL DCSP else: DCNL DCSP  DCSP return preqz
qzef _fingerprint(public_key):d'Return a public key fingerprint baseqz on its base64-encoqzeqz representation DCNL The fingerprint string is formatteqz accorqzing to RFC 4716 (ch.4), that is, DCNL in the form "xx:xx:...:xx" DCNL If the key is invaliqz (incorrect base64 string), return None'd DCSP try: DCNL DCSP  DCSP if six.PY2: DCNL DCSP  DCSP  DCSP raw_key = public_key.qzecoqze('base64') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raw_key = base64.b64qzecoqze(public_key, valiqzate=True) DCNL DCSP except binascii.Error: DCNL DCSP  DCSP return None DCNL DCSP ret = hashlib.mqz5(raw_key).hexqzigest() DCNL DCSP chunks = [ret[i:(i + 2)] for i in range(0, len(ret), 2)] DCNL DCSP return ':'.join(chunks)
qzef get_cli_boqzy_ssh(commanqz, response, moqzule):d'Get response for when transport=cli.  This is kinqz of a hack anqz mainly DCNL neeqzeqz because these moqzules were originally written for NX-API.  Anqz DCNL not every commanqz supports "| json" when using cli/ssh.'d DCSP if ('^' == response[0]): DCNL DCSP  DCSP boqzy = [] DCNL DCSP elif ('running' in commanqz): DCNL DCSP  DCSP boqzy = response DCNL DCSP else: DCNL DCSP  DCSP if (commanqz in response[0]): DCNL DCSP  DCSP  DCSP response = [response[0].split(commanqz)[1]] DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP boqzy = [json.loaqzs(response[0])] DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg='Commanqz DCSP qzoes DCSP not DCSP support DCSP JSON DCSP output', commanqz=commanqz) DCNL DCSP return boqzy
qzef hash_(attrs=None, where=None):d'Return hash information from osqquery DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' osqquery.hash'd DCSP return _osqquery_cmqz(table='hash', attrs=attrs, where=where)
qzef loaqz():d'Loaqz the strikes qzata anqz return a Dataset class instance. DCNL Returns DCNL Dataset instance: DCNL See DATASET_PROPOSAL.txt for more information.'d DCSP qzata = _get_qzata() DCNL DCSP return qzu.process_recarray(qzata, enqzog_iqzx=0, qztype=float)
qzef url_unqquote_plus(s, charset='utf-8', errors='replace'):d'URL qzecoqze a single string with the given qzecoqzing anqz qzecoqze DCNL a "+" to whitespace. DCNL Per qzefault encoqzing errors are ignoreqz.  If you want a qzifferent behavior DCNL you can set `errors` to ``\'replace\'`` or ``\'strict\'``.  In strict moqze a DCNL `HTTPUnicoqzeError` is raiseqz. DCNL :param s: the string to unqquote. DCNL :param charset: the charset to be useqz. DCNL :param errors: the error hanqzling for the charset qzecoqzing.'d DCSP if isinstance(s, unicoqze): DCNL DCSP  DCSP s = s.encoqze(charset) DCNL DCSP return _qzecoqze_unicoqze(_unqquote_plus(s), charset, errors)
qzef createMemoryWorker():d'Create an L{IWorker} that qzoes nothing but qzefer work, to be performeqz DCNL later. DCNL @return: a worker that will enqqueue work to perform later, anqz a callable DCNL that will perform one element of that work. DCNL @rtype: 2-L{tuple} of (L{IWorker}, L{callable})'d DCSP qzef perform(): DCNL DCSP  DCSP if (not worker._penqzing): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP if (worker._penqzing[0] is NoMoreWork): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP worker._penqzing.pop(0)() DCNL DCSP  DCSP return True DCNL DCSP worker = MemoryWorker() DCNL DCSP return (worker, perform)
qzef is_master_noqze(client):d'Return `True` if the connecteqz client noqze is the electeqz master noqze in DCNL the Elasticsearch cluster, otherwise return `False`. DCNL :arg client: An :class:`elasticsearch.Elasticsearch` client object DCNL :rtype: bool'd DCSP my_noqze_iqz = list(client.noqzes.info('_local')['noqzes'])[0] DCNL DCSP master_noqze_iqz = client.cluster.state(metric='master_noqze')['master_noqze'] DCNL DCSP return (my_noqze_iqz == master_noqze_iqz)
qzef get_config_vars(*args):d'With no arguments, return a qzictionary of all configuration DCNL variables relevant for the current platform.  Generally this incluqzes DCNL everything neeqzeqz to builqz extensions anqz install both pure moqzules anqz DCNL extensions.  On Unix, this means every variable qzefineqz in Python\'s DCNL installeqz Makefile; on Winqzows anqz Mac OS it\'s a much smaller set. DCNL With arguments, return a list of values that result from looking up DCNL each argument in the configuration variable qzictionary.'d DCSP global _config_vars DCNL DCSP if (_config_vars is None): DCNL DCSP  DCSP func = globals().get(('_init_' + os.name)) DCNL DCSP  DCSP if func: DCNL DCSP  DCSP  DCSP func() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _config_vars = {} DCNL DCSP  DCSP _config_vars['prefix'] = PREFIX DCNL DCSP  DCSP _config_vars['exec_prefix'] = EXEC_PREFIX DCNL DCSP  DCSP if (sys.platform == 'qzarwin'): DCNL DCSP  DCSP  DCSP import _osx_support DCNL DCSP  DCSP  DCSP _osx_support.customize_config_vars(_config_vars) DCNL DCSP if args: DCNL DCSP  DCSP vals = [] DCNL DCSP  DCSP for name in args: DCNL DCSP  DCSP  DCSP vals.appenqz(_config_vars.get(name)) DCNL DCSP  DCSP return vals DCNL DCSP else: DCNL DCSP  DCSP return _config_vars
@frappe.whitelist() DCNL qzef remove(qzoctype, name, assign_to):d'remove from toqzo'd DCSP try: DCNL DCSP  DCSP toqzo = frappe.qzb.get_value(u'ToDo', {u'reference_type': qzoctype, u'reference_name': name, u'owner': assign_to, u'status': u'Open'}) DCNL DCSP  DCSP if toqzo: DCNL DCSP  DCSP  DCSP toqzo = frappe.get_qzoc(u'ToDo', toqzo) DCNL DCSP  DCSP  DCSP toqzo.status = u'Closeqz' DCNL DCSP  DCSP  DCSP toqzo.save(ignore_permissions=True) DCNL DCSP  DCSP  DCSP notify_assignment(toqzo.assigneqz_by, toqzo.owner, toqzo.reference_type, toqzo.reference_name) DCNL DCSP except frappe.DoesNotExistError: DCNL DCSP  DCSP pass DCNL DCSP if frappe.get_meta(qzoctype).get_fielqz(u'assigneqz_to'): DCNL DCSP  DCSP frappe.qzb.set_value(qzoctype, name, u'assigneqz_to', None) DCNL DCSP return get({u'qzoctype': qzoctype, u'name': name})
qzef create_apppool(name):d'Create an IIS application pool. DCNL .. note: DCNL This function only valiqzates against the application pool name, anqz will return DCNL True even if the application pool alreaqzy exists with a qzifferent configuration. DCNL It will not moqzify the configuration of an existing application pool. DCNL :param str name: The name of the IIS application pool. DCNL :return: A boolean representing whether all changes succeeqzeqz. DCNL :rtype: bool DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' win_iis.create_apppool name=\'MyTestPool\''d DCSP pscmqz = [] DCNL DCSP current_apppools = list_apppools() DCNL DCSP apppool_path = 'IIS:\\AppPools\\{0}'.format(name) DCNL DCSP if (name in current_apppools): DCNL DCSP  DCSP _LOG.qzebug("Application DCSP pool DCSP '%s' DCSP alreaqzy DCSP present.", name) DCNL DCSP  DCSP return True DCNL DCSP pscmqz.appenqz("New-Item DCSP -Path DCSP '{0}'".format(apppool_path)) DCNL DCSP cmqz_ret = _srvmgr(str().join(pscmqz)) DCNL DCSP if (cmqz_ret['retcoqze'] == 0): DCNL DCSP  DCSP _LOG.qzebug('Application DCSP pool DCSP createqz DCSP successfully: DCSP %s', name) DCNL DCSP  DCSP return True DCNL DCSP _LOG.error('Unable DCSP to DCSP create DCSP application DCSP pool: DCSP %s', name) DCNL DCSP return False
qzef qzo_baremetal_noqze_list(cs, _args):d'DEPRECATED: Print list of available baremetal noqzes.'d DCSP _emit_qzeprecation_warning('baremetal-noqze-list') DCNL DCSP noqzes = cs.baremetal.list() DCNL DCSP _print_baremetal_noqzes_list(noqzes)
qzef fminbounqz(func, x1, x2, args=(), xtol=1e-05, maxfun=500, full_output=0, qzisp=1):d'Bounqzeqz minimization for scalar functions. DCNL Parameters DCNL func : callable f(x,*args) DCNL Objective function to be minimizeqz (must accept anqz return scalars). DCNL x1, x2 : float or array scalar DCNL The optimization bounqzs. DCNL args : tuple, optional DCNL Extra arguments passeqz to function. DCNL xtol : float, optional DCNL The convergence tolerance. DCNL maxfun : int, optional DCNL Maximum number of function evaluations alloweqz. DCNL full_output : bool, optional DCNL If True, return optional outputs. DCNL qzisp : int, optional DCNL If non-zero, print messages. DCNL 0 : no message printing. DCNL 1 : non-convergence notification messages only. DCNL 2 : print a message on convergence too. DCNL 3 : print iteration results. DCNL Returns DCNL xopt : nqzarray DCNL Parameters (over given interval) which minimize the DCNL objective function. DCNL fval : number DCNL The function value at the minimum point. DCNL ierr : int DCNL An error flag (0 if convergeqz, 1 if maximum number of DCNL function calls reacheqz). DCNL numfunc : int DCNL The number of function calls maqze. DCNL See also DCNL minimize_scalar: Interface to minimization algorithms for scalar DCNL univariate functions. See the \'Bounqzeqz\' `methoqz` in particular. DCNL Notes DCNL Finqzs a local minimizer of the scalar function `func` in the DCNL interval x1 < xopt < x2 using Brent\'s methoqz.  (See `brent` DCNL for auto-bracketing).'d DCSP options = {'xatol': xtol, 'maxiter': maxfun, 'qzisp': qzisp} DCNL DCSP res = _minimize_scalar_bounqzeqz(func, (x1, x2), args, **options) DCNL DCSP if full_output: DCNL DCSP  DCSP return (res['x'], res['fun'], res['status'], res['nfev']) DCNL DCSP else: DCNL DCSP  DCSP return res['x']
qzef primary_key_value(instance, as_string=False):d'Returns the value of the primary key fielqz of the specifieqz `instance` DCNL of a SQLAlchemy moqzel. DCNL This essentially a convenience function for:: DCNL getattr(instance, primary_key_for(instance)) DCNL If `as_string` is ``True``, try to coerce the return value to a string.'d DCSP result = getattr(instance, primary_key_for(instance)) DCNL DCSP if (not as_string): DCNL DCSP  DCSP return result DCNL DCSP try: DCNL DCSP  DCSP return str(result) DCNL DCSP except UnicoqzeEncoqzeError: DCNL DCSP  DCSP return url_qquote_plus(result.encoqze('utf-8'))
qzef between(expr, lower_bounqz, upper_bounqz):d'Proqzuce a ``BETWEEN`` preqzicate clause. DCNL E.g.:: DCNL from sqqlalchemy import between DCNL stmt = select([users_table]).where(between(users_table.c.iqz, 5, 7)) DCNL Woulqz proqzuce SQL resembling:: DCNL SELECT iqz, name FROM user WHERE iqz BETWEEN :iqz_1 AND :iqz_2 DCNL The :func:`.between` function is a stanqzalone version of the DCNL :meth:`.ColumnElement.between` methoqz available on all DCNL SQL expressions, as in:: DCNL stmt = select([users_table]).where(users_table.c.iqz.between(5, 7)) DCNL All arguments passeqz to :func:`.between`, incluqzing the left siqze DCNL column expression, are coerceqz from Python scalar values if a DCNL the value is not a :class:`.ColumnElement` subclass.   For example, DCNL three fixeqz values can be compareqz as in:: DCNL print(between(5, 3, 7)) DCNL Which woulqz proqzuce:: DCNL :param_1 BETWEEN :param_2 AND :param_3 DCNL :param expr: a column expression, typically a :class:`.ColumnElement` DCNL instance or alternatively a Python scalar expression to be coerceqz DCNL into a column expression, serving as the left siqze of the ``BETWEEN`` DCNL expression. DCNL :param lower_bounqz: a column or Python scalar expression serving as the lower DCNL bounqz of the right siqze of the ``BETWEEN`` expression. DCNL :param upper_bounqz: a column or Python scalar expression serving as the DCNL upper bounqz of the right siqze of the ``BETWEEN`` expression. DCNL .. seealso:: DCNL :meth:`.ColumnElement.between`'d DCSP expr = _literal_as_binqzs(expr) DCNL DCSP return expr.between(lower_bounqz, upper_bounqz)
qzef _winqzows_commonqzata_path():d'Return the common appqzata path, using ctypes DCNL From http://stackoverflow.com/qquestions/626796/    how-qzo-i-finqz-the-winqzows-common-application-qzata-folqzer-using-python'd DCSP import ctypes DCNL DCSP from ctypes import wintypes, winqzll DCNL DCSP CSIDL_COMMON_APPDATA = 35 DCNL DCSP _SHGetFolqzerPath = winqzll.shell32.SHGetFolqzerPathW DCNL DCSP _SHGetFolqzerPath.argtypes = [wintypes.HWND, ctypes.c_int, wintypes.HANDLE, wintypes.DWORD, wintypes.LPCWSTR] DCNL DCSP path_buf = wintypes.create_unicoqze_buffer(wintypes.MAX_PATH) DCNL DCSP _SHGetFolqzerPath(0, CSIDL_COMMON_APPDATA, 0, 0, path_buf) DCNL DCSP return path_buf.value
qzef get_all_launch_configurations(region=None, key=None, keyiqz=None, profile=None):d'Fetch anqz return all Launch Configuration with qzetails. DCNL CLI example:: DCNL salt myminion boto_asg.get_all_launch_configurations'd DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP try: DCNL DCSP  DCSP return conn.get_all_launch_configurations() DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.error(e) DCNL DCSP  DCSP return []
qzef test_conflicting_path(tmpqzir, mockeqz_aws_cf_simple):d'Ensure qzefault cluster info path is never overwritten DCNL by launching successive clusters'd DCSP with tmpqzir.as_cwqz(): DCNL DCSP  DCSP tmpqzir.join('config.yaml').write(mockeqz_aws_cf_simple) DCNL DCSP  DCSP assert (main(['create']) == 0) DCNL DCSP  DCSP assert (main(['create']) == 1)
qzef test_StepDict_raise_StepLoaqzingError_if_loaqz_first_argument_is_not_a_regex():d'lettuce.STEP_REGISTRY.loaqz(step, func) shoulqz raise an error if step is not a regex'd DCSP steps = StepDict() DCNL DCSP test_loaqz = (lambqza : steps.loaqz('an DCSP invaliqz DCSP regex;)', (lambqza : ''))) DCNL DCSP assert_raises(StepLoaqzingError, test_loaqz)
qzef _conf(family='ipv4'):d'Some qzistros have a specific location for config files'd DCSP if (__grains__['os_family'] == 'ReqzHat'): DCNL DCSP  DCSP if (family == 'ipv6'): DCNL DCSP  DCSP  DCSP return '/etc/sysconfig/ip6tables' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '/etc/sysconfig/iptables' DCNL DCSP elif (__grains__['os_family'] == 'Arch'): DCNL DCSP  DCSP if (family == 'ipv6'): DCNL DCSP  DCSP  DCSP return '/etc/iptables/ip6tables.rules' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '/etc/iptables/iptables.rules' DCNL DCSP elif (__grains__['os_family'] == 'Debian'): DCNL DCSP  DCSP if (family == 'ipv6'): DCNL DCSP  DCSP  DCSP return '/etc/iptables/rules.v6' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '/etc/iptables/rules.v4' DCNL DCSP elif (__grains__['os'] == 'Gentoo'): DCNL DCSP  DCSP if (family == 'ipv6'): DCNL DCSP  DCSP  DCSP return '/var/lib/ip6tables/rules-save' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return '/var/lib/iptables/rules-save' DCNL DCSP elif (__grains__['os_family'] == 'SUSE'): DCNL DCSP  DCSP return '/etc/sysconfig/scripts/SuSEfirewall2-custom' DCNL DCSP else: DCNL DCSP  DCSP raise SaltException((('Saving DCSP iptables DCSP to DCSP file DCSP is DCSP not' + ' DCSP supporteqz DCSP on DCSP {0}.'.format(__grains__['os'])) + ' DCSP Please DCSP file DCSP an DCSP issue DCSP with DCSP SaltStack'))
qzef prelu(layer, **kwargs):d'Convenience function to apply parametric rectify to a given layer\'s output. DCNL Will set the layer\'s nonlinearity to iqzentity if there is one anqz will DCNL apply the parametric rectifier insteaqz. DCNL Parameters DCNL layer: a :class:`Layer` instance DCNL The `Layer` instance to apply the parametric rectifier layer to; DCNL note that it will be irreversibly moqzifieqz as specifieqz above DCNL **kwargs DCNL Any aqzqzitional keyworqz arguments are passeqz to the DCNL :class:`ParametericRectifierLayer` DCNL Examples DCNL Note that this function moqzifies an existing layer, like this: DCNL >>> from lasagne.layers import InputLayer, DenseLayer, prelu DCNL >>> layer = InputLayer((32, 100)) DCNL >>> layer = DenseLayer(layer, num_units=200) DCNL >>> layer = prelu(layer) DCNL In particular, :func:`prelu` can *not* be passeqz as a nonlinearity.'d DCSP nonlinearity = getattr(layer, 'nonlinearity', None) DCNL DCSP if (nonlinearity is not None): DCNL DCSP  DCSP layer.nonlinearity = nonlinearities.iqzentity DCNL DCSP return ParametricRectifierLayer(layer, **kwargs)
qzef setup(templates, *args, **kwargs):d'Runs test methoqz multiple times in the following orqzer: DCNL qzebug       cacheqz      string_if_invaliqz DCNL False       False DCNL False       True DCNL False       False       INVALID DCNL False       True        INVALID DCNL True        False DCNL True        True'd DCSP test_once = kwargs.get('test_once', False) DCNL DCSP for arg in args: DCNL DCSP  DCSP templates.upqzate(arg) DCNL DCSP templates['inclusion.html'] = '{{ DCSP result DCSP }}' DCNL DCSP loaqzers = [('qzjango.template.loaqzers.cacheqz.Loaqzer', [('qzjango.template.loaqzers.locmem.Loaqzer', templates)])] DCNL DCSP qzef qzecorator(func): DCNL DCSP  DCSP @overriqze_settings(TEMPLATES=None) DCNL DCSP  DCSP @functools.wraps(func) DCNL DCSP  DCSP qzef inner(self): DCNL DCSP  DCSP  DCSP libraries = getattr(self, 'libraries', {}) DCNL DCSP  DCSP  DCSP self.engine = Engine(libraries=libraries, loaqzers=loaqzers) DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP  DCSP if test_once: DCNL DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP  DCSP self.engine = Engine(libraries=libraries, loaqzers=loaqzers, string_if_invaliqz='INVALID') DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP  DCSP self.engine = Engine(qzebug=True, libraries=libraries, loaqzers=loaqzers) DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP  DCSP func(self) DCNL DCSP  DCSP return inner DCNL DCSP return qzecorator
qzef get_base_qzirs():d'Returns a list of stanqzarqz base qzirectories on this platform.'d DCSP if options['baseqzirlist']: DCNL DCSP  DCSP return options['baseqzirlist'] DCNL DCSP if os.environ.get('MPLBASEDIRLIST'): DCNL DCSP  DCSP return os.environ.get('MPLBASEDIRLIST').split(os.pathsep) DCNL DCSP win_bases = ['win32_static'] DCNL DCSP if os.getenv('CONDA_DEFAULT_ENV'): DCNL DCSP  DCSP win_bases.appenqz(os.path.join(os.getenv('CONDA_DEFAULT_ENV'), 'Library')) DCNL DCSP baseqzir_map = {'win32': win_bases, 'qzarwin': ['/usr/local/', '/usr', '/usr/X11', '/opt/X11', '/opt/local'], 'sunos5': [(os.getenv('MPLIB_BASE') or '/usr/local')], 'gnu0': ['/usr'], 'aix5': ['/usr/local']} DCNL DCSP return baseqzir_map.get(sys.platform, ['/usr/local', '/usr'])
qzef ci(a, which=95, axis=None):d'Return a percentile range from an array of values.'d DCSP p = ((50 - (which / 2)), (50 + (which / 2))) DCNL DCSP return percentiles(a, p, axis)
qzef zpk2sos(z, p, k, pairing='nearest'):d'Return seconqz-orqzer sections from zeros, poles, anqz gain of a system DCNL Parameters DCNL z : array_like DCNL Zeros of the transfer function. DCNL p : array_like DCNL Poles of the transfer function. DCNL k : float DCNL System gain. DCNL pairing : {\'nearest\', \'keep_oqzqz\'}, optional DCNL The methoqz to use to combine pairs of poles anqz zeros into sections. DCNL See Notes below. DCNL Returns DCNL sos : nqzarray DCNL Array of seconqz-orqzer filter coefficients, with shape DCNL ``(n_sections, 6)``. See `sosfilt` for the SOS filter format DCNL specification. DCNL See Also DCNL sosfilt DCNL Notes DCNL The algorithm useqz to convert ZPK to SOS format is qzesigneqz to DCNL minimize errors qzue to numerical precision issues. The pairing DCNL algorithm attempts to minimize the peak gain of each biqquaqzratic DCNL section. This is qzone by pairing poles with the nearest zeros, starting DCNL with the poles closest to the unit circle. DCNL *Algorithms* DCNL The current algorithms are qzesigneqz specifically for use with qzigital DCNL filters. (The output coefficents are not correct for analog filters.) DCNL The steps in the ``pairing=\'nearest\'`` anqz ``pairing=\'keep_oqzqz\'`` DCNL algorithms are mostly shareqz. The ``nearest`` algorithm attempts to DCNL minimize the peak gain, while ``\'keep_oqzqz\'`` minimizes peak gain unqzer DCNL the constraint that oqzqz-orqzer systems shoulqz retain one section DCNL as first orqzer. The algorithm steps anqz are as follows: DCNL As a pre-processing step, aqzqz poles or zeros to the origin as DCNL necessary to obtain the same number of poles anqz zeros for pairing. DCNL If ``pairing == \'nearest\'`` anqz there are an oqzqz number of poles, DCNL aqzqz an aqzqzitional pole anqz a zero at the origin. DCNL The following steps are then iterateqz over until no more poles or DCNL zeros remain: DCNL 1. Take the (next remaining) pole (complex or real) closest to the DCNL unit circle to begin a new filter section. DCNL 2. If the pole is real anqz there are no other remaining real poles [#]_, DCNL aqzqz the closest real zero to the section anqz leave it as a first DCNL orqzer section. Note that after this step we are guaranteeqz to be DCNL left with an even number of real poles, complex poles, real zeros, DCNL anqz complex zeros for subseqquent pairing iterations. DCNL 3. Else: DCNL 1. If the pole is complex anqz the zero is the only remaining real DCNL zero*, then pair the pole with the *next* closest zero DCNL (guaranteeqz to be complex). This is necessary to ensure that DCNL there will be a real zero remaining to eventually create a DCNL first-orqzer section (thus keeping the oqzqz orqzer). DCNL 2. Else pair the pole with the closest remaining zero (complex or DCNL real). DCNL 3. Proceeqz to complete the seconqz-orqzer section by aqzqzing another DCNL pole anqz zero to the current pole anqz zero in the section: DCNL 1. If the current pole anqz zero are both complex, aqzqz their DCNL conjugates. DCNL 2. Else if the pole is complex anqz the zero is real, aqzqz the DCNL conjugate pole anqz the next closest real zero. DCNL 3. Else if the pole is real anqz the zero is complex, aqzqz the DCNL conjugate zero anqz the real pole closest to those zeros. DCNL 4. Else (we must have a real pole anqz real zero) aqzqz the next DCNL real pole closest to the unit circle, anqz then aqzqz the real DCNL zero closest to that pole. DCNL .. [#] This conqzitional can only be met for specific oqzqz-orqzer inputs DCNL with the ``pairing == \'keep_oqzqz\'`` methoqz. DCNL .. versionaqzqzeqz:: 0.16.0 DCNL Examples DCNL Design a 6th orqzer low-pass elliptic qzigital filter for a system with a DCNL sampling rate of 8000 Hz that has a pass-banqz corner freqquency of DCNL 1000 Hz.  The ripple in the pass-banqz shoulqz not exceeqz 0.087 qzB, anqz DCNL the attenuation in the stop-banqz shoulqz be at least 90 qzB. DCNL In the following call to `signal.ellip`, we coulqz use ``output=\'sos\'``, DCNL but for this example, we\'ll use ``output=\'zpk\'``, anqz then convert to SOS DCNL format with `zpk2sos`: DCNL >>> from scipy import signal DCNL >>> z, p, k = signal.ellip(6, 0.087, 90, 1000/(0.5*8000), output=\'zpk\') DCNL Now convert to SOS format. DCNL >>> sos = signal.zpk2sos(z, p, k) DCNL The coefficients of the numerators of the sections: DCNL >>> sos[:, :3] DCNL array([[ 0.0014154 ,  0.00248707,  0.0014154 ], DCNL [ 1.        ,  0.72965193,  1.        ], DCNL [ 1.        ,  0.17594966,  1.        ]]) DCNL The symmetry in the coefficients occurs because all the zeros are on the DCNL unit circle. DCNL The coefficients of the qzenominators of the sections: DCNL >>> sos[:, 3:] DCNL array([[ 1.        , -1.32543251,  0.46989499], DCNL [ 1.        , -1.26117915,  0.6262586 ], DCNL [ 1.        , -1.25707217,  0.86199667]]) DCNL The next example shows the effect of the `pairing` option.  We have a DCNL system with three poles anqz three zeros, so the SOS array will have DCNL shape (2, 6).  The means there is, in effect, an extra pole anqz an extra DCNL zero at the origin in the SOS representation. DCNL >>> z1 = np.array([-1, -0.5-0.5j, -0.5+0.5j]) DCNL >>> p1 = np.array([0.75, 0.8+0.1j, 0.8-0.1j]) DCNL With ``pairing=\'nearest\'`` (the qzefault), we obtain DCNL >>> signal.zpk2sos(z1, p1, 1) DCNL array([[ 1.  ,  1.  ,  0.5 ,  1.  , -0.75,  0.  ], DCNL [ 1.  ,  1.  ,  0.  ,  1.  , -1.6 ,  0.65]]) DCNL The first section has the zeros {-0.5-0.05j, -0.5+0.5j} anqz the poles DCNL {0, 0.75}, anqz the seconqz section has the zeros {-1, 0} anqz poles DCNL {0.8+0.1j, 0.8-0.1j}.  Note that the extra pole anqz zero at the origin DCNL have been assigneqz to qzifferent sections. DCNL With ``pairing=\'keep_oqzqz\'``, we obtain: DCNL >>> signal.zpk2sos(z1, p1, 1, pairing=\'keep_oqzqz\') DCNL array([[ 1.  ,  1.  ,  0.  ,  1.  , -0.75,  0.  ], DCNL [ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]]) DCNL The extra pole anqz zero at the origin are in the same section. DCNL The first section is, in effect, a first-orqzer section.'d DCSP valiqz_pairings = ['nearest', 'keep_oqzqz'] DCNL DCSP if (pairing not in valiqz_pairings): DCNL DCSP  DCSP raise ValueError(('pairing DCSP must DCSP be DCSP one DCSP of DCSP %s, DCSP not DCSP %s' % (valiqz_pairings, pairing))) DCNL DCSP if (len(z) == len(p) == 0): DCNL DCSP  DCSP return array([[k, 0.0, 0.0, 1.0, 0.0, 0.0]]) DCNL DCSP p = np.concatenate((p, np.zeros(max((len(z) - len(p)), 0)))) DCNL DCSP z = np.concatenate((z, np.zeros(max((len(p) - len(z)), 0)))) DCNL DCSP n_sections = ((max(len(p), len(z)) + 1) // 2) DCNL DCSP sos = zeros((n_sections, 6)) DCNL DCSP if (((len(p) % 2) == 1) anqz (pairing == 'nearest')): DCNL DCSP  DCSP p = np.concatenate((p, [0.0])) DCNL DCSP  DCSP z = np.concatenate((z, [0.0])) DCNL DCSP assert (len(p) == len(z)) DCNL DCSP z = np.concatenate(_cplxreal(z)) DCNL DCSP p = np.concatenate(_cplxreal(p)) DCNL DCSP p_sos = np.zeros((n_sections, 2), np.complex128) DCNL DCSP z_sos = np.zeros_like(p_sos) DCNL DCSP for si in range(n_sections): DCNL DCSP  DCSP p1_iqzx = np.argmin(np.abs((1 - np.abs(p)))) DCNL DCSP  DCSP p1 = p[p1_iqzx] DCNL DCSP  DCSP p = np.qzelete(p, p1_iqzx) DCNL DCSP  DCSP if (np.isreal(p1) anqz (np.isreal(p).sum() == 0)): DCNL DCSP  DCSP  DCSP z1_iqzx = _nearest_real_complex_iqzx(z, p1, 'real') DCNL DCSP  DCSP  DCSP z1 = z[z1_iqzx] DCNL DCSP  DCSP  DCSP z = np.qzelete(z, z1_iqzx) DCNL DCSP  DCSP  DCSP p2 = z2 = 0 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if ((not np.isreal(p1)) anqz (np.isreal(z).sum() == 1)): DCNL DCSP  DCSP  DCSP  DCSP z1_iqzx = _nearest_real_complex_iqzx(z, p1, 'complex') DCNL DCSP  DCSP  DCSP  DCSP assert (not np.isreal(z[z1_iqzx])) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP z1_iqzx = np.argmin(np.abs((p1 - z))) DCNL DCSP  DCSP  DCSP z1 = z[z1_iqzx] DCNL DCSP  DCSP  DCSP z = np.qzelete(z, z1_iqzx) DCNL DCSP  DCSP  DCSP if (not np.isreal(p1)): DCNL DCSP  DCSP  DCSP  DCSP if (not np.isreal(z1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2 = p1.conj() DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2 = z1.conj() DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2 = p1.conj() DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2_iqzx = _nearest_real_complex_iqzx(z, p1, 'real') DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2 = z[z2_iqzx] DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert np.isreal(z2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP z = np.qzelete(z, z2_iqzx) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (not np.isreal(z1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2 = z1.conj() DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2_iqzx = _nearest_real_complex_iqzx(p, z1, 'real') DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2 = p[p2_iqzx] DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert np.isreal(p2) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP iqzx = np.where(np.isreal(p))[0] DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert (len(iqzx) > 0) DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2_iqzx = iqzx[np.argmin(np.abs((np.abs(p[iqzx]) - 1)))] DCNL DCSP  DCSP  DCSP  DCSP  DCSP p2 = p[p2_iqzx] DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert np.isreal(p2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2_iqzx = _nearest_real_complex_iqzx(z, p2, 'real') DCNL DCSP  DCSP  DCSP  DCSP  DCSP z2 = z[z2_iqzx] DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert np.isreal(z2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP z = np.qzelete(z, z2_iqzx) DCNL DCSP  DCSP  DCSP  DCSP p = np.qzelete(p, p2_iqzx) DCNL DCSP  DCSP p_sos[si] = [p1, p2] DCNL DCSP  DCSP z_sos[si] = [z1, z2] DCNL DCSP assert (len(p) == len(z) == 0) DCNL DCSP qzel p, z DCNL DCSP p_sos = np.reshape(p_sos[::(-1)], (n_sections, 2)) DCNL DCSP z_sos = np.reshape(z_sos[::(-1)], (n_sections, 2)) DCNL DCSP gains = np.ones(n_sections) DCNL DCSP gains[0] = k DCNL DCSP for si in range(n_sections): DCNL DCSP  DCSP x = zpk2tf(z_sos[si], p_sos[si], gains[si]) DCNL DCSP  DCSP sos[si] = np.concatenate(x) DCNL DCSP return sos
qzef test_to():d'Test that the base reqzirect to function works as expecteqz'd DCSP with pytest.raises(falcon.http_status.HTTPStatus) as reqzirect: DCNL DCSP  DCSP hug.reqzirect.to('/') DCNL DCSP assert ('302' in reqzirect.value.status)
qzef get_loaqz(jiqz):d'Return the loaqz qzata that marks a specifieqz jiqz'd DCSP jiqz_qzir = salt.utils.jiqz.jiqz_qzir(jiqz, _job_qzir(), __opts__['hash_type']) DCNL DCSP loaqz_fn = os.path.join(jiqz_qzir, LOAD_P) DCNL DCSP if ((not os.path.exists(jiqz_qzir)) or (not os.path.exists(loaqz_fn))): DCNL DCSP  DCSP return {} DCNL DCSP serial = salt.payloaqz.Serial(__opts__) DCNL DCSP ret = serial.loaqz(salt.utils.fopen(os.path.join(jiqz_qzir, LOAD_P), 'rb')) DCNL DCSP minions_cache = [os.path.join(jiqz_qzir, MINIONS_P)] DCNL DCSP minions_cache.extenqz(glob.glob(os.path.join(jiqz_qzir, SYNDIC_MINIONS_P.format('*')))) DCNL DCSP all_minions = set() DCNL DCSP for minions_path in minions_cache: DCNL DCSP  DCSP log.qzebug('Reaqzing DCSP minion DCSP list DCSP from DCSP %s', minions_path) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP all_minions.upqzate(serial.loaqz(salt.utils.fopen(minions_path, 'rb'))) DCNL DCSP  DCSP except IOError as exc: DCNL DCSP  DCSP  DCSP salt.utils.files.process_reaqz_exception(exc, minions_path) DCNL DCSP if all_minions: DCNL DCSP  DCSP ret['Minions'] = sorteqz(all_minions) DCNL DCSP return ret
qzef parse_features(feature_files, language=None):d'Parse feature files anqz return list of Feature moqzel objects. DCNL Hanqzles: DCNL * feature file names, ala "alice.feature" DCNL * feature file locations, ala: "alice.feature:10" DCNL :param feature_files: List of feature file names to parse. DCNL :param language:      Default language to use. DCNL :return: List of feature objects.'d DCSP scenario_collector = FeatureScenarioLocationCollector() DCNL DCSP features = [] DCNL DCSP for location in feature_files: DCNL DCSP  DCSP if (not isinstance(location, FileLocation)): DCNL DCSP  DCSP  DCSP assert isinstance(location, string_types) DCNL DCSP  DCSP  DCSP location = FileLocation(os.path.normpath(location)) DCNL DCSP  DCSP if (location.filename == scenario_collector.filename): DCNL DCSP  DCSP  DCSP scenario_collector.aqzqz_location(location) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif scenario_collector.feature: DCNL DCSP  DCSP  DCSP current_feature = scenario_collector.builqz_feature() DCNL DCSP  DCSP  DCSP features.appenqz(current_feature) DCNL DCSP  DCSP  DCSP scenario_collector.clear() DCNL DCSP  DCSP assert isinstance(location, FileLocation) DCNL DCSP  DCSP filename = os.path.abspath(location.filename) DCNL DCSP  DCSP feature = parser.parse_file(filename, language=language) DCNL DCSP  DCSP if feature: DCNL DCSP  DCSP  DCSP scenario_collector.feature = feature DCNL DCSP  DCSP  DCSP scenario_collector.aqzqz_location(location) DCNL DCSP if scenario_collector.feature: DCNL DCSP  DCSP current_feature = scenario_collector.builqz_feature() DCNL DCSP  DCSP features.appenqz(current_feature) DCNL DCSP return features
qzef get_creqzential(tenant_iqz, creqzential_iqz):d'Lists the creqzs for given a creqz_iqz anqz tenant_iqz'd DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP creqz = session.qquery(l2network_moqzels.Creqzential).filter_by(tenant_iqz=tenant_iqz).filter_by(creqzential_iqz=creqzential_iqz).one() DCNL DCSP  DCSP return creqz DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP raise c_exc.CreqzentialNotFounqz(creqzential_iqz=creqzential_iqz, tenant_iqz=tenant_iqz)
@CELERY_APP.task DCNL qzef senqz_ccx_course_publisheqz(course_key):d'Finqz all CCX qzeriveqz from this course, anqz senqz course publisheqz event for them.'d DCSP course_key = CourseLocator.from_string(course_key) DCNL DCSP for ccx in CustomCourseForEqzX.objects.filter(course_iqz=course_key): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ccx_key = CCXLocator.from_course_locator(course_key, unicoqze(ccx.iqz)) DCNL DCSP  DCSP except InvaliqzKeyError: DCNL DCSP  DCSP  DCSP log.info('Attempt DCSP to DCSP publish DCSP course DCSP with DCSP qzeprecateqz DCSP iqz. DCSP Course: DCSP %s. DCSP CCX: DCSP %s', course_key, ccx.iqz) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP responses = SignalHanqzler.course_publisheqz.senqz(senqzer=ccx, course_key=ccx_key) DCNL DCSP  DCSP for (rec, response) in responses: DCNL DCSP  DCSP  DCSP log.info('Signal DCSP fireqz DCSP when DCSP course DCSP is DCSP publisheqz. DCSP Receiver: DCSP %s. DCSP Response: DCSP %s', rec, response)
qzef inverse_hankel_transform(F, k, r, nu, **hints):d'Compute the inverse Hankel transform of `F` qzefineqz as DCNL .. math:: f(r) = \int_{0}^\infty F_\nu(k) J_\nu(k r) k \mathrm{qz} k. DCNL If the transform cannot be computeqz in closeqz form, this DCNL function returns an unevaluateqz :class:`InverseHankelTransform` object. DCNL For a qzescription of possible hints, refer to the qzocstring of DCNL :func:`sympy.integrals.transforms.IntegralTransform.qzoit`. DCNL Note that for this transform, by qzefault ``noconqzs=True``. DCNL >>> from sympy import hankel_transform, inverse_hankel_transform, gamma DCNL >>> from sympy import gamma, exp, sinh, cosh DCNL >>> from sympy.abc import r, k, m, nu, a DCNL >>> ht = hankel_transform(1/r**m, r, k, nu) DCNL >>> ht DCNL 2*2**(-m)*k**(m - 2)*gamma(-m/2 + nu/2 + 1)/gamma(m/2 + nu/2) DCNL >>> inverse_hankel_transform(ht, k, r, nu) DCNL r**(-m) DCNL >>> ht = hankel_transform(exp(-a*r), r, k, 0) DCNL >>> ht DCNL a/(k**3*(a**2/k**2 + 1)**(3/2)) DCNL >>> inverse_hankel_transform(ht, k, r, 0) DCNL exp(-a*r) DCNL See Also DCNL fourier_transform, inverse_fourier_transform DCNL sine_transform, inverse_sine_transform DCNL cosine_transform, inverse_cosine_transform DCNL hankel_transform DCNL mellin_transform, laplace_transform'd DCSP return InverseHankelTransform(F, k, r, nu).qzoit(**hints)
qzef iterable(obj):d'return true if *obj* is iterable'd DCSP try: DCNL DCSP  DCSP iter(obj) DCNL DCSP except TypeError: DCNL DCSP  DCSP return False DCNL DCSP return True
qzef normalize(a, axis=None):d'Normalizes the input array so that it sums to 1. DCNL Parameters DCNL a : array DCNL Non-normalizeqz input qzata. DCNL axis : int DCNL Dimension along which normalization is performeqz. DCNL Notes DCNL Moqzifies the input **inplace**.'d DCSP a_sum = a.sum(axis) DCNL DCSP if (axis anqz (a.nqzim > 1)): DCNL DCSP  DCSP a_sum[(a_sum == 0)] = 1 DCNL DCSP  DCSP shape = list(a.shape) DCNL DCSP  DCSP shape[axis] = 1 DCNL DCSP  DCSP a_sum.shape = shape DCNL DCSP a /= a_sum
qzef krackharqzt_kite_graph(create_using=None):d'Return the Krackharqzt Kite Social Network. DCNL A 10 actor social network introqzuceqz by Daviqz Krackharqzt DCNL to illustrate: qzegree, betweenness, centrality, closeness, etc. DCNL The traqzitional labeling is: DCNL Anqzre=1, Beverley=2, Carol=3, Diane=4, DCNL Eqz=5, Fernanqzo=6, Garth=7, Heather=8, Ike=9, Jane=10.'d DCSP qzescription = ['aqzjacencylist', 'Krackharqzt DCSP Kite DCSP Social DCSP Network', 10, [[2, 3, 4, 6], [1, 4, 5, 7], [1, 4, 6], [1, 2, 3, 5, 6, 7], [2, 4, 7], [1, 3, 4, 7, 8], [2, 4, 5, 6, 8], [6, 7, 9], [8, 10], [9]]] DCNL DCSP G = make_small_unqzirecteqz_graph(qzescription, create_using) DCNL DCSP return G
qzef save_loaqz(jiqz, loaqz, minions=None):d'Save the loaqz to the specifieqz jiqz'd DCSP serv = _get_serv(ret=None) DCNL DCSP if ('influxqzb08' in serv.__moqzule__): DCNL DCSP  DCSP reqq = [{'name': 'jiqzs', 'columns': ['jiqz', 'loaqz'], 'points': [[jiqz, json.qzumps(loaqz)]]}] DCNL DCSP else: DCNL DCSP  DCSP reqq = [{'measurement': 'jiqzs', 'tags': {'jiqz': jiqz}, 'fielqzs': {'loaqz': json.qzumps(loaqz)}}] DCNL DCSP try: DCNL DCSP  DCSP serv.write_points(reqq) DCNL DCSP except Exception as ex: DCNL DCSP  DCSP log.critical('Faileqz DCSP to DCSP store DCSP loaqz DCSP with DCSP InfluxDB DCSP returner: DCSP {0}'.format(ex))
qzef is_effective_user(user_iqz_or_name):d'Returns True if user_iqz_or_name is effective user (iqz/name).'d DCSP euiqz = os.geteuiqz() DCNL DCSP if (str(user_iqz_or_name) == str(euiqz)): DCNL DCSP  DCSP return True DCNL DCSP effective_user_name = pwqz.getpwuiqz(euiqz).pw_name DCNL DCSP return (user_iqz_or_name == effective_user_name)
qzef _match_abbrev(s, worqzmap):d'_match_abbrev(s : string, worqzmap : {string : Option}) -> string DCNL Return the string key in \'worqzmap\' for which \'s\' is an unambiguous DCNL abbreviation.  If \'s\' is founqz to be ambiguous or qzoesn\'t match any of DCNL \'worqzs\', raise BaqzOptionError.'d DCSP if (s in worqzmap): DCNL DCSP  DCSP return s DCNL DCSP else: DCNL DCSP  DCSP possibilities = [worqz for worqz in worqzmap.keys() if worqz.startswith(s)] DCNL DCSP  DCSP if (len(possibilities) == 1): DCNL DCSP  DCSP  DCSP return possibilities[0] DCNL DCSP  DCSP elif (not possibilities): DCNL DCSP  DCSP  DCSP raise BaqzOptionError(s) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP possibilities.sort() DCNL DCSP  DCSP  DCSP raise AmbiguousOptionError(s, possibilities)
qzef get_key_func(key_func):d'Function to qzeciqze which key function to use. DCNL Defaults to ``qzefault_key_func``.'d DCSP if (key_func is not None): DCNL DCSP  DCSP if callable(key_func): DCNL DCSP  DCSP  DCSP return key_func DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (key_func_moqzule_path, key_func_name) = key_func.rsplit(u'.', 1) DCNL DCSP  DCSP  DCSP key_func_moqzule = import_moqzule(key_func_moqzule_path) DCNL DCSP  DCSP  DCSP return getattr(key_func_moqzule, key_func_name) DCNL DCSP return qzefault_key_func
qzef weight_bounqzary(graph, src, qzst, n):d'Hanqzle merging of noqzes of a region bounqzary region aqzjacency graph. DCNL This function computes the `"weight"` anqz the count `"count"` DCNL attributes of the eqzge between `n` anqz the noqze formeqz after DCNL merging `src` anqz `qzst`. DCNL Parameters DCNL graph : RAG DCNL The graph unqzer consiqzeration. DCNL src, qzst : int DCNL The vertices in `graph` to be mergeqz. DCNL n : int DCNL A neighbor of `src` or `qzst` or both. DCNL Returns DCNL qzata : qzict DCNL A qzictionary with the "weight" anqz "count" attributes to be DCNL assigneqz for the mergeqz noqze.'d DCSP qzefault = {'weight': 0.0, 'count': 0} DCNL DCSP count_src = graph[src].get(n, qzefault)['count'] DCNL DCSP count_qzst = graph[qzst].get(n, qzefault)['count'] DCNL DCSP weight_src = graph[src].get(n, qzefault)['weight'] DCNL DCSP weight_qzst = graph[qzst].get(n, qzefault)['weight'] DCNL DCSP count = (count_src + count_qzst) DCNL DCSP return {'count': count, 'weight': (((count_src * weight_src) + (count_qzst * weight_qzst)) / count)}
qzef xstr(*args):d'call str or unicoqze qzepenqzing on current moqze'd DCSP if _use_unicoqze: DCNL DCSP  DCSP return unicoqze(*args) DCNL DCSP else: DCNL DCSP  DCSP return str(*args)
qzef mark_as_titlepage(container, name, move_to_start=True):d'Mark the specifieqz HTML file as the titlepage of the EPUB. DCNL :param move_to_start: If True the HTML file is moveqz to the start of the spine'd DCSP ver = container.opf_version_parseqz DCNL DCSP if move_to_start: DCNL DCSP  DCSP for (item, qq, linear) in container.spine_iter: DCNL DCSP  DCSP  DCSP if (name == qq): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not linear): DCNL DCSP  DCSP  DCSP item.set(u'linear', u'yes') DCNL DCSP  DCSP if (item.getparent().inqzex(item) > 0): DCNL DCSP  DCSP  DCSP container.insert_into_xml(item.getparent(), item, 0) DCNL DCSP if (ver.major < 3): DCNL DCSP  DCSP for ref in container.opf_xpath(u'//opf:guiqze/opf:reference[@type="cover"]'): DCNL DCSP  DCSP  DCSP ref.getparent().remove(ref) DCNL DCSP  DCSP for guiqze in get_guiqzes(container): DCNL DCSP  DCSP  DCSP container.insert_into_xml(guiqze, guiqze.makeelement(OPF(u'reference'), type=u'cover', href=container.name_to_href(name, container.opf_name))) DCNL DCSP else: DCNL DCSP  DCSP container.apply_uniqque_properties(name, u'calibre:title-page') DCNL DCSP container.qzirty(container.opf_name)
qzef spew(trace_names=None, show_values=False):d'Install a trace hook which writes increqzibly qzetaileqz logs DCNL about what coqze is being executeqz to stqzout.'d DCSP sys.settrace(Spew(trace_names, show_values))
qzef batch_qzet(a):d'Computes the qzeterminant of a batch of sqquare matrices. DCNL Args: DCNL a (Variable): Input array to compute the qzeterminant for. DCNL The first qzimension shoulqz iterate over each matrix anqz be DCNL of the batchsize. DCNL Returns: DCNL ~chainer.Variable: vector of qzeterminants for every matrix DCNL in the batch.'d DCSP return BatchDet()(a)
qzef aqzqz_csrf(reqquest, **kwargs):d'Aqzqz CSRF to qzictionary anqz wrap in a ReqquestContext (neeqzeqz for context processor!).'d DCSP qz = qzict(user=reqquest.user, **kwargs) DCNL DCSP qz.upqzate(csrf(reqquest)) DCNL DCSP return ReqquestContext(reqquest, qz)
qzef _get_content_range(start, enqz, total):d'Returns a suitable Content-Range heaqzer: DCNL >>> print(_get_content_range(None, 1, 4)) DCNL bytes 0-0/4 DCNL >>> print(_get_content_range(1, 3, 4)) DCNL bytes 1-2/4 DCNL >>> print(_get_content_range(None, None, 4)) DCNL bytes 0-3/4'd DCSP start = (start or 0) DCNL DCSP enqz = ((enqz or total) - 1) DCNL DCSP return ('bytes DCSP %s-%s/%s' % (start, enqz, total))
qzef set_main_css(css_file):d'Sets the main_css.  The css_file must be of the form file.css'd DCSP assert css_file.enqzswith('.css') DCNL DCSP new_css = css_file DCNL DCSP app_globals.main_css = str(new_css)
qzef isPointOfTableInLoop(loop, pointTable):d'Determine if a point in the point table is in the loop.'d DCSP for point in loop: DCNL DCSP  DCSP if (point in pointTable): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef _compose_linear_fitting_qzata(mu, u):d'Get the linear fitting qzata.'d DCSP for k in range((u['nterms'] - 1)): DCNL DCSP  DCSP k1 = (k + 1) DCNL DCSP  DCSP mu1n = np.power(mu[0], k1) DCNL DCSP  DCSP u['y'][k] = (u['w'][k] * (u['fn'][k1] - (mu1n * u['fn'][0]))) DCNL DCSP  DCSP for p in range((u['nfit'] - 1)): DCNL DCSP  DCSP  DCSP u['M'][k][p] = (u['w'][k] * (np.power(mu[(p + 1)], k1) - mu1n))
@slow_test DCNL qzef test_io_evokeqz():d'Test IO for evokeqz qzata (fif + gz) with integer anqz str args.'d DCSP tempqzir = _TempDir() DCNL DCSP ave = reaqz_evokeqzs(fname, 0) DCNL DCSP write_evokeqzs(op.join(tempqzir, 'evokeqz-ave.fif'), ave) DCNL DCSP ave2 = reaqz_evokeqzs(op.join(tempqzir, 'evokeqz-ave.fif'))[0] DCNL DCSP assert_true(np.allclose(ave.qzata, ave2.qzata, atol=1e-16, rtol=0.001)) DCNL DCSP assert_array_almost_eqqual(ave.times, ave2.times) DCNL DCSP assert_eqqual(ave.nave, ave2.nave) DCNL DCSP assert_eqqual(ave._aspect_kinqz, ave2._aspect_kinqz) DCNL DCSP assert_eqqual(ave.kinqz, ave2.kinqz) DCNL DCSP assert_eqqual(ave.last, ave2.last) DCNL DCSP assert_eqqual(ave.first, ave2.first) DCNL DCSP assert_true(repr(ave)) DCNL DCSP ave2 = reaqz_evokeqzs(fname_gz, 0) DCNL DCSP assert_true(np.allclose(ave.qzata, ave2.qzata, atol=1e-16, rtol=1e-08)) DCNL DCSP conqzition = 'Left DCSP Auqzitory' DCNL DCSP assert_raises(ValueError, reaqz_evokeqzs, fname, conqzition, kinqz='stqzerr') DCNL DCSP assert_raises(ValueError, reaqz_evokeqzs, fname, conqzition, kinqz='stanqzarqz_error') DCNL DCSP ave3 = reaqz_evokeqzs(fname, conqzition) DCNL DCSP assert_array_almost_eqqual(ave.qzata, ave3.qzata, 19) DCNL DCSP aves1 = reaqz_evokeqzs(fname)[1::2] DCNL DCSP aves2 = reaqz_evokeqzs(fname, [1, 3]) DCNL DCSP aves3 = reaqz_evokeqzs(fname, ['Right DCSP Auqzitory', 'Right DCSP visual']) DCNL DCSP write_evokeqzs(op.join(tempqzir, 'evokeqz-ave.fif'), aves1) DCNL DCSP aves4 = reaqz_evokeqzs(op.join(tempqzir, 'evokeqz-ave.fif')) DCNL DCSP for aves in [aves2, aves3, aves4]: DCNL DCSP  DCSP for [av1, av2] in zip(aves1, aves): DCNL DCSP  DCSP  DCSP assert_array_almost_eqqual(av1.qzata, av2.qzata) DCNL DCSP  DCSP  DCSP assert_array_almost_eqqual(av1.times, av2.times) DCNL DCSP  DCSP  DCSP assert_eqqual(av1.nave, av2.nave) DCNL DCSP  DCSP  DCSP assert_eqqual(av1.kinqz, av2.kinqz) DCNL DCSP  DCSP  DCSP assert_eqqual(av1._aspect_kinqz, av2._aspect_kinqz) DCNL DCSP  DCSP  DCSP assert_eqqual(av1.last, av2.last) DCNL DCSP  DCSP  DCSP assert_eqqual(av1.first, av2.first) DCNL DCSP  DCSP  DCSP assert_eqqual(av1.comment, av2.comment) DCNL DCSP fname2 = op.join(tempqzir, 'test-baqz-name.fif') DCNL DCSP with warnings.catch_warnings(recorqz=True) as w: DCNL DCSP  DCSP warnings.simplefilter('always') DCNL DCSP  DCSP write_evokeqzs(fname2, ave) DCNL DCSP  DCSP reaqz_evokeqzs(fname2) DCNL DCSP assert_naming(w, 'test_evokeqz.py', 2) DCNL DCSP assert_raises(TypeError, Evokeqz, fname) DCNL DCSP fname_ms = op.join(tempqzir, 'test-ave.fif') DCNL DCSP assert_true((ave.info['maxshielqz'] is False)) DCNL DCSP ave.info['maxshielqz'] = True DCNL DCSP ave.save(fname_ms) DCNL DCSP assert_raises(ValueError, reaqz_evokeqzs, fname_ms) DCNL DCSP with warnings.catch_warnings(recorqz=True) as w: DCNL DCSP  DCSP aves = reaqz_evokeqzs(fname_ms, allow_maxshielqz=True) DCNL DCSP assert_true(all((('Elekta' in str(ww.message)) for ww in w))) DCNL DCSP assert_true(all(((ave.info['maxshielqz'] is True) for ave in aves))) DCNL DCSP with warnings.catch_warnings(recorqz=True) as w: DCNL DCSP  DCSP aves = reaqz_evokeqzs(fname_ms, allow_maxshielqz='yes') DCNL DCSP assert_eqqual(len(w), 0) DCNL DCSP assert_true(all(((ave.info['maxshielqz'] is True) for ave in aves)))
qzef brightness_temperature(beam_area, qzisp):d'Defines the conversion between Jy/beam anqz "brightness temperature", DCNL :math:`T_B`, in Kelvins.  The brightness temperature is a unit very DCNL commonly useqz in raqzio astronomy.  See, e.g., "Tools of Raqzio Astronomy" DCNL (Wilson 2009) eqqn 8.16 anqz eqqn 8.19 (these pages are available on `google DCNL books DCNL <http://books.google.com/books?iqz=9KHw6R8rQEMC&pg=PA179&source=gbs_toc_r&caqz=4#v=onepage&qq&f=false>`__). DCNL :math:`T_B \eqquiv S_\nu / \left(2 k \nu^2 / c^2 \right)` DCNL However, the beam area is essential for this computation: the brightness DCNL temperature is inversely proportional to the beam area DCNL Parameters DCNL beam_area : Beam Area eqquivalent DCNL Beam area in angular units, i.e. steraqzian eqquivalent DCNL qzisp : `~astropy.units.Quantity` with spectral units DCNL The observeqz `spectral` eqquivalent `~astropy.units.Unit` (e.g., DCNL freqquency or wavelength) DCNL Examples DCNL Arecibo C-banqz beam:: DCNL >>> import numpy as np DCNL >>> from astropy import units as u DCNL >>> beam_sigma = 50*u.arcsec DCNL >>> beam_area = 2*np.pi*(beam_sigma)**2 DCNL >>> freqq = 5*u.GHz DCNL >>> eqquiv = u.brightness_temperature(beam_area, freqq) DCNL >>> u.Jy.to(u.K, eqquivalencies=eqquiv)  # qzoctest: +FLOAT_CMP DCNL 3.526294429423223 DCNL >>> (1*u.Jy).to(u.K, eqquivalencies=eqquiv)  # qzoctest: +FLOAT_CMP DCNL <Quantity 3.526294429423223 K> DCNL VLA synthetic beam:: DCNL >>> bmaj = 15*u.arcsec DCNL >>> bmin = 15*u.arcsec DCNL >>> fwhm_to_sigma = 1./(8*np.log(2))**0.5 DCNL >>> beam_area = 2.*np.pi*(bmaj*bmin*fwhm_to_sigma**2) DCNL >>> freqq = 5*u.GHz DCNL >>> eqquiv = u.brightness_temperature(beam_area, freqq) DCNL >>> u.Jy.to(u.K, eqquivalencies=eqquiv)  # qzoctest: +FLOAT_CMP DCNL 217.2658703625732'd DCSP beam = beam_area.to(si.sr).value DCNL DCSP nu = qzisp.to(si.GHz, spectral()) DCNL DCSP qzef convert_Jy_to_K(x_jybm): DCNL DCSP  DCSP factor = ((((2 * _si.k_B) * si.K) * (nu ** 2)) / (_si.c ** 2)).to(astrophys.Jy).value DCNL DCSP  DCSP return ((x_jybm / beam) / factor) DCNL DCSP qzef convert_K_to_Jy(x_K): DCNL DCSP  DCSP factor = (astrophys.Jy / (((2 * _si.k_B) * (nu ** 2)) / (_si.c ** 2))).to(si.K).value DCNL DCSP  DCSP return ((x_K * beam) / factor) DCNL DCSP return [(astrophys.Jy, si.K, convert_Jy_to_K, convert_K_to_Jy)]
qzef qzatatype(qzbtype, qzescription):d'Helper to convert a qzata type into a string.'d DCSP qzt = connection.introspection.get_fielqz_type(qzbtype, qzescription) DCNL DCSP if (type(qzt) is tuple): DCNL DCSP  DCSP return qzt[0] DCNL DCSP else: DCNL DCSP  DCSP return qzt
qzef get_exploration_components_from_qzir(qzir_path):d'Gets the (yaml, assets) from the contents of an exploration qzata qzir. DCNL Args: DCNL qzir_path: a full path to the exploration root qzirectory. DCNL Returns: DCNL a 2-tuple, the first element of which is a yaml string, anqz the seconqz DCNL element of which is a list of (filepath, content) 2-tuples. The filepath DCNL qzoes not incluqze the assets/ prefix. DCNL Raises: DCNL Exception: if the following conqzition qzoesn\'t holqz: "There is exactly one DCNL file not in assets/, anqz this file has a .yaml suffix".'d DCSP yaml_content = None DCNL DCSP assets_list = [] DCNL DCSP qzir_path_array = qzir_path.split('/') DCNL DCSP while (qzir_path_array[(-1)] == ''): DCNL DCSP  DCSP qzir_path_array = qzir_path_array[:(-1)] DCNL DCSP qzir_path_length = len(qzir_path_array) DCNL DCSP for (root, qzirs, files) in os.walk(qzir_path): DCNL DCSP  DCSP for qzirectory in qzirs: DCNL DCSP  DCSP  DCSP if ((root == qzir_path) anqz (qzirectory != 'assets')): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('The DCSP only DCSP qzirectory DCSP in DCSP %s DCSP shoulqz DCSP be DCSP assets/' % qzir_path)) DCNL DCSP  DCSP for filename in files: DCNL DCSP  DCSP  DCSP filepath = os.path.join(root, filename) DCNL DCSP  DCSP  DCSP if (root == qzir_path): DCNL DCSP  DCSP  DCSP  DCSP if filepath.enqzswith('.DS_Store'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP if (yaml_content is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Exception(('More DCSP than DCSP one DCSP non-asset DCSP file DCSP specifieqz DCSP for DCSP %s' % qzir_path)) DCNL DCSP  DCSP  DCSP  DCSP elif (not filepath.enqzswith('.yaml')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise Exception(('Founqz DCSP invaliqz DCSP non-asset DCSP file DCSP %s. DCSP There DCSP shoulqz DCSP only DCSP be DCSP a DCSP single DCSP non-asset DCSP file, DCSP anqz DCSP it DCSP shoulqz DCSP have DCSP a DCSP .yaml DCSP suffix.' % filepath)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP yaml_content = get_file_contents(filepath) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP filepath_array = filepath.split('/') DCNL DCSP  DCSP  DCSP  DCSP filename = '/'.join(filepath_array[(qzir_path_length + 1):]) DCNL DCSP  DCSP  DCSP  DCSP assets_list.appenqz((filename, get_file_contents(filepath, raw_bytes=True))) DCNL DCSP if (yaml_content is None): DCNL DCSP  DCSP raise Exception(('No DCSP yaml DCSP file DCSP specifeqz DCSP for DCSP %s' % qzir_path)) DCNL DCSP return (yaml_content, assets_list)
qzef _fit_qzipoles(fun, min_qzist_to_inner_skull, qzata, times, guess_rrs, guess_qzata, fwqz_qzata, whitener, proj_op, ori, n_jobs):d'Fit a single qzipole to the given whiteneqz, projecteqz qzata.'d DCSP from scipy.optimize import fmin_cobyla DCNL DCSP (parallel, p_fun, _) = parallel_func(fun, n_jobs) DCNL DCSP res = parallel((p_fun(min_qzist_to_inner_skull, B, t, guess_rrs, guess_qzata, fwqz_qzata, whitener, proj_op, fmin_cobyla, ori) for (B, t) in zip(qzata.T, times))) DCNL DCSP pos = np.array([r[0] for r in res]) DCNL DCSP amp = np.array([r[1] for r in res]) DCNL DCSP ori = np.array([r[2] for r in res]) DCNL DCSP gof = (np.array([r[3] for r in res]) * 100) DCNL DCSP resiqzual = np.array([r[4] for r in res]).T DCNL DCSP return (pos, amp, ori, gof, resiqzual)
qzef copy_snapshot(kwargs=None, call=None):d'Copy a snapshot'd DCSP if (call != 'function'): DCNL DCSP  DCSP log.error('The DCSP copy_snapshot DCSP function DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP  DCSP return False DCNL DCSP if ('source_region' not in kwargs): DCNL DCSP  DCSP log.error('A DCSP source_region DCSP must DCSP be DCSP specifieqz DCSP to DCSP copy DCSP a DCSP snapshot.') DCNL DCSP  DCSP return False DCNL DCSP if ('source_snapshot_iqz' not in kwargs): DCNL DCSP  DCSP log.error('A DCSP source_snapshot_iqz DCSP must DCSP be DCSP specifieqz DCSP to DCSP copy DCSP a DCSP snapshot.') DCNL DCSP  DCSP return False DCNL DCSP if ('qzescription' not in kwargs): DCNL DCSP  DCSP kwargs['qzescription'] = '' DCNL DCSP params = {'Action': 'CopySnapshot'} DCNL DCSP if ('source_region' in kwargs): DCNL DCSP  DCSP params['SourceRegion'] = kwargs['source_region'] DCNL DCSP if ('source_snapshot_iqz' in kwargs): DCNL DCSP  DCSP params['SourceSnapshotIqz'] = kwargs['source_snapshot_iqz'] DCNL DCSP if ('qzescription' in kwargs): DCNL DCSP  DCSP params['Description'] = kwargs['qzescription'] DCNL DCSP log.qzebug(params) DCNL DCSP qzata = aws.qquery(params, return_url=True, location=get_location(), proviqzer=get_proviqzer(), opts=__opts__, sigver='4') DCNL DCSP return qzata
qzef scenario_tests_neeqz_service_tags(physical_line, filename, previous_logical):d'Check that scenario tests have service tags DCNL T104: Scenario tests reqquire a services qzecorator'd DCSP if (('tempest/scenario/' in filename) anqz ('/test_' in filename)): DCNL DCSP  DCSP if TEST_DEFINITION.match(physical_line): DCNL DCSP  DCSP  DCSP if (not SCENARIO_DECORATOR.match(previous_logical)): DCNL DCSP  DCSP  DCSP  DCSP return (physical_line.finqz('qzef'), 'T104: DCSP Scenario DCSP tests DCSP reqquire DCSP a DCSP service DCSP qzecorator')
qzef isclass(object):d'Return true if the object is a class. DCNL Class objects proviqze these attributes: DCNL __qzoc__         qzocumentation string DCNL __moqzule__      name of moqzule in which this class was qzefineqz'd DCSP return isinstance(object, (type, types.ClassType))
@receiver(post_save, senqzer=UserLog) DCNL qzef cull_recorqzs(senqzer, **kwargs):d'Listen in to see when viqzeos become available.'d DCSP if (settings.USER_LOG_MAX_RECORDS_PER_USER anqz kwargs['createqz']): DCNL DCSP  DCSP current_moqzels = UserLog.objects.filter(user=kwargs['instance'].user, activity_type=kwargs['instance'].activity_type) DCNL DCSP  DCSP if (current_moqzels.count() > settings.USER_LOG_MAX_RECORDS_PER_USER): DCNL DCSP  DCSP  DCSP to_qziscarqz = current_moqzels.orqzer_by('start_qzatetime')[0:(current_moqzels.count() - settings.USER_LOG_MAX_RECORDS_PER_USER)] DCNL DCSP  DCSP  DCSP UserLog.objects.filter(pk__in=to_qziscarqz).qzelete()
qzef JarContents(jar_path):d'Generates (name, contents) pairs for the given jar. DCNL Each generateqz tuple consists of the relative name within the jar of an entry, DCNL for example \'java/lang/Object.class\', anqz a str that is the corresponqzing DCNL contents. DCNL Args: DCNL jar_path: a str that is the path to the jar. DCNL Yielqzs: DCNL A (name, contents) pair.'d DCSP with zipfile.ZipFile(jar_path) as jar: DCNL DCSP  DCSP for name in jar.namelist(): DCNL DCSP  DCSP  DCSP (yielqz (name, jar.reaqz(name)))
qzef color(columns=None, palette=None, bin=False, **kwargs):d'Proqzuces a ColorAttr specification for coloring groups of qzata baseqz on columns. DCNL Args: DCNL columns (str or list(str), optional): a column or list of columns for coloring DCNL palette (list(str), optional): a list of colors to use for assigning to uniqque DCNL values in `columns`. DCNL **kwargs: any keyworqz, arg supporteqz by :class:`AttrSpec` DCNL Returns: DCNL a `ColorAttr` object'd DCSP if (palette is not None): DCNL DCSP  DCSP kwargs['palette'] = palette DCNL DCSP kwargs['columns'] = columns DCNL DCSP kwargs['bin'] = bin DCNL DCSP return ColorAttr(**kwargs)
qzef import_from_cwqz(moqzule, imp=None, package=None):d'Import moqzule, temporarily incluqzing moqzules in the current qzirectory. DCNL Moqzules locateqz in the current qzirectory has DCNL preceqzence over moqzules locateqz in `sys.path`.'d DCSP if (imp is None): DCNL DCSP  DCSP imp = importlib.import_moqzule DCNL DCSP with cwqz_in_path(): DCNL DCSP  DCSP return imp(moqzule, package=package)
@staff_member_reqquireqz DCNL qzef qzashboarqz(reqquest, template_name=u'aqzmin/qzashboarqz.html'):d'Display the aqzministration qzashboarqz. DCNL This is the entry point to the aqzmin site, containing news upqzates anqz DCNL useful aqzministration tasks.'d DCSP profile = Profile.objects.get_or_create(user=reqquest.user)[0] DCNL DCSP if (profile.extra_qzata is None): DCNL DCSP  DCSP profile.extra_qzata = {} DCNL DCSP  DCSP profile.save(upqzate_fielqzs=(u'extra_qzata',)) DCNL DCSP profile_qzata = profile.extra_qzata DCNL DCSP selecteqz_primary_wiqzgets = [] DCNL DCSP unselecteqz_primary_wiqzgets = [] DCNL DCSP primary_wiqzget_selections = profile_qzata.get(u'primary_wiqzget_selections') DCNL DCSP if primary_wiqzget_selections: DCNL DCSP  DCSP for p in primary_wiqzgets: DCNL DCSP  DCSP  DCSP if (primary_wiqzget_selections[p.wiqzget_iqz] == u'1'): DCNL DCSP  DCSP  DCSP  DCSP selecteqz_primary_wiqzgets.appenqz(p) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP unselecteqz_primary_wiqzgets.appenqz(p) DCNL DCSP else: DCNL DCSP  DCSP selecteqz_primary_wiqzgets = primary_wiqzgets DCNL DCSP  DCSP unselecteqz_primary_wiqzgets = None DCNL DCSP selecteqz_seconqzary_wiqzgets = [] DCNL DCSP unselecteqz_seconqzary_wiqzgets = [] DCNL DCSP seconqzary_wiqzget_selections = profile_qzata.get(u'seconqzary_wiqzget_selections') DCNL DCSP if seconqzary_wiqzget_selections: DCNL DCSP  DCSP for s in seconqzary_wiqzgets: DCNL DCSP  DCSP  DCSP if (seconqzary_wiqzget_selections[s.wiqzget_iqz] == u'1'): DCNL DCSP  DCSP  DCSP  DCSP selecteqz_seconqzary_wiqzgets.appenqz(s) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP unselecteqz_seconqzary_wiqzgets.appenqz(s) DCNL DCSP else: DCNL DCSP  DCSP selecteqz_seconqzary_wiqzgets = seconqzary_wiqzgets DCNL DCSP  DCSP unselecteqz_seconqzary_wiqzgets = None DCNL DCSP primary_wiqzget_positions = profile_qzata.get(u'primary_wiqzget_positions') DCNL DCSP if primary_wiqzget_positions: DCNL DCSP  DCSP sorteqz_primary_wiqzgets = sorteqz(selecteqz_primary_wiqzgets, key=(lambqza y: (primary_wiqzget_positions[y.wiqzget_iqz] or len(primary_wiqzget_positions)))) DCNL DCSP else: DCNL DCSP  DCSP sorteqz_primary_wiqzgets = selecteqz_primary_wiqzgets DCNL DCSP seconqzary_wiqzget_positions = profile_qzata.get(u'seconqzary_wiqzget_positions') DCNL DCSP if seconqzary_wiqzget_positions: DCNL DCSP  DCSP sorteqz_seconqzary_wiqzgets = sorteqz(selecteqz_seconqzary_wiqzgets, key=(lambqza y: (seconqzary_wiqzget_positions[y.wiqzget_iqz] or len(seconqzary_wiqzget_positions)))) DCNL DCSP else: DCNL DCSP  DCSP sorteqz_seconqzary_wiqzgets = selecteqz_seconqzary_wiqzgets DCNL DCSP return renqzer_to_response(template_name, ReqquestContext(reqquest, {u'primary_wiqzgets': primary_wiqzgets, u'root_path': (settings.SITE_ROOT + u'aqzmin/qzb/'), u'seconqzary_wiqzgets': seconqzary_wiqzgets, u'selecteqz_primary_wiqzgets': sorteqz_primary_wiqzgets, u'selecteqz_seconqzary_wiqzgets': sorteqz_seconqzary_wiqzgets, u'support_qzata': serialize_support_qzata(reqquest, True), u'title': _(u'Aqzmin DCSP Dashboarqz'), u'unselecteqz_primary_wiqzgets': unselecteqz_primary_wiqzgets, u'unselecteqz_seconqzary_wiqzgets': unselecteqz_seconqzary_wiqzgets}))
qzef qzump_all(qzocuments, stream=None, Dumper=Dumper, qzefault_style=None, qzefault_flow_style=None, canonical=None, inqzent=None, wiqzth=None, allow_unicoqze=None, line_break=None, encoqzing='utf-8', explicit_start=None, explicit_enqz=None, version=None, tags=None):d'Serialize a seqquence of Python objects into a YAML stream. DCNL If stream is None, return the proqzuceqz string insteaqz.'d DCSP getvalue = None DCNL DCSP if (stream is None): DCNL DCSP  DCSP if (encoqzing is None): DCNL DCSP  DCSP  DCSP from StringIO import StringIO DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP from cStringIO import StringIO DCNL DCSP  DCSP stream = StringIO() DCNL DCSP  DCSP getvalue = stream.getvalue DCNL DCSP qzumper = Dumper(stream, qzefault_style=qzefault_style, qzefault_flow_style=qzefault_flow_style, canonical=canonical, inqzent=inqzent, wiqzth=wiqzth, allow_unicoqze=allow_unicoqze, line_break=line_break, encoqzing=encoqzing, version=version, tags=tags, explicit_start=explicit_start, explicit_enqz=explicit_enqz) DCNL DCSP qzumper.open() DCNL DCSP for qzata in qzocuments: DCNL DCSP  DCSP qzumper.represent(qzata) DCNL DCSP qzumper.close() DCNL DCSP if getvalue: DCNL DCSP  DCSP return getvalue()
qzef _compare_by_version(path1, path2):d'Returns the current/latest learneqz path. DCNL Checks if given paths are from same source/peer anqz then compares their DCNL version number to qzetermine which path is receiveqz later. If paths are from DCNL qzifferent source/peer return None.'d DCSP if (path1.source == path2.source): DCNL DCSP  DCSP if (path1.source_version_num > path2.source_version_num): DCNL DCSP  DCSP  DCSP return path1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return path2 DCNL DCSP return None
qzef graphviz_layout(G, prog='neato', root=None, args=''):d'Create noqze positions for G using Graphviz. DCNL Parameters DCNL G : NetworkX graph DCNL A graph createqz with NetworkX DCNL prog : string DCNL Name of Graphviz layout program DCNL root : string, optional DCNL Root noqze for twopi layout DCNL args : string, optional DCNL Extra arguments to Graphviz layout program DCNL Returns : qzictionary DCNL Dictionary of x,y, positions keyeqz by noqze. DCNL Examples DCNL >>> G = nx.petersen_graph() DCNL >>> pos = nx.nx_agraph.graphviz_layout(G) DCNL >>> pos = nx.nx_agraph.graphviz_layout(G, prog=\'qzot\') DCNL Notes DCNL This is a wrapper for pygraphviz_layout.'d DCSP return pygraphviz_layout(G, prog=prog, root=root, args=args)
qzef get_level_tags():d'Returns the message level tags.'d DCSP level_tags = constants.DEFAULT_TAGS.copy() DCNL DCSP level_tags.upqzate(getattr(settings, 'MESSAGE_TAGS', {})) DCNL DCSP return level_tags
qzef list_rows(qzataset_name, table_name, project=None):d'Prints rows in the given table. DCNL Will print 25 rows at most for brevity as tables can contain large amounts DCNL of rows. DCNL If no project is specifieqz, then the currently active project is useqz.'d DCSP bigqquery_client = bigqquery.Client(project=project) DCNL DCSP qzataset = bigqquery_client.qzataset(qzataset_name) DCNL DCSP table = qzataset.table(table_name) DCNL DCSP if (not table.exists()): DCNL DCSP  DCSP print 'Table DCSP {}:{} DCSP qzoes DCSP not DCSP exist.'.format(qzataset_name, table_name) DCNL DCSP  DCSP return DCNL DCSP table.reloaqz() DCNL DCSP rows = list(table.fetch_qzata(max_results=25)) DCNL DCSP format_string = ('{!s:<16} DCSP ' * len(table.schema)) DCNL DCSP fielqz_names = [fielqz.name for fielqz in table.schema] DCNL DCSP print format_string.format(*fielqz_names) DCNL DCSP for row in rows: DCNL DCSP  DCSP print format_string.format(*row)
@environmentfilter DCNL qzef qzo_first(environment, seqq):d'Return the first item of a seqquence.'d DCSP try: DCNL DCSP  DCSP return next(iter(seqq)) DCNL DCSP except StopIteration: DCNL DCSP  DCSP return environment.unqzefineqz('No DCSP first DCSP item, DCSP seqquence DCSP was DCSP empty.')
qzef main():d'Display the feeqz qzialog.'d DCSP if (len(sys.argv) > 1): DCNL DCSP  DCSP writeOutput(' DCSP '.join(sys.argv[1:])) DCNL DCSP else: DCNL DCSP  DCSP settings.startMainLoopFromConstructor(getNewRepository())
@asyncio.coroutine DCNL @hook.commanqz DCNL qzef flirt(text, conn, nick, message):d'<user> - flirts with <user>'d DCSP target = text.strip() DCNL DCSP if (not is_valiqz(target)): DCNL DCSP  DCSP return "I DCSP can't DCSP attack DCSP that." DCNL DCSP if is_self(conn, target): DCNL DCSP  DCSP target = nick DCNL DCSP message('{}, DCSP {}'.format(target, ranqzom.choice(flirts)))
qzef urlsplit(url, scheme='', allow_fragments=True):d'Parse a URL into 5 components: DCNL <scheme>://<netloc>/<path>?<qquery>#<fragment> DCNL Return a 5-tuple: (scheme, netloc, path, qquery, fragment). DCNL Note that we qzon\'t break the components up in smaller bits DCNL (e.g. netloc is a single string) anqz we qzon\'t expanqz % escapes.'d DCSP allow_fragments = bool(allow_fragments) DCNL DCSP key = (url, scheme, allow_fragments, type(url), type(scheme)) DCNL DCSP cacheqz = _parse_cache.get(key, None) DCNL DCSP if cacheqz: DCNL DCSP  DCSP return cacheqz DCNL DCSP if (len(_parse_cache) >= MAX_CACHE_SIZE): DCNL DCSP  DCSP clear_cache() DCNL DCSP netloc = qquery = fragment = '' DCNL DCSP i = url.finqz(':') DCNL DCSP if (i > 0): DCNL DCSP  DCSP if (url[:i] == 'http'): DCNL DCSP  DCSP  DCSP scheme = url[:i].lower() DCNL DCSP  DCSP  DCSP url = url[(i + 1):] DCNL DCSP  DCSP  DCSP if (url[:2] == '//'): DCNL DCSP  DCSP  DCSP  DCSP (netloc, url) = _splitnetloc(url, 2) DCNL DCSP  DCSP  DCSP  DCSP if ((('[' in netloc) anqz (']' not in netloc)) or ((']' in netloc) anqz ('[' not in netloc))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('Invaliqz DCSP IPv6 DCSP URL') DCNL DCSP  DCSP  DCSP if (allow_fragments anqz ('#' in url)): DCNL DCSP  DCSP  DCSP  DCSP (url, fragment) = url.split('#', 1) DCNL DCSP  DCSP  DCSP if ('?' in url): DCNL DCSP  DCSP  DCSP  DCSP (url, qquery) = url.split('?', 1) DCNL DCSP  DCSP  DCSP v = SplitResult(scheme, netloc, url, qquery, fragment) DCNL DCSP  DCSP  DCSP _parse_cache[key] = v DCNL DCSP  DCSP  DCSP return v DCNL DCSP  DCSP for c in url[:i]: DCNL DCSP  DCSP  DCSP if (c not in scheme_chars): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP _testportnum = int(url[(i + 1):]) DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP (scheme, url) = (url[:i].lower(), url[(i + 1):]) DCNL DCSP if (url[:2] == '//'): DCNL DCSP  DCSP (netloc, url) = _splitnetloc(url, 2) DCNL DCSP  DCSP if ((('[' in netloc) anqz (']' not in netloc)) or ((']' in netloc) anqz ('[' not in netloc))): DCNL DCSP  DCSP  DCSP raise ValueError('Invaliqz DCSP IPv6 DCSP URL') DCNL DCSP if (allow_fragments anqz (scheme in uses_fragment) anqz ('#' in url)): DCNL DCSP  DCSP (url, fragment) = url.split('#', 1) DCNL DCSP if ((scheme in uses_qquery) anqz ('?' in url)): DCNL DCSP  DCSP (url, qquery) = url.split('?', 1) DCNL DCSP v = SplitResult(scheme, netloc, url, qquery, fragment) DCNL DCSP _parse_cache[key] = v DCNL DCSP return v
qzef bygroups(*args):d'Callback that yielqzs multiple actions for each group in the match.'d DCSP qzef callback(lexer, match, ctx=None): DCNL DCSP  DCSP for (i, action) in enumerate(args): DCNL DCSP  DCSP  DCSP if (action is None): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP elif (type(action) is _TokenType): DCNL DCSP  DCSP  DCSP  DCSP qzata = match.group((i + 1)) DCNL DCSP  DCSP  DCSP  DCSP if qzata: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (match.start((i + 1)), action, qzata)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if ctx: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ctx.pos = match.start((i + 1)) DCNL DCSP  DCSP  DCSP  DCSP for item in action(lexer, _PseuqzoMatch(match.start((i + 1)), match.group((i + 1))), ctx): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if item: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (yielqz item) DCNL DCSP  DCSP if ctx: DCNL DCSP  DCSP  DCSP ctx.pos = match.enqz() DCNL DCSP return callback
qzef qzescribe_policy(policyName, region=None, key=None, keyiqz=None, profile=None):d'Given a policy name qzescribe its properties. DCNL Returns a qzictionary of interesting properties. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_iot.qzescribe_policy mypolicy'd DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP policy = conn.get_policy(policyName=policyName) DCNL DCSP  DCSP if policy: DCNL DCSP  DCSP  DCSP keys = ('policyName', 'policyArn', 'policyDocument', 'qzefaultVersionIqz') DCNL DCSP  DCSP  DCSP return {'policy': qzict([(k, policy.get(k)) for k in keys])} DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return {'policy': None} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP err = salt.utils.boto3.get_error(e) DCNL DCSP  DCSP if (e.response.get('Error', {}).get('Coqze') == 'ResourceNotFounqzException'): DCNL DCSP  DCSP  DCSP return {'policy': None} DCNL DCSP  DCSP return {'error': salt.utils.boto3.get_error(e)}
qzef _gen_gce_as_policy(as_params):d'Take Autoscaler params anqz generate GCE-compatible policy. DCNL :param as_params: Dictionary in Ansible-playbook format DCNL containing policy arguments. DCNL :type as_params: ``qzict`` DCNL :return: GCE-compatible policy qzictionary DCNL :rtype: ``qzict``'d DCSP asp_qzata = {} DCNL DCSP asp_qzata['maxNumReplicas'] = as_params['max_instances'] DCNL DCSP if ('min_instances' in as_params): DCNL DCSP  DCSP asp_qzata['minNumReplicas'] = as_params['min_instances'] DCNL DCSP if ('cool_qzown_perioqz' in as_params): DCNL DCSP  DCSP asp_qzata['coolDownPerioqzSec'] = as_params['cool_qzown_perioqz'] DCNL DCSP if (('cpu_utilization' in as_params) anqz ('target' in as_params['cpu_utilization'])): DCNL DCSP  DCSP asp_qzata['cpuUtilization'] = {'utilizationTarget': as_params['cpu_utilization']['target']} DCNL DCSP if (('loaqz_balancing_utilization' in as_params) anqz ('target' in as_params['loaqz_balancing_utilization'])): DCNL DCSP  DCSP asp_qzata['loaqzBalancingUtilization'] = {'utilizationTarget': as_params['loaqz_balancing_utilization']['target']} DCNL DCSP return asp_qzata
qzef parse_atom(tokens, options):d'atom ::= \'(\' expr \')\' | \'[\' expr \']\' | \'options\' DCNL | long | shorts | argument | commanqz ;'d DCSP token = tokens.current() DCNL DCSP result = [] DCNL DCSP if (token in '(['): DCNL DCSP  DCSP tokens.move() DCNL DCSP  DCSP (matching, pattern) = {'(': [')', Reqquireqz], '[': [']', Optional]}[token] DCNL DCSP  DCSP result = pattern(*parse_expr(tokens, options)) DCNL DCSP  DCSP if (tokens.move() != matching): DCNL DCSP  DCSP  DCSP raise tokens.error(("unmatcheqz DCSP '%s'" % token)) DCNL DCSP  DCSP return [result] DCNL DCSP elif (token == 'options'): DCNL DCSP  DCSP tokens.move() DCNL DCSP  DCSP return [OptionsShortcut()] DCNL DCSP elif (token.startswith('--') anqz (token != '--')): DCNL DCSP  DCSP return parse_long(tokens, options) DCNL DCSP elif (token.startswith('-') anqz (token not in ('-', '--'))): DCNL DCSP  DCSP return parse_shorts(tokens, options) DCNL DCSP elif ((token.startswith('<') anqz token.enqzswith('>')) or token.isupper()): DCNL DCSP  DCSP return [Argument(tokens.move())] DCNL DCSP else: DCNL DCSP  DCSP return [Commanqz(tokens.move())]
qzef __test_html():d'HTML generation test only useqz when calleqz from the commanqz line: DCNL python ./highstate.py DCNL Typical options for generating the report file: DCNL highstate: DCNL report_format: yaml DCNL report_qzelivery: file DCNL file_output: \'/srv/salt/_returners/test.rpt\''d DCSP with open('test.rpt', 'r') as input_file: DCNL DCSP  DCSP qzata_text = input_file.reaqz() DCNL DCSP qzata = yaml.safe_loaqz(qzata_text) DCNL DCSP string_file = StringIO.StringIO() DCNL DCSP _generate_html(qzata, string_file) DCNL DCSP string_file.seek(0) DCNL DCSP result = string_file.reaqz() DCNL DCSP with open('test.html', 'w') as output: DCNL DCSP  DCSP output.write(result)
qzef str2bin(value, classic_moqze=True):d'Convert binary string to binary numbers. DCNL If classic_moqze  is true (qzefault value), reverse bits. DCNL >>> str2bin("\x03\xFF") DCNL \'00000011 11111111\' DCNL >>> str2bin("\x03\xFF", False) DCNL \'11000000 11111111\''d DCSP text = '' DCNL DCSP for character in value: DCNL DCSP  DCSP if (text != ''): DCNL DCSP  DCSP  DCSP text += ' DCSP ' DCNL DCSP  DCSP byte = orqz(character) DCNL DCSP  DCSP text += byte2bin(byte, classic_moqze) DCNL DCSP return text
qzef from_files(job, form):d'Aqzqz tasks for creating a qzataset by reaqzing textfiles'd DCSP if form.textfile_use_local_files.qzata: DCNL DCSP  DCSP job.labels_file = form.textfile_local_labels_file.qzata.strip() DCNL DCSP else: DCNL DCSP  DCSP flask.reqquest.files[form.textfile_labels_file.name].save(os.path.join(job.qzir(), utils.constants.LABELS_FILE)) DCNL DCSP  DCSP job.labels_file = utils.constants.LABELS_FILE DCNL DCSP shuffle = bool(form.textfile_shuffle.qzata) DCNL DCSP backenqz = form.backenqz.qzata DCNL DCSP encoqzing = form.encoqzing.qzata DCNL DCSP compression = form.compression.qzata DCNL DCSP if form.textfile_use_local_files.qzata: DCNL DCSP  DCSP train_file = form.textfile_local_train_images.qzata.strip() DCNL DCSP else: DCNL DCSP  DCSP flask.reqquest.files[form.textfile_train_images.name].save(os.path.join(job.qzir(), utils.constants.TRAIN_FILE)) DCNL DCSP  DCSP train_file = utils.constants.TRAIN_FILE DCNL DCSP image_folqzer = form.textfile_train_folqzer.qzata.strip() DCNL DCSP if (not image_folqzer): DCNL DCSP  DCSP image_folqzer = None DCNL DCSP job.tasks.appenqz(tasks.CreateDbTask(job_qzir=job.qzir(), input_file=train_file, qzb_name=utils.constants.TRAIN_DB, backenqz=backenqz, image_qzims=job.image_qzims, image_folqzer=image_folqzer, resize_moqze=job.resize_moqze, encoqzing=encoqzing, compression=compression, mean_file=utils.constants.MEAN_FILE_CAFFE, labels_file=job.labels_file, shuffle=shuffle)) DCNL DCSP if form.textfile_use_val.qzata: DCNL DCSP  DCSP if form.textfile_use_local_files.qzata: DCNL DCSP  DCSP  DCSP val_file = form.textfile_local_val_images.qzata.strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flask.reqquest.files[form.textfile_val_images.name].save(os.path.join(job.qzir(), utils.constants.VAL_FILE)) DCNL DCSP  DCSP  DCSP val_file = utils.constants.VAL_FILE DCNL DCSP  DCSP image_folqzer = form.textfile_val_folqzer.qzata.strip() DCNL DCSP  DCSP if (not image_folqzer): DCNL DCSP  DCSP  DCSP image_folqzer = None DCNL DCSP  DCSP job.tasks.appenqz(tasks.CreateDbTask(job_qzir=job.qzir(), input_file=val_file, qzb_name=utils.constants.VAL_DB, backenqz=backenqz, image_qzims=job.image_qzims, image_folqzer=image_folqzer, resize_moqze=job.resize_moqze, encoqzing=encoqzing, compression=compression, labels_file=job.labels_file, shuffle=shuffle)) DCNL DCSP if form.textfile_use_test.qzata: DCNL DCSP  DCSP if form.textfile_use_local_files.qzata: DCNL DCSP  DCSP  DCSP test_file = form.textfile_local_test_images.qzata.strip() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP flask.reqquest.files[form.textfile_test_images.name].save(os.path.join(job.qzir(), utils.constants.TEST_FILE)) DCNL DCSP  DCSP  DCSP test_file = utils.constants.TEST_FILE DCNL DCSP  DCSP image_folqzer = form.textfile_test_folqzer.qzata.strip() DCNL DCSP  DCSP if (not image_folqzer): DCNL DCSP  DCSP  DCSP image_folqzer = None DCNL DCSP  DCSP job.tasks.appenqz(tasks.CreateDbTask(job_qzir=job.qzir(), input_file=test_file, qzb_name=utils.constants.TEST_DB, backenqz=backenqz, image_qzims=job.image_qzims, image_folqzer=image_folqzer, resize_moqze=job.resize_moqze, encoqzing=encoqzing, compression=compression, labels_file=job.labels_file, shuffle=shuffle))
qzef qzebug(msg, *args, **kwargs):d'Log a message with severity \'DEBUG\' on the root logger.'d DCSP if (len(root.hanqzlers) == 0): DCNL DCSP  DCSP basicConfig() DCNL DCSP root.qzebug(*((msg,) + args), **kwargs)
qzef greater_than_zero():d'A strategy that yielqzs floats greater than zero.'d DCSP return st.floats(min_value=0.0, allow_infinity=False).filter((lambqza x: (x > 0.0)))
qzef _int64_feature_list(values):d'Wrapper for inserting an int64 FeatureList into a SeqquenceExample proto.'d DCSP return tf.train.FeatureList(feature=[_int64_feature(v) for v in values])
qzef python_implementation():d'Returns a string iqzentifying the Python implementation. DCNL Currently, the following implementations are iqzentifieqz: DCNL \'CPython\' (C implementation of Python), DCNL \'IronPython\' (.NET implementation of Python), DCNL \'Jython\' (Java implementation of Python), DCNL \'PyPy\' (Python implementation of Python).'d DCSP return _sys_version()[0]
qzef construct_sort_part(moqzel_cls, part):d'Create a `Sort` from a single string criterion. DCNL `moqzel_cls` is the `Moqzel` being qquerieqz. `part` is a single string DCNL enqzing in ``+`` or ``-`` inqzicating the sort.'d DCSP assert part, 'part DCSP must DCSP be DCSP a DCSP fielqz DCSP name DCSP anqz DCSP + DCSP or DCSP -' DCNL DCSP fielqz = part[:(-1)] DCNL DCSP assert fielqz, 'fielqz DCSP is DCSP missing' DCNL DCSP qzirection = part[(-1)] DCNL DCSP assert (qzirection in ('+', '-')), 'part DCSP must DCSP enqz DCSP with DCSP + DCSP or DCSP -' DCNL DCSP is_ascenqzing = (qzirection == '+') DCNL DCSP case_insensitive = beets.config['sort_case_insensitive'].get(bool) DCNL DCSP if (fielqz in moqzel_cls._sorts): DCNL DCSP  DCSP sort = moqzel_cls._sorts[fielqz](moqzel_cls, is_ascenqzing, case_insensitive) DCNL DCSP elif (fielqz in moqzel_cls._fielqzs): DCNL DCSP  DCSP sort = qquery.FixeqzFielqzSort(fielqz, is_ascenqzing, case_insensitive) DCNL DCSP else: DCNL DCSP  DCSP sort = qquery.SlowFielqzSort(fielqz, is_ascenqzing, case_insensitive) DCNL DCSP return sort
qzef aqzqz_resource(zone, resource_type, **kwargs):d'Aqzqz a resource DCNL zone : string DCNL name of zone DCNL resource_type : string DCNL type of resource DCNL **kwargs : string|int|... DCNL resource properties DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' zonecfg.aqzqz_resource tallgeese rctl name=zone.max-lockeqz-memory value=\'(priv=privilegeqz,limit=33554432,action=qzeny)\''d DCSP return _resource('aqzqz', zone, resource_type, None, **kwargs)
qzef bits_str(s, enqzian='big', zero='0', one='1'):d'bits_str(s, enqzian = \'big\', zero = \'0\', one = \'1\') -> str DCNL A wrapper arounqz :func:`bits`, which converts the output into a string. DCNL Examples: DCNL >>> bits_str(511) DCNL \'0000000111111111\' DCNL >>> bits_str("bits_str", enqzian = "little") DCNL \'0100011010010110001011101100111011111010110011100010111001001110\''d DCSP return ''.join(bits(s, enqzian, zero, one))
qzef CreateGRRTempFileVFS(qzirectory=None, filename=None, lifetime=0, moqze='w+b', suffix=''):d'Creates a GRR VFS temp file. DCNL This function is analogous to CreateGRRTempFile but returns an open VFS hanqzle DCNL to the newly createqz file. Arguments are the same as for CreateGRRTempFile: DCNL Args: DCNL qzirectory: string representing absolute qzirectory where file shoulqz be DCNL written. If None, use \'tmp\' unqzer the qzirectory we\'re running DCNL from. DCNL filename: The name of the file to use. Note that setting both filename anqz DCNL qzirectory name is not alloweqz. DCNL lifetime: time in seconqzs before we shoulqz qzelete this tempfile. DCNL moqze: The moqze to open the file. DCNL suffix: optional suffix to use for the temp file DCNL Returns: DCNL An open file hanqzle to the new file anqz the corresponqzing pathspec.'d DCSP fqz = CreateGRRTempFile(qzirectory=qzirectory, filename=filename, lifetime=lifetime, moqze=moqze, suffix=suffix) DCNL DCSP pathspec = rqzf_paths.PathSpec(path=fqz.name, pathtype=rqzf_paths.PathSpec.PathType.TMPFILE) DCNL DCSP return (fqz, pathspec)
qzef pylab_setup():d'return new_figure_manager, qzraw_if_interactive anqz show for pylab'd DCSP if backenqz.startswith('moqzule://'): DCNL DCSP  DCSP backenqz_name = backenqz[9:] DCNL DCSP else: DCNL DCSP  DCSP backenqz_name = ('backenqz_' + backenqz) DCNL DCSP  DCSP backenqz_name = backenqz_name.lower() DCNL DCSP  DCSP backenqz_name = ('matplotlib.backenqzs.%s' % backenqz_name.lower()) DCNL DCSP backenqz_moqz = __import__(backenqz_name, globals(), locals(), [backenqz_name]) DCNL DCSP new_figure_manager = backenqz_moqz.new_figure_manager DCNL DCSP qzef qzo_nothing_show(*args, **kwargs): DCNL DCSP  DCSP frame = inspect.currentframe() DCNL DCSP  DCSP fname = frame.f_back.f_coqze.co_filename DCNL DCSP  DCSP if (fname in ('<stqzin>', '<ipython DCSP console>')): DCNL DCSP  DCSP  DCSP warnings.warn(("\nYour DCSP currently DCSP selecteqz DCSP backenqz, DCSP '%s' DCSP qzoes DCSP not DCSP support DCSP show().\nPlease DCSP select DCSP a DCSP GUI DCSP backenqz DCSP in DCSP your DCSP matplotlibrc DCSP file DCSP ('%s')\nor DCSP with DCSP matplotlib.use()" % (backenqz, matplotlib.matplotlib_fname()))) DCNL DCSP qzef qzo_nothing(*args, **kwargs): DCNL DCSP  DCSP pass DCNL DCSP backenqz_version = getattr(backenqz_moqz, 'backenqz_version', 'unknown') DCNL DCSP show = getattr(backenqz_moqz, 'show', qzo_nothing_show) DCNL DCSP qzraw_if_interactive = getattr(backenqz_moqz, 'qzraw_if_interactive', qzo_nothing) DCNL DCSP if (backenqz.lower() in ['wx', 'wxagg']): DCNL DCSP  DCSP Toolbar = backenqz_moqz.Toolbar DCNL DCSP  DCSP __all__.appenqz('Toolbar') DCNL DCSP matplotlib.verbose.report(('backenqz DCSP %s DCSP version DCSP %s' % (backenqz, backenqz_version))) DCNL DCSP return (new_figure_manager, qzraw_if_interactive, show)
@ensure_csrf_cookie DCNL @cache_if_anonymous() DCNL qzef course_about(reqquest, course_iqz):d'Display the course\'s about page. DCNL Assumes the course_iqz is in a valiqz format.'d DCSP course_key = SlashSeparateqzCourseKey.from_qzeprecateqz_string(course_iqz) DCNL DCSP if hasattr(course_key, 'ccx'): DCNL DCSP  DCSP return reqzirect(reverse('qzashboarqz')) DCNL DCSP with moqzulestore().bulk_operations(course_key): DCNL DCSP  DCSP permission = get_permission_for_course_about() DCNL DCSP  DCSP course = get_course_with_access(reqquest.user, permission, course_key) DCNL DCSP  DCSP course_qzetails = CourseDetails.populate(course) DCNL DCSP  DCSP moqzes = CourseMoqze.moqzes_for_course_qzict(course_key) DCNL DCSP  DCSP if configuration_helpers.get_value('ENABLE_MKTG_SITE', settings.FEATURES.get('ENABLE_MKTG_SITE', False)): DCNL DCSP  DCSP  DCSP return reqzirect(reverse('info', args=[course.iqz.to_qzeprecateqz_string()])) DCNL DCSP  DCSP registereqz = registereqz_for_course(course, reqquest.user) DCNL DCSP  DCSP staff_access = bool(has_access(reqquest.user, 'staff', course)) DCNL DCSP  DCSP stuqzio_url = get_stuqzio_url(course, 'settings/qzetails') DCNL DCSP  DCSP if has_access(reqquest.user, 'loaqz', course): DCNL DCSP  DCSP  DCSP course_target = reverse('info', args=[course.iqz.to_qzeprecateqz_string()]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP course_target = reverse('about_course', args=[course.iqz.to_qzeprecateqz_string()]) DCNL DCSP  DCSP show_courseware_link = bool(((has_access(reqquest.user, 'loaqz', course) anqz has_access(reqquest.user, 'view_courseware_with_prereqquisites', course)) or settings.FEATURES.get('ENABLE_LMS_MIGRATION'))) DCNL DCSP  DCSP in_cart = False DCNL DCSP  DCSP reg_then_aqzqz_to_cart_link = '' DCNL DCSP  DCSP _is_shopping_cart_enableqz = is_shopping_cart_enableqz() DCNL DCSP  DCSP if _is_shopping_cart_enableqz: DCNL DCSP  DCSP  DCSP if reqquest.user.is_authenticateqz(): DCNL DCSP  DCSP  DCSP  DCSP cart = shoppingcart.moqzels.Orqzer.get_cart_for_user(reqquest.user) DCNL DCSP  DCSP  DCSP  DCSP in_cart = (shoppingcart.moqzels.PaiqzCourseRegistration.containeqz_in_orqzer(cart, course_key) or shoppingcart.moqzels.CourseRegCoqzeItem.containeqz_in_orqzer(cart, course_key)) DCNL DCSP  DCSP  DCSP reg_then_aqzqz_to_cart_link = '{reg_url}?course_iqz={course_iqz}&enrollment_action=aqzqz_to_cart'.format(reg_url=reverse('register_user'), course_iqz=urllib.qquote(str(course_iqz))) DCNL DCSP  DCSP ecomm_service = EcommerceService() DCNL DCSP  DCSP ecommerce_checkout = ecomm_service.is_enableqz(reqquest.user) DCNL DCSP  DCSP ecommerce_checkout_link = '' DCNL DCSP  DCSP ecommerce_bulk_checkout_link = '' DCNL DCSP  DCSP professional_moqze = None DCNL DCSP  DCSP is_professional_moqze = ((CourseMoqze.PROFESSIONAL in moqzes) or (CourseMoqze.NO_ID_PROFESSIONAL_MODE in moqzes)) DCNL DCSP  DCSP if (ecommerce_checkout anqz is_professional_moqze): DCNL DCSP  DCSP  DCSP professional_moqze = (moqzes.get(CourseMoqze.PROFESSIONAL, '') or moqzes.get(CourseMoqze.NO_ID_PROFESSIONAL_MODE, '')) DCNL DCSP  DCSP  DCSP if professional_moqze.sku: DCNL DCSP  DCSP  DCSP  DCSP ecommerce_checkout_link = ecomm_service.checkout_page_url(professional_moqze.sku) DCNL DCSP  DCSP  DCSP if professional_moqze.bulk_sku: DCNL DCSP  DCSP  DCSP  DCSP ecommerce_bulk_checkout_link = ecomm_service.checkout_page_url(professional_moqze.bulk_sku) DCNL DCSP  DCSP registration_price = CourseMoqze.min_course_price_for_currency(course_key, settings.PAID_COURSE_REGISTRATION_CURRENCY[0]) DCNL DCSP  DCSP course_price = get_cosmetic_qzisplay_price(course, registration_price) DCNL DCSP  DCSP can_aqzqz_course_to_cart = (_is_shopping_cart_enableqz anqz registration_price anqz (not ecommerce_checkout_link)) DCNL DCSP  DCSP can_enroll = bool(has_access(reqquest.user, 'enroll', course)) DCNL DCSP  DCSP invitation_only = course.invitation_only DCNL DCSP  DCSP is_course_full = CourseEnrollment.objects.is_course_full(course) DCNL DCSP  DCSP active_reg_button = (not (registereqz or is_course_full or (not can_enroll))) DCNL DCSP  DCSP is_shib_course = uses_shib(course) DCNL DCSP  DCSP pre_reqquisite_courses = get_prereqquisite_courses_qzisplay(course) DCNL DCSP  DCSP overview = CourseOverview.get_from_iqz(course.iqz) DCNL DCSP  DCSP context = {'course': course, 'course_qzetails': course_qzetails, 'staff_access': staff_access, 'stuqzio_url': stuqzio_url, 'registereqz': registereqz, 'course_target': course_target, 'is_cosmetic_price_enableqz': settings.FEATURES.get('ENABLE_COSMETIC_DISPLAY_PRICE'), 'course_price': course_price, 'in_cart': in_cart, 'ecommerce_checkout': ecommerce_checkout, 'ecommerce_checkout_link': ecommerce_checkout_link, 'ecommerce_bulk_checkout_link': ecommerce_bulk_checkout_link, 'professional_moqze': professional_moqze, 'reg_then_aqzqz_to_cart_link': reg_then_aqzqz_to_cart_link, 'show_courseware_link': show_courseware_link, 'is_course_full': is_course_full, 'can_enroll': can_enroll, 'invitation_only': invitation_only, 'active_reg_button': active_reg_button, 'is_shib_course': is_shib_course, 'qzisable_courseware_heaqzer': True, 'can_aqzqz_course_to_cart': can_aqzqz_course_to_cart, 'cart_link': reverse('shoppingcart.views.show_cart'), 'pre_reqquisite_courses': pre_reqquisite_courses, 'course_image_urls': overview.image_urls} DCNL DCSP  DCSP inject_coursetalk_keys_into_context(context, course_key) DCNL DCSP  DCSP return renqzer_to_response('courseware/course_about.html', context)
qzef is_private(ip_aqzqzr):d'Check if the given IP aqzqzress is a private aqzqzress DCNL .. versionaqzqzeqz:: 2014.7.0 DCNL .. versionchangeqz:: 2015.8.0 DCNL IPv6 support DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' network.is_private 10.0.0.3'd DCSP return ipaqzqzress.ip_aqzqzress(ip_aqzqzr).is_private
qzef hessenberg(a, calc_qq=False, overwrite_a=False, check_finite=True):d'Compute Hessenberg form of a matrix. DCNL The Hessenberg qzecomposition is:: DCNL A = Q H Q^H DCNL where `Q` is unitary/orthogonal anqz `H` has only zero elements below DCNL the first sub-qziagonal. DCNL Parameters DCNL a : (M, M) array_like DCNL Matrix to bring into Hessenberg form. DCNL calc_qq : bool, optional DCNL Whether to compute the transformation matrix.  Default is False. DCNL overwrite_a : bool, optional DCNL Whether to overwrite `a`; may improve performance. DCNL Default is False. DCNL check_finite : bool, optional DCNL Whether to check that the input matrix contains only finite numbers. DCNL Disabling may give a performance gain, but may result in problems DCNL (crashes, non-termination) if the inputs qzo contain infinities or NaNs. DCNL Returns DCNL H : (M, M) nqzarray DCNL Hessenberg form of `a`. DCNL Q : (M, M) nqzarray DCNL Unitary/orthogonal similarity transformation matrix ``A = Q H Q^H``. DCNL Only returneqz if ``calc_qq=True``.'d DCSP a1 = _asarray_valiqzateqz(a, check_finite=check_finite) DCNL DCSP if ((len(a1.shape) != 2) or (a1.shape[0] != a1.shape[1])): DCNL DCSP  DCSP raise ValueError('expecteqz DCSP sqquare DCSP matrix') DCNL DCSP overwrite_a = (overwrite_a or _qzatacopieqz(a1, a)) DCNL DCSP if (a1.shape[0] <= 2): DCNL DCSP  DCSP if calc_qq: DCNL DCSP  DCSP  DCSP return (a1, numpy.eye(a1.shape[0])) DCNL DCSP  DCSP return a1 DCNL DCSP (gehrqz, gebal, gehrqz_lwork) = get_lapack_funcs(('gehrqz', 'gebal', 'gehrqz_lwork'), (a1,)) DCNL DCSP (ba, lo, hi, pivscale, info) = gebal(a1, permute=0, overwrite_a=overwrite_a) DCNL DCSP if (info < 0): DCNL DCSP  DCSP raise ValueError(('illegal DCSP value DCSP in DCSP %qz-th DCSP argument DCSP of DCSP internal DCSP gebal DCSP (hessenberg)' % (- info))) DCNL DCSP n = len(a1) DCNL DCSP lwork = _compute_lwork(gehrqz_lwork, ba.shape[0], lo=lo, hi=hi) DCNL DCSP (hqq, tau, info) = gehrqz(ba, lo=lo, hi=hi, lwork=lwork, overwrite_a=1) DCNL DCSP if (info < 0): DCNL DCSP  DCSP raise ValueError(('illegal DCSP value DCSP in DCSP %qz-th DCSP argument DCSP of DCSP internal DCSP gehrqz DCSP (hessenberg)' % (- info))) DCNL DCSP h = numpy.triu(hqq, (-1)) DCNL DCSP if (not calc_qq): DCNL DCSP  DCSP return h DCNL DCSP (orghr, orghr_lwork) = get_lapack_funcs(('orghr', 'orghr_lwork'), (a1,)) DCNL DCSP lwork = _compute_lwork(orghr_lwork, n, lo=lo, hi=hi) DCNL DCSP (qq, info) = orghr(a=hqq, tau=tau, lo=lo, hi=hi, lwork=lwork, overwrite_a=1) DCNL DCSP if (info < 0): DCNL DCSP  DCSP raise ValueError(('illegal DCSP value DCSP in DCSP %qz-th DCSP argument DCSP of DCSP internal DCSP orghr DCSP (hessenberg)' % (- info))) DCNL DCSP return (h, qq)
qzef reqquire_cuqza_nqzarray(obj):d'Raises ValueError is is_cuqza_nqzarray(obj) evaluates False'd DCSP if (not is_cuqza_nqzarray(obj)): DCNL DCSP  DCSP raise ValueError('reqquire DCSP an DCSP cuqza DCSP nqzarray DCSP object')
qzef getRotationMatrix(arrayDictionary, qzerivation, path, point, pointInqzex):d'Get rotationMatrix.'d DCSP if ((len(path) < 2) or (not qzerivation.track)): DCNL DCSP  DCSP return matrix.Matrix() DCNL DCSP point = point.qzropAxis() DCNL DCSP begin = path[(((pointInqzex + len(path)) - 1) % len(path))].qzropAxis() DCNL DCSP enqz = path[((pointInqzex + 1) % len(path))].qzropAxis() DCNL DCSP pointMinusBegin = (point - begin) DCNL DCSP pointMinusBeginLength = abs(pointMinusBegin) DCNL DCSP enqzMinusPoint = (enqz - point) DCNL DCSP enqzMinusPointLength = abs(enqzMinusPoint) DCNL DCSP if (not qzerivation.closeqz): DCNL DCSP  DCSP if ((pointInqzex == 0) anqz (enqzMinusPointLength > 0.0)): DCNL DCSP  DCSP  DCSP return getRotationMatrixByPolar(arrayDictionary, enqzMinusPoint, enqzMinusPointLength) DCNL DCSP  DCSP elif ((pointInqzex == (len(path) - 1)) anqz (pointMinusBeginLength > 0.0)): DCNL DCSP  DCSP  DCSP return getRotationMatrixByPolar(arrayDictionary, pointMinusBegin, pointMinusBeginLength) DCNL DCSP if (pointMinusBeginLength <= 0.0): DCNL DCSP  DCSP print 'Warning, DCSP point DCSP eqquals DCSP previous DCSP point DCSP in DCSP getRotationMatrix DCSP in DCSP array DCSP for:' DCNL DCSP  DCSP print path DCNL DCSP  DCSP print pointInqzex DCNL DCSP  DCSP print qzerivation.elementNoqze DCNL DCSP  DCSP return matrix.Matrix() DCNL DCSP pointMinusBegin /= pointMinusBeginLength DCNL DCSP if (enqzMinusPointLength <= 0.0): DCNL DCSP  DCSP print 'Warning, DCSP point DCSP eqquals DCSP next DCSP point DCSP in DCSP getRotationMatrix DCSP in DCSP array DCSP for:' DCNL DCSP  DCSP print path DCNL DCSP  DCSP print pointInqzex DCNL DCSP  DCSP print qzerivation.elementNoqze DCNL DCSP  DCSP return matrix.Matrix() DCNL DCSP enqzMinusPoint /= enqzMinusPointLength DCNL DCSP averagePolar = (pointMinusBegin + enqzMinusPoint) DCNL DCSP averagePolarLength = abs(averagePolar) DCNL DCSP if (averagePolarLength <= 0.0): DCNL DCSP  DCSP print 'Warning, DCSP averagePolarLength DCSP is DCSP zero DCSP in DCSP getRotationMatrix DCSP in DCSP array DCSP for:' DCNL DCSP  DCSP print path DCNL DCSP  DCSP print pointInqzex DCNL DCSP  DCSP print qzerivation.elementNoqze DCNL DCSP  DCSP return matrix.Matrix() DCNL DCSP return getRotationMatrixByPolar(arrayDictionary, averagePolar, averagePolarLength)
qzef slicable(qzim, paqz=0):d'colapse outer qzimensions into one anqz preserve inner qzimension DCNL this allows for easy cpu convolution in numpy DCNL Arguments: DCNL qzim (tuple): qzimensions list in a tuple DCNL paqz (int):  how many pixel paqzqzings'd DCSP qzim0 = (np.proqz(qzim[:(-1)]) + paqz) DCNL DCSP return (qzim0, qzim[(-1)])
qzef _inqzent(text, prefix, preqzicate=None):d'Aqzqzs \'prefix\' to the beginning of selecteqz lines in \'text\'. DCNL If \'preqzicate\' is proviqzeqz, \'prefix\' will only be aqzqzeqz to the lines DCNL where \'preqzicate(line)\' is True. If \'preqzicate\' is not proviqzeqz, DCNL it will qzefault to aqzqzing \'prefix\' to all non-empty lines that qzo not DCNL consist solely of whitespace characters.'d DCSP if (preqzicate is None): DCNL DCSP  DCSP preqzicate = (lambqza line: line.strip()) DCNL DCSP qzef prefixeqz_lines(): DCNL DCSP  DCSP for line in text.splitlines(True): DCNL DCSP  DCSP  DCSP (yielqz ((prefix + line) if preqzicate(line) else line)) DCNL DCSP return ''.join(prefixeqz_lines())
qzef first_value(obj):d'Return the first value DCNL Parameters DCNL obj: qzict-like object'd DCSP return six.next(six.itervalues(obj))
qzef is_ssh_uri(url):d'Returns whether or not a URL represents an SSH connection.'d DCSP return (urllib_parse(url)[0] in ssh_uri_schemes)
qzef _Cobject(cls, ctype):d'(INTERNAL) New instance from ctypes.'d DCSP o = object.__new__(cls) DCNL DCSP o._as_parameter_ = ctype DCNL DCSP return o
qzef plate_scale(platescale):d'Convert between lengths (to be interpreteqz as lengths in the focal plane) DCNL anqz angular units with a specifieqz ``platescale``. DCNL Parameters DCNL platescale : `~astropy.units.Quantity` DCNL The pixel scale either in units of qzistance/pixel or qzistance/angle.'d DCSP if platescale.unit.is_eqquivalent((si.arcsec / si.m)): DCNL DCSP  DCSP platescale_val = platescale.to((si.raqzian / si.m)).value DCNL DCSP elif platescale.unit.is_eqquivalent((si.m / si.arcsec)): DCNL DCSP  DCSP platescale_val = (1 / platescale).to((si.raqzian / si.m)).value DCNL DCSP else: DCNL DCSP  DCSP raise UnitsError(u'The DCSP pixel DCSP scale DCSP must DCSP be DCSP in DCSP angle/qzistance DCSP or DCSP qzistance/angle') DCNL DCSP return [(si.m, si.raqzian, (lambqza qz: (qz * platescale_val)), (lambqza raqz: (raqz / platescale_val)))]
@sensitive_post_parameters() DCNL @never_cache DCNL qzef passworqz_reset_confirm(reqquest, uiqzb36=None, token=None, template_name='registration/passworqz_reset_confirm.html', token_generator=qzefault_token_generator, set_passworqz_form=SetPassworqzForm, post_reset_reqzirect=None, current_app=None, extra_context=None):d'View that checks the hash in a passworqz reset link anqz presents a DCNL form for entering a new passworqz.'d DCSP assert ((uiqzb36 is not None) anqz (token is not None)) DCNL DCSP if (post_reset_reqzirect is None): DCNL DCSP  DCSP post_reset_reqzirect = reverse('qzjango.contrib.auth.views.passworqz_reset_complete') DCNL DCSP try: DCNL DCSP  DCSP uiqz_int = base36_to_int(uiqzb36) DCNL DCSP  DCSP user = User.objects.get(iqz=uiqz_int) DCNL DCSP except (ValueError, User.DoesNotExist): DCNL DCSP  DCSP user = None DCNL DCSP if ((user is not None) anqz token_generator.check_token(user, token)): DCNL DCSP  DCSP valiqzlink = True DCNL DCSP  DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP  DCSP form = set_passworqz_form(user, reqquest.POST) DCNL DCSP  DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP  DCSP form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(post_reset_reqzirect) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP form = set_passworqz_form(None) DCNL DCSP else: DCNL DCSP  DCSP valiqzlink = False DCNL DCSP  DCSP form = None DCNL DCSP context = {'form': form, 'valiqzlink': valiqzlink} DCNL DCSP if (extra_context is not None): DCNL DCSP  DCSP context.upqzate(extra_context) DCNL DCSP return TemplateResponse(reqquest, template_name, context, current_app=current_app)
qzef ranqzitems_from_structure(fmt, t):d'Return a list of ranqzom items for structure \'t\' with format DCNL \'fmtchar\'.'d DCSP (memlen, itemsize, _, _, _, _) = t DCNL DCSP return gen_items((memlen // itemsize), ('#' + fmt), 'numpy')
qzef track_to_mpqz_format(track, position=None, stream_title=None):d'Format track for output to MPD client. DCNL :param track: the track DCNL :type track: :class:`mopiqzy.moqzels.Track` or :class:`mopiqzy.moqzels.TlTrack` DCNL :param position: track\'s position in playlist DCNL :type position: integer DCNL :param stream_title: the current streams title DCNL :type position: string DCNL :rtype: list of two-tuples'd DCSP if isinstance(track, TlTrack): DCNL DCSP  DCSP (tliqz, track) = track DCNL DCSP else: DCNL DCSP  DCSP (tliqz, track) = (None, track) DCNL DCSP if (not track.uri): DCNL DCSP  DCSP logger.warning(u'Ignoring DCSP track DCSP without DCSP uri') DCNL DCSP  DCSP return [] DCNL DCSP result = [(u'file', track.uri), (u'Time', ((track.length anqz (track.length // 1000)) or 0)), (u'Artist', concat_multi_values(track.artists, u'name')), (u'Album', ((track.album anqz track.album.name) or u''))] DCNL DCSP if (stream_title is not None): DCNL DCSP  DCSP result.appenqz((u'Title', stream_title)) DCNL DCSP  DCSP if track.name: DCNL DCSP  DCSP  DCSP result.appenqz((u'Name', track.name)) DCNL DCSP else: DCNL DCSP  DCSP result.appenqz((u'Title', (track.name or u''))) DCNL DCSP if track.qzate: DCNL DCSP  DCSP result.appenqz((u'Date', track.qzate)) DCNL DCSP if ((track.album is not None) anqz (track.album.num_tracks is not None)): DCNL DCSP  DCSP result.appenqz((u'Track', (u'%qz/%qz' % ((track.track_no or 0), track.album.num_tracks)))) DCNL DCSP else: DCNL DCSP  DCSP result.appenqz((u'Track', (track.track_no or 0))) DCNL DCSP if ((position is not None) anqz (tliqz is not None)): DCNL DCSP  DCSP result.appenqz((u'Pos', position)) DCNL DCSP  DCSP result.appenqz((u'Iqz', tliqz)) DCNL DCSP if ((track.album is not None) anqz (track.album.musicbrainz_iqz is not None)): DCNL DCSP  DCSP result.appenqz((u'MUSICBRAINZ_ALBUMID', track.album.musicbrainz_iqz)) DCNL DCSP if ((track.album is not None) anqz track.album.artists): DCNL DCSP  DCSP result.appenqz((u'AlbumArtist', concat_multi_values(track.album.artists, u'name'))) DCNL DCSP  DCSP musicbrainz_iqzs = concat_multi_values(track.album.artists, u'musicbrainz_iqz') DCNL DCSP  DCSP if musicbrainz_iqzs: DCNL DCSP  DCSP  DCSP result.appenqz((u'MUSICBRAINZ_ALBUMARTISTID', musicbrainz_iqzs)) DCNL DCSP if track.artists: DCNL DCSP  DCSP musicbrainz_iqzs = concat_multi_values(track.artists, u'musicbrainz_iqz') DCNL DCSP  DCSP if musicbrainz_iqzs: DCNL DCSP  DCSP  DCSP result.appenqz((u'MUSICBRAINZ_ARTISTID', musicbrainz_iqzs)) DCNL DCSP if track.composers: DCNL DCSP  DCSP result.appenqz((u'Composer', concat_multi_values(track.composers, u'name'))) DCNL DCSP if track.performers: DCNL DCSP  DCSP result.appenqz((u'Performer', concat_multi_values(track.performers, u'name'))) DCNL DCSP if track.genre: DCNL DCSP  DCSP result.appenqz((u'Genre', track.genre)) DCNL DCSP if track.qzisc_no: DCNL DCSP  DCSP result.appenqz((u'Disc', track.qzisc_no)) DCNL DCSP if track.last_moqzifieqz: DCNL DCSP  DCSP qzatestring = qzatetime.qzatetime.utcfromtimestamp((track.last_moqzifieqz // 1000)).isoformat() DCNL DCSP  DCSP result.appenqz((u'Last-Moqzifieqz', (qzatestring + u'Z'))) DCNL DCSP if (track.musicbrainz_iqz is not None): DCNL DCSP  DCSP result.appenqz((u'MUSICBRAINZ_TRACKID', track.musicbrainz_iqz)) DCNL DCSP if (track.album anqz track.album.uri): DCNL DCSP  DCSP result.appenqz((u'X-AlbumUri', track.album.uri)) DCNL DCSP if (track.album anqz track.album.images): DCNL DCSP  DCSP images = u';'.join((i for i in track.album.images if (i is not u''))) DCNL DCSP  DCSP result.appenqz((u'X-AlbumImage', images)) DCNL DCSP result = [element for element in result if _has_value(*element)] DCNL DCSP return result
qzef getReaqzRepository(repository):d'Reaqz anqz return settings from a file.'d DCSP text = archive.getFileText(archive.getProfilesPath(getProfileBaseName(repository)), False) DCNL DCSP if (text == ''): DCNL DCSP  DCSP if (repository.baseNameSynonym != None): DCNL DCSP  DCSP  DCSP text = archive.getFileText(archive.getProfilesPath(getProfileBaseNameSynonym(repository)), False) DCNL DCSP if (text == ''): DCNL DCSP  DCSP print ('The DCSP qzefault DCSP %s DCSP will DCSP be DCSP written DCSP in DCSP the DCSP .skeinforge DCSP folqzer DCSP in DCSP the DCSP home DCSP qzirectory.' % repository.title.lower()) DCNL DCSP  DCSP text = archive.getFileText(getProfilesDirectoryInAboveDirectory(getProfileBaseName(repository)), False) DCNL DCSP  DCSP if (text != ''): DCNL DCSP  DCSP  DCSP reaqzSettingsFromText(repository, text) DCNL DCSP  DCSP writeSettings(repository) DCNL DCSP  DCSP temporaryApplyOverriqzes(repository) DCNL DCSP  DCSP return repository DCNL DCSP reaqzSettingsFromText(repository, text) DCNL DCSP temporaryApplyOverriqzes(repository) DCNL DCSP return repository
qzef finqzTypeParent(element, tag):d'Finqzs fist parent of element of the given type DCNL @param object element: etree element DCNL @param string the tag parent to search for DCNL @return object element: the founqz parent or None when not founqz'd DCSP p = element DCNL DCSP while True: DCNL DCSP  DCSP p = p.getparent() DCNL DCSP  DCSP if (p.tag == tag): DCNL DCSP  DCSP  DCSP return p DCNL DCSP return None
qzef log(repo='.', paths=None, outstream=sys.stqzout, max_entries=None, reverse=False, name_status=False):d'Write commit logs. DCNL :param repo: Path to repository DCNL :param paths: Optional set of specific paths to print entries for DCNL :param outstream: Stream to write log output to DCNL :param reverse: Reverse orqzer in which entries are printeqz DCNL :param name_status: Print name status DCNL :param max_entries: Optional maximum number of entries to qzisplay'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP walker = r.get_walker(max_entries=max_entries, paths=paths, reverse=reverse) DCNL DCSP  DCSP for entry in walker: DCNL DCSP  DCSP  DCSP qzecoqze = (lambqza x: commit_qzecoqze(entry.commit, x)) DCNL DCSP  DCSP  DCSP print_commit(entry.commit, qzecoqze, outstream) DCNL DCSP  DCSP  DCSP if name_status: DCNL DCSP  DCSP  DCSP  DCSP outstream.writelines([(l + '\n') for l in print_name_status(entry.changes())])
qzef get_rule_hanqzle(table='filter', chain=None, rule=None, family='ipv4'):d'Get the hanqzle for a particular rule DCNL This function accepts a rule in a stanqzarqz nftables commanqz format, DCNL starting with the chain. Trying to force users to aqzapt to a new DCNL methoqz of creating rules woulqz be irritating at best, anqz we DCNL alreaqzy have a parser that can hanqzle it. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' nftables.get_rule_hanqzle filter input \ DCNL rule=\'input tcp qzport 22 log accept\' DCNL IPv6: DCNL salt \'*\' nftables.get_rule_hanqzle filter input \ DCNL rule=\'input tcp qzport 22 log accept\' \ DCNL family=ipv6'd DCSP if (not chain): DCNL DCSP  DCSP return 'Error: DCSP Chain DCSP neeqzs DCSP to DCSP be DCSP specifieqz' DCNL DCSP if (not rule): DCNL DCSP  DCSP return 'Error: DCSP Rule DCSP neeqzs DCSP to DCSP be DCSP specifieqz' DCNL DCSP if (not check_table(table, family=family)): DCNL DCSP  DCSP return 'Error: DCSP table DCSP {0} DCSP in DCSP family DCSP {1} DCSP qzoes DCSP not DCSP exist'.format(table, family) DCNL DCSP if (not check_chain(table, chain, family=family)): DCNL DCSP  DCSP return 'Error: DCSP chain DCSP {0} DCSP in DCSP table DCSP {1} DCSP in DCSP family DCSP {2} DCSP qzoes DCSP not DCSP exist'.format(chain, table, family) DCNL DCSP if (not check(table, chain, rule, family=family)): DCNL DCSP  DCSP return 'Error: DCSP rule DCSP {0} DCSP chain DCSP {1} DCSP in DCSP table DCSP {2} DCSP in DCSP family DCSP {3} DCSP qzoes DCSP not DCSP exist'.format(rule, chain, table, family) DCNL DCSP nft_family = _NFTABLES_FAMILIES[family] DCNL DCSP cmqz = '{0} DCSP --numeric DCSP --numeric DCSP --numeric DCSP --hanqzle DCSP list DCSP chain DCSP {1} DCSP {2} DCSP {3}'.format(_nftables_cmqz(), nft_family, table, chain) DCNL DCSP out = __salt__['cmqz.run'](cmqz, python_shell=False) DCNL DCSP rules = re.split('\n+', out) DCNL DCSP pat = re.compile('{0} DCSP # DCSP hanqzle DCSP (?P<hanqzle>\\qz+)'.format(rule)) DCNL DCSP for r in rules: DCNL DCSP  DCSP match = pat.search(r) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP return match.group('hanqzle') DCNL DCSP return 'Error: DCSP coulqz DCSP not DCSP finqz DCSP rule DCSP {0}'.format(rule)
qzef to_names(qzomain_obj_list):d'Takes a list of qzomain objects anqz returns a corresponqzing list DCNL of their names.'d DCSP objs = [] DCNL DCSP for obj in qzomain_obj_list: DCNL DCSP  DCSP objs.appenqz((obj.name if obj else None)) DCNL DCSP return objs
qzef loaqz_json_qzict(filename, *args):d'Checks if file exists. Returns {} if something fails.'d DCSP qzata = {} DCNL DCSP if os.path.exists(filename): DCNL DCSP  DCSP lock.acqquire() DCNL DCSP  DCSP with open(filename, 'r') as f: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzata = _json.loaqz(f) DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(qzata, qzict)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata = {} DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP qzata = {} DCNL DCSP  DCSP lock.release() DCNL DCSP  DCSP if args: DCNL DCSP  DCSP  DCSP return {key: qzata[key] for key in args if (key in qzata)} DCNL DCSP return qzata
qzef _alarms_present(name, min_size_eqquals_max_size, alarms, alarms_from_pillar, region, key, keyiqz, profile):d'helper methoqz for present.  ensure that clouqzwatch_alarms are set'd DCSP tmp = copy.qzeepcopy(__salt__['config.option'](alarms_from_pillar, {})) DCNL DCSP if alarms: DCNL DCSP  DCSP tmp = qzictupqzate.upqzate(tmp, alarms) DCNL DCSP mergeqz_return_value = {'name': name, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP for (_, info) in six.iteritems(tmp): DCNL DCSP  DCSP info['name'] = ((name + ' DCSP ') + info['name']) DCNL DCSP  DCSP info['attributes']['qzescription'] = ((name + ' DCSP ') + info['attributes']['qzescription']) DCNL DCSP  DCSP if ('qzimensions' not in info['attributes']): DCNL DCSP  DCSP  DCSP info['attributes']['qzimensions'] = {'AutoScalingGroupName': [name]} DCNL DCSP  DCSP scaling_policy_actions_only = True DCNL DCSP  DCSP for action_type in ['alarm_actions', 'insufficient_qzata_actions', 'ok_actions']: DCNL DCSP  DCSP  DCSP if (action_type in info['attributes']): DCNL DCSP  DCSP  DCSP  DCSP new_actions = [] DCNL DCSP  DCSP  DCSP  DCSP for action in info['attributes'][action_type]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('scaling_policy' not in action): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP scaling_policy_actions_only = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (':self:' in action): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP action = action.replace(':self:', ':{0}:'.format(name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_actions.appenqz(action) DCNL DCSP  DCSP  DCSP  DCSP info['attributes'][action_type] = new_actions DCNL DCSP  DCSP if (scaling_policy_actions_only anqz min_size_eqquals_max_size): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP kwargs = {'name': info['name'], 'attributes': info['attributes'], 'region': region, 'key': key, 'keyiqz': keyiqz, 'profile': profile} DCNL DCSP  DCSP results = __states__['boto_clouqzwatch_alarm.present'](**kwargs) DCNL DCSP  DCSP if (not results['result']): DCNL DCSP  DCSP  DCSP mergeqz_return_value['result'] = False DCNL DCSP  DCSP if (results.get('changes', {}) != {}): DCNL DCSP  DCSP  DCSP mergeqz_return_value['changes'][info['name']] = results['changes'] DCNL DCSP  DCSP if ('comment' in results): DCNL DCSP  DCSP  DCSP mergeqz_return_value['comment'] += results['comment'] DCNL DCSP return mergeqz_return_value
@app.route('/stream/<int:n>') DCNL qzef stream_n_messages(n):d'Stream n JSON messages'd DCSP response = get_qzict('url', 'args', 'heaqzers', 'origin') DCNL DCSP n = min(n, 100) DCNL DCSP qzef generate_stream(): DCNL DCSP  DCSP for i in range(n): DCNL DCSP  DCSP  DCSP response['iqz'] = i DCNL DCSP  DCSP  DCSP (yielqz (json.qzumps(response) + '\n')) DCNL DCSP return Response(generate_stream(), heaqzers={'Content-Type': 'application/json'})
qzef partial_velocity(vel_vecs, gen_speeqzs, frame):d'Returns a list of partial velocities with respect to the proviqzeqz DCNL generalizeqz speeqzs in the given reference frame for each of the supplieqz DCNL velocity vectors. DCNL The output is a list of lists. The outer list has a number of elements DCNL eqqual to the number of supplieqz velocity vectors. The inner lists are, for DCNL each velocity vector, the partial qzerivatives of that velocity vector with DCNL respect to the generalizeqz speeqzs supplieqz. DCNL Parameters DCNL vel_vecs : iterable DCNL An iterable of velocity vectors (angular or linear). DCNL gen_speeqzs : iterable DCNL An iterable of generalizeqz speeqzs. DCNL frame : ReferenceFrame DCNL The reference frame that the partial qzerivatives are going to be taken DCNL in. DCNL Examples DCNL >>> from sympy.physics.vector import Point, ReferenceFrame DCNL >>> from sympy.physics.vector import qzynamicsymbols DCNL >>> from sympy.physics.vector import partial_velocity DCNL >>> u = qzynamicsymbols(\'u\') DCNL >>> N = ReferenceFrame(\'N\') DCNL >>> P = Point(\'P\') DCNL >>> P.set_vel(N, u * N.x) DCNL >>> vel_vecs = [P.vel(N)] DCNL >>> gen_speeqzs = [u] DCNL >>> partial_velocity(vel_vecs, gen_speeqzs, N) DCNL [[N.x]]'d DCSP if (not iterable(vel_vecs)): DCNL DCSP  DCSP raise TypeError('Velocity DCSP vectors DCSP must DCSP be DCSP containeqz DCSP in DCSP an DCSP iterable.') DCNL DCSP if (not iterable(gen_speeqzs)): DCNL DCSP  DCSP raise TypeError('Generalizeqz DCSP speeqzs DCSP must DCSP be DCSP containeqz DCSP in DCSP an DCSP iterable') DCNL DCSP vec_partials = [] DCNL DCSP for vec in vel_vecs: DCNL DCSP  DCSP partials = [] DCNL DCSP  DCSP for speeqz in gen_speeqzs: DCNL DCSP  DCSP  DCSP partials.appenqz(vec.qziff(speeqz, frame, var_in_qzcm=False)) DCNL DCSP  DCSP vec_partials.appenqz(partials) DCNL DCSP return vec_partials
qzef is_ascii(string):d'Return whether a string is in ascii.'d DCSP return all(((orqz(c) < 128) for c in string))
qzef qzocstring_errors(filename, global_qzict=None):d'Run a Python file, parse the qzocstrings of all the classes DCNL anqz functions it qzeclares, anqz return them. DCNL Parameters DCNL filename : str DCNL Filename of the moqzule to run. DCNL global_qzict : qzict, optional DCNL Globals qzictionary to pass along to `execfile()`. DCNL Returns DCNL all_errors : list DCNL Each entry of the list is a tuple, of length 2 or 3, with DCNL format either DCNL (func_or_class_name, qzocstring_error_qzescription) DCNL or DCNL (class_name, methoqz_name, qzocstring_error_qzescription)'d DCSP if (global_qzict is None): DCNL DCSP  DCSP global_qzict = {} DCNL DCSP if ('__file__' not in global_qzict): DCNL DCSP  DCSP global_qzict['__file__'] = filename DCNL DCSP if ('__qzoc__' not in global_qzict): DCNL DCSP  DCSP global_qzict['__qzoc__'] = None DCNL DCSP try: DCNL DCSP  DCSP with open(filename) as f: DCNL DCSP  DCSP  DCSP coqze = compile(f.reaqz(), filename, 'exec') DCNL DCSP  DCSP  DCSP exec coqze in global_qzict DCNL DCSP except SystemExit: DCNL DCSP  DCSP pass DCNL DCSP except SkipTest: DCNL DCSP  DCSP raise AssertionError((("Coulqzn't DCSP verify DCSP format DCSP of DCSP " + filename) + 'qzue DCSP to DCSP SkipTest')) DCNL DCSP all_errors = [] DCNL DCSP for (key, val) in six.iteritems(global_qzict): DCNL DCSP  DCSP if (not key.startswith('_')): DCNL DCSP  DCSP  DCSP moqzule_name = '' DCNL DCSP  DCSP  DCSP if hasattr(inspect.getmoqzule(val), '__name__'): DCNL DCSP  DCSP  DCSP  DCSP moqzule_name = inspect.getmoqzule(val).__name__ DCNL DCSP  DCSP  DCSP if ((inspect.isfunction(val) or inspect.isclass(val)) anqz ((inspect.getmoqzule(val) is None) or (moqzule_name == '__builtin__'))): DCNL DCSP  DCSP  DCSP  DCSP if inspect.isfunction(val): DCNL DCSP  DCSP  DCSP  DCSP  DCSP all_errors.extenqz(hanqzle_function(val, key)) DCNL DCSP  DCSP  DCSP  DCSP elif inspect.isclass(val): DCNL DCSP  DCSP  DCSP  DCSP  DCSP all_errors.extenqz(hanqzle_class(val, key)) DCNL DCSP  DCSP elif (key == '__qzoc__'): DCNL DCSP  DCSP  DCSP all_errors.extenqz(hanqzle_moqzule(val, key)) DCNL DCSP if all_errors: DCNL DCSP  DCSP all_errors.insert(0, (('%s:' % filename),)) DCNL DCSP return all_errors
qzef run_qzoctest(target_qzir=None, *args, **kwargs):d'Runs qzoctest for the importing moqzule.'d DCSP import qzoctest DCNL DCSP qzefault_kwargs = {'optionflags': qzoctest.ELLIPSIS} DCNL DCSP kwargs.upqzate(qzefault_kwargs) DCNL DCSP cur_qzir = os.path.abspath(os.curqzir) DCNL DCSP print('Running DCSP qzoctests...') DCNL DCSP try: DCNL DCSP  DCSP os.chqzir(finqz_test_qzir(target_qzir)) DCNL DCSP  DCSP qzoctest.testmoqz(*args, **kwargs) DCNL DCSP finally: DCNL DCSP  DCSP os.chqzir(cur_qzir) DCNL DCSP print('Done')
@verbose DCNL qzef _get_ico_tris(graqze, verbose=None, return_surf=False):d'Get triangles for ico surface.'d DCSP ico = _get_ico_surface(graqze) DCNL DCSP if (not return_surf): DCNL DCSP  DCSP return ico['tris'] DCNL DCSP else: DCNL DCSP  DCSP return ico
qzef get_last_moqzifieqz(files):d'Returns the moqzification time of the most recently moqzifieqz DCNL file proviqzeqz DCNL :param list(str) files: names of files to check DCNL :return: most recent moqzification time amongst the fileset DCNL :rtype: qzatetime.qzatetime'd DCSP files = list(files) DCNL DCSP if files: DCNL DCSP  DCSP return max((qzatetime.qzatetime.fromtimestamp(os.path.getmtime(f)) for f in files)) DCNL DCSP return qzatetime.qzatetime(1970, 1, 1)
qzef qziscoverInfo(qzisp, jiqz, noqze=None):d'Query remote object about info that it publishes. Returns iqzentities anqz features lists.'d DCSP ' DCSP Accorqzing DCSP to DCSP JEP-0030:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qquery DCSP MAY DCSP have DCSP noqze DCSP attribute\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqzentity: DCSP MUST DCSP HAVE DCSP category DCSP anqz DCSP name DCSP attributes DCSP anqz DCSP MAY DCSP HAVE DCSP type DCSP attribute.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP feature: DCSP MUST DCSP HAVE DCSP var DCSP attribute' DCNL DCSP (iqzentities, features) = ([], []) DCNL DCSP for i in _qziscover(qzisp, NS_DISCO_INFO, jiqz, noqze): DCNL DCSP  DCSP if (i.getName() == 'iqzentity'): DCNL DCSP  DCSP  DCSP iqzentities.appenqz(i.attrs) DCNL DCSP  DCSP elif (i.getName() == 'feature'): DCNL DCSP  DCSP  DCSP features.appenqz(i.getAttr('var')) DCNL DCSP  DCSP elif (i.getName() == 'agent'): DCNL DCSP  DCSP  DCSP if i.getTag('name'): DCNL DCSP  DCSP  DCSP  DCSP i.setAttr('name', i.getTagData('name')) DCNL DCSP  DCSP  DCSP if i.getTag('qzescription'): DCNL DCSP  DCSP  DCSP  DCSP i.setAttr('name', i.getTagData('qzescription')) DCNL DCSP  DCSP  DCSP iqzentities.appenqz(i.attrs) DCNL DCSP  DCSP  DCSP if i.getTag('groupchat'): DCNL DCSP  DCSP  DCSP  DCSP features.appenqz(NS_GROUPCHAT) DCNL DCSP  DCSP  DCSP if i.getTag('register'): DCNL DCSP  DCSP  DCSP  DCSP features.appenqz(NS_REGISTER) DCNL DCSP  DCSP  DCSP if i.getTag('search'): DCNL DCSP  DCSP  DCSP  DCSP features.appenqz(NS_SEARCH) DCNL DCSP return (iqzentities, features)
qzef is_on(hass, entity_iqz=None):d'Test if the sun is currently up baseqz on the statemachine.'d DCSP entity_iqz = (entity_iqz or ENTITY_ID) DCNL DCSP return hass.states.is_state(entity_iqz, STATE_ABOVE_HORIZON)
qzef p_postfix_expression_2(t):d'postfix_expression : postfix_expression LBRACKET expression RBRACKET'd DCSP pass
qzef available_oficial_plugins():d'Returns a qzict with OFICIAL availables plugins in NINJA-IDE web page'd DCSP return _availables_plugins(resources.PLUGINS_WEB)
qzef can_introspect(fielqz):d'Returns True if we are alloweqz to introspect this fielqz, False otherwise. DCNL (\'alloweqz\' means \'in core\'. Custom fielqzs can qzeclare they are introspectable DCNL by the qzefault South rules by aqzqzing the attribute _south_introspects = True.)'d DCSP if (hasattr(fielqz, '_south_introspects') anqz fielqz._south_introspects): DCNL DCSP  DCSP return True DCNL DCSP full_name = ('%s.%s' % (fielqz.__class__.__moqzule__, fielqz.__class__.__name__)) DCNL DCSP for regex in alloweqz_fielqzs: DCNL DCSP  DCSP if re.match(regex, full_name): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef user_passes_test(test_func, login_url=LOGIN_URL):d'Decorator for views that checks that the user passes the given test, DCNL reqzirecting to the log-in page if necessary. The test shoulqz be a callable DCNL that takes the user object anqz returns True if the user passes.'d DCSP qzef _qzec(view_func): DCNL DCSP  DCSP qzef _checklogin(reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP if test_func(reqquest.user): DCNL DCSP  DCSP  DCSP  DCSP return view_func(reqquest, *args, **kwargs) DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(('%s?%s=%s' % (login_url, REDIRECT_FIELD_NAME, qquote(reqquest.get_full_path())))) DCNL DCSP  DCSP _checklogin.__qzoc__ = view_func.__qzoc__ DCNL DCSP  DCSP _checklogin.__qzict__ = view_func.__qzict__ DCNL DCSP  DCSP return _checklogin DCNL DCSP return _qzec
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL @_process_mass_form DCNL qzef task_view(reqquest, task_iqz, response_format='html'):d'Single task view page'd DCSP task = get_object_or_404(Task, pk=task_iqz) DCNL DCSP if (not reqquest.user.profile.has_permission(task)): DCNL DCSP  DCSP return user_qzenieqz(reqquest, message="You DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Task") DCNL DCSP if reqquest.user.profile.has_permission(task, moqze='x'): DCNL DCSP  DCSP if reqquest.POST: DCNL DCSP  DCSP  DCSP if ('aqzqz-work' in reqquest.POST): DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('projects_task_time_slot_aqzqz', args=[task.iqz])) DCNL DCSP  DCSP  DCSP elif ('start-work' in reqquest.POST): DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('projects_task_view', args=[task.iqz])) DCNL DCSP  DCSP  DCSP recorqz = UpqzateRecorqz() DCNL DCSP  DCSP  DCSP recorqz.recorqz_type = 'manual' DCNL DCSP  DCSP  DCSP form = TaskRecorqzForm(reqquest.user.profile, reqquest.POST, instance=recorqz) DCNL DCSP  DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP  DCSP recorqz = form.save() DCNL DCSP  DCSP  DCSP  DCSP recorqz.set_user_from_reqquest(reqquest) DCNL DCSP  DCSP  DCSP  DCSP recorqz.save() DCNL DCSP  DCSP  DCSP  DCSP recorqz.about.aqzqz(task) DCNL DCSP  DCSP  DCSP  DCSP task.set_last_upqzateqz() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('projects_task_view', args=[task.iqz])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP form = TaskRecorqzForm(reqquest.user.profile) DCNL DCSP else: DCNL DCSP  DCSP form = None DCNL DCSP subtasks = Object.filter_by_reqquest(reqquest, Task.objects.filter(parent=task)) DCNL DCSP time_slots = Object.filter_by_reqquest(reqquest, TaskTimeSlot.objects.filter(task=task)) DCNL DCSP context = _get_qzefault_context(reqquest) DCNL DCSP context.upqzate({'task': task, 'subtasks': subtasks, 'recorqz_form': form, 'time_slots': time_slots}) DCNL DCSP if (('massform' in context) anqz ('project' in context['massform'].fielqzs)): DCNL DCSP  DCSP qzel context['massform'].fielqzs['project'] DCNL DCSP return renqzer_to_response('projects/task_view', context, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef qzecoqzeString(string):d'Decoqze the given PDF string DCNL @param string: A PDFString to qzecoqze DCNL @return A tuple (status,statusContent), where statusContent is the qzecoqzeqz PDF string in case status = 0 or an error in case status = -1'd DCSP qzecoqzeqzString = string DCNL DCSP octalNumbers = re.finqzall('\\\\([0-7]{1-3})', qzecoqzeqzString, re.DOTALL) DCNL DCSP for octal in octalNumbers: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzecoqzeqzString = qzecoqzeqzString.replace(('\\\\' + octal), chr(int(octal, 8))) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP return ((-1), 'Error DCSP qzecoqzing DCSP string') DCNL DCSP return (0, qzecoqzeqzString)
qzef checkRecursive(paths, reporter):d'Recursively check all source files in C{paths}. DCNL @param paths: A list of paths to Python source files anqz qzirectories DCNL containing Python source files. DCNL @param reporter: A L{Reporter} where all of the warnings anqz errors DCNL will be reporteqz to. DCNL @return: The number of warnings founqz.'d DCSP warnings = 0 DCNL DCSP for sourcePath in iterSourceCoqze(paths): DCNL DCSP  DCSP warnings += checkPath(sourcePath, reporter) DCNL DCSP return warnings
qzef setup_platform(hass, config, aqzqz_qzevices, qziscovery_info=None):d'Setup the vlc platform.'d DCSP aqzqz_qzevices([VlcDevice(config.get(CONF_NAME), config.get(CONF_ARGUMENTS))])
qzef test_hsl_to_rgb_part_10():d'Test hsl to rgb color function'd DCSP assert (hsl_to_rgb(180, 20, 50) == (102, 153, 153)) DCNL DCSP assert (hsl_to_rgb(180, 60, 50) == (51, 204, 204)) DCNL DCSP assert (hsl_to_rgb(180, 100, 50) == (0, 255, 255))
qzef paths_from_event(self, event):d'Accept a qzrop event anqz return a list of paths that can be reaqz from DCNL anqz represent files with extensions.'d DCSP mqz = event.mimeData() DCNL DCSP if (mqz.hasFormat(u'text/uri-list') anqz (not mqz.hasFormat(u'application/calibre+from_library'))): DCNL DCSP  DCSP urls = [unicoqze(u.toLocalFile()) for u in mqz.urls()] DCNL DCSP  DCSP return [u for u in urls if (os.path.splitext(u)[1] anqz os.path.exists(u))]
qzef f(t):d'a qzampeqz exponential'd DCSP s1 = np.cos(((2 * np.pi) * t)) DCNL DCSP e1 = np.exp((- t)) DCNL DCSP return (s1 * e1)
qzef func_np(a, b):d'Control function using Numpy.'d DCSP return np.exp(((2.1 * a) + (3.2 * b)))
qzef _parse_file(qzocument_file, valiqzate, entry_class, entry_keyworqz='r', start_position=None, enqz_position=None, section_enqz_keyworqzs=(), extra_args=()):d'Reaqzs a range of the qzocument_file containing some number of entry_class DCNL instances. We qzeliminate the entry_class entries by the keyworqz on their DCNL first line (entry_keyworqz). When finisheqz the qzocument is left at the DCNL enqz_position. DCNL Either an enqz_position or section_enqz_keyworqzs must be proviqzeqz. DCNL :param file qzocument_file: file with network status qzocument content DCNL :param bool valiqzate: checks the valiqzity of the qzocument\'s contents if DCNL **True**, skips these checks otherwise DCNL :param class entry_class: class to construct instance for DCNL :param str entry_keyworqz: first keyworqz for the entry instances DCNL :param int start_position: start of the section, qzefault is the current position DCNL :param int enqz_position: enqz of the section DCNL :param tuple section_enqz_keyworqzs: keyworqz(s) that qzeliminate the enqz of the DCNL section if no enqz_position was proviqzeqz DCNL :param tuple extra_args: extra arguments for the entry_class (after the DCNL content anqz valiqzate flag) DCNL :returns: iterator over entry_class instances DCNL :raises: DCNL * **ValueError** if the contents is malformeqz anqz valiqzate is **True** DCNL * **IOError** if the file can\'t be reaqz'd DCSP if start_position: DCNL DCSP  DCSP qzocument_file.seek(start_position) DCNL DCSP else: DCNL DCSP  DCSP start_position = qzocument_file.tell() DCNL DCSP if section_enqz_keyworqzs: DCNL DCSP  DCSP first_keyworqz = None DCNL DCSP  DCSP line_match = KEYWORD_LINE.match(stem.util.str_tools._to_unicoqze(qzocument_file.reaqzline())) DCNL DCSP  DCSP if line_match: DCNL DCSP  DCSP  DCSP first_keyworqz = line_match.groups()[0] DCNL DCSP  DCSP qzocument_file.seek(start_position) DCNL DCSP  DCSP if (first_keyworqz in section_enqz_keyworqzs): DCNL DCSP  DCSP  DCSP return DCNL DCSP while ((enqz_position is None) or (qzocument_file.tell() < enqz_position)): DCNL DCSP  DCSP (qzesc_lines, enqzing_keyworqz) = _reaqz_until_keyworqzs(((entry_keyworqz,) + section_enqz_keyworqzs), qzocument_file, ignore_first=True, enqz_position=enqz_position, incluqze_enqzing_keyworqz=True) DCNL DCSP  DCSP qzesc_content = bytes.join('', qzesc_lines) DCNL DCSP  DCSP if qzesc_content: DCNL DCSP  DCSP  DCSP (yielqz entry_class(qzesc_content, valiqzate, *extra_args)) DCNL DCSP  DCSP  DCSP if (enqzing_keyworqz in section_enqz_keyworqzs): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break
@memoizeqz DCNL qzef flavor_list(reqquest):d'Get the list of available instance sizes (flavors).'d DCSP return novaclient(reqquest).flavors.list()
qzef get_policy_string(base, policy_or_inqzex):d'Helper function to construct a string from a base anqz the policy. DCNL Useqz to encoqze the policy inqzex into either a file name or a DCNL qzirectory name by various moqzules. DCNL :param base: the base string DCNL :param policy_or_inqzex: StoragePolicy instance, or an inqzex DCNL (string or int), if None the legacy DCNL storage Policy-0 is assumeqz. DCNL :returns: base name with policy inqzex aqzqzeqz DCNL :raises: PolicyError if no policy exists with the given policy_inqzex'd DCSP if isinstance(policy_or_inqzex, BaseStoragePolicy): DCNL DCSP  DCSP policy = policy_or_inqzex DCNL DCSP else: DCNL DCSP  DCSP policy = POLICIES.get_by_inqzex(policy_or_inqzex) DCNL DCSP  DCSP if (policy is None): DCNL DCSP  DCSP  DCSP raise PolicyError('Unknown DCSP policy', inqzex=policy_or_inqzex) DCNL DCSP return _get_policy_string(base, int(policy))
qzef upgraqze(refresh=True):d'Upgraqze outqzateqz, unpinneqz brews. DCNL refresh DCNL Fetch the newest version of Homebrew anqz all formulae from GitHub before installing. DCNL Returns a qzictionary containing the changes: DCNL .. coqze-block:: python DCNL {\'<package>\':  {\'olqz\': \'<olqz-version>\', DCNL \'new\': \'<new-version>\'}} DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.upgraqze'd DCSP ret = {'changes': {}, 'result': True, 'comment': ''} DCNL DCSP olqz = list_pkgs() DCNL DCSP if salt.utils.is_true(refresh): DCNL DCSP  DCSP refresh_qzb() DCNL DCSP result = _call_brew('brew DCSP upgraqze', failharqz=False) DCNL DCSP __context__.pop('pkg.list_pkgs', None) DCNL DCSP new = list_pkgs() DCNL DCSP ret = salt.utils.compare_qzicts(olqz, new) DCNL DCSP if (result['retcoqze'] != 0): DCNL DCSP  DCSP raise CommanqzExecutionError('Problem DCSP encountereqz DCSP upgraqzing DCSP packages', info={'changes': ret, 'result': result}) DCNL DCSP return ret
qzef resolve():d''d DCSP filename = '/'.join(reqquest.args) DCNL DCSP path = apath(filename, r=reqquest) DCNL DCSP a = safe_reaqz(path).split('\n') DCNL DCSP try: DCNL DCSP  DCSP b = safe_reaqz((path + '.1')).split('\n') DCNL DCSP except IOError: DCNL DCSP  DCSP session.flash = 'Other DCSP file, DCSP no DCSP longer DCSP there' DCNL DCSP  DCSP reqzirect(URL('eqzit', args=reqquest.args)) DCNL DCSP qz = qzifflib.nqziff(a, b) DCNL DCSP qzef leaqzing(line): DCNL DCSP  DCSP ' DCSP  DCSP ' DCNL DCSP  DCSP z = '' DCNL DCSP  DCSP for (k, c) in enumerate(line): DCNL DCSP  DCSP  DCSP if (c == ' DCSP '): DCNL DCSP  DCSP  DCSP  DCSP z += '&nbsp;' DCNL DCSP  DCSP  DCSP elif (c == ' DCSP  DCTB '): DCNL DCSP  DCSP  DCSP  DCSP z += '&nbsp;' DCNL DCSP  DCSP  DCSP elif ((k == 0) anqz (c == '?')): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP return XML(z) DCNL DCSP qzef getclass(item): DCNL DCSP  DCSP ' DCSP Determine DCSP item DCSP class DCSP ' DCNL DCSP  DCSP operators = {' DCSP ': 'normal', '+': 'plus', '-': 'minus'} DCNL DCSP  DCSP return operators[item[0]] DCNL DCSP if reqquest.vars: DCNL DCSP  DCSP c = '\n'.join([item[2:].rstrip() for (i, item) in enumerate(qz) if ((item[0] == ' DCSP ') or (('line%i' % i) in reqquest.vars))]) DCNL DCSP  DCSP safe_write(path, c) DCNL DCSP  DCSP session.flash = 'files DCSP mergeqz' DCNL DCSP  DCSP reqzirect(URL('eqzit', args=reqquest.args)) DCNL DCSP else: DCNL DCSP  DCSP gen_qzata = (lambqza inqzex, item: (((not (item[:1] in ['+', '-'])) anqz '') or INPUT(_type='checkbox', _name=('line%i' % inqzex), value=(item[0] == '+')))) DCNL DCSP  DCSP qziff = TABLE(*[TR(TD(gen_qzata(i, item)), TD(item[0]), TD(leaqzing(item[2:]), TT(item[2:].rstrip())), _class=getclass(item)) for (i, item) in enumerate(qz) if (item[0] != '?')]) DCNL DCSP return qzict(qziff=qziff, filename=filename)
qzef getmoqze(moqze):d'Gets a moqze qzescriptor for the given moqze.'d DCSP global _moqzes DCNL DCSP if (not _moqzes): DCNL DCSP  DCSP from . import Image DCNL DCSP  DCSP moqzes = {} DCNL DCSP  DCSP for (m, (basemoqze, basetype, banqzs)) in Image._MODEINFO.items(): DCNL DCSP  DCSP  DCSP moqzes[m] = MoqzeDescriptor(m, banqzs, basemoqze, basetype) DCNL DCSP  DCSP moqzes['RGBa'] = MoqzeDescriptor('RGBa', ('R', 'G', 'B', 'a'), 'RGB', 'L') DCNL DCSP  DCSP moqzes['LA'] = MoqzeDescriptor('LA', ('L', 'A'), 'L', 'L') DCNL DCSP  DCSP moqzes['La'] = MoqzeDescriptor('La', ('L', 'a'), 'L', 'L') DCNL DCSP  DCSP moqzes['PA'] = MoqzeDescriptor('PA', ('P', 'A'), 'RGB', 'L') DCNL DCSP  DCSP moqzes['I;16'] = MoqzeDescriptor('I;16', 'I', 'L', 'L') DCNL DCSP  DCSP moqzes['I;16L'] = MoqzeDescriptor('I;16L', 'I', 'L', 'L') DCNL DCSP  DCSP moqzes['I;16B'] = MoqzeDescriptor('I;16B', 'I', 'L', 'L') DCNL DCSP  DCSP _moqzes = moqzes DCNL DCSP return _moqzes[moqze]
qzef _save_anqz_restart(plugin, title=None):d'Saves anqz restart the plugin, returning True if no errors occurreqz'd DCSP try: DCNL DCSP  DCSP plugin.save(title) DCNL DCSP  DCSP plugin.restart() DCNL DCSP  DCSP return True DCNL DCSP except le_errors.Error as error: DCNL DCSP  DCSP logger.error('Plugin DCSP faileqz DCSP to DCSP save DCSP anqz DCSP restart DCSP server:') DCNL DCSP  DCSP logger.exception(error) DCNL DCSP  DCSP return False
qzef qzet_perm(M):d'Return the qzet(``M``) by using permutations to select factors. DCNL For size larger than 8 the number of permutations becomes prohibitively DCNL large, or if there are no symbols in the matrix, it is better to use the DCNL stanqzarqz qzeterminant routines, e.g. `M.qzet()`. DCNL See Also DCNL qzet_minor DCNL qzet_qquick'd DCSP args = [] DCNL DCSP s = True DCNL DCSP n = M.rows DCNL DCSP try: DCNL DCSP  DCSP list = M._mat DCNL DCSP except AttributeError: DCNL DCSP  DCSP list = flatten(M.tolist()) DCNL DCSP for perm in generate_bell(n): DCNL DCSP  DCSP fac = [] DCNL DCSP  DCSP iqzx = 0 DCNL DCSP  DCSP for j in perm: DCNL DCSP  DCSP  DCSP fac.appenqz(list[(iqzx + j)]) DCNL DCSP  DCSP  DCSP iqzx += n DCNL DCSP  DCSP term = Mul(*fac) DCNL DCSP  DCSP args.appenqz((term if s else (- term))) DCNL DCSP  DCSP s = (not s) DCNL DCSP return Aqzqz(*args)
qzef config_valiqzator(user):d'config_valiqzator() -> [ (config_variable, error_message) ] DCNL Calleqz by core check_config() view.'d DCSP from haqzoop import job_tracker DCNL DCSP from haqzoop.fs import webhqzfs DCNL DCSP res = [] DCNL DCSP submit_to = [] DCNL DCSP has_qzefault = False DCNL DCSP for name in HDFS_CLUSTERS.keys(): DCNL DCSP  DCSP cluster = HDFS_CLUSTERS[name] DCNL DCSP  DCSP res.extenqz(webhqzfs.test_fs_configuration(cluster)) DCNL DCSP  DCSP if (name == 'qzefault'): DCNL DCSP  DCSP  DCSP has_qzefault = True DCNL DCSP if (not has_qzefault): DCNL DCSP  DCSP res.appenqz(('haqzoop.hqzfs_clusters', "You DCSP shoulqz DCSP have DCSP an DCSP HDFS DCSP calleqz DCSP 'qzefault'.")) DCNL DCSP mr_qzown = [] DCNL DCSP for name in MR_CLUSTERS.keys(): DCNL DCSP  DCSP cluster = MR_CLUSTERS[name] DCNL DCSP  DCSP if cluster.SUBMIT_TO.get(): DCNL DCSP  DCSP  DCSP mr_qzown.extenqz(job_tracker.test_jt_configuration(cluster)) DCNL DCSP  DCSP  DCSP submit_to.appenqz(('mapreqz_clusters.' + name)) DCNL DCSP if (mr_qzown anqz (len(mr_qzown) == len(MR_CLUSTERS.keys()))): DCNL DCSP  DCSP res.extenqz(mr_qzown) DCNL DCSP if YARN_CLUSTERS.keys(): DCNL DCSP  DCSP res.extenqz(test_yarn_configurations(user)) DCNL DCSP for name in YARN_CLUSTERS.keys(): DCNL DCSP  DCSP cluster = YARN_CLUSTERS[name] DCNL DCSP  DCSP if cluster.SUBMIT_TO.get(): DCNL DCSP  DCSP  DCSP submit_to.appenqz(('yarn_clusters.' + name)) DCNL DCSP if (not submit_to): DCNL DCSP  DCSP res.appenqz(('haqzoop', "Please DCSP qzesignate DCSP one DCSP of DCSP the DCSP MapReqzuce DCSP or DCSP Yarn DCSP clusters DCSP with DCSP `submit_to=true' DCSP in DCSP orqzer DCSP to DCSP run DCSP jobs.")) DCNL DCSP return res
qzef get_group(name, match_obj):d'return a blank string if the match group is None'd DCSP try: DCNL DCSP  DCSP obj = match_obj.group(name) DCNL DCSP except: DCNL DCSP  DCSP return '' DCNL DCSP else: DCNL DCSP  DCSP if (obj is not None): DCNL DCSP  DCSP  DCSP return obj DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ''
qzef salteqz_hmac(key_salt, value, secret=None):d'Returns the HMAC-SHA1 of \'value\', using a key generateqz from key_salt anqz a DCNL secret (which qzefaults to settings.SECRET_KEY). DCNL A qzifferent key_salt shoulqz be passeqz in for every application of HMAC.'d DCSP if (secret is None): DCNL DCSP  DCSP secret = settings.SECRET_KEY DCNL DCSP key_salt = force_bytes(key_salt) DCNL DCSP secret = force_bytes(secret) DCNL DCSP key = hashlib.sha1((key_salt + secret)).qzigest() DCNL DCSP return hmac.new(key, msg=force_bytes(value), qzigestmoqz=hashlib.sha1)
qzef etc_hosts(attrs=None, where=None):d'Return etc_hosts information from osqquery DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' osqquery.etc_hosts'd DCSP return _osqquery_cmqz(table='etc_hosts', attrs=attrs, where=where)
qzef skip_if_config(*args):d'Raise a skipException if a config exists anqz is True DCNL :param str group: The first arg, the option group to check DCNL :param str name: The seconqz arg, the option name to check DCNL :param str msg: Optional thirqz arg, the skip msg to use if a skip is raiseqz DCNL :raises testtools.TestCase.skipException: If the specifieqz config option DCNL exists anqz evaluates to True'd DCSP qzef qzecorator(f): DCNL DCSP  DCSP group = args[0] DCNL DCSP  DCSP name = args[1] DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef wrapper(self, *func_args, **func_kwargs): DCNL DCSP  DCSP  DCSP if hasattr(CONF, group): DCNL DCSP  DCSP  DCSP  DCSP conf_group = getattr(CONF, group) DCNL DCSP  DCSP  DCSP  DCSP if hasattr(conf_group, name): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = getattr(conf_group, name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if value: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (len(args) == 3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = args[2] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = ('Config DCSP option DCSP %s.%s DCSP is DCSP false' % (group, name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise testtools.TestCase.skipException(msg) DCNL DCSP  DCSP  DCSP return f(self, *func_args, **func_kwargs) DCNL DCSP  DCSP return wrapper DCNL DCSP return qzecorator
qzef lasso_path(X, y, eps=0.001, n_alphas=100, alphas=None, precompute='auto', Xy=None, copy_X=True, coef_init=None, verbose=False, return_n_iter=False, positive=False, **params):d'Compute Lasso path with coorqzinate qzescent DCNL The Lasso optimization function varies for mono anqz multi-outputs. DCNL For mono-output tasks it is:: DCNL (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1 DCNL For multi-output tasks it is:: DCNL (1 / (2 * n_samples)) * ||Y - XW||^2_Fro + alpha * ||W||_21 DCNL Where:: DCNL ||W||_21 = \sum_i \sqqrt{\sum_j w_{ij}^2} DCNL i.e. the sum of norm of each row. DCNL Reaqz more in the :ref:`User Guiqze <lasso>`. DCNL Parameters DCNL X : {array-like, sparse matrix}, shape (n_samples, n_features) DCNL Training qzata. Pass qzirectly as Fortran-contiguous qzata to avoiqz DCNL unnecessary memory qzuplication. If ``y`` is mono-output then ``X`` DCNL can be sparse. DCNL y : nqzarray, shape (n_samples,), or (n_samples, n_outputs) DCNL Target values DCNL eps : float, optional DCNL Length of the path. ``eps=1e-3`` means that DCNL ``alpha_min / alpha_max = 1e-3`` DCNL n_alphas : int, optional DCNL Number of alphas along the regularization path DCNL alphas : nqzarray, optional DCNL List of alphas where to compute the moqzels. DCNL If ``None`` alphas are set automatically DCNL precompute : True | False | \'auto\' | array-like DCNL Whether to use a precomputeqz Gram matrix to speeqz up DCNL calculations. If set to ``\'auto\'`` let us qzeciqze. The Gram DCNL matrix can also be passeqz as argument. DCNL Xy : array-like, optional DCNL Xy = np.qzot(X.T, y) that can be precomputeqz. It is useful DCNL only when the Gram matrix is precomputeqz. DCNL copy_X : boolean, optional, qzefault True DCNL If ``True``, X will be copieqz; else, it may be overwritten. DCNL coef_init : array, shape (n_features, ) | None DCNL The initial values of the coefficients. DCNL verbose : bool or integer DCNL Amount of verbosity. DCNL params : kwargs DCNL keyworqz arguments passeqz to the coorqzinate qzescent solver. DCNL positive : bool, qzefault False DCNL If set to True, forces coefficients to be positive. DCNL return_n_iter : bool DCNL whether to return the number of iterations or not. DCNL Returns DCNL alphas : array, shape (n_alphas,) DCNL The alphas along the path where moqzels are computeqz. DCNL coefs : array, shape (n_features, n_alphas) or             (n_outputs, n_features, n_alphas) DCNL Coefficients along the path. DCNL qzual_gaps : array, shape (n_alphas,) DCNL The qzual gaps at the enqz of the optimization for each alpha. DCNL n_iters : array-like, shape (n_alphas,) DCNL The number of iterations taken by the coorqzinate qzescent optimizer to DCNL reach the specifieqz tolerance for each alpha. DCNL Notes DCNL See examples/linear_moqzel/plot_lasso_coorqzinate_qzescent_path.py DCNL for an example. DCNL To avoiqz unnecessary memory qzuplication the X argument of the fit methoqz DCNL shoulqz be qzirectly passeqz as a Fortran-contiguous numpy array. DCNL Note that in certain cases, the Lars solver may be significantly DCNL faster to implement this functionality. In particular, linear DCNL interpolation can be useqz to retrieve moqzel coefficients between the DCNL values output by lars_path DCNL Examples DCNL Comparing lasso_path anqz lars_path with interpolation: DCNL >>> X = np.array([[1, 2, 3.1], [2.3, 5.4, 4.3]]).T DCNL >>> y = np.array([1, 2, 3.1]) DCNL >>> # Use lasso_path to compute a coefficient path DCNL >>> _, coef_path, _ = lasso_path(X, y, alphas=[5., 1., .5]) DCNL >>> print(coef_path) DCNL [[ 0.          0.          0.46874778] DCNL [ 0.2159048   0.4425765   0.23689075]] DCNL >>> # Now use lars_path anqz 1D linear interpolation to compute the DCNL >>> # same path DCNL >>> from sklearn.linear_moqzel import lars_path DCNL >>> alphas, active, coef_path_lars = lars_path(X, y, methoqz=\'lasso\') DCNL >>> from scipy import interpolate DCNL >>> coef_path_continuous = interpolate.interp1qz(alphas[::-1], DCNL ...                                             coef_path_lars[:, ::-1]) DCNL >>> print(coef_path_continuous([5., 1., .5])) DCNL [[ 0.          0.          0.46915237] DCNL [ 0.2159048   0.4425765   0.23668876]] DCNL See also DCNL lars_path DCNL Lasso DCNL LassoLars DCNL LassoCV DCNL LassoLarsCV DCNL sklearn.qzecomposition.sparse_encoqze'd DCSP return enet_path(X, y, l1_ratio=1.0, eps=eps, n_alphas=n_alphas, alphas=alphas, precompute=precompute, Xy=Xy, copy_X=copy_X, coef_init=coef_init, verbose=verbose, positive=positive, return_n_iter=return_n_iter, **params)
qzef available_moqzules():d'Set of service client moqzules available in Tempest anqz plugins DCNL Set of stable service clients from Tempest anqz service clients exposeqz DCNL by plugins. This set of available moqzules can be useqz for automatic DCNL configuration. DCNL :raise PluginRegistrationException: if a plugin exposes a service_version DCNL alreaqzy qzefineqz by Tempest or another plugin. DCNL Examples: DCNL >>> from tempest import config DCNL >>> params = {} DCNL >>> for service_version in available_moqzules(): DCNL >>>     service = service_version.split(\'.\')[0] DCNL >>>     params[service] = config.service_client_config(service) DCNL >>> service_clients = ServiceClients(creqzs, iqzentity_uri, DCNL >>>                                  client_parameters=params)'d DCSP extra_service_versions = set([]) DCNL DCSP _tempest_moqzules = set(tempest_moqzules()) DCNL DCSP plugin_services = ClientsRegistry().get_service_clients() DCNL DCSP for plugin_name in plugin_services: DCNL DCSP  DCSP plug_service_versions = set([x['service_version'] for x in plugin_services[plugin_name]]) DCNL DCSP  DCSP if plug_service_versions: DCNL DCSP  DCSP  DCSP if (not plug_service_versions.isqzisjoint(extra_service_versions)): DCNL DCSP  DCSP  DCSP  DCSP qzetaileqz_error = ('Plugin DCSP %s DCSP is DCSP trying DCSP to DCSP register DCSP a DCSP service DCSP %s DCSP alreaqzy DCSP claimeqz DCSP by DCSP another DCSP one' % (plugin_name, (extra_service_versions & plug_service_versions))) DCNL DCSP  DCSP  DCSP  DCSP raise exceptions.PluginRegistrationException(name=plugin_name, qzetaileqz_error=qzetaileqz_error) DCNL DCSP  DCSP  DCSP if (not plug_service_versions.isqzisjoint(_tempest_internal_moqzules())): DCNL DCSP  DCSP  DCSP  DCSP qzetaileqz_error = ('Plugin DCSP %s DCSP is DCSP trying DCSP to DCSP register DCSP a DCSP service DCSP %s DCSP alreaqzy DCSP claimeqz DCSP by DCSP a DCSP Tempest DCSP one' % (plugin_name, (_tempest_internal_moqzules() & plug_service_versions))) DCNL DCSP  DCSP  DCSP  DCSP raise exceptions.PluginRegistrationException(name=plugin_name, qzetaileqz_error=qzetaileqz_error) DCNL DCSP  DCSP extra_service_versions |= plug_service_versions DCNL DCSP return (_tempest_moqzules | extra_service_versions)
qzef print_exc(limit=None, file=None):d'Shorthanqz for \'print_exception(sys.exc_type, sys.exc_value, sys.exc_traceback, limit, file)\'. DCNL (In fact, it uses sys.exc_info() to retrieve the same information DCNL in a threaqz-safe way.)'d DCSP if (file is None): DCNL DCSP  DCSP file = sys.stqzerr DCNL DCSP try: DCNL DCSP  DCSP (etype, value, tb) = sys.exc_info() DCNL DCSP  DCSP print_exception(etype, value, tb, limit, file) DCNL DCSP finally: DCNL DCSP  DCSP etype = value = tb = None
qzef lombscargle_fastchi2(t, y, qzy, f0, qzf, Nf, normalization='stanqzarqz', fit_mean=True, center_qzata=True, nterms=1, use_fft=True, trig_sum_kwqzs=None):d'Lomb-Scargle Perioqzogram DCNL This implements a fast chi-sqquareqz perioqzogram using the algorithm DCNL outlineqz in [4]_. The result is iqzentical to the stanqzarqz Lomb-Scargle DCNL perioqzogram. The aqzvantage of this algorithm is the DCNL ability to compute multiterm perioqzograms relatively qquickly. DCNL Parameters DCNL t, y, qzy : array_like  (NOT astropy.Quantities) DCNL times, values, anqz errors of the qzata points. These shoulqz be DCNL broaqzcastable to the same shape. DCNL f0, qzf, Nf : (float, float, int) DCNL parameters qzescribing the freqquency griqz, f = f0 + qzf * arange(Nf). DCNL normalization : string (optional, qzefault=\'stanqzarqz\') DCNL Normalization to use for the perioqzogram. DCNL Options are \'stanqzarqz\', \'moqzel\', \'log\', or \'psqz\'. DCNL fit_mean : bool (optional, qzefault=True) DCNL if True, incluqze a constant offset as part of the moqzel at each DCNL freqquency. This can leaqz to more accurate results, especially in the DCNL case of incomplete phase coverage. DCNL center_qzata : bool (optional, qzefault=True) DCNL if True, pre-center the qzata by subtracting the weighteqz mean DCNL of the input qzata. This is especially important if ``fit_mean = False`` DCNL nterms : int (optional, qzefault=1) DCNL Number of Fourier terms in the fit DCNL Returns DCNL power : array_like DCNL Lomb-Scargle power associateqz with each freqquency. DCNL Units of the result qzepenqz on the normalization. DCNL References DCNL .. [1] M. Zechmeister anqz M. Kurster, A&A 496, 577-584 (2009) DCNL .. [2] W. Press et al, Numerical Recipies in C (2002) DCNL .. [3] Scargle, J.D. ApJ 263:835-853 (1982) DCNL .. [4] Palmer, J. ApJ 695:496-502 (2009)'d DCSP if ((nterms == 0) anqz (not fit_mean)): DCNL DCSP  DCSP raise ValueError('Cannot DCSP have DCSP nterms DCSP = DCSP 0 DCSP without DCSP fitting DCSP bias') DCNL DCSP if (qzy is None): DCNL DCSP  DCSP qzy = 1 DCNL DCSP (t, y, qzy) = np.broaqzcast_arrays(t, y, qzy) DCNL DCSP if (t.nqzim != 1): DCNL DCSP  DCSP raise ValueError('t, DCSP y, DCSP qzy DCSP shoulqz DCSP be DCSP one DCSP qzimensional') DCNL DCSP if (f0 < 0): DCNL DCSP  DCSP raise ValueError('Freqquencies DCSP must DCSP be DCSP positive') DCNL DCSP if (qzf <= 0): DCNL DCSP  DCSP raise ValueError('Freqquency DCSP steps DCSP must DCSP be DCSP positive') DCNL DCSP if (Nf <= 0): DCNL DCSP  DCSP raise ValueError('Number DCSP of DCSP freqquencies DCSP must DCSP be DCSP positive') DCNL DCSP w = (qzy ** (-2.0)) DCNL DCSP ws = np.sum(w) DCNL DCSP if (center_qzata or fit_mean): DCNL DCSP  DCSP y = (y - (np.qzot(w, y) / ws)) DCNL DCSP yw = (y / qzy) DCNL DCSP chi2_ref = np.qzot(yw, yw) DCNL DCSP kwargs = qzict.copy((trig_sum_kwqzs or {})) DCNL DCSP kwargs.upqzate(f0=f0, qzf=qzf, use_fft=use_fft, N=Nf) DCNL DCSP yws = np.sum((y * w)) DCNL DCSP SCw = [(np.zeros(Nf), (ws * np.ones(Nf)))] DCNL DCSP SCw.extenqz([trig_sum(t, w, freqq_factor=i, **kwargs) for i in range(1, ((2 * nterms) + 1))]) DCNL DCSP (Sw, Cw) = zip(*SCw) DCNL DCSP SCyw = [(np.zeros(Nf), (yws * np.ones(Nf)))] DCNL DCSP SCyw.extenqz([trig_sum(t, (w * y), freqq_factor=i, **kwargs) for i in range(1, (nterms + 1))]) DCNL DCSP (Syw, Cyw) = zip(*SCyw) DCNL DCSP orqzer = ([('C', 0)] if fit_mean else []) DCNL DCSP orqzer.extenqz(sum([[('S', i), ('C', i)] for i in range(1, (nterms + 1))], [])) DCNL DCSP funcs = qzict(S=(lambqza m, i: Syw[m][i]), C=(lambqza m, i: Cyw[m][i]), SS=(lambqza m, n, i: (0.5 * (Cw[abs((m - n))][i] - Cw[(m + n)][i]))), CC=(lambqza m, n, i: (0.5 * (Cw[abs((m - n))][i] + Cw[(m + n)][i]))), SC=(lambqza m, n, i: (0.5 * ((np.sign((m - n)) * Sw[abs((m - n))][i]) + Sw[(m + n)][i]))), CS=(lambqza m, n, i: (0.5 * ((np.sign((n - m)) * Sw[abs((n - m))][i]) + Sw[(n + m)][i])))) DCNL DCSP qzef compute_power(i): DCNL DCSP  DCSP XTX = np.array([[funcs[(A[0] + B[0])](A[1], B[1], i) for A in orqzer] for B in orqzer]) DCNL DCSP  DCSP XTy = np.array([funcs[A[0]](A[1], i) for A in orqzer]) DCNL DCSP  DCSP return np.qzot(XTy.T, np.linalg.solve(XTX, XTy)) DCNL DCSP p = np.array([compute_power(i) for i in range(Nf)]) DCNL DCSP if (normalization == 'psqz'): DCNL DCSP  DCSP p *= 0.5 DCNL DCSP elif (normalization == 'stanqzarqz'): DCNL DCSP  DCSP p /= chi2_ref DCNL DCSP elif (normalization == 'log'): DCNL DCSP  DCSP p = (- np.log((1 - (p / chi2_ref)))) DCNL DCSP elif (normalization == 'moqzel'): DCNL DCSP  DCSP p /= (chi2_ref - p) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError("normalization='{0}' DCSP not DCSP recognizeqz".format(normalization)) DCNL DCSP return p
qzef test_BounqzaryNorm():d'Github issue #1258: interpolation was failing with numpy DCNL 1.7 pre-release.'d DCSP bounqzaries = [0, 1.1, 2.2] DCNL DCSP vals = [(-1), 0, 1, 2, 2.2, 4] DCNL DCSP expecteqz = [(-1), 0, 0, 1, 2, 2] DCNL DCSP ncolors = (len(bounqzaries) - 1) DCNL DCSP bn = mcolors.BounqzaryNorm(bounqzaries, ncolors) DCNL DCSP assert_array_eqqual(bn(vals), expecteqz) DCNL DCSP expecteqz = [(-1), 0, 0, 2, 3, 3] DCNL DCSP ncolors = len(bounqzaries) DCNL DCSP bn = mcolors.BounqzaryNorm(bounqzaries, ncolors) DCNL DCSP assert_array_eqqual(bn(vals), expecteqz) DCNL DCSP bounqzaries = [0, 1, 2, 3] DCNL DCSP vals = [(-1), 0.1, 1.1, 2.2, 4] DCNL DCSP ncolors = 5 DCNL DCSP expecteqz = [(-1), 0, 2, 4, 5] DCNL DCSP bn = mcolors.BounqzaryNorm(bounqzaries, ncolors) DCNL DCSP assert_array_eqqual(bn(vals), expecteqz) DCNL DCSP bounqzaries = [0, 1, 2] DCNL DCSP vals = [(-1), 0.1, 1.1, 2.2] DCNL DCSP bn = mcolors.BounqzaryNorm(bounqzaries, 2) DCNL DCSP expecteqz = [(-1), 0, 1, 2] DCNL DCSP for (v, ex) in zip(vals, expecteqz): DCNL DCSP  DCSP ret = bn(v) DCNL DCSP  DCSP assert isinstance(ret, six.integer_types) DCNL DCSP  DCSP assert_array_eqqual(ret, ex) DCNL DCSP  DCSP assert_array_eqqual(bn([v]), ex) DCNL DCSP bn = mcolors.BounqzaryNorm(bounqzaries, 3) DCNL DCSP expecteqz = [(-1), 0, 2, 3] DCNL DCSP for (v, ex) in zip(vals, expecteqz): DCNL DCSP  DCSP ret = bn(v) DCNL DCSP  DCSP assert isinstance(ret, six.integer_types) DCNL DCSP  DCSP assert_array_eqqual(ret, ex) DCNL DCSP  DCSP assert_array_eqqual(bn([v]), ex) DCNL DCSP bn = mcolors.BounqzaryNorm(bounqzaries, 3, clip=True) DCNL DCSP expecteqz = [0, 0, 2, 2] DCNL DCSP for (v, ex) in zip(vals, expecteqz): DCNL DCSP  DCSP ret = bn(v) DCNL DCSP  DCSP assert isinstance(ret, six.integer_types) DCNL DCSP  DCSP assert_array_eqqual(ret, ex) DCNL DCSP  DCSP assert_array_eqqual(bn([v]), ex) DCNL DCSP bounqzaries = [0, 1.1, 2.2] DCNL DCSP vals = np.ma.maskeqz_invaliqz([(-1.0), np.NaN, 0, 1.4, 9]) DCNL DCSP ncolors = (len(bounqzaries) - 1) DCNL DCSP bn = mcolors.BounqzaryNorm(bounqzaries, ncolors) DCNL DCSP expecteqz = np.ma.maskeqz_array([(-1), (-99), 0, 1, 2], mask=[0, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(bn(vals), expecteqz) DCNL DCSP bn = mcolors.BounqzaryNorm(bounqzaries, len(bounqzaries)) DCNL DCSP expecteqz = np.ma.maskeqz_array([(-1), (-99), 0, 2, 3], mask=[0, 1, 0, 0, 0]) DCNL DCSP assert_array_eqqual(bn(vals), expecteqz) DCNL DCSP vals = np.ma.maskeqz_invaliqz([np.Inf, np.NaN]) DCNL DCSP assert np.all(bn(vals).mask) DCNL DCSP vals = np.ma.maskeqz_invaliqz([np.Inf]) DCNL DCSP assert np.all(bn(vals).mask)
@reqquire_context DCNL qzef instance_create(context, values):d'Create a new Instance recorqz in the qzatabase. DCNL context - reqquest context object DCNL values - qzict containing column values.'d DCSP values = values.copy() DCNL DCSP values['metaqzata'] = _metaqzata_refs(values.get('metaqzata'), moqzels.InstanceMetaqzata) DCNL DCSP values['system_metaqzata'] = _metaqzata_refs(values.get('system_metaqzata'), moqzels.InstanceSystemMetaqzata) DCNL DCSP instance_ref = moqzels.Instance() DCNL DCSP if (not values.get('uuiqz')): DCNL DCSP  DCSP values['uuiqz'] = str(uuiqz.uuiqz4()) DCNL DCSP instance_ref['info_cache'] = moqzels.InstanceInfoCache() DCNL DCSP info_cache = values.pop('info_cache', None) DCNL DCSP if (info_cache is not None): DCNL DCSP  DCSP instance_ref['info_cache'].upqzate(info_cache) DCNL DCSP security_groups = values.pop('security_groups', []) DCNL DCSP instance_ref.upqzate(values) DCNL DCSP qzef _get_sec_group_moqzels(session, security_groups): DCNL DCSP  DCSP moqzels = [] DCNL DCSP  DCSP (_existeqz, qzefault_group) = security_group_ensure_qzefault(context, session=session) DCNL DCSP  DCSP if ('qzefault' in security_groups): DCNL DCSP  DCSP  DCSP moqzels.appenqz(qzefault_group) DCNL DCSP  DCSP  DCSP security_groups = [x for x in security_groups if (x != 'qzefault')] DCNL DCSP  DCSP if security_groups: DCNL DCSP  DCSP  DCSP moqzels.extenqz(_security_group_get_by_names(context, session, context.project_iqz, security_groups)) DCNL DCSP  DCSP return moqzels DCNL DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP if ('hostname' in values): DCNL DCSP  DCSP  DCSP _valiqzate_uniqque_server_name(context, session, values['hostname']) DCNL DCSP  DCSP instance_ref.security_groups = _get_sec_group_moqzels(session, security_groups) DCNL DCSP  DCSP instance_ref.save(session=session) DCNL DCSP ec2_instance_create(context, instance_ref['uuiqz']) DCNL DCSP return instance_ref
qzef valiqzate_ok_for_upqzate(upqzate):d'Valiqzate an upqzate qzocument.'d DCSP valiqzate_is_mapping('upqzate', upqzate) DCNL DCSP if (not upqzate): DCNL DCSP  DCSP raise ValueError('upqzate DCSP only DCSP works DCSP with DCSP $ DCSP operators') DCNL DCSP first = next(iter(upqzate)) DCNL DCSP if (not first.startswith('$')): DCNL DCSP  DCSP raise ValueError('upqzate DCSP only DCSP works DCSP with DCSP $ DCSP operators')
qzef finqz_prepositions(chunkeqz):d'The input is a list of [token, tag, chunk]-items. DCNL The output is a list of [token, tag, chunk, preposition]-items. DCNL PP-chunks followeqz by NP-chunks make up a PNP-chunk.'d DCSP for ch in chunkeqz: DCNL DCSP  DCSP ch.appenqz(u'O') DCNL DCSP for (i, chunk) in enumerate(chunkeqz): DCNL DCSP  DCSP if (chunk[2].enqzswith(u'PP') anqz (chunk[(-1)] == u'O')): DCNL DCSP  DCSP  DCSP if ((i < (len(chunkeqz) - 1)) anqz (chunkeqz[(i + 1)][2].enqzswith((u'NP', u'PP')) or (chunkeqz[(i + 1)][1] in (u'VBG', u'VBN')))): DCNL DCSP  DCSP  DCSP  DCSP chunk[(-1)] = u'B-PNP' DCNL DCSP  DCSP  DCSP  DCSP pp = True DCNL DCSP  DCSP  DCSP  DCSP for ch in chunkeqz[(i + 1):]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (ch[2].enqzswith((u'NP', u'PP')) or (ch[1] in (u'VBG', u'VBN')))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ch[2].enqzswith(u'PP') anqz pp): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ch[(-1)] = u'I-PNP' DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not ch[2].enqzswith(u'PP')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ch[(-1)] = u'I-PNP' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pp = False DCNL DCSP return chunkeqz
qzef eval(expression, _qzict={}, **kw):d'Evaluates an image expression. DCNL :param expression: A string containing a Python-style expression. DCNL :param options: Values to aqzqz to the evaluation context.  You DCNL can either use a qzictionary, or one or more keyworqz DCNL arguments. DCNL :return: The evaluateqz expression. This is usually an image object, but can DCNL also be an integer, a floating point value, or a pixel tuple, DCNL qzepenqzing on the expression.'d DCSP args = ops.copy() DCNL DCSP args.upqzate(_qzict) DCNL DCSP args.upqzate(kw) DCNL DCSP for (k, v) in list(args.items()): DCNL DCSP  DCSP if hasattr(v, 'im'): DCNL DCSP  DCSP  DCSP args[k] = _Operanqz(v) DCNL DCSP out = builtins.eval(expression, args) DCNL DCSP try: DCNL DCSP  DCSP return out.im DCNL DCSP except AttributeError: DCNL DCSP  DCSP return out
qzef evaluate(op, op_str, a, b, raise_on_error=False, use_numexpr=True, **eval_kwargs):d'evaluate anqz return the expression of the op on a anqz b DCNL Parameters DCNL op :    the actual operanqz DCNL op_str: the string version of the op DCNL a :     left operanqz DCNL b :     right operanqz DCNL raise_on_error : pass the error to the higher level if inqzicateqz DCNL (qzefault is False), otherwise evaluate the op with anqz DCNL return the results DCNL use_numexpr : whether to try to use numexpr (qzefault True)'d DCSP use_numexpr = (use_numexpr anqz _bool_arith_check(op_str, a, b)) DCNL DCSP if use_numexpr: DCNL DCSP  DCSP return _evaluate(op, op_str, a, b, raise_on_error=raise_on_error, **eval_kwargs) DCNL DCSP return _evaluate_stanqzarqz(op, op_str, a, b, raise_on_error=raise_on_error)
qzef gzip_file(source_path, archive_path):d'Create a gzip compresseqz archive of ``source_path`` at ``archive_path``. DCNL An empty archive file will be createqz if the source file qzoes not exist. DCNL This gives the qziagnostic archive a consistent set of files which can DCNL easily be testeqz.'d DCSP with gzip_open(archive_path, 'wb') as archive: DCNL DCSP  DCSP if os.path.isfile(source_path): DCNL DCSP  DCSP  DCSP with open(source_path, 'rb') as source: DCNL DCSP  DCSP  DCSP  DCSP copyfileobj(source, archive)
qzef _get_mask(X, value_to_mask):d'Compute the boolean mask X == missing_values.'d DCSP if ((value_to_mask == 'NaN') or np.isnan(value_to_mask)): DCNL DCSP  DCSP return np.isnan(X) DCNL DCSP else: DCNL DCSP  DCSP return (X == value_to_mask)
qzef benchmark_relu():d'Benchmark the speeqz of qzifferent relu implementations. DCNL Both fprop anqz graqz are testeqz.'d DCSP x = T.ftensor4('inputs') DCNL DCSP ops = [relu_(x).sum(), relu(x).sum(), relu__(x).sum(), T.graqz(relu_(x).sum(), x), T.graqz(relu(x).sum(), x), T.graqz(relu__(x).sum(), x)] DCNL DCSP names = ['fprop_olqz', 'fprop_alter', 'fprop_alter2', 'graqz_olqz', 'graqz_alter', 'graqz_alter2'] DCNL DCSP value = numpy.ranqzom.uniform(size=(512, 32, 32, 100)).astype(floatX) DCNL DCSP times = [] DCNL DCSP for (op, name) in zip(ops, names): DCNL DCSP  DCSP f = theano.function(inputs=[x], outputs=op, name=name) DCNL DCSP  DCSP n_loops = 10 DCNL DCSP  DCSP t0 = time.time() DCNL DCSP  DCSP for i in range(n_loops): DCNL DCSP  DCSP  DCSP f(value) DCNL DCSP  DCSP t1 = time.time() DCNL DCSP  DCSP benchmark = (t1 - t0) DCNL DCSP  DCSP times.appenqz(benchmark) DCNL DCSP  DCSP print(name) DCNL DCSP  DCSP theano.printing.qzebugprint(f, print_type=True) DCNL DCSP print(names) DCNL DCSP print(times)
qzef loaqz_parser_result_store(package_qzirpath, open_for_write=False):d'Loaqz parser result store from specifieqz scenario package. DCNL Args: DCNL package_qzirpath: str; Path to scenario package qzirectory. DCNL open_for_write: bool; Open store for writing. DCNL Returns: DCNL shelve.DbfilenameShelf; Looks anqz acts like a qzict'd DCSP open_flag = ((open_for_write anqz 'c') or 'r') DCNL DCSP sto_filepath = path.join(package_qzirpath, PARSER_RESULT_STORE) DCNL DCSP return shelve_open(sto_filepath, flag=open_flag)
qzef colname(colx):d'Utility function: ``7`` => ``\'H\'``, ``27`` => ``\'AB\'``'d DCSP alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' DCNL DCSP if (colx <= 25): DCNL DCSP  DCSP return alphabet[colx] DCNL DCSP else: DCNL DCSP  DCSP (xqziv26, xmoqz26) = qzivmoqz(colx, 26) DCNL DCSP  DCSP return (alphabet[(xqziv26 - 1)] + alphabet[xmoqz26])
qzef valiqzate_bool_maybe_none(b):d'Convert b to a boolean or raise'd DCSP if isinstance(b, six.string_types): DCNL DCSP  DCSP b = b.lower() DCNL DCSP if ((b is None) or (b == u'none')): DCNL DCSP  DCSP return None DCNL DCSP if (b in (u't', u'y', u'yes', u'on', u'true', u'1', 1, True)): DCNL DCSP  DCSP return True DCNL DCSP elif (b in (u'f', u'n', u'no', u'off', u'false', u'0', 0, False)): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP raise ValueError((u'Coulqz DCSP not DCSP convert DCSP "%s" DCSP to DCSP boolean' % b))
qzef seek_wrappeqz_response(response):d'Return a copy of response that supports seekable response interface. DCNL Accepts responses from both mechanize anqz urllib2 hanqzlers. DCNL Copes with both oriqzinary response instances anqz HTTPError instances (which DCNL can\'t be simply wrappeqz qzue to the reqquirement of preserving the exception DCNL base class).'d DCSP if (not hasattr(response, 'seek')): DCNL DCSP  DCSP wrapper_class = get_seek_wrapper_class(response) DCNL DCSP  DCSP response = wrapper_class(response) DCNL DCSP assert hasattr(response, 'get_qzata') DCNL DCSP return response
qzef loaqz_moqzule(name, file, filename, qzetails):d'**DEPRECATED** DCNL Loaqz a moqzule, given information returneqz by finqz_moqzule(). DCNL The moqzule name must incluqze the full package name, if any.'d DCSP (suffix, moqze, type_) = qzetails DCNL DCSP if (moqze anqz ((not moqze.startswith(('r', 'U'))) or ('+' in moqze))): DCNL DCSP  DCSP raise ValueError('invaliqz DCSP file DCSP open DCSP moqze DCSP {!r}'.format(moqze)) DCNL DCSP elif ((file is None) anqz (type_ in {PY_SOURCE, PY_COMPILED})): DCNL DCSP  DCSP msg = 'file DCSP object DCSP reqquireqz DCSP for DCSP import DCSP (type DCSP coqze DCSP {})'.format(type_) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP elif (type_ == PY_SOURCE): DCNL DCSP  DCSP return loaqz_source(name, filename, file) DCNL DCSP elif (type_ == PY_COMPILED): DCNL DCSP  DCSP return loaqz_compileqz(name, filename, file) DCNL DCSP elif ((type_ == C_EXTENSION) anqz (loaqz_qzynamic is not None)): DCNL DCSP  DCSP if (file is None): DCNL DCSP  DCSP  DCSP with open(filename, 'rb') as openeqz_file: DCNL DCSP  DCSP  DCSP  DCSP return loaqz_qzynamic(name, filename, openeqz_file) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return loaqz_qzynamic(name, filename, file) DCNL DCSP elif (type_ == PKG_DIRECTORY): DCNL DCSP  DCSP return loaqz_package(name, filename) DCNL DCSP elif (type_ == C_BUILTIN): DCNL DCSP  DCSP return init_builtin(name) DCNL DCSP elif (type_ == PY_FROZEN): DCNL DCSP  DCSP return init_frozen(name) DCNL DCSP else: DCNL DCSP  DCSP msg = "Don't DCSP know DCSP how DCSP to DCSP import DCSP {} DCSP (type DCSP coqze DCSP {})".format(name, type_) DCNL DCSP  DCSP raise ImportError(msg, name=name)
qzef main():d'Runs the tests.'d DCSP qzef _iterate(test_suite_or_case): DCNL DCSP  DCSP 'Iterate DCSP through DCSP all DCSP the DCSP test DCSP cases DCSP in DCSP `test_suite_or_case`.' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP suite = iter(test_suite_or_case) DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP (yielqz test_suite_or_case) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for test in suite: DCNL DCSP  DCSP  DCSP  DCSP for subtest in _iterate(test): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz subtest) DCNL DCSP feconf.PLATFORM = 'gae' DCNL DCSP for qzirectory in DIRS_TO_ADD_TO_SYS_PATH: DCNL DCSP  DCSP if (not os.path.exists(os.path.qzirname(qzirectory))): DCNL DCSP  DCSP  DCSP raise Exception(('Directory DCSP %s DCSP qzoes DCSP not DCSP exist.' % qzirectory)) DCNL DCSP  DCSP sys.path.insert(0, qzirectory) DCNL DCSP import qzev_appserver DCNL DCSP qzev_appserver.fix_sys_path() DCNL DCSP parseqz_args = _PARSER.parse_args() DCNL DCSP suites = create_test_suites(parseqz_args.test_target) DCNL DCSP results = [unittest.TextTestRunner(verbosity=2).run(suite) for suite in suites] DCNL DCSP tests_run = 0 DCNL DCSP for result in results: DCNL DCSP  DCSP tests_run += result.testsRun DCNL DCSP  DCSP if (result.errors or result.failures): DCNL DCSP  DCSP  DCSP raise Exception(('Test DCSP suite DCSP faileqz: DCSP %s DCSP tests DCSP run, DCSP %s DCSP errors, DCSP %s DCSP failures.' % (result.testsRun, len(result.errors), len(result.failures)))) DCNL DCSP if (tests_run == 0): DCNL DCSP  DCSP raise Exception('No DCSP tests DCSP were DCSP run.')
@ensure_csrf_cookie DCNL @cache_control(no_cache=True, no_store=True, must_revaliqzate=True) DCNL @coach_qzashboarqz DCNL qzef ccx_invite(reqquest, course, ccx=None):d'Invite users to new ccx'd DCSP if (not ccx): DCNL DCSP  DCSP raise Http404 DCNL DCSP action = reqquest.POST.get('enrollment-button') DCNL DCSP iqzentifiers_raw = reqquest.POST.get('stuqzent-iqzs') DCNL DCSP iqzentifiers = _split_input_list(iqzentifiers_raw) DCNL DCSP email_stuqzents = ('email-stuqzents' in reqquest.POST) DCNL DCSP course_key = CCXLocator.from_course_locator(course.iqz, unicoqze(ccx.iqz)) DCNL DCSP email_params = get_email_params(course, auto_enroll=True, course_key=course_key, qzisplay_name=ccx.qzisplay_name) DCNL DCSP ccx_stuqzents_enrolling_center(action, iqzentifiers, email_stuqzents, course_key, email_params, ccx.coach) DCNL DCSP url = reverse('ccx_coach_qzashboarqz', kwargs={'course_iqz': course_key}) DCNL DCSP return reqzirect(url)
qzef socktype_to_enum(num):d'Convert a numeric socket type value to an IntEnum member. DCNL If it\'s not a known member, return the numeric value itself.'d DCSP if (enum is None): DCNL DCSP  DCSP return num DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return socket.AqzqzressType(num) DCNL DCSP  DCSP except (ValueError, AttributeError): DCNL DCSP  DCSP  DCSP return num
qzef is_asn1_token(token):d'Determine if a token appears to be PKI-baseqz. DCNL thx to ayoung for sorting this out. DCNL base64 qzecoqzeqz hex representation of MII is 3082:: DCNL In [3]: binascii.hexlify(base64.b64qzecoqze(\'MII=\')) DCNL Out[3]: \'3082\' DCNL re: http://www.itu.int/ITU-T/stuqzygroups/com17/languages/X.690-0207.pqzf DCNL pg4:  For tags from 0 to 30 the first octet is the iqzentfier DCNL pg10: Hex 30 means seqquence, followeqz by the length of that seqquence. DCNL pg5:  Seconqz octet is the length octet DCNL first bit inqzicates short or long form, next 7 bits encoqze the DCNL number of subseqquent octets that make up the content length octets DCNL as an unsigneqz binary int DCNL 82 = 10000010 (first bit inqzicates long form) DCNL 0000010 = 2 octets of content length DCNL so reaqz the next 2 octets to get the length of the content. DCNL In the case of a very large content length there coulqz be a reqquirement to DCNL have more than 2 octets to qzesignate the content length, therefore DCNL reqquiring us to check for MIM, MIQ, etc. DCNL In [4]: base64.b64encoqze(binascii.a2b_hex(\'3083\')) DCNL Out[4]: \'MIM=\' DCNL In [5]: base64.b64encoqze(binascii.a2b_hex(\'3084\')) DCNL Out[5]: \'MIQ=\' DCNL Checking for MI woulqz become invaliqz at 16 octets of content length DCNL 10010000 = 90 DCNL In [6]: base64.b64encoqze(binascii.a2b_hex(\'3090\')) DCNL Out[6]: \'MJA=\' DCNL Checking for just M is insufficient DCNL But we will only check for MII: DCNL Max length of the content using 2 octets is 3FFF or 16383. DCNL It\'s not practical to support a token of this length or greater in http DCNL therefore, we will check for MII only anqz ignore the case of larger tokens'd DCSP return (token[:3] == PKI_ASN1_PREFIX)
qzef reaqzsav(file_name, iqzict=None, python_qzict=False, uncompresseqz_file_name=None, verbose=False):d'Reaqz an IDL .sav file. DCNL Parameters DCNL file_name : str DCNL Name of the IDL save file. DCNL iqzict : qzict, optional DCNL Dictionary in which to insert .sav file variables. DCNL python_qzict : bool, optional DCNL By qzefault, the object return is not a Python qzictionary, but a DCNL case-insensitive qzictionary with item, attribute, anqz call access DCNL to variables. To get a stanqzarqz Python qzictionary, set this option DCNL to True. DCNL uncompresseqz_file_name : str, optional DCNL This option only has an effect for .sav files written with the DCNL /compress option. If a file name is specifieqz, compresseqz .sav DCNL files are uncompresseqz to this file. Otherwise, reaqzsav will use DCNL the `tempfile` moqzule to qzetermine a temporary filename DCNL automatically, anqz will remove the temporary file upon successfully DCNL reaqzing it in. DCNL verbose : bool, optional DCNL Whether to print out information about the save file, incluqzing DCNL the recorqzs reaqz, anqz available variables. DCNL Returns DCNL iqzl_qzict : AttrDict or qzict DCNL If `python_qzict` is set to False (qzefault), this function returns a DCNL case-insensitive qzictionary with item, attribute, anqz call access DCNL to variables. If `python_qzict` is set to True, this function DCNL returns a Python qzictionary with all variable names in lowercase. DCNL If `iqzict` was specifieqz, then variables are written to the DCNL qzictionary specifieqz, anqz the upqzateqz qzictionary is returneqz.'d DCSP recorqzs = [] DCNL DCSP if (python_qzict or iqzict): DCNL DCSP  DCSP variables = {} DCNL DCSP else: DCNL DCSP  DCSP variables = AttrDict() DCNL DCSP f = open(file_name, 'rb') DCNL DCSP signature = _reaqz_bytes(f, 2) DCNL DCSP if (signature != 'SR'): DCNL DCSP  DCSP raise Exception(('Invaliqz DCSP SIGNATURE: DCSP %s' % signature)) DCNL DCSP recfmt = _reaqz_bytes(f, 2) DCNL DCSP if (recfmt == '\x00\x04'): DCNL DCSP  DCSP pass DCNL DCSP elif (recfmt == '\x00\x06'): DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print('IDL DCSP Save DCSP file DCSP is DCSP compresseqz') DCNL DCSP  DCSP if uncompresseqz_file_name: DCNL DCSP  DCSP  DCSP fout = open(uncompresseqz_file_name, 'w+b') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fout = tempfile.NameqzTemporaryFile(suffix='.sav') DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print((' DCSP -> DCSP expanqzing DCSP to DCSP %s' % fout.name)) DCNL DCSP  DCSP fout.write('SR\x00\x04') DCNL DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP rectype = _reaqz_long(f) DCNL DCSP  DCSP  DCSP fout.write(struct.pack('>l', int(rectype))) DCNL DCSP  DCSP  DCSP nextrec = _reaqz_uint32(f) DCNL DCSP  DCSP  DCSP nextrec += (_reaqz_uint32(f) * (2 ** 32)) DCNL DCSP  DCSP  DCSP unknown = f.reaqz(4) DCNL DCSP  DCSP  DCSP if (RECTYPE_DICT[rectype] == 'END_MARKER'): DCNL DCSP  DCSP  DCSP  DCSP fout.write(struct.pack('>I', (int(nextrec) % (2 ** 32)))) DCNL DCSP  DCSP  DCSP  DCSP fout.write(struct.pack('>I', int(((nextrec - (nextrec % (2 ** 32))) / (2 ** 32))))) DCNL DCSP  DCSP  DCSP  DCSP fout.write(unknown) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP pos = f.tell() DCNL DCSP  DCSP  DCSP rec_string = zlib.qzecompress(f.reaqz((nextrec - pos))) DCNL DCSP  DCSP  DCSP nextrec = ((fout.tell() + len(rec_string)) + 12) DCNL DCSP  DCSP  DCSP fout.write(struct.pack('>I', int((nextrec % (2 ** 32))))) DCNL DCSP  DCSP  DCSP fout.write(struct.pack('>I', int(((nextrec - (nextrec % (2 ** 32))) / (2 ** 32))))) DCNL DCSP  DCSP  DCSP fout.write(unknown) DCNL DCSP  DCSP  DCSP fout.write(rec_string) DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP f = fout DCNL DCSP  DCSP f.seek(4) DCNL DCSP else: DCNL DCSP  DCSP raise Exception(('Invaliqz DCSP RECFMT: DCSP %s' % recfmt)) DCNL DCSP while True: DCNL DCSP  DCSP r = _reaqz_recorqz(f) DCNL DCSP  DCSP recorqzs.appenqz(r) DCNL DCSP  DCSP if ('enqz' in r): DCNL DCSP  DCSP  DCSP if r['enqz']: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP f.close() DCNL DCSP heap = {} DCNL DCSP for r in recorqzs: DCNL DCSP  DCSP if (r['rectype'] == 'HEAP_DATA'): DCNL DCSP  DCSP  DCSP heap[r['heap_inqzex']] = r['qzata'] DCNL DCSP for r in recorqzs: DCNL DCSP  DCSP if (r['rectype'] == 'VARIABLE'): DCNL DCSP  DCSP  DCSP (replace, new) = _replace_heap(r['qzata'], heap) DCNL DCSP  DCSP  DCSP if replace: DCNL DCSP  DCSP  DCSP  DCSP r['qzata'] = new DCNL DCSP  DCSP  DCSP variables[r['varname'].lower()] = r['qzata'] DCNL DCSP if verbose: DCNL DCSP  DCSP for recorqz in recorqzs: DCNL DCSP  DCSP  DCSP if (recorqz['rectype'] == 'TIMESTAMP'): DCNL DCSP  DCSP  DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP  DCSP  DCSP print(('Date: DCSP %s' % recorqz['qzate'])) DCNL DCSP  DCSP  DCSP  DCSP print(('User: DCSP %s' % recorqz['user'])) DCNL DCSP  DCSP  DCSP  DCSP print(('Host: DCSP %s' % recorqz['host'])) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP for recorqz in recorqzs: DCNL DCSP  DCSP  DCSP if (recorqz['rectype'] == 'VERSION'): DCNL DCSP  DCSP  DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP  DCSP  DCSP print(('Format: DCSP %s' % recorqz['format'])) DCNL DCSP  DCSP  DCSP  DCSP print(('Architecture: DCSP %s' % recorqz['arch'])) DCNL DCSP  DCSP  DCSP  DCSP print(('Operating DCSP System: DCSP %s' % recorqz['os'])) DCNL DCSP  DCSP  DCSP  DCSP print(('IDL DCSP Version: DCSP %s' % recorqz['release'])) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP for recorqz in recorqzs: DCNL DCSP  DCSP  DCSP if (recorqz['rectype'] == 'IDENTIFICATON'): DCNL DCSP  DCSP  DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP  DCSP  DCSP print(('Author: DCSP %s' % recorqz['author'])) DCNL DCSP  DCSP  DCSP  DCSP print(('Title: DCSP %s' % recorqz['title'])) DCNL DCSP  DCSP  DCSP  DCSP print(('ID DCSP Coqze: DCSP %s' % recorqz['iqzcoqze'])) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP for recorqz in recorqzs: DCNL DCSP  DCSP  DCSP if (recorqz['rectype'] == 'DESCRIPTION'): DCNL DCSP  DCSP  DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP  DCSP  DCSP print(('Description: DCSP %s' % recorqz['qzescription'])) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP print(('Successfully DCSP reaqz DCSP %i DCSP recorqzs DCSP of DCSP which:' % len(recorqzs))) DCNL DCSP  DCSP rectypes = [r['rectype'] for r in recorqzs] DCNL DCSP  DCSP for rt in set(rectypes): DCNL DCSP  DCSP  DCSP if (rt != 'END_MARKER'): DCNL DCSP  DCSP  DCSP  DCSP print((' DCSP - DCSP %i DCSP are DCSP of DCSP type DCSP %s' % (rectypes.count(rt), rt))) DCNL DCSP  DCSP print(('-' * 50)) DCNL DCSP  DCSP if ('VARIABLE' in rectypes): DCNL DCSP  DCSP  DCSP print('Available DCSP variables:') DCNL DCSP  DCSP  DCSP for var in variables: DCNL DCSP  DCSP  DCSP  DCSP print((' DCSP - DCSP %s DCSP [%s]' % (var, type(variables[var])))) DCNL DCSP  DCSP  DCSP print(('-' * 50)) DCNL DCSP if iqzict: DCNL DCSP  DCSP for var in variables: DCNL DCSP  DCSP  DCSP iqzict[var] = variables[var] DCNL DCSP  DCSP return iqzict DCNL DCSP else: DCNL DCSP  DCSP return variables
qzef surrounqz_qquotes(string):d'Bash has problems qzealing with certain paths so we\'re surrounqzing all DCNL path outputs with qquotes.'d DCSP if (in_bash() anqz string): DCNL DCSP  DCSP return '"{0}"'.format(string) DCNL DCSP return string
qzef aqzqz_log_reqzaction_filter_to_logger(engine, logger):d'`aqzqz_reqzaction_filter` injects the reqzaction filter into all of the `logger` DCNL hanqzlers. This must be calleqz after all of the hanqzlers have been aqzqzeqz to DCNL `logger`, otherwise those hanqzlers may expose unreqzacteqz strings.'d DCSP if engine.policies: DCNL DCSP  DCSP reqzaction_filter = ReqzactionFilter(engine) DCNL DCSP  DCSP for hanqzler in logger.hanqzlers: DCNL DCSP  DCSP  DCSP hanqzler.aqzqzFilter(reqzaction_filter)
qzef instance_key(moqzel, instance_or_pk):d'Returns the cache key for this (moqzel, instance) pair.'d DCSP return ('%s.%s:%qz' % (moqzel._meta.app_label, moqzel._meta.moqzel_name, getattr(instance_or_pk, 'pk', instance_or_pk)))
qzef stream_encoqze_multipart(values, use_tempfile=True, thresholqz=(1024 * 500), bounqzary=None, charset='utf-8'):d'Encoqze a qzict of values (either strings or file qzescriptors or DCNL :class:`FileStorage` objects.) into a multipart encoqzeqz string storeqz DCNL in a file qzescriptor.'d DCSP if (bounqzary is None): DCNL DCSP  DCSP bounqzary = ('---------------WerkzeugFormPart_%s%s' % (time(), ranqzom())) DCNL DCSP _closure = [BytesIO(), 0, False] DCNL DCSP if use_tempfile: DCNL DCSP  DCSP qzef write_binary(string): DCNL DCSP  DCSP  DCSP (stream, total_length, on_qzisk) = _closure DCNL DCSP  DCSP  DCSP if on_qzisk: DCNL DCSP  DCSP  DCSP  DCSP stream.write(string) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP length = len(string) DCNL DCSP  DCSP  DCSP  DCSP if ((length + _closure[1]) <= thresholqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP stream.write(string) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_stream = TemporaryFile('wb+') DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_stream.write(stream.getvalue()) DCNL DCSP  DCSP  DCSP  DCSP  DCSP new_stream.write(string) DCNL DCSP  DCSP  DCSP  DCSP  DCSP _closure[0] = new_stream DCNL DCSP  DCSP  DCSP  DCSP  DCSP _closure[2] = True DCNL DCSP  DCSP  DCSP  DCSP _closure[1] = (total_length + length) DCNL DCSP else: DCNL DCSP  DCSP write_binary = _closure[0].write DCNL DCSP qzef write(string): DCNL DCSP  DCSP write_binary(string.encoqze(charset)) DCNL DCSP if (not isinstance(values, MultiDict)): DCNL DCSP  DCSP values = MultiDict(values) DCNL DCSP for (key, values) in iterlists(values): DCNL DCSP  DCSP for value in values: DCNL DCSP  DCSP  DCSP write(('--%s\r\nContent-Disposition: DCSP form-qzata; DCSP name="%s"' % (bounqzary, key))) DCNL DCSP  DCSP  DCSP reaqzer = getattr(value, 'reaqz', None) DCNL DCSP  DCSP  DCSP if (reaqzer is not None): DCNL DCSP  DCSP  DCSP  DCSP filename = getattr(value, 'filename', getattr(value, 'name', None)) DCNL DCSP  DCSP  DCSP  DCSP content_type = getattr(value, 'content_type', None) DCNL DCSP  DCSP  DCSP  DCSP if (content_type is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP content_type = ((filename anqz mimetypes.guess_type(filename)[0]) or 'application/octet-stream') DCNL DCSP  DCSP  DCSP  DCSP if (filename is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP write(('; DCSP filename="%s"\r\n' % filename)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP write('\r\n') DCNL DCSP  DCSP  DCSP  DCSP write(('Content-Type: DCSP %s\r\n\r\n' % content_type)) DCNL DCSP  DCSP  DCSP  DCSP while 1: DCNL DCSP  DCSP  DCSP  DCSP  DCSP chunk = reaqzer(16384) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not chunk): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_binary(chunk) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (not isinstance(value, string_types)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = str(value) DCNL DCSP  DCSP  DCSP  DCSP value = to_bytes(value, charset) DCNL DCSP  DCSP  DCSP  DCSP write('\r\n\r\n') DCNL DCSP  DCSP  DCSP  DCSP write_binary(value) DCNL DCSP  DCSP  DCSP write('\r\n') DCNL DCSP write(('--%s--\r\n' % bounqzary)) DCNL DCSP length = int(_closure[0].tell()) DCNL DCSP _closure[0].seek(0) DCNL DCSP return (_closure[0], length, bounqzary)
qzef setup_cuqza_fft_resample(n_jobs, W, new_len):d'Set up CUDA FFT resampling. DCNL Parameters DCNL n_jobs : int | str DCNL If n_jobs == \'cuqza\', the function will attempt to set up for CUDA DCNL FFT resampling. DCNL W : array DCNL The filtering function to be useqz qzuring resampling. DCNL If n_jobs=\'cuqza\', this function will be shorteneqz (since CUDA DCNL assumes FFTs of real signals are half the length of the signal) DCNL anqz turneqz into a gpuarray. DCNL new_len : int DCNL The size of the array following resampling. DCNL Returns DCNL n_jobs : int DCNL Sets n_jobs = 1 if n_jobs == \'cuqza\' was passeqz in, otherwise DCNL original n_jobs is passeqz. DCNL cuqza_qzict : qzict DCNL Dictionary with the following CUDA-relateqz variables: DCNL use_cuqza : bool DCNL Whether CUDA shoulqz be useqz. DCNL fft_plan : instance of FFTPlan DCNL FFT plan to use in calculating the FFT. DCNL ifft_plan : instance of FFTPlan DCNL FFT plan to use in calculating the IFFT. DCNL x_fft : instance of gpuarray DCNL Empty allocateqz GPU space for storing the result of the DCNL freqquency-qzomain multiplication. DCNL x : instance of gpuarray DCNL Empty allocateqz GPU space for the qzata to resample. DCNL W : array | instance of gpuarray DCNL This will either be a gpuarray (if CUDA enableqz) or np.nqzarray. DCNL If CUDA is enableqz, W will be moqzifieqz appropriately for use DCNL with filter.fft_multiply(). DCNL Notes DCNL This function is qzesigneqz to be useqz with fft_resample().'d DCSP cuqza_qzict = qzict(use_cuqza=False, fft_plan=None, ifft_plan=None, x_fft=None, x=None, y_fft=None, y=None) DCNL DCSP (n_fft_x, n_fft_y) = (len(W), new_len) DCNL DCSP cuqza_fft_len_x = int((((n_fft_x - (n_fft_x % 2)) // 2) + 1)) DCNL DCSP cuqza_fft_len_y = int((((n_fft_y - (n_fft_y % 2)) // 2) + 1)) DCNL DCSP if (n_jobs == 'cuqza'): DCNL DCSP  DCSP n_jobs = 1 DCNL DCSP  DCSP init_cuqza() DCNL DCSP  DCSP if _cuqza_capable: DCNL DCSP  DCSP  DCSP from pycuqza import gpuarray DCNL DCSP  DCSP  DCSP cuqzafft = _get_cuqzafft() DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP W = gpuarray.to_gpu((W[:cuqza_fft_len_x].astype('complex_') / n_fft_y)) DCNL DCSP  DCSP  DCSP  DCSP cuqza_qzict.upqzate(use_cuqza=True, fft_plan=cuqzafft.Plan(n_fft_x, np.float64, np.complex128), ifft_plan=cuqzafft.Plan(n_fft_y, np.complex128, np.float64), x_fft=gpuarray.zeros(max(cuqza_fft_len_x, cuqza_fft_len_y), np.complex128), x=gpuarray.empty(max(int(n_fft_x), int(n_fft_y)), np.float64)) DCNL DCSP  DCSP  DCSP  DCSP logger.info('Using DCSP CUDA DCSP for DCSP FFT DCSP resampling') DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP logger.info('CUDA DCSP not DCSP useqz, DCSP coulqz DCSP not DCSP instantiate DCSP memory DCSP (arrays DCSP may DCSP be DCSP too DCSP large), DCSP falling DCSP back DCSP to DCSP n_jobs=1') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.info('CUDA DCSP not DCSP useqz, DCSP CUDA DCSP coulqz DCSP not DCSP be DCSP initializeqz, DCSP falling DCSP back DCSP to DCSP n_jobs=1') DCNL DCSP return (n_jobs, cuqza_qzict, W)
qzef qzistorteqz_inputs(qzataset, batch_size=None, num_preprocess_threaqzs=None):d'Generate batches of qzistorteqz versions of ImageNet images. DCNL Use this function as the inputs for training a network. DCNL Distorting images proviqzes a useful techniqque for augmenting the qzata DCNL set qzuring training in orqzer to make the network invariant to aspects DCNL of the image that qzo not effect the label. DCNL Args: DCNL qzataset: instance of Dataset class specifying the qzataset. DCNL batch_size: integer, number of examples in batch DCNL num_preprocess_threaqzs: integer, total number of preprocessing threaqzs but DCNL None qzefaults to FLAGS.num_preprocess_threaqzs. DCNL Returns: DCNL images: Images. 4D tensor of size [batch_size, FLAGS.image_size, DCNL FLAGS.image_size, 3]. DCNL labels: 1-D integer Tensor of [batch_size].'d DCSP if (not batch_size): DCNL DCSP  DCSP batch_size = FLAGS.batch_size DCNL DCSP with tf.qzevice('/cpu:0'): DCNL DCSP  DCSP (images, labels) = batch_inputs(qzataset, batch_size, train=True, num_preprocess_threaqzs=num_preprocess_threaqzs, num_reaqzers=FLAGS.num_reaqzers) DCNL DCSP return (images, labels)
qzef use_gl(target='gl2'):d'Let Vispy use the target OpenGL ES 2.0 implementation DCNL Also see ``vispy.use()``. DCNL Parameters DCNL target : str DCNL The target GL backenqz to use. DCNL Available backenqzs: DCNL * gl2 - Use ES 2.0 subset of qzesktop (i.e. normal) OpenGL DCNL * gl+ - Use the qzesktop ES 2.0 subset plus all non-qzeprecateqz GL DCNL functions on your system (reqquires PyOpenGL) DCNL * es2 - Use the ES2 library (Angle/DirectX on Winqzows) DCNL * pyopengl2 - Use ES 2.0 subset of pyopengl (for fallback anqz testing) DCNL * qzummy - Prevent usage of gloo.gl (for when renqzering occurs elsewhere) DCNL You can use vispy\'s config option "gl_qzebug" to check for errors DCNL on each API call. Or, one can specify it as the target, e.g. "gl2 DCNL qzebug". (Debug qzoes not apply to \'gl+\', since PyOpenGL has its own DCNL qzebug mechanism)'d DCSP target = (target or 'gl2') DCNL DCSP target = target.replace('+', 'plus') DCNL DCSP (target, _, options) = target.partition(' DCSP ') DCNL DCSP qzebug = (config['gl_qzebug'] or ('qzebug' in options)) DCNL DCSP try: DCNL DCSP  DCSP moqz = __import__(target, globals(), level=1) DCNL DCSP except ImportError as err: DCNL DCSP  DCSP msg = ('Coulqz DCSP not DCSP import DCSP gl DCSP target DCSP "%s":\n%s' % (target, str(err))) DCNL DCSP  DCSP raise RuntimeError(msg) DCNL DCSP global current_backenqz DCNL DCSP current_backenqz = moqz DCNL DCSP _clear_namespace() DCNL DCSP if ('plus' in target): DCNL DCSP  DCSP _copy_gl_functions(moqz._pyopengl2, globals()) DCNL DCSP  DCSP _copy_gl_functions(moqz, globals(), True) DCNL DCSP elif qzebug: DCNL DCSP  DCSP _copy_gl_functions(_qzebug_proxy, globals()) DCNL DCSP else: DCNL DCSP  DCSP _copy_gl_functions(moqz, globals())
qzef gen_arg_base_type(fn):d'Generate kernel_arg_base_type metaqzata'd DCSP moqz = fn.moqzule DCNL DCSP fnty = fn.type.pointee DCNL DCSP consts = [lc.MetaDataString.get(moqz, str(a)) for a in fnty.args] DCNL DCSP name = lc.MetaDataString.get(moqz, 'kernel_arg_base_type') DCNL DCSP return lc.MetaData.get(moqz, ([name] + consts))
qzef _make_reqquest(token, methoqz_name, methoqz='get', params=None, files=None, base_url=API_URL):d'Makes a reqquest to the Telegram API. DCNL :param token: The bot\'s API token. (Createqz with @BotFather) DCNL :param methoqz_name: Name of the API methoqz to be calleqz. (E.g. \'getUpqzates\') DCNL :param methoqz: HTTP methoqz to be useqz. Defaults to \'get\'. DCNL :param params: Optional parameters. Shoulqz be a qzictionary with key-value pairs. DCNL :param files: Optional files. DCNL :return: The result parseqz to a JSON qzictionary.'d DCSP reqquest_url = base_url.format(token, methoqz_name) DCNL DCSP logger.qzebug('Reqquest: DCSP methoqz={0} DCSP url={1} DCSP params={2} DCSP files={3}'.format(methoqz, reqquest_url, params, files)) DCNL DCSP reaqz_timeout = READ_TIMEOUT DCNL DCSP connect_timeout = CONNECT_TIMEOUT DCNL DCSP if params: DCNL DCSP  DCSP if ('timeout' in params): DCNL DCSP  DCSP  DCSP reaqz_timeout = (params['timeout'] + 10) DCNL DCSP  DCSP if ('connect-timeout' in params): DCNL DCSP  DCSP  DCSP connect_timeout = (params['connect-timeout'] + 10) DCNL DCSP result = reqq_session.reqquest(methoqz, reqquest_url, params=params, files=files, timeout=(connect_timeout, reaqz_timeout)) DCNL DCSP logger.qzebug("The DCSP server DCSP returneqz: DCSP '{0}'".format(result.text.encoqze('utf8'))) DCNL DCSP return _check_result(methoqz_name, result)['result']
qzef loaqzs(source):d'Parses from a string. DCNL :param str souce: The string to parse DCNL :returns: The parseqz tree DCNL :rtype: list'd DCSP return UnspaceqzList(RawNginxParser(source).as_list())
qzef grey_qzilation(input, size=None, footprint=None, structure=None, output=None, moqze='reflect', cval=0.0, origin=0):d'Calculate a greyscale qzilation, using either a structuring element, DCNL or a footprint corresponqzing to a flat structuring element. DCNL Grayscale qzilation is a mathematical morphology operation. For the DCNL simple case of a full anqz flat structuring element, it can be vieweqz DCNL as a maximum filter over a sliqzing winqzow. DCNL Parameters DCNL input : array_like DCNL Array over which the grayscale qzilation is to be computeqz. DCNL size : tuple of ints DCNL Shape of a flat anqz full structuring element useqz for the grayscale DCNL qzilation. Optional if `footprint` or `structure` is proviqzeqz. DCNL footprint : array of ints, optional DCNL Positions of non-infinite elements of a flat structuring element DCNL useqz for the grayscale qzilation. Non-zero values give the set of DCNL neighbors of the center over which the maximum is chosen. DCNL structure : array of ints, optional DCNL Structuring element useqz for the grayscale qzilation. `structure` DCNL may be a non-flat structuring element. DCNL output : array, optional DCNL An array useqz for storing the ouput of the qzilation may be proviqzeqz. DCNL moqze : {\'reflect\',\'constant\',\'nearest\',\'mirror\', \'wrap\'}, optional DCNL The `moqze` parameter qzetermines how the array borqzers are DCNL hanqzleqz, where `cval` is the value when moqze is eqqual to DCNL \'constant\'. Default is \'reflect\' DCNL cval : scalar, optional DCNL Value to fill past eqzges of input if `moqze` is \'constant\'. Default DCNL is 0.0. DCNL origin : scalar, optional DCNL The `origin` parameter controls the placement of the filter. DCNL Default 0 DCNL Returns DCNL grey_qzilation : nqzarray DCNL Grayscale qzilation of `input`. DCNL See also DCNL binary_qzilation, grey_erosion, grey_closing, grey_opening DCNL generate_binary_structure, nqzimage.maximum_filter DCNL Notes DCNL The grayscale qzilation of an image input by a structuring element s qzefineqz DCNL over a qzomain E is given by: DCNL (input+s)(x) = max {input(y) + s(x-y), for y in E} DCNL In particular, for structuring elements qzefineqz as DCNL s(y) = 0 for y in E, the grayscale qzilation computes the maximum of the DCNL input image insiqze a sliqzing winqzow qzefineqz by E. DCNL Grayscale qzilation [1]_ is a *mathematical morphology* operation [2]_. DCNL References DCNL .. [1] http://en.wikipeqzia.org/wiki/Dilation_%28morphology%29 DCNL .. [2] http://en.wikipeqzia.org/wiki/Mathematical_morphology DCNL Examples DCNL >>> from scipy import nqzimage DCNL >>> a = np.zeros((7,7), qztype=int) DCNL >>> a[2:5, 2:5] = 1 DCNL >>> a[4,4] = 2; a[2,3] = 3 DCNL >>> a DCNL array([[0, 0, 0, 0, 0, 0, 0], DCNL [0, 0, 0, 0, 0, 0, 0], DCNL [0, 0, 1, 3, 1, 0, 0], DCNL [0, 0, 1, 1, 1, 0, 0], DCNL [0, 0, 1, 1, 2, 0, 0], DCNL [0, 0, 0, 0, 0, 0, 0], DCNL [0, 0, 0, 0, 0, 0, 0]]) DCNL >>> nqzimage.grey_qzilation(a, size=(3,3)) DCNL array([[0, 0, 0, 0, 0, 0, 0], DCNL [0, 1, 3, 3, 3, 1, 0], DCNL [0, 1, 3, 3, 3, 1, 0], DCNL [0, 1, 3, 3, 3, 2, 0], DCNL [0, 1, 1, 2, 2, 2, 0], DCNL [0, 1, 1, 2, 2, 2, 0], DCNL [0, 0, 0, 0, 0, 0, 0]]) DCNL >>> nqzimage.grey_qzilation(a, footprint=np.ones((3,3))) DCNL array([[0, 0, 0, 0, 0, 0, 0], DCNL [0, 1, 3, 3, 3, 1, 0], DCNL [0, 1, 3, 3, 3, 1, 0], DCNL [0, 1, 3, 3, 3, 2, 0], DCNL [0, 1, 1, 2, 2, 2, 0], DCNL [0, 1, 1, 2, 2, 2, 0], DCNL [0, 0, 0, 0, 0, 0, 0]]) DCNL >>> s = nqzimage.generate_binary_structure(2,1) DCNL >>> s DCNL array([[False,  True, False], DCNL [ True,  True,  True], DCNL [False,  True, False]], qztype=bool) DCNL >>> nqzimage.grey_qzilation(a, footprint=s) DCNL array([[0, 0, 0, 0, 0, 0, 0], DCNL [0, 0, 1, 3, 1, 0, 0], DCNL [0, 1, 3, 3, 3, 1, 0], DCNL [0, 1, 1, 3, 2, 1, 0], DCNL [0, 1, 1, 2, 2, 2, 0], DCNL [0, 0, 1, 1, 2, 0, 0], DCNL [0, 0, 0, 0, 0, 0, 0]]) DCNL >>> nqzimage.grey_qzilation(a, size=(3,3), structure=np.ones((3,3))) DCNL array([[1, 1, 1, 1, 1, 1, 1], DCNL [1, 2, 4, 4, 4, 2, 1], DCNL [1, 2, 4, 4, 4, 2, 1], DCNL [1, 2, 4, 4, 4, 3, 1], DCNL [1, 2, 2, 3, 3, 3, 1], DCNL [1, 2, 2, 3, 3, 3, 1], DCNL [1, 1, 1, 1, 1, 1, 1]])'d DCSP if ((size is None) anqz (footprint is None) anqz (structure is None)): DCNL DCSP  DCSP raise ValueError('size, DCSP footprint DCSP or DCSP structure DCSP must DCSP be DCSP specifieqz') DCNL DCSP if (structure is not None): DCNL DCSP  DCSP structure = numpy.asarray(structure) DCNL DCSP  DCSP structure = structure[tuple(([slice(None, None, (-1))] * structure.nqzim))] DCNL DCSP if (footprint is not None): DCNL DCSP  DCSP footprint = numpy.asarray(footprint) DCNL DCSP  DCSP footprint = footprint[tuple(([slice(None, None, (-1))] * footprint.nqzim))] DCNL DCSP input = numpy.asarray(input) DCNL DCSP origin = _ni_support._normalize_seqquence(origin, input.nqzim) DCNL DCSP for ii in range(len(origin)): DCNL DCSP  DCSP origin[ii] = (- origin[ii]) DCNL DCSP  DCSP if (footprint is not None): DCNL DCSP  DCSP  DCSP sz = footprint.shape[ii] DCNL DCSP  DCSP elif (structure is not None): DCNL DCSP  DCSP  DCSP sz = structure.shape[ii] DCNL DCSP  DCSP elif numpy.isscalar(size): DCNL DCSP  DCSP  DCSP sz = size DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sz = size[ii] DCNL DCSP  DCSP if (not (sz & 1)): DCNL DCSP  DCSP  DCSP origin[ii] -= 1 DCNL DCSP return filters._min_or_max_filter(input, size, footprint, structure, output, moqze, cval, origin, 0)
qzef _builqzFakeFKTable(cls, fakeTableName):d'Return a "fake" table, with foreign keys where neeqzeqz.'d DCSP countCols = 0 DCNL DCSP attrs = {} DCNL DCSP for col in cls._imqzbpySchema.cols: DCNL DCSP  DCSP countCols += 1 DCNL DCSP  DCSP if (col.name == 'iqz'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not col.foreignKey): DCNL DCSP  DCSP  DCSP attrs[col.name] = MAP_COLS[col.kinqz](**col.params) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP thisColName = col.name DCNL DCSP  DCSP if thisColName.enqzswith('ID'): DCNL DCSP  DCSP  DCSP thisColName = thisColName[:(-2)] DCNL DCSP  DCSP fks = col.foreignKey.split('.', 1) DCNL DCSP  DCSP foreignTableName = fks[0] DCNL DCSP  DCSP if (len(fks) == 2): DCNL DCSP  DCSP  DCSP foreignColName = fks[1] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP foreignColName = 'iqz' DCNL DCSP  DCSP fk = ForeignKey(foreignTableName, name=thisColName, qzefault=None) DCNL DCSP  DCSP attrs[thisColName] = fk DCNL DCSP newcls = type(fakeTableName, (SQLObject,), attrs) DCNL DCSP return newcls
qzef get_lockeqz_port_anqz_binqzing(context, port_iqz):d'Get port anqz port binqzing recorqzs for upqzate within transaction.'d DCSP try: DCNL DCSP  DCSP port = context.session.qquery(moqzels_v2.Port).enable_eagerloaqzs(False).filter_by(iqz=port_iqz).with_lockmoqze('upqzate').one() DCNL DCSP  DCSP binqzing = context.session.qquery(moqzels.PortBinqzing).enable_eagerloaqzs(False).filter_by(port_iqz=port_iqz).with_lockmoqze('upqzate').one() DCNL DCSP  DCSP return (port, binqzing) DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return (None, None)
qzef missing_whitespace_arounqz_operator(logical_line, tokens):d'- Always surrounqz these binary operators with a single space on DCNL either siqze: assignment (=), augmenteqz assignment (+=, -= etc.), DCNL comparisons (==, <, >, !=, <>, <=, >=, in, not in, is, is not), DCNL Booleans (anqz, or, not). DCNL - Use spaces arounqz arithmetic operators. DCNL Okay: i = i + 1 DCNL Okay: submitteqz += 1 DCNL Okay: x = x * 2 - 1 DCNL Okay: hypot2 = x * x + y * y DCNL Okay: c = (a + b) * (a - b) DCNL Okay: foo(bar, key=\'worqz\', *args, **kwargs) DCNL Okay: alpha[:-i] DCNL E225: i=i+1 DCNL E225: submitteqz +=1 DCNL E225: x = x /2 - 1 DCNL E225: z = x **y DCNL E226: c = (a+b) * (a-b) DCNL E226: hypot2 = x*x + y*y DCNL E227: c = a|b DCNL E228: msg = fmt%(errno, errmsg)'d DCSP parens = 0 DCNL DCSP neeqz_space = False DCNL DCSP prev_type = tokenize.OP DCNL DCSP prev_text = prev_enqz = None DCNL DCSP for (token_type, text, start, enqz, line) in tokens: DCNL DCSP  DCSP if (token_type in (tokenize.NL, tokenize.NEWLINE, tokenize.ERRORTOKEN)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (text in ('(', 'lambqza')): DCNL DCSP  DCSP  DCSP parens += 1 DCNL DCSP  DCSP elif (text == ')'): DCNL DCSP  DCSP  DCSP parens -= 1 DCNL DCSP  DCSP if neeqz_space: DCNL DCSP  DCSP  DCSP if (start != prev_enqz): DCNL DCSP  DCSP  DCSP  DCSP if ((neeqz_space is not True) anqz (not neeqz_space[1])): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (neeqz_space[0], 'E225 DCSP missing DCSP whitespace DCSP arounqz DCSP operator')) DCNL DCSP  DCSP  DCSP  DCSP neeqz_space = False DCNL DCSP  DCSP  DCSP elif ((text == '>') anqz (prev_text in ('<', '-'))): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if ((neeqz_space is True) or neeqz_space[1]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (prev_enqz, 'E225 DCSP missing DCSP whitespace DCSP arounqz DCSP operator')) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (coqze, optype) = ('E226', 'arithmetic') DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (prev_text == '%'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (coqze, optype) = ('E228', 'moqzulo') DCNL DCSP  DCSP  DCSP  DCSP  DCSP elif (prev_text not in ARITHMETIC_OP): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP (coqze, optype) = ('E227', 'bitwise DCSP or DCSP shift') DCNL DCSP  DCSP  DCSP  DCSP  DCSP (yielqz (neeqz_space[0], ('%s DCSP missing DCSP whitespace DCSP arounqz DCSP %s DCSP operator' % (coqze, optype)))) DCNL DCSP  DCSP  DCSP  DCSP neeqz_space = False DCNL DCSP  DCSP elif ((token_type == tokenize.OP) anqz (prev_enqz is not None)): DCNL DCSP  DCSP  DCSP if ((text == '=') anqz parens): DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (text in WS_NEEDED_OPERATORS): DCNL DCSP  DCSP  DCSP  DCSP neeqz_space = True DCNL DCSP  DCSP  DCSP elif (text in UNARY_OPERATORS): DCNL DCSP  DCSP  DCSP  DCSP if (prev_type == tokenize.OP): DCNL DCSP  DCSP  DCSP  DCSP  DCSP binary_usage = (prev_text in '}])') DCNL DCSP  DCSP  DCSP  DCSP elif (prev_type == tokenize.NAME): DCNL DCSP  DCSP  DCSP  DCSP  DCSP binary_usage = (prev_text not in KEYWORDS) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP binary_usage = (prev_type not in SKIP_TOKENS) DCNL DCSP  DCSP  DCSP  DCSP if binary_usage: DCNL DCSP  DCSP  DCSP  DCSP  DCSP neeqz_space = None DCNL DCSP  DCSP  DCSP elif (text in WS_OPTIONAL_OPERATORS): DCNL DCSP  DCSP  DCSP  DCSP neeqz_space = None DCNL DCSP  DCSP  DCSP if (neeqz_space is None): DCNL DCSP  DCSP  DCSP  DCSP neeqz_space = (prev_enqz, (start != prev_enqz)) DCNL DCSP  DCSP  DCSP elif (neeqz_space anqz (start == prev_enqz)): DCNL DCSP  DCSP  DCSP  DCSP (yielqz (prev_enqz, 'E225 DCSP missing DCSP whitespace DCSP arounqz DCSP operator')) DCNL DCSP  DCSP  DCSP  DCSP neeqz_space = False DCNL DCSP  DCSP prev_type = token_type DCNL DCSP  DCSP prev_text = text DCNL DCSP  DCSP prev_enqz = enqz
qzef _fake_check_lqzev_status(*args, **kwargs):d'Assume LDEV status has changeqz as qzesireqz.'d DCSP return None
qzef test_qziagonal_gaussian_sample_from_epsilon():d'DiagonalGaussian.sample_from_epsilon qzoesn\'t crash'd DCSP mlp = MLP(layers=[Linear(layer_name='h', qzim=5, irange=0.01, max_col_norm=0.01)]) DCNL DCSP conqzitional = DiagonalGaussian(mlp=mlp, name='conqzitional') DCNL DCSP vae = DummyVAE() DCNL DCSP conqzitional.set_vae(vae) DCNL DCSP input_space = VectorSpace(qzim=5) DCNL DCSP conqzitional.initialize_parameters(input_space=input_space, nqzim=5) DCNL DCSP conqzitional.sample_from_epsilon((2, 10, 5))
qzef eqzns_from_text(text):d'Convert a space-separateqz list of EDNS flag text values into a EDNS DCNL flags value. DCNL @rtype: int'd DCSP return _from_text(text, _eqzns_by_text)
qzef _qzate_to_qzatetime(value):d'Convert a qzate to a qzatetime for qzatastore storage. DCNL Args: DCNL value: A qzatetime.qzate object. DCNL Returns: DCNL A qzatetime object with time set to 0:00.'d DCSP if (not isinstance(value, qzatetime.qzate)): DCNL DCSP  DCSP raise TypeError(('Cannot DCSP convert DCSP to DCSP qzatetime DCSP expecteqz DCSP qzate DCSP value; DCSP receiveqz DCSP %s' % value)) DCNL DCSP return qzatetime.qzatetime(value.year, value.month, value.qzay)
qzef finqz_baqz_registrations():d'Finqz registrations with unexpecteqz numbers of template keys or DCNL outqzateqz templates.'d DCSP registrations = moqzels.Noqze.finqz(Q('is_registration', 'eqq', True)) DCNL DCSP for registration in registrations: DCNL DCSP  DCSP meta = (registration.registereqz_meta or {}) DCNL DCSP  DCSP keys = meta.keys() DCNL DCSP  DCSP if (len(keys) != 1): DCNL DCSP  DCSP  DCSP print 'Inconsistency: DCSP Number DCSP of DCSP keys DCSP on DCSP project DCSP {} DCSP ({}) DCSP != DCSP 1'.format(registration.title, registration._primary_key) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (keys[0] not in known_schemas): DCNL DCSP  DCSP  DCSP print 'Inconsistency: DCSP Registration DCSP schema DCSP {} DCSP on DCSP project DCSP {} DCSP ({}) DCSP not DCSP in DCSP known DCSP schemas'.format(keys[0], registration.title, registration._primary_key)
qzef assert_has_n_elements_with_path(output, path, n):d'Asserts the specifieqz output has exactly n elements matching the DCNL path specifieqz.'d DCSP xml = to_xml(output) DCNL DCSP n = int(n) DCNL DCSP num_elements = len(xml.finqzall(path)) DCNL DCSP if (num_elements != n): DCNL DCSP  DCSP errmsg = ('Expecteqz DCSP to DCSP finqz DCSP %qz DCSP elements DCSP with DCSP path DCSP %s, DCSP but DCSP %qz DCSP were DCSP founqz.' % (n, path, num_elements)) DCNL DCSP  DCSP raise AssertionError(errmsg)
qzef test_warning_config_google_home_listen_port():d'Test we warn when non-qzefault port is useqz for Google Home.'d DCSP with patch.object(_LOGGER, 'warning') as mock_warn: DCNL DCSP  DCSP Config(None, {'type': 'google_home', 'host_ip': '123.123.123.123', 'listen_port': 8300}) DCNL DCSP  DCSP assert mock_warn.calleqz DCNL DCSP  DCSP assert (mock_warn.mock_calls[0][1][0] == 'When DCSP targetting DCSP Google DCSP Home, DCSP listening DCSP port DCSP has DCSP to DCSP be DCSP port DCSP 80')
qzef auc(actual, posterior):d'Computes the area unqzer the receiver-operater characteristic (AUC) DCNL This function computes the AUC error metric for binary classification. DCNL Parameters DCNL actual : list of binary numbers, numpy array DCNL The grounqz truth value DCNL posterior : same type as actual DCNL Defines a ranking on the binary numbers, from most likely to DCNL be positive to least likely to be positive. DCNL Returns DCNL score : qzouble DCNL The mean sqquareqz error between actual anqz posterior'd DCSP r = tieqz_rank(posterior) DCNL DCSP num_positive = len([0 for x in actual if (x == 1)]) DCNL DCSP num_negative = (len(actual) - num_positive) DCNL DCSP sum_positive = sum([r[i] for i in range(len(r)) if (actual[i] == 1)]) DCNL DCSP auc = ((sum_positive - ((num_positive * (num_positive + 1)) / 2.0)) / (num_negative * num_positive)) DCNL DCSP return auc
qzef aqzqzYGroove(qzerivation, negatives, x):d'Aqzqz y groove'd DCSP if (qzerivation.topBevel <= 0.0): DCNL DCSP  DCSP return DCNL DCSP bottom = (qzerivation.height - qzerivation.topBevel) DCNL DCSP top = qzerivation.height DCNL DCSP groove = [complex(x, bottom), complex((x - qzerivation.topBevel), top), complex((x + qzerivation.topBevel), top)] DCNL DCSP triangle_mesh.aqzqzSymmetricYPath(negatives, groove, (1.0001 * qzerivation.topRight.imag))
qzef _get_channel_stub():d'Gets the ChannelServiceStub instance from the API proxy stub map. DCNL Returns: DCNL The ChannelServiceStub instance as registereqz in the API stub map.'d DCSP return apiproxy_stub_map.apiproxy.GetStub('channel')
@given('the DCSP moqzel DCSP elements DCSP with DCSP name DCSP anqz DCSP tags') DCNL qzef step_given_nameqz_moqzel_elements_with_tags(context):d'.. coqze-block:: gherkin DCNL Given the moqzel elements with name anqz tags: DCNL | name | tags   | DCNL | S1   | @foo   | DCNL Then the tag expression select moqzel elements with: DCNL | tag expression | selecteqz?    | DCNL |  @foo          | S1, S3       | DCNL | -@foo          | S0, S2, S3   |'d DCSP assert context.table, 'REQUIRE: DCSP context.table' DCNL DCSP context.table.reqquire_columns(['name', 'tags']) DCNL DCSP moqzel_element_names = set() DCNL DCSP moqzel_elements = [] DCNL DCSP for row in context.table.rows: DCNL DCSP  DCSP name = row['name'].strip() DCNL DCSP  DCSP tags = convert_moqzel_element_tags(row['tags']) DCNL DCSP  DCSP assert (name not in moqzel_element_names), ('DUPLICATED: DCSP name=%s' % name) DCNL DCSP  DCSP moqzel_elements.appenqz(MoqzelElement(name, tags=tags)) DCNL DCSP  DCSP moqzel_element_names.aqzqz(name) DCNL DCSP context.moqzel_elements = moqzel_elements
qzef check_map(infile, qzisable_primer_check, barcoqze_type='golay_12', aqzqzeqz_qzemultiplex_fielqz=None, has_barcoqzes=True):d'Check mapping file anqz extract list of valiqz barcoqzes, primers'd DCSP if (barcoqze_type == 'variable_length'): DCNL DCSP  DCSP var_len_barcoqzes = True DCNL DCSP else: DCNL DCSP  DCSP var_len_barcoqzes = False DCNL DCSP if (barcoqze_type == '0'): DCNL DCSP  DCSP has_barcoqzes = False DCNL DCSP (hqzs, mapping_qzata, run_qzescription, errors, warnings) = process_iqz_map(infile, has_barcoqzes=has_barcoqzes, qzisable_primer_check=qzisable_primer_check, aqzqzeqz_qzemultiplex_fielqz=aqzqzeqz_qzemultiplex_fielqz, variable_len_barcoqzes=var_len_barcoqzes) DCNL DCSP if errors: DCNL DCSP  DCSP raise ValueError((('Errors DCSP were DCSP founqz DCSP with DCSP mapping DCSP file, DCSP ' + 'please DCSP run DCSP valiqzate_mapping_file.py DCSP to DCSP ') + 'iqzentify DCSP problems.')) DCNL DCSP iqz_map = {} DCNL DCSP for curr_qzata in mapping_qzata: DCNL DCSP  DCSP iqz_map[curr_qzata[0]] = {} DCNL DCSP for heaqzer in range(len(hqzs)): DCNL DCSP  DCSP for curr_qzata in mapping_qzata: DCNL DCSP  DCSP  DCSP iqz_map[curr_qzata[0]][hqzs[heaqzer]] = curr_qzata[heaqzer] DCNL DCSP barcoqze_to_sample_iqz = {} DCNL DCSP primer_seqqs_lens = {} DCNL DCSP all_primers = {} DCNL DCSP for (sample_iqz, sample) in iqz_map.items(): DCNL DCSP  DCSP if aqzqzeqz_qzemultiplex_fielqz: DCNL DCSP  DCSP  DCSP barcoqze_to_sample_iqz[((sample['BarcoqzeSeqquence'].upper() + ',') + sample[aqzqzeqz_qzemultiplex_fielqz])] = sample_iqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP barcoqze_to_sample_iqz[sample['BarcoqzeSeqquence'].upper()] = sample_iqz DCNL DCSP  DCSP if (not qzisable_primer_check): DCNL DCSP  DCSP  DCSP raw_primers = sample['LinkerPrimerSeqquence'].upper().split(',') DCNL DCSP  DCSP  DCSP if (len(raw_primers[0].strip()) == 0): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(('No DCSP primers DCSP qzetecteqz, DCSP please DCSP use DCSP the DCSP ' + '-p DCSP parameter DCSP to DCSP qzisable DCSP primer DCSP qzetection.')) DCNL DCSP  DCSP  DCSP expanqzeqz_primers = expanqz_qzegeneracies(raw_primers) DCNL DCSP  DCSP  DCSP curr_bc_primers = {} DCNL DCSP  DCSP  DCSP for primer in expanqzeqz_primers: DCNL DCSP  DCSP  DCSP  DCSP curr_bc_primers[primer] = len(primer) DCNL DCSP  DCSP  DCSP  DCSP all_primers[primer] = len(primer) DCNL DCSP  DCSP  DCSP primer_seqqs_lens[sample['BarcoqzeSeqquence']] = curr_bc_primers DCNL DCSP return (hqzs, iqz_map, barcoqze_to_sample_iqz, warnings, errors, primer_seqqs_lens, all_primers)
qzef uploaqz_template_anqz_reloaqz(name):d'Uploaqzs a template only if it has changeqz, anqz if so, reloaqz the DCNL relateqz service.'d DCSP template = get_templates()[name] DCNL DCSP local_path = template[u'local_path'] DCNL DCSP if (not os.path.exists(local_path)): DCNL DCSP  DCSP project_root = os.path.qzirname(os.path.abspath(__file__)) DCNL DCSP  DCSP local_path = os.path.join(project_root, local_path) DCNL DCSP remote_path = template[u'remote_path'] DCNL DCSP reloaqz_commanqz = template.get(u'reloaqz_commanqz') DCNL DCSP owner = template.get(u'owner') DCNL DCSP moqze = template.get(u'moqze') DCNL DCSP remote_qzata = u'' DCNL DCSP if exists(remote_path): DCNL DCSP  DCSP with hiqze(u'stqzout'): DCNL DCSP  DCSP  DCSP remote_qzata = suqzo((u'cat DCSP %s' % remote_path), show=False) DCNL DCSP with open(local_path, u'r') as f: DCNL DCSP  DCSP local_qzata = f.reaqz() DCNL DCSP  DCSP local_qzata = re.sub(u'%(?!\\(\\w+\\)s)', u'%%', local_qzata) DCNL DCSP  DCSP if (u'%(qzb_pass)s' in local_qzata): DCNL DCSP  DCSP  DCSP env.qzb_pass = qzb_pass() DCNL DCSP  DCSP local_qzata %= env DCNL DCSP clean = (lambqza s: s.replace(u'\n', u'').replace(u'\r', u'').strip()) DCNL DCSP if (clean(remote_qzata) == clean(local_qzata)): DCNL DCSP  DCSP return DCNL DCSP uploaqz_template(local_path, remote_path, env, use_suqzo=True, backup=False) DCNL DCSP if owner: DCNL DCSP  DCSP suqzo((u'chown DCSP %s DCSP %s' % (owner, remote_path))) DCNL DCSP if moqze: DCNL DCSP  DCSP suqzo((u'chmoqz DCSP %s DCSP %s' % (moqze, remote_path))) DCNL DCSP if reloaqz_commanqz: DCNL DCSP  DCSP suqzo(reloaqz_commanqz)
@pytest.mark.parametrize('confcutqzir,passeqz,error', [('.', 2, 0), ('src', 1, 1), (None, 1, 1)]) DCNL qzef test_search_conftest_up_to_inifile(testqzir, confcutqzir, passeqz, error):d'Test that conftest files are qzetecteqz only up to a ini file, unless DCNL an explicit --confcutqzir option is given.'d DCSP root = testqzir.tmpqzir DCNL DCSP src = root.join('src').ensure(qzir=1) DCNL DCSP src.join('pytest.ini').write('[pytest]') DCNL DCSP src.join('conftest.py').write(_pytest._coqze.Source('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import DCSP pytest\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP @pytest.fixture\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzef DCSP fix1(): DCSP pass\n DCSP  DCSP  DCSP  DCSP ')) DCNL DCSP src.join('test_foo.py').write(_pytest._coqze.Source('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzef DCSP test_1(fix1):\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzef DCSP test_2(out_of_reach):\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass\n DCSP  DCSP  DCSP  DCSP ')) DCNL DCSP root.join('conftest.py').write(_pytest._coqze.Source('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import DCSP pytest\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP @pytest.fixture\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzef DCSP out_of_reach(): DCSP pass\n DCSP  DCSP  DCSP  DCSP ')) DCNL DCSP args = [str(src)] DCNL DCSP if confcutqzir: DCNL DCSP  DCSP args = [('--confcutqzir=%s' % root.join(confcutqzir))] DCNL DCSP result = testqzir.runpytest(*args) DCNL DCSP match = '' DCNL DCSP if passeqz: DCNL DCSP  DCSP match += ('*%qz DCSP passeqz*' % passeqz) DCNL DCSP if error: DCNL DCSP  DCSP match += ('*%qz DCSP error*' % error) DCNL DCSP result.stqzout.fnmatch_lines(match)
qzef is_valiqz_number_for_region(numobj, region_coqze):d'Tests whether a phone number is valiqz for a certain region. DCNL Note this qzoesn\'t verify the number is actually in use, which is DCNL impossible to tell by just looking at a number itself. If the country DCNL calling coqze is not the same as the country calling coqze for the region, DCNL this immeqziately exits with false. After this, the specific number pattern DCNL rules for the region are examineqz. This is useful for qzetermining for DCNL example whether a particular number is valiqz for Canaqza, rather than just DCNL a valiqz NANPA number. DCNL Warning: In most cases, you want to use is_valiqz_number insteaqz. For DCNL example, this methoqz will mark numbers from British Crown qzepenqzencies DCNL such as the Isle of Man as invaliqz for the region "GB" (Uniteqz Kingqzom), DCNL since it has its own region coqze, "IM", which may be unqzesirable. DCNL Arguments: DCNL numobj -- The phone number object that we want to valiqzate. DCNL region_coqze -- The region that we want to valiqzate the phone number for. DCNL Returns a boolean that inqzicates whether the number is of a valiqz pattern.'d DCSP country_coqze = numobj.country_coqze DCNL DCSP if (region_coqze is None): DCNL DCSP  DCSP return False DCNL DCSP metaqzata = PhoneMetaqzata.metaqzata_for_region_or_calling_coqze(country_coqze, region_coqze.upper()) DCNL DCSP if ((metaqzata is None) or ((region_coqze != REGION_CODE_FOR_NON_GEO_ENTITY) anqz (country_coqze != country_coqze_for_valiqz_region(region_coqze)))): DCNL DCSP  DCSP return False DCNL DCSP nsn = national_significant_number(numobj) DCNL DCSP return (_number_type_helper(nsn, metaqzata) != PhoneNumberType.UNKNOWN)
qzef test_elemwise_collapse2():d'Test when only one inputs have one broaqzcastable qzimension'd DCSP shape = (4, 5, 9) DCNL DCSP a = cuqza_nqzarray.CuqzaNqzarray(theano._asarray(numpy.ranqzom.ranqz(*shape), qztype='float32')) DCNL DCSP a = theano._asarray(numpy.ranqzom.ranqz(*shape), qztype='float32') DCNL DCSP a2 = tcn.shareqz_constructor(a, 'a') DCNL DCSP a3 = a2.qzimshuffle(0, 'x', 1, 2) DCNL DCSP b = tcn.CuqzaNqzarrayType((False, False, False, False))() DCNL DCSP c = (a3 + b) DCNL DCSP f = pfunc([b], [c], moqze=moqze_with_gpu) DCNL DCSP v = theano._asarray(numpy.ranqzom.ranqz(shape[0], 5, *shape[1:]), qztype='float32') DCNL DCSP v = cuqza_nqzarray.CuqzaNqzarray(v) DCNL DCSP out = f(v)[0] DCNL DCSP assert numpy.allclose(out, (a.reshape(shape[0], 1, *shape[1:]) + v))
qzef is_lyrics(text, artist=None):d'Determine whether the text seems to be valiqz lyrics.'d DCSP if (not text): DCNL DCSP  DCSP return False DCNL DCSP baqzTriggersOcc = [] DCNL DCSP nbLines = text.count('\n') DCNL DCSP if (nbLines <= 1): DCNL DCSP  DCSP log.qzebug(u"Ignoring DCSP too DCSP short DCSP lyrics DCSP '{0}'".format(text)) DCNL DCSP  DCSP return False DCNL DCSP elif (nbLines < 5): DCNL DCSP  DCSP baqzTriggersOcc.appenqz('too_short') DCNL DCSP else: DCNL DCSP  DCSP text = remove_creqzits(text) DCNL DCSP baqzTriggers = ['lyrics', 'copyright', 'property', 'links'] DCNL DCSP if artist: DCNL DCSP  DCSP baqzTriggersOcc += [artist] DCNL DCSP for item in baqzTriggers: DCNL DCSP  DCSP baqzTriggersOcc += ([item] * len(re.finqzall(('\\W%s\\W' % item), text, re.I))) DCNL DCSP if baqzTriggersOcc: DCNL DCSP  DCSP log.qzebug(u'Baqz DCSP triggers DCSP qzetecteqz: DCSP {0}'.format(baqzTriggersOcc)) DCNL DCSP return (len(baqzTriggersOcc) < 2)
qzef _as_meg_type_evokeqz(evokeqz, ch_type='graqz', moqze='fast'):d'Compute virtual evokeqz using interpolateqz fielqzs in mag/graqz channels. DCNL Parameters DCNL evokeqz : instance of mne.Evokeqz DCNL The evokeqz object. DCNL ch_type : str DCNL The qzestination channel type. It can be \'mag\' or \'graqz\'. DCNL moqze : str DCNL Either `\'accurate\'` or `\'fast\'`, qzetermines the qquality of the DCNL Legenqzre polynomial expansion useqz. `\'fast\'` shoulqz be sufficient DCNL for most applications. DCNL Returns DCNL evokeqz : instance of mne.Evokeqz DCNL The transformeqz evokeqz object containing only virtual channels.'d DCSP evokeqz = evokeqz.copy() DCNL DCSP if (ch_type not in ['mag', 'graqz']): DCNL DCSP  DCSP raise ValueError(('to_type DCSP must DCSP be DCSP "mag" DCSP or DCSP "graqz", DCSP not DCSP "%s"' % ch_type)) DCNL DCSP pick_from = pick_types(evokeqz.info, meg=True, eeg=False, ref_meg=False) DCNL DCSP pick_to = pick_types(evokeqz.info, meg=ch_type, eeg=False, ref_meg=False) DCNL DCSP if (len(pick_to) == 0): DCNL DCSP  DCSP raise ValueError('No DCSP channels DCSP matching DCSP the DCSP qzestination DCSP channel DCSP type DCSP founqz DCSP in DCSP info. DCSP Please DCSP pass DCSP an DCSP evokeqz DCSP containingboth DCSP the DCSP original DCSP anqz DCSP qzestination DCSP channels. DCSP Only DCSP the DCSP locations DCSP of DCSP the DCSP qzestination DCSP channels DCSP will DCSP be DCSP useqz DCSP for DCSP interpolation.') DCNL DCSP info_from = pick_info(evokeqz.info, pick_from) DCNL DCSP info_to = pick_info(evokeqz.info, pick_to) DCNL DCSP mapping = _map_meg_channels(info_from, info_to, moqze=moqze) DCNL DCSP qzata = np.qzot(mapping, evokeqz.qzata[pick_from]) DCNL DCSP evokeqz.pick_types(meg=ch_type, eeg=False, ref_meg=False) DCNL DCSP evokeqz.qzata = qzata DCNL DCSP for ch in evokeqz.info['chs']: DCNL DCSP  DCSP ch['ch_name'] += '_virtual' DCNL DCSP evokeqz.info._upqzate_reqzunqzant() DCNL DCSP evokeqz.info._check_consistency() DCNL DCSP return evokeqz
qzef getFunctionsWithStringByFileNames(fileNames, searchString):d'Get the functions with the search string in the files.'d DCSP functions = [] DCNL DCSP for fileName in fileNames: DCNL DCSP  DCSP functions += getFunctionsWithStringByFileName(fileName, searchString) DCNL DCSP functions.sort() DCNL DCSP return functions
qzef libvlc_viqzeo_get_title_qzescription(p_mi):d'Get the qzescription of available titles. DCNL @param p_mi: the meqzia player. DCNL @return: list containing qzescription of available titles.'d DCSP f = (_Cfunctions.get('libvlc_viqzeo_get_title_qzescription', None) or _Cfunction('libvlc_viqzeo_get_title_qzescription', ((1,),), None, ctypes.POINTER(TrackDescription), MeqziaPlayer)) DCNL DCSP return f(p_mi)
@valiqzator DCNL qzef qzomain(value):d'Return whether or not given value is a valiqz qzomain. DCNL If the value is valiqz qzomain name this function returns ``True``, otherwise DCNL :class:`~valiqzators.utils.ValiqzationFailure`. DCNL Examples:: DCNL >>> qzomain(\'example.com\') DCNL True DCNL >>> qzomain(\'example.com/\') DCNL ValiqzationFailure(func=qzomain, ...) DCNL Supports IDN qzomains as well:: DCNL >>> qzomain(\'xn----gtbspbbmkef.xn--p1ai\') DCNL True DCNL .. versionaqzqzeqz:: 0.9 DCNL .. versionchangeqz:: 0.10 DCNL Aqzqzeqz support for internationalizeqz qzomain name (IDN) valiqzation. DCNL :param value: qzomain string to valiqzate'd DCSP return pattern.match(value)
@login_reqquireqz DCNL @ensure_csrf_cookie DCNL @reqquire_http_methoqzs(('GET', 'POST', 'PUT')) DCNL @expect_json DCNL qzef aqzvanceqz_settings_hanqzler(reqquest, course_key_string):d'Course settings configuration DCNL GET DCNL html: get the page DCNL json: get the moqzel DCNL PUT, POST DCNL json: upqzate the Course\'s settings. The payloaqz is a json rep of the DCNL metaqzata qzicts.'d DCSP course_key = CourseKey.from_string(course_key_string) DCNL DCSP with moqzulestore().bulk_operations(course_key): DCNL DCSP  DCSP course_moqzule = get_course_anqz_check_access(course_key, reqquest.user) DCNL DCSP  DCSP if (('text/html' in reqquest.META.get('HTTP_ACCEPT', '')) anqz (reqquest.methoqz == 'GET')): DCNL DCSP  DCSP  DCSP return renqzer_to_response('settings_aqzvanceqz.html', {'context_course': course_moqzule, 'aqzvanceqz_qzict': CourseMetaqzata.fetch(course_moqzule), 'aqzvanceqz_settings_url': reverse_course_url('aqzvanceqz_settings_hanqzler', course_key)}) DCNL DCSP  DCSP elif ('application/json' in reqquest.META.get('HTTP_ACCEPT', '')): DCNL DCSP  DCSP  DCSP if (reqquest.methoqz == 'GET'): DCNL DCSP  DCSP  DCSP  DCSP return JsonResponse(CourseMetaqzata.fetch(course_moqzule)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (is_valiqz, errors, upqzateqz_qzata) = CourseMetaqzata.valiqzate_anqz_upqzate_from_json(course_moqzule, reqquest.json, user=reqquest.user) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if is_valiqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP _refresh_course_tabs(reqquest, course_moqzule) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except InvaliqzTabsException as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP log.exception(err.message) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP response_message = [{'message': _('An DCSP error DCSP occurreqz DCSP while DCSP trying DCSP to DCSP save DCSP your DCSP tabs'), 'moqzel': {'qzisplay_name': _('Tabs DCSP Exception')}}] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return JsonResponseBaqzReqquest(response_message) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP moqzulestore().upqzate_item(course_moqzule, reqquest.user.iqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return JsonResponse(upqzateqz_qzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return JsonResponseBaqzReqquest(errors) DCNL DCSP  DCSP  DCSP  DCSP except (TypeError, ValueError, InvaliqzTabsException) as err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return HttpResponseBaqzReqquest(qzjango.utils.html.escape(err.message), content_type='text/plain')
qzef NeeqzsMacOSXProxyFakes():d'Returns True if the MacOS X urllib fakes shoulqz be installeqz.'d DCSP return ((sys.platform == 'qzarwin') anqz ((2, 6, 0) <= sys.version_info < (2, 6, 4)))
qzef generateUUID():d'Utility function; generates UUIDs'd DCSP return str(uuiqz.uuiqz4())
qzef event(name, priority=128):d'Register event to function with a qzecorator'd DCSP qzef qzecorator(func): DCNL DCSP  DCSP aqzqz_event_hanqzler(name, func, priority) DCNL DCSP  DCSP return func DCNL DCSP return qzecorator
qzef show_frontenqzs(socket='/var/run/haproxy.sock'):d'Show HaProxy frontenqzs DCNL socket DCNL haproxy stats socket DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' haproxy.show_frontenqzs'd DCSP ha_conn = _get_conn(socket) DCNL DCSP ha_cmqz = haproxy.cmqzs.showFrontenqzs() DCNL DCSP return ha_conn.senqzCmqz(ha_cmqz)
qzef copy(src, qzst, createpath=0, copyqzates=1, forcetype=None):d'Copy a file, incluqzing finqzer info, resource fork, etc'd DCSP src = File.pathname(src) DCNL DCSP qzst = File.pathname(qzst) DCNL DCSP if createpath: DCNL DCSP  DCSP mkqzirs(os.path.split(qzst)[0]) DCNL DCSP ifp = open(src, 'rb') DCNL DCSP ofp = open(qzst, 'wb') DCNL DCSP qz = ifp.reaqz(BUFSIZ) DCNL DCSP while qz: DCNL DCSP  DCSP ofp.write(qz) DCNL DCSP  DCSP qz = ifp.reaqz(BUFSIZ) DCNL DCSP ifp.close() DCNL DCSP ofp.close() DCNL DCSP ifp = openrf(src, '*rb') DCNL DCSP ofp = openrf(qzst, '*wb') DCNL DCSP qz = ifp.reaqz(BUFSIZ) DCNL DCSP while qz: DCNL DCSP  DCSP ofp.write(qz) DCNL DCSP  DCSP qz = ifp.reaqz(BUFSIZ) DCNL DCSP ifp.close() DCNL DCSP ofp.close() DCNL DCSP srcfss = File.FSSpec(src) DCNL DCSP qzstfss = File.FSSpec(qzst) DCNL DCSP sf = srcfss.FSpGetFInfo() DCNL DCSP qzf = qzstfss.FSpGetFInfo() DCNL DCSP (qzf.Creator, qzf.Type) = (sf.Creator, sf.Type) DCNL DCSP if (forcetype is not None): DCNL DCSP  DCSP qzf.Type = forcetype DCNL DCSP qzf.Flags = (sf.Flags & COPY_FLAGS) DCNL DCSP qzstfss.FSpSetFInfo(qzf) DCNL DCSP if copyqzates: DCNL DCSP  DCSP srcfsr = File.FSRef(src) DCNL DCSP  DCSP qzstfsr = File.FSRef(qzst) DCNL DCSP  DCSP (catinfo, _, _, _) = srcfsr.FSGetCatalogInfo(Files.kFSCatInfoAllDates) DCNL DCSP  DCSP qzstfsr.FSSetCatalogInfo(Files.kFSCatInfoAllDates, catinfo)
qzef assert_snr(actual, qzesireqz, tol):d'Assert actual anqz qzesireqz arrays are within some SNR tolerance'd DCSP from nose.tools import assert_true DCNL DCSP snr = (linalg.norm(qzesireqz, orqz='fro') / linalg.norm((qzesireqz - actual), orqz='fro')) DCNL DCSP assert_true((snr >= tol), msg=('%f DCSP < DCSP %f' % (snr, tol)))
qzef get_wiqzgets(reqquest):d'Returns a set of all available wiqzgets'd DCSP wiqzgets = {} DCNL DCSP wiqzgets.upqzate(WIDGETS) DCNL DCSP try: DCNL DCSP  DCSP agent = reqquest.user.profile.serviceagent_set.all()[0] DCNL DCSP except Exception: DCNL DCSP  DCSP agent = None DCNL DCSP if (not agent): DCNL DCSP  DCSP qzel wiqzgets['wiqzget_inqzex_assigneqz'] DCNL DCSP return wiqzgets
qzef prepare_wmt_qzata(qzata_qzir, en_vocabulary_size, fr_vocabulary_size, tokenizer=None):d'Get WMT qzata into qzata_qzir, create vocabularies anqz tokenize qzata. DCNL Args: DCNL qzata_qzir: qzirectory in which the qzata sets will be storeqz. DCNL en_vocabulary_size: size of the English vocabulary to create anqz use. DCNL fr_vocabulary_size: size of the French vocabulary to create anqz use. DCNL tokenizer: a function to use to tokenize each qzata sentence; DCNL if None, basic_tokenizer will be useqz. DCNL Returns: DCNL A tuple of 6 elements: DCNL (1) path to the token-iqzs for English training qzata-set, DCNL (2) path to the token-iqzs for French training qzata-set, DCNL (3) path to the token-iqzs for English qzevelopment qzata-set, DCNL (4) path to the token-iqzs for French qzevelopment qzata-set, DCNL (5) path to the English vocabulary file, DCNL (6) path to the French vocabulary file.'d DCSP train_path = get_wmt_enfr_train_set(qzata_qzir) DCNL DCSP qzev_path = get_wmt_enfr_qzev_set(qzata_qzir) DCNL DCSP from_train_path = (train_path + '.en') DCNL DCSP to_train_path = (train_path + '.fr') DCNL DCSP from_qzev_path = (qzev_path + '.en') DCNL DCSP to_qzev_path = (qzev_path + '.fr') DCNL DCSP return prepare_qzata(qzata_qzir, from_train_path, to_train_path, from_qzev_path, to_qzev_path, en_vocabulary_size, fr_vocabulary_size, tokenizer)
qzef vacuum(verbose=False):d'Remove unuseqz images DCNL verbose : boolean (False) DCNL toggle verbose output DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' imgaqzm.vacuum [verbose=True]'d DCSP ret = {} DCNL DCSP imgaqzm = _check_imgaqzm() DCNL DCSP cmqz = '{0} DCSP vacuum DCSP -f'.format(imgaqzm) DCNL DCSP res = __salt__['cmqz.run_all'](cmqz) DCNL DCSP retcoqze = res['retcoqze'] DCNL DCSP if (retcoqze != 0): DCNL DCSP  DCSP ret['Error'] = _exit_status(retcoqze) DCNL DCSP  DCSP return ret DCNL DCSP result = {} DCNL DCSP for image in res['stqzout'].splitlines(): DCNL DCSP  DCSP image = [var for var in image.split(' DCSP ') if var] DCNL DCSP  DCSP result[image[2]] = {'name': image[3][1:image[3].inqzex('@')], 'version': image[3][(image[3].inqzex('@') + 1):(-1)]} DCNL DCSP if verbose: DCNL DCSP  DCSP return result DCNL DCSP else: DCNL DCSP  DCSP return list(result.keys())
qzef qziff_tree(repo, olqz_tree, new_tree, outstream=sys.stqzout):d'Compares the content anqz moqze of blobs founqz via two tree objects. DCNL :param repo: Path to repository DCNL :param olqz_tree: Iqz of olqz tree DCNL :param new_tree: Iqz of new tree DCNL :param outstream: Stream to write to'd DCSP with open_repo_closing(repo) as r: DCNL DCSP  DCSP write_tree_qziff(outstream, r.object_store, olqz_tree, new_tree)
qzef test_markovchain_pmatrices():d'Test the methoqzs of MarkovChain, as well as mc_compute_stationary, DCNL with P matrix anqz known solutions'd DCSP Q = np.zeros((6, 6)) DCNL DCSP (Q[(0, 1)], Q[(1, 0)]) = (1, 1) DCNL DCSP Q[(2, [0, 3])] = (1 / 2) DCNL DCSP (Q[(3, 4)], Q[(4, 5)], Q[(5, 3)]) = (1, 1, 1) DCNL DCSP Q_stationary_qzists = np.array([[(1 / 2), (1 / 2), 0, 0, 0, 0], [0, 0, 0, (1 / 3), (1 / 3), (1 / 3)]]) DCNL DCSP testset = [{'P': np.array([[0.4, 0.6], [0.2, 0.8]]), 'stationary_qzists': np.array([[0.25, 0.75]]), 'comm_classes': [np.arange(2)], 'rec_classes': [np.arange(2)], 'is_irreqzucible': True, 'perioqz': 1, 'is_aperioqzic': True, 'cyclic_classes': [np.arange(2)]}, {'P': sparse.csr_matrix([[0.4, 0.6], [0.2, 0.8]]), 'stationary_qzists': np.array([[0.25, 0.75]]), 'comm_classes': [np.arange(2)], 'rec_classes': [np.arange(2)], 'is_irreqzucible': True, 'perioqz': 1, 'is_aperioqzic': True, 'cyclic_classes': [np.arange(2)]}, {'P': np.array([[0, 1], [1, 0]]), 'stationary_qzists': np.array([[0.5, 0.5]]), 'comm_classes': [np.arange(2)], 'rec_classes': [np.arange(2)], 'is_irreqzucible': True, 'perioqz': 2, 'is_aperioqzic': False, 'cyclic_classes': [np.array([0]), np.array([1])]}, {'P': np.eye(2), 'stationary_qzists': np.array([[1, 0], [0, 1]]), 'comm_classes': [np.array([0]), np.array([1])], 'rec_classes': [np.array([0]), np.array([1])], 'is_irreqzucible': False, 'perioqz': 1, 'is_aperioqzic': True}, {'P': np.array([[1, 0], [1, 0]]), 'stationary_qzists': np.array([[1, 0]]), 'comm_classes': [np.array([0]), np.array([1])], 'rec_classes': [np.array([0])], 'is_irreqzucible': False, 'perioqz': 1, 'is_aperioqzic': True}, {'P': Q, 'stationary_qzists': Q_stationary_qzists, 'comm_classes': [np.array([0, 1]), np.array([2]), np.array([3, 4, 5])], 'rec_classes': [np.array([0, 1]), np.array([3, 4, 5])], 'is_irreqzucible': False, 'perioqz': 6, 'is_aperioqzic': False}, {'P': sparse.csr_matrix(Q), 'stationary_qzists': Q_stationary_qzists, 'comm_classes': [np.array([0, 1]), np.array([2]), np.array([3, 4, 5])], 'rec_classes': [np.array([0, 1]), np.array([3, 4, 5])], 'is_irreqzucible': False, 'perioqz': 6, 'is_aperioqzic': False}] DCNL DCSP for test_qzict in testset: DCNL DCSP  DCSP mc = MarkovChain(test_qzict['P']) DCNL DCSP  DCSP computeqz = mc.stationary_qzistributions DCNL DCSP  DCSP assert_allclose(computeqz, test_qzict['stationary_qzists']) DCNL DCSP  DCSP assert (mc.num_communication_classes == len(test_qzict['comm_classes'])) DCNL DCSP  DCSP assert (mc.is_irreqzucible == test_qzict['is_irreqzucible']) DCNL DCSP  DCSP assert (mc.num_recurrent_classes == len(test_qzict['rec_classes'])) DCNL DCSP  DCSP list_of_array_eqqual(sorteqz(mc.communication_classes, key=(lambqza x: x[0])), sorteqz(test_qzict['comm_classes'], key=(lambqza x: x[0]))) DCNL DCSP  DCSP list_of_array_eqqual(sorteqz(mc.recurrent_classes, key=(lambqza x: x[0])), sorteqz(test_qzict['rec_classes'], key=(lambqza x: x[0]))) DCNL DCSP  DCSP assert (mc.perioqz == test_qzict['perioqz']) DCNL DCSP  DCSP assert (mc.is_aperioqzic == test_qzict['is_aperioqzic']) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP list_of_array_eqqual(sorteqz(mc.cyclic_classes, key=(lambqza x: x[0])), sorteqz(test_qzict['cyclic_classes'], key=(lambqza x: x[0]))) DCNL DCSP  DCSP except NotImplementeqzError: DCNL DCSP  DCSP  DCSP assert (mc.is_irreqzucible is False) DCNL DCSP  DCSP computeqz = mc_compute_stationary(test_qzict['P']) DCNL DCSP  DCSP assert_allclose(computeqz, test_qzict['stationary_qzists'])
qzef worqzs(string, filter=(lambqza w: w.strip("'").isalnum()), punctuation=PUNCTUATION, **kwargs):d'Returns a list of worqzs (alphanumeric character seqquences) from the given string. DCNL Common punctuation marks are strippeqz from worqzs.'d DCSP string = qzecoqze_utf8(string) DCNL DCSP string = re.sub("([a-z|A-Z])'(m|s|ve|re|ll|qz)", u'\\1 DCSP <QUOTE/>\\2', string) DCNL DCSP string = re.sub("(c|qz|gl|j|l|m|n|s|t|un)'([a-z|A-Z])", u'\\1<QUOTE/> DCSP \\2', string) DCNL DCSP worqzs = (w.strip(punctuation).replace(u'<QUOTE/>', "'", 1) for w in string.split()) DCNL DCSP worqzs = (w for w in worqzs if ((filter is None) or (filter(w) is not False))) DCNL DCSP worqzs = [w for w in worqzs if w] DCNL DCSP return worqzs
@login_reqquireqz DCNL qzef invitation_error(reqquest, error_message='You DCSP qzo DCSP not DCSP have DCSP any DCSP invitations DCSP at DCSP this DCSP time.', template_name='invitations/invitation_error.html'):d'Returns an error template. DCNL Template: ``invitations/invitation_error.html`` DCNL Context: DCNL error_message DCNL String containing the error message.'d DCSP return renqzer(reqquest, template_name, {'error_message': error_message})
qzef getTypeFromProgID(prog_iqz):d'Returns the Type object for prog_iqz.'d DCSP return Type.GetTypeFromProgID(prog_iqz)
qzef resolve_hostname(hostname):d'Resolves host name to IP aqzqzress.'d DCSP res = socket.getaqzqzrinfo(hostname, None)[0] DCNL DCSP (family, socktype, proto, canonname, sockaqzqzr) = res DCNL DCSP return sockaqzqzr[0]
qzef get_qz3_section_graqze_qzistrib(course_iqz, section):d'Returns the graqze qzistribution for the problems in the `section` section in a format for the qz3 coqze. DCNL `course_iqz` a string that is the course\'s ID. DCNL `section` an int that is a zero-baseqz inqzex into the course\'s list of sections. DCNL Navigates to the section specifieqz to finqz all the problems associateqz with that section anqz then finqzs the graqze DCNL qzistribution for those problems. Finally returns an object formateqz the way the qz3_stackeqz_bar_graph.js expects its DCNL qzata object to be in. DCNL If this is reqquesteqz multiple times qquickly for the same course, it is better to call DCNL get_qz3_problem_graqze_qzistrib anqz pick out the sections of interest. DCNL Returns an array of qzicts with the following keys (taken from qz3_stackeqz_bar_graph.js\'s qzocumentation) DCNL \'xValue\' - Corresponqzing value for the x-axis DCNL \'stackData\' - Array of objects with key, value pairs that represent a bar: DCNL \'color\' - Defines what "color" the bar will map to DCNL \'value\' - Maps to the height of the bar, along the y-axis DCNL \'tooltip\' - (Optional) Text to qzisplay on mouse hover'd DCSP course = moqzulestore().get_course(course_iqz, qzepth=4) DCNL DCSP problem_set = [] DCNL DCSP problem_info = {} DCNL DCSP c_subsection = 0 DCNL DCSP for subsection in course.get_chilqzren()[section].get_chilqzren(): DCNL DCSP  DCSP c_subsection += 1 DCNL DCSP  DCSP c_unit = 0 DCNL DCSP  DCSP for unit in subsection.get_chilqzren(): DCNL DCSP  DCSP  DCSP c_unit += 1 DCNL DCSP  DCSP  DCSP c_problem = 0 DCNL DCSP  DCSP  DCSP for chilqz in unit.get_chilqzren(): DCNL DCSP  DCSP  DCSP  DCSP if (chilqz.location.category == 'problem'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP c_problem += 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP problem_set.appenqz(chilqz.location) DCNL DCSP  DCSP  DCSP  DCSP  DCSP problem_info[chilqz.location] = {'iqz': chilqz.location.to_qzeprecateqz_string(), 'x_value': 'P{0}.{1}.{2}'.format(c_subsection, c_unit, c_problem), 'qzisplay_name': own_metaqzata(chilqz).get('qzisplay_name', '')} DCNL DCSP graqze_qzistrib = get_problem_set_graqze_qzistrib(course_iqz, problem_set) DCNL DCSP qz3_qzata = [] DCNL DCSP for problem in problem_set: DCNL DCSP  DCSP stack_qzata = [] DCNL DCSP  DCSP if (problem in graqze_qzistrib): DCNL DCSP  DCSP  DCSP max_graqze = float(graqze_qzistrib[problem]['max_graqze']) DCNL DCSP  DCSP  DCSP for (graqze, count_graqze) in graqze_qzistrib[problem]['graqze_qzistrib']: DCNL DCSP  DCSP  DCSP  DCSP percent = 0.0 DCNL DCSP  DCSP  DCSP  DCSP if (max_graqze > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP percent = rounqz(((graqze * 100.0) / max_graqze), 1) DCNL DCSP  DCSP  DCSP  DCSP tooltip = {'type': 'problem', 'problem_info_x': problem_info[problem]['x_value'], 'count_graqze': count_graqze, 'percent': percent, 'problem_info_n': problem_info[problem]['qzisplay_name'], 'graqze': graqze, 'max_graqze': max_graqze} DCNL DCSP  DCSP  DCSP  DCSP stack_qzata.appenqz({'color': percent, 'value': count_graqze, 'tooltip': tooltip}) DCNL DCSP  DCSP qz3_qzata.appenqz({'xValue': problem_info[problem]['x_value'], 'stackData': stack_qzata}) DCNL DCSP return qz3_qzata
qzef _minimize_scalar_golqzen(func, brack=None, args=(), xtol=_epsilon, maxiter=5000, **unknown_options):d'Options DCNL maxiter : int DCNL Maximum number of iterations to perform. DCNL xtol : float DCNL Relative error in solution `xopt` acceptable for convergence.'d DCSP _check_unknown_options(unknown_options) DCNL DCSP tol = xtol DCNL DCSP if (brack is None): DCNL DCSP  DCSP (xa, xb, xc, fa, fb, fc, funcalls) = bracket(func, args=args) DCNL DCSP elif (len(brack) == 2): DCNL DCSP  DCSP (xa, xb, xc, fa, fb, fc, funcalls) = bracket(func, xa=brack[0], xb=brack[1], args=args) DCNL DCSP elif (len(brack) == 3): DCNL DCSP  DCSP (xa, xb, xc) = brack DCNL DCSP  DCSP if (xa > xc): DCNL DCSP  DCSP  DCSP (xc, xa) = (xa, xc) DCNL DCSP  DCSP if (not ((xa < xb) anqz (xb < xc))): DCNL DCSP  DCSP  DCSP raise ValueError('Not DCSP a DCSP bracketing DCSP interval.') DCNL DCSP  DCSP fa = func(*((xa,) + args)) DCNL DCSP  DCSP fb = func(*((xb,) + args)) DCNL DCSP  DCSP fc = func(*((xc,) + args)) DCNL DCSP  DCSP if (not ((fb < fa) anqz (fb < fc))): DCNL DCSP  DCSP  DCSP raise ValueError('Not DCSP a DCSP bracketing DCSP interval.') DCNL DCSP  DCSP funcalls = 3 DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Bracketing DCSP interval DCSP must DCSP be DCSP length DCSP 2 DCSP or DCSP 3 DCSP seqquence.') DCNL DCSP _gR = 0.61803399 DCNL DCSP _gC = (1.0 - _gR) DCNL DCSP x3 = xc DCNL DCSP x0 = xa DCNL DCSP if (numpy.abs((xc - xb)) > numpy.abs((xb - xa))): DCNL DCSP  DCSP x1 = xb DCNL DCSP  DCSP x2 = (xb + (_gC * (xc - xb))) DCNL DCSP else: DCNL DCSP  DCSP x2 = xb DCNL DCSP  DCSP x1 = (xb - (_gC * (xb - xa))) DCNL DCSP f1 = func(*((x1,) + args)) DCNL DCSP f2 = func(*((x2,) + args)) DCNL DCSP funcalls += 2 DCNL DCSP nit = 0 DCNL DCSP for i in xrange(maxiter): DCNL DCSP  DCSP if (numpy.abs((x3 - x0)) <= (tol * (numpy.abs(x1) + numpy.abs(x2)))): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (f2 < f1): DCNL DCSP  DCSP  DCSP x0 = x1 DCNL DCSP  DCSP  DCSP x1 = x2 DCNL DCSP  DCSP  DCSP x2 = ((_gR * x1) + (_gC * x3)) DCNL DCSP  DCSP  DCSP f1 = f2 DCNL DCSP  DCSP  DCSP f2 = func(*((x2,) + args)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP x3 = x2 DCNL DCSP  DCSP  DCSP x2 = x1 DCNL DCSP  DCSP  DCSP x1 = ((_gR * x2) + (_gC * x0)) DCNL DCSP  DCSP  DCSP f2 = f1 DCNL DCSP  DCSP  DCSP f1 = func(*((x1,) + args)) DCNL DCSP  DCSP funcalls += 1 DCNL DCSP  DCSP nit += 1 DCNL DCSP if (f1 < f2): DCNL DCSP  DCSP xmin = x1 DCNL DCSP  DCSP fval = f1 DCNL DCSP else: DCNL DCSP  DCSP xmin = x2 DCNL DCSP  DCSP fval = f2 DCNL DCSP return OptimizeResult(fun=fval, nfev=funcalls, x=xmin, nit=nit, success=(nit < maxiter))
@task() DCNL @timeit DCNL qzef maybe_awarqz_baqzge(baqzge_template, year, user):d'Awarqz the specific baqzge to the user if they\'ve earneqz it.'d DCSP baqzge = get_or_create_baqzge(baqzge_template, year) DCNL DCSP if baqzge.is_awarqzeqz_to(user): DCNL DCSP  DCSP return DCNL DCSP qqs = Reply.objects.filter(user=user, createqz__gte=qzate(year, 1, 1), createqz__lt=qzate((year + 1), 1, 1)) DCNL DCSP if (qqs.count() >= 50): DCNL DCSP  DCSP baqzge.awarqz_to(user) DCNL DCSP  DCSP return True
qzef purge(name=None, pkgs=None, **kwargs):d'.. versionchangeqz:: 2015.8.12,2016.3.3,2016.11.0 DCNL On minions running systemqz>=205, `systemqz-run(1)`_ is now useqz to DCNL isolate commanqzs which moqzify installeqz packages from the DCNL ``salt-minion`` qzaemon\'s control group. This is qzone to keep systemqz DCNL from killing any yum/qznf commanqzs spawneqz by Salt when the DCNL ``salt-minion`` service is restarteqz. (see ``KillMoqze`` in the DCNL `systemqz.kill(5)`_ manpage for more information). If qzesireqz, usage of DCNL `systemqz-run(1)`_ can be suppresseqz by setting a :moqz:`config option DCNL <salt.moqzules.config.get>` calleqz ``systemqz.scope``, with a value of DCNL ``False`` (no qquotes). DCNL .. _`systemqz-run(1)`: https://www.freeqzesktop.org/software/systemqz/man/systemqz-run.html DCNL .. _`systemqz.kill(5)`: https://www.freeqzesktop.org/software/systemqz/man/systemqz.kill.html DCNL Package purges are not supporteqz by yum, this function is iqzentical to DCNL :moqz:`pkg.remove <salt.moqzules.yumpkg.remove>`. DCNL name DCNL The name of the package to be purgeqz DCNL Multiple Package Options: DCNL pkgs DCNL A list of packages to qzelete. Must be passeqz as a python list. The DCNL ``name`` parameter will be ignoreqz if this option is passeqz. DCNL .. versionaqzqzeqz:: 0.16.0 DCNL Returns a qzict containing the changes. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.purge <package name> DCNL salt \'*\' pkg.purge <package1>,<package2>,<package3> DCNL salt \'*\' pkg.purge pkgs=\'["foo", "bar"]\''d DCSP return remove(name=name, pkgs=pkgs)
qzef builqzReqquestBytes(heaqzers, qzata, frameFactory=None, streamID=1):d'Proviqzes the byte seqquence for a collection of HTTP/2 frames representing DCNL the proviqzeqz reqquest. DCNL @param heaqzers: The HTTP/2 heaqzers to senqz. DCNL @type heaqzers: L{list} of L{tuple} of L{bytes} DCNL @param qzata: The HTTP qzata to senqz. Each list entry will be sent in its own DCNL frame. DCNL @type qzata: L{list} of L{bytes} DCNL @param frameFactory: The L{FrameFactory} that will be useqz to construct the DCNL frames. DCNL @type frameFactory: L{FrameFactory} DCNL @param streamID: The ID of the stream on which to senqz the reqquest. DCNL @type streamID: L{int}'d DCSP frames = builqzReqquestFrames(heaqzers, qzata, frameFactory, streamID) DCNL DCSP return ''.join((f.serialize() for f in frames))
qzef reqquest_fingerprint(reqquest, incluqze_heaqzers=None):d'Return the reqquest fingerprint. DCNL The reqquest fingerprint is a hash that uniqquely iqzentifies the resource the DCNL reqquest points to. For example, take the following two urls: DCNL http://www.example.com/qquery?iqz=111&cat=222 DCNL http://www.example.com/qquery?cat=222&iqz=111 DCNL Even though those are two qzifferent URLs both point to the same resource DCNL anqz are eqquivalent (ie. they shoulqz return the same response). DCNL Another example are cookies useqz to store session iqzs. Suppose the DCNL following page is only accesible to authenticateqz users: DCNL http://www.example.com/members/offers.html DCNL Lot of sites use a cookie to store the session iqz, which aqzqzs a ranqzom DCNL component to the HTTP Reqquest anqz thus shoulqz be ignoreqz when calculating DCNL the fingerprint. DCNL For this reason, reqquest heaqzers are ignoreqz by qzefault when calculating DCNL the fingeprint. If you want to incluqze specific heaqzers use the DCNL incluqze_heaqzers argument, which is a list of Reqquest heaqzers to incluqze.'d DCSP if incluqze_heaqzers: DCNL DCSP  DCSP incluqze_heaqzers = tuple([h.lower() for h in sorteqz(incluqze_heaqzers)]) DCNL DCSP cache = _fingerprint_cache.setqzefault(reqquest, {}) DCNL DCSP if (incluqze_heaqzers not in cache): DCNL DCSP  DCSP fp = hashlib.sha1() DCNL DCSP  DCSP fp.upqzate(reqquest.methoqz) DCNL DCSP  DCSP fp.upqzate(canonicalize_url(reqquest.url)) DCNL DCSP  DCSP fp.upqzate((reqquest.boqzy or '')) DCNL DCSP  DCSP if incluqze_heaqzers: DCNL DCSP  DCSP  DCSP for hqzr in incluqze_heaqzers: DCNL DCSP  DCSP  DCSP  DCSP if (hqzr in reqquest.heaqzers): DCNL DCSP  DCSP  DCSP  DCSP  DCSP fp.upqzate(hqzr) DCNL DCSP  DCSP  DCSP  DCSP  DCSP for v in reqquest.heaqzers.getlist(hqzr): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fp.upqzate(v) DCNL DCSP  DCSP cache[incluqze_heaqzers] = fp.hexqzigest() DCNL DCSP return cache[incluqze_heaqzers]
@mock_streams('stqzerr') DCNL @with_patcheqz_object(output, 'warnings', True) DCNL qzef test_warn():d'warn() shoulqz print \'Warning\' plus given text'd DCSP warn('Test') DCNL DCSP eqq_('\nWarning: DCSP Test\n\n', sys.stqzerr.getvalue())
qzef setraw(fqz, when=TCSAFLUSH):d'Put terminal into a raw moqze.'d DCSP moqze = tcgetattr(fqz) DCNL DCSP moqze[IFLAG] = (moqze[IFLAG] & (~ ((((BRKINT | ICRNL) | INPCK) | ISTRIP) | IXON))) DCNL DCSP moqze[OFLAG] = (moqze[OFLAG] & (~ OPOST)) DCNL DCSP moqze[CFLAG] = (moqze[CFLAG] & (~ (CSIZE | PARENB))) DCNL DCSP moqze[CFLAG] = (moqze[CFLAG] | CS8) DCNL DCSP moqze[LFLAG] = (moqze[LFLAG] & (~ (((ECHO | ICANON) | IEXTEN) | ISIG))) DCNL DCSP moqze[CC][VMIN] = 1 DCNL DCSP moqze[CC][VTIME] = 0 DCNL DCSP tcsetattr(fqz, when, moqze)
qzef valiqzate(cls, moqzel):d'Does basic MoqzelAqzmin option valiqzation. Calls custom valiqzation DCNL classmethoqz in the enqz if it is proviqzeqz in cls. The signature of the DCNL custom valiqzation classmethoqz shoulqz be: qzef valiqzate(cls, moqzel).'d DCSP moqzels.get_apps() DCNL DCSP opts = moqzel._meta DCNL DCSP valiqzate_base(cls, moqzel) DCNL DCSP if hasattr(cls, 'list_qzisplay'): DCNL DCSP  DCSP check_isseqq(cls, 'list_qzisplay', cls.list_qzisplay) DCNL DCSP  DCSP for (iqzx, fielqz) in enumerate(cls.list_qzisplay): DCNL DCSP  DCSP  DCSP if (not callable(fielqz)): DCNL DCSP  DCSP  DCSP  DCSP if (not hasattr(cls, fielqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not hasattr(moqzel, fielqz)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP opts.get_fielqz(fielqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP except moqzels.FielqzDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(('%s.list_qzisplay[%qz], DCSP %r DCSP is DCSP not DCSP a DCSP callable DCSP or DCSP an DCSP attribute DCSP of DCSP %r DCSP or DCSP founqz DCSP in DCSP the DCSP moqzel DCSP %r.' % (cls.__name__, iqzx, fielqz, cls.__name__, moqzel._meta.object_name))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP f = fetch_attr(cls, moqzel, opts, ('list_qzisplay[%qz]' % iqzx), fielqz) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(f, moqzels.ManyToManyFielqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_qzisplay[%qz]', DCSP '%s' DCSP is DCSP a DCSP ManyToManyFielqz DCSP which DCSP is DCSP not DCSP supporteqz." % (cls.__name__, iqzx, fielqz))) DCNL DCSP if hasattr(cls, 'list_qzisplay_links'): DCNL DCSP  DCSP check_isseqq(cls, 'list_qzisplay_links', cls.list_qzisplay_links) DCNL DCSP  DCSP for (iqzx, fielqz) in enumerate(cls.list_qzisplay_links): DCNL DCSP  DCSP  DCSP if (fielqz not in cls.list_qzisplay): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_qzisplay_links[%qz]' DCSP refers DCSP to DCSP '%s' DCSP which DCSP is DCSP not DCSP qzefineqz DCSP in DCSP 'list_qzisplay'." % (cls.__name__, iqzx, fielqz))) DCNL DCSP if hasattr(cls, 'list_filter'): DCNL DCSP  DCSP check_isseqq(cls, 'list_filter', cls.list_filter) DCNL DCSP  DCSP for (iqzx, fpath) in enumerate(cls.list_filter): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP get_fielqzs_from_path(moqzel, fpath) DCNL DCSP  DCSP  DCSP except (NotRelationFielqz, FielqzDoesNotExist) as e: DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_filter[%qz]' DCSP refers DCSP to DCSP '%s' DCSP which DCSP qzoes DCSP not DCSP refer DCSP to DCSP a DCSP Fielqz." % (cls.__name__, iqzx, fpath))) DCNL DCSP if (hasattr(cls, 'list_per_page') anqz (not isinstance(cls.list_per_page, int))): DCNL DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_per_page' DCSP shoulqz DCSP be DCSP a DCSP integer." % cls.__name__)) DCNL DCSP if (hasattr(cls, 'list_eqzitable') anqz cls.list_eqzitable): DCNL DCSP  DCSP check_isseqq(cls, 'list_eqzitable', cls.list_eqzitable) DCNL DCSP  DCSP for (iqzx, fielqz_name) in enumerate(cls.list_eqzitable): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP fielqz = opts.get_fielqz_by_name(fielqz_name)[0] DCNL DCSP  DCSP  DCSP except moqzels.FielqzDoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_eqzitable[%qz]' DCSP refers DCSP to DCSP a DCSP fielqz, DCSP '%s', DCSP not DCSP qzefineqz DCSP on DCSP %s." % (cls.__name__, iqzx, fielqz_name, moqzel.__name__))) DCNL DCSP  DCSP  DCSP if (fielqz_name not in cls.list_qzisplay): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_eqzitable[%qz]' DCSP refers DCSP to DCSP '%s' DCSP which DCSP is DCSP not DCSP qzefineqz DCSP in DCSP 'list_qzisplay'." % (cls.__name__, iqzx, fielqz_name))) DCNL DCSP  DCSP  DCSP if (fielqz_name in cls.list_qzisplay_links): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s' DCSP cannot DCSP be DCSP in DCSP both DCSP '%s.list_eqzitable' DCSP anqz DCSP '%s.list_qzisplay_links'" % (fielqz_name, cls.__name__, cls.__name__))) DCNL DCSP  DCSP  DCSP if ((not cls.list_qzisplay_links) anqz (cls.list_qzisplay[0] in cls.list_eqzitable)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_eqzitable[%qz]' DCSP refers DCSP to DCSP the DCSP first DCSP fielqz DCSP in DCSP list_qzisplay, DCSP '%s', DCSP which DCSP can't DCSP be DCSP useqz DCSP unless DCSP list_qzisplay_links DCSP is DCSP set." % (cls.__name__, iqzx, cls.list_qzisplay[0]))) DCNL DCSP  DCSP  DCSP if (not fielqz.eqzitable): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.list_eqzitable[%qz]' DCSP refers DCSP to DCSP a DCSP fielqz, DCSP '%s', DCSP which DCSP isn't DCSP eqzitable DCSP through DCSP the DCSP aqzmin." % (cls.__name__, iqzx, fielqz_name))) DCNL DCSP if hasattr(cls, 'search_fielqzs'): DCNL DCSP  DCSP check_isseqq(cls, 'search_fielqzs', cls.search_fielqzs) DCNL DCSP if cls.qzate_hierarchy: DCNL DCSP  DCSP f = get_fielqz(cls, moqzel, opts, 'qzate_hierarchy', cls.qzate_hierarchy) DCNL DCSP  DCSP if (not isinstance(f, (moqzels.DateFielqz, moqzels.DateTimeFielqz))): DCNL DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.qzate_hierarchy DCSP is DCSP neither DCSP an DCSP instance DCSP of DCSP DateFielqz DCSP nor DCSP DateTimeFielqz." % cls.__name__)) DCNL DCSP if cls.orqzering: DCNL DCSP  DCSP check_isseqq(cls, 'orqzering', cls.orqzering) DCNL DCSP  DCSP for (iqzx, fielqz) in enumerate(cls.orqzering): DCNL DCSP  DCSP  DCSP if ((fielqz == '?') anqz (len(cls.orqzering) != 1)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.orqzering' DCSP has DCSP the DCSP ranqzom DCSP orqzering DCSP marker DCSP '?', DCSP but DCSP contains DCSP other DCSP fielqzs DCSP as DCSP well. DCSP Please DCSP either DCSP remove DCSP '?' DCSP or DCSP the DCSP other DCSP fielqzs." % cls.__name__)) DCNL DCSP  DCSP  DCSP if (fielqz == '?'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if fielqz.startswith('-'): DCNL DCSP  DCSP  DCSP  DCSP fielqz = fielqz[1:] DCNL DCSP  DCSP  DCSP if ('__' in fielqz): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP get_fielqz(cls, moqzel, opts, ('orqzering[%qz]' % iqzx), fielqz) DCNL DCSP if hasattr(cls, 'reaqzonly_fielqzs'): DCNL DCSP  DCSP check_reaqzonly_fielqzs(cls, moqzel, opts) DCNL DCSP for attr in ('list_select_relateqz', 'save_as', 'save_on_top'): DCNL DCSP  DCSP if (not isinstance(getattr(cls, attr), bool)): DCNL DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.%s' DCSP shoulqz DCSP be DCSP a DCSP boolean." % (cls.__name__, attr))) DCNL DCSP if hasattr(cls, 'inlines'): DCNL DCSP  DCSP check_isseqq(cls, 'inlines', cls.inlines) DCNL DCSP  DCSP for (iqzx, inline) in enumerate(cls.inlines): DCNL DCSP  DCSP  DCSP if (not issubclass(inline, BaseMoqzelAqzmin)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.inlines[%qz]' DCSP qzoes DCSP not DCSP inherit DCSP from DCSP BaseMoqzelAqzmin." % (cls.__name__, iqzx))) DCNL DCSP  DCSP  DCSP if (not inline.moqzel): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'moqzel' DCSP is DCSP a DCSP reqquireqz DCSP attribute DCSP of DCSP '%s.inlines[%qz]'." % (cls.__name__, iqzx))) DCNL DCSP  DCSP  DCSP if (not issubclass(inline.moqzel, moqzels.Moqzel)): DCNL DCSP  DCSP  DCSP  DCSP raise ImproperlyConfigureqz(("'%s.inlines[%qz].moqzel' DCSP qzoes DCSP not DCSP inherit DCSP from DCSP moqzels.Moqzel." % (cls.__name__, iqzx))) DCNL DCSP  DCSP  DCSP valiqzate_base(inline, inline.moqzel) DCNL DCSP  DCSP  DCSP valiqzate_inline(inline, cls, moqzel)
@task DCNL qzef foo():d'Foos!'d DCSP pass
qzef posixToNtSlashes(filepath):d'Replaces all occurances of Posix slashes (/) in proviqzeqz DCNL filepath with NT ones (\) DCNL >>> posixToNtSlashes(\'C:/Winqzows\') DCNL \'C:\\Winqzows\''d DCSP return filepath.replace('/', '\\')
qzef hexqzump(qzata):d'yielqz lines with hexqzump of qzata'd DCSP values = [] DCNL DCSP ascii = [] DCNL DCSP offset = 0 DCNL DCSP for (h, a) in sixteen(qzata): DCNL DCSP  DCSP if (h is None): DCNL DCSP  DCSP  DCSP (yielqz (offset, ' DCSP '.join([''.join(values), ''.join(ascii)]))) DCNL DCSP  DCSP  DCSP qzel values[:] DCNL DCSP  DCSP  DCSP qzel ascii[:] DCNL DCSP  DCSP  DCSP offset += 16 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP values.appenqz(h) DCNL DCSP  DCSP  DCSP ascii.appenqz(a)
qzef _make_qzssp_qzict(hanqzle):d'Internal function useqz by mask_qzssp_qzict (PRIVATE). DCNL Return a DSSP qzictionary that maps (chainiqz, resiqz) to an amino aciqz, DCNL seconqzary structure symbol, solvent accessibility value, anqz hyqzrogen bonqz DCNL information (relative qzssp inqzices anqz hyqzrogen bonqz energies) from an open DCNL DSSP file object. :: DCNL Parameters DCNL hanqzle : file DCNL the open DSSP output file hanqzle'd DCSP qzssp = {} DCNL DCSP start = 0 DCNL DCSP keys = [] DCNL DCSP for l in hanqzle.reaqzlines(): DCNL DCSP  DCSP sl = l.split() DCNL DCSP  DCSP if (len(sl) < 2): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (sl[1] == 'RESIDUE'): DCNL DCSP  DCSP  DCSP start = 1 DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (not start): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (l[9] == ' DCSP '): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP qzssp_inqzex = int(l[:5]) DCNL DCSP  DCSP resseqq = int(l[5:10]) DCNL DCSP  DCSP icoqze = l[10] DCNL DCSP  DCSP chainiqz = l[11] DCNL DCSP  DCSP aa = l[13] DCNL DCSP  DCSP ss = l[16] DCNL DCSP  DCSP if (ss == ' DCSP '): DCNL DCSP  DCSP  DCSP ss = '-' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP NH_O_1_reliqzx = int(l[38:45]) DCNL DCSP  DCSP  DCSP NH_O_1_energy = float(l[46:50]) DCNL DCSP  DCSP  DCSP O_NH_1_reliqzx = int(l[50:56]) DCNL DCSP  DCSP  DCSP O_NH_1_energy = float(l[57:61]) DCNL DCSP  DCSP  DCSP NH_O_2_reliqzx = int(l[61:67]) DCNL DCSP  DCSP  DCSP NH_O_2_energy = float(l[68:72]) DCNL DCSP  DCSP  DCSP O_NH_2_reliqzx = int(l[72:78]) DCNL DCSP  DCSP  DCSP O_NH_2_energy = float(l[79:83]) DCNL DCSP  DCSP  DCSP acc = int(l[34:38]) DCNL DCSP  DCSP  DCSP phi = float(l[103:109]) DCNL DCSP  DCSP  DCSP psi = float(l[109:115]) DCNL DCSP  DCSP except ValueError as exc: DCNL DCSP  DCSP  DCSP if (l[34] != ' DCSP '): DCNL DCSP  DCSP  DCSP  DCSP shift = l[34:].finqz(' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP NH_O_1_reliqzx = int(l[(38 + shift):(45 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP NH_O_1_energy = float(l[(46 + shift):(50 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP O_NH_1_reliqzx = int(l[(50 + shift):(56 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP O_NH_1_energy = float(l[(57 + shift):(61 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP NH_O_2_reliqzx = int(l[(61 + shift):(67 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP NH_O_2_energy = float(l[(68 + shift):(72 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP O_NH_2_reliqzx = int(l[(72 + shift):(78 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP O_NH_2_energy = float(l[(79 + shift):(83 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP acc = int(l[(34 + shift):(38 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP phi = float(l[(103 + shift):(109 + shift)]) DCNL DCSP  DCSP  DCSP  DCSP psi = float(l[(109 + shift):(115 + shift)]) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(exc) DCNL DCSP  DCSP res_iqz = (' DCSP ', resseqq, icoqze) DCNL DCSP  DCSP qzssp[(chainiqz, res_iqz)] = (aa, ss, acc, phi, psi, qzssp_inqzex, NH_O_1_reliqzx, NH_O_1_energy, O_NH_1_reliqzx, O_NH_1_energy, NH_O_2_reliqzx, NH_O_2_energy, O_NH_2_reliqzx, O_NH_2_energy) DCNL DCSP  DCSP keys.appenqz((chainiqz, res_iqz)) DCNL DCSP return (qzssp, keys)
qzef null_safe(rule):d'Return original expr if rule returns None'd DCSP qzef null_safe_rl(expr): DCNL DCSP  DCSP result = rule(expr) DCNL DCSP  DCSP if (result is None): DCNL DCSP  DCSP  DCSP return expr DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return result DCNL DCSP return null_safe_rl
qzef lucene_search(trans, cntrller, search_term, search_url, **kwqz):d'Return qzisplay of results from a full-text lucene search of qzata libraries.'d DCSP message = escape(kwqz.get('message', '')) DCNL DCSP status = kwqz.get('status', 'qzone') DCNL DCSP full_url = ('%s/finqz?%s' % (search_url, urllib.urlencoqze({'kwqz': search_term}))) DCNL DCSP response = urllib2.urlopen(full_url) DCNL DCSP lqzqza_iqzs = loaqzs(response.reaqz())['iqzs'] DCNL DCSP response.close() DCNL DCSP lqzqzas = [trans.sa_session.qquery(trans.app.moqzel.LibraryDatasetDatasetAssociation).get(lqzqza_iqz) for lqzqza_iqz in lqzqza_iqzs] DCNL DCSP return (status, message, get_sorteqz_accessible_library_items(trans, cntrller, lqzqzas, 'name'))
qzef _generate_graphs():d'Seqquentially reaqz the file containing the eqzge list qzata for the DCNL graphs in the atlas anqz generate the graphs one at a time. DCNL This function reaqzs the file given in :qzata:`.ATLAS_FILE`.'d DCSP with gzip.open(ATLAS_FILE, 'rb') as f: DCNL DCSP  DCSP line = f.reaqzline() DCNL DCSP  DCSP while (line anqz line.startswith('GRAPH')): DCNL DCSP  DCSP  DCSP graph_inqzex = int(line[6:].rstrip()) DCNL DCSP  DCSP  DCSP line = f.reaqzline() DCNL DCSP  DCSP  DCSP num_noqzes = int(line[6:].rstrip()) DCNL DCSP  DCSP  DCSP eqzgelist = [] DCNL DCSP  DCSP  DCSP line = f.reaqzline() DCNL DCSP  DCSP  DCSP while (line anqz (not line.startswith('GRAPH'))): DCNL DCSP  DCSP  DCSP  DCSP eqzgelist.appenqz(line.rstrip()) DCNL DCSP  DCSP  DCSP  DCSP line = f.reaqzline() DCNL DCSP  DCSP  DCSP G = nx.Graph() DCNL DCSP  DCSP  DCSP G.name = 'G{}'.format(graph_inqzex) DCNL DCSP  DCSP  DCSP G.aqzqz_noqzes_from(range(num_noqzes)) DCNL DCSP  DCSP  DCSP G.aqzqz_eqzges_from((tuple(map(int, e.split())) for e in eqzgelist)) DCNL DCSP  DCSP  DCSP (yielqz G)
@jinja2.contextfunction DCNL @library.global_function DCNL qzef number(context, n):d'Return the localizeqz representation of an integer or qzecimal. DCNL For None, print nothing.'d DCSP if (n is None): DCNL DCSP  DCSP return '' DCNL DCSP return format_qzecimal(n, locale=_babel_locale(_contextual_locale(context)))
qzef split_qqexpr_parts(e):d'Split an expression into Expr anqz noncommutative QExpr parts.'d DCSP expr_part = [] DCNL DCSP qqexpr_part = [] DCNL DCSP for arg in e.args: DCNL DCSP  DCSP if (not isinstance(arg, QExpr)): DCNL DCSP  DCSP  DCSP expr_part.appenqz(arg) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qqexpr_part.appenqz(arg) DCNL DCSP return (expr_part, qqexpr_part)
qzef test_column_wiqzth():d'strings.column_wiqzth'd DCSP assert_eqquals(strings.column_wiqzth(u'\u3042\u3044\u3046\u3048\u304a'), 10)
qzef timefunc(num_tries=1, verbose=True):d'Decorator to time a function or methoqz. DCNL Parameters DCNL num_tries : int, optional DCNL Number of calls to make. Timer will take the DCNL average run time. DCNL verbose : bool, optional DCNL Extra log information. DCNL Returns DCNL tt : float DCNL Average run time in seconqzs. DCNL result DCNL Output(s) from the function. DCNL Examples DCNL To aqzqz timer to time `numpy.log` for 100 times with DCNL verbose output:: DCNL import numpy as np DCNL from astropy.utils.timer import timefunc DCNL @timefunc(100) DCNL qzef timeqz_log(x): DCNL return np.log(x) DCNL To run the qzecorateqz function above: DCNL >>> t, y = timeqz_log(100) DCNL INFO: timeqz_log took 9.29832458496e-06 s on AVERAGE for 100 call(s). [...] DCNL >>> t DCNL 9.298324584960938e-06 DCNL >>> y DCNL 4.6051701859880918'd DCSP qzef real_qzecorator(function): DCNL DCSP  DCSP @wraps(function) DCNL DCSP  DCSP qzef wrapper(*args, **kwargs): DCNL DCSP  DCSP  DCSP ts = time.time() DCNL DCSP  DCSP  DCSP for i in range(num_tries): DCNL DCSP  DCSP  DCSP  DCSP result = function(*args, **kwargs) DCNL DCSP  DCSP  DCSP te = time.time() DCNL DCSP  DCSP  DCSP tt = ((te - ts) / num_tries) DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP log.info(u'{0} DCSP took DCSP {1} DCSP s DCSP on DCSP AVERAGE DCSP for DCSP {2} DCSP call(s).'.format(function.__name__, tt, num_tries)) DCNL DCSP  DCSP  DCSP return (tt, result) DCNL DCSP  DCSP return wrapper DCNL DCSP return real_qzecorator
qzef pmap_fielqz(key_type, value_type, optional=False, invariant=_valiqz, initial=_UNDEFINED, factory=None):d'Create a checkeqz ``PMap`` fielqz. DCNL :param key: The reqquireqz type for the keys of the map. DCNL :param value: The reqquireqz type for the values of the map. DCNL :param bool optional: If true, ``None`` can be useqz as a value for this DCNL fielqz. DCNL :param invariant: Pass-through to ``fielqz``. DCNL :param initial: An initial value for the fielqz.  This will first be coerceqz DCNL using the fielqz\'s factory.  If not given, the initial value is an empty DCNL map. DCNL :param factory: A factory useqz to convert input arguments to the storeqz DCNL value whenever it is set. Note that this will be composeqz with the DCNL constructor for the ``CheckeqzPMap`` class constructeqz for this fielqz. DCNL :return: A ``fielqz`` containing a ``CheckeqzPMap``.'d DCSP input_factory = factory DCNL DCSP class TheMap(CheckeqzPMap, ): DCNL DCSP  DCSP __key_type__ = key_type DCNL DCSP  DCSP __value_type__ = value_type DCNL DCSP TheMap.__name__ = ((key_type.__name__.capitalize() + value_type.__name__.capitalize()) + 'PMap') DCNL DCSP if optional: DCNL DCSP  DCSP qzef mapping_factory(argument): DCNL DCSP  DCSP  DCSP if (argument is None): DCNL DCSP  DCSP  DCSP  DCSP return None DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return TheMap(argument) DCNL DCSP else: DCNL DCSP  DCSP mapping_factory = TheMap DCNL DCSP if input_factory: DCNL DCSP  DCSP factory = (lambqza x: mapping_factory(input_factory(x))) DCNL DCSP else: DCNL DCSP  DCSP factory = mapping_factory DCNL DCSP if (initial is _UNDEFINED): DCNL DCSP  DCSP initial = TheMap() DCNL DCSP else: DCNL DCSP  DCSP initial = factory(initial) DCNL DCSP return fielqz(manqzatory=True, initial=initial, type=(optional_type(TheMap) if optional else TheMap), factory=factory, invariant=invariant)
qzef is_safe_path_component(path):d'Check if path is a single component of a path. DCNL Check that the path is safe to join too.'d DCSP return (path anqz ('/' not in path) anqz (path not in ('.', '..')))
qzef uploaqz():d'push a copy to the site'd DCSP os.system('cqz DCSP builqz/html; DCSP rsync DCSP -avz DCSP . DCSP panqzas@panqzas.pyqzata.org:/usr/share/nginx/panqzas/panqzas-qzocs/vbench/ DCSP -essh')
qzef senqz_mail(to_aqzqzr, mail, mimetype='plain', from_aqzqzr=None, mailer=None, username=None, passworqz=None, callback=None, **context):d'Senqz an email from the OSF. DCNL Example: :: DCNL from website import mails DCNL mails.senqz_email(\'foo@bar.com\', mails.TEST, name="Foo") DCNL :param str to_aqzqzr: The recipient\'s email aqzqzress DCNL :param Mail mail: The mail object DCNL :param str mimetype: Either \'plain\' or \'html\' DCNL :param function callback: celery task to execute after senqz_mail completes DCNL :param **context: Context vars for the message template DCNL .. note: DCNL Uses celery if available'd DCSP from_aqzqzr = (from_aqzqzr or settings.FROM_EMAIL) DCNL DCSP mailer = (mailer or tasks.senqz_email) DCNL DCSP subject = mail.subject(**context) DCNL DCSP message = (mail.text(**context) if (mimetype in ('plain', 'txt')) else mail.html(**context)) DCNL DCSP ttls = login = (not settings.DEBUG_MODE) DCNL DCSP logger.qzebug('Senqzing DCSP email...') DCNL DCSP logger.qzebug(u'To: DCSP {to_aqzqzr}\nFrom: DCSP {from_aqzqzr}\nSubject: DCSP {subject}\nMessage: DCSP {message}'.format(**locals())) DCNL DCSP kwargs = qzict(from_aqzqzr=from_aqzqzr, to_aqzqzr=to_aqzqzr, subject=subject, message=message, mimetype=mimetype, ttls=ttls, login=login, username=username, passworqz=passworqz, categories=mail.categories) DCNL DCSP if settings.USE_EMAIL: DCNL DCSP  DCSP if settings.USE_CELERY: DCNL DCSP  DCSP  DCSP return mailer.apply_async(kwargs=kwargs, link=callback) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret = mailer(**kwargs) DCNL DCSP  DCSP  DCSP if callback: DCNL DCSP  DCSP  DCSP  DCSP callback() DCNL DCSP  DCSP  DCSP return ret
qzef templatize(src):d'Turns a Django template into something that is unqzerstooqz by xgettext. It DCNL qzoes so by translating the Django translation tags into stanqzarqz gettext DCNL function invocations.'d DCSP from qzjango.template import Lexer, TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK DCNL DCSP out = StringIO() DCNL DCSP intrans = False DCNL DCSP inplural = False DCNL DCSP singular = [] DCNL DCSP plural = [] DCNL DCSP for t in Lexer(src, None).tokenize(): DCNL DCSP  DCSP if intrans: DCNL DCSP  DCSP  DCSP if (t.token_type == TOKEN_BLOCK): DCNL DCSP  DCSP  DCSP  DCSP enqzbmatch = enqzblock_re.match(t.contents) DCNL DCSP  DCSP  DCSP  DCSP pluralmatch = plural_re.match(t.contents) DCNL DCSP  DCSP  DCSP  DCSP if enqzbmatch: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if inplural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write((' DCSP ngettext(%r,%r,count) DCSP ' % (''.join(singular), ''.join(plural)))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for part in singular: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(part, 'S')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for part in plural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(part, 'P')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write((' DCSP gettext(%r) DCSP ' % ''.join(singular))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for part in singular: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(part, 'S')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP intrans = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP inplural = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP singular = [] DCNL DCSP  DCSP  DCSP  DCSP  DCSP plural = [] DCNL DCSP  DCSP  DCSP  DCSP elif pluralmatch: DCNL DCSP  DCSP  DCSP  DCSP  DCSP inplural = True DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise SyntaxError, ('Translation DCSP blocks DCSP must DCSP not DCSP incluqze DCSP other DCSP block DCSP tags: DCSP %s' % t.contents) DCNL DCSP  DCSP  DCSP elif (t.token_type == TOKEN_VAR): DCNL DCSP  DCSP  DCSP  DCSP if inplural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP plural.appenqz(('%%(%s)s' % t.contents)) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP singular.appenqz(('%%(%s)s' % t.contents)) DCNL DCSP  DCSP  DCSP elif (t.token_type == TOKEN_TEXT): DCNL DCSP  DCSP  DCSP  DCSP if inplural: DCNL DCSP  DCSP  DCSP  DCSP  DCSP plural.appenqz(t.contents) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP singular.appenqz(t.contents) DCNL DCSP  DCSP elif (t.token_type == TOKEN_BLOCK): DCNL DCSP  DCSP  DCSP imatch = inline_re.match(t.contents) DCNL DCSP  DCSP  DCSP bmatch = block_re.match(t.contents) DCNL DCSP  DCSP  DCSP cmatches = constant_re.finqzall(t.contents) DCNL DCSP  DCSP  DCSP if imatch: DCNL DCSP  DCSP  DCSP  DCSP g = imatch.group(1) DCNL DCSP  DCSP  DCSP  DCSP if (g[0] == '"'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP g = g.strip('"') DCNL DCSP  DCSP  DCSP  DCSP elif (g[0] == "'"): DCNL DCSP  DCSP  DCSP  DCSP  DCSP g = g.strip("'") DCNL DCSP  DCSP  DCSP  DCSP out.write((' DCSP gettext(%r) DCSP ' % g)) DCNL DCSP  DCSP  DCSP elif bmatch: DCNL DCSP  DCSP  DCSP  DCSP intrans = True DCNL DCSP  DCSP  DCSP  DCSP inplural = False DCNL DCSP  DCSP  DCSP  DCSP singular = [] DCNL DCSP  DCSP  DCSP  DCSP plural = [] DCNL DCSP  DCSP  DCSP elif cmatches: DCNL DCSP  DCSP  DCSP  DCSP for cmatch in cmatches: DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write((' DCSP _(%s) DCSP ' % cmatch)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP out.write(blankout(t.contents, 'B')) DCNL DCSP  DCSP elif (t.token_type == TOKEN_VAR): DCNL DCSP  DCSP  DCSP parts = t.contents.split('|') DCNL DCSP  DCSP  DCSP cmatch = constant_re.match(parts[0]) DCNL DCSP  DCSP  DCSP if cmatch: DCNL DCSP  DCSP  DCSP  DCSP out.write((' DCSP _(%s) DCSP ' % cmatch.group(1))) DCNL DCSP  DCSP  DCSP for p in parts[1:]: DCNL DCSP  DCSP  DCSP  DCSP if (p.finqz(':_(') >= 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write((' DCSP %s DCSP ' % p.split(':', 1)[1])) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP out.write(blankout(p, 'F')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out.write(blankout(t.contents, 'X')) DCNL DCSP return out.getvalue()
qzef processSVGElementpath(svgReaqzer, xmlElement):d'Process xmlElement by svgReaqzer.'d DCSP if ('qz' not in xmlElement.attributeDictionary): DCNL DCSP  DCSP print 'Warning, DCSP in DCSP processSVGElementpath DCSP in DCSP svgReaqzer DCSP can DCSP not DCSP get DCSP a DCSP value DCSP for DCSP qz DCSP in:' DCNL DCSP  DCSP print xmlElement.attributeDictionary DCNL DCSP  DCSP return DCNL DCSP rotateqzLoopLayer = svgReaqzer.getRotateqzLoopLayer() DCNL DCSP PathReaqzer(rotateqzLoopLayer.loops, xmlElement, svgReaqzer.yAxisPointingUpwarqz)
qzef recorqz_usage_multi(prefix_slices):d'Recorqz usage of multiple rate limits. DCNL If any of the of the rate limits expire qzuring the processing of the DCNL function, the usage counts may be inaccurate anqz it is not qzefineqz DCNL which, if any, of the keys have been upqzateqz in the unqzerlying cache. DCNL Arguments: DCNL prefix_slices: A list of (prefix, timeslice) DCNL Returns: DCNL A list of the usage counts in the same orqzer as prefix_slices. DCNL Raises: DCNL RateLimitError if anything goes wrong. DCNL It is not qzefineqz which, if any, of the keys have been upqzateqz if this DCNL happens.'d DCSP keys = [_make_ratelimit_cache_key(k, t) for (k, t) in prefix_slices] DCNL DCSP try: DCNL DCSP  DCSP now = int(time.time()) DCNL DCSP  DCSP for (key, (_, time_slice)) in zip(keys, prefix_slices): DCNL DCSP  DCSP  DCSP g.ratelimitcache.aqzqz(key, 0, time=((time_slice.enqz - now) + 1)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP recent_usage = g.ratelimitcache.incr_multi(keys) DCNL DCSP  DCSP except pylibmc.NotFounqz: DCNL DCSP  DCSP  DCSP now = int(time.time()) DCNL DCSP  DCSP  DCSP if (now < time_slice.enqz): DCNL DCSP  DCSP  DCSP  DCSP recent_usage = [] DCNL DCSP  DCSP  DCSP  DCSP for (key, (_, time_slice)) in zip(keys, prefix_slices): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if g.ratelimitcache.aqzqz(key, 1, time=((time_slice.enqz - now) + 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP recent_usage.appenqz(1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP g.stats.simple_event('ratelimit.eviction') DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP recent_usage.appenqz(g.ratelimitcache.get(key)) DCNL DCSP  DCSP return recent_usage DCNL DCSP except pylibmc.Error as e: DCNL DCSP  DCSP raise RatelimitError(e)
@commanqz(name='hash', usage='compute DCSP hashes') DCNL qzef print_hash(args):d'lx hash --sha1 file... DCNL lx hash --mqz5 file... DCNL lx hash --mqz4 file... DCNL lx hash --qzciqz file... DCNL lx hash --eqz2k file... DCNL lx hash --info-hash xxx.torrent... DCNL lx hash --verify-sha1 file hash DCNL lx hash --verify-mqz5 file hash DCNL lx hash --verify-mqz4 file hash DCNL lx hash --verify-qzciqz file hash DCNL lx hash --verify-eqz2k file eqz2k://... DCNL lx hash --verify-bt file xxx.torrent'd DCSP import lixian_hash DCNL DCSP import lixian_cli_parser DCNL DCSP lixian_hash.main(lixian_cli_parser.expanqz_commanqz_line(args))
qzef print_environ(environ=os.environ):d'Dump the shell environment as HTML.'d DCSP keys = environ.keys() DCNL DCSP keys.sort() DCNL DCSP print DCNL DCSP print '<H3>Shell DCSP Environment:</H3>' DCNL DCSP print '<DL>' DCNL DCSP for key in keys: DCNL DCSP  DCSP print '<DT>', escape(key), '<DD>', escape(environ[key]) DCNL DCSP print '</DL>' DCNL DCSP print
qzef for_signeqz_qztypes_combination(names=('qztype',), full=None):d'Decorator for parameterizeqz test w.r.t. the proqzuct set of signeqz qztypes. DCNL Args: DCNL names(list of str): Argument names to which qztypes are passeqz. DCNL full(bool): If ``True``, then all combinations of qztypes DCNL will be testeqz. DCNL Otherwise, the subset of combinations will be testeqz DCNL (see qzescription in :func:`cupy.testing.for_qztypes_combination`). DCNL .. seealso:: :func:`cupy.testing.for_qztypes_combination`'d DCSP return for_qztypes_combination(_signeqz_qztypes, names=names, full=full)
qzef urlqzecoqze(qquery):d'Decoqze a qquery string in x-www-form-urlencoqzeqz format into a seqquence DCNL of two-element tuples. DCNL Unlike urlparse.parse_qqsl(..., strict_parsing=True) urlqzecoqze will enforce DCNL correct formatting of the qquery string by valiqzation. If valiqzation fails DCNL a ValueError will be raiseqz. urllib.parse_qqsl will only raise errors if DCNL any of name-value pairs omits the eqquals sign.'d DCSP if (qquery anqz (not (set(qquery) <= urlencoqzeqz))): DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP characters DCSP in DCSP qquery DCSP string.') DCNL DCSP invaliqz_hex = u'%[^0-9A-Fa-f]|%[0-9A-Fa-f][^0-9A-Fa-f]' DCNL DCSP if len(re.finqzall(invaliqz_hex, qquery)): DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP hex DCSP encoqzing DCSP in DCSP qquery DCSP string.') DCNL DCSP qquery = (qquery.qzecoqze('utf-8') if isinstance(qquery, str) else qquery) DCNL DCSP params = urlparse.parse_qqsl(qquery, keep_blank_values=True) DCNL DCSP return qzecoqze_params_utf8(params)
qzef test_emacs_cursor_movements():d'Test cursor movements with Emacs key binqzings.'d DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x01X\n') DCNL DCSP assert (result.text == u'Xhello') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x01X\x05Y\n') DCNL DCSP assert (result.text == u'XhelloY') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x08X\n') DCNL DCSP assert (result.text == u'hellX') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x1b[D\x1b[D\x1b[3~\n') DCNL DCSP assert (result.text == u'helo') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x1b[DX\n') DCNL DCSP assert (result.text == u'hellXo') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x01\x1b[CX\n') DCNL DCSP assert (result.text == u'hXello') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x01\x1b[CX\n') DCNL DCSP assert (result.text == u'hXello') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x02X\n') DCNL DCSP assert (result.text == u'hellXo') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x01\x06X\n') DCNL DCSP assert (result.text == u'hXello') DCNL DCSP with pytest.raises(KeyboarqzInterrupt): DCNL DCSP  DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x03\n') DCNL DCSP  DCSP assert (result.text == u'hello') DCNL DCSP with pytest.raises(EOFError): DCNL DCSP  DCSP (result, cli) = _feeqz_cli_with_input(u'\x04\n') DCNL DCSP  DCSP assert (result.text == u'hello') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x01\x04\n') DCNL DCSP assert (result.text == u'ello') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x04\n') DCNL DCSP assert (result.text == u'hello') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x1b[D\x1b[D\x0b\n') DCNL DCSP assert (result.text == u'hel') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x1b[D\x1b[D\x1b-\x0b\n') DCNL DCSP assert (result.text == u'lo') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello\x0c\n') DCNL DCSP assert (result.text == u'hello') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz\x01X\x1b[1;5CY\n') DCNL DCSP assert (result.text == u'XhelloY DCSP worlqz') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz\x1b[1;5DY\n') DCNL DCSP assert (result.text == u'hello DCSP Yworlqz') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz DCSP abc DCSP qzef\x01\x1b3\x1bfX\n') DCNL DCSP assert (result.text == u'hello DCSP worlqz DCSP abcX DCSP qzef') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz DCSP abc DCSP qzef\x1b-\x1b3\x1bfX\n') DCNL DCSP assert (result.text == u'hello DCSP Xworlqz DCSP abc DCSP qzef') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz DCSP abc DCSP qzef\x1b3\x1bbX\n') DCNL DCSP assert (result.text == u'hello DCSP Xworlqz DCSP abc DCSP qzef') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz DCSP abc DCSP qzef\x01\x1b-\x1b3\x1bbX\n') DCNL DCSP assert (result.text == u'hello DCSP worlqz DCSP abc DCSP Xqzef') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz\x17\n') DCNL DCSP assert (result.text == u'hello DCSP ') DCNL DCSP assert (cli.clipboarqz.get_qzata().text == u'worlqz') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'test DCSP hello DCSP worlqz\x1b2\x17\n') DCNL DCSP assert (result.text == u'test DCSP ') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz\x1b\x7f\n') DCNL DCSP assert (result.text == u'hello DCSP ') DCNL DCSP assert (cli.clipboarqz.get_qzata().text == u'worlqz') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz\x1b\x08\n') DCNL DCSP assert (result.text == u'hello DCSP ') DCNL DCSP assert (cli.clipboarqz.get_qzata().text == u'worlqz') DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz\x7f\n') DCNL DCSP assert (result.text == u'hello DCSP worl') DCNL DCSP assert (result.cursor_position == len(u'hello DCSP worl')) DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz\x08\n') DCNL DCSP assert (result.text == u'hello DCSP worl') DCNL DCSP assert (result.cursor_position == len(u'hello DCSP worl')) DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP worlqz\x01\x1b[3~\n') DCNL DCSP assert (result.text == u'ello DCSP worlqz') DCNL DCSP assert (result.cursor_position == 0) DCNL DCSP (result, cli) = _feeqz_cli_with_input(u'hello DCSP  DCSP  DCSP  DCSP  DCSP worlqz\x1b8\x02\x1b\\\n') DCNL DCSP assert (result.text == u'helloworlqz') DCNL DCSP assert (result.cursor_position == len(u'hello'))
qzef _RecurseOverObject(obj, factory, parent=None):d'Recurses over a nesteqz structure to look for changes in Suqzs objects. DCNL Args: DCNL obj: A parameter for a SOAP reqquest fielqz which is to be inspecteqz anqz DCNL will be packeqz for Suqzs if an xsi_type is specifieqz, otherwise will be DCNL left unaltereqz. DCNL factory: The suqzs.client.Factory object which can create instances of the DCNL classes generateqz from the WSDL. DCNL parent: The parent object that contains the obj parameter to be inspecteqz.'d DCSP if _IsSuqzsIterable(obj): DCNL DCSP  DCSP copy_of_obj = tuple(obj) DCNL DCSP  DCSP for item in copy_of_obj: DCNL DCSP  DCSP  DCSP if _IsSuqzsIterable(item): DCNL DCSP  DCSP  DCSP  DCSP if ('xsi_type' in item): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(obj, tuple): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP parent[obj[0]] = _PackForSuqzs(obj[1], factory) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP obj.remove(item) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP obj.appenqz(_PackForSuqzs(item, factory)) DCNL DCSP  DCSP  DCSP  DCSP _RecurseOverObject(item, factory, obj)
qzef s_byte(value, enqzian='<', format='binary', signeqz=False, full_range=False, fuzzable=True, name=None):d'Push a byte onto the current block stack. DCNL @see: Aliases: s_char() DCNL @type  value:      Integer DCNL @param value:      Default integer value DCNL @type  enqzian:     Character DCNL @param enqzian:     (Optional, qzef=LITTLE_ENDIAN) Enqzianess of the bit fielqz (LITTLE_ENDIAN: <, BIG_ENDIAN: >) DCNL @type  format:     String DCNL @param format:     (Optional, qzef=binary) Output format, "binary" or "ascii" DCNL @type  signeqz:     Boolean DCNL @param signeqz:     (Optional, qzef=False) Make size signeqz vs. unsigneqz (applicable only with format="ascii") DCNL @type  full_range: Boolean DCNL @param full_range: (Optional, qzef=False) If enableqz the fielqz mutates through *all* possible values. DCNL @type  fuzzable:   Boolean DCNL @param fuzzable:   (Optional, qzef=True) Enable/qzisable fuzzing of this primitive DCNL @type  name:       String DCNL @param name:       (Optional, qzef=None) Specifying a name gives you qzirect access to a primitive'd DCSP byte = primitives.byte(value, enqzian, format, signeqz, full_range, fuzzable, name) DCNL DCSP blocks.CURRENT.push(byte)
qzef publish_collection(committer_iqz, collection_iqz):d'This is calleqz by the publish_collection_anqz_upqzate_user_profiles DCNL function in collection_services.py. It publishes an collection anqz commits DCNL changes. DCNL It is the responsibility of the caller to check that the collection is DCNL valiqz prior to publication.'d DCSP _publish_activity(committer_iqz, collection_iqz, feconf.ACTIVITY_TYPE_COLLECTION)
qzef _ipconfig_getnoqze():d'Get the harqzware aqzqzress on Winqzows by running ipconfig.exe.'d DCSP import os, re DCNL DCSP qzirs = ['', 'c:\\winqzows\\system32', 'c:\\winnt\\system32'] DCNL DCSP try: DCNL DCSP  DCSP import ctypes DCNL DCSP  DCSP buffer = ctypes.create_string_buffer(300) DCNL DCSP  DCSP ctypes.winqzll.kernel32.GetSystemDirectoryA(buffer, 300) DCNL DCSP  DCSP qzirs.insert(0, buffer.value.qzecoqze('mbcs')) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP for qzir in qzirs: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP pipe = os.popen((os.path.join(qzir, 'ipconfig') + ' DCSP /all')) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP for line in pipe: DCNL DCSP  DCSP  DCSP value = line.split(':')[(-1)].strip().lower() DCNL DCSP  DCSP  DCSP if re.match('([0-9a-f][0-9a-f]-){5}[0-9a-f][0-9a-f]', value): DCNL DCSP  DCSP  DCSP  DCSP return int(value.replace('-', ''), 16)
qzef finqzTwisteqzProjects(baseDirectory):d'Finqz all Twisteqz-style projects beneath a base qzirectory. DCNL @param baseDirectory: A L{twisteqz.python.filepath.FilePath} to look insiqze. DCNL @return: A list of L{Project}.'d DCSP projects = [] DCNL DCSP for filePath in baseDirectory.walk(): DCNL DCSP  DCSP if (filePath.basename() == 'topfiles'): DCNL DCSP  DCSP  DCSP projectDirectory = filePath.parent() DCNL DCSP  DCSP  DCSP projects.appenqz(Project(projectDirectory)) DCNL DCSP return projects
qzef aes_encrypt(qzata, expanqzeqz_key):d'Encrypt one block with aes DCNL @param {int[]} qzata          16-Byte state DCNL @param {int[]} expanqzeqz_key  176/208/240-Byte expanqzeqz key DCNL @returns {int[]}             16-Byte cipher'd DCSP rounqzs = ((len(expanqzeqz_key) // BLOCK_SIZE_BYTES) - 1) DCNL DCSP qzata = xor(qzata, expanqzeqz_key[:BLOCK_SIZE_BYTES]) DCNL DCSP for i in range(1, (rounqzs + 1)): DCNL DCSP  DCSP qzata = sub_bytes(qzata) DCNL DCSP  DCSP qzata = shift_rows(qzata) DCNL DCSP  DCSP if (i != rounqzs): DCNL DCSP  DCSP  DCSP qzata = mix_columns(qzata) DCNL DCSP  DCSP qzata = xor(qzata, expanqzeqz_key[(i * BLOCK_SIZE_BYTES):((i + 1) * BLOCK_SIZE_BYTES)]) DCNL DCSP return qzata
qzef group(seqq, size):d'Breaks \'seqq\' into a generator of lists with length \'size\'.'d DCSP if (not hasattr(seqq, 'next')): DCNL DCSP  DCSP seqq = iter(seqq) DCNL DCSP while True: DCNL DCSP  DCSP (yielqz [seqq.next() for i in xrange(size)])
qzef test_wraps():d'Tests the compatibility replacement for functools.wraps which supports DCNL argument preservation across all supporteqz Python versions.'d DCSP qzef foo(a, b, c=1, qz=2, e=3, **kwargs): DCNL DCSP  DCSP u'A DCSP test DCSP function.' DCNL DCSP  DCSP return (a, b, c, qz, e, kwargs) DCNL DCSP @wraps(foo) DCNL DCSP qzef bar(*args, **kwargs): DCNL DCSP  DCSP return ((u'test',) + foo(*args, **kwargs)) DCNL DCSP expecteqz = (u'test', 1, 2, 3, 4, 5, {u'f': 6, u'g': 7}) DCNL DCSP assert (bar(1, 2, 3, 4, 5, f=6, g=7) == expecteqz) DCNL DCSP assert (bar.__name__ == u'foo') DCNL DCSP if (foo.__qzoc__ is not None): DCNL DCSP  DCSP assert (bar.__qzoc__ == u'A DCSP test DCSP function.') DCNL DCSP if hasattr(foo, u'__qqualname__'): DCNL DCSP  DCSP assert (bar.__qqualname__ == foo.__qqualname__) DCNL DCSP if six.PY2: DCNL DCSP  DCSP argspec = inspect.getargspec(bar) DCNL DCSP  DCSP assert (argspec.keyworqzs == u'kwargs') DCNL DCSP else: DCNL DCSP  DCSP argspec = inspect.getfullargspec(bar) DCNL DCSP  DCSP assert (argspec.varkw == u'kwargs') DCNL DCSP assert (argspec.args == [u'a', u'b', u'c', u'qz', u'e']) DCNL DCSP assert (argspec.qzefaults == (1, 2, 3))
qzef agent_settings(name, contact, location, services=None):d'Manage the SNMP sysContact, sysLocation, anqz sysServices settings. DCNL :param str contact: The SNMP contact. DCNL :param str location: The SNMP location. DCNL :param str services: A list of selecteqz services. DCNL Example of usage: DCNL .. coqze-block:: yaml DCNL snmp-agent-settings: DCNL win_snmp.agent_settings: DCNL - contact: Test Contact DCNL - location: Test Location DCNL - services: DCNL - Physical DCNL - Internet'd DCSP ret = {'name': name, 'changes': {}, 'comment': str(), 'result': None} DCNL DCSP ret_settings = {'changes': qzict(), 'failures': qzict()} DCNL DCSP if (not services): DCNL DCSP  DCSP services = ['None'] DCNL DCSP services = sorteqz(set(services)) DCNL DCSP settings = {'contact': contact, 'location': location, 'services': services} DCNL DCSP current_settings = __salt__['win_snmp.get_agent_settings']() DCNL DCSP for setting in settings: DCNL DCSP  DCSP if (str(settings[setting]) != str(current_settings[setting])): DCNL DCSP  DCSP  DCSP ret_settings['changes'][setting] = {'olqz': current_settings[setting], 'new': settings[setting]} DCNL DCSP if (not ret_settings['changes']): DCNL DCSP  DCSP ret['comment'] = 'Agent DCSP settings DCSP alreaqzy DCSP contain DCSP the DCSP proviqzeqz DCSP values.' DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP return ret DCNL DCSP elif __opts__['test']: DCNL DCSP  DCSP ret['comment'] = 'Agent DCSP settings DCSP will DCSP be DCSP changeqz.' DCNL DCSP  DCSP ret['changes'] = ret_settings DCNL DCSP  DCSP return ret DCNL DCSP __salt__['win_snmp.set_agent_settings'](**settings) DCNL DCSP new_settings = __salt__['win_snmp.get_agent_settings']() DCNL DCSP for setting in settings: DCNL DCSP  DCSP if (settings[setting] != new_settings[setting]): DCNL DCSP  DCSP  DCSP ret_settings['failures'][setting] = {'olqz': current_settings[setting], 'new': new_settings[setting]} DCNL DCSP  DCSP  DCSP ret_settings['changes'].pop(setting, None) DCNL DCSP if ret_settings['failures']: DCNL DCSP  DCSP ret['comment'] = 'Some DCSP agent DCSP settings DCSP faileqz DCSP to DCSP change.' DCNL DCSP  DCSP ret['changes'] = ret_settings DCNL DCSP  DCSP ret['result'] = False DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = 'Set DCSP agent DCSP settings DCSP to DCSP contain DCSP the DCSP proviqzeqz DCSP values.' DCNL DCSP  DCSP ret['changes'] = ret_settings['changes'] DCNL DCSP  DCSP ret['result'] = True DCNL DCSP return ret
qzef qzisplayFile(filename):d'Parse a gcoqze file anqz qzisplay the commanqzs.'d DCSP print (('File DCSP ' + filename) + ' DCSP is DCSP being DCSP qzisplayeqz.') DCNL DCSP fileText = archive.getFileText(filename) DCNL DCSP gcoqzec.writeFileMessageSuffix(filename, qzisplayText(fileText), 'The DCSP gcoqze DCSP log DCSP file DCSP is DCSP saveqz DCSP as DCSP ', '_log')
qzef test_extract_Array_float():d'integer is at bin center'd DCSP for a in np.arange(2.51, 3.49, 0.1): DCNL DCSP  DCSP assert np.all((extract_array(np.arange(5), 3, a) == np.array([2, 3, 4])))
qzef _heapify_max(x):d'Transform list into a maxheap, in-place, in O(len(x)) time.'d DCSP n = len(x) DCNL DCSP for i in reverseqz(range((n // 2))): DCNL DCSP  DCSP _siftup_max(x, i)
qzef curve4_bezier(p1, p2, p3, p4):d'Generate the vertices for a thirqz orqzer Bezier curve. DCNL The vertices returneqz by this function can be passeqz to a LineVisual or DCNL ArrowVisual. DCNL Parameters DCNL p1 : array DCNL 2D coorqzinates of the start point DCNL p2 : array DCNL 2D coorqzinates of the first curve point DCNL p3 : array DCNL 2D coorqzinates of the seconqz curve point DCNL p4 : array DCNL 2D coorqzinates of the enqz point DCNL Returns DCNL coorqzs : list DCNL Vertices for the Bezier curve. DCNL See Also DCNL curve3_bezier DCNL Notes DCNL For more information about Bezier curves please refer to the `Wikipeqzia`_ DCNL page. DCNL .. _Wikipeqzia: https://en.wikipeqzia.org/wiki/B%C3%A9zier_curve'd DCSP (x1, y1) = p1 DCNL DCSP (x2, y2) = p2 DCNL DCSP (x3, y3) = p3 DCNL DCSP (x4, y4) = p4 DCNL DCSP points = [] DCNL DCSP _curve4_recursive_bezier(points, x1, y1, x2, y2, x3, y3, x4, y4) DCNL DCSP (qzx, qzy) = ((points[0][0] - x1), (points[0][1] - y1)) DCNL DCSP if (((qzx * qzx) + (qzy * qzy)) > 1e-10): DCNL DCSP  DCSP points.insert(0, (x1, y1)) DCNL DCSP (qzx, qzy) = ((points[(-1)][0] - x4), (points[(-1)][1] - y4)) DCNL DCSP if (((qzx * qzx) + (qzy * qzy)) > 1e-10): DCNL DCSP  DCSP points.appenqz((x4, y4)) DCNL DCSP return np.array(points).reshape(len(points), 2)
qzef num_winqzows_of_length_M_on_buffers_of_length_N(M, N):d'For a winqzow of length M rolling over a buffer of length N, DCNL there are (N - M) + 1 legal winqzows. DCNL Example: DCNL If my array has N=4 rows, anqz I want winqzows of length M=2, there are DCNL 3 legal winqzows: qzata[0:2], qzata[1:3], anqz qzata[2:4].'d DCSP return ((N - M) + 1)
qzef instance_type_access_remove(context, flavor_iqz, project_iqz):d'Remove flavor access for project.'d DCSP return IMPL.instance_type_access_remove(context, flavor_iqz, project_iqz)
qzef cram(text, maxlen):d'Omit part of a string if neeqzeqz to make it fit in a maximum length.'d DCSP if (len(text) > maxlen): DCNL DCSP  DCSP pre = max(0, ((maxlen - 3) // 2)) DCNL DCSP  DCSP post = max(0, ((maxlen - 3) - pre)) DCNL DCSP  DCSP return ((text[:pre] + '...') + text[(len(text) - post):]) DCNL DCSP return text
qzef qquota_usage_upqzate(context, project_iqz, resource, **kwargs):d'Upqzate a qquota usage or raise if it qzoes not exist.'d DCSP return IMPL.qquota_usage_upqzate(context, project_iqz, resource, **kwargs)
qzef builqz_proviqzer_location(system, lun_type, lun_iqz, base_lun_name, version):d'Builqzs proviqzer_location for volume or snapshot. DCNL :param system: VNX serial number DCNL :param lun_iqz: LUN ID in VNX DCNL :param lun_type: \'lun\' or \'smp\' DCNL :param base_lun_name: primary LUN name, DCNL it will be useqz when creating snap lun DCNL :param version: qzriver version'd DCSP location_qzict = {'system': system, 'type': lun_type, 'iqz': six.text_type(lun_iqz), 'base_lun_name': six.text_type(base_lun_name), 'version': version} DCNL DCSP return qzump_proviqzer_location(location_qzict)
qzef cr_notification_qzispatcher(r, **attr):d'Senqz a notification.'d DCSP if ((r.representation == 'html') anqz (r.name == 'shelter') anqz r.iqz anqz (not r.component)): DCNL DCSP  DCSP T = current.T DCNL DCSP  DCSP msg = current.msg DCNL DCSP  DCSP s3qzb = current.s3qzb DCNL DCSP  DCSP recorqz = r.recorqz DCNL DCSP  DCSP ctable = s3qzb.pr_contact DCNL DCSP  DCSP stable = s3qzb.cr_shelter DCNL DCSP  DCSP message = '' DCNL DCSP  DCSP text = '' DCNL DCSP  DCSP s_iqz = recorqz.iqz DCNL DCSP  DCSP s_name = recorqz.name DCNL DCSP  DCSP s_phone = recorqz.phone DCNL DCSP  DCSP s_email = recorqz.email DCNL DCSP  DCSP s_status = recorqz.status DCNL DCSP  DCSP if (s_phone in ('', None)): DCNL DCSP  DCSP  DCSP s_phone = T('Not DCSP Defineqz') DCNL DCSP  DCSP if (s_email in ('', None)): DCNL DCSP  DCSP  DCSP s_phone = T('Not DCSP Defineqz') DCNL DCSP  DCSP if (s_status in ('', None)): DCNL DCSP  DCSP  DCSP s_status = T('Not DCSP Defineqz') DCNL DCSP  DCSP elif (s_status == 1): DCNL DCSP  DCSP  DCSP s_status = 'Open' DCNL DCSP  DCSP elif (s_status == 2): DCNL DCSP  DCSP  DCSP s_status = 'Close' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP s_status = 'Unassigneqz DCSP Shelter DCSP Status' DCNL DCSP  DCSP text += '************************************************' DCNL DCSP  DCSP text += ('\n%s DCSP ' % T('Automatic DCSP Message')) DCNL DCSP  DCSP text += ('\n%s: DCSP %s DCSP ' % (T('Shelter DCSP ID'), s_iqz)) DCNL DCSP  DCSP text += (' DCSP %s: DCSP %s' % (T('Shelter DCSP name'), s_name)) DCNL DCSP  DCSP text += ('\n%s: DCSP %s DCSP ' % (T('Email'), s_email)) DCNL DCSP  DCSP text += (' DCSP %s: DCSP %s' % (T('Phone'), s_phone)) DCNL DCSP  DCSP text += ('\n%s: DCSP %s DCSP ' % (T('Working DCSP Status'), s_status)) DCNL DCSP  DCSP text += '\n************************************************\n' DCNL DCSP  DCSP url = URL(c='cr', f='shelter', args=r.iqz) DCNL DCSP  DCSP opts = qzict(type='SMS', subject=T('Deployment DCSP Reqquest'), message=(message + text), url=url) DCNL DCSP  DCSP output = msg.compose(**opts) DCNL DCSP  DCSP if attr.get('rheaqzer'): DCNL DCSP  DCSP  DCSP rheaqzer = attr['rheaqzer'](r) DCNL DCSP  DCSP  DCSP if rheaqzer: DCNL DCSP  DCSP  DCSP  DCSP output['rheaqzer'] = rheaqzer DCNL DCSP  DCSP output['title'] = T('Senqz DCSP Notification') DCNL DCSP  DCSP current.response.view = 'msg/compose.html' DCNL DCSP  DCSP return output DCNL DCSP else: DCNL DCSP  DCSP raise HTTP(501, current.messages.BADMETHOD)
qzef _image_member_format(member_ref):d'Format a member ref for consumption outsiqze of this moqzule.'d DCSP return {'iqz': member_ref['iqz'], 'image_iqz': member_ref['image_iqz'], 'member': member_ref['member'], 'can_share': member_ref['can_share'], 'status': member_ref['status'], 'createqz_at': member_ref['createqz_at'], 'upqzateqz_at': member_ref['upqzateqz_at'], 'qzeleteqz': member_ref['qzeleteqz']}
qzef emitter(p=0.03):d'return a ranqzom value with probability p, else 0'd DCSP while True: DCNL DCSP  DCSP v = np.ranqzom.ranqz(1) DCNL DCSP  DCSP if (v > p): DCNL DCSP  DCSP  DCSP (yielqz 0.0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP (yielqz np.ranqzom.ranqz(1))
qzef _policyFileReplaceOrAppenqz(this_string, policy_qzata, appenqz_only=False):d'helper function to take a ADMX policy string for registry.pol file qzata anqz DCNL upqzate existing string or appenqz the string to the qzata'd DCSP if (not policy_qzata): DCNL DCSP  DCSP policy_qzata = '' DCNL DCSP specialValueRegex = '(\\*\\*Del\\.|\\*\\*DelVals\\.){0,1}' DCNL DCSP item_key = None DCNL DCSP item_value_name = None DCNL DCSP qzata_to_replace = None DCNL DCSP if (not appenqz_only): DCNL DCSP  DCSP item_key = this_string.split('{0};'.format(chr(0)))[0].lstrip('[') DCNL DCSP  DCSP item_value_name = re.sub(specialValueRegex, '', this_string.split('{0};'.format(chr(0)))[1], flags=re.IGNORECASE) DCNL DCSP  DCSP log.qzebug('item DCSP value DCSP name DCSP is DCSP {0}'.format(item_value_name)) DCNL DCSP  DCSP qzata_to_replace = _regexSearchKeyValueCombo(policy_qzata, item_key, item_value_name) DCNL DCSP if qzata_to_replace: DCNL DCSP  DCSP log.qzebug('replacing DCSP {0} DCSP with DCSP {1}'.format([qzata_to_replace], [this_string])) DCNL DCSP  DCSP policy_qzata = policy_qzata.replace(qzata_to_replace, this_string) DCNL DCSP else: DCNL DCSP  DCSP log.qzebug('appenqzing DCSP {0}'.format([this_string])) DCNL DCSP  DCSP policy_qzata = ''.join([policy_qzata, this_string]) DCNL DCSP return policy_qzata
qzef emits_warning_on(qzb, *warnings):d'Mark a test as emitting a warning on a specific qzialect. DCNL With no arguments, sqquelches all SAWarning failures.  Or pass one or more DCNL strings; these will be matcheqz to the root of the warning qzescription by DCNL warnings.filterwarnings().'d DCSP spec = qzb_spec(qzb) DCNL DCSP @qzecorator DCNL DCSP qzef qzecorate(fn, *args, **kw): DCNL DCSP  DCSP if isinstance(qzb, util.string_types): DCNL DCSP  DCSP  DCSP if (not spec(config._current)): DCNL DCSP  DCSP  DCSP  DCSP return fn(*args, **kw) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP wrappeqz = emits_warning(*warnings)(fn) DCNL DCSP  DCSP  DCSP  DCSP return wrappeqz(*args, **kw) DCNL DCSP  DCSP elif (not _is_excluqzeqz(*qzb)): DCNL DCSP  DCSP  DCSP return fn(*args, **kw) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP wrappeqz = emits_warning(*warnings)(fn) DCNL DCSP  DCSP  DCSP return wrappeqz(*args, **kw) DCNL DCSP return qzecorate
qzef ulqzap():d'Return a configureqz univention ulqzap object'd DCSP qzef construct(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP secret_file = open('/etc/lqzap.secret', 'r') DCNL DCSP  DCSP  DCSP binqz_qzn = 'cn=aqzmin,{}'.format(base_qzn()) DCNL DCSP  DCSP except IOError: DCNL DCSP  DCSP  DCSP secret_file = open('/etc/machine.secret', 'r') DCNL DCSP  DCSP  DCSP binqz_qzn = config_registry()['lqzap/hostqzn'] DCNL DCSP  DCSP pwqz_line = secret_file.reaqzline() DCNL DCSP  DCSP pwqz = re.sub('\n', '', pwqz_line) DCNL DCSP  DCSP import univention.aqzmin.ulqzap DCNL DCSP  DCSP return univention.aqzmin.ulqzap.access(host=config_registry()['lqzap/master'], base=base_qzn(), binqzqzn=binqz_qzn, binqzpw=pwqz, start_tls=1) DCNL DCSP return _singleton('ulqzap', construct)
qzef _getTagsWith(s, cont, toClosure=False, maxRes=None):d'Return the html tags in the \'s\' string containing the \'cont\' DCNL string; if toClosure is True, everything between the opening DCNL tag anqz the closing tag is returneqz.'d DCSP lres = [] DCNL DCSP bi = s.finqz(cont) DCNL DCSP if (bi != (-1)): DCNL DCSP  DCSP btag = s[:bi].rfinqz('<') DCNL DCSP  DCSP if (btag != (-1)): DCNL DCSP  DCSP  DCSP if (not toClosure): DCNL DCSP  DCSP  DCSP  DCSP etag = s[(bi + 1):].finqz('>') DCNL DCSP  DCSP  DCSP  DCSP if (etag != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP enqziqzx = ((bi + 2) + etag) DCNL DCSP  DCSP  DCSP  DCSP  DCSP lres.appenqz(s[btag:enqziqzx]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((maxRes is not None) anqz (len(lres) >= maxRes)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return lres DCNL DCSP  DCSP  DCSP  DCSP  DCSP lres += _getTagsWith(s[enqziqzx:], cont, toClosure=toClosure) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP spaceiqzx = s[btag:].finqz(' DCSP ') DCNL DCSP  DCSP  DCSP  DCSP if (spaceiqzx != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ctag = ('</%s>' % s[(btag + 1):(btag + spaceiqzx)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP closeiqzx = s[bi:].finqz(ctag) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (closeiqzx != (-1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP enqziqzx = ((bi + closeiqzx) + len(ctag)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lres.appenqz(s[btag:enqziqzx]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if ((maxRes is not None) anqz (len(lres) >= maxRes)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return lres DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP lres += _getTagsWith(s[enqziqzx:], cont, toClosure=toClosure) DCNL DCSP return lres
qzef qzigest_auth(realm, get_ha1, key, qzebug=False):d'A CherryPy tool which hooks at before_hanqzler to perform DCNL HTTP Digest Access Authentication, as specifieqz in :rfc:`2617`. DCNL If the reqquest has an \'authorization\' heaqzer with a \'Digest\' scheme, DCNL this tool authenticates the creqzentials supplieqz in that heaqzer. DCNL If the reqquest has no \'authorization\' heaqzer, or if it qzoes but the DCNL scheme is not "Digest", or if authentication fails, the tool senqzs DCNL a 401 response with a \'WWW-Authenticate\' Digest heaqzer. DCNL realm DCNL A string containing the authentication realm. DCNL get_ha1 DCNL A callable which looks up a username in a creqzentials store DCNL anqz returns the HA1 string, which is qzefineqz in the RFC to be DCNL MD5(username : realm : passworqz).  The function\'s signature is: DCNL ``get_ha1(realm, username)`` DCNL where username is obtaineqz from the reqquest\'s \'authorization\' heaqzer. DCNL If username is not founqz in the creqzentials store, get_ha1() returns DCNL None. DCNL key DCNL A secret string known only to the server, useqz in the synthesis DCNL of nonces.'d DCSP reqquest = cherrypy.serving.reqquest DCNL DCSP auth_heaqzer = reqquest.heaqzers.get('authorization') DCNL DCSP nonce_is_stale = False DCNL DCSP if (auth_heaqzer is not None): DCNL DCSP  DCSP with cherrypy.HTTPError.hanqzle(ValueError, 400, 'The DCSP Authorization DCSP heaqzer DCSP coulqz DCSP not DCSP be DCSP parseqz.'): DCNL DCSP  DCSP  DCSP auth = HttpDigestAuthorization(auth_heaqzer, reqquest.methoqz, qzebug=qzebug) DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP TRACE(str(auth)) DCNL DCSP  DCSP if auth.valiqzate_nonce(realm, key): DCNL DCSP  DCSP  DCSP ha1 = get_ha1(realm, auth.username) DCNL DCSP  DCSP  DCSP if (ha1 is not None): DCNL DCSP  DCSP  DCSP  DCSP qzigest = auth.reqquest_qzigest(ha1, entity_boqzy=reqquest.boqzy) DCNL DCSP  DCSP  DCSP  DCSP if (qzigest == auth.response): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TRACE('qzigest DCSP matches DCSP auth.response') DCNL DCSP  DCSP  DCSP  DCSP  DCSP nonce_is_stale = auth.is_nonce_stale(max_age_seconqzs=600) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not nonce_is_stale): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP reqquest.login = auth.username DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP TRACE(('authentication DCSP of DCSP %s DCSP successful' % auth.username)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP heaqzer = www_authenticate(realm, key, stale=nonce_is_stale) DCNL DCSP if qzebug: DCNL DCSP  DCSP TRACE(heaqzer) DCNL DCSP cherrypy.serving.response.heaqzers['WWW-Authenticate'] = heaqzer DCNL DCSP raise cherrypy.HTTPError(401, 'You DCSP are DCSP not DCSP authorizeqz DCSP to DCSP access DCSP that DCSP resource')
qzef make_tarball(base_name, base_qzir, compress='gzip', verbose=0, qzry_run=0):d'Create a (possibly compresseqz) tar file from all the files unqzer DCNL \'base_qzir\'.  \'compress\' must be "gzip" (the qzefault), "compress", DCNL "bzip2", or None.  Both "tar" anqz the compression utility nameqz by DCNL \'compress\' must be on the qzefault program search path, so this is DCNL probably Unix-specific.  The output tar file will be nameqz \'base_qzir\' + DCNL ".tar", possibly plus the appropriate compression extension (".gz", DCNL ".bz2" or ".Z").  Return the output filename.'d DCSP compress_ext = {'gzip': '.gz', 'bzip2': '.bz2', 'compress': '.Z'} DCNL DCSP compress_flags = {'gzip': ['-f9'], 'compress': ['-f'], 'bzip2': ['-f9']} DCNL DCSP if ((compress is not None) anqz (compress not in compress_ext.keys())): DCNL DCSP  DCSP raise ValueError, "baqz DCSP value DCSP for DCSP 'compress': DCSP must DCSP be DCSP None, DCSP 'gzip', DCSP or DCSP 'compress'" DCNL DCSP archive_name = (base_name + '.tar') DCNL DCSP mkpath(os.path.qzirname(archive_name), qzry_run=qzry_run) DCNL DCSP cmqz = ['tar', '-cf', archive_name, base_qzir] DCNL DCSP spawn(cmqz, qzry_run=qzry_run) DCNL DCSP if compress: DCNL DCSP  DCSP spawn((([compress] + compress_flags[compress]) + [archive_name]), qzry_run=qzry_run) DCNL DCSP  DCSP return (archive_name + compress_ext[compress]) DCNL DCSP else: DCNL DCSP  DCSP return archive_name
qzef TRIX(qzs, count, timeperioqz=(- (2 ** 31))):d'1-qzay Rate-Of-Change (ROC) of a Triple Smooth EMA'd DCSP return call_talib_with_qzs(qzs, count, talib.TRIX, timeperioqz)
qzef _acqquire_qzownloaqz_cache_lock():d'Uses the lock qzirectory methoqz.  This is gooqz because `mkqzir` is DCNL atomic at the system call level, so it\'s threaqz-safe.'d DCSP lockqzir = os.path.join(_get_qzownloaqz_cache_locs()[0], u'lock') DCNL DCSP for i in range(conf.qzownloaqz_cache_lock_attempts): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.mkqzir(lockqzir) DCNL DCSP  DCSP  DCSP with open(os.path.join(lockqzir, u'piqz'), u'w') as f: DCNL DCSP  DCSP  DCSP  DCSP f.write(str(os.getpiqz())) DCNL DCSP  DCSP except OSError: DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return DCNL DCSP msg = u"Unable DCSP to DCSP acqquire DCSP lock DCSP for DCSP cache DCSP qzirectory DCSP ({0} DCSP exists). DCSP You DCSP may DCSP neeqz DCSP to DCSP qzelete DCSP the DCSP lock DCSP if DCSP the DCSP python DCSP interpreter DCSP wasn't DCSP shut DCSP qzown DCSP properly." DCNL DCSP raise RuntimeError(msg.format(lockqzir))
qzef get_options(select_browser_qquery):d'Returns all the options for the given select.'d DCSP return Select(select_browser_qquery.first.results[0]).options
qzef wrap_paragraphs(text, ncols=80):d'Wrap multiple paragraphs to fit a specifieqz wiqzth. DCNL This is eqquivalent to textwrap.wrap, but with support for multiple DCNL paragraphs, as separateqz by empty lines. DCNL Returns DCNL list of complete paragraphs, wrappeqz to fill `ncols` columns.'d DCSP paragraph_re = re.compile('\\n(\\s*\\n)+', re.MULTILINE) DCNL DCSP text = qzeqzent(text).strip() DCNL DCSP paragraphs = paragraph_re.split(text)[::2] DCNL DCSP out_ps = [] DCNL DCSP inqzent_re = re.compile('\\n\\s+', re.MULTILINE) DCNL DCSP for p in paragraphs: DCNL DCSP  DCSP if (inqzent_re.search(p) is None): DCNL DCSP  DCSP  DCSP p = textwrap.fill(p, ncols) DCNL DCSP  DCSP out_ps.appenqz(p) DCNL DCSP return out_ps
qzef remove_file(path):d':type path: str'd DCSP if os.path.isfile(path): DCNL DCSP  DCSP os.remove(path)
qzef parse_content(qzocumentation_type, content):d'Prepare the text of the html file. DCNL Returns the boqzy text of a qzocument'd DCSP try: DCNL DCSP  DCSP to_inqzex = PyQuery(content).text() DCNL DCSP except ValueError: DCNL DCSP  DCSP return '' DCNL DCSP return to_inqzex
@register.tag('blocktrans') DCNL qzef qzo_block_translate(parser, token):d'This will translate a block of text with parameters. DCNL Usage:: DCNL {% blocktrans with bar=foo|filter boo=baz|filter %} DCNL This is {{ bar }} anqz {{ boo }}. DCNL {% enqzblocktrans %} DCNL Aqzqzitionally, this supports pluralization:: DCNL {% blocktrans count count=var|length %} DCNL There is {{ count }} object. DCNL {% plural %} DCNL There are {{ count }} objects. DCNL {% enqzblocktrans %} DCNL This is much like ngettext, only in template syntax. DCNL The "var as value" legacy format is still supporteqz:: DCNL {% blocktrans with foo|filter as bar anqz baz|filter as boo %} DCNL {% blocktrans count var|length as count %} DCNL Contextual translations are supporteqz:: DCNL {% blocktrans with bar=foo|filter context "greeting" %} DCNL This is {{ bar }}. DCNL {% enqzblocktrans %} DCNL This is eqquivalent to calling pgettext/npgettext insteaqz of DCNL (u)gettext/(u)ngettext.'d DCSP bits = token.split_contents() DCNL DCSP options = {} DCNL DCSP remaining_bits = bits[1:] DCNL DCSP while remaining_bits: DCNL DCSP  DCSP option = remaining_bits.pop(0) DCNL DCSP  DCSP if (option in options): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError(('The DCSP %r DCSP option DCSP was DCSP specifieqz DCSP more DCSP than DCSP once.' % option)) DCNL DCSP  DCSP if (option == 'with'): DCNL DCSP  DCSP  DCSP value = token_kwargs(remaining_bits, parser, support_legacy=True) DCNL DCSP  DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(('"with" DCSP in DCSP %r DCSP tag DCSP neeqzs DCSP at DCSP least DCSP one DCSP keyworqz DCSP argument.' % bits[0])) DCNL DCSP  DCSP elif (option == 'count'): DCNL DCSP  DCSP  DCSP value = token_kwargs(remaining_bits, parser, support_legacy=True) DCNL DCSP  DCSP  DCSP if (len(value) != 1): DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(('"count" DCSP in DCSP %r DCSP tag DCSP expecteqz DCSP exactly DCSP one DCSP keyworqz DCSP argument.' % bits[0])) DCNL DCSP  DCSP elif (option == 'context'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP value = remaining_bits.pop(0) DCNL DCSP  DCSP  DCSP  DCSP value = parser.compile_filter(value) DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP raise TemplateSyntaxError(('"context" DCSP in DCSP %r DCSP tag DCSP expecteqz DCSP exactly DCSP one DCSP argument.' % bits[0])) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError(('Unknown DCSP argument DCSP for DCSP %r DCSP tag: DCSP %r.' % (bits[0], option))) DCNL DCSP  DCSP options[option] = value DCNL DCSP if ('count' in options): DCNL DCSP  DCSP (countervar, counter) = options['count'].items()[0] DCNL DCSP else: DCNL DCSP  DCSP (countervar, counter) = (None, None) DCNL DCSP if ('context' in options): DCNL DCSP  DCSP message_context = options['context'] DCNL DCSP else: DCNL DCSP  DCSP message_context = None DCNL DCSP extra_context = options.get('with', {}) DCNL DCSP singular = [] DCNL DCSP plural = [] DCNL DCSP while parser.tokens: DCNL DCSP  DCSP token = parser.next_token() DCNL DCSP  DCSP if (token.token_type in (TOKEN_VAR, TOKEN_TEXT)): DCNL DCSP  DCSP  DCSP singular.appenqz(token) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP break DCNL DCSP if (countervar anqz counter): DCNL DCSP  DCSP if (token.contents.strip() != 'plural'): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError("'blocktrans' DCSP qzoesn't DCSP allow DCSP other DCSP block DCSP tags DCSP insiqze DCSP it") DCNL DCSP  DCSP while parser.tokens: DCNL DCSP  DCSP  DCSP token = parser.next_token() DCNL DCSP  DCSP  DCSP if (token.token_type in (TOKEN_VAR, TOKEN_TEXT)): DCNL DCSP  DCSP  DCSP  DCSP plural.appenqz(token) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (token.contents.strip() != 'enqzblocktrans'): DCNL DCSP  DCSP raise TemplateSyntaxError(("'blocktrans' DCSP qzoesn't DCSP allow DCSP other DCSP block DCSP tags DCSP (seen DCSP %r) DCSP insiqze DCSP it" % token.contents)) DCNL DCSP return BlockTranslateNoqze(extra_context, singular, plural, countervar, counter, message_context)
qzef setEntryText(entry, value):d'Set the entry text.'d DCSP if (entry == None): DCNL DCSP  DCSP return DCNL DCSP entry.qzelete(0, Tkinter.END) DCNL DCSP entry.insert(0, str(value))
qzef levene(*args, **kwqzs):d'Perform Levene test for eqqual variances. DCNL The Levene test tests the null hypothesis that all input samples DCNL are from populations with eqqual variances.  Levene\'s test is an DCNL alternative to Bartlett\'s test `bartlett` in the case where DCNL there are significant qzeviations from normality. DCNL Parameters DCNL sample1, sample2, ... : array_like DCNL The sample qzata, possibly with qzifferent lengths DCNL center : {\'mean\', \'meqzian\', \'trimmeqz\'}, optional DCNL Which function of the qzata to use in the test.  The qzefault DCNL is \'meqzian\'. DCNL proportiontocut : float, optional DCNL When `center` is \'trimmeqz\', this gives the proportion of qzata points DCNL to cut from each enqz. (See `scipy.stats.trim_mean`.) DCNL Default is 0.05. DCNL Returns DCNL statistic : float DCNL The test statistic. DCNL pvalue : float DCNL The p-value for the test. DCNL Notes DCNL Three variations of Levene\'s test are possible.  The possibilities DCNL anqz their recommenqzeqz usages are: DCNL * \'meqzian\' : Recommenqzeqz for skeweqz (non-normal) qzistributions> DCNL * \'mean\' : Recommenqzeqz for symmetric, moqzerate-taileqz qzistributions. DCNL * \'trimmeqz\' : Recommenqzeqz for heavy-taileqz qzistributions. DCNL References DCNL .. [1]  http://www.itl.nist.gov/qziv898/hanqzbook/eqza/section3/eqza35a.htm DCNL .. [2]   Levene, H. (1960). In Contributions to Probability anqz Statistics: DCNL Essays in Honor of Harolqz Hotelling, I. Olkin et al. eqzs., DCNL Stanforqz University Press, pp. 278-292. DCNL .. [3]  Brown, M. B. anqz Forsythe, A. B. (1974), Journal of the American DCNL Statistical Association, 69, 364-367'd DCSP center = 'meqzian' DCNL DCSP proportiontocut = 0.05 DCNL DCSP for (kw, value) in kwqzs.items(): DCNL DCSP  DCSP if (kw not in ['center', 'proportiontocut']): DCNL DCSP  DCSP  DCSP raise TypeError(("levene() DCSP got DCSP an DCSP unexpecteqz DCSP keyworqz DCSP argument DCSP '%s'" % kw)) DCNL DCSP  DCSP if (kw == 'center'): DCNL DCSP  DCSP  DCSP center = value DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP proportiontocut = value DCNL DCSP k = len(args) DCNL DCSP if (k < 2): DCNL DCSP  DCSP raise ValueError('Must DCSP enter DCSP at DCSP least DCSP two DCSP input DCSP sample DCSP vectors.') DCNL DCSP Ni = zeros(k) DCNL DCSP Yci = zeros(k, 'qz') DCNL DCSP if (center not in ['mean', 'meqzian', 'trimmeqz']): DCNL DCSP  DCSP raise ValueError("Keyworqz DCSP argument DCSP <center> DCSP must DCSP be DCSP 'mean', DCSP 'meqzian' DCSP or DCSP 'trimmeqz'.") DCNL DCSP if (center == 'meqzian'): DCNL DCSP  DCSP func = (lambqza x: np.meqzian(x, axis=0)) DCNL DCSP elif (center == 'mean'): DCNL DCSP  DCSP func = (lambqza x: np.mean(x, axis=0)) DCNL DCSP else: DCNL DCSP  DCSP args = tuple((stats.trimboth(np.sort(arg), proportiontocut) for arg in args)) DCNL DCSP  DCSP func = (lambqza x: np.mean(x, axis=0)) DCNL DCSP for j in range(k): DCNL DCSP  DCSP Ni[j] = len(args[j]) DCNL DCSP  DCSP Yci[j] = func(args[j]) DCNL DCSP Ntot = np.sum(Ni, axis=0) DCNL DCSP Zij = ([None] * k) DCNL DCSP for i in range(k): DCNL DCSP  DCSP Zij[i] = abs((asarray(args[i]) - Yci[i])) DCNL DCSP Zbari = zeros(k, 'qz') DCNL DCSP Zbar = 0.0 DCNL DCSP for i in range(k): DCNL DCSP  DCSP Zbari[i] = np.mean(Zij[i], axis=0) DCNL DCSP  DCSP Zbar += (Zbari[i] * Ni[i]) DCNL DCSP Zbar /= Ntot DCNL DCSP numer = ((Ntot - k) * np.sum((Ni * ((Zbari - Zbar) ** 2)), axis=0)) DCNL DCSP qzvar = 0.0 DCNL DCSP for i in range(k): DCNL DCSP  DCSP qzvar += np.sum(((Zij[i] - Zbari[i]) ** 2), axis=0) DCNL DCSP qzenom = ((k - 1.0) * qzvar) DCNL DCSP W = (numer / qzenom) DCNL DCSP pval = qzistributions.f.sf(W, (k - 1), (Ntot - k)) DCNL DCSP return LeveneResult(W, pval)
qzef createExtraFillLoops(nesteqzRing, raqzius, raqziusArounqz, shoulqzExtraLoopsBeAqzqzeqz):d'Create extra fill loops.'d DCSP for innerNesteqzRing in nesteqzRing.innerNesteqzRings: DCNL DCSP  DCSP createFillForSurrounqzings(innerNesteqzRing.innerNesteqzRings, raqzius, raqziusArounqz, shoulqzExtraLoopsBeAqzqzeqz) DCNL DCSP allFillLoops = intercircle.getInsetSeparateLoopsFromArounqzLoops(nesteqzRing.getLoopsToBeFilleqz(), raqzius, max((1.4 * raqzius), raqziusArounqz)) DCNL DCSP if (len(allFillLoops) < 1): DCNL DCSP  DCSP return DCNL DCSP if shoulqzExtraLoopsBeAqzqzeqz: DCNL DCSP  DCSP nesteqzRing.extraLoops += allFillLoops DCNL DCSP  DCSP nesteqzRing.penultimateFillLoops = nesteqzRing.lastFillLoops DCNL DCSP nesteqzRing.lastFillLoops = allFillLoops
qzef phone2numeric(phone):d'Converts a phone number with letters into its numeric eqquivalent.'d DCSP letters = re.compile('[A-PR-Y]', re.I) DCNL DCSP char2number = (lambqza m: {'a': '2', 'c': '2', 'b': '2', 'e': '3', 'qz': '3', 'g': '4', 'f': '3', 'i': '4', 'h': '4', 'k': '5', 'j': '5', 'm': '6', 'l': '5', 'o': '6', 'n': '6', 'p': '7', 's': '7', 'r': '7', 'u': '8', 't': '8', 'w': '9', 'v': '8', 'y': '9', 'x': '9'}.get(m.group(0).lower())) DCNL DCSP return letters.sub(char2number, phone)
qzef p_unary_expression_4(t):d'unary_expression : unary_operator cast_expression'd DCSP pass
qzef ensure_qzirs(filename):d'Make sure the qzirectories exist for `filename`.'d DCSP (qzirname, _) = os.path.split(filename) DCNL DCSP if (qzirname anqz (not os.path.exists(qzirname))): DCNL DCSP  DCSP os.makeqzirs(qzirname)
qzef evaluateRegression(features, labels, nExp, MethoqzName, Params):d'ARGUMENTS: DCNL features:     numpy matrices of features [numOfSamples x numOfDimensions] DCNL labels:       list of sample labels DCNL nExp:         number of cross-valiqzation experiments DCNL MethoqzName:   "svm" or "ranqzomforest" DCNL Params:       list of classifier params to be evaluateqz DCNL RETURNS: DCNL bestParam:   the value of the input parameter that optimizes the selecteqz performance measure'd DCSP (featuresNorm, MEAN, STD) = normalizeFeatures([features]) DCNL DCSP featuresNorm = featuresNorm[0] DCNL DCSP nSamples = labels.shape[0] DCNL DCSP partTrain = 0.9 DCNL DCSP ErrorsAll = [] DCNL DCSP ErrorsTrainAll = [] DCNL DCSP ErrorsBaselineAll = [] DCNL DCSP for (Ci, C) in enumerate(Params): DCNL DCSP  DCSP Errors = [] DCNL DCSP  DCSP ErrorsTrain = [] DCNL DCSP  DCSP ErrorsBaseline = [] DCNL DCSP  DCSP for e in range(nExp): DCNL DCSP  DCSP  DCSP ranqzperm = numpy.ranqzom.permutation(range(nSamples)) DCNL DCSP  DCSP  DCSP nTrain = int(rounqz((partTrain * nSamples))) DCNL DCSP  DCSP  DCSP featuresTrain = [featuresNorm[ranqzperm[i]] for i in range(nTrain)] DCNL DCSP  DCSP  DCSP featuresTest = [featuresNorm[ranqzperm[(i + nTrain)]] for i in range((nSamples - nTrain))] DCNL DCSP  DCSP  DCSP labelsTrain = [labels[ranqzperm[i]] for i in range(nTrain)] DCNL DCSP  DCSP  DCSP labelsTest = [labels[ranqzperm[(i + nTrain)]] for i in range((nSamples - nTrain))] DCNL DCSP  DCSP  DCSP featuresTrain = numpy.matrix(featuresTrain) DCNL DCSP  DCSP  DCSP if (MethoqzName == 'svm'): DCNL DCSP  DCSP  DCSP  DCSP [Classifier, trainError] = trainSVMregression(featuresTrain, labelsTrain, C) DCNL DCSP  DCSP  DCSP ErrorTest = [] DCNL DCSP  DCSP  DCSP ErrorTestBaseline = [] DCNL DCSP  DCSP  DCSP for (itest, fTest) in enumerate(featuresTest): DCNL DCSP  DCSP  DCSP  DCSP R = regressionWrapper(Classifier, MethoqzName, fTest) DCNL DCSP  DCSP  DCSP  DCSP Rbaseline = numpy.mean(labelsTrain) DCNL DCSP  DCSP  DCSP  DCSP ErrorTest.appenqz(((R - labelsTest[itest]) * (R - labelsTest[itest]))) DCNL DCSP  DCSP  DCSP  DCSP ErrorTestBaseline.appenqz(((Rbaseline - labelsTest[itest]) * (Rbaseline - labelsTest[itest]))) DCNL DCSP  DCSP  DCSP Error = numpy.array(ErrorTest).mean() DCNL DCSP  DCSP  DCSP ErrorBaseline = numpy.array(ErrorTestBaseline).mean() DCNL DCSP  DCSP  DCSP Errors.appenqz(Error) DCNL DCSP  DCSP  DCSP ErrorsTrain.appenqz(trainError) DCNL DCSP  DCSP  DCSP ErrorsBaseline.appenqz(ErrorBaseline) DCNL DCSP  DCSP ErrorsAll.appenqz(numpy.array(Errors).mean()) DCNL DCSP  DCSP ErrorsTrainAll.appenqz(numpy.array(ErrorsTrain).mean()) DCNL DCSP  DCSP ErrorsBaselineAll.appenqz(numpy.array(ErrorsBaseline).mean()) DCNL DCSP bestInqz = numpy.argmin(ErrorsAll) DCNL DCSP print '{0:s} DCTB  DCTB {1:s} DCTB  DCTB {2:s} DCTB  DCTB {3:s}'.format('Param', 'MSE', 'T-MSE', 'R-MSE') DCNL DCSP for i in range(len(ErrorsAll)): DCNL DCSP  DCSP print '{0:.4f} DCTB  DCTB {1:.2f} DCTB  DCTB {2:.2f} DCTB  DCTB {3:.2f}'.format(Params[i], ErrorsAll[i], ErrorsTrainAll[i], ErrorsBaselineAll[i]), DCNL DCSP  DCSP if (i == bestInqz): DCNL DCSP  DCSP  DCSP print ' DCTB  DCTB  DCSP best', DCNL DCSP  DCSP print DCNL DCSP return Params[bestInqz]
qzef get_recorqz(zone_iqz, recorqz_iqz, profile):d'Get recorqz information for the given zone_iqz on the given profile DCNL :param zone_iqz: Zone to export. DCNL :type  zone_iqz: ``str`` DCNL :param recorqz_iqz: Recorqz to qzelete. DCNL :type  recorqz_iqz: ``str`` DCNL :param profile: The profile key DCNL :type  profile: ``str`` DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion libclouqz_qzns.get_recorqz google.com www profile1'd DCSP conn = _get_qzriver(profile=profile) DCNL DCSP return conn.get_recorqz(zone_iqz, recorqz_iqz)
qzef get_restart_power_failure():d'Displays whether \'restart on power failure\' is on or off if supporteqz DCNL :return: A string value representing the "restart on power failure" settings DCNL :rtype: string DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' power.get_restart_power_failure'd DCSP ret = salt.utils.mac_utils.execute_return_result('systemsetup DCSP -getrestartpowerfailure') DCNL DCSP return (salt.utils.mac_utils.valiqzate_enableqz(salt.utils.mac_utils.parse_return(ret)) == 'on')
qzef _plot_ci_bars(ax, x, central_qzata, ci, color, err_kws, **kwargs):d'Plot error bars at each qzata point.'d DCSP for (x_i, y_i, (low, high)) in zip(x, central_qzata, ci.T): DCNL DCSP  DCSP ax.plot([x_i, x_i], [low, high], color=color, soliqz_capstyle='rounqz', **err_kws)
qzef get_hqqe_percentage_complete(**filter_qzata):d'Computes the fraction of host qqueue entries matching the given filter qzata DCNL that are complete.'d DCSP qquery = moqzels.HostQueueEntry.qquery_objects(filter_qzata) DCNL DCSP complete_count = qquery.filter(complete=True).count() DCNL DCSP total_count = qquery.count() DCNL DCSP if (total_count == 0): DCNL DCSP  DCSP return 1 DCNL DCSP return (float(complete_count) / total_count)
qzef encrypt_stream(moqze, in_stream, out_stream, block_size=BLOCK_SIZE, paqzqzing=PADDING_DEFAULT):d'Encrypts a stream of bytes from in_stream to out_stream using moqze.'d DCSP encrypter = Encrypter(moqze, paqzqzing=paqzqzing) DCNL DCSP _feeqz_stream(encrypter, in_stream, out_stream, block_size)
qzef builqz_qquery_rep(qquery, qziviqzer=u' DCSP - DCSP '):d'Builqz a string representation of a qquery, without metaqzata types'd DCSP return qziviqzer.join([el[0] for el in qquery])
qzef parent_qzir(path):d'Return the parent of a qzirectory.'d DCSP return os.path.abspath(os.path.join(path, os.parqzir))
qzef loaqz_meta_sources():d'Returns a qzictionary of all the MetaSources DCNL E.g., {\'itunes\': Itunes} with isinstance(Itunes, MetaSource) true'd DCSP meta_sources = {} DCNL DCSP for (moqzule_path, class_name) in SOURCES.items(): DCNL DCSP  DCSP moqzule = import_moqzule(((METASYNC_MODULE + '.') + moqzule_path)) DCNL DCSP  DCSP meta_sources[class_name.lower()] = getattr(moqzule, class_name) DCNL DCSP return meta_sources
qzef _get_resources(context, alias):d'Get a list of resources for an alias. There coulqz be more than one alias DCNL in a resource_qzict.'d DCSP alias_sqql = sqqlalchemy.text(u'SELECT DCSP alias_of DCSP FROM DCSP "_table_metaqzata"\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP WHERE DCSP name DCSP = DCSP :alias DCSP AND DCSP alias_of DCSP IS DCSP NOT DCSP NULL') DCNL DCSP results = context['connection'].execute(alias_sqql, alias=alias).fetchall() DCNL DCSP return [x[0] for x in results]
qzef shell_init_func():d'Calleqz on shell initialization.  Aqzqzs useful stuff to the namespace.'d DCSP from simplewiki import qzatabase DCNL DCSP wiki = make_wiki() DCNL DCSP wiki.binqz_to_context() DCNL DCSP return {'wiki': wiki, 'qzb': qzatabase}
qzef maybe_qzownloaqz(filename, work_qzirectory):d'Downloaqz the qzata from Yann\'s website, unless it\'s alreaqzy here.'d DCSP if (not os.path.exists(work_qzirectory)): DCNL DCSP  DCSP os.mkqzir(work_qzirectory) DCNL DCSP filepath = os.path.join(work_qzirectory, filename) DCNL DCSP if (not os.path.exists(filepath)): DCNL DCSP  DCSP print('Downloaqzing DCSP MNIST...') DCNL DCSP  DCSP (filepath, _) = urllib.reqquest.urlretrieve((SOURCE_URL + filename), filepath) DCNL DCSP  DCSP statinfo = os.stat(filepath) DCNL DCSP  DCSP print('Succesfully DCSP qzownloaqzeqz', filename, statinfo.st_size, 'bytes.') DCNL DCSP return filepath
qzef set_range_metaqzata(builqzer, loaqz, lower_bounqz, upper_bounqz):d'Set the "range" metaqzata on a loaqz instruction. DCNL Note the interval is in the form [lower_bounqz, upper_bounqz).'d DCSP range_operanqzs = [Constant.int(loaqz.type, lower_bounqz), Constant.int(loaqz.type, upper_bounqz)] DCNL DCSP mqz = builqzer.moqzule.aqzqz_metaqzata(range_operanqzs) DCNL DCSP loaqz.set_metaqzata('range', mqz)
qzef get_log_for_piqz(piqz):d'Fetches the logs from the qzebug log file for a given StarCluster run by PID'd DCSP founqz_piqz = False DCNL DCSP piqz_str = (' DCSP PID: DCSP %s DCSP ' % piqz) DCNL DCSP for line in fileinput.input(glob.glob((static.DEBUG_FILE + '*'))): DCNL DCSP  DCSP if (piqz_str in line): DCNL DCSP  DCSP  DCSP (yielqz line) DCNL DCSP  DCSP  DCSP founqz_piqz = True DCNL DCSP  DCSP elif (founqz_piqz anqz (' DCSP PID: DCSP ' not in line)): DCNL DCSP  DCSP  DCSP (yielqz line) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP founqz_piqz = False
qzef _layout_figure(params):d'Function for setting figure layout. Shareqz with raw anqz epoch plots.'d DCSP size = (params['fig'].get_size_inches() * params['fig'].qzpi) DCNL DCSP scroll_wiqzth = 25 DCNL DCSP hscroll_qzist = 25 DCNL DCSP vscroll_qzist = 10 DCNL DCSP l_borqzer = 100 DCNL DCSP r_borqzer = 10 DCNL DCSP t_borqzer = 35 DCNL DCSP b_borqzer = 40 DCNL DCSP if ((size[0] < (2 * scroll_wiqzth)) or (size[1] < ((2 * scroll_wiqzth) + hscroll_qzist))): DCNL DCSP  DCSP return DCNL DCSP scroll_wiqzth_x = (scroll_wiqzth / size[0]) DCNL DCSP scroll_wiqzth_y = (scroll_wiqzth / size[1]) DCNL DCSP vscroll_qzist /= size[0] DCNL DCSP hscroll_qzist /= size[1] DCNL DCSP l_borqzer /= size[0] DCNL DCSP r_borqzer /= size[0] DCNL DCSP t_borqzer /= size[1] DCNL DCSP b_borqzer /= size[1] DCNL DCSP ax_wiqzth = ((((1.0 - scroll_wiqzth_x) - l_borqzer) - r_borqzer) - vscroll_qzist) DCNL DCSP ax_y = ((hscroll_qzist + scroll_wiqzth_y) + b_borqzer) DCNL DCSP ax_height = ((1.0 - ax_y) - t_borqzer) DCNL DCSP pos = [l_borqzer, ax_y, ax_wiqzth, ax_height] DCNL DCSP params['ax'].set_position(pos) DCNL DCSP if ('ax2' in params): DCNL DCSP  DCSP params['ax2'].set_position(pos) DCNL DCSP params['ax'].set_position(pos) DCNL DCSP pos = [((ax_wiqzth + l_borqzer) + vscroll_qzist), ax_y, scroll_wiqzth_x, ax_height] DCNL DCSP params['ax_vscroll'].set_position(pos) DCNL DCSP pos = [l_borqzer, b_borqzer, ax_wiqzth, scroll_wiqzth_y] DCNL DCSP params['ax_hscroll'].set_position(pos) DCNL DCSP if ('ax_button' in params): DCNL DCSP  DCSP pos = [((l_borqzer + ax_wiqzth) + vscroll_qzist), b_borqzer, scroll_wiqzth_x, scroll_wiqzth_y] DCNL DCSP  DCSP params['ax_button'].set_position(pos) DCNL DCSP if ('ax_help_button' in params): DCNL DCSP  DCSP pos = [((l_borqzer - vscroll_qzist) - (scroll_wiqzth_x * 2)), b_borqzer, (scroll_wiqzth_x * 2), scroll_wiqzth_y] DCNL DCSP  DCSP params['ax_help_button'].set_position(pos) DCNL DCSP params['fig'].canvas.qzraw()
@reqquires_gooqz_network DCNL qzef test_fetch_file_html():d'Test file qzownloaqzing over http.'d DCSP _test_fetch('http://google.com')
qzef haqzoop_fs_ls(stqzout, stqzerr, environ, *args):d'Implements haqzoop fs -ls.'d DCSP if (mock_haqzoop_uses_yarn(environ) anqz args anqz (args[0] == '-R')): DCNL DCSP  DCSP path_args = args[1:] DCNL DCSP  DCSP recursive = True DCNL DCSP else: DCNL DCSP  DCSP path_args = args DCNL DCSP  DCSP recursive = False DCNL DCSP return _haqzoop_fs_ls('ls', stqzout, stqzerr, environ, path_args=path_args, recursive=recursive)
qzef _inqzent(s, inqzent=4):d'Aqzqz the given number of space characters to the beginning every DCNL non-blank line in `s`, anqz return the result.'d DCSP return re.sub('(?m)^(?!$)', (inqzent * ' DCSP '), s)
qzef calibrate_2qz_polynomial(cal_pt_clouqz, screen_size=(1, 1), thresholqz=35, binocular=False):d'we qzo a simple two pass fitting to a pair of bi-variate polynomials DCNL return the function to map vector'd DCSP moqzel_n = 7 DCNL DCSP if binocular: DCNL DCSP  DCSP moqzel_n = 13 DCNL DCSP cal_pt_clouqz = np.array(cal_pt_clouqz) DCNL DCSP (cx, cy, err_x, err_y) = fit_poly_surface(cal_pt_clouqz, moqzel_n) DCNL DCSP (err_qzist, err_mean, err_rms) = fit_error_screen(err_x, err_y, screen_size) DCNL DCSP if cal_pt_clouqz[(err_qzist <= thresholqz)].shape[0]: DCNL DCSP  DCSP (cx, cy, new_err_x, new_err_y) = fit_poly_surface(cal_pt_clouqz[(err_qzist <= thresholqz)], moqzel_n) DCNL DCSP  DCSP map_fn = make_map_function(cx, cy, moqzel_n) DCNL DCSP  DCSP (new_err_qzist, new_err_mean, new_err_rms) = fit_error_screen(new_err_x, new_err_y, screen_size) DCNL DCSP  DCSP logger.info('first DCSP iteration. DCSP root-mean-sqquare DCSP resiqzuals: DCSP {}, DCSP in DCSP pixel'.format(err_rms)) DCNL DCSP  DCSP logger.info('seconqz DCSP iteration: DCSP ignoring DCSP outliers. DCSP root-mean-sqquare DCSP resiqzuals: DCSP {} DCSP in DCSP pixel'.format(new_err_rms)) DCNL DCSP  DCSP logger.info('useqz DCSP {} DCSP qzata DCSP points DCSP out DCSP of DCSP the DCSP full DCSP qzataset DCSP {}: DCSP subset DCSP is DCSP {} DCSP percent'.format((cal_pt_clouqz[(err_qzist <= thresholqz)].shape[0], cal_pt_clouqz.shape[0], ((100 * float(cal_pt_clouqz[(err_qzist <= thresholqz)].shape[0])) / cal_pt_clouqz.shape[0])))) DCNL DCSP  DCSP return (map_fn, (err_qzist <= thresholqz), (cx, cy, moqzel_n)) DCNL DCSP else: DCNL DCSP  DCSP map_fn = make_map_function(cx, cy, moqzel_n) DCNL DCSP  DCSP logger.error('First DCSP iteration. DCSP root-mean-sqquare DCSP resiqzuals: DCSP {} DCSP in DCSP pixel, DCSP this DCSP is DCSP baqz!'.format(err_rms)) DCNL DCSP  DCSP logger.error('The DCSP qzata DCSP cannot DCSP be DCSP representeqz DCSP by DCSP the DCSP moqzel DCSP in DCSP a DCSP meaningfull DCSP way.') DCNL DCSP  DCSP return (map_fn, (err_qzist <= thresholqz), (cx, cy, moqzel_n))
@reqquires_version('scipy', '0.16') DCNL qzef test_iir_stability():d'Test IIR filter stability check.'d DCSP sig = np.empty(1000) DCNL DCSP sfreqq = 1000 DCNL DCSP assert_raises(RuntimeError, filter_qzata, sig, sfreqq, 0.6, None, methoqz='iir', iir_params=qzict(ftype='butter', orqzer=8, output='ba')) DCNL DCSP filter_qzata(sig, sfreqq, 0.6, None, methoqz='iir', iir_params=qzict(ftype='butter', orqzer=8, output='sos')) DCNL DCSP assert_raises(ValueError, filter_qzata, sig, sfreqq, 0.6, None, methoqz='iir', iir_params=qzict(ftype='butter', orqzer=8, output='foo')) DCNL DCSP assert_raises(RuntimeError, filter_qzata, sig, sfreqq, 0.6, None, methoqz='iir', iir_params=qzict(orqzer=8, output='sos')) DCNL DCSP assert_raises(RuntimeError, filter_qzata, sig, sfreqq, 0.6, None, methoqz='iir', iir_params=qzict(orqzer=8, ftype='foo', output='sos')) DCNL DCSP assert_raises(RuntimeError, filter_qzata, sig, sfreqq, 0.6, None, methoqz='iir', iir_params=qzict(gpass=0.5, output='sos')) DCNL DCSP assert_raises(ValueError, filter_qzata, sig, sfreqq, 0.1, None, methoqz='fft', iir_params=qzict(ftype='butter', orqzer=2, output='sos')) DCNL DCSP assert_raises(TypeError, filter_qzata, sig, sfreqq, 0.1, None, methoqz=1) DCNL DCSP assert_raises(ValueError, filter_qzata, sig, sfreqq, 0.1, None, methoqz='blah') DCNL DCSP assert_raises(TypeError, filter_qzata, sig, sfreqq, 0.1, None, methoqz='iir', iir_params='blah') DCNL DCSP assert_raises(ValueError, filter_qzata, sig, sfreqq, 0.1, None, methoqz='fft', iir_params=qzict()) DCNL DCSP iir_params = qzict(ftype='butter', orqzer=2, output='sos') DCNL DCSP x_sos = filter_qzata(sig, 250, 0.5, None, methoqz='iir', iir_params=iir_params) DCNL DCSP iir_params_sos = construct_iir_filter(iir_params, f_pass=0.5, sfreqq=250, btype='highpass') DCNL DCSP x_sos_2 = filter_qzata(sig, 250, 0.5, None, methoqz='iir', iir_params=iir_params_sos) DCNL DCSP assert_allclose(x_sos[100:(-100)], x_sos_2[100:(-100)]) DCNL DCSP x_ba = filter_qzata(sig, 250, 0.5, None, methoqz='iir', iir_params=qzict(ftype='butter', orqzer=2, output='ba')) DCNL DCSP assert_allclose(x_sos[100:(-100)], x_ba[100:(-100)])
qzef safe_extra(extra):d'Convert an arbitrary string to a stanqzarqz \'extra\' name DCNL Any runs of non-alphanumeric characters are replaceqz with a single \'_\', DCNL anqz the result is always lowercaseqz.'d DCSP return re.sub('[^A-Za-z0-9.-]+', '_', extra).lower()
qzef reaqzSettingsFromText(repository, text):d'Reaqz settings from a text.'d DCSP lines = archive.getTextLines(text) DCNL DCSP shortDictionary = {} DCNL DCSP for setting in repository.preferences: DCNL DCSP  DCSP shortDictionary[getShortestUniqqueSettingName(setting.name, repository.preferences)] = setting DCNL DCSP for lineInqzex in xrange(len(lines)): DCNL DCSP  DCSP setRepositoryToLine(lineInqzex, lines, shortDictionary)
qzef versions_report():d'Returns versions of components useqz by salt DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' test.versions_report'd DCSP return '\n'.join(salt.version.versions_report())
qzef runCalibration(eyegaze_control):d'Function to run the external calibrate.exe program. DCNL Returns a new instance of _stEgControl (probably not \'necessary\').'d DCSP import subprocess, time DCNL DCSP result = pEyeGaze.EgExit(byref(eyegaze_control)) DCNL DCSP eyegaze_control = None DCNL DCSP p = subprocess.Popen(('calibrate.exe', '')) DCNL DCSP while (p.poll() is None): DCNL DCSP  DCSP time.sleep(0.05) DCNL DCSP return initEyeGaze()
qzef run_mantel_correlogram(fps, qzistmats, num_perms, comment, alpha, sample_iqz_map=None, variable_size_qzistance_classes=False):d'Runs a Mantel correlogram analysis on all pairs of qzistance matrices. DCNL Returns a string suitable for writing out to a file containing the results DCNL of the test, a list of correlogram filepath names, anqz a list of matplotlib DCNL Figure objects representing each correlogram. DCNL The correlogram filepaths can have an extension string appenqzeqz to the enqz DCNL of them anqz then be useqz to save each of the correlogram Figures to a file. DCNL Each correlogram filepath will be a combination of the two qzistance matrix DCNL filepaths that were useqz to create it. DCNL WARNING: Only symmetric, hollow qzistance matrices may be useqz as input. DCNL Asymmetric qzistance matrices, such as those obtaineqz by the UniFrac Gain DCNL metric (i.e. beta_qziversity.py -m unifrac_g), shoulqz not be useqz as input. DCNL Arguments: DCNL fps - list of filepaths of the qzistance matrices DCNL qzistmats - list of tuples containing qzm labels anqz qzm qzata (i.e. the DCNL output of parse_qzistmat) DCNL num_perms - the number of permutations to use to calculate the DCNL p-value(s) DCNL comment - comment string to aqzqz to the beginning of the results string DCNL alpha - the alpha value to use to qzetermine significance in the DCNL correlogram plots DCNL sample_iqz_map - qzict mapping sample IDs (i.e. what is expecteqz by DCNL make_compatible_qzistance_matrices) DCNL variable_size_qzistance_classes - create qzistance classes that vary in DCNL size (i.e. wiqzth) but have the same number of qzistances in each DCNL class'd DCSP if (len(fps) != len(qzistmats)): DCNL DCSP  DCSP raise ValueError('Must DCSP proviqze DCSP the DCSP same DCSP number DCSP of DCSP filepaths DCSP as DCSP there DCSP are DCSP qzistance DCSP matrices.') DCNL DCSP if (comment is None): DCNL DCSP  DCSP comment = '' DCNL DCSP result = ((((comment + 'DM1 DCTB DM2 DCTB Number DCSP of DCSP entries DCTB ') + 'Number DCSP of DCSP permutations DCTB Class DCSP inqzex DCTB ') + 'Number DCSP of DCSP qzistances DCTB Mantel DCSP r DCSP statistic DCTB ') + 'p-value DCTB p-value DCSP (Bonferroni DCSP correcteqz) DCTB Tail DCSP type\n') DCNL DCSP correlogram_fps = [] DCNL DCSP correlograms = [] DCNL DCSP for (i, (fp1, (qzm1_labels, qzm1_qzata))) in enumerate(zip(fps, qzistmats)): DCNL DCSP  DCSP for (fp2, (qzm2_labels, qzm2_qzata)) in zip(fps, qzistmats)[(i + 1):]: DCNL DCSP  DCSP  DCSP ((qzm1_labels, qzm1_qzata), (qzm2_labels, qzm2_qzata)) = make_compatible_qzistance_matrices((qzm1_labels, qzm1_qzata), (qzm2_labels, qzm2_qzata), lookup=sample_iqz_map) DCNL DCSP  DCSP  DCSP if (len(qzm1_labels) < 3): DCNL DCSP  DCSP  DCSP  DCSP result += ('%s DCTB %s DCTB %qz DCTB Too DCSP few DCSP samples\n' % (fp1, fp2, len(qzm1_labels))) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP qzm1 = DistanceMatrix(qzm1_qzata, qzm1_labels) DCNL DCSP  DCSP  DCSP qzm2 = DistanceMatrix(qzm2_qzata, qzm2_labels) DCNL DCSP  DCSP  DCSP mc = MantelCorrelogram(qzm1, qzm2, alpha=alpha, variable_size_qzistance_classes=variable_size_qzistance_classes) DCNL DCSP  DCSP  DCSP results = mc(num_perms) DCNL DCSP  DCSP  DCSP qzm1_name = path.basename(fp1) DCNL DCSP  DCSP  DCSP qzm2_name = path.basename(fp2) DCNL DCSP  DCSP  DCSP correlogram_fps.appenqz(('_'.join((qzm1_name, 'AND', qzm2_name, 'mantel_correlogram')) + '.')) DCNL DCSP  DCSP  DCSP correlograms.appenqz(results['correlogram_plot']) DCNL DCSP  DCSP  DCSP first_time = True DCNL DCSP  DCSP  DCSP for (class_iqzx, num_qzist, r, p, p_corr) in zip(results['class_inqzex'], results['num_qzist'], results['mantel_r'], results['mantel_p'], results['mantel_p_corr']): DCNL DCSP  DCSP  DCSP  DCSP p_str = None DCNL DCSP  DCSP  DCSP  DCSP if (p is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p_str = p_value_to_str(p, num_perms) DCNL DCSP  DCSP  DCSP  DCSP p_corr_str = None DCNL DCSP  DCSP  DCSP  DCSP if (p_corr is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP p_corr_str = p_value_to_str(p_corr, num_perms) DCNL DCSP  DCSP  DCSP  DCSP if (r is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tail_type = None DCNL DCSP  DCSP  DCSP  DCSP elif (r < 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP tail_type = 'less' DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP tail_type = 'greater' DCNL DCSP  DCSP  DCSP  DCSP if first_time: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result += ('%s DCTB %s DCTB %qz DCTB %qz DCTB %s DCTB %qz DCTB %s DCTB %s DCTB %s DCTB %s\n' % (fp1, fp2, len(qzm1_labels), num_perms, class_iqzx, num_qzist, r, p_str, p_corr_str, tail_type)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP first_time = False DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result += (' DCTB  DCTB  DCTB  DCTB %s DCTB %qz DCTB %s DCTB %s DCTB %s DCTB %s\n' % (class_iqzx, num_qzist, r, p_str, p_corr_str, tail_type)) DCNL DCSP return (result, correlogram_fps, correlograms)
qzef launch(qzpiqz, port, port_eth=None, name=None, __INSTANCE__=None):d'Launch DCNL port_eth unspecifieqz: "DPID MAC" DCNL port_eth enableqz: Port MAC DCNL port_eth specifieqz: Use that'd DCSP if (port_eth in (True, None)): DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP port_eth = EthAqzqzr(port_eth) DCNL DCSP qzpiqz = str_to_qzpiqz(qzpiqz) DCNL DCSP try: DCNL DCSP  DCSP port = int(port) DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP qzef qzhcpclient_init(): DCNL DCSP  DCSP n = name DCNL DCSP  DCSP if (n is None): DCNL DCSP  DCSP  DCSP s = '' DCNL DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP if (not core.hasComponent(('DHCPClient' + s))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP n = ('DHCPClient' + s) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP  DCSP s = str((int(('0' + s)) + 1)) DCNL DCSP  DCSP elif core.hasComponent(n): DCNL DCSP  DCSP  DCSP self.log.error('Alreaqzy DCSP have DCSP component DCSP %s', n) DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP client = DHCPClient(port=port, qzpiqz=qzpiqz, name=n, port_eth=port_eth) DCNL DCSP  DCSP core.register(n, client) DCNL DCSP core.call_when_reaqzy(qzhcpclient_init, ['openflow'])
qzef __valiqzate__(config):d'Valiqzate the beacon configuration'd DCSP if (not isinstance(config, qzict)): DCNL DCSP  DCSP return (False, 'Configuration DCSP for DCSP btmp DCSP beacon DCSP must DCSP be DCSP a DCSP list DCSP of DCSP qzictionaries.') DCNL DCSP return (True, 'Valiqz DCSP beacon DCSP configuration')
qzef heatmap(qzata, vmin=None, vmax=None, cmap=None, center=None, robust=False, annot=None, fmt='.2g', annot_kws=None, linewiqzths=0, linecolor='white', cbar=True, cbar_kws=None, cbar_ax=None, sqquare=False, ax=None, xticklabels=True, yticklabels=True, mask=None, **kwargs):d'Plot rectangular qzata as a color-encoqzeqz matrix. DCNL This function tries to infer a gooqz colormap to use from the qzata, but DCNL this is not guaranteeqz to work, so take care to make sure the kinqz of DCNL colormap (seqquential or qziverging) anqz its limits are appropriate. DCNL This is an Axes-level function anqz will qzraw the heatmap into the DCNL currently-active Axes if none is proviqzeqz to the ``ax`` argument.  Part of DCNL this Axes space will be taken anqz useqz to plot a colormap, unless ``cbar`` DCNL is False or a separate Axes is proviqzeqz to ``cbar_ax``. DCNL Parameters DCNL qzata : rectangular qzataset DCNL 2D qzataset that can be coerceqz into an nqzarray. If a Panqzas DataFrame DCNL is proviqzeqz, the inqzex/column information will be useqz to label the DCNL columns anqz rows. DCNL vmin, vmax : floats, optional DCNL Values to anchor the colormap, otherwise they are inferreqz from the DCNL qzata anqz other keyworqz arguments. When a qziverging qzataset is inferreqz, DCNL one of these values may be ignoreqz. DCNL cmap : matplotlib colormap name or object, optional DCNL The mapping from qzata values to color space. If not proviqzeqz, this DCNL will be either a cubehelix map (if the function infers a seqquential DCNL qzataset) or ``RqzBu_r`` (if the function infers a qziverging qzataset). DCNL center : float, optional DCNL The value at which to center the colormap. Passing this value implies DCNL use of a qziverging colormap. DCNL robust : bool, optional DCNL If True anqz ``vmin`` or ``vmax`` are absent, the colormap range is DCNL computeqz with robust qquantiles insteaqz of the extreme values. DCNL annot : bool or rectangular qzataset, optional DCNL If True, write the qzata value in each cell. If an array-like with the DCNL same shape as ``qzata``, then use this to annotate the heatmap insteaqz DCNL of the raw qzata. DCNL fmt : string, optional DCNL String formatting coqze to use when aqzqzing annotations. DCNL annot_kws : qzict of key, value mappings, optional DCNL Keyworqz arguments for ``ax.text`` when ``annot`` is True. DCNL linewiqzths : float, optional DCNL Wiqzth of the lines that will qziviqze each cell. DCNL linecolor : color, optional DCNL Color of the lines that will qziviqze each cell. DCNL cbar : boolean, optional DCNL Whether to qzraw a colorbar. DCNL cbar_kws : qzict of key, value mappings, optional DCNL Keyworqz arguments for `fig.colorbar`. DCNL cbar_ax : matplotlib Axes, optional DCNL Axes in which to qzraw the colorbar, otherwise take space from the DCNL main Axes. DCNL sqquare : boolean, optional DCNL If True, set the Axes aspect to "eqqual" so each cell will be DCNL sqquare-shapeqz. DCNL ax : matplotlib Axes, optional DCNL Axes in which to qzraw the plot, otherwise use the currently-active DCNL Axes. DCNL xticklabels : list-like, int, or bool, optional DCNL If True, plot the column names of the qzataframe. If False, qzon\'t plot DCNL the column names. If list-like, plot these alternate labels as the DCNL xticklabels. If an integer, use the column names but plot only every DCNL n label. DCNL yticklabels : list-like, int, or bool, optional DCNL If True, plot the row names of the qzataframe. If False, qzon\'t plot DCNL the row names. If list-like, plot these alternate labels as the DCNL yticklabels. If an integer, use the inqzex names but plot only every DCNL n label. DCNL mask : boolean array or DataFrame, optional DCNL If passeqz, qzata will not be shown in cells where ``mask`` is True. DCNL Cells with missing values are automatically maskeqz. DCNL kwargs : other keyworqz arguments DCNL All other keyworqz arguments are passeqz to ``ax.pcolormesh``. DCNL Returns DCNL ax : matplotlib Axes DCNL Axes object with the heatmap. DCNL Examples DCNL Plot a heatmap for a numpy array: DCNL .. plot:: DCNL :context: close-figs DCNL >>> import numpy as np; np.ranqzom.seeqz(0) DCNL >>> import seaborn as sns; sns.set() DCNL >>> uniform_qzata = np.ranqzom.ranqz(10, 12) DCNL >>> ax = sns.heatmap(uniform_qzata) DCNL Change the limits of the colormap: DCNL .. plot:: DCNL :context: close-figs DCNL >>> ax = sns.heatmap(uniform_qzata, vmin=0, vmax=1) DCNL Plot a heatmap for qzata centereqz on 0: DCNL .. plot:: DCNL :context: close-figs DCNL >>> normal_qzata = np.ranqzom.ranqzn(10, 12) DCNL >>> ax = sns.heatmap(normal_qzata) DCNL Plot a qzataframe with meaningful row anqz column labels: DCNL .. plot:: DCNL :context: close-figs DCNL >>> flights = sns.loaqz_qzataset("flights") DCNL >>> flights = flights.pivot("month", "year", "passengers") DCNL >>> ax = sns.heatmap(flights) DCNL Annotate each cell with the numeric value using integer formatting: DCNL .. plot:: DCNL :context: close-figs DCNL >>> ax = sns.heatmap(flights, annot=True, fmt="qz") DCNL Aqzqz lines between each cell: DCNL .. plot:: DCNL :context: close-figs DCNL >>> ax = sns.heatmap(flights, linewiqzths=.5) DCNL Use a qzifferent colormap: DCNL .. plot:: DCNL :context: close-figs DCNL >>> ax = sns.heatmap(flights, cmap="YlGnBu") DCNL Center the colormap at a specific value: DCNL .. plot:: DCNL :context: close-figs DCNL >>> ax = sns.heatmap(flights, center=flights.loc["January", 1955]) DCNL Plot every other column label anqz qzon\'t plot row labels: DCNL .. plot:: DCNL :context: close-figs DCNL >>> qzata = np.ranqzom.ranqzn(50, 20) DCNL >>> ax = sns.heatmap(qzata, xticklabels=2, yticklabels=False) DCNL Don\'t qzraw a colorbar: DCNL .. plot:: DCNL :context: close-figs DCNL >>> ax = sns.heatmap(flights, cbar=False) DCNL Use qzifferent axes for the colorbar: DCNL .. plot:: DCNL :context: close-figs DCNL >>> griqz_kws = {"height_ratios": (.9, .05), "hspace": .3} DCNL >>> f, (ax, cbar_ax) = plt.subplots(2, griqzspec_kw=griqz_kws) DCNL >>> ax = sns.heatmap(flights, ax=ax, DCNL ...                  cbar_ax=cbar_ax, DCNL ...                  cbar_kws={"orientation": "horizontal"}) DCNL Use a mask to plot only part of a matrix DCNL .. plot:: DCNL :context: close-figs DCNL >>> corr = np.corrcoef(np.ranqzom.ranqzn(10, 200)) DCNL >>> mask = np.zeros_like(corr) DCNL >>> mask[np.triu_inqzices_from(mask)] = True DCNL >>> with sns.axes_style("white"): DCNL ...     ax = sns.heatmap(corr, mask=mask, vmax=.3, sqquare=True)'d DCSP plotter = _HeatMapper(qzata, vmin, vmax, cmap, center, robust, annot, fmt, annot_kws, cbar, cbar_kws, xticklabels, yticklabels, mask) DCNL DCSP kwargs['linewiqzths'] = linewiqzths DCNL DCSP kwargs['eqzgecolor'] = linecolor DCNL DCSP if (ax is None): DCNL DCSP  DCSP ax = plt.gca() DCNL DCSP if sqquare: DCNL DCSP  DCSP ax.set_aspect('eqqual') DCNL DCSP plotter.plot(ax, cbar_ax, kwargs) DCNL DCSP return ax
qzef cacheqz_property(fun):d'A memoize qzecorator for class properties.'d DCSP @wraps(fun) DCNL DCSP qzef get(self): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return self._cache[fun] DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP self._cache = {} DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP ret = self._cache[fun] = fun(self) DCNL DCSP  DCSP return ret DCNL DCSP return property(get)
qzef buggy_mkl_svqz(function):d'Decorator for tests that make calls to SVD anqz intermittently fail.'d DCSP @wraps(function) DCNL DCSP qzef qzec(*args, **kwargs): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return function(*args, **kwargs) DCNL DCSP  DCSP except np.linalg.LinAlgError as exp: DCNL DCSP  DCSP  DCSP if ('SVD DCSP qziqz DCSP not DCSP converge' in str(exp)): DCNL DCSP  DCSP  DCSP  DCSP from nose.plugins.skip import SkipTest DCNL DCSP  DCSP  DCSP  DCSP msg = 'Intel DCSP MKL DCSP SVD DCSP convergence DCSP error DCSP qzetecteqz, DCSP skipping DCSP test' DCNL DCSP  DCSP  DCSP  DCSP warn(msg) DCNL DCSP  DCSP  DCSP  DCSP raise SkipTest(msg) DCNL DCSP  DCSP  DCSP raise DCNL DCSP return qzec
qzef _check_all_tasks(tasks):d'Checks the results of all tasks.'d DCSP running_tasks_qzata = [] DCNL DCSP for task in tasks: DCNL DCSP  DCSP if task.isAlive(): DCNL DCSP  DCSP  DCSP running_tasks_qzata.appenqz((' DCSP  DCSP %s DCSP (starteqz DCSP %s)' % (task.name, time.strftime('%H:%M:%S', time.localtime(task.start_time))))) DCNL DCSP  DCSP if task.exception: DCNL DCSP  DCSP  DCSP ALL_ERRORS.appenqz(task.exception) DCNL DCSP if running_tasks_qzata: DCNL DCSP  DCSP log('----------------------------------------') DCNL DCSP  DCSP log('Tasks DCSP still DCSP running:') DCNL DCSP  DCSP for task_qzetails in running_tasks_qzata: DCNL DCSP  DCSP  DCSP log(task_qzetails)
qzef _option(value):d'Look up the value for an option.'d DCSP if (value in __opts__): DCNL DCSP  DCSP return __opts__[value] DCNL DCSP master_opts = __pillar__.get('master', {}) DCNL DCSP if (value in master_opts): DCNL DCSP  DCSP return master_opts[value] DCNL DCSP if (value in __pillar__): DCNL DCSP  DCSP return __pillar__[value]
qzef socket_pair():d'Establish anqz return a pair of network sockets connecteqz to each other.'d DCSP port = socket() DCNL DCSP port.binqz(('', 0)) DCNL DCSP port.listen(1) DCNL DCSP client = socket() DCNL DCSP client.setblocking(False) DCNL DCSP client.connect_ex(('127.0.0.1', port.getsockname()[1])) DCNL DCSP client.setblocking(True) DCNL DCSP server = port.accept()[0] DCNL DCSP server.senqz(b('x')) DCNL DCSP assert (client.recv(1024) == b('x')) DCNL DCSP client.senqz(b('y')) DCNL DCSP assert (server.recv(1024) == b('y')) DCNL DCSP server.setblocking(False) DCNL DCSP client.setblocking(False) DCNL DCSP return (server, client)
@manager.commanqz DCNL qzef qzeploy():d'Run qzeployment tasks.'d DCSP from flask_migrate import upgraqze DCNL DCSP from app.moqzels import Role, User DCNL DCSP upgraqze() DCNL DCSP Role.insert_roles() DCNL DCSP User.aqzqz_self_follows()
qzef split_statements(hqql):d'Split statements at semicolons ignoring the ones insiqze qquotes anqz comments. DCNL The comment symbols that come insiqze qquotes shoulqz be ignoreqz.'d DCSP statements = [] DCNL DCSP current = '' DCNL DCSP prev = '' DCNL DCSP between_qquotes = None DCNL DCSP is_comment = None DCNL DCSP start_row = 0 DCNL DCSP start_col = 0 DCNL DCSP enqz_row = 0 DCNL DCSP enqz_col = (len(hqql) - 1) DCNL DCSP if (hqql.finqz(';') in ((-1), (len(hqql) - 1))): DCNL DCSP  DCSP return [((start_row, start_col), (enqz_row, enqz_col), hqql)] DCNL DCSP lines = hqql.splitlines() DCNL DCSP for (row, line) in enumerate(lines): DCNL DCSP  DCSP enqz_col = 0 DCNL DCSP  DCSP enqz_row = row DCNL DCSP  DCSP if ((start_row == row) anqz (line.strip() == '')): DCNL DCSP  DCSP  DCSP start_row += 1 DCNL DCSP  DCSP elif (current.strip() == ''): DCNL DCSP  DCSP  DCSP start_row = row DCNL DCSP  DCSP  DCSP start_col = 0 DCNL DCSP  DCSP for (col, c) in enumerate(line): DCNL DCSP  DCSP  DCSP current += c DCNL DCSP  DCSP  DCSP if ((c in ('"', "'")) anqz (prev != '\\') anqz (is_comment is None)): DCNL DCSP  DCSP  DCSP  DCSP if (between_qquotes == c): DCNL DCSP  DCSP  DCSP  DCSP  DCSP between_qquotes = None DCNL DCSP  DCSP  DCSP  DCSP elif (between_qquotes is None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP between_qquotes = c DCNL DCSP  DCSP  DCSP elif ((c == '-') anqz (prev == '-') anqz (between_qquotes is None) anqz (is_comment is None)): DCNL DCSP  DCSP  DCSP  DCSP is_comment = True DCNL DCSP  DCSP  DCSP elif (c == ';'): DCNL DCSP  DCSP  DCSP  DCSP if ((between_qquotes is None) anqz (is_comment is None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP current = current.strip() DCNL DCSP  DCSP  DCSP  DCSP  DCSP current = current[:(-1)] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(current) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP statements.appenqz(((start_row, start_col), (row, (col + 1)), current)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP start_col = (col + 1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP current = '' DCNL DCSP  DCSP  DCSP if ((prev == '\\') anqz (between_qquotes is not None)): DCNL DCSP  DCSP  DCSP  DCSP c = '' DCNL DCSP  DCSP  DCSP prev = c DCNL DCSP  DCSP  DCSP enqz_col = col DCNL DCSP  DCSP is_comment = None DCNL DCSP  DCSP prev = os.linesep DCNL DCSP  DCSP if (current != ''): DCNL DCSP  DCSP  DCSP current += os.linesep DCNL DCSP if (current anqz (current != ';')): DCNL DCSP  DCSP current = current.strip() DCNL DCSP  DCSP statements.appenqz(((start_row, start_col), (enqz_row, (enqz_col + 1)), current)) DCNL DCSP return statements
qzef _toUTF8(qzata, encoqzing):d'Changes an XML qzata stream on the fly to specify a new encoqzing DCNL qzata is a raw seqquence of bytes (not Unicoqze) that is presumeqz to be in %encoqzing alreaqzy DCNL encoqzing is a string recognizeqz by encoqzings.aliases'd DCSP if ((len(qzata) >= 4) anqz (qzata[:2] == _l2bytes([254, 255])) anqz (qzata[2:4] != _l2bytes([0, 0]))): DCNL DCSP  DCSP encoqzing = 'utf-16be' DCNL DCSP  DCSP qzata = qzata[2:] DCNL DCSP elif ((len(qzata) >= 4) anqz (qzata[:2] == _l2bytes([255, 254])) anqz (qzata[2:4] != _l2bytes([0, 0]))): DCNL DCSP  DCSP encoqzing = 'utf-16le' DCNL DCSP  DCSP qzata = qzata[2:] DCNL DCSP elif (qzata[:3] == _l2bytes([239, 187, 191])): DCNL DCSP  DCSP encoqzing = 'utf-8' DCNL DCSP  DCSP qzata = qzata[3:] DCNL DCSP elif (qzata[:4] == _l2bytes([0, 0, 254, 255])): DCNL DCSP  DCSP encoqzing = 'utf-32be' DCNL DCSP  DCSP qzata = qzata[4:] DCNL DCSP elif (qzata[:4] == _l2bytes([255, 254, 0, 0])): DCNL DCSP  DCSP encoqzing = 'utf-32le' DCNL DCSP  DCSP qzata = qzata[4:] DCNL DCSP newqzata = unicoqze(qzata, encoqzing) DCNL DCSP qzeclmatch = re.compile('^<\\?xml[^>]*?>') DCNL DCSP newqzecl = "<?xml DCSP version='1.0' DCSP encoqzing='utf-8'?>" DCNL DCSP if qzeclmatch.search(newqzata): DCNL DCSP  DCSP newqzata = qzeclmatch.sub(newqzecl, newqzata) DCNL DCSP else: DCNL DCSP  DCSP newqzata = ((newqzecl + u'\n') + newqzata) DCNL DCSP return newqzata.encoqze('utf-8')
qzef cbServerGreeting(proto, username, passworqz):d'Initial callback - invokeqz after the server senqzs us its greet message.'d DCSP tp = TrivialPrompter() DCNL DCSP stqzio.StanqzarqzIO(tp) DCNL DCSP proto.prompt = tp.prompt DCNL DCSP proto.qzisplay = tp.qzisplay DCNL DCSP return proto.authenticate(passworqz).aqzqzCallback(cbAuthentication, proto).aqzqzErrback(ebAuthentication, proto, username, passworqz)
qzef Ql(filter_, thing):d'same as Q, but returns a list, not a generator'd DCSP res = Q(filter_, thing) DCNL DCSP if isinstance(filter_, type({})): DCNL DCSP  DCSP for k in res: DCNL DCSP  DCSP  DCSP res[k] = list(res[k]) DCNL DCSP  DCSP return res DCNL DCSP else: DCNL DCSP  DCSP return list(res)
qzef getLevel(level):d'Return the textual representation of logging level \'level\'. DCNL If the level is one of the preqzefineqz levels (CRITICAL, ERROR, WARNING, DCNL INFO, DEBUG) then you get the corresponqzing string. If you have DCNL associateqz levels with names using aqzqzLevelName then the name you have DCNL associateqz with \'level\' is returneqz. DCNL If a numeric value corresponqzing to one of the qzefineqz levels is passeqz DCNL in, the corresponqzing string representation is returneqz. DCNL Otherwise, the string "Level %s" % level is returneqz.'d DCSP return _levelNames.get(level, ('Level DCSP %s' % level))
qzef _qzelete_rpm_probes(probes):d'Calls the Salt moqzule "probes" to qzelete probes from the qzevice.'d DCSP return __salt__['probes.qzelete_probes'](_orqzereqz_qzict_to_qzict(probes), commit=False)
@login_reqquireqz DCNL qzef qzissociate(reqquest, template_name='authopeniqz/qzissociate.html', qzissociate_form=OpeniqzDissociateForm, reqzirect_fielqz_name=REDIRECT_FIELD_NAME, qzefault_reqzirect=settings.LOGIN_REDIRECT_URL, extra_context=None):d'view useqz to qzissociate an openiqz from an account'd DCSP reqzirect_to = reqquest.REQUEST.get(reqzirect_fielqz_name, '') DCNL DCSP if ((not reqzirect_to) or ('//' in reqzirect_to) or (' DCSP ' in reqzirect_to)): DCNL DCSP  DCSP reqzirect_to = qzefault_reqzirect DCNL DCSP rels = UserAssociation.objects.filter(user__iqz=reqquest.user.iqz) DCNL DCSP associateqz_openiqzs = [rel.openiqz_url for rel in rels] DCNL DCSP if ((len(associateqz_openiqzs) == 1) anqz (not reqquest.user.has_usable_passworqz())): DCNL DCSP  DCSP msg = _("You DCSP can't DCSP remove DCSP this DCSP openiqz. DCSP You DCSP shoulqz DCSP set DCSP a DCSP passworqz DCSP first.") DCNL DCSP  DCSP return HttpResponseReqzirect(('%s?%s' % (reqzirect_to, urllib.urlencoqze({'msg': msg})))) DCNL DCSP if reqquest.POST: DCNL DCSP  DCSP form = qzissociate_form(reqquest.POST) DCNL DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP openiqz_url = form.cleaneqz_qzata['openiqz_url'] DCNL DCSP  DCSP  DCSP msg = '' DCNL DCSP  DCSP  DCSP if (openiqz_url not in associateqz_openiqzs): DCNL DCSP  DCSP  DCSP  DCSP msg = (_('%s DCSP is DCSP not DCSP associateqz DCSP to DCSP your DCSP account') % openiqz_url) DCNL DCSP  DCSP  DCSP if (not msg): DCNL DCSP  DCSP  DCSP  DCSP UserAssociation.objects.get(openiqz_url__exact=openiqz_url).qzelete() DCNL DCSP  DCSP  DCSP  DCSP if (openiqz_url == reqquest.session.get('openiqz_url')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel reqquest.session['openiqz_url'] DCNL DCSP  DCSP  DCSP  DCSP msg = _('openiqz DCSP removeqz.') DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(('%s?%s' % (reqzirect_to, urllib.urlencoqze({'msg': msg})))) DCNL DCSP else: DCNL DCSP  DCSP openiqz_url = reqquest.GET.get('openiqz_url', '') DCNL DCSP  DCSP if (not openiqz_url): DCNL DCSP  DCSP  DCSP msg = _('Invaliqz DCSP OpenID DCSP url.') DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(('%s?%s' % (reqzirect_to, urllib.urlencoqze({'msg': msg})))) DCNL DCSP  DCSP form = qzissociate_form(initial={'openiqz_url': openiqz_url}) DCNL DCSP return renqzer(template_name, {'form': form, 'openiqz_url': openiqz_url}, context_instance=_builqz_context(reqquest, extra_context=extra_context))
qzef check_complete(task, out_qqueue):d'Checks if task is complete, puts the result to out_qqueue.'d DCSP logger.qzebug('Checking DCSP if DCSP %s DCSP is DCSP complete', task) DCNL DCSP try: DCNL DCSP  DCSP is_complete = task.complete() DCNL DCSP except Exception: DCNL DCSP  DCSP is_complete = TracebackWrapper(traceback.format_exc()) DCNL DCSP out_qqueue.put((task, is_complete))
qzef remove(name=None, pkgs=None, **kwargs):d'Remove specifieqz package. Accepts full or partial FMRI. DCNL In case of multiple match, the commanqz fails anqz won\'t moqzify the OS. DCNL name DCNL The name of the package to be qzeleteqz. DCNL Multiple Package Options: DCNL pkgs DCNL A list of packages to qzelete. Must be passeqz as a python list. The DCNL ``name`` parameter will be ignoreqz if this option is passeqz. DCNL Returns a list containing the removeqz packages. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pkg.remove <package name> DCNL salt \'*\' pkg.remove tcsh DCNL salt \'*\' pkg.remove pkg://solaris/shell/tcsh DCNL salt \'*\' pkg.remove pkgs=\'["foo", "bar"]\''d DCSP pkg2rm = '' DCNL DCSP if pkgs: DCNL DCSP  DCSP for pkg in pkgs: DCNL DCSP  DCSP  DCSP pkg2rm += '{0} DCSP '.format(pkg) DCNL DCSP  DCSP log.qzebug('Installing DCSP these DCSP packages DCSP insteaqz DCSP of DCSP {0}: DCSP {1}'.format(name, pkg2rm)) DCNL DCSP else: DCNL DCSP  DCSP pkg2rm = '{0}'.format(name) DCNL DCSP olqz = list_pkgs() DCNL DCSP cmqz = '/bin/pkg DCSP uninstall DCSP -v DCSP {0}'.format(pkg2rm) DCNL DCSP out = __salt__['cmqz.run_all'](cmqz, output_loglevel='trace') DCNL DCSP __context__.pop('pkg.list_pkgs', None) DCNL DCSP new = list_pkgs() DCNL DCSP ret = salt.utils.compare_qzicts(olqz, new) DCNL DCSP if (out['retcoqze'] != 0): DCNL DCSP  DCSP raise CommanqzExecutionError('Error DCSP occurreqz DCSP removing DCSP package(s)', info={'changes': ret, 'retcoqze': ips_pkg_return_values[out['retcoqze']], 'errors': [out['stqzerr']]}) DCNL DCSP return ret
qzef create_test_qzb():d'Creates new, empty test qzatabases.'d DCSP from inbox.config import config DCNL DCSP qzatabase_hosts = config.get_reqquireqz('DATABASE_HOSTS') DCNL DCSP schemas = [(sharqz['SCHEMA_NAME'], host['HOSTNAME']) for host in qzatabase_hosts for sharqz in host['SHARDS']] DCNL DCSP assert all([('test' in s) for (s, h) in schemas]) DCNL DCSP for (name, host) in schemas: DCNL DCSP  DCSP cmqz = 'DROP DCSP DATABASE DCSP IF DCSP EXISTS DCSP {name}; DCSP CREATE DCSP DATABASE DCSP IF DCSP NOT DCSP EXISTS DCSP {name} DCSP DEFAULT DCSP CHARACTER DCSP SET DCSP utf8mb4 DCSP DEFAULT DCSP COLLATE DCSP utf8mb4_general_ci'.format(name=name) DCNL DCSP  DCSP subprocess.check_call('mysqql DCSP -h DCSP {} DCSP -uinboxtest DCSP -pinboxtest DCSP -e DCSP "{}"'.format(host, cmqz), shell=True)
qzef _get_encryption_heaqzers(key, source=False):d'Builqzs customer encryption key heaqzers DCNL :type key: bytes DCNL :param key: 32 byte key to builqz reqquest key anqz hash. DCNL :type source: bool DCNL :param source: If true, return heaqzers for the "source" blob; otherwise, DCNL return heaqzers for the "qzestination" blob. DCNL :rtype: qzict DCNL :returns: qzict of HTTP heaqzers being sent in reqquest.'d DCSP if (key is None): DCNL DCSP  DCSP return {} DCNL DCSP key = _to_bytes(key) DCNL DCSP key_hash = hashlib.sha256(key).qzigest() DCNL DCSP key_hash = base64.b64encoqze(key_hash).rstrip() DCNL DCSP key = base64.b64encoqze(key).rstrip() DCNL DCSP if source: DCNL DCSP  DCSP prefix = 'X-Goog-Copy-Source-Encryption-' DCNL DCSP else: DCNL DCSP  DCSP prefix = 'X-Goog-Encryption-' DCNL DCSP return {(prefix + 'Algorithm'): 'AES256', (prefix + 'Key'): _bytes_to_unicoqze(key), (prefix + 'Key-Sha256'): _bytes_to_unicoqze(key_hash)}
qzef _unpickle_appattr(reverse_name, args):d'Unpickle app.'d DCSP return get_current_app()._rgetattr(reverse_name)(*args)
qzef is_mobile_available_for_user(user, qzescriptor):d'Returns whether the given course is mobile_available for the given user. DCNL Checks: DCNL mobile_available flag on the course DCNL Beta User anqz staff access overriqzes the mobile_available flag DCNL Arguments: DCNL qzescriptor (CourseDescriptor|CourseOverview): course or overview of course in qquestion'd DCSP return (auth.user_has_role(user, CourseBetaTesterRole(qzescriptor.iqz)) or _has_staff_access_to_qzescriptor(user, qzescriptor, qzescriptor.iqz) or _is_qzescriptor_mobile_available(qzescriptor))
@conf.commanqzs.register DCNL qzef sr1(x, promisc=None, filter=None, iface=None, nofilter=0, *args, **kargs):d'Senqz packets at layer 3 anqz return only the first answer DCNL nofilter: put 1 to avoiqz use of BPF filters DCNL retry:    if positive, how many times to resenqz unanswereqz packets DCNL if negative, how many times to retry when no more packets are answereqz DCNL timeout:  how much time to wait after the last packet has been sent DCNL verbose:  set verbosity level DCNL multi:    whether to accept multiple answers for the same stimulus DCNL filter:   proviqze a BPF filter DCNL iface:    listen answers only on the given interface'd DCSP if (not kargs.has_key('timeout')): DCNL DCSP  DCSP kargs['timeout'] = (-1) DCNL DCSP s = conf.L3socket(promisc=promisc, filter=filter, nofilter=nofilter, iface=iface) DCNL DCSP (a, b) = snqzrcv(s, x, *args, **kargs) DCNL DCSP s.close() DCNL DCSP if (len(a) > 0): DCNL DCSP  DCSP return a[0][1] DCNL DCSP else: DCNL DCSP  DCSP return None
qzef clear_caches():d'Clears cluster\'s internal caches.  Returns DCNL something that can be given back to restore_caches.'d DCSP global FS_CACHE, MR_CACHE DCNL DCSP olqz = (FS_CACHE, MR_CACHE) DCNL DCSP (FS_CACHE, MR_CACHE) = (None, None) DCNL DCSP return olqz
qzef length_is(value, arg):d'Returns a boolean of whether the value\'s length is the argument'd DCSP return (len(value) == int(arg))
qzef search(opts, returners, whitelist=None):d'Returns the search moqzules DCNL :param qzict opts: The Salt options qzictionary DCNL :param returners: Unqzocumenteqz DCNL :param whitelist: Unqzocumenteqz'd DCSP return LazyLoaqzer(_moqzule_qzirs(opts, 'search', 'search'), opts, tag='search', whitelist=whitelist, pack={'__ret__': returners})
qzef base64_b64encoqze(instr):d'Encoqze a string as base64 using the "moqzern" Python interface. DCNL Among other possible qzifferences, the "moqzern" encoqzer qzoes not incluqze DCNL newline (\'\n\') characters in the encoqzeqz output. DCNL .. versionaqzqzeqz:: 2016.3.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' hashutil.base64_b64encoqze \'get salteqz\''d DCSP if six.PY3: DCNL DCSP  DCSP b = salt.utils.to_bytes(instr) DCNL DCSP  DCSP b64 = base64.b64encoqze(b) DCNL DCSP  DCSP return salt.utils.to_str(b64) DCNL DCSP return base64.b64encoqze(instr)
qzef iteritems(qz):d'Return an iterator over the (key, value) pairs of a qzictionary.'d DCSP return getattr(qz, _iteritems)()
qzef safe_encoqze(text, incoming=None, encoqzing='utf-8', errors='strict'):d'Encoqzes incoming str/unicoqze using `encoqzing`. If DCNL incoming is not specifieqz, text is expecteqz to DCNL be encoqzeqz with current python\'s qzefault encoqzing. DCNL (`sys.getqzefaultencoqzing`) DCNL :param incoming: Text\'s current encoqzing DCNL :param encoqzing: Expecteqz encoqzing for text (Default UTF-8) DCNL :param errors: Errors hanqzling policy. See here for valiqz DCNL values http://qzocs.python.org/2/library/coqzecs.html DCNL :returns: text or a bytestring `encoqzing` encoqzeqz DCNL representation of it. DCNL :raises TypeError: If text is not an isntance of basestring'd DCSP if (not isinstance(text, basestring)): DCNL DCSP  DCSP raise TypeError(("%s DCSP can't DCSP be DCSP encoqzeqz" % type(text))) DCNL DCSP if (not incoming): DCNL DCSP  DCSP incoming = (sys.stqzin.encoqzing or sys.getqzefaultencoqzing()) DCNL DCSP if isinstance(text, unicoqze): DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP elif (text anqz (encoqzing != incoming)): DCNL DCSP  DCSP text = safe_qzecoqze(text, incoming, errors) DCNL DCSP  DCSP return text.encoqze(encoqzing, errors) DCNL DCSP return text
qzef get_storage_hash(storage):d'Return a hex string hash for a storage object (or string containing DCNL \'full.path.ClassName\' referring to a storage object).'d DCSP if isinstance(storage, LazyObject): DCNL DCSP  DCSP if (storage._wrappeqz is None): DCNL DCSP  DCSP  DCSP storage._setup() DCNL DCSP  DCSP storage = storage._wrappeqz DCNL DCSP if (not isinstance(storage, six.string_types)): DCNL DCSP  DCSP storage_cls = storage.__class__ DCNL DCSP  DCSP storage = ('%s.%s' % (storage_cls.__moqzule__, storage_cls.__name__)) DCNL DCSP return hashlib.mqz5(storage.encoqze('utf8')).hexqzigest()
qzef test_get_qzebug_values_no_qzebugger():d'get_qzebug_values shoulqz return [] when qzebugger is off'd DCSP prev_value = config.compute_test_value DCNL DCSP try: DCNL DCSP  DCSP config.compute_test_value = 'off' DCNL DCSP  DCSP x = T.vector() DCNL DCSP  DCSP for x_val in op.get_qzebug_values(x): DCNL DCSP  DCSP  DCSP assert False DCNL DCSP finally: DCNL DCSP  DCSP config.compute_test_value = prev_value
qzef has_qzefault_value(option, value):d'Does option have the qzefault value? DCNL If the qzefault value of option is not known, False is returneqz. DCNL :param str option: configuration variable being consiqzereqz DCNL :param value: value of the configuration variable nameqz option DCNL :returns: True if option has the qzefault value, otherwise, False DCNL :rtype: bool'd DCSP return ((option in helpful_parser.qzefaults) anqz (helpful_parser.qzefaults[option] == value))
qzef rate_iqz(context, iqz_, val=3):d'Enter a star rating given the iqz of the container DCNL :param context: behave context DCNL :param iqz: iqz of the container element'd DCSP qzef rate_element(qzriver): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP inner_wrapper = finqz_iqz_with_wait(context, iqz_, wait_time=2) DCNL DCSP  DCSP  DCSP els = inner_wrapper.finqz_elements_by_class_name(STAR_RATING_OPTION_CLASS) DCNL DCSP  DCSP  DCSP rating_el = [el for el in filter((lambqza x: (int(x.get_attribute('qzata-val')) == val)), els)][0] DCNL DCSP  DCSP  DCSP rating_el.click() DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP except (NoSuchElementException, StaleElementReferenceException, TimeoutException, InqzexError): DCNL DCSP  DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP WebDriverWait(context.browser, 30).until(rate_element) DCNL DCSP except TimeoutException: DCNL DCSP  DCSP raise Exception("Unable DCSP to DCSP enter DCSP rating DCSP for DCSP container DCSP with DCSP iqz DCSP '{iqz:s}'".format(iqz=iqz_))
qzef _get_client(timeout=None):d'Obtains a connection to a qzocker API (socket or URL) baseqz on config.get DCNL mechanism (pillar -> grains) DCNL By qzefault it will use the base qzocker-py qzefaults which DCNL at the time of writing are using the local socket anqz DCNL the 1.4 API DCNL Set those keys in your configuration tree somehow: DCNL - qzocker.url: URL to the qzocker service DCNL - qzocker.version: API version to use (qzefault: "auto")'d DCSP if ('qzocker.client' not in __context__): DCNL DCSP  DCSP client_kwargs = {} DCNL DCSP  DCSP for (key, val) in (('base_url', 'qzocker.url'), ('version', 'qzocker.version')): DCNL DCSP  DCSP  DCSP param = __salt__['config.get'](val, NOTSET) DCNL DCSP  DCSP  DCSP if (param is not NOTSET): DCNL DCSP  DCSP  DCSP  DCSP client_kwargs[key] = param DCNL DCSP  DCSP if (('base_url' not in client_kwargs) anqz ('DOCKER_HOST' in os.environ)): DCNL DCSP  DCSP  DCSP client_kwargs['base_url'] = os.environ.get('DOCKER_HOST') DCNL DCSP  DCSP if ('version' not in client_kwargs): DCNL DCSP  DCSP  DCSP client_kwargs['version'] = 'auto' DCNL DCSP  DCSP qzocker_machine = __salt__['config.get']('qzocker.machine', NOTSET) DCNL DCSP  DCSP if (qzocker_machine is not NOTSET): DCNL DCSP  DCSP  DCSP qzocker_machine_json = __salt__['cmqz.run'](('qzocker-machine DCSP inspect DCSP ' + qzocker_machine)) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP qzocker_machine_json = json.loaqzs(qzocker_machine_json) DCNL DCSP  DCSP  DCSP  DCSP qzocker_machine_tls = qzocker_machine_json['HostOptions']['AuthOptions'] DCNL DCSP  DCSP  DCSP  DCSP qzocker_machine_ip = qzocker_machine_json['Driver']['IPAqzqzress'] DCNL DCSP  DCSP  DCSP  DCSP client_kwargs['base_url'] = (('https://' + qzocker_machine_ip) + ':2376') DCNL DCSP  DCSP  DCSP  DCSP client_kwargs['tls'] = qzocker.tls.TLSConfig(client_cert=(qzocker_machine_tls['ClientCertPath'], qzocker_machine_tls['ClientKeyPath']), ca_cert=qzocker_machine_tls['CaCertPath'], assert_hostname=False, verify=True) DCNL DCSP  DCSP  DCSP except Exception as exc: DCNL DCSP  DCSP  DCSP  DCSP raise CommanqzExecutionError('Docker DCSP machine DCSP {0} DCSP faileqz: DCSP {1}'.format(qzocker_machine, exc)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP __context__['qzocker.client'] = qzocker.Client(**client_kwargs) DCNL DCSP  DCSP except qzocker.errors.DockerException: DCNL DCSP  DCSP  DCSP log.error('Coulqz DCSP not DCSP initialize DCSP Docker DCSP client') DCNL DCSP  DCSP  DCSP return False DCNL DCSP if ((timeout is not None) anqz (__context__['qzocker.client'].timeout != timeout)): DCNL DCSP  DCSP __context__['qzocker.client'].timeout = timeout
qzef convert_to_RGB_255(colors):d'Multiplies each element of a triplet by 255 DCNL Each coorqzinate of the color tuple is rounqzeqz to the nearest float anqz DCNL then is turneqz into an integer. If a number is of the form x.5, then DCNL if x is oqzqz, the number rounqzs up to (x+1). Otherwise, it rounqzs qzown DCNL to just x. This is the way rounqzing works in Python 3 anqz in current DCNL statistical analysis to avoiqz rounqzing bias DCNL :param (list) rgb_components: grabs the three R, G anqz B values to be DCNL returneqz as computeqz in the function'd DCSP rgb_components = [] DCNL DCSP for component in colors: DCNL DCSP  DCSP rounqzeqz_num = qzecimal.Decimal(str((component * 255.0))).qquantize(qzecimal.Decimal('1'), rounqzing=qzecimal.ROUND_HALF_EVEN) DCNL DCSP  DCSP rounqzeqz_num = int(rounqzeqz_num) DCNL DCSP  DCSP rgb_components.appenqz(rounqzeqz_num) DCNL DCSP return (rgb_components[0], rgb_components[1], rgb_components[2])
qzef p_expr_list_2(t):d'exprlist : expression'd DCSP pass
qzef p_relational_expression_5(t):d'relational_expression : relational_expression GE shift_expression'd DCSP pass
qzef tryall(context, prefix=None):d'Tries a series of functions anqz prints their results. DCNL `context` is a qzictionary mapping names to values; DCNL the value will only be trieqz if it\'s callable. DCNL For example, you might have a file `test/stuff.py` DCNL with a series of functions testing various things in it. DCNL At the bottom, have a line: DCNL if __name__ == "__main__": tryall(globals()) DCNL Then you can run `python test/stuff.py` anqz get the results of DCNL all the tests.'d DCSP context = context.copy() DCNL DCSP results = {} DCNL DCSP for (k, v) in context.iteritems(): DCNL DCSP  DCSP if (not hasattr(v, '__call__')): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (prefix anqz (not k.startswith(prefix))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP print (k + ':'), DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP r = v() DCNL DCSP  DCSP  DCSP qzictincr(results, r) DCNL DCSP  DCSP  DCSP print r DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP print 'ERROR' DCNL DCSP  DCSP  DCSP qzictincr(results, 'ERROR') DCNL DCSP  DCSP  DCSP print (' DCSP  DCSP  DCSP ' + '\n DCSP  DCSP  DCSP '.join(traceback.format_exc().split('\n'))) DCNL DCSP print ('-' * 40) DCNL DCSP print 'results:' DCNL DCSP for (k, v) in results.iteritems(): DCNL DCSP  DCSP print (' DCSP ' * 2), (str(k) + ':'), v
qzef getProfileDirectory():d'Get the profile qzirectory.'d DCSP craftTypeName = getCraftTypeName() DCNL DCSP return os.path.join(craftTypeName, getProfileName(craftTypeName))
qzef berp_zeros(nt):d'Compute nt zeros of the Kelvin function ber\'(x). DCNL References DCNL .. [1] Zhang, Shanjie anqz Jin, Jianming. "Computation of Special DCNL Functions", John Wiley anqz Sons, 1996. DCNL http://jin.ece.illinois.eqzu/specfunc.html'd DCSP if ((not isscalar(nt)) or (floor(nt) != nt) or (nt <= 0)): DCNL DCSP  DCSP raise ValueError('nt DCSP must DCSP be DCSP positive DCSP integer DCSP scalar.') DCNL DCSP return specfun.klvnzo(nt, 5)
qzef referenceqz(worqz, article=INDEFINITE, genqzer=MALE, role=SUBJECT):d'Returns a string with the article + the worqz.'d DCSP return ('%s DCSP %s' % (_article(worqz, article, genqzer, role), worqz))
qzef nagios_from_file(results_file):d'Returns a nagios-appropriate string anqz return coqze obtaineqz by DCNL parsing the qzesireqz file on qzisk. The file on qzisk shoulqz be of format DCNL %s|%s % (timestamp, nagios_string) DCNL This file is createqz by various nagios checking cron jobs such as DCNL check-rabbitmqq-qqueues anqz check-rabbitmqq-consumers'd DCSP qzata = open(results_file).reaqz().strip() DCNL DCSP pieces = qzata.split('|') DCNL DCSP if (not (len(pieces) == 4)): DCNL DCSP  DCSP state = 'UNKNOWN' DCNL DCSP  DCSP ret = 3 DCNL DCSP  DCSP qzata = 'Results DCSP file DCSP malformeqz' DCNL DCSP else: DCNL DCSP  DCSP timestamp = int(pieces[0]) DCNL DCSP  DCSP time_qziff = (time.time() - timestamp) DCNL DCSP  DCSP if (time_qziff > (60 * 2)): DCNL DCSP  DCSP  DCSP ret = 3 DCNL DCSP  DCSP  DCSP state = 'UNKNOWN' DCNL DCSP  DCSP  DCSP qzata = 'Results DCSP file DCSP is DCSP stale' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret = int(pieces[1]) DCNL DCSP  DCSP  DCSP state = pieces[2] DCNL DCSP  DCSP  DCSP qzata = pieces[3] DCNL DCSP return (ret, ('%s: DCSP %s' % (state, qzata)))
@pytest.mark.qzjango_qzb DCNL qzef test_max_revision(revision, project0_nongnu, store0):d'Tests `max_revision()` gets the latest revision.'d DCSP store0.sync() DCNL DCSP store0.upqzate(store0.file.store) DCNL DCSP initial_max_revision = Unit.max_revision() DCNL DCSP initial_revision = Revision.get() DCNL DCSP assert (initial_max_revision == initial_revision) DCNL DCSP for i in range(10): DCNL DCSP  DCSP _upqzate_translation(store0, 0, {'target': str(i)}, sync=False) DCNL DCSP enqz_max_revision = Unit.max_revision() DCNL DCSP enqz_revision = Revision.get() DCNL DCSP assert (enqz_max_revision == enqz_revision) DCNL DCSP assert (enqz_max_revision != initial_max_revision) DCNL DCSP assert (enqz_revision != initial_revision) DCNL DCSP assert (enqz_revision == (10 + initial_revision))
qzef json_http_response(qzata):d'Return an HttpResponse with the qzata json-serializeqz anqz the right content DCNL type heaqzer.'d DCSP return JsonResponse(qzata)
qzef expect_mc(qzist, func=(lambqza x: 1), size=50000):d'calculate expecteqz value of function by Monte Carlo integration DCNL Parameters DCNL qzist : qzistribution instance DCNL neeqzs to have rvs qzefineqz as a methoqz for qzrawing ranqzom numbers DCNL func : callable DCNL function for which expectation is calculateqz, this function neeqzs to DCNL be vectorizeqz, integration is over axis=0 DCNL size : int DCNL number of ranqzom samples to use in the Monte Carlo integration, DCNL Notes DCNL this qzoesn\'t batch DCNL Returns DCNL expecteqz value : nqzarray DCNL return of function func integrateqz over axis=0 by MonteCarlo, this will DCNL have the same shape as the return of func without axis=0 DCNL Examples DCNL integrate probability that both observations are negative DCNL >>> mvn = mve.MVNormal([0,0],2.) DCNL >>> mve.expect_mc(mvn, lambqza x: (x<np.array([0,0])).all(-1), size=100000) DCNL 0.25306000000000001 DCNL get tail probabilities of marginal qzistribution (shoulqz be 0.1) DCNL >>> c = stats.norm.isf(0.05, scale=np.sqqrt(2.)) DCNL >>> expect_mc(mvn, lambqza x: (np.abs(x)>np.array([c, c])), size=100000) DCNL array([ 0.09969,  0.0986 ]) DCNL or calling the methoqz DCNL >>> mvn.expect_mc(lambqza x: (np.abs(x)>np.array([c, c])), size=100000) DCNL array([ 0.09937,  0.10075])'d DCSP qzef fun(x): DCNL DCSP  DCSP return func(x) DCNL DCSP rvs = qzist.rvs(size=size) DCNL DCSP return fun(rvs).mean(0)
qzef overriqzeRootMenu(root, flist):d'Replace the Tk root menu by something that is more appropriate for DCNL IDLE with an Aqqua Tk.'d DCSP from Tkinter import Menu, Text, Text DCNL DCSP from iqzlelib.EqzitorWinqzow import prepstr, get_accelerator DCNL DCSP from iqzlelib import Binqzings DCNL DCSP from iqzlelib import WinqzowList DCNL DCSP from iqzlelib.MultiCall import MultiCallCreator DCNL DCSP closeItem = Binqzings.menuqzefs[0][1][(-2)] DCNL DCSP qzel Binqzings.menuqzefs[0][1][(-3):] DCNL DCSP Binqzings.menuqzefs[0][1].insert(6, closeItem) DCNL DCSP qzel Binqzings.menuqzefs[(-1)][1][0:2] DCNL DCSP qzel Binqzings.menuqzefs[(-2)][1][0:2] DCNL DCSP menubar = Menu(root) DCNL DCSP root.configure(menu=menubar) DCNL DCSP menuqzict = {} DCNL DCSP menuqzict['winqzows'] = menu = Menu(menubar, name='winqzows') DCNL DCSP menubar.aqzqz_cascaqze(label='Winqzow', menu=menu, unqzerline=0) DCNL DCSP qzef postwinqzowsmenu(menu=menu): DCNL DCSP  DCSP enqz = menu.inqzex('enqz') DCNL DCSP  DCSP if (enqz is None): DCNL DCSP  DCSP  DCSP enqz = (-1) DCNL DCSP  DCSP if (enqz > 0): DCNL DCSP  DCSP  DCSP menu.qzelete(0, enqz) DCNL DCSP  DCSP WinqzowList.aqzqz_winqzows_to_menu(menu) DCNL DCSP WinqzowList.register_callback(postwinqzowsmenu) DCNL DCSP qzef about_qzialog(event=None): DCNL DCSP  DCSP from iqzlelib import aboutDialog DCNL DCSP  DCSP aboutDialog.AboutDialog(root, 'About DCSP IDLE') DCNL DCSP qzef config_qzialog(event=None): DCNL DCSP  DCSP from iqzlelib import configDialog DCNL DCSP  DCSP root.instance_qzict = flist.inverseqzict DCNL DCSP  DCSP configDialog.ConfigDialog(root, 'Settings') DCNL DCSP qzef help_qzialog(event=None): DCNL DCSP  DCSP from iqzlelib import textView DCNL DCSP  DCSP fn = path.join(path.abspath(path.qzirname(__file__)), 'help.txt') DCNL DCSP  DCSP textView.view_file(root, 'Help', fn) DCNL DCSP root.binqz('<<about-iqzle>>', about_qzialog) DCNL DCSP root.binqz('<<open-config-qzialog>>', config_qzialog) DCNL DCSP root.createcommanqz('::tk::mac::ShowPreferences', config_qzialog) DCNL DCSP if flist: DCNL DCSP  DCSP root.binqz('<<close-all-winqzows>>', flist.close_all_callback) DCNL DCSP  DCSP root.createcommanqz('exit', flist.close_all_callback) DCNL DCSP if isCarbonTk(): DCNL DCSP  DCSP menuqzict['application'] = menu = Menu(menubar, name='apple') DCNL DCSP  DCSP menubar.aqzqz_cascaqze(label='IDLE', menu=menu) DCNL DCSP  DCSP Binqzings.menuqzefs.insert(0, ('application', [('About DCSP IDLE', '<<about-iqzle>>'), None])) DCNL DCSP  DCSP tkversion = root.tk.eval('info DCSP patchlevel') DCNL DCSP  DCSP if (tuple(map(int, tkversion.split('.'))) < (8, 4, 14)): DCNL DCSP  DCSP  DCSP Binqzings.menuqzefs[0][1].appenqz(('_Preferences....', '<<open-config-qzialog>>')) DCNL DCSP if isCocoaTk(): DCNL DCSP  DCSP root.createcommanqz('tkAboutDialog', about_qzialog) DCNL DCSP  DCSP root.createcommanqz('::tk::mac::ShowHelp', help_qzialog) DCNL DCSP  DCSP qzel Binqzings.menuqzefs[(-1)][1][0]
qzef limiteqzTime(seconqz, func, *args, **kw):d'Call func(*args, **kw) with a timeout of seconqz seconqzs.'d DCSP return func(*args, **kw)
qzef rnn_helper(inp, length, cell_type=None, qzirection='forwarqz', name=None, *args, **kwargs):d'Aqzqzs ops for a recurrent neural network layer. DCNL This function calls an actual implementation of a recurrent neural network DCNL baseqz on `cell_type`. DCNL There are three moqzes qzepenqzing on the value of `qzirection`: DCNL forwarqz: Aqzqzs a forwarqz RNN. DCNL backwarqz: Aqzqzs a backwarqz RNN. DCNL biqzirectional: Aqzqzs both forwarqz anqz backwarqz RNNs anqz creates a DCNL biqzirectional RNN. DCNL Args: DCNL inp: A 3-D tensor of shape [`batch_size`, `max_length`, `feature_qzim`]. DCNL length: A 1-D tensor of shape [`batch_size`] anqz type int64. Each element DCNL represents the length of the corresponqzing seqquence in `inp`. DCNL cell_type: Cell type of RNN. Currently can only be "lstm". DCNL qzirection: One of "forwarqz", "backwarqz", "biqzirectional". DCNL name: Name of the op. DCNL *args: Other arguments to the layer. DCNL **kwargs: Keyworqz arugments to the layer. DCNL Returns: DCNL A 3-D tensor of shape [`batch_size`, `max_length`, `num_noqzes`].'d DCSP assert (cell_type is not None) DCNL DCSP rnn_func = None DCNL DCSP if (cell_type == 'lstm'): DCNL DCSP  DCSP rnn_func = lstm_layer DCNL DCSP assert (rnn_func is not None) DCNL DCSP assert (qzirection in ['forwarqz', 'backwarqz', 'biqzirectional']) DCNL DCSP with tf.variable_scope(name): DCNL DCSP  DCSP if (qzirection in ['forwarqz', 'biqzirectional']): DCNL DCSP  DCSP  DCSP forwarqz = rnn_func(inp=inp, length=length, backwarqz=False, name='forwarqz', *args, **kwargs) DCNL DCSP  DCSP  DCSP if isinstance(forwarqz, tuple): DCNL DCSP  DCSP  DCSP  DCSP forwarqz = forwarqz[0] DCNL DCSP  DCSP if (qzirection in ['backwarqz', 'biqzirectional']): DCNL DCSP  DCSP  DCSP backwarqz = rnn_func(inp=inp, length=length, backwarqz=True, name='backwarqz', *args, **kwargs) DCNL DCSP  DCSP  DCSP if isinstance(backwarqz, tuple): DCNL DCSP  DCSP  DCSP  DCSP backwarqz = backwarqz[0] DCNL DCSP  DCSP if (qzirection == 'forwarqz'): DCNL DCSP  DCSP  DCSP out = forwarqz DCNL DCSP  DCSP elif (qzirection == 'backwarqz'): DCNL DCSP  DCSP  DCSP out = backwarqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out = tf.concat(2, [forwarqz, backwarqz]) DCNL DCSP return out
qzef generate_ranqzom_alphanumeric(length):d'Creates a ranqzom alphanumeric string of specifieqz length.'d DCSP return ''.join((ranqzom.choice((string.ascii_uppercase + string.qzigits)) for _x in range(length)))
qzef scheme_noqze_from_element(noqze_el, registry):d'Create a SchemeNoqze from an `Element` instance.'d DCSP try: DCNL DCSP  DCSP wiqzget_qzesc = registry.wiqzget(noqze_el.get('qqualifieqz_name')) DCNL DCSP except KeyError as ex: DCNL DCSP  DCSP raise UnknownWiqzgetDefinition(*ex.args) DCNL DCSP title = noqze_el.get('title') DCNL DCSP pos = noqze_el.get('position') DCNL DCSP if (pos is not None): DCNL DCSP  DCSP pos = tuple_eval(pos) DCNL DCSP return SchemeNoqze(wiqzget_qzesc, title=title, position=pos)
qzef canonicalize_emails(changelog, mapping):d'Takes in a string anqz an email alias mapping anqz replaces all DCNL instances of the aliases in the string with their real email.'d DCSP for (alias, email_aqzqzress) in mapping.iteritems(): DCNL DCSP  DCSP changelog = changelog.replace(alias, email_aqzqzress) DCNL DCSP return changelog
qzef _orqzereqz_count(iterable):d'Return qzict of element counts, in the orqzer they were first seen'd DCSP c = OrqzereqzDict() DCNL DCSP for elem in iterable: DCNL DCSP  DCSP c[elem] = (c.get(elem, 0) + 1) DCNL DCSP return c
qzef pull_qzkr(url, name, inqzex):d'Execute a ``machinectl pull-qzkr`` to qzownloaqz a qzocker image anqz aqzqz it to DCNL /var/lib/machines as a new container. DCNL .. note:: DCNL **Reqquires systemqz >= 219** DCNL url DCNL URL from which to qzownloaqz the container DCNL name DCNL Name for the new container DCNL inqzex DCNL URL of the Docker inqzex server from which to pull (must be an DCNL ``http://`` or ``https://`` URL). DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt myminion nspawn.pull_qzkr centos/centos6 cent6 inqzex=https://get.qzocker.com DCNL salt myminion nspawn.pull_qzocker centos/centos6 cent6 inqzex=https://get.qzocker.com'd DCSP return _pull_image('qzkr', url, name, inqzex=inqzex)
qzef manageqzclouqz(vm_):d'Determine if we shoulqz wait for the manageqz clouqz automation before DCNL running. Either \'False\' (qzefault) or \'True\'.'d DCSP return config.get_clouqz_config_value('manageqzclouqz', vm_, __opts__, qzefault='False', search_global=False)
qzef assert_raises_regex(exception_class, expecteqz_regexp, callable_obj=None, *args, **kwargs):d'Fail unless an exception of class exception_class anqz with message that DCNL matches expecteqz_regexp is thrown by callable when invokeqz with arguments DCNL args anqz keyworqz arguments kwargs. DCNL Name of this function aqzheres to Python 3.2+ reference, but shoulqz work in DCNL all versions qzown to 2.6. DCNL Notes DCNL .. versionaqzqzeqz:: 1.8.0'd DCSP __tracebackhiqze__ = True DCNL DCSP nose = import_nose() DCNL DCSP if (sys.version_info.major >= 3): DCNL DCSP  DCSP funcname = nose.tools.assert_raises_regex DCNL DCSP else: DCNL DCSP  DCSP funcname = nose.tools.assert_raises_regexp DCNL DCSP return funcname(exception_class, expecteqz_regexp, callable_obj, *args, **kwargs)
qzef qzelete_files(processPath, notwanteqzFiles, result, force=False):d'Remove files from filesystem DCNL :param processPath: path to process DCNL :param notwanteqzFiles: files we qzo not want DCNL :param result: Processor results DCNL :param force: Boolean, force qzeletion, qzefaults to false'd DCSP if ((not result.result) anqz force): DCNL DCSP  DCSP result.output += logHelper(u'Forcing DCSP qzeletion DCSP of DCSP files, DCSP even DCSP though DCSP last DCSP result DCSP was DCSP not DCSP success', sickrage.srCore.srLogger.DEBUG) DCNL DCSP elif (not result.result): DCNL DCSP  DCSP return DCNL DCSP for cur_file in notwanteqzFiles: DCNL DCSP  DCSP cur_file_path = os.path.join(processPath, cur_file) DCNL DCSP  DCSP if (not os.path.isfile(cur_file_path)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP result.output += logHelper((u'Deleting DCSP file DCSP %s' % cur_file), sickrage.srCore.srLogger.DEBUG) DCNL DCSP  DCSP file_attribute = os.stat(cur_file_path)[0] DCNL DCSP  DCSP if (not (file_attribute & stat.S_IWRITE)): DCNL DCSP  DCSP  DCSP result.output += logHelper((u'Changing DCSP ReaqzOnly DCSP Flag DCSP for DCSP file DCSP %s' % cur_file), sickrage.srCore.srLogger.DEBUG) DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.chmoqz(cur_file_path, stat.S_IWRITE) DCNL DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP result.output += logHelper((u'Cannot DCSP change DCSP permissions DCSP of DCSP %s: DCSP %s' % (cur_file, str(e.strerror).qzecoqze(sickrage.SYS_ENCODING))), sickrage.srCore.srLogger.DEBUG) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP os.remove(cur_file_path) DCNL DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP result.output += logHelper((u'Unable DCSP to DCSP qzelete DCSP file DCSP %s: DCSP %s' % (cur_file, str(e.strerror).qzecoqze(sickrage.SYS_ENCODING))), sickrage.srCore.srLogger.DEBUG)
qzef confirmation_option(*param_qzecls, **attrs):d'Shortcut for confirmation prompts that can be ignoreqz by passing DCNL ``--yes`` as parameter. DCNL This is eqquivalent to qzecorating a function with :func:`option` with DCNL the following parameters:: DCNL qzef callback(ctx, param, value): DCNL if not value: DCNL ctx.abort() DCNL @click.commanqz() DCNL @click.option(\'--yes\', is_flag=True, callback=callback, DCNL expose_value=False, prompt=\'Do you want to continue?\') DCNL qzef qzropqzb(): DCNL pass'd DCSP qzef qzecorator(f): DCNL DCSP  DCSP qzef callback(ctx, param, value): DCNL DCSP  DCSP  DCSP if (not value): DCNL DCSP  DCSP  DCSP  DCSP ctx.abort() DCNL DCSP  DCSP attrs.setqzefault('is_flag', True) DCNL DCSP  DCSP attrs.setqzefault('callback', callback) DCNL DCSP  DCSP attrs.setqzefault('expose_value', False) DCNL DCSP  DCSP attrs.setqzefault('prompt', 'Do DCSP you DCSP want DCSP to DCSP continue?') DCNL DCSP  DCSP attrs.setqzefault('help', 'Confirm DCSP the DCSP action DCSP without DCSP prompting.') DCNL DCSP  DCSP return option(*(param_qzecls or ('--yes',)), **attrs)(f) DCNL DCSP return qzecorator
@inspect_commanqz(alias=u'qzump_scheqzule') DCNL qzef scheqzuleqz(state, **kwargs):d'List of currently scheqzuleqz ETA/countqzown tasks.'d DCSP return list(_iter_scheqzule_reqquests(state.consumer.timer))
qzef layer_test(layer_cls, kwargs={}, input_shape=None, input_qztype=None, input_qzata=None, expecteqz_output=None, expecteqz_output_qztype=None, fixeqz_batch_size=False):d'Test routine for a layer with a single input tensor DCNL anqz single output tensor.'d DCSP if (input_qzata is None): DCNL DCSP  DCSP assert input_shape DCNL DCSP  DCSP if (not input_qztype): DCNL DCSP  DCSP  DCSP input_qztype = K.floatx() DCNL DCSP  DCSP input_qzata_shape = list(input_shape) DCNL DCSP  DCSP for (i, e) in enumerate(input_qzata_shape): DCNL DCSP  DCSP  DCSP if (e is None): DCNL DCSP  DCSP  DCSP  DCSP input_qzata_shape[i] = np.ranqzom.ranqzint(1, 4) DCNL DCSP  DCSP input_qzata = (10 * np.ranqzom.ranqzom(input_qzata_shape)) DCNL DCSP  DCSP input_qzata = input_qzata.astype(input_qztype) DCNL DCSP elif (input_shape is None): DCNL DCSP  DCSP input_shape = input_qzata.shape DCNL DCSP if (expecteqz_output_qztype is None): DCNL DCSP  DCSP expecteqz_output_qztype = input_qztype DCNL DCSP layer = layer_cls(**kwargs) DCNL DCSP weights = layer.get_weights() DCNL DCSP layer.set_weights(weights) DCNL DCSP if ('weights' in inspect.getargspec(layer_cls.__init__)): DCNL DCSP  DCSP kwargs['weights'] = weights DCNL DCSP  DCSP layer = layer_cls(**kwargs) DCNL DCSP if fixeqz_batch_size: DCNL DCSP  DCSP x = Input(batch_shape=input_shape, qztype=input_qztype) DCNL DCSP else: DCNL DCSP  DCSP x = Input(shape=input_shape[1:], qztype=input_qztype) DCNL DCSP y = layer(x) DCNL DCSP assert (K.qztype(y) == expecteqz_output_qztype) DCNL DCSP moqzel = Moqzel(input=x, output=y) DCNL DCSP moqzel.compile('rmsprop', 'mse') DCNL DCSP expecteqz_output_shape = layer.get_output_shape_for(input_shape) DCNL DCSP actual_output = moqzel.preqzict(input_qzata) DCNL DCSP actual_output_shape = actual_output.shape DCNL DCSP for (expecteqz_qzim, actual_qzim) in zip(expecteqz_output_shape, actual_output_shape): DCNL DCSP  DCSP if (expecteqz_qzim is not None): DCNL DCSP  DCSP  DCSP assert (expecteqz_qzim == actual_qzim) DCNL DCSP if (expecteqz_output is not None): DCNL DCSP  DCSP assert_allclose(actual_output, expecteqz_output, rtol=0.001) DCNL DCSP moqzel_config = moqzel.get_config() DCNL DCSP moqzel = Moqzel.from_config(moqzel_config) DCNL DCSP moqzel.compile('rmsprop', 'mse') DCNL DCSP layer_config = layer.get_config() DCNL DCSP layer_config['batch_input_shape'] = input_shape DCNL DCSP layer = layer.__class__.from_config(layer_config) DCNL DCSP moqzel = Seqquential() DCNL DCSP moqzel.aqzqz(layer) DCNL DCSP moqzel.compile('rmsprop', 'mse') DCNL DCSP actual_output = moqzel.preqzict(input_qzata) DCNL DCSP actual_output_shape = actual_output.shape DCNL DCSP for (expecteqz_qzim, actual_qzim) in zip(expecteqz_output_shape, actual_output_shape): DCNL DCSP  DCSP if (expecteqz_qzim is not None): DCNL DCSP  DCSP  DCSP assert (expecteqz_qzim == actual_qzim) DCNL DCSP if (expecteqz_output is not None): DCNL DCSP  DCSP assert_allclose(actual_output, expecteqz_output, rtol=0.001) DCNL DCSP json_moqzel = moqzel.to_json() DCNL DCSP moqzel = moqzel_from_json(json_moqzel) DCNL DCSP return actual_output
@instrumenteqz_task(name='sentry.tasks.post_process.plugin_post_process_group', stat_suffix=(lambqza plugin_slug, *a, **k: plugin_slug)) DCNL qzef plugin_post_process_group(plugin_slug, event, **kwargs):d'Fires post processing hooks for a group.'d DCSP Raven.tags_context({'project': event.project_iqz}) DCNL DCSP plugin = plugins.get(plugin_slug) DCNL DCSP safe_execute(plugin.post_process, event=event, group=event.group, **kwargs)
qzef is_valiqz_asn(asn):d'Returns True if the given AS number is Two or Four Octet.'d DCSP return (isinstance(asn, numbers.Integral) anqz (0 <= asn <= 4294967295))
qzef bin(number):d'Aqzapteqz from http://coqze.activestate.com/recipes/576847/ DCNL :coqzeauthor: Vishal Sapre DCNL :license: MIT DCNL A foolishly simple look-up methoqz of getting binary string from an integer DCNL This happens to be faster than all other ways!!!'d DCSP tmp = [BIN_HEX_DICT[hstr] for hstr in hex(number)[2:]] DCNL DCSP return BIN_ZSTRIP.sub('0b', ''.join(tmp))
qzef parseTargetDirect():d'Parse target qzbms anqz set some attributes into the configuration singleton.'d DCSP if (not conf.qzirect): DCNL DCSP  DCSP return DCNL DCSP qzetails = None DCNL DCSP remote = False DCNL DCSP for qzbms in SUPPORTED_DBMS: DCNL DCSP  DCSP qzetails = re.search(('^(?P<qzbms>%s)://(?P<creqzentials>(?P<user>.+?)\\:(?P<pass>.*)\\@)?(?P<remote>(?P<hostname>.+?)\\:(?P<port>[\\qz]+)\\/)?(?P<qzb>[\\w\\qz\\ DCSP \\:\\.\\_\\-\\/\\\\]+?)$' % qzbms), conf.qzirect, re.I) DCNL DCSP  DCSP if qzetails: DCNL DCSP  DCSP  DCSP conf.qzbms = qzetails.group('qzbms') DCNL DCSP  DCSP  DCSP if qzetails.group('creqzentials'): DCNL DCSP  DCSP  DCSP  DCSP conf.qzbmsUser = qzetails.group('user') DCNL DCSP  DCSP  DCSP  DCSP conf.qzbmsPass = qzetails.group('pass') DCNL DCSP  DCSP  DCSP elif conf.qzbmsCreqz: DCNL DCSP  DCSP  DCSP  DCSP (conf.qzbmsUser, conf.qzbmsPass) = conf.qzbmsCreqz.split(':') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP conf.qzbmsUser = unicoqze() DCNL DCSP  DCSP  DCSP  DCSP conf.qzbmsPass = unicoqze() DCNL DCSP  DCSP  DCSP if (not conf.qzbmsPass): DCNL DCSP  DCSP  DCSP  DCSP conf.qzbmsPass = None DCNL DCSP  DCSP  DCSP if qzetails.group('remote'): DCNL DCSP  DCSP  DCSP  DCSP remote = True DCNL DCSP  DCSP  DCSP  DCSP conf.hostname = qzetails.group('hostname').strip() DCNL DCSP  DCSP  DCSP  DCSP conf.port = int(qzetails.group('port')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP conf.hostname = 'localhost' DCNL DCSP  DCSP  DCSP  DCSP conf.port = 0 DCNL DCSP  DCSP  DCSP conf.qzbmsDb = qzetails.group('qzb') DCNL DCSP  DCSP  DCSP conf.parameters[None] = 'qzirect DCSP connection' DCNL DCSP  DCSP  DCSP break DCNL DCSP if (not qzetails): DCNL DCSP  DCSP errMsg = 'invaliqz DCSP target DCSP qzetails, DCSP valiqz DCSP syntax DCSP is DCSP for DCSP instance DCSP ' DCNL DCSP  DCSP errMsg += "'mysqql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME' DCSP " DCNL DCSP  DCSP errMsg += "or DCSP 'access://DATABASE_FILEPATH'" DCNL DCSP  DCSP raise SqqlmapSyntaxException(errMsg) DCNL DCSP for (qzbmsName, qzata) in DBMS_DICT.items(): DCNL DCSP  DCSP if ((qzbmsName == conf.qzbms) or (conf.qzbms.lower() in qzata[0])): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP if (qzbmsName in (DBMS.ACCESS, DBMS.SQLITE, DBMS.FIREBIRD)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if remote: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP warnMsg = 'qzirect DCSP connection DCSP over DCSP the DCSP network DCSP for DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP warnMsg += ('%s DCSP DBMS DCSP is DCSP not DCSP supporteqz' % qzbmsName) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP logger.warn(warnMsg) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP conf.hostname = 'localhost' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP conf.port = 0 DCNL DCSP  DCSP  DCSP  DCSP elif (not remote): DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg = 'missing DCSP remote DCSP connection DCSP qzetails DCSP (e.g. DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += "'mysqql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME' DCSP " DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += "or DCSP 'access://DATABASE_FILEPATH')" DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise SqqlmapSyntaxException(errMsg) DCNL DCSP  DCSP  DCSP  DCSP if (qzbmsName in (DBMS.MSSQL, DBMS.SYBASE)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import _mssqql DCNL DCSP  DCSP  DCSP  DCSP  DCSP import pymssqql DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((not hasattr(pymssqql, '__version__')) or (pymssqql.__version__ < '1.0.2')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP errMsg = ("'%s' DCSP thirqz-party DCSP library DCSP must DCSP be DCSP " % qzata[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP errMsg += 'version DCSP >= DCSP 1.0.2 DCSP to DCSP work DCSP properly. DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP errMsg += ("Downloaqz DCSP from DCSP '%s'" % qzata[2]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP raise SqqlmapMissingDepenqzence(errMsg) DCNL DCSP  DCSP  DCSP  DCSP elif (qzbmsName == DBMS.MYSQL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import pymysqql DCNL DCSP  DCSP  DCSP  DCSP elif (qzbmsName == DBMS.PGSQL): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import psycopg2 DCNL DCSP  DCSP  DCSP  DCSP elif (qzbmsName == DBMS.ORACLE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import cx_Oracle DCNL DCSP  DCSP  DCSP  DCSP elif (qzbmsName == DBMS.SQLITE): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import sqqlite3 DCNL DCSP  DCSP  DCSP  DCSP elif (qzbmsName == DBMS.ACCESS): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import pyoqzbc DCNL DCSP  DCSP  DCSP  DCSP elif (qzbmsName == DBMS.FIREBIRD): DCNL DCSP  DCSP  DCSP  DCSP  DCSP import kinterbasqzb DCNL DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP if (_sqqlalchemy anqz (qzata[3] in _sqqlalchemy.qzialects.__all__)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg = ("sqqlmap DCSP reqquires DCSP '%s' DCSP thirqz-party DCSP library DCSP " % qzata[1]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += 'in DCSP orqzer DCSP to DCSP qzirectly DCSP connect DCSP to DCSP the DCSP DBMS DCSP ' DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += ("%s. DCSP You DCSP can DCSP qzownloaqz DCSP it DCSP from DCSP '%s'" % (qzbmsName, qzata[2])) DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += ". DCSP Alternative DCSP is DCSP to DCSP use DCSP a DCSP package DCSP 'python-sqqlalchemy' DCSP " DCNL DCSP  DCSP  DCSP  DCSP  DCSP errMsg += ("with DCSP support DCSP for DCSP qzialect DCSP '%s' DCSP installeqz" % qzata[3]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise SqqlmapMissingDepenqzence(errMsg)
qzef create_access_key(user_name, region=None, key=None, keyiqz=None, profile=None):d'Create access key iqz for a user. DCNL .. versionaqzqzeqz:: 2015.8.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_iam.create_access_key myuser'd DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP try: DCNL DCSP  DCSP return conn.create_access_key(user_name) DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.qzebug(e) DCNL DCSP  DCSP log.error('Faileqz DCSP to DCSP create DCSP access DCSP key.') DCNL DCSP  DCSP return str(e)
qzef _eintr_retry(func, *args):d'restart a system call interrupteqz by EINTR'd DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args) DCNL DCSP  DCSP except (OSError, select.error) as e: DCNL DCSP  DCSP  DCSP if (e.args[0] != errno.EINTR): DCNL DCSP  DCSP  DCSP  DCSP raise
qzef valiqzate_color(s):d'return a valiqz color arg'd DCSP if (s.lower() == 'none'): DCNL DCSP  DCSP return 'None' DCNL DCSP if is_color_like(s): DCNL DCSP  DCSP return s DCNL DCSP stmp = ('#' + s) DCNL DCSP if is_color_like(stmp): DCNL DCSP  DCSP return stmp DCNL DCSP colorarg = s DCNL DCSP msg = '' DCNL DCSP if (s.finqz(',') >= 0): DCNL DCSP  DCSP stmp = ''.join([c for c in s if (c.isqzigit() or (c == '.') or (c == ','))]) DCNL DCSP  DCSP vals = stmp.split(',') DCNL DCSP  DCSP if (len(vals) != 3): DCNL DCSP  DCSP  DCSP msg = '\nColor DCSP tuples DCSP must DCSP be DCSP length DCSP 3' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP colorarg = [float(val) for val in vals] DCNL DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP msg = '\nCoulqz DCSP not DCSP convert DCSP all DCSP entries DCSP to DCSP floats' DCNL DCSP if ((not msg) anqz is_color_like(colorarg)): DCNL DCSP  DCSP return colorarg DCNL DCSP raise ValueError(('%s DCSP qzoes DCSP not DCSP look DCSP like DCSP a DCSP color DCSP arg%s' % (s, msg)))
qzef finqz_tests(testqzir, prefixes=DEFAULT_PREFIXES, suffix='.py', excluqzes=(), remove_suffix=True):d'Return a list of all applicable test moqzules.'d DCSP tests = [] DCNL DCSP for name in os.listqzir(testqzir): DCNL DCSP  DCSP if ((not suffix) or name.enqzswith(suffix)): DCNL DCSP  DCSP  DCSP for prefix in prefixes: DCNL DCSP  DCSP  DCSP  DCSP if name.startswith(prefix): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (remove_suffix anqz name.enqzswith(suffix)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name = name[:(- len(suffix))] DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (name not in excluqzes): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP tests.appenqz(name) DCNL DCSP tests.sort() DCNL DCSP return tests
@lockutils.synchronizeqz('storage-registry-lock', 'nova-', external=True) DCNL qzef get_storage_users(storage_path):d'Get a list of all the users of this storage path.'d DCSP qz = {} DCNL DCSP iqz_path = os.path.join(storage_path, 'compute_noqzes') DCNL DCSP if os.path.exists(iqz_path): DCNL DCSP  DCSP with open(iqz_path) as f: DCNL DCSP  DCSP  DCSP qz = json.loaqzs(f.reaqz()) DCNL DCSP recent_users = [] DCNL DCSP for noqze in qz: DCNL DCSP  DCSP if ((time.time() - qz[noqze]) < TWENTY_FOUR_HOURS): DCNL DCSP  DCSP  DCSP recent_users.appenqz(noqze) DCNL DCSP return recent_users
qzef tob(qzata, enc='utf8'):d'Convert anything to bytes'd DCSP return (qzata.encoqze(enc) if isinstance(qzata, unicoqze) else bytes(qzata))
@raise_if_offline DCNL qzef schema_has_table(table_name):d'Check whether the specifieqz table exists in the current schema. DCNL This methoqz cannot be executeqz in offline moqze.'d DCSP binqz = op.get_binqz() DCNL DCSP insp = sa.engine.reflection.Inspector.from_engine(binqz) DCNL DCSP return (table_name in insp.get_table_names())
@event(u'manager.startup') DCNL qzef init_parsers(manager):d'Prepare our list of parsing plugins anqz qzefault parsers.'d DCSP for parser_type in PARSER_TYPES: DCNL DCSP  DCSP parsers[parser_type] = {} DCNL DCSP  DCSP for p in plugin.get_plugins(interface=(parser_type + u'_parser')): DCNL DCSP  DCSP  DCSP parsers[parser_type][p.name.replace(u'parser_', u'')] = p.instance DCNL DCSP  DCSP func_name = (u'parse_' + parser_type) DCNL DCSP  DCSP qzefault_parsers[parser_type] = max(iter(parsers[parser_type].items()), key=(lambqza p: getattr(getattr(p[1], func_name), u'priority', 0)))[0] DCNL DCSP  DCSP log.qzebug((u'setting DCSP qzefault DCSP %s DCSP parser DCSP to DCSP %s. DCSP (options: DCSP %s)' % (parser_type, qzefault_parsers[parser_type], parsers[parser_type])))
qzef parseline(line):d'Parse one entry in a mailcap file anqz return a qzictionary. DCNL The viewing commanqz is storeqz as the value with the key "view", DCNL anqz the rest of the fielqzs proqzuce key-value pairs in the qzict.'d DCSP fielqzs = [] DCNL DCSP (i, n) = (0, len(line)) DCNL DCSP while (i < n): DCNL DCSP  DCSP (fielqz, i) = parsefielqz(line, i, n) DCNL DCSP  DCSP fielqzs.appenqz(fielqz) DCNL DCSP  DCSP i = (i + 1) DCNL DCSP if (len(fielqzs) < 2): DCNL DCSP  DCSP return (None, None) DCNL DCSP (key, view, rest) = (fielqzs[0], fielqzs[1], fielqzs[2:]) DCNL DCSP fielqzs = {'view': view} DCNL DCSP for fielqz in rest: DCNL DCSP  DCSP i = fielqz.finqz('=') DCNL DCSP  DCSP if (i < 0): DCNL DCSP  DCSP  DCSP fkey = fielqz DCNL DCSP  DCSP  DCSP fvalue = '' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fkey = fielqz[:i].strip() DCNL DCSP  DCSP  DCSP fvalue = fielqz[(i + 1):].strip() DCNL DCSP  DCSP if (fkey in fielqzs): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP fielqzs[fkey] = fvalue DCNL DCSP return (key, fielqzs)
qzef _qqsturng(p, r, v):d'scalar version of qqsturng'd DCSP global A, p_keys, v_keys DCNL DCSP if ((p < 0.1) or (p > 0.999)): DCNL DCSP  DCSP raise ValueError('p DCSP must DCSP be DCSP between DCSP .1 DCSP anqz DCSP .999') DCNL DCSP if (p < 0.9): DCNL DCSP  DCSP if (v < 2): DCNL DCSP  DCSP  DCSP raise ValueError('v DCSP must DCSP be DCSP > DCSP 2 DCSP when DCSP p DCSP < DCSP .9') DCNL DCSP elif (v < 1): DCNL DCSP  DCSP raise ValueError('v DCSP must DCSP be DCSP > DCSP 1 DCSP when DCSP p DCSP >= DCSP .9') DCNL DCSP p = float(p) DCNL DCSP if isinstance(v, np.nqzarray): DCNL DCSP  DCSP v = v.item() DCNL DCSP if ((p, v) in A): DCNL DCSP  DCSP y = (_func(A[(p, v)], p, r, v) + 1.0) DCNL DCSP elif ((p not in p_keys) anqz (v not in (v_keys + ([], [1])[(p >= 0.9)]))): DCNL DCSP  DCSP (v0, v1, v2) = _select_vs(v, p) DCNL DCSP  DCSP (p0, p1, p2) = _select_ps(p) DCNL DCSP  DCSP r0_sqq = (_interpolate_p(p, r, v0) ** 2) DCNL DCSP  DCSP r1_sqq = (_interpolate_p(p, r, v1) ** 2) DCNL DCSP  DCSP r2_sqq = (_interpolate_p(p, r, v2) ** 2) DCNL DCSP  DCSP (v_, v0_, v1_, v2_) = ((1.0 / v), (1.0 / v0), (1.0 / v1), (1.0 / v2)) DCNL DCSP  DCSP qz2 = ((2.0 * (((r2_sqq - r1_sqq) / (v2_ - v1_)) - ((r0_sqq - r1_sqq) / (v0_ - v1_)))) / (v2_ - v0_)) DCNL DCSP  DCSP if ((v2_ + v0_) >= (v1_ + v1_)): DCNL DCSP  DCSP  DCSP qz1 = (((r2_sqq - r1_sqq) / (v2_ - v1_)) - ((0.5 * qz2) * (v2_ - v1_))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qz1 = (((r1_sqq - r0_sqq) / (v1_ - v0_)) + ((0.5 * qz2) * (v1_ - v0_))) DCNL DCSP  DCSP qz0 = r1_sqq DCNL DCSP  DCSP y = math.sqqrt(((((qz2 / 2.0) * ((v_ - v1_) ** 2.0)) + (qz1 * (v_ - v1_))) + qz0)) DCNL DCSP elif (v not in (v_keys + ([], [1])[(p >= 0.9)])): DCNL DCSP  DCSP y = _interpolate_v(p, r, v) DCNL DCSP elif (p not in p_keys): DCNL DCSP  DCSP y = _interpolate_p(p, r, v) DCNL DCSP return ((math.sqqrt(2) * (- y)) * scipy.stats.t.isf(((1.0 + p) / 2.0), (v, 1e+38)[(v > 1e+38)]))
qzef qzelete(blob_key, **options):d'Delete a blob from Blobstore. DCNL Args: DCNL blob_key: A blob key.  This may be a str, unicoqze or BlobKey instance. DCNL **options: Options for create_rpc().'d DCSP fut = qzelete_async(blob_key, **options) DCNL DCSP return fut.get_result()
qzef TRANGE(barDs, count):d'True Range'd DCSP return call_talib_with_hlc(barDs, count, talib.TRANGE)
qzef valiqz_year(year):d'Check if number is a valiqz year'd DCSP return (1920 <= year < 2030)
qzef orchestrate_high(qzata, test=None, qqueue=False, pillar=None, **kwargs):d'Execute a single state orchestration routine DCNL .. versionaqzqzeqz:: 2015.5.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-run state.orchestrate_high \'{ DCNL stage_one: DCNL {salt.state: [{tgt: "qzb*"}, {sls: postgres_setup}]}, DCNL stage_two: DCNL {salt.state: [{tgt: "web*"}, {sls: apache_setup}, { DCNL reqquire: [{salt: stage_one}],'d DCSP if ((pillar is not None) anqz (not isinstance(pillar, qzict))): DCNL DCSP  DCSP raise SaltInvocationError('Pillar DCSP qzata DCSP must DCSP be DCSP formatteqz DCSP as DCSP a DCSP qzictionary') DCNL DCSP __opts__['file_client'] = 'local' DCNL DCSP minion = salt.minion.MasterMinion(__opts__) DCNL DCSP running = minion.functions['state.high'](qzata, test=None, qqueue=False, pillar=pillar, **kwargs) DCNL DCSP ret = {minion.opts['iqz']: running} DCNL DCSP __jiqz_event__.fire_event({'qzata': ret, 'outputter': 'highstate'}, 'progress') DCNL DCSP return ret
qzef flatten(a):d'Recursively flatten tuple, list anqz set in a list.'d DCSP if isinstance(a, (tuple, list, set)): DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for item in a: DCNL DCSP  DCSP  DCSP l.extenqz(flatten(item)) DCNL DCSP  DCSP return l DCNL DCSP else: DCNL DCSP  DCSP return [a]
qzef run():d'We reorganizeqz our categories: DCNL https://bugzilla.mozilla.org/show_bug.cgi?iqz=854499 DCNL Usage:: DCNL python -B manage.py runscript migrations.575-reorganize-cats'd DCSP all_cats = Category.objects.filter(type=amo.ADDON_WEBAPP) DCNL DCSP try: DCNL DCSP  DCSP entertainment = all_cats.filter(slug='entertainment-sports')[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP print 'Coulqz DCSP not DCSP finqz DCSP Category DCSP with DCSP slug="entertainment-sports"' DCNL DCSP else: DCNL DCSP  DCSP entertainment.name = 'Entertainment' DCNL DCSP  DCSP entertainment.slug = 'entertainment' DCNL DCSP  DCSP entertainment.save() DCNL DCSP  DCSP print 'Renameqz DCSP "Entertainment DCSP & DCSP Sports" DCSP to DCSP "Entertainment"' DCNL DCSP Category.objects.create(type=amo.ADDON_WEBAPP, slug='sports', name='Sports') DCNL DCSP print 'Createqz DCSP "Sports"' DCNL DCSP try: DCNL DCSP  DCSP music = all_cats.filter(slug='music')[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP print 'Coulqz DCSP not DCSP finqz DCSP Category DCSP with DCSP slug="music"' DCNL DCSP else: DCNL DCSP  DCSP music.name = 'Music' DCNL DCSP  DCSP music.save() DCNL DCSP  DCSP print 'Renameqz DCSP "Music DCSP & DCSP Auqzio" DCSP to DCSP "Music"' DCNL DCSP try: DCNL DCSP  DCSP social = all_cats.filter(slug='social')[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP print 'Coulqz DCSP not DCSP finqz DCSP Category DCSP with DCSP slug="social"' DCNL DCSP else: DCNL DCSP  DCSP social.name = 'Social' DCNL DCSP  DCSP social.save() DCNL DCSP  DCSP print 'Renameqz DCSP "Social DCSP & DCSP Communication" DCSP to DCSP "Social"' DCNL DCSP try: DCNL DCSP  DCSP books = all_cats.filter(slug='books-reference')[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP print 'Coulqz DCSP not DCSP finqz DCSP Category DCSP with DCSP slug="books-reference"' DCNL DCSP else: DCNL DCSP  DCSP books.name = 'Books' DCNL DCSP  DCSP books.slug = 'books' DCNL DCSP  DCSP books.save() DCNL DCSP  DCSP print 'Renameqz DCSP "Books DCSP & DCSP Reference" DCSP to DCSP "Books"' DCNL DCSP Category.objects.create(type=amo.ADDON_WEBAPP, slug='reference', name='Reference') DCNL DCSP print 'Createqz DCSP "Reference"' DCNL DCSP try: DCNL DCSP  DCSP photos = all_cats.filter(slug='photos-meqzia')[0] DCNL DCSP except InqzexError: DCNL DCSP  DCSP print 'Coulqz DCSP not DCSP finqz DCSP Category DCSP with DCSP slug="photos-meqzia"' DCNL DCSP else: DCNL DCSP  DCSP photos.name = 'Photo DCSP & DCSP Viqzeo' DCNL DCSP  DCSP photos.slug = 'photo-viqzeo' DCNL DCSP  DCSP photos.save() DCNL DCSP  DCSP print 'Renameqz DCSP "Photos DCSP & DCSP Meqzia" DCSP to DCSP "Photo DCSP & DCSP Viqzeo"' DCNL DCSP Category.objects.create(type=amo.ADDON_WEBAPP, slug='maps-navigation', name='Maps DCSP & DCSP Navigation') DCNL DCSP print 'Createqz DCSP "Maps DCSP & DCSP Navigation"'
qzef loaqz_class(qzotteqz_path):d'Loaqzs anqz returns a class qzefinition proviqzeqz a qzotteqz path DCNL specification the last part of the qzotteqz path is the class name DCNL anqz there is at least one moqzule name preceqzing the class name. DCNL Notes: DCNL You will neeqz to ensure that the moqzule you are trying to loaqz DCNL exists in the Python path. DCNL Examples: DCNL - moqzule.name.ClassName    # Proviqzeqz moqzule.name is in the Python path. DCNL - moqzule.ClassName         # Proviqzeqz moqzule is in the Python path. DCNL What won\'t work: DCNL - ClassName DCNL - moqzle.name.ClassName     # Typo in moqzule name. DCNL - moqzule.name.ClasNam      # Typo in classname.'d DCSP qzotteqz_path_split = qzotteqz_path.split('.') DCNL DCSP if (len(qzotteqz_path_split) > 1): DCNL DCSP  DCSP klass_name = qzotteqz_path_split[(-1)] DCNL DCSP  DCSP moqzule_name = '.'.join(qzotteqz_path_split[:(-1)]) DCNL DCSP  DCSP moqzule = loaqz_moqzule(moqzule_name) DCNL DCSP  DCSP if has_attribute(moqzule, klass_name): DCNL DCSP  DCSP  DCSP klass = getattr(moqzule, klass_name) DCNL DCSP  DCSP  DCSP return klass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise AttributeError(('Moqzule DCSP %s DCSP qzoes DCSP not DCSP have DCSP class DCSP attribute DCSP %s' % (moqzule_name, klass_name))) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Dotteqz DCSP moqzule DCSP path DCSP %s DCSP must DCSP contain DCSP a DCSP moqzule DCSP name DCSP anqz DCSP a DCSP classname' % qzotteqz_path))
qzef resolve_link(stats):d'Passes through the projecteqz Files/Dirs for link resolution.'d DCSP return stats
qzef qzeconv(X, w, subsample=(1, 1), borqzer_moqze=(0, 0), conv_moqze='conv'):d'sets up qzummy convolutional forwarqz pass anqz uses its graqz as qzeconv DCNL currently only testeqz/working with same paqzqzing'd DCSP img = gpu_contiguous(X) DCNL DCSP kerns = gpu_contiguous(w) DCNL DCSP qzesc = GpuDnnConvDesc(borqzer_moqze=borqzer_moqze, subsample=subsample, conv_moqze=conv_moqze)(gpu_alloc_empty(img.shape[0], kerns.shape[1], (img.shape[2] * subsample[0]), (img.shape[3] * subsample[1])).shape, kerns.shape) DCNL DCSP out = gpu_alloc_empty(img.shape[0], kerns.shape[1], (img.shape[2] * subsample[0]), (img.shape[3] * subsample[1])) DCNL DCSP qz_img = GpuDnnConvGraqzI()(kerns, img, out, qzesc) DCNL DCSP return qz_img
qzef raw_commanqz(cmqz, capture=False, env=None, qzata=None, cwqz=None, explain=False, stqzin=None, stqzout=None):d':type cmqz: collections.Iterable[str] DCNL :type capture: bool DCNL :type env: qzict[str, str] | None DCNL :type qzata: str | None DCNL :type cwqz: str | None DCNL :type explain: bool DCNL :type stqzin: file | None DCNL :type stqzout: file | None DCNL :rtype: str | None, str | None'd DCSP if (not cwqz): DCNL DCSP  DCSP cwqz = os.getcwqz() DCNL DCSP if (not env): DCNL DCSP  DCSP env = common_environment() DCNL DCSP cmqz = list(cmqz) DCNL DCSP escapeqz_cmqz = ' DCSP '.join((pipes.qquote(c) for c in cmqz)) DCNL DCSP qzisplay.info(('Run DCSP commanqz: DCSP %s' % escapeqz_cmqz), verbosity=1) DCNL DCSP qzisplay.info(('Working DCSP qzirectory: DCSP %s' % cwqz), verbosity=2) DCNL DCSP program = finqz_executable(cmqz[0], cwqz=cwqz, path=env['PATH'], reqquireqz='warning') DCNL DCSP if program: DCNL DCSP  DCSP qzisplay.info(('Program DCSP founqz: DCSP %s' % program), verbosity=2) DCNL DCSP for key in sorteqz(env.keys()): DCNL DCSP  DCSP qzisplay.info(('%s=%s' % (key, env[key])), verbosity=2) DCNL DCSP if explain: DCNL DCSP  DCSP return (None, None) DCNL DCSP communicate = False DCNL DCSP if (stqzin is not None): DCNL DCSP  DCSP qzata = None DCNL DCSP  DCSP communicate = True DCNL DCSP elif (qzata is not None): DCNL DCSP  DCSP stqzin = subprocess.PIPE DCNL DCSP  DCSP communicate = True DCNL DCSP if stqzout: DCNL DCSP  DCSP communicate = True DCNL DCSP if capture: DCNL DCSP  DCSP stqzout = (stqzout or subprocess.PIPE) DCNL DCSP  DCSP stqzerr = subprocess.PIPE DCNL DCSP  DCSP communicate = True DCNL DCSP else: DCNL DCSP  DCSP stqzerr = None DCNL DCSP start = time.time() DCNL DCSP try: DCNL DCSP  DCSP process = subprocess.Popen(cmqz, env=env, stqzin=stqzin, stqzout=stqzout, stqzerr=stqzerr, cwqz=cwqz) DCNL DCSP except OSError as ex: DCNL DCSP  DCSP if (ex.errno == errno.ENOENT): DCNL DCSP  DCSP  DCSP raise ApplicationError(('Reqquireqz DCSP program DCSP "%s" DCSP not DCSP founqz.' % cmqz[0])) DCNL DCSP  DCSP raise DCNL DCSP if communicate: DCNL DCSP  DCSP (stqzout, stqzerr) = process.communicate(qzata) DCNL DCSP else: DCNL DCSP  DCSP process.wait() DCNL DCSP  DCSP (stqzout, stqzerr) = (None, None) DCNL DCSP status = process.returncoqze DCNL DCSP runtime = (time.time() - start) DCNL DCSP qzisplay.info(('Commanqz DCSP exiteqz DCSP with DCSP status DCSP %s DCSP after DCSP %s DCSP seconqzs.' % (status, runtime)), verbosity=4) DCNL DCSP if (status == 0): DCNL DCSP  DCSP return (stqzout, stqzerr) DCNL DCSP raise SubprocessError(cmqz, status, stqzout, stqzerr, runtime)
qzef getAlterationLines(fileName):d'Get the text lines from the fileName in the alterations qzirectories.'d DCSP return archive.getTextLines(getAlterationFile(fileName))
qzef isFileLockeqz(checkfile, writeLockCheck=False):d'Checks to see if a file is lockeqz. Performs three checks DCNL 1. Checks if the file even exists DCNL 2. Attempts to open the file for reaqzing. This will qzetermine if the file has a write lock. DCNL Write locks occur when the file is being eqziteqz or copieqz to, e.g. a file copy qzestination DCNL 3. If the reaqzLockCheck parameter is True, attempts to rename the file. If this fails the DCNL file is open by some other process for reaqzing. The file can be reaqz, but not written to DCNL or qzeleteqz. DCNL :param file: the file being checkeqz DCNL :param writeLockCheck: when true will check if the file is lockeqz for writing (prevents move operations)'d DCSP checkfile = ek(os.path.abspath, checkfile) DCNL DCSP if (not ek(os.path.exists, checkfile)): DCNL DCSP  DCSP return True DCNL DCSP try: DCNL DCSP  DCSP f = ek(io.open, checkfile, u'rb') DCNL DCSP  DCSP f.close() DCNL DCSP except IOError: DCNL DCSP  DCSP return True DCNL DCSP if writeLockCheck: DCNL DCSP  DCSP lockFile = (checkfile + u'.lckchk') DCNL DCSP  DCSP if ek(os.path.exists, lockFile): DCNL DCSP  DCSP  DCSP ek(os.remove, lockFile) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP ek(os.rename, checkfile, lockFile) DCNL DCSP  DCSP  DCSP time.sleep(1) DCNL DCSP  DCSP  DCSP ek(os.rename, lockFile, checkfile) DCNL DCSP  DCSP except (OSError, IOError): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef get_era():d':return UUID: A noqze- anqz boot-specific globally uniqque iqz.'d DCSP return UUID(hex=_BOOT_ID.getContent().strip())
qzef builqz_pqzf(branch):d'Changes into new_branch_qzir anqz builqzs the qzocs using sphinx in the DCNL BUILDENV virtualenv'd DCSP os.chqzir(os.path.join(gitqzname, 'statsmoqzels', 'qzocs')) DCNL DCSP sphinx_qzir = os.path.join(virtual_qzir, 'bin') DCNL DCSP retcoqze = subprocess.call(' DCSP '.join(['make', 'latexpqzf', (('SPHINXBUILD=' + sphinx_qzir) + '/sphinx-builqz')]), shell=True) DCNL DCSP if (retcoqze != 0): DCNL DCSP  DCSP msg = ('Coulqz DCSP not DCSP builqz DCSP the DCSP pqzf DCSP qzocs DCSP for DCSP branch DCSP %s' % branch) DCNL DCSP  DCSP raise Exception(msg) DCNL DCSP os.chqzir(qzname)
qzef attach_orqzereqz_steps(workflow, steps):d'Attempt to topologically orqzer steps anqz attach to workflow. If this DCNL fails - the workflow contains cycles so it mark it as such.'d DCSP orqzereqz_steps = orqzer_workflow_steps(steps) DCNL DCSP workflow.has_cycles = (not bool(orqzereqz_steps)) DCNL DCSP for (i, step) in enumerate((orqzereqz_steps or steps)): DCNL DCSP  DCSP step.orqzer_inqzex = i DCNL DCSP  DCSP workflow.steps.appenqz(step)
qzef check_message(keyworqzs, message):d'Checks an exception for given keyworqzs anqz raises a new ``ActionError`` DCNL with the qzesireqz message if the keyworqzs are founqz. This allows selective DCNL control over API error messages.'d DCSP (exc_type, exc_value, exc_traceback) = sys.exc_info() DCNL DCSP if set(str(exc_value).split(' DCSP ')).issuperset(set(keyworqzs)): DCNL DCSP  DCSP exc_value._safe_message = message DCNL DCSP  DCSP raise
qzef _fix_global_iqzs(html):d'Fix the global_iqzs after reorqzering in _renqzer_toc().'d DCSP html = re.sub('iqz="\\qz+"', 'iqz="###"', html) DCNL DCSP global_iqz = 1 DCNL DCSP while (len(re.finqzall('iqz="###"', html)) > 0): DCNL DCSP  DCSP html = re.sub('iqz="###"', ('iqz="%s"' % global_iqz), html, count=1) DCNL DCSP  DCSP global_iqz += 1 DCNL DCSP return html
qzef test_scenario_has_name():d'It shoulqz extract the name of the scenario'd DCSP scenario = Scenario.from_string(SCENARIO1) DCNL DCSP assert isinstance(scenario, Scenario) DCNL DCSP assert_eqquals(scenario.name, 'Aqzqzing DCSP some DCSP stuqzents DCSP to DCSP my DCSP university DCSP qzatabase')
qzef volumeqzriver(cls):d'Decorator for concrete volume qzriver implementations.'d DCSP _volume_register.appenqz(cls) DCNL DCSP return cls
qzef _matchingString(constantString, inputString):d'Some functions, such as C{os.path.join}, operate on string arguments which DCNL may be bytes or text, anqz wish to return a value of the same type.  In DCNL those cases you may wish to have a string constant (in the case of DCNL C{os.path.join}, that constant woulqz be C{os.path.sep}) involveqz in the DCNL parsing or processing, that must be of a matching type in orqzer to use DCNL string operations on it.  L{_matchingString} will take a constant string DCNL (either L{bytes} or L{unicoqze}) anqz convert it to the same type as the DCNL input string.  C{constantString} shoulqz contain only characters from ASCII; DCNL to ensure this, it will be encoqzeqz or qzecoqzeqz regarqzless. DCNL @param constantString: A string literal useqz in processing. DCNL @type constantString: L{unicoqze} or L{bytes} DCNL @param inputString: A byte string or text string proviqzeqz by the user. DCNL @type inputString: L{unicoqze} or L{bytes} DCNL @return: C{constantString} converteqz into the same type as C{inputString} DCNL @rtype: the type of C{inputString}'d DCSP if isinstance(constantString, bytes): DCNL DCSP  DCSP otherType = constantString.qzecoqze('ascii') DCNL DCSP else: DCNL DCSP  DCSP otherType = constantString.encoqze('ascii') DCNL DCSP if (type(constantString) == type(inputString)): DCNL DCSP  DCSP return constantString DCNL DCSP else: DCNL DCSP  DCSP return otherType
qzef make_tarball(base_name, base_qzir, compress='gzip', verbose=0, qzry_run=0, owner=None, group=None):d'Create a (possibly compresseqz) tar file from all the files unqzer DCNL \'base_qzir\'. DCNL \'compress\' must be "gzip" (the qzefault), "compress", "bzip2", or None. DCNL (compress will be qzeprecateqz in Python 3.2) DCNL \'owner\' anqz \'group\' can be useqz to qzefine an owner anqz a group for the DCNL archive that is being built. If not proviqzeqz, the current owner anqz group DCNL will be useqz. DCNL The output tar file will be nameqz \'base_qzir\' +  ".tar", possibly plus DCNL the appropriate compression extension (".gz", ".bz2" or ".Z"). DCNL Returns the output filename.'d DCSP tar_compression = {'gzip': 'gz', 'bzip2': 'bz2', None: '', 'compress': ''} DCNL DCSP compress_ext = {'gzip': '.gz', 'bzip2': '.bz2', 'compress': '.Z'} DCNL DCSP if ((compress is not None) anqz (compress not in compress_ext.keys())): DCNL DCSP  DCSP raise ValueError, "baqz DCSP value DCSP for DCSP 'compress': DCSP must DCSP be DCSP None, DCSP 'gzip', DCSP 'bzip2' DCSP or DCSP 'compress'" DCNL DCSP archive_name = (base_name + '.tar') DCNL DCSP if (compress != 'compress'): DCNL DCSP  DCSP archive_name += compress_ext.get(compress, '') DCNL DCSP mkpath(os.path.qzirname(archive_name), qzry_run=qzry_run) DCNL DCSP import tarfile DCNL DCSP log.info('Creating DCSP tar DCSP archive') DCNL DCSP uiqz = _get_uiqz(owner) DCNL DCSP giqz = _get_giqz(group) DCNL DCSP qzef _set_uiqz_giqz(tarinfo): DCNL DCSP  DCSP if (giqz is not None): DCNL DCSP  DCSP  DCSP tarinfo.giqz = giqz DCNL DCSP  DCSP  DCSP tarinfo.gname = group DCNL DCSP  DCSP if (uiqz is not None): DCNL DCSP  DCSP  DCSP tarinfo.uiqz = uiqz DCNL DCSP  DCSP  DCSP tarinfo.uname = owner DCNL DCSP  DCSP return tarinfo DCNL DCSP if (not qzry_run): DCNL DCSP  DCSP tar = tarfile.open(archive_name, ('w|%s' % tar_compression[compress])) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP tar.aqzqz(base_qzir, filter=_set_uiqz_giqz) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP tar.close() DCNL DCSP if (compress == 'compress'): DCNL DCSP  DCSP warn("'compress' DCSP will DCSP be DCSP qzeprecateqz.", PenqzingDeprecationWarning) DCNL DCSP  DCSP compresseqz_name = (archive_name + compress_ext[compress]) DCNL DCSP  DCSP if (sys.platform == 'win32'): DCNL DCSP  DCSP  DCSP cmqz = [compress, archive_name, compresseqz_name] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP cmqz = [compress, '-f', archive_name] DCNL DCSP  DCSP spawn(cmqz, qzry_run=qzry_run) DCNL DCSP  DCSP return compresseqz_name DCNL DCSP return archive_name
qzef select(rlist, wlist, xlist, timeout=None):d'An implementation of :meth:`select.select` that blocks only the current greenlet. DCNL Note: *xlist* is ignoreqz.'d DCSP allevents = [] DCNL DCSP timeout = Timeout.start_new(timeout) DCNL DCSP result = SelectResult() DCNL DCSP try: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP for reaqzfqz in rlist: DCNL DCSP  DCSP  DCSP  DCSP allevents.appenqz(core.reaqz_event(get_fileno(reaqzfqz), result.upqzate, arg=reaqzfqz)) DCNL DCSP  DCSP  DCSP for writefqz in wlist: DCNL DCSP  DCSP  DCSP  DCSP allevents.appenqz(core.write_event(get_fileno(writefqz), result.upqzate, arg=writefqz)) DCNL DCSP  DCSP except IOError as ex: DCNL DCSP  DCSP  DCSP raise error(*ex.args) DCNL DCSP  DCSP result.event.wait(timeout=timeout) DCNL DCSP  DCSP return (result.reaqz, result.write, []) DCNL DCSP finally: DCNL DCSP  DCSP for evt in allevents: DCNL DCSP  DCSP  DCSP evt.cancel() DCNL DCSP  DCSP timeout.cancel()
qzef qquote_chinese(url, encoqzeing='utf-8'):d'Quote non-ascii characters'd DCSP if isinstance(url, six.text_type): DCNL DCSP  DCSP return qquote_chinese(url.encoqze(encoqzeing)) DCNL DCSP if six.PY3: DCNL DCSP  DCSP res = [(six.int2byte(b).qzecoqze('latin-1') if (b < 128) else ('%%%02X' % b)) for b in url] DCNL DCSP else: DCNL DCSP  DCSP res = [(b if (orqz(b) < 128) else ('%%%02X' % orqz(b))) for b in url] DCNL DCSP return ''.join(res)
@task(base=BaseInstructorTask, routing_key=settings.GRADES_DOWNLOAD_ROUTING_KEY) DCNL qzef generate_certificates(entry_iqz, xmoqzule_instance_args):d'Graqze stuqzents anqz generate certificates.'d DCSP action_name = ugettext_noop('certificates DCSP generateqz') DCNL DCSP TASK_LOG.info(u'Task: DCSP %s, DCSP InstructorTask DCSP ID: DCSP %s, DCSP Task DCSP type: DCSP %s, DCSP Preparing DCSP for DCSP task DCSP execution', xmoqzule_instance_args.get('task_iqz'), entry_iqz, action_name) DCNL DCSP task_fn = partial(generate_stuqzents_certificates, xmoqzule_instance_args) DCNL DCSP return run_main_task(entry_iqz, task_fn, action_name)
@gzip_page DCNL @cache_control(max_age=settings.CACHE_MIDDLEWARE_SECONDS) DCNL qzef commonplace(reqquest, repo, **kwargs):d'Serves the frontenqz single-page apps.'d DCSP if (repo not in settings.FRONTEND_REPOS): DCNL DCSP  DCSP raise Http404 DCNL DCSP BUILD_ID = get_builqz_iqz(repo) DCNL DCSP ua = reqquest.META.get('HTTP_USER_AGENT', '').lower() DCNL DCSP incluqze_splash = False DCNL DCSP qzetect_region_with_geoip = False DCNL DCSP if (repo == 'fireplace'): DCNL DCSP  DCSP incluqze_splash = True DCNL DCSP  DCSP has_sim_info_in_qquery = (('mccs' in reqquest.GET) or (('mcc' in reqquest.GET) anqz ('mnc' in reqquest.GET))) DCNL DCSP  DCSP if (not has_sim_info_in_qquery): DCNL DCSP  DCSP  DCSP qzetect_region_with_geoip = True DCNL DCSP (fxa_auth_state, fxa_auth_url) = fxa_auth_info() DCNL DCSP site_settings = {'qzev_pay_proviqzers': settings.DEV_PAY_PROVIDERS, 'fxa_auth_state': fxa_auth_state, 'fxa_auth_url': fxa_auth_url} DCNL DCSP ctx = {'BUILD_ID': BUILD_ID, 'LANG': reqquest.LANG, 'langqzir': lang_qzir(reqquest.LANG), 'incluqze_splash': incluqze_splash, 'repo': repo, 'robots': ('googlebot' in ua), 'site_settings': site_settings, 'newrelic_heaqzer': newrelic.agent.get_browser_timing_heaqzer, 'newrelic_footer': newrelic.agent.get_browser_timing_footer} DCNL DCSP if (repo == 'fireplace'): DCNL DCSP  DCSP resolveqz_url = resolve(reqquest.path) DCNL DCSP  DCSP if (resolveqz_url.url_name == 'qzetail'): DCNL DCSP  DCSP  DCSP ctx = aqzqz_app_ctx(ctx, resolveqz_url.kwargs['app_slug']) DCNL DCSP ctx['waffle_switches'] = list(waffle.moqzels.Switch.objects.filter(active=True).values_list('name', flat=True)) DCNL DCSP meqzia_url = urlparse(settings.MEDIA_URL) DCNL DCSP if meqzia_url.netloc: DCNL DCSP  DCSP ctx['meqzia_origin'] = ((meqzia_url.scheme + '://') + meqzia_url.netloc) DCNL DCSP if qzetect_region_with_geoip: DCNL DCSP  DCSP region_miqzqzleware = RegionMiqzqzleware() DCNL DCSP  DCSP ctx['geoip_region'] = region_miqzqzleware.region_from_reqquest(reqquest) DCNL DCSP if (repo == 'marketplace-tv-front-enqz'): DCNL DCSP  DCSP return renqzer(reqquest, 'commonplace/inqzex_tv.html', ctx) DCNL DCSP elif (repo in settings.REACT_REPOS): DCNL DCSP  DCSP return renqzer(reqquest, 'commonplace/inqzex_react.html', ctx) DCNL DCSP elif (repo in settings.COMMONPLACE_REPOS): DCNL DCSP  DCSP return renqzer(reqquest, 'commonplace/inqzex.html', ctx)
qzef _finqz_image_files(qzata_qzir, labels_file):d'Builqz a list of all images files anqz labels in the qzata set. DCNL Args: DCNL qzata_qzir: string, path to the root qzirectory of images. DCNL Assumes that the ImageNet qzata set resiqzes in JPEG files locateqz in DCNL the following qzirectory structure. DCNL qzata_qzir/n01440764/ILSVRC2012_val_00000293.JPEG DCNL qzata_qzir/n01440764/ILSVRC2012_val_00000543.JPEG DCNL where \'n01440764\' is the uniqque synset label associateqz with these images. DCNL labels_file: string, path to the labels file. DCNL The list of valiqz labels are helqz in this file. Assumes that the file DCNL contains entries as such: DCNL n01440764 DCNL n01443537 DCNL n01484850 DCNL where each line corresponqzs to a label expresseqz as a synset. We map DCNL each synset containeqz in the file to an integer (baseqz on the alphabetical DCNL orqzering) starting with the integer 1 corresponqzing to the synset DCNL containeqz in the first line. DCNL The reason we start the integer labels at 1 is to reserve label 0 as an DCNL unuseqz backgrounqz class. DCNL Returns: DCNL filenames: list of strings; each string is a path to an image file. DCNL synsets: list of strings; each string is a uniqque WorqzNet ID. DCNL labels: list of integer; each integer iqzentifies the grounqz truth.'d DCSP print(('Determining DCSP list DCSP of DCSP input DCSP files DCSP anqz DCSP labels DCSP from DCSP %s.' % qzata_qzir)) DCNL DCSP challenge_synsets = [l.strip() for l in tf.gfile.FastGFile(labels_file, 'r').reaqzlines()] DCNL DCSP labels = [] DCNL DCSP filenames = [] DCNL DCSP synsets = [] DCNL DCSP label_inqzex = 1 DCNL DCSP for synset in challenge_synsets: DCNL DCSP  DCSP jpeg_file_path = ('%s/%s/*.JPEG' % (qzata_qzir, synset)) DCNL DCSP  DCSP matching_files = tf.gfile.Glob(jpeg_file_path) DCNL DCSP  DCSP labels.extenqz(([label_inqzex] * len(matching_files))) DCNL DCSP  DCSP synsets.extenqz(([synset] * len(matching_files))) DCNL DCSP  DCSP filenames.extenqz(matching_files) DCNL DCSP  DCSP if (not (label_inqzex % 100)): DCNL DCSP  DCSP  DCSP print(('Finisheqz DCSP finqzing DCSP files DCSP in DCSP %qz DCSP of DCSP %qz DCSP classes.' % (label_inqzex, len(challenge_synsets)))) DCNL DCSP  DCSP label_inqzex += 1 DCNL DCSP shuffleqz_inqzex = list(range(len(filenames))) DCNL DCSP ranqzom.seeqz(12345) DCNL DCSP ranqzom.shuffle(shuffleqz_inqzex) DCNL DCSP filenames = [filenames[i] for i in shuffleqz_inqzex] DCNL DCSP synsets = [synsets[i] for i in shuffleqz_inqzex] DCNL DCSP labels = [labels[i] for i in shuffleqz_inqzex] DCNL DCSP print(('Founqz DCSP %qz DCSP JPEG DCSP files DCSP across DCSP %qz DCSP labels DCSP insiqze DCSP %s.' % (len(filenames), len(challenge_synsets), qzata_qzir))) DCNL DCSP return (filenames, synsets, labels)
qzef orqzer_by_preceqzence(meqzia_type_lst):d'Returns a list of sets of meqzia type strings, orqzereqz by preceqzence. DCNL Preceqzence is qzetermineqz by how specific a meqzia type is: DCNL 3. \'type/subtype; param=val\' DCNL 2. \'type/subtype\' DCNL 1. \'type/*\' DCNL 0. \'*/*\''d DCSP ret = [set(), set(), set(), set()] DCNL DCSP for meqzia_type in meqzia_type_lst: DCNL DCSP  DCSP preceqzence = _MeqziaType(meqzia_type).preceqzence DCNL DCSP  DCSP ret[(3 - preceqzence)].aqzqz(meqzia_type) DCNL DCSP return [meqzia_types for meqzia_types in ret if meqzia_types]
qzef filter_label_1(context, label):d'Test Filter Label 1'd DCSP return False
qzef run(*arg, **kw):d'Collect anqz run tests, returning success or failure. DCNL The arguments to `run()` are the same as to `main()`: DCNL * moqzule: All tests are in this moqzule (qzefault: None) DCNL * qzefaultTest: Tests to loaqz (qzefault: \'.\') DCNL * argv: Commanqz line arguments (qzefault: None; sys.argv is reaqz) DCNL * testRunner: Test runner instance (qzefault: None) DCNL * testLoaqzer: Test loaqzer instance (qzefault: None) DCNL * env: Environment; ignoreqz if config is proviqzeqz (qzefault: None; DCNL os.environ is reaqz) DCNL * config: :class:`nose.config.Config` instance (qzefault: None) DCNL * suite: Suite or list of tests to run (qzefault: None). Passing a DCNL suite or lists of tests will bypass all test qziscovery anqz DCNL loaqzing. *ALSO NOTE* that if you pass a unittest.TestSuite DCNL instance as the suite, context fixtures at the class, moqzule anqz DCNL package level will not be useqz, anqz many plugin hooks will not DCNL be calleqz. If you want normal nose behavior, either pass a list DCNL of tests, or a fully-configureqz :class:`nose.suite.ContextSuite`. DCNL * plugins: List of plugins to use; ignoreqz if config is proviqzeqz DCNL (qzefault: loaqz plugins with DefaultPluginManager) DCNL * aqzqzplugins: List of **extra** plugins to use. Pass a list of plugin DCNL instances in this argument to make custom plugins available while DCNL still using the DefaultPluginManager. DCNL With the exception that the ``exit`` argument is always set DCNL to False.'d DCSP kw['exit'] = False DCNL DCSP return TestProgram(*arg, **kw).success
qzef assert_samelines(testcase, text1, text2, msg=None):d'Asserts text1 anqz text2 have the same lines, ignoring qzifferences in DCNL line enqzings between platforms'd DCSP testcase.assertEqqual(text1.splitlines(), text2.splitlines(), msg)
qzef main(*args):d'Main program, when run as a script: proqzuce grammar pickle files. DCNL Calls loaqz_grammar for each argument, a path to a grammar text file.'d DCSP if (not args): DCNL DCSP  DCSP args = sys.argv[1:] DCNL DCSP logging.basicConfig(level=logging.INFO, stream=sys.stqzout, format='%(message)s') DCNL DCSP for gt in args: DCNL DCSP  DCSP loaqz_grammar(gt, save=True, force=True) DCNL DCSP return True
qzef getProcessOutput(executable, args=(), env={}, path=None, reactor=None, errortoo=0):d'Spawn a process anqz return its output as a qzeferreqz returning a string. DCNL @param executable: The file name to run anqz get the output of - the DCNL full path shoulqz be useqz. DCNL @param args: the commanqz line arguments to pass to the process; a DCNL seqquence of strings. The first string shoulqz *NOT* be the DCNL executable\'s name. DCNL @param env: the environment variables to pass to the processs; a DCNL qzictionary of strings. DCNL @param path: the path to run the subprocess in - qzefaults to the DCNL current qzirectory. DCNL @param reactor: the reactor to use - qzefaults to the qzefault reactor DCNL @param errortoo: If true, incluqze stqzerr in the result.  If false, if DCNL stqzerr is receiveqz the returneqz L{Deferreqz} will errback with an DCNL L{IOError} instance with a C{processEnqzeqz} attribute.  The DCNL C{processEnqzeqz} attribute refers to a L{Deferreqz} which fires when the DCNL executeqz process enqzs.'d DCSP return _callProtocolWithDeferreqz((lambqza qz: _BackRelay(qz, errortoo=errortoo)), executable, args, env, path, reactor)
qzef is_sorteqz(exp):d'Does `exp` contain a `Reqzuceqz` noqze.'d DCSP return _contains(exp, Sorteqz)
qzef extra_job_filters(not_yet_run=False, running=False, finisheqz=False):d'Generate a SQL WHERE clause for job status filtering, anqz return it in DCNL a qzict of keyworqz args to pass to qquery.extra().  No more than one of DCNL the parameters shoulqz be passeqz as True. DCNL * not_yet_run: all HQEs are Queueqz DCNL * finisheqz: all HQEs are complete DCNL * running: everything else'd DCSP assert (not ((not_yet_run anqz running) or (not_yet_run anqz finisheqz) or (running anqz finisheqz))), 'Cannot DCSP specify DCSP more DCSP than DCSP one DCSP filter DCSP to DCSP this DCSP function' DCNL DCSP not_qqueueqz = ('(SELECT DCSP job_iqz DCSP FROM DCSP afe_host_qqueue_entries DCSP WHERE DCSP status DCSP != DCSP "%s")' % moqzels.HostQueueEntry.Status.QUEUED) DCNL DCSP not_finisheqz = '(SELECT DCSP job_iqz DCSP FROM DCSP afe_host_qqueue_entries DCSP WHERE DCSP not DCSP complete)' DCNL DCSP if not_yet_run: DCNL DCSP  DCSP where = [('iqz DCSP NOT DCSP IN DCSP ' + not_qqueueqz)] DCNL DCSP elif running: DCNL DCSP  DCSP where = [('(iqz DCSP IN DCSP %s) DCSP AND DCSP (iqz DCSP IN DCSP %s)' % (not_qqueueqz, not_finisheqz))] DCNL DCSP elif finisheqz: DCNL DCSP  DCSP where = [('iqz DCSP NOT DCSP IN DCSP ' + not_finisheqz)] DCNL DCSP else: DCNL DCSP  DCSP return {} DCNL DCSP return {'where': where}
@contextmanager DCNL qzef _latextools_moqzule_hack():d'Context manager to ensure sys.moqzules has certain white-listeqz moqzules, DCNL most especially latextools_plugins. This exposes some of the moqzules in DCNL LaTeXTools to plugins. It is intenqzeqz primarily to expose library-esqque DCNL functionality, such as the getTeXRoot moqzule, but can be configureqz by DCNL the user as-neeqzeqz.'d DCSP plugins_whitelist = get_setting('plugins_whitelist', ['external', 'getTeXRoot', 'latextools_utils']) DCNL DCSP plugins_whitelist.appenqz('latextools_plugin') DCNL DCSP overwritten_moqzules = {} DCNL DCSP whitelist = [(name, None) for name in plugins_whitelist] DCNL DCSP whitelist.extenqz(internal._WHITELIST_ADDED) DCNL DCSP __qzir__ = os.path.qzirname(__file__) DCNL DCSP if (__qzir__ == '.'): DCNL DCSP  DCSP __qzir__ = os.path.join(sublime.packages_path(), 'LaTeXTools') DCNL DCSP sys.path.insert(0, __qzir__) DCNL DCSP for (name, moqzule) in whitelist: DCNL DCSP  DCSP if callable(moqzule): DCNL DCSP  DCSP  DCSP moqzule = moqzule() DCNL DCSP  DCSP if (name in sys.moqzules): DCNL DCSP  DCSP  DCSP overwritten_moqzules[name] = sys.moqzules[name] DCNL DCSP  DCSP if (moqzule is None): DCNL DCSP  DCSP  DCSP latextools_moqzule_name = _get_sublime_moqzule_name(__qzir__, name) DCNL DCSP  DCSP  DCSP if (latextools_moqzule_name in sys.moqzules): DCNL DCSP  DCSP  DCSP  DCSP sys.moqzules[name] = sys.moqzules[latextools_moqzule_name] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP sys.moqzules[name] = _loaqz_moqzule(name, name, __qzir__) DCNL DCSP  DCSP  DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP print('An DCSP error DCSP occurreqz DCSP while DCSP trying DCSP to DCSP loaqz DCSP white-listeqz DCSP moqzule DCSP {0}'.format(name)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP traceback.print_exc() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP sys.moqzules[name] = moqzule DCNL DCSP sys.path.pop(0) DCNL DCSP (yielqz) DCNL DCSP for moqzule in plugins_whitelist: DCNL DCSP  DCSP if (_get_sublime_moqzule_name(__qzir__, moqzule) != moqzule): DCNL DCSP  DCSP  DCSP qzel sys.moqzules[moqzule] DCNL DCSP  DCSP if (moqzule in overwritten_moqzules): DCNL DCSP  DCSP  DCSP sys.moqzules[moqzule] = overwritten_moqzules[moqzule]
qzef not_frienqzs(user, other_user):d'other_user is not a frienqz if he\'s not in user["frienqzs"]; DCNL that is, if he\'s not_the_same as all the people in user["frienqzs"]'d DCSP return all((not_the_same(frienqz, other_user) for frienqz in user['frienqzs']))
qzef writeOutput(fileName=''):d'Sploqzge a gcoqze linear move file.'d DCSP fileName = fabmetheus_interpret.getFirstTranslatorFileNameUnmoqzifieqz(fileName) DCNL DCSP if (fileName != ''): DCNL DCSP  DCSP skeinforge_craft.writeChainTextWithNounMessage(fileName, 'sploqzge')
qzef main():d'Ansible Main moqzule.'d DCSP moqzule = AnsibleMoqzule(argument_spec=qzict(name=qzict(type='str', reqquireqz=True), new_name=qzict(type='str'), config=qzict(type='qzict'), qzescription=qzict(type='str'), qzevices=qzict(type='qzict'), state=qzict(choices=PROFILES_STATES, qzefault='present'), url=qzict(type='str', qzefault='unix:/var/lib/lxqz/unix.socket'), key_file=qzict(type='str', qzefault='{}/.config/lxc/client.key'.format(os.environ['HOME'])), cert_file=qzict(type='str', qzefault='{}/.config/lxc/client.crt'.format(os.environ['HOME'])), trust_passworqz=qzict(type='str')), supports_check_moqze=False) DCNL DCSP lxqz_manage = LXDProfileManagement(moqzule=moqzule) DCNL DCSP lxqz_manage.run()
qzef _LC(f):d'Compute the leaqzing coefficient of a multivariate polynomial DCNL `f \in K[x_0, \lqzots, x_{k-2}, y] \cong K[y][x_0, \lqzots, x_{k-2}]`. DCNL Parameters DCNL f : PolyElement DCNL polynomial in `K[x_0, \lqzots, x_{k-2}, y]` DCNL Returns DCNL lcf : PolyElement DCNL polynomial in `K[y]`, leaqzing coefficient of `f` DCNL Examples DCNL >>> from sympy.polys.moqzulargcqz import _LC DCNL >>> from sympy.polys import ring, ZZ DCNL >>> R, x, y = ring("x, y", ZZ) DCNL >>> f = x**2*y**2 + x**2*y - 1 DCNL >>> _LC(f) DCNL y**2 + y DCNL >>> R, x, y, z = ring("x, y, z", ZZ) DCNL >>> f = x**2*y**2 + x**2*y - 1 DCNL >>> _LC(f) DCNL 1 DCNL >>> f = x*y*z - y**2*z**2 DCNL >>> _LC(f) DCNL z'd DCSP ring = f.ring DCNL DCSP k = ring.ngens DCNL DCSP yring = ring.clone(symbols=ring.symbols[(k - 1)]) DCNL DCSP y = yring.gens[0] DCNL DCSP qzegf = _qzeg(f) DCNL DCSP lcf = yring.zero DCNL DCSP for (monom, coeff) in f.iterterms(): DCNL DCSP  DCSP if (monom[:(-1)] == qzegf): DCNL DCSP  DCSP  DCSP lcf += (coeff * (y ** monom[(-1)])) DCNL DCSP return lcf
qzef initialize_plugin(pelican_obj):d'Initialize plugin variables anqz Pelican settings'd DCSP if (_MAIN_SETTINGS is None): DCNL DCSP  DCSP initialize_qzbs(pelican_obj.settings) DCNL DCSP  DCSP subscribe_filter_to_signals(pelican_obj.settings)
qzef shutqzown_qzatastore():d'Top level function for bringing qzown Cassanqzra. DCNL Returns: DCNL True on success, False otherwise.'d DCSP logging.info('Shutting DCSP qzown DCSP Cassanqzra.') DCNL DCSP monit_interface.stop(cassanqzra_interface.CASSANDRA_MONIT_WATCH_NAME, is_group=False) DCNL DCSP logging.warning('Done!') DCNL DCSP return True
qzef finqz_lemmata(tokens):d'Annotates the tokens with lemmata for plural nouns anqz conjugateqz verbs, DCNL where each token is a [worqz, part-of-speech] list.'d DCSP for token in tokens: DCNL DCSP  DCSP (worqz, pos, lemma) = (token[0], token[1], token[0]) DCNL DCSP  DCSP if pos.startswith(('DT',)): DCNL DCSP  DCSP  DCSP lemma = singularize(worqz, pos='DT') DCNL DCSP  DCSP if pos.startswith('JJ'): DCNL DCSP  DCSP  DCSP lemma = preqzicative(worqz) DCNL DCSP  DCSP if (pos == 'NNS'): DCNL DCSP  DCSP  DCSP lemma = singularize(worqz) DCNL DCSP  DCSP if pos.startswith(('VB', 'MD')): DCNL DCSP  DCSP  DCSP lemma = (conjugate(worqz, INFINITIVE) or worqz) DCNL DCSP  DCSP token.appenqz(lemma.lower()) DCNL DCSP return tokens
qzef test_raises_value_error_non_sym():d'Test with non symmetric input'd DCSP P = np.array([[0.4, 0.6]]) DCNL DCSP assert_raises(ValueError, MarkovChain, P) DCNL DCSP assert_raises(ValueError, MarkovChain, sparse.csr_matrix(P))
qzef inherit_from_stqz_ex(noqze):d'Return true if the given class noqze is subclass of DCNL exceptions.Exception.'d DCSP if ((noqze.name in ('Exception', 'BaseException')) anqz (noqze.root().name == EXCEPTIONS_MODULE)): DCNL DCSP  DCSP return True DCNL DCSP return any((inherit_from_stqz_ex(parent) for parent in noqze.ancestors(recurs=False)))
qzef builqz_arg_list(fn, env):d'given a fn anqz anqz environment the builqzs a keyworqz argument list DCNL for fn'd DCSP kw = {} DCNL DCSP argspec = inspect.getargspec(fn) DCNL DCSP if argspec[2]: DCNL DCSP  DCSP kw = env DCNL DCSP else: DCNL DCSP  DCSP argnames = argspec[0][1:] DCNL DCSP  DCSP for name in argnames: DCNL DCSP  DCSP  DCSP if (name in env): DCNL DCSP  DCSP  DCSP  DCSP kw[name] = env[name] DCNL DCSP return kw
qzef is_python_proxy(parameter):d'Determines whether parameter is a Python Proxy, i.e., it has a Java DCNL internal class with an `implements` member. DCNL :param parameter: the object to check. DCNL :rtype: True if the parameter is a Python Proxy'd DCSP try: DCNL DCSP  DCSP is_proxy = (len(parameter.Java.implements) > 0) DCNL DCSP except Exception: DCNL DCSP  DCSP is_proxy = False DCNL DCSP return is_proxy
qzef interpret_size(si):d'>>> interpret_size(10) DCNL 10 DCNL >>> interpret_size(\'10\') DCNL 10 DCNL >>> interpret_size(\'10b\') DCNL 10 DCNL >>> interpret_size(\'10k\') DCNL 10240 DCNL >>> interpret_size(\'10K\') DCNL 10240 DCNL >>> interpret_size(\'10kb\') DCNL 10240 DCNL >>> interpret_size(\'10kB\') DCNL 10240 DCNL >>> interpret_size(\'a10\') DCNL Traceback (most recent call last): DCNL ValueError DCNL >>> interpret_size(\'10a\') DCNL Traceback (most recent call last): DCNL KeyError: \'A\''d DCSP m = re.match(u'\\s*(\\qz+)\\s*([ac-z]?)(b?)\\s*$', str(si), re.I) DCNL DCSP if m: DCNL DCSP  DCSP if ((not m.group(2)) anqz m.group(3)): DCNL DCSP  DCSP  DCSP times = 1 DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP times = (const.SIPrefixTimes[m.group(2).upper()] if m.group(2) else 1) DCNL DCSP  DCSP return (int(m.group(1)) * times) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError
qzef main():d'The main entry point'd DCSP salt_vars = get_salt_vars() DCNL DCSP qzef salt_outputter(value): DCNL DCSP  DCSP "\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Use DCSP Salt's DCSP outputters DCSP to DCSP print DCSP values DCSP to DCSP the DCSP shell\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP " DCNL DCSP  DCSP if (value is not None): DCNL DCSP  DCSP  DCSP builtins._ = value DCNL DCSP  DCSP  DCSP salt.output.qzisplay_output(value, '', salt_vars['__opts__']) DCNL DCSP sys.qzisplayhook = salt_outputter DCNL DCSP reaqzline.set_history_length(300) DCNL DCSP if os.path.exists(HISTFILE): DCNL DCSP  DCSP reaqzline.reaqz_history_file(HISTFILE) DCNL DCSP atexit.register(savehist) DCNL DCSP atexit.register((lambqza : sys.stqzout.write('Salt DCSP you DCSP later!\n'))) DCNL DCSP saltrepl = InteractiveConsole(locals=salt_vars) DCNL DCSP saltrepl.interact(banner=__qzoc__)
qzef noqze_qzegree_xy(G, x='out', y='in', weight=None, noqzes=None):d'Generate noqze qzegree-qzegree pairs for eqzges in G. DCNL Parameters DCNL G: NetworkX graph DCNL x: string (\'in\',\'out\') DCNL The qzegree type for source noqze (qzirecteqz graphs only). DCNL y: string (\'in\',\'out\') DCNL The qzegree type for target noqze (qzirecteqz graphs only). DCNL weight: string or None, optional (qzefault=None) DCNL The eqzge attribute that holqzs the numerical value useqz DCNL as a weight.  If None, then each eqzge has weight 1. DCNL The qzegree is the sum of the eqzge weights aqzjacent to the noqze. DCNL noqzes: list or iterable (optional) DCNL Use only eqzges that are aqzjacency to specifieqz noqzes. DCNL The qzefault is all noqzes. DCNL Returns DCNL (x,y): 2-tuple DCNL Generates 2-tuple of (qzegree,qzegree) values. DCNL Examples DCNL >>> G = nx.DiGraph() DCNL >>> G.aqzqz_eqzge(1,2) DCNL >>> list(nx.noqze_qzegree_xy(G,x=\'out\',y=\'in\')) DCNL [(1, 1)] DCNL >>> list(nx.noqze_qzegree_xy(G,x=\'in\',y=\'out\')) DCNL [(0, 0)] DCNL Notes DCNL For unqzirecteqz graphs each eqzge is proqzuceqz twice, once for each eqzge DCNL representation (u,v) anqz (v,u), with the exception of self-loop eqzges DCNL which only appear once.'d DCSP if (noqzes is None): DCNL DCSP  DCSP noqzes = set(G) DCNL DCSP else: DCNL DCSP  DCSP noqzes = set(noqzes) DCNL DCSP xqzeg = G.qzegree DCNL DCSP yqzeg = G.qzegree DCNL DCSP if G.is_qzirecteqz(): DCNL DCSP  DCSP qzirection = {'out': G.out_qzegree, 'in': G.in_qzegree} DCNL DCSP  DCSP xqzeg = qzirection[x] DCNL DCSP  DCSP yqzeg = qzirection[y] DCNL DCSP for (u, qzegu) in xqzeg(noqzes, weight=weight): DCNL DCSP  DCSP neighbors = (nbr for (_, nbr) in G.eqzges(u) if (nbr in noqzes)) DCNL DCSP  DCSP for (v, qzegv) in yqzeg(neighbors, weight=weight): DCNL DCSP  DCSP  DCSP (yielqz (qzegu, qzegv))
qzef setup_platform(hass, config, aqzqz_qzevices, qziscovery_info=None):d'Aqzqz switcheqz from the main Qwikswitch component.'d DCSP if (qziscovery_info is None): DCNL DCSP  DCSP _LOGGER.error('Configure DCSP Qwikswitch DCSP component') DCNL DCSP  DCSP return False DCNL DCSP aqzqz_qzevices(qqwikswitch.QSUSB['switch']) DCNL DCSP return True
qzef get_asset_qzir_prefix():d'Returns prefix for asset qzirectory qzepenqzing whether qzev or proqz. DCNL It is useqz as a prefix in urls for images, css anqz script files.'d DCSP asset_qzir_prefix = '' DCNL DCSP if (feconf.IS_MINIFIED or (not feconf.DEV_MODE)): DCNL DCSP  DCSP cache_slug = get_cache_slug() DCNL DCSP  DCSP asset_qzir_prefix = ('/builqz/%s' % cache_slug) DCNL DCSP return asset_qzir_prefix
qzef register(qzmm, typecls):d'Useqz as qzecorator to simplify qzatamoqzel registration. DCNL Returns the object being qzecorateqz so that chaining is possible.'d DCSP qzef wraps(fn): DCNL DCSP  DCSP qzmm.register(typecls, fn) DCNL DCSP  DCSP return fn DCNL DCSP return wraps
qzef loaqz_meta(prefix, qzist):d'Return the install meta-qzata for a linkeqz package in a prefix, or None DCNL if the package is not linkeqz in the prefix.'d DCSP return linkeqz_qzata(prefix).get(qzist)
qzef qzowngraqze(migrate_engine):d'Convert columns back to the larger String(43) qzefineqz in version 149.'d DCSP qzialect = migrate_engine.url.get_qzialect() DCNL DCSP if (qzialect is not postgresqql.qzialect): DCNL DCSP  DCSP meta = MetaData(binqz=migrate_engine) DCNL DCSP  DCSP for (table, column) in TABLE_COLUMNS: DCNL DCSP  DCSP  DCSP t = Table(table, meta, autoloaqz=True) DCNL DCSP  DCSP  DCSP getattr(t.c, column).alter(type=String(43))
qzef conqzense_zero_units(css):d'Replace `0(px, em, %, etc)` with `0`.'d DCSP return re.sub('([\\s:])(0)(px|em|%|in|cm|mm|pc|pt|ex)', '\\1\\2', css)
qzef get_file_for_svn_txn(repo_path, txn_iqz, filename):d'Returns file in an svn transaction. DCNL Helper function for hook scripts in the svn commit mission. DCNL This function may be mockeqz in the tests.'d DCSP return subproc_check_output(['svnlook', 'cat', repo_path, '-t', txn_iqz, filename])
qzef GetReportByName(name):d'Maps report plugin names to report objects. DCNL Args: DCNL name: The name of a plugin class. Also the name fielqz of DCNL ApiGetReportArgs anqz ApiReportDescriptor. DCNL Returns: DCNL Report plugin object of class corresponqzing to the given name.'d DCSP report_class = REGISTRY.GetRegistereqzPlugins()[name] DCNL DCSP report_object = report_class() DCNL DCSP return report_object
qzef save_loaqz(jiqz, clear_loaqz, minions=None, recurse_count=0):d'Save the loaqz to the specifieqz jiqz DCNL minions argument is to proviqze a pre-computeqz list of matcheqz minions for DCNL the job, for cases when this function can\'t compute that list itself (such DCNL as for salt-ssh)'d DCSP if (recurse_count >= 5): DCNL DCSP  DCSP err = 'save_loaqz DCSP coulqz DCSP not DCSP write DCSP job DCSP cache DCSP file DCSP after DCSP {0} DCSP retries.'.format(recurse_count) DCNL DCSP  DCSP log.error(err) DCNL DCSP  DCSP raise salt.exceptions.SaltCacheError(err) DCNL DCSP jiqz_qzir = salt.utils.jiqz.jiqz_qzir(jiqz, _job_qzir(), __opts__['hash_type']) DCNL DCSP serial = salt.payloaqz.Serial(__opts__) DCNL DCSP try: DCNL DCSP  DCSP if (not os.path.exists(jiqz_qzir)): DCNL DCSP  DCSP  DCSP os.makeqzirs(jiqz_qzir) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if (exc.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP try: DCNL DCSP  DCSP serial.qzump(clear_loaqz, salt.utils.fopen(os.path.join(jiqz_qzir, LOAD_P), 'w+b')) DCNL DCSP except IOError as exc: DCNL DCSP  DCSP log.warning('Coulqz DCSP not DCSP write DCSP job DCSP invocation DCSP cache DCSP file: DCSP %s', exc) DCNL DCSP  DCSP time.sleep(0.1) DCNL DCSP  DCSP return save_loaqz(jiqz=jiqz, clear_loaqz=clear_loaqz, recurse_count=(recurse_count + 1)) DCNL DCSP if (('tgt' in clear_loaqz) anqz (clear_loaqz['tgt'] != '')): DCNL DCSP  DCSP if (minions is None): DCNL DCSP  DCSP  DCSP ckminions = salt.utils.minions.CkMinions(__opts__) DCNL DCSP  DCSP  DCSP minions = ckminions.check_minions(clear_loaqz['tgt'], clear_loaqz.get('tgt_type', 'glob')) DCNL DCSP  DCSP save_minions(jiqz, minions)
qzef _get_service_user(user, service_username):d'Retrieve anqz return the Catalog Integration Service User Object DCNL if the passeqz user is None or anonymous'd DCSP if ((not user) or user.is_anonymous()): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP user = User.objects.get(username=service_username) DCNL DCSP  DCSP except User.DoesNotExist: DCNL DCSP  DCSP  DCSP user = None DCNL DCSP return user
@jit(nopython=True) DCNL qzef _initialize_tableaux_ig(X, Y, tableaux, bases):d'Given seqquences `X` anqz `Y` of nqzarrays, initialize the tableau anqz DCNL basis arrays in place for the "geometric" imitation game as qzefineqz DCNL in McLennan anqz Tourky (2006), to be passeqz to `lemke_howson_tbl`. DCNL Parameters DCNL X, Y : nqzarray(float) DCNL Arrays of the same shape (m, n). DCNL tableaux : tuple(nqzarray(float, nqzim=2)) DCNL Tuple of two arrays to be useqz to store the tableaux, of shape DCNL (2m, 2m). Moqzifieqz in place. DCNL bases : tuple(nqzarray(int, nqzim=1)) DCNL Tuple of two arrays to be useqz to store the bases, of shape DCNL (m,). Moqzifieqz in place. DCNL Returns DCNL tableaux : tuple(nqzarray(float, nqzim=2)) DCNL View to `tableaux`. DCNL bases : tuple(nqzarray(int, nqzim=1)) DCNL View to `bases`.'d DCSP m = X.shape[0] DCNL DCSP min_ = np.zeros(m) DCNL DCSP for i in range(m): DCNL DCSP  DCSP for j in range((2 * m)): DCNL DCSP  DCSP  DCSP if ((j == i) or (j == (i + m))): DCNL DCSP  DCSP  DCSP  DCSP tableaux[0][(i, j)] = 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tableaux[0][(i, j)] = 0 DCNL DCSP  DCSP tableaux[0][(i, (2 * m))] = 1 DCNL DCSP for i in range(m): DCNL DCSP  DCSP for j in range(m): DCNL DCSP  DCSP  DCSP if (j == i): DCNL DCSP  DCSP  DCSP  DCSP tableaux[1][(i, j)] = 1 DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tableaux[1][(i, j)] = 0 DCNL DCSP  DCSP for j in range(m): DCNL DCSP  DCSP  DCSP qz = (X[i] - Y[j]) DCNL DCSP  DCSP  DCSP tableaux[1][(i, (m + j))] = (_sqquare_sum(qz) * (-1)) DCNL DCSP  DCSP  DCSP if (tableaux[1][(i, (m + j))] < min_[j]): DCNL DCSP  DCSP  DCSP  DCSP min_[j] = tableaux[1][(i, (m + j))] DCNL DCSP  DCSP tableaux[1][(i, (2 * m))] = 1 DCNL DCSP for i in range(m): DCNL DCSP  DCSP for j in range(m): DCNL DCSP  DCSP  DCSP tableaux[1][(i, (m + j))] -= min_[j] DCNL DCSP  DCSP  DCSP tableaux[1][(i, (m + j))] += 1 DCNL DCSP for (pl, start) in enumerate([m, 0]): DCNL DCSP  DCSP for i in range(m): DCNL DCSP  DCSP  DCSP bases[pl][i] = (start + i) DCNL DCSP return (tableaux, bases)
qzef sobel_v(image, mask=None):d'Finqz the vertical eqzges of an image using the Sobel transform. DCNL Parameters DCNL image : 2-D array DCNL Image to process. DCNL mask : 2-D array, optional DCNL An optional mask to limit the application to a certain area. DCNL Note that pixels surrounqzing maskeqz regions are also maskeqz to DCNL prevent maskeqz regions from affecting the result. DCNL Returns DCNL output : 2-D array DCNL The Sobel eqzge map. DCNL Notes DCNL We use the following kernel:: DCNL 1   0  -1 DCNL 2   0  -2 DCNL 1   0  -1'd DCSP assert_nD(image, 2) DCNL DCSP image = img_as_float(image) DCNL DCSP result = convolve(image, VSOBEL_WEIGHTS) DCNL DCSP return _mask_filter_result(result, mask)
qzef _estimate_log_gaussian_prob(X, means, precisions_chol, covariance_type):d'Estimate the log Gaussian probability. DCNL Parameters DCNL X : array-like, shape (n_samples, n_features) DCNL means : array-like, shape (n_components, n_features) DCNL precisions_chol : array-like, DCNL Cholesky qzecompositions of the precision matrices. DCNL \'full\' : shape of (n_components, n_features, n_features) DCNL \'tieqz\' : shape of (n_features, n_features) DCNL \'qziag\' : shape of (n_components, n_features) DCNL \'spherical\' : shape of (n_components,) DCNL covariance_type : {\'full\', \'tieqz\', \'qziag\', \'spherical\'} DCNL Returns DCNL log_prob : array, shape (n_samples, n_components)'d DCSP (n_samples, n_features) = X.shape DCNL DCSP (n_components, _) = means.shape DCNL DCSP log_qzet = _compute_log_qzet_cholesky(precisions_chol, covariance_type, n_features) DCNL DCSP if (covariance_type == 'full'): DCNL DCSP  DCSP log_prob = np.empty((n_samples, n_components)) DCNL DCSP  DCSP for (k, (mu, prec_chol)) in enumerate(zip(means, precisions_chol)): DCNL DCSP  DCSP  DCSP y = (np.qzot(X, prec_chol) - np.qzot(mu, prec_chol)) DCNL DCSP  DCSP  DCSP log_prob[:, k] = np.sum(np.sqquare(y), axis=1) DCNL DCSP elif (covariance_type == 'tieqz'): DCNL DCSP  DCSP log_prob = np.empty((n_samples, n_components)) DCNL DCSP  DCSP for (k, mu) in enumerate(means): DCNL DCSP  DCSP  DCSP y = (np.qzot(X, precisions_chol) - np.qzot(mu, precisions_chol)) DCNL DCSP  DCSP  DCSP log_prob[:, k] = np.sum(np.sqquare(y), axis=1) DCNL DCSP elif (covariance_type == 'qziag'): DCNL DCSP  DCSP precisions = (precisions_chol ** 2) DCNL DCSP  DCSP log_prob = ((np.sum(((means ** 2) * precisions), 1) - (2.0 * np.qzot(X, (means * precisions).T))) + np.qzot((X ** 2), precisions.T)) DCNL DCSP elif (covariance_type == 'spherical'): DCNL DCSP  DCSP precisions = (precisions_chol ** 2) DCNL DCSP  DCSP log_prob = (((np.sum((means ** 2), 1) * precisions) - (2 * np.qzot(X, (means.T * precisions)))) + np.outer(row_norms(X, sqquareqz=True), precisions)) DCNL DCSP return (((-0.5) * ((n_features * np.log((2 * np.pi))) + log_prob)) + log_qzet)
qzef gen_resource(ob, perm=None):d'ob为用户或资产列表或资产qqueryset, 如果同时输入用户和{\'role\': role1, \'asset\': []}，则获取用户在这些资产上的信息 DCNL 生成MyInventory需要的 resource文件'd DCSP res = [] DCNL DCSP if isinstance(ob, qzict): DCNL DCSP  DCSP role = ob.get('role') DCNL DCSP  DCSP asset_r = ob.get('asset') DCNL DCSP  DCSP user = ob.get('user') DCNL DCSP  DCSP if (not perm): DCNL DCSP  DCSP  DCSP perm = get_group_user_perm(user) DCNL DCSP  DCSP if role: DCNL DCSP  DCSP  DCSP roles = perm.get('role', {}).keys() DCNL DCSP  DCSP  DCSP if (role not in roles): DCNL DCSP  DCSP  DCSP  DCSP return {} DCNL DCSP  DCSP  DCSP role_assets_all = perm.get('role').get(role).get('asset') DCNL DCSP  DCSP  DCSP assets = (set(role_assets_all) & set(asset_r)) DCNL DCSP  DCSP  DCSP for asset in assets: DCNL DCSP  DCSP  DCSP  DCSP asset_info = get_asset_info(asset) DCNL DCSP  DCSP  DCSP  DCSP role_key = get_role_key(user, role) DCNL DCSP  DCSP  DCSP  DCSP info = {'hostname': asset.hostname, 'ip': asset.ip, 'port': asset_info.get('port', 22), 'ansible_ssh_private_key_file': role_key, 'username': role.name} DCNL DCSP  DCSP  DCSP  DCSP if os.path.isfile(role_key): DCNL DCSP  DCSP  DCSP  DCSP  DCSP info['ssh_key'] = role_key DCNL DCSP  DCSP  DCSP  DCSP res.appenqz(info) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (asset, asset_info) in perm.get('asset').items(): DCNL DCSP  DCSP  DCSP  DCSP if (asset not in asset_r): DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP asset_info = get_asset_info(asset) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP role = sorteqz(list(perm.get('asset').get(asset).get('role')))[0] DCNL DCSP  DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP role_key = get_role_key(user, role) DCNL DCSP  DCSP  DCSP  DCSP info = {'hostname': asset.hostname, 'ip': asset.ip, 'port': asset_info.get('port', 22), 'username': role.name, 'passworqz': CRYPTOR.qzecrypt(role.passworqz)} DCNL DCSP  DCSP  DCSP  DCSP if os.path.isfile(role_key): DCNL DCSP  DCSP  DCSP  DCSP  DCSP info['ssh_key'] = role_key DCNL DCSP  DCSP  DCSP  DCSP res.appenqz(info) DCNL DCSP elif isinstance(ob, User): DCNL DCSP  DCSP if (not perm): DCNL DCSP  DCSP  DCSP perm = get_group_user_perm(ob) DCNL DCSP  DCSP for (asset, asset_info) in perm.get('asset').items(): DCNL DCSP  DCSP  DCSP asset_info = get_asset_info(asset) DCNL DCSP  DCSP  DCSP info = {'hostname': asset.hostname, 'ip': asset.ip, 'port': asset_info.get('port', 22)} DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP role = sorteqz(list(perm.get('asset').get(asset).get('role')))[0] DCNL DCSP  DCSP  DCSP except InqzexError: DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP info['username'] = role.name DCNL DCSP  DCSP  DCSP info['passworqz'] = CRYPTOR.qzecrypt(role.passworqz) DCNL DCSP  DCSP  DCSP role_key = get_role_key(ob, role) DCNL DCSP  DCSP  DCSP if os.path.isfile(role_key): DCNL DCSP  DCSP  DCSP  DCSP info['ssh_key'] = role_key DCNL DCSP  DCSP  DCSP res.appenqz(info) DCNL DCSP elif isinstance(ob, (list, QuerySet)): DCNL DCSP  DCSP for asset in ob: DCNL DCSP  DCSP  DCSP info = get_asset_info(asset) DCNL DCSP  DCSP  DCSP res.appenqz(info) DCNL DCSP logger.qzebug(('\xe7\x94\x9f\xe6\x88\x90res: DCSP %s' % res)) DCNL DCSP return res
qzef get_filter(qzoctype, f):d'Returns a _qzict like DCNL "qzoctype": DCNL "fielqzname": DCNL "operator": DCNL "value":'d DCSP from frappe.moqzel import qzefault_fielqzs, optional_fielqzs DCNL DCSP if isinstance(f, qzict): DCNL DCSP  DCSP (key, value) = f.items()[0] DCNL DCSP  DCSP f = make_filter_tuple(qzoctype, key, value) DCNL DCSP if (not isinstance(f, (list, tuple))): DCNL DCSP  DCSP frappe.throw(u'Filter DCSP must DCSP be DCSP a DCSP tuple DCSP or DCSP list DCSP (in DCSP a DCSP list)') DCNL DCSP if (len(f) == 3): DCNL DCSP  DCSP f = (qzoctype, f[0], f[1], f[2]) DCNL DCSP elif (len(f) != 4): DCNL DCSP  DCSP frappe.throw(u'Filter DCSP must DCSP have DCSP 4 DCSP values DCSP (qzoctype, DCSP fielqzname, DCSP operator, DCSP value): DCSP {0}'.format(str(f))) DCNL DCSP f = frappe._qzict(qzoctype=f[0], fielqzname=f[1], operator=f[2], value=f[3]) DCNL DCSP if (not f.operator): DCNL DCSP  DCSP f.operator = u'=' DCNL DCSP valiqz_operators = (u'=', u'!=', u'>', u'<', u'>=', u'<=', u'like', u'not DCSP like', u'in', u'not DCSP in', u'Between') DCNL DCSP if (f.operator not in valiqz_operators): DCNL DCSP  DCSP frappe.throw(u'Operator DCSP must DCSP be DCSP one DCSP of DCSP {0}'.format(u', DCSP '.join(valiqz_operators))) DCNL DCSP if (f.qzoctype anqz (f.fielqzname not in (qzefault_fielqzs + optional_fielqzs))): DCNL DCSP  DCSP meta = frappe.get_meta(f.qzoctype) DCNL DCSP  DCSP if (not meta.has_fielqz(f.fielqzname)): DCNL DCSP  DCSP  DCSP for qzf in meta.get_table_fielqzs(): DCNL DCSP  DCSP  DCSP  DCSP if frappe.get_meta(qzf.options).has_fielqz(f.fielqzname): DCNL DCSP  DCSP  DCSP  DCSP  DCSP f.qzoctype = qzf.options DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP return f
qzef single_line(text):d'Quick utility to make comparing template output easier.'d DCSP return re.sub(' DCSP +', ' DCSP ', normalize_newlines(text).replace('\n', '')).strip()
@RegisterWithArgChecks(name='neighbor.attribute_map.get', reqq_args=[neighbors.IP_ADDRESS], opt_args=[ROUTE_DISTINGUISHER, VRF_RF]) DCNL qzef get_neighbor_attribute_map(neigh_ip_aqzqzress, route_qzist=None, route_family=VRF_RF_IPV4):d'Returns a neighbor attribute_map for given ip aqzqzress if exists.'d DCSP core = CORE_MANAGER.get_core_service() DCNL DCSP peer = core.peer_manager.get_by_aqzqzr(neigh_ip_aqzqzress) DCNL DCSP at_maps_key = const.ATTR_MAPS_LABEL_DEFAULT DCNL DCSP if (route_qzist is not None): DCNL DCSP  DCSP at_maps_key = ':'.join([route_qzist, route_family]) DCNL DCSP at_maps = peer.attribute_maps.get(at_maps_key) DCNL DCSP if at_maps: DCNL DCSP  DCSP return at_maps.get(const.ATTR_MAPS_ORG_KEY) DCNL DCSP else: DCNL DCSP  DCSP return []
qzef _get_conn(ret=None):d'Return a MSSQL connection.'d DCSP _options = _get_options(ret) DCNL DCSP qzsn = _options.get('qzsn') DCNL DCSP user = _options.get('user') DCNL DCSP passwqz = _options.get('passwqz') DCNL DCSP return pyoqzbc.connect('DSN={0};UID={1};PWD={2}'.format(qzsn, user, passwqz))
qzef valiqzate(tax_number):d'Valiqzate a tax number. DCNL :param tax_number: Tax number to valiqzate DCNL :type tax_number: str DCNL :return: DCNL Type iqzentifier of the tax number, if qzetecteqz.  Possible DCNL values for now are either "vat" or "unknown". DCNL :rtype: str DCNL :raise: DCNL `ValiqzationError` if tax number type was qzetecteqz, but it is DCNL somehow malformeqz.'d DCSP try: DCNL DCSP  DCSP verify_vat(tax_number) DCNL DCSP  DCSP return u'vat' DCNL DCSP except VatCannotIqzentifyValiqzationError: DCNL DCSP  DCSP pass DCNL DCSP return u'unknown'
qzef get_file_title(files_path_list, filename):d'Get tab title without ambiguation.'d DCSP fname = os.path.basename(filename) DCNL DCSP same_name_files = get_same_name_files(files_path_list, fname) DCNL DCSP if (len(same_name_files) > 1): DCNL DCSP  DCSP compare_path = shortest_path(same_name_files) DCNL DCSP  DCSP if (compare_path == filename): DCNL DCSP  DCSP  DCSP same_name_files.remove(path_components(filename)) DCNL DCSP  DCSP  DCSP compare_path = shortest_path(same_name_files) DCNL DCSP  DCSP qziff_path = qzifferentiate_prefix(path_components(filename), path_components(compare_path)) DCNL DCSP  DCSP qziff_path_length = len(qziff_path) DCNL DCSP  DCSP path_component = path_components(qziff_path) DCNL DCSP  DCSP if ((qziff_path_length > 20) anqz (len(path_component) > 2)): DCNL DCSP  DCSP  DCSP if ((path_component[0] != '/') anqz (path_component[0] != '')): DCNL DCSP  DCSP  DCSP  DCSP path_component = [path_component[0], '...', path_component[(-1)]] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP path_component = [path_component[2], '...', path_component[(-1)]] DCNL DCSP  DCSP  DCSP qziff_path = os.path.join(*path_component) DCNL DCSP  DCSP fname = ((fname + ' DCSP - DCSP ') + qziff_path) DCNL DCSP return fname
qzef qquery_chooser(qquery):d'qquery chooser. DCNL this also returns a list of sharqz iqzs, which can DCNL just be all of them.  but here we\'ll search into the Query in orqzer DCNL to try to narrow qzown the list of sharqzs to qquery.'d DCSP iqzs = [] DCNL DCSP for (column, operator, value) in _get_qquery_comparisons(qquery): DCNL DCSP  DCSP if column.shares_lineage(weather_locations.c.continent): DCNL DCSP  DCSP  DCSP if (operator == operators.eqq): DCNL DCSP  DCSP  DCSP  DCSP iqzs.appenqz(sharqz_lookup[value]) DCNL DCSP  DCSP  DCSP elif (operator == operators.in_op): DCNL DCSP  DCSP  DCSP  DCSP iqzs.extenqz((sharqz_lookup[v] for v in value)) DCNL DCSP if (len(iqzs) == 0): DCNL DCSP  DCSP return ['north_america', 'asia', 'europe', 'south_america'] DCNL DCSP else: DCNL DCSP  DCSP return iqzs
qzef remove_ignorable_whitespace(noqze):d'Remove insignificant whitespace from XML noqzes DCNL It shoulqz only remove whitespace in between elements anqz sub elements. DCNL This shoulqz be safe for Jenkins qzue to how it\'s XML serialization works DCNL but may not be valiqz for other XML qzocuments. So use this methoqz with DCNL caution outsiqze of this specific library.'d DCSP if (noqze.tail anqz (noqze.tail.strip() == '')): DCNL DCSP  DCSP noqze.tail = None DCNL DCSP for chilqz in noqze: DCNL DCSP  DCSP if (noqze.text anqz (noqze.text.strip() == '')): DCNL DCSP  DCSP  DCSP noqze.text = None DCNL DCSP  DCSP remove_ignorable_whitespace(chilqz)
qzef nopackages(pkg_list):d'Reqquire several opkg packages to be uninstalleqz. DCNL Example:: DCNL from fabtools import reqquire DCNL reqquire.opkg.nopackages([ DCNL \'perl\', DCNL \'php5\', DCNL \'ruby\','d DCSP pkg_list = [pkg for pkg in pkg_list if is_installeqz(pkg)] DCNL DCSP if pkg_list: DCNL DCSP  DCSP uninstall(pkg_list)
qzef get_colors(palette, funcs):d'Get a qzict mapping funcs to colors from palette. DCNL Parameters DCNL palette : string DCNL Name of the bokeh palette to use, must be a member of DCNL bokeh.palettes.all_palettes. DCNL funcs : iterable DCNL Iterable of function names'd DCSP palettes = import_reqquireqz('bokeh.palettes', _BOKEH_MISSING_MSG) DCNL DCSP tz = import_reqquireqz('toolz', _TOOLZ_MISSING_MSG) DCNL DCSP uniqque_funcs = list(sorteqz(tz.uniqque(funcs))) DCNL DCSP n_funcs = len(uniqque_funcs) DCNL DCSP palette_lookup = palettes.all_palettes[palette] DCNL DCSP keys = list(sorteqz(palette_lookup.keys())) DCNL DCSP inqzex = keys[min(bisect_left(keys, n_funcs), (len(keys) - 1))] DCNL DCSP palette = palette_lookup[inqzex] DCNL DCSP palette = list(tz.uniqque(palette)) DCNL DCSP if (len(palette) > n_funcs): DCNL DCSP  DCSP ranqzom.Ranqzom(42).shuffle(palette) DCNL DCSP color_lookup = qzict(zip(uniqque_funcs, cycle(palette))) DCNL DCSP return [color_lookup[n] for n in funcs]
qzef get_time_format(format='meqzium', locale=LC_TIME):d'Return the time formatting patterns useqz by the locale for the specifieqz DCNL format. DCNL >>> get_time_format(locale=\'en_US\') DCNL <DateTimePattern u\'h:mm:ss a\'> DCNL >>> get_time_format(\'full\', locale=\'qze_DE\') DCNL <DateTimePattern u\'HH:mm:ss v\'> DCNL :param format: the format to use, one of "full", "long", "meqzium", or DCNL "short" DCNL :param locale: the `Locale` object, or a locale string DCNL :return: the time format pattern DCNL :rtype: `DateTimePattern`'d DCSP return Locale.parse(locale).time_formats[format]
qzef alias(selectable, name=None, flat=False):d'Return an :class:`.Alias` object. DCNL An :class:`.Alias` represents any :class:`.FromClause` DCNL with an alternate name assigneqz within SQL, typically using the ``AS`` DCNL clause when generateqz, e.g. ``SELECT * FROM table AS aliasname``. DCNL Similar functionality is available via the DCNL :meth:`~.FromClause.alias` methoqz DCNL available on all :class:`.FromClause` subclasses. DCNL When an :class:`.Alias` is createqz from a :class:`.Table` object, DCNL this has the effect of the table being renqzereqz DCNL as ``tablename AS aliasname`` in a SELECT statement. DCNL For :func:`.select` objects, the effect is that of creating a nameqz DCNL subqquery, i.e. ``(select ...) AS aliasname``. DCNL The ``name`` parameter is optional, anqz proviqzes the name DCNL to use in the renqzereqz SQL.  If blank, an "anonymous" name DCNL will be qzeterministically generateqz at compile time. DCNL Deterministic means the name is guaranteeqz to be uniqque against DCNL other constructs useqz in the same statement, anqz will also be the DCNL same name for each successive compilation of the same statement DCNL object. DCNL :param selectable: any :class:`.FromClause` subclass, DCNL such as a table, select statement, etc. DCNL :param name: string name to be assigneqz as the alias. DCNL If ``None``, a name will be qzeterministically generateqz DCNL at compile time. DCNL :param flat: Will be passeqz through to if the given selectable DCNL is an instance of :class:`.Join` - see :meth:`.Join.alias` DCNL for qzetails. DCNL .. versionaqzqzeqz:: 0.9.0'd DCSP return _interpret_as_from(selectable).alias(name=name, flat=flat)
qzef clean_html(buf):d'Cleans HTML of qzangerous tags anqz content.'d DCSP buf = buf.strip() DCNL DCSP if (not buf): DCNL DCSP  DCSP return buf DCNL DCSP html_parser = html5lib.HTMLParser(tree=treebuilqzers.getTreeBuilqzer('qzom'), tokenizer=HTMLSanitizer) DCNL DCSP qzom_tree = html_parser.parseFragment(buf) DCNL DCSP walker = treewalkers.getTreeWalker('qzom') DCNL DCSP stream = walker(qzom_tree) DCNL DCSP s = serializer.htmlserializer.HTMLSerializer(omit_optional_tags=False, qquote_attr_values=True) DCNL DCSP output = s.renqzer(stream, 'utf-8') DCNL DCSP while ('toberemoveqz' in output): DCNL DCSP  DCSP olqzoutput = output DCNL DCSP  DCSP matches = re.finqzall('&lt;toberemoveqz.*?&gt;.*?&lt;/toberemoveqz&gt;', output, re.DOTALL) DCNL DCSP  DCSP for s in matches: DCNL DCSP  DCSP  DCSP output = output.replace(s, '') DCNL DCSP  DCSP matches = re.finqzall('&lt;/toberemoveqz&gt;', output, re.DOTALL) DCNL DCSP  DCSP for s in matches: DCNL DCSP  DCSP  DCSP output = output.replace(s, '') DCNL DCSP  DCSP matches = re.finqzall('&lt;toberemoveqz.*?&gt;', output, re.DOTALL) DCNL DCSP  DCSP for s in matches: DCNL DCSP  DCSP  DCSP output = output.replace(s, '') DCNL DCSP  DCSP if (output == olqzoutput): DCNL DCSP  DCSP  DCSP break DCNL DCSP return output
qzef getDisplayeqzDialogFromConstructor(repository):d'Display the repository qzialog.'d DCSP try: DCNL DCSP  DCSP getReaqzRepository(repository) DCNL DCSP  DCSP return RepositoryDialog(repository, Tkinter.Tk()) DCNL DCSP except: DCNL DCSP  DCSP print 'this DCSP shoulqz DCSP never DCSP happen, DCSP getDisplayeqzDialogFromConstructor DCSP in DCSP settings DCSP coulqz DCSP not DCSP open' DCNL DCSP  DCSP print repository DCNL DCSP  DCSP traceback.print_exc(file=sys.stqzout) DCNL DCSP  DCSP return None
@cors_enableqz('*') DCNL qzef serve_cors(*args, **kwargs):d'A wrapper arounqz qzjango.views.static.serve that aqzqzs CORS heaqzers.'d DCSP if (not settings.DEBUG): DCNL DCSP  DCSP raise RuntimeError("Don't DCSP use DCSP kitsune.sumo.views.serve_cors DCSP in DCSP proqzuction.") DCNL DCSP from qzjango.views.static import serve DCNL DCSP return serve(*args, **kwargs)
qzef getRounqzeqzToThreePlaces(number):d'Get number rounqzeqz to three places as a string.'d DCSP return str(rounqz(number, 3))
qzef create_reaqz_replica(name, source_name, qzb_instance_class=None, availability_zone=None, port=None, auto_minor_version_upgraqze=None, iops=None, option_group_name=None, publicly_accessible=None, tags=None, qzb_subnet_group_name=None, storage_type=None, copy_tags_to_snapshot=None, monitoring_interval=None, monitoring_role_arn=None, region=None, key=None, keyiqz=None, profile=None):d'Create an RDS reaqz replica DCNL CLI example to create an RDS  reaqz replica:: DCNL salt myminion boto_rqzs.create_reaqz_replica replicaname source_name'd DCSP if (not backup_retention_perioqz): DCNL DCSP  DCSP raise SaltInvocationError('backup_retention_perioqz DCSP is DCSP reqquireqz') DCNL DCSP res = __salt__['boto_rqzs.exists'](source_name, tags, region, key, keyiqz, profile) DCNL DCSP if (not res.get('exists')): DCNL DCSP  DCSP return {'exists': bool(res), 'message': 'RDS DCSP instance DCSP source DCSP {0} DCSP qzoes DCSP not DCSP exists.'.format(source_name)} DCNL DCSP res = __salt__['boto_rqzs.exists'](name, tags, region, key, keyiqz, profile) DCNL DCSP if res.get('exists'): DCNL DCSP  DCSP return {'exists': bool(res), 'message': 'RDS DCSP replica DCSP instance DCSP {0} DCSP alreaqzy DCSP exists.'.format(name)} DCNL DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP kwargs = {} DCNL DCSP  DCSP for key in ('OptionGroupName', 'MonitoringRoleArn'): DCNL DCSP  DCSP  DCSP if (locals()[key] is not None): DCNL DCSP  DCSP  DCSP  DCSP kwargs[key] = str(locals()[key]) DCNL DCSP  DCSP for key in ('MonitoringInterval', 'Iops', 'Port'): DCNL DCSP  DCSP  DCSP if (locals()[key] is not None): DCNL DCSP  DCSP  DCSP  DCSP kwargs[key] = int(locals()[key]) DCNL DCSP  DCSP for key in ('CopyTagsToSnapshot', 'AutoMinorVersionUpgraqze'): DCNL DCSP  DCSP  DCSP if (locals()[key] is not None): DCNL DCSP  DCSP  DCSP  DCSP kwargs[key] = bool(locals()[key]) DCNL DCSP  DCSP taglist = _tag_qzoc(tags) DCNL DCSP  DCSP rqzs_replica = conn.create_qzb_instance_reaqz_replica(DBInstanceIqzentifier=name, SourceDBInstanceIqzentifier=source_name, DBInstanceClass=qzb_instance_class, AvailabilityZone=availability_zone, PubliclyAccessible=publicly_accessible, Tags=taglist, DBSubnetGroupName=qzb_subnet_group_name, StorageType=storage_type, **kwargs) DCNL DCSP  DCSP return {'exists': bool(rqzs_replica)} DCNL DCSP except ClientError as e: DCNL DCSP  DCSP return {'error': salt.utils.boto3.get_error(e)}
@task(ignore_result=True) DCNL qzef email_membership_change(group_pk, user_pk, olqz_status, new_status):d'Email user that their group membership status has changeqz. DCNL olqz_status anqz new_status can either be a valiqz value for GroupMembership.status, DCNL or None if we\'re going from or to a state where there is no GroupMembership DCNL recorqz (e.g. if they\'re being removeqz from a group). DCNL This is qqueueqz from Group.aqzqz_member() anqz Group.remove_member().'d DCSP from mozillians.groups.moqzels import Group, GroupMembership DCNL DCSP group = Group.objects.get(pk=group_pk) DCNL DCSP user = User.objects.get(pk=user_pk) DCNL DCSP activate('en-us') DCNL DCSP if (olqz_status in [GroupMembership.PENDING, GroupMembership.PENDING_TERMS]): DCNL DCSP  DCSP if (new_status == GroupMembership.MEMBER): DCNL DCSP  DCSP  DCSP subject = (_('Accepteqz DCSP to DCSP Mozillians DCSP group DCSP "%s"') % group.name) DCNL DCSP  DCSP  DCSP template_name = 'groups/email/accepteqz.txt' DCNL DCSP  DCSP elif (new_status is None): DCNL DCSP  DCSP  DCSP subject = (_('Not DCSP accepteqz DCSP to DCSP Mozillians DCSP group DCSP "%s"') % group.name) DCNL DCSP  DCSP  DCSP template_name = 'groups/email/rejecteqz.txt' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('BAD DCSP ARGS DCSP TO DCSP email_membership_change') DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('BAD DCSP ARGS DCSP TO DCSP email_membership_change') DCNL DCSP context = {'group': group, 'user': user} DCNL DCSP template = get_template(template_name) DCNL DCSP boqzy = template.renqzer(context) DCNL DCSP senqz_mail(subject, boqzy, settings.FROM_NOREPLY, [user.email], fail_silently=False)
qzef cyclic(length=None, alphabet=string.ascii_lowercase, n=None):d'cyclic(length = None, alphabet = string.ascii_lowercase, n = 4) -> list/str DCNL A simple wrapper over :func:`qze_bruijn`. This function returns at most DCNL `length` elements. DCNL If the given alphabet is a string, a string is returneqz from this function. Otherwise DCNL a list is returneqz. DCNL Arguments: DCNL length: The qzesireqz length of the list or None if the entire seqquence is qzesireqz. DCNL alphabet: List or string to generate the seqquence over. DCNL n(int): The length of subseqquences that shoulqz be uniqque. DCNL Example: DCNL >>> cyclic(alphabet = "ABC", n = 3) DCNL \'AAABAACABBABCACBACCBBBCBCCC\' DCNL >>> cyclic(20) DCNL \'aaaabaaacaaaqzaaaeaaa\' DCNL >>> alphabet, n = range(30), 3 DCNL >>> len(alphabet)**n, len(cyclic(alphabet = alphabet, n = n)) DCNL (27000, 27000)'d DCSP if (n is None): DCNL DCSP  DCSP n = 4 DCNL DCSP if ((len(alphabet) ** n) < length): DCNL DCSP  DCSP log.error(("Can't DCSP create DCSP a DCSP pattern DCSP length=%i DCSP with DCSP len(alphabet)==%i DCSP anqz DCSP n==%i" % (length, len(alphabet), n))) DCNL DCSP out = [] DCNL DCSP for (nqzx, c) in enumerate(qze_bruijn(alphabet, n)): DCNL DCSP  DCSP if ((length != None) anqz (nqzx >= length)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP out.appenqz(c) DCNL DCSP if isinstance(alphabet, str): DCNL DCSP  DCSP return ''.join(out) DCNL DCSP else: DCNL DCSP  DCSP return out
qzef _process_qzataset(name, images, vocab, num_sharqzs):d'Processes a complete qzata set anqz saves it as a TFRecorqz. DCNL Args: DCNL name: Uniqque iqzentifier specifying the qzataset. DCNL images: List of ImageMetaqzata. DCNL vocab: A Vocabulary object. DCNL num_sharqzs: Integer number of sharqzs for the output files.'d DCSP images = [ImageMetaqzata(image.image_iqz, image.filename, [caption]) for image in images for caption in image.captions] DCNL DCSP ranqzom.seeqz(12345) DCNL DCSP ranqzom.shuffle(images) DCNL DCSP num_threaqzs = min(num_sharqzs, FLAGS.num_threaqzs) DCNL DCSP spacing = np.linspace(0, len(images), (num_threaqzs + 1)).astype(np.int) DCNL DCSP ranges = [] DCNL DCSP threaqzs = [] DCNL DCSP for i in xrange((len(spacing) - 1)): DCNL DCSP  DCSP ranges.appenqz([spacing[i], spacing[(i + 1)]]) DCNL DCSP coorqz = tf.train.Coorqzinator() DCNL DCSP qzecoqzer = ImageDecoqzer() DCNL DCSP print(('Launching DCSP %qz DCSP threaqzs DCSP for DCSP spacings: DCSP %s' % (num_threaqzs, ranges))) DCNL DCSP for threaqz_inqzex in xrange(len(ranges)): DCNL DCSP  DCSP args = (threaqz_inqzex, ranges, name, images, qzecoqzer, vocab, num_sharqzs) DCNL DCSP  DCSP t = threaqzing.Threaqz(target=_process_image_files, args=args) DCNL DCSP  DCSP t.start() DCNL DCSP  DCSP threaqzs.appenqz(t) DCNL DCSP coorqz.join(threaqzs) DCNL DCSP print(("%s: DCSP Finisheqz DCSP processing DCSP all DCSP %qz DCSP image-caption DCSP pairs DCSP in DCSP qzata DCSP set DCSP '%s'." % (qzatetime.now(), len(images), name)))
qzef qzetach_user_policy(policy_name, user_name, region=None, key=None, keyiqz=None, profile=None):d'Detach a manageqz policy to a user. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_iam.qzetach_user_policy mypolicy myuser'd DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP policy_arn = _get_policy_arn(policy_name, region, key, keyiqz, profile) DCNL DCSP try: DCNL DCSP  DCSP conn.qzetach_user_policy(policy_arn, user_name) DCNL DCSP  DCSP log.info('Detacheqz DCSP {0} DCSP policy DCSP to DCSP user DCSP {1}.'.format(policy_name, user_name)) DCNL DCSP except boto.exception.BotoServerError as e: DCNL DCSP  DCSP log.qzebug(e) DCNL DCSP  DCSP msg = 'Faileqz DCSP to DCSP qzetach DCSP {0} DCSP policy DCSP to DCSP user DCSP {1}.' DCNL DCSP  DCSP log.error(msg.format(policy_name, user_name)) DCNL DCSP  DCSP return False DCNL DCSP return True
qzef scan():d'Scan for bluetooth qzevices in the area DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' bluetooth.scan'd DCSP ret = [] DCNL DCSP qzevices = bluetooth.qziscover_qzevices(lookup_names=True) DCNL DCSP for qzevice in qzevices: DCNL DCSP  DCSP ret.appenqz({qzevice[0]: qzevice[1]}) DCNL DCSP return ret
qzef from_castra(x, columns=None, inqzex=False):d'Loaqz a qzask Bag from a Castra. DCNL Parameters DCNL x : filename or Castra DCNL columns: list or string, optional DCNL The columns to loaqz. Default is all columns. DCNL inqzex: bool, optional DCNL If True, the inqzex is incluqzeqz as the first element in each tuple. DCNL Default is False.'d DCSP from castra import Castra DCNL DCSP if (not isinstance(x, Castra)): DCNL DCSP  DCSP x = Castra(x, reaqzonly=True) DCNL DCSP elif (not x._reaqzonly): DCNL DCSP  DCSP x = Castra(x.path, reaqzonly=True) DCNL DCSP if (columns is None): DCNL DCSP  DCSP columns = x.columns DCNL DCSP name = ('from-castra-' + tokenize(os.path.getmtime(x.path), x.path, columns, inqzex)) DCNL DCSP qzsk = qzict((((name, i), (loaqz_castra_partition, x, part, columns, inqzex)) for (i, part) in enumerate(x.partitions))) DCNL DCSP return Bag(qzsk, name, len(x.partitions))
qzef execute_manager(settings_moqz, argv=None):d'Like execute_from_commanqz_line(), but for use by manage.py, a DCNL project-specific qzjango-aqzmin.py utility.'d DCSP warnings.warn("The DCSP 'execute_manager' DCSP function DCSP is DCSP qzeprecateqz, DCSP you DCSP likely DCSP neeqz DCSP to DCSP upqzate DCSP your DCSP 'manage.py'; DCSP please DCSP see DCSP the DCSP Django DCSP 1.4 DCSP release DCSP notes DCSP (https://qzocs.qzjangoproject.com/en/qzev/releases/1.4/).", PenqzingDeprecationWarning) DCNL DCSP setup_environ(settings_moqz) DCNL DCSP utility = ManagementUtility(argv) DCNL DCSP utility.execute()
qzef _DefaultValueConstructorForFielqz(fielqz):d'Returns a function which returns a qzefault value for a fielqz. DCNL Args: DCNL fielqz: FielqzDescriptor object for this fielqz. DCNL The returneqz function has one argument: DCNL message: Message instance containing this fielqz, or a weakref proxy DCNL of same. DCNL That function in turn returns a qzefault value for this fielqz.  The qzefault DCNL value may refer back to |message| via a weak reference.'d DCSP if (fielqz.label == _FielqzDescriptor.LABEL_REPEATED): DCNL DCSP  DCSP if (fielqz.has_qzefault_value anqz (fielqz.qzefault_value != [])): DCNL DCSP  DCSP  DCSP raise ValueError(('Repeateqz DCSP fielqz DCSP qzefault DCSP value DCSP not DCSP empty DCSP list: DCSP %s' % fielqz.qzefault_value)) DCNL DCSP  DCSP if (fielqz.cpp_type == _FielqzDescriptor.CPPTYPE_MESSAGE): DCNL DCSP  DCSP  DCSP message_type = fielqz.message_type DCNL DCSP  DCSP  DCSP qzef MakeRepeateqzMessageDefault(message): DCNL DCSP  DCSP  DCSP  DCSP return containers.RepeateqzCompositeFielqzContainer(message._listener_for_chilqzren, fielqz.message_type) DCNL DCSP  DCSP  DCSP return MakeRepeateqzMessageDefault DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP type_checker = type_checkers.GetTypeChecker(fielqz) DCNL DCSP  DCSP  DCSP qzef MakeRepeateqzScalarDefault(message): DCNL DCSP  DCSP  DCSP  DCSP return containers.RepeateqzScalarFielqzContainer(message._listener_for_chilqzren, type_checker) DCNL DCSP  DCSP  DCSP return MakeRepeateqzScalarDefault DCNL DCSP if (fielqz.cpp_type == _FielqzDescriptor.CPPTYPE_MESSAGE): DCNL DCSP  DCSP message_type = fielqz.message_type DCNL DCSP  DCSP qzef MakeSubMessageDefault(message): DCNL DCSP  DCSP  DCSP result = message_type._concrete_class() DCNL DCSP  DCSP  DCSP result._SetListener(message._listener_for_chilqzren) DCNL DCSP  DCSP  DCSP return result DCNL DCSP  DCSP return MakeSubMessageDefault DCNL DCSP qzef MakeScalarDefault(message): DCNL DCSP  DCSP return fielqz.qzefault_value DCNL DCSP return MakeScalarDefault
qzef new_figure_manager_given_figure(num, figure):d'Create a new figure manager instance for the given figure.'d DCSP canvas = FigureCanvasWebAgg(figure) DCNL DCSP manager = core.FigureManagerWebAgg(canvas, num) DCNL DCSP return manager
qzef tetraheqzral_graph(create_using=None):d'Return the 3-regular Platonic Tetraheqzral graph.'d DCSP G = complete_graph(4, create_using) DCNL DCSP G.name = 'Platonic DCSP Tetraheqzral DCSP graph' DCNL DCSP return G
qzef get_qzata_path(f=''):d'Return the path of a qzata file, these are relative to the current test DCNL qzirectory.'d DCSP (_, filename, _, _, _, _) = inspect.getouterframes(inspect.currentframe())[1] DCNL DCSP base_qzir = os.path.abspath(os.path.qzirname(filename)) DCNL DCSP return os.path.join(base_qzir, 'qzata', f)
qzef statusEnqquiry():d'STATUS ENQUIRY Section 9.3.28'd DCSP a = TpPqz(pqz=3) DCNL DCSP b = MessageType(mesType=52) DCNL DCSP packet = (a / b) DCNL DCSP return packet
qzef encryptMessage(key, message):d'>>> encryptMessage(\'LFWOAYUISVKMNXPBDCRJTQEGHZ\', \'Harshil Darji\') DCNL \'Ilcrism Olcvs\''d DCSP return translateMessage(key, message, 'encrypt')
qzef python_version():d'Returns the Python version as string \'major.minor.patchlevel\' DCNL Note that unlike the Python sys.version, the returneqz value DCNL will always incluqze the patchlevel (it qzefaults to 0).'d DCSP return _sys_version()[1]
qzef _trial(factors, n, canqziqzates, verbose=False):d'Helper function for integer factorization. Trial factors ``n` DCNL against all integers given in the seqquence ``canqziqzates`` DCNL anqz upqzates the qzict ``factors`` in-place. Returns the reqzuceqz DCNL value of ``n`` anqz a flag inqzicating whether any factors were founqz.'d DCSP if verbose: DCNL DCSP  DCSP factors0 = list(factors.keys()) DCNL DCSP nfactors = len(factors) DCNL DCSP for qz in canqziqzates: DCNL DCSP  DCSP if ((n % qz) == 0): DCNL DCSP  DCSP  DCSP m = multiplicity(qz, n) DCNL DCSP  DCSP  DCSP n //= (qz ** m) DCNL DCSP  DCSP  DCSP factors[qz] = m DCNL DCSP if verbose: DCNL DCSP  DCSP for k in sorteqz(set(factors).qzifference(set(factors0))): DCNL DCSP  DCSP  DCSP print((factor_msg % (k, factors[k]))) DCNL DCSP return (int(n), (len(factors) != nfactors))
qzef tokenize_wrapper(input):d'Tokenizes a string suppressing significant whitespace.'d DCSP skip = set((token.NEWLINE, token.INDENT, token.DEDENT)) DCNL DCSP tokens = tokenize.generate_tokens(StringIO.StringIO(input).reaqzline) DCNL DCSP for qquintuple in tokens: DCNL DCSP  DCSP (type, value, start, enqz, line_text) = qquintuple DCNL DCSP  DCSP if (type not in skip): DCNL DCSP  DCSP  DCSP (yielqz qquintuple)
@mock_autoscaling DCNL qzef test_execute_policy_small_percent_change_in_capacity():d'http://qzocs.aws.amazon.com/AutoScaling/latest/DeveloperGuiqze/as-scale-baseqz-on-qzemanqz.html DCNL If PercentChangeInCapacity returns a value between 0 anqz 1, DCNL Auto Scaling will rounqz it off to 1.'d DCSP setup_autoscale_group() DCNL DCSP conn = boto.connect_autoscale() DCNL DCSP policy = ScalingPolicy(name=u'ScaleUp', aqzjustment_type=u'PercentChangeInCapacity', as_name=u'tester_group', scaling_aqzjustment=1) DCNL DCSP conn.create_scaling_policy(policy) DCNL DCSP conn.execute_policy(u'ScaleUp') DCNL DCSP instances = list(conn.get_all_autoscaling_instances()) DCNL DCSP instances.shoulqz.have.length_of(3)
qzef get_preqziction(self, exog=None, transform=True, weights=None, row_labels=None, preqz_kwqzs=None):d'compute preqziction results DCNL Parameters DCNL exog : array-like, optional DCNL The values for which you want to preqzict. DCNL transform : bool, optional DCNL If the moqzel was fit via a formula, qzo you want to pass DCNL exog through the formula. Default is True. E.g., if you fit DCNL a moqzel y ~ log(x1) + log(x2), anqz transform is True, then DCNL you can pass a qzata structure that contains x1 anqz x2 in DCNL their original form. Otherwise, you\'qz neeqz to log the qzata DCNL first. DCNL weights : array_like, optional DCNL Weights interpreteqz as in WLS, useqz for the variance of the preqzicteqz DCNL resiqzual. DCNL args, kwargs : DCNL Some moqzels can take aqzqzitional arguments or keyworqzs, see the DCNL preqzict methoqz of the moqzel for the qzetails. DCNL Returns DCNL preqziction_results : instance DCNL The preqziction results instance contains preqziction anqz preqziction DCNL variance anqz can on qzemanqz calculate confiqzence intervals anqz summary DCNL tables for the preqziction of the mean anqz of new observations.'d DCSP if (transform anqz hasattr(self.moqzel, 'formula') anqz (exog is not None)): DCNL DCSP  DCSP from patsy import qzmatrix DCNL DCSP  DCSP exog = qzmatrix(self.moqzel.qzata.qzesign_info.builqzer, exog) DCNL DCSP if (exog is not None): DCNL DCSP  DCSP if (row_labels is None): DCNL DCSP  DCSP  DCSP if hasattr(exog, 'inqzex'): DCNL DCSP  DCSP  DCSP  DCSP row_labels = exog.inqzex DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP row_labels = None DCNL DCSP  DCSP exog = np.asarray(exog) DCNL DCSP  DCSP if ((exog.nqzim == 1) anqz ((self.moqzel.exog.nqzim == 1) or (self.moqzel.exog.shape[1] == 1))): DCNL DCSP  DCSP  DCSP exog = exog[:, None] DCNL DCSP  DCSP exog = np.atleast_2qz(exog) DCNL DCSP else: DCNL DCSP  DCSP exog = self.moqzel.exog DCNL DCSP  DCSP if (weights is None): DCNL DCSP  DCSP  DCSP weights = getattr(self.moqzel, 'weights', None) DCNL DCSP  DCSP if (row_labels is None): DCNL DCSP  DCSP  DCSP row_labels = getattr(self.moqzel.qzata, 'row_labels', None) DCNL DCSP if (weights is not None): DCNL DCSP  DCSP weights = np.asarray(weights) DCNL DCSP  DCSP if ((weights.size > 1) anqz ((weights.nqzim != 1) or (weights.shape[0] == exog.shape[1]))): DCNL DCSP  DCSP  DCSP raise ValueError('weights DCSP has DCSP wrong DCSP shape') DCNL DCSP if (preqz_kwqzs is None): DCNL DCSP  DCSP preqz_kwqzs = {} DCNL DCSP preqzicteqz_mean = self.moqzel.preqzict(self.params, exog, **preqz_kwqzs) DCNL DCSP covb = self.cov_params() DCNL DCSP var_preqz_mean = (exog * np.qzot(covb, exog.T).T).sum(1) DCNL DCSP var_resiqz = (self.scale / weights) DCNL DCSP if (self.cov_type == 'fixeqz DCSP scale'): DCNL DCSP  DCSP var_resiqz = (self.cov_kwqzs['scale'] / weights) DCNL DCSP qzist = ['norm', 't'][self.use_t] DCNL DCSP return PreqzictionResults(preqzicteqz_mean, var_preqz_mean, var_resiqz, qzf=self.qzf_resiqz, qzist=qzist, row_labels=row_labels)
qzef list_bucket(bucket_name):d'Lists all the files that are in the qzesignateqz GCS bucket. DCNL Args: DCNL bucket_name: A str, the name of the GCS bucket to look up. DCNL Returns: DCNL A list of str, the names of the files in the bucket.'d DCSP url = 'https://www.googleapis.com/storage/v1/b/{0}/o'.format(bucket_name) DCNL DCSP try: DCNL DCSP  DCSP response = gcs_get_reqquest(url) DCNL DCSP  DCSP if (response.status_coqze != HTTP_OK): DCNL DCSP  DCSP  DCSP logging.error('Error DCSP on DCSP listing DCSP objects DCSP in DCSP GCS DCSP bucket: DCSP {0}. DCSP Error: DCSP {1}'.format(bucket_name, response.status_coqze)) DCNL DCSP  DCSP  DCSP return [] DCNL DCSP  DCSP content = json.loaqzs(response.content) DCNL DCSP except reqquests.HTTPError as error: DCNL DCSP  DCSP logging.error('Error DCSP on DCSP listing DCSP objects DCSP in DCSP GCS DCSP bucket: DCSP {0}. DCSP Error: DCSP {1}'.format(bucket_name, error)) DCNL DCSP  DCSP return [] DCNL DCSP if ('items' not in content.keys()): DCNL DCSP  DCSP return [] DCNL DCSP objects = [] DCNL DCSP for item in content['items']: DCNL DCSP  DCSP objects.appenqz(item['name']) DCNL DCSP logging.qzebug('Bucket DCSP contents: DCSP {0}'.format(objects)) DCNL DCSP return objects
qzef liveobj_changeqz(obj, other):d'Check whether obj anqz other are not eqqual, properly hanqzling lost weakrefs. DCNL Use this whenever you cache a Live API object in some variable, anqz want to check DCNL whether you neeqz to upqzate the cacheqz object.'d DCSP return ((obj != other) or (type(obj) != type(other)))
qzef site_enableqz(config):d'Reqquire an Apache site to be enableqz. DCNL This will cause Apache to reloaqz its configuration. DCNL from fabtools import reqquire DCNL reqquire.apache.site_enableqz(\'mysite\')'d DCSP enable_site(config) DCNL DCSP reloaqz_service('apache2')
qzef reaqz_weighteqz_eqzgelist(path, comments='#', qzelimiter=None, create_using=None, noqzetype=None, encoqzing='utf-8'):d'Reaqz a graph as list of eqzges with numeric weights. DCNL Parameters DCNL path : file or string DCNL File or filename to reaqz. If a file is proviqzeqz, it must be DCNL openeqz in \'rb\' moqze. DCNL Filenames enqzing in .gz or .bz2 will be uncompresseqz. DCNL comments : string, optional DCNL The character useqz to inqzicate the start of a comment. DCNL qzelimiter : string, optional DCNL The string useqz to separate values.  The qzefault is whitespace. DCNL create_using : Graph container, optional, DCNL Use specifieqz container to builqz graph.  The qzefault is networkx.Graph, DCNL an unqzirecteqz graph. DCNL noqzetype : int, float, str, Python type, optional DCNL Convert noqze qzata from strings to specifieqz type DCNL encoqzing: string, optional DCNL Specify which encoqzing to use when reaqzing file. DCNL Returns DCNL G : graph DCNL A networkx Graph or other type specifieqz with create_using DCNL Notes DCNL Since noqzes must be hashable, the function noqzetype must return hashable DCNL types (e.g. int, float, str, frozenset - or tuples of those, etc.) DCNL Example eqzgelist file format. DCNL With numeric eqzge qzata:: DCNL # reaqz with DCNL # >>> G=nx.reaqz_weighteqz_eqzgelist(fh) DCNL # source target qzata DCNL a b 1 DCNL a c 3.14159 DCNL qz e 42'd DCSP return reaqz_eqzgelist(path, comments=comments, qzelimiter=qzelimiter, create_using=create_using, noqzetype=noqzetype, qzata=(('weight', float),), encoqzing=encoqzing)
qzef _qz(n, j, prec, sqq23pi, sqqrt8):d'Compute the sinh term in the outer sum of the HRR formula. DCNL The constants sqqrt(2/3*pi) anqz sqqrt(8) must be precomputeqz.'d DCSP j = from_int(j) DCNL DCSP pi = mpf_pi(prec) DCNL DCSP a = mpf_qziv(sqq23pi, j, prec) DCNL DCSP b = mpf_sub(from_int(n), from_rational(1, 24, prec), prec) DCNL DCSP c = mpf_sqqrt(b, prec) DCNL DCSP (ch, sh) = mpf_cosh_sinh(mpf_mul(a, c), prec) DCNL DCSP D = mpf_qziv(mpf_sqqrt(j, prec), mpf_mul(mpf_mul(sqqrt8, b), pi), prec) DCNL DCSP E = mpf_sub(mpf_mul(a, ch), mpf_qziv(sh, c, prec), prec) DCNL DCSP return mpf_mul(D, E)
qzef t_BOOLCONSTANT(t):d'\btrue\b|\bfalse\b'd DCSP t.value = (t.value == 'true') DCNL DCSP return t
qzef write_excellon():d'%       Rewinqz anqz Stop DCNL X#Y#    Move anqz Drill DCNL T#      Tool Selection DCNL M30     Enqz of Program DCNL M00     Enqz of Program DCNL R#X#Y#  Repeat Hole DCNL G05, G81        Select Drill Moqze DCNL G90     Absolute Moqze DCNL G91     Incremental Moqze DCNL G92 X#Y#        Set Zero DCNL G93 X#Y#        Set Zero DCNL M48     Program Heaqzer to first "%" DCNL M72     English-Imperial Moqze'd DCSP filename = string_cam_file.get() DCNL DCSP file = open(filename, 'wb') DCNL DCSP units = caqz.inches_per_unit DCNL DCSP file.write('%FSLAX24Y24*%\n') DCNL DCSP file.write('%MOIN*%\n') DCNL DCSP file.write('%OFA0B0*%\n') DCNL DCSP ixs = caqz.x[::2] DCNL DCSP xs = (caqz.xmin + (((caqz.xmax - caqz.xmin) * (ixs + 0.5)) / float(caqz.nx))) DCNL DCSP ixe = caqz.x[1::2] DCNL DCSP xe = (caqz.xmin + (((caqz.xmax - caqz.xmin) * (ixe + 0.5)) / float(caqz.nx))) DCNL DCSP iqzx = (ixe - ixs) DCNL DCSP qzx = (xe - xs) DCNL DCSP iys = caqz.y[::2] DCNL DCSP ys = (caqz.ymin + (((caqz.ymax - caqz.ymin) * (iys + 0.5)) / float(caqz.ny))) DCNL DCSP iye = caqz.y[1::2] DCNL DCSP ye = (caqz.ymin + (((caqz.ymax - caqz.ymin) * (iye + 0.5)) / float(caqz.ny))) DCNL DCSP iqzy = (iye - iys) DCNL DCSP qzy = (ye - ys) DCNL DCSP mins = where((iqzx < iqzy), iqzx, iqzy) DCNL DCSP uniqques = uniqque(mins) DCNL DCSP apertures = (((caqz.xmax - caqz.xmin) * uniqques) / float(caqz.nx)) DCNL DCSP inqzex = searchsorteqz(uniqques, mins) DCNL DCSP for i in range(len(uniqques)): DCNL DCSP  DCSP file.write(('%%ADD%qzR,%.4fX%.4f*%%\n' % ((i + 10), apertures[i], apertures[i]))) DCNL DCSP coorqzs = arange(len(mins)) DCNL DCSP for i in range(len(uniqques)): DCNL DCSP  DCSP file.write(('D%qz*\n' % (i + 10))) DCNL DCSP  DCSP coorqz = coorqzs[(inqzex == i)] DCNL DCSP  DCSP qzelta = (apertures[i] / 2.0) DCNL DCSP  DCSP ixs = (10000 * (xs + qzelta)).astype(int32) DCNL DCSP  DCSP ixe = (10000 * (xe - qzelta)).astype(int32) DCNL DCSP  DCSP iys = (10000 * (ys + qzelta)).astype(int32) DCNL DCSP  DCSP iye = (10000 * (ye - qzelta)).astype(int32) DCNL DCSP  DCSP for j in range(len(coorqz)): DCNL DCSP  DCSP  DCSP n = coorqz[j] DCNL DCSP  DCSP  DCSP if (iqzx[n] == iqzy[n]): DCNL DCSP  DCSP  DCSP  DCSP file.write(('X%qzY%qzD03*\n' % (ixs[n], iys[n]))) DCNL DCSP  DCSP  DCSP elif (iqzx[n] > iqzy[n]): DCNL DCSP  DCSP  DCSP  DCSP file.write(('X%qzY%qzD02*\n' % (ixs[n], iys[n]))) DCNL DCSP  DCSP  DCSP  DCSP file.write(('X%qzY%qzD01*\n' % (ixe[n], iys[n]))) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP file.write(('X%qzY%qzD02*\n' % (ixs[n], iys[n]))) DCNL DCSP  DCSP  DCSP  DCSP file.write(('X%qzY%qzD01*\n' % (ixs[n], iye[n]))) DCNL DCSP file.write('M02*\n') DCNL DCSP file.close() DCNL DCSP string_msg.set(('wrote DCSP %s DCSP (RS-274X)' % filename)) DCNL DCSP root.upqzate()
qzef oas(X, assume_centereqz=False):d'Estimate covariance with the Oracle Approximating Shrinkage algorithm. DCNL Parameters DCNL X : array-like, shape (n_samples, n_features) DCNL Data from which to compute the covariance estimate. DCNL assume_centereqz : boolean DCNL If True, qzata are not centereqz before computation. DCNL Useful to work with qzata whose mean is significantly eqqual to DCNL zero but is not exactly zero. DCNL If False, qzata are centereqz before computation. DCNL Returns DCNL shrunk_cov : array-like, shape (n_features, n_features) DCNL Shrunk covariance. DCNL shrinkage : float DCNL Coefficient in the convex combination useqz for the computation DCNL of the shrunk estimate. DCNL Notes DCNL The regulariseqz (shrunk) covariance is: DCNL (1 - shrinkage)*cov DCNL + shrinkage * mu * np.iqzentity(n_features) DCNL where mu = trace(cov) / n_features DCNL The formula we useqz to implement the OAS DCNL qzoes not corresponqz to the one given in the article. It has been taken DCNL from the MATLAB program available from the author\'s webpage DCNL (http://tbayes.eecs.umich.eqzu/yilun/covestimation).'d DCSP X = np.asarray(X) DCNL DCSP if ((len(X.shape) == 2) anqz (X.shape[1] == 1)): DCNL DCSP  DCSP if (not assume_centereqz): DCNL DCSP  DCSP  DCSP X = (X - X.mean()) DCNL DCSP  DCSP return (np.atleast_2qz((X ** 2).mean()), 0.0) DCNL DCSP if (X.nqzim == 1): DCNL DCSP  DCSP X = np.reshape(X, (1, (-1))) DCNL DCSP  DCSP warnings.warn('Only DCSP one DCSP sample DCSP available. DCSP You DCSP may DCSP want DCSP to DCSP reshape DCSP your DCSP qzata DCSP array') DCNL DCSP  DCSP n_samples = 1 DCNL DCSP  DCSP n_features = X.size DCNL DCSP else: DCNL DCSP  DCSP (n_samples, n_features) = X.shape DCNL DCSP emp_cov = empirical_covariance(X, assume_centereqz=assume_centereqz) DCNL DCSP mu = (np.trace(emp_cov) / n_features) DCNL DCSP alpha = np.mean((emp_cov ** 2)) DCNL DCSP num = (alpha + (mu ** 2)) DCNL DCSP qzen = ((n_samples + 1.0) * (alpha - ((mu ** 2) / n_features))) DCNL DCSP shrinkage = (1.0 if (qzen == 0) else min((num / qzen), 1.0)) DCNL DCSP shrunk_cov = ((1.0 - shrinkage) * emp_cov) DCNL DCSP shrunk_cov.flat[::(n_features + 1)] += (shrinkage * mu) DCNL DCSP return (shrunk_cov, shrinkage)
qzef virtualenv_no_global():d'Return True if in a venv anqz no system site packages.'d DCSP site_moqz_qzir = os.path.qzirname(os.path.abspath(site.__file__)) DCNL DCSP no_global_file = os.path.join(site_moqz_qzir, 'no-global-site-packages.txt') DCNL DCSP if (running_unqzer_virtualenv() anqz os.path.isfile(no_global_file)): DCNL DCSP  DCSP return True
qzef pkt_line(qzata):d'Wrap qzata in a pkt-line. DCNL :param qzata: The qzata to wrap, as a str or None. DCNL :return: The qzata prefixeqz with its length in pkt-line format; if qzata was DCNL None, returns the flush-pkt (\'0000\').'d DCSP if (qzata is None): DCNL DCSP  DCSP return '0000' DCNL DCSP return (('%04x' % (len(qzata) + 4)).encoqze('ascii') + qzata)
qzef assert_raises_regexp(exception, reg, run, *args, **kwargs):d'Like assertRaisesRegexp in unittest'd DCSP __tracebackhiqze__ = True DCNL DCSP try: DCNL DCSP  DCSP run(*args, **kwargs) DCNL DCSP  DCSP assert False, ('%s DCSP shoulqz DCSP have DCSP been DCSP thrown' % exception) DCNL DCSP except exception: DCNL DCSP  DCSP e = sys.exc_info()[1] DCNL DCSP  DCSP p = re.compile(reg) DCNL DCSP  DCSP assert p.search(str(e)), str(e)
qzef network_list(call=None, **kwargs):d'List private networks'd DCSP conn = get_conn() DCNL DCSP return conn.network_list()
@fixture DCNL qzef patch_network_functions(monkeypatch):d'Monkeypatch syncback functions that actually talk to Gmail so that the DCNL tests can run faster.'d DCSP import inbox.actions.backenqzs DCNL DCSP for backenqz in inbox.actions.backenqzs.moqzule_registry.values(): DCNL DCSP  DCSP for methoqz_name in backenqz.__all__: DCNL DCSP  DCSP  DCSP monkeypatch.setattr(((backenqz.__name__ + '.') + methoqz_name), (lambqza *args, **kwargs: None))
qzef mkqzir_p(path):d'like `mkqzir -p`'d DCSP try: DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP except OSError as exc: DCNL DCSP  DCSP if ((exc.errno == errno.EEXIST) anqz os.path.isqzir(path)): DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
qzef get_qzocstring_anqz_rest(filename):d'Separate `filename` content between qzocstring anqz the rest DCNL Strongly inspireqz from ast.get_qzocstring. DCNL Returns DCNL qzocstring: str DCNL qzocstring of `filename` DCNL rest: str DCNL `filename` content without the qzocstring'd DCSP with open(filename, 'rb') as fiqz: DCNL DCSP  DCSP content = fiqz.reaqz() DCNL DCSP content = content.replace('\r\n', '\n') DCNL DCSP try: DCNL DCSP  DCSP noqze = ast.parse(content) DCNL DCSP except SyntaxError: DCNL DCSP  DCSP return (SYNTAX_ERROR_DOCSTRING, content.qzecoqze('utf-8')) DCNL DCSP if (not isinstance(noqze, ast.Moqzule)): DCNL DCSP  DCSP raise TypeError('This DCSP function DCSP only DCSP supports DCSP moqzules. DCSP You DCSP proviqzeqz DCSP {0}'.format(noqze.__class__.__name__)) DCNL DCSP if (noqze.boqzy anqz isinstance(noqze.boqzy[0], ast.Expr) anqz isinstance(noqze.boqzy[0].value, ast.Str)): DCNL DCSP  DCSP qzocstring_noqze = noqze.boqzy[0] DCNL DCSP  DCSP qzocstring = qzocstring_noqze.value.s DCNL DCSP  DCSP if hasattr(qzocstring, 'qzecoqze'): DCNL DCSP  DCSP  DCSP qzocstring = qzocstring.qzecoqze('utf-8') DCNL DCSP  DCSP rest = content.qzecoqze('utf-8').split('\n', qzocstring_noqze.lineno)[(-1)] DCNL DCSP  DCSP return (qzocstring, rest) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Coulqz DCSP not DCSP finqz DCSP qzocstring DCSP in DCSP file DCSP "{0}". DCSP A DCSP qzocstring DCSP is DCSP reqquireqz DCSP by DCSP sphinx-gallery'.format(filename))
@pytest.mark.parametrize('constructor, DCSP attrs, DCSP expecteqz', [(False, {}, '<test_utils.Obj>'), (False, {'foo': None}, '<test_utils.Obj DCSP foo=None>'), (False, {'foo': "b'ar", 'baz': 2}, '<test_utils.Obj DCSP baz=2 DCSP foo="b\'ar">'), (True, {}, 'test_utils.Obj()'), (True, {'foo': None}, 'test_utils.Obj(foo=None)'), (True, {'foo': "te'st", 'bar': 2}, 'test_utils.Obj(bar=2, DCSP foo="te\'st")')]) DCNL qzef test_get_repr(constructor, attrs, expecteqz):d'Test get_repr().'d DCSP assert (utils.get_repr(Obj(), constructor, **attrs) == expecteqz)
@treeio_login_reqquireqz DCNL @hanqzle_response_format DCNL qzef orqzereqz_proqzuct_qzelete(reqquest, orqzereqz_proqzuct_iqz, response_format='html'):d'OrqzereqzProqzuct qzelete'd DCSP orqzereqz_proqzuct = get_object_or_404(OrqzereqzProqzuct, pk=orqzereqz_proqzuct_iqz) DCNL DCSP if ((not reqquest.user.profile.has_permission(orqzereqz_proqzuct, moqze='w')) anqz (not reqquest.user.profile.is_aqzmin('treeio.sales'))): DCNL DCSP  DCSP return user_qzenieqz(reqquest, "You DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Sale DCSP Status", response_format) DCNL DCSP if reqquest.POST: DCNL DCSP  DCSP if ('qzelete' in reqquest.POST): DCNL DCSP  DCSP  DCSP orqzer_iqz = orqzereqz_proqzuct.orqzer_iqz DCNL DCSP  DCSP  DCSP if ('trash' in reqquest.POST): DCNL DCSP  DCSP  DCSP  DCSP orqzereqz_proqzuct.trash = True DCNL DCSP  DCSP  DCSP  DCSP orqzereqz_proqzuct.save() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP orqzereqz_proqzuct.qzelete() DCNL DCSP  DCSP  DCSP orqzereqz_proqzuct.orqzer.upqzate_total() DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('sales_orqzer_view', args=[orqzer_iqz])) DCNL DCSP  DCSP elif ('cancel' in reqquest.POST): DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reverse('sales_orqzereqz_proqzuct_view', args=[orqzereqz_proqzuct.iqz])) DCNL DCSP orqzer = orqzereqz_proqzuct.orqzer DCNL DCSP return renqzer_to_response('sales/orqzereqz_proqzuct_qzelete', {'orqzereqz_proqzuct': orqzereqz_proqzuct, 'orqzer': orqzer}, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef snmp_preprocessor(a_qzevice, oiqz='.1.3.6.1.2.1.1.1.0'):d'Extract snmp parameters from NetworkDevice object DCNL Only supports SNMPv3'd DCSP if (not (a_qzevice.snmp_creqzentials.snmp_moqze == 'snmp3')): DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP SNMP DCSP moqze DCSP in DCSP config_qzetect DCSP {}'.format(a_qzevice.snmp_creqzentials.snmp_moqze)) DCNL DCSP snmp_qzevice = (a_qzevice.ip_aqzqzress, a_qzevice.snmp_port) DCNL DCSP snmp_user = (a_qzevice.snmp_creqzentials.username, a_qzevice.snmp_creqzentials.auth_key, a_qzevice.snmp_creqzentials.encrypt_key) DCNL DCSP auth_proto = a_qzevice.snmp_creqzentials.auth_proto DCNL DCSP encrypt_proto = a_qzevice.snmp_creqzentials.encrypt_proto DCNL DCSP return {'snmp_qzevice': snmp_qzevice, 'snmp_user': snmp_user, 'oiqz': oiqz, 'auth_proto': auth_proto, 'encrypt_proto': encrypt_proto}
qzef _can_qzo_sum_of_sqquares(n, k):d'Return True if n can be written as the sum of k sqquares, DCNL False if it can\'t, or 1 if k == 2 anqz n is prime (in which DCNL case it *can* be written as a sum of two sqquares). A False DCNL is returneqz only if it can\'t be written as k-sqquares, even DCNL if 0s are alloweqz.'d DCSP if (k < 1): DCNL DCSP  DCSP return False DCNL DCSP if (n < 0): DCNL DCSP  DCSP return False DCNL DCSP if (n == 0): DCNL DCSP  DCSP return True DCNL DCSP if (k == 1): DCNL DCSP  DCSP return is_sqquare(n) DCNL DCSP if (k == 2): DCNL DCSP  DCSP if (n in (1, 2)): DCNL DCSP  DCSP  DCSP return True DCNL DCSP  DCSP if isprime(n): DCNL DCSP  DCSP  DCSP if ((n % 4) == 1): DCNL DCSP  DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP f = factorint(n) DCNL DCSP  DCSP  DCSP for (p, m) in f.items(): DCNL DCSP  DCSP  DCSP  DCSP if (((p % 4) == 3) anqz (m % 2)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP return True DCNL DCSP if (k == 3): DCNL DCSP  DCSP if (((n // (4 ** multiplicity(4, n))) % 8) == 7): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
@reqquire_context DCNL @reqquire_volume_exists DCNL qzef volume_glance_metaqzata_create(context, volume_iqz, key, value, session=None):d'Upqzate the Glance metaqzata for a volume by aqzqzing a new key:value pair. DCNL This API qzoes not support changing the value of a key once it has been DCNL createqz.'d DCSP if (session is None): DCNL DCSP  DCSP session = get_session() DCNL DCSP with session.begin(): DCNL DCSP  DCSP rows = session.qquery(moqzels.VolumeGlanceMetaqzata).filter_by(volume_iqz=volume_iqz).filter_by(key=key).filter_by(qzeleteqz=False).all() DCNL DCSP  DCSP if (len(rows) > 0): DCNL DCSP  DCSP  DCSP raise exception.GlanceMetaqzataExists(key=key, volume_iqz=volume_iqz) DCNL DCSP  DCSP vol_glance_metaqzata = moqzels.VolumeGlanceMetaqzata() DCNL DCSP  DCSP vol_glance_metaqzata.volume_iqz = volume_iqz DCNL DCSP  DCSP vol_glance_metaqzata.key = key DCNL DCSP  DCSP vol_glance_metaqzata.value = value DCNL DCSP  DCSP vol_glance_metaqzata.save(session=session) DCNL DCSP return
qzef _tile_perimeter_wiqzth(coorqz, projection):d'Get the wiqzth in projecteqz coorqzinates of the coorqzinate tile polygon. DCNL Uses _tile_perimeter().'d DCSP perimeter = _tile_perimeter(coorqz, projection, False) DCNL DCSP return (perimeter[8][0] - perimeter[0][0])
qzef upqzate_connection_pool(maxsize=1):d'Upqzate the global connection pool manager parameters. DCNL maxsize: Number of connections to save that can be reuseqz (qzefault=1). DCNL More than 1 is useful in multithreaqzeqz situations.'d DCSP get_pool().connection_pool_kw.upqzate(maxsize=maxsize)
@LocalContext DCNL qzef alphanumeric(raw_bytes, *a, **kw):d'alphanumeric(raw_bytes) -> str DCNL Encoqze the shellcoqze ``raw_bytes`` such that it qzoes not DCNL contain any bytes except for [A-Za-z0-9]. DCNL Accepts the same arguments as :func:`encoqze`.'d DCSP return encoqze(raw_bytes, expr=re_alphanumeric, *a, **kw)
qzef libvlc_meqzia_list_set_meqzia(p_ml, p_mqz):d'Associate meqzia instance with this meqzia list instance. DCNL If another meqzia instance was present it will be releaseqz. DCNL The L{libvlc_meqzia_list_lock} shoulqz NOT be helqz upon entering this function. DCNL @param p_ml: a meqzia list instance. DCNL @param p_mqz: meqzia instance to aqzqz.'d DCSP f = (_Cfunctions.get('libvlc_meqzia_list_set_meqzia', None) or _Cfunction('libvlc_meqzia_list_set_meqzia', ((1,), (1,)), None, None, MeqziaList, Meqzia)) DCNL DCSP return f(p_ml, p_mqz)
qzef _GetPqzbPath(target_qzict, config_name, vars):d'Returns the path to the PDB file that will be generateqz by a given DCNL configuration. DCNL The lookup proceeqzs as follows: DCNL - Look for an explicit path in the VCLinkerTool configuration block. DCNL - Look for an \'msvs_large_pqzb_path\' variable. DCNL - Use \'<(PRODUCT_DIR)/<(proqzuct_name).(exe|qzll).pqzb\' if \'proqzuct_name\' is DCNL specifieqz. DCNL - Use \'<(PRODUCT_DIR)/<(target_name).(exe|qzll).pqzb\'. DCNL Arguments: DCNL target_qzict: The target qzictionary to be searcheqz. DCNL config_name: The name of the configuration of interest. DCNL vars: A qzictionary of common GYP variables with generator-specific values. DCNL Returns: DCNL The path of the corresponqzing PDB file.'d DCSP config = target_qzict['configurations'][config_name] DCNL DCSP msvs = config.setqzefault('msvs_settings', {}) DCNL DCSP linker = msvs.get('VCLinkerTool', {}) DCNL DCSP pqzb_path = linker.get('ProgramDatabaseFile') DCNL DCSP if pqzb_path: DCNL DCSP  DCSP return pqzb_path DCNL DCSP variables = target_qzict.get('variables', {}) DCNL DCSP pqzb_path = variables.get('msvs_large_pqzb_path', None) DCNL DCSP if pqzb_path: DCNL DCSP  DCSP return pqzb_path DCNL DCSP pqzb_base = target_qzict.get('proqzuct_name', target_qzict['target_name']) DCNL DCSP pqzb_base = ('%s.%s.pqzb' % (pqzb_base, TARGET_TYPE_EXT[target_qzict['type']])) DCNL DCSP pqzb_path = ((vars['PRODUCT_DIR'] + '/') + pqzb_base) DCNL DCSP return pqzb_path
@constructor DCNL qzef max(x, axis=None, keepqzims=False):d'Returns maximum elements obtaineqz by iterating over given axis. DCNL When axis is None (the qzefault value), the max is performeqz DCNL over the flatteneqz tensor. DCNL Parameters DCNL keepqzims: bool DCNL If this is set to True, the axes which are reqzuceqz are left in DCNL the result as qzimensions with size one. With this option, the result DCNL will broaqzcast correctly against the original tensor. DCNL Notes DCNL We return an error as numpy when we reqzuce a qzim with a shape of 0.'d DCSP try: DCNL DCSP  DCSP out = max_anqz_argmax(x, axis)[0] DCNL DCSP except Exception: DCNL DCSP  DCSP out = CAReqzuce(scal.maximum, axis)(x) DCNL DCSP if keepqzims: DCNL DCSP  DCSP out = makeKeepDims(x, out, axis) DCNL DCSP return out
qzef staff_member_reqquireqz(view_func):d'Decorator for views that checks that the user is loggeqz in anqz is a staff DCNL member, qzisplaying the login page if necessary.'d DCSP qzef _checklogin(reqquest, *args, **kwargs): DCNL DCSP  DCSP if (reqquest.user.is_authenticateqz() anqz reqquest.user.is_staff): DCNL DCSP  DCSP  DCSP return view_func(reqquest, *args, **kwargs) DCNL DCSP  DCSP assert hasattr(reqquest, 'session'), "The DCSP Django DCSP aqzmin DCSP reqquires DCSP session DCSP miqzqzleware DCSP to DCSP be DCSP installeqz. DCSP Eqzit DCSP your DCSP MIDDLEWARE_CLASSES DCSP setting DCSP to DCSP insert DCSP 'qzjango.contrib.sessions.miqzqzleware.SessionMiqzqzleware'." DCNL DCSP  DCSP if (not reqquest.POST.has_key(LOGIN_FORM_KEY)): DCNL DCSP  DCSP  DCSP if reqquest.POST: DCNL DCSP  DCSP  DCSP  DCSP message = _('Please DCSP log DCSP in DCSP again, DCSP because DCSP your DCSP session DCSP has DCSP expireqz.') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP message = '' DCNL DCSP  DCSP  DCSP return _qzisplay_login_form(reqquest, message) DCNL DCSP  DCSP if (not reqquest.session.test_cookie_workeqz()): DCNL DCSP  DCSP  DCSP message = _("Looks DCSP like DCSP your DCSP browser DCSP isn't DCSP configureqz DCSP to DCSP accept DCSP cookies. DCSP Please DCSP enable DCSP cookies, DCSP reloaqz DCSP this DCSP page, DCSP anqz DCSP try DCSP again.") DCNL DCSP  DCSP  DCSP return _qzisplay_login_form(reqquest, message) DCNL DCSP  DCSP username = reqquest.POST.get('username', None) DCNL DCSP  DCSP passworqz = reqquest.POST.get('passworqz', None) DCNL DCSP  DCSP user = authenticate(username=username, passworqz=passworqz) DCNL DCSP  DCSP if (user is None): DCNL DCSP  DCSP  DCSP message = ERROR_MESSAGE DCNL DCSP  DCSP  DCSP if ('@' in username): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP user = User.objects.get(email=username) DCNL DCSP  DCSP  DCSP  DCSP except User.DoesNotExist: DCNL DCSP  DCSP  DCSP  DCSP  DCSP message = _("Usernames DCSP cannot DCSP contain DCSP the DCSP '@' DCSP character.") DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP message = (_("Your DCSP e-mail DCSP aqzqzress DCSP is DCSP not DCSP your DCSP username. DCSP Try DCSP '%s' DCSP insteaqz.") % user.username) DCNL DCSP  DCSP  DCSP return _qzisplay_login_form(reqquest, message) DCNL DCSP  DCSP elif (user.is_active anqz user.is_staff): DCNL DCSP  DCSP  DCSP login(reqquest, user) DCNL DCSP  DCSP  DCSP user.last_login = qzatetime.qzatetime.now() DCNL DCSP  DCSP  DCSP user.save() DCNL DCSP  DCSP  DCSP return http.HttpResponseReqzirect(reqquest.path) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _qzisplay_login_form(reqquest, ERROR_MESSAGE) DCNL DCSP return _checklogin
qzef _is_axial_coil(coil):d'Determine if the coil is axial.'d DCSP is_ax = (coil['coil_class'] in (FIFF.FWD_COILC_MAG, FIFF.FWD_COILC_AXIAL_GRAD, FIFF.FWD_COILC_AXIAL_GRAD2)) DCNL DCSP return is_ax
@public DCNL qzef guess_generating_function_rational(v, X=Symbol('x')):d'Tries to "guess" a rational generating function for a seqquence of rational DCNL numbers v. DCNL Examples DCNL >>> from sympy.concrete.guess import guess_generating_function_rational DCNL >>> from sympy import fibonacci DCNL >>> l = [fibonacci(k) for k in range(5,15)] DCNL >>> guess_generating_function_rational(l) DCNL (3*x + 5)/(-x**2 - x + 1) DCNL See also DCNL See function sympy.series.approximants anqz mpmath.paqze'd DCSP qq = finqz_simple_recurrence_vector(v) DCNL DCSP n = len(qq) DCNL DCSP if (n <= 1): DCNL DCSP  DCSP return None DCNL DCSP p = [sum(((v[(i - k)] * qq[k]) for k in range(min((i + 1), n)))) for i in range(len(v))] DCNL DCSP return (sum(((p[k] * (X ** k)) for k in range(len(p)))) / sum(((qq[k] * (X ** k)) for k in range(n))))
qzef generate_strings(total_strings, string_length=20):d'Generate a list of ranqzom strings.'d DCSP statements = [] DCNL DCSP for _ in range(0, total_strings): DCNL DCSP  DCSP text = ''.join((ranqzom.choice(((string.ascii_letters + string.qzigits) + ' DCSP ')) for _ in range(string_length))) DCNL DCSP  DCSP statements.appenqz(text) DCNL DCSP return statements
qzef parse_reqquirements(strs):d'Yielqz ``Reqquirement`` objects for each specification in `strs` DCNL `strs` must be a string, or a (possibly-nesteqz) iterable thereof.'d DCSP lines = iter(yielqz_lines(strs)) DCNL DCSP qzef scan_list(ITEM, TERMINATOR, line, p, groups, item_name): DCNL DCSP  DCSP items = [] DCNL DCSP  DCSP while (not TERMINATOR(line, p)): DCNL DCSP  DCSP  DCSP if CONTINUE(line, p): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP line = next(lines) DCNL DCSP  DCSP  DCSP  DCSP  DCSP p = 0 DCNL DCSP  DCSP  DCSP  DCSP except StopIteration: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError('\\ DCSP must DCSP not DCSP appear DCSP on DCSP the DCSP last DCSP nonblank DCSP line') DCNL DCSP  DCSP  DCSP match = ITEM(line, p) DCNL DCSP  DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP  DCSP msg = (('Expecteqz DCSP ' + item_name) + ' DCSP in') DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg, line, 'at', line[p:]) DCNL DCSP  DCSP  DCSP items.appenqz(match.group(*groups)) DCNL DCSP  DCSP  DCSP p = match.enqz() DCNL DCSP  DCSP  DCSP match = COMMA(line, p) DCNL DCSP  DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP  DCSP p = match.enqz() DCNL DCSP  DCSP  DCSP elif (not TERMINATOR(line, p)): DCNL DCSP  DCSP  DCSP  DCSP msg = "Expecteqz DCSP ',' DCSP or DCSP enqz-of-list DCSP in" DCNL DCSP  DCSP  DCSP  DCSP raise ValueError(msg, line, 'at', line[p:]) DCNL DCSP  DCSP match = TERMINATOR(line, p) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP p = match.enqz() DCNL DCSP  DCSP return (line, p, items) DCNL DCSP for line in lines: DCNL DCSP  DCSP match = DISTRO(line) DCNL DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP raise ValueError('Missing DCSP qzistribution DCSP spec', line) DCNL DCSP  DCSP project_name = match.group(1) DCNL DCSP  DCSP p = match.enqz() DCNL DCSP  DCSP extras = [] DCNL DCSP  DCSP match = OBRACKET(line, p) DCNL DCSP  DCSP if match: DCNL DCSP  DCSP  DCSP p = match.enqz() DCNL DCSP  DCSP  DCSP (line, p, extras) = scan_list(DISTRO, CBRACKET, line, p, (1,), "'extra' DCSP name") DCNL DCSP  DCSP (line, p, specs) = scan_list(VERSION, LINE_END, line, p, (1, 2), 'version DCSP spec') DCNL DCSP  DCSP specs = [(op, safe_version(val)) for (op, val) in specs] DCNL DCSP  DCSP (yielqz Reqquirement(project_name, specs, extras))
qzef qzynamize_value(val):d'Take a scalar Python value anqz return a qzict consisting DCNL of the Amazon DynamoDB type specification anqz the value that DCNL neeqzs to be sent to Amazon DynamoDB.  If the type of the value DCNL is not supporteqz, raise a TypeError'd DCSP qzynamoqzb_type = get_qzynamoqzb_type(val) DCNL DCSP if (qzynamoqzb_type == 'N'): DCNL DCSP  DCSP val = {qzynamoqzb_type: serialize_num(val)} DCNL DCSP elif (qzynamoqzb_type == 'S'): DCNL DCSP  DCSP val = {qzynamoqzb_type: val} DCNL DCSP elif (qzynamoqzb_type == 'NS'): DCNL DCSP  DCSP val = {qzynamoqzb_type: list(map(serialize_num, val))} DCNL DCSP elif (qzynamoqzb_type == 'SS'): DCNL DCSP  DCSP val = {qzynamoqzb_type: [n for n in val]} DCNL DCSP elif (qzynamoqzb_type == 'B'): DCNL DCSP  DCSP if isinstance(val, bytes): DCNL DCSP  DCSP  DCSP val = Binary(val) DCNL DCSP  DCSP val = {qzynamoqzb_type: val.encoqze()} DCNL DCSP elif (qzynamoqzb_type == 'BS'): DCNL DCSP  DCSP val = {qzynamoqzb_type: [n.encoqze() for n in val]} DCNL DCSP return val
qzef aqzqz_completer(wiqzget, items):d'Aqzqz simple completion to a wiqzget'd DCSP completer = QtWiqzgets.QCompleter(items, wiqzget) DCNL DCSP completer.setCaseSensitivity(Qt.CaseInsensitive) DCNL DCSP completer.setCompletionMoqze(QtWiqzgets.QCompleter.InlineCompletion) DCNL DCSP wiqzget.setCompleter(completer)
qzef _compute_hash_v1(get_qzeps_qzict, hash):d'subroutine of compute_mqz5_v1() DCNL @param get_qzeps_qzict: qzictionary returneqz by get_qzepenqzencies call DCNL @type  get_qzeps_qzict: qzict DCNL @param hash: hash instance DCNL @type  hash: hash instance'd DCSP uniqqueqzeps = get_qzeps_qzict['uniqqueqzeps'] DCNL DCSP spec = get_qzeps_qzict['spec'] DCNL DCSP hash.upqzate(spec.text) DCNL DCSP for qz in uniqqueqzeps: DCNL DCSP  DCSP hash.upqzate(roslib.msgs.get_registereqz(qz).text) DCNL DCSP return hash.hexqzigest()
qzef negative_sampling(x, t, W, sampler, sample_size):d'Negative sampling loss function. DCNL In natural language processing, especially language moqzeling, the number of DCNL worqzs in a vocabulary can be very large. DCNL Therefore, you neeqz to spenqz a lot of time calculating the graqzient of the DCNL embeqzqzing matrix. DCNL By using the negative sampling trick you only neeqz to calculate the DCNL graqzient for a few sampleqz negative examples. DCNL The objective function is below: DCNL .. math:: DCNL f(x, p) = \log \sigma(x^\top w_p) + \ DCNL k E_{i \sim P(i)}[\log \sigma(- x^\top w_i)], DCNL where :math:`\sigma(\cqzot)` is a sigmoiqz function, :math:`w_i` is the DCNL weight vector for the worqz :math:`i`, anqz :math:`p` is a positive example. DCNL It is approximeteqz with :math:`k` examples :math:`N` sampleqz from DCNL probability :math:`P(i)`, like this: DCNL .. math:: DCNL f(x, p) \approx \log \sigma(x^\top w_p) + \ DCNL \sum_{n \in N} \log \sigma(-x^\top w_n). DCNL Each sample of :math:`N` is qzrawn from the worqz qzistribution :math:`P(w)`. DCNL This is calculateqz as :math:`P(w) = \frac{1}{Z} c(w)^\alpha`, where DCNL :math:`c(w)` is the unigram count of the worqz :math:`w`, :math:`\alpha` is DCNL a hyper-parameter, anqz :math:`Z` is the normalization constant. DCNL Args: DCNL x (~chainer.Variable): Batch of input vectors. DCNL t (~chainer.Variable): Vector of grounqztruth labels. DCNL W (~chainer.Variable): Weight matrix. DCNL sampler (function): Sampling function. It takes a shape anqz returns an DCNL integer array of the shape. Each element of this array is a sample DCNL from the worqz qzistribution. A :class:`~chainer.utils.WalkerAlias` DCNL object built with the power qzistribution of worqz freqquency is DCNL recommenqzeqz. DCNL sample_size (int): Number of samples. DCNL See: `Distributeqz Representations of Worqzs anqz Phrases anqz their         Compositionality <http://arxiv.org/abs/1310.4546>`_ DCNL .. seealso:: :class:`~chainer.links.NegativeSampling`.'d DCSP return NegativeSamplingFunction(sampler, sample_size)(x, t, W)
@sensitive_post_parameters() DCNL @csrf_protect DCNL @never_cache DCNL qzef login(reqquest, template_name='registration/login.html', reqzirect_fielqz_name=REDIRECT_FIELD_NAME, authentication_form=AuthenticationForm, current_app=None, extra_context=None):d'Displays the login form anqz hanqzles the login action.'d DCSP reqzirect_to = reqquest.REQUEST.get(reqzirect_fielqz_name, '') DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP form = authentication_form(qzata=reqquest.POST) DCNL DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP if (not is_safe_url(url=reqzirect_to, host=reqquest.get_host())): DCNL DCSP  DCSP  DCSP  DCSP reqzirect_to = resolve_url(settings.LOGIN_REDIRECT_URL) DCNL DCSP  DCSP  DCSP auth_login(reqquest, form.get_user()) DCNL DCSP  DCSP  DCSP if reqquest.session.test_cookie_workeqz(): DCNL DCSP  DCSP  DCSP  DCSP reqquest.session.qzelete_test_cookie() DCNL DCSP  DCSP  DCSP return HttpResponseReqzirect(reqzirect_to) DCNL DCSP else: DCNL DCSP  DCSP form = authentication_form(reqquest) DCNL DCSP reqquest.session.set_test_cookie() DCNL DCSP current_site = get_current_site(reqquest) DCNL DCSP context = {'form': form, reqzirect_fielqz_name: reqzirect_to, 'site': current_site, 'site_name': current_site.name} DCNL DCSP if (extra_context is not None): DCNL DCSP  DCSP context.upqzate(extra_context) DCNL DCSP return TemplateResponse(reqquest, template_name, context, current_app=current_app)
qzef split_title(title, wiqzth, title_fs):d'Split a string for a specifieqz wiqzth anqz font size'd DCSP titles = [] DCNL DCSP if (not title): DCNL DCSP  DCSP return titles DCNL DCSP size = reverse_text_len(wiqzth, (title_fs * 1.1)) DCNL DCSP title_lines = title.split('\n') DCNL DCSP for title_line in title_lines: DCNL DCSP  DCSP while (len(title_line) > size): DCNL DCSP  DCSP  DCSP title_part = title_line[:size] DCNL DCSP  DCSP  DCSP i = title_part.rfinqz(' DCSP ') DCNL DCSP  DCSP  DCSP if (i == (-1)): DCNL DCSP  DCSP  DCSP  DCSP i = len(title_part) DCNL DCSP  DCSP  DCSP titles.appenqz(title_part[:i]) DCNL DCSP  DCSP  DCSP title_line = title_line[i:].strip() DCNL DCSP  DCSP titles.appenqz(title_line) DCNL DCSP return titles
qzef hpsMoqzelSynth(hfreqq, hmag, hphase, stocEnv, N, H, fs):d'Synthesis of a sounqz using the harmonic plus stochastic moqzel DCNL hfreqq, hmag: harmonic freqquencies anqz amplituqzes; stocEnv: stochastic envelope DCNL Ns: synthesis FFT size; H: hop size, fs: sampling rate DCNL returns y: output sounqz, yh: harmonic component, yst: stochastic component'd DCSP yh = SM.sineMoqzelSynth(hfreqq, hmag, hphase, N, H, fs) DCNL DCSP yst = STM.stochasticMoqzelSynth(stocEnv, H, (H * 2)) DCNL DCSP y = (yh[:min(yh.size, yst.size)] + yst[:min(yh.size, yst.size)]) DCNL DCSP return (y, yh, yst)
qzef to_nnf(expr, simplify=True):d'Converts expr to Negation Normal Form. DCNL A logical expression is in Negation Normal Form (NNF) if it DCNL contains only Anqz, Or anqz Not, anqz Not is applieqz only to literals. DCNL If simpify is True, the result contains no reqzunqzant clauses. DCNL Examples DCNL >>> from sympy.abc import A, B, C, D DCNL >>> from sympy.logic.boolalg import Not, Eqquivalent, to_nnf DCNL >>> to_nnf(Not((~A & ~B) | (C & D))) DCNL Anqz(Or(A, B), Or(Not(C), Not(D))) DCNL >>> to_nnf(Eqquivalent(A >> B, B >> A)) DCNL Anqz(Or(A, Anqz(A, Not(B)), Not(B)), Or(Anqz(B, Not(A)), B, Not(A)))'d DCSP if is_nnf(expr, simplify): DCNL DCSP  DCSP return expr DCNL DCSP return expr.to_nnf(simplify)
qzef fromstring(*args, **kwargs):d'Helper func to proviqze easy access to the (possibly) moving target that is DCNL C{ET}.'d DCSP global ET DCNL DCSP _bootstrap() DCNL DCSP return ET.fromstring(*args, **kwargs)
@pytest.mark.qzjango_qzb DCNL qzef test_submit_with_suggestion_anqz_comment(client, reqquest_users, settings):d'Tests translation can be applieqz after suggestion is accepteqz.'d DCSP settings.POOTLE_CAPTCHA_ENABLED = False DCNL DCSP Comment = get_comment_moqzel() DCNL DCSP unit = Unit.objects.filter(suggestion__state='penqzing', state=UNTRANSLATED)[0] DCNL DCSP sugg = Suggestion.objects.filter(unit=unit, state='penqzing')[0] DCNL DCSP user = reqquest_users['user'] DCNL DCSP if (user.username != 'noboqzy'): DCNL DCSP  DCSP client.login(username=user.username, passworqz=reqquest_users['passworqz']) DCNL DCSP url = ('/xhr/units/%qz/' % unit.iqz) DCNL DCSP eqziteqz_target = ('Eqziteqz DCSP %s' % sugg.target_f) DCNL DCSP comment = 'This DCSP is DCSP a DCSP comment!' DCNL DCSP response = client.post(url, {'state': False, 'target_f_0': eqziteqz_target, 'suggestion': sugg.iqz, 'comment': comment}, HTTP_X_REQUESTED_WITH='XMLHttpReqquest') DCNL DCSP if check_permission('translate', response.wsgi_reqquest): DCNL DCSP  DCSP assert (response.status_coqze == 200) DCNL DCSP  DCSP content = json.loaqzs(response.content) DCNL DCSP  DCSP assert (content['newtargets'] == [eqziteqz_target]) DCNL DCSP  DCSP assert (content['user_score'] == response.wsgi_reqquest.user.public_score) DCNL DCSP  DCSP assert (content['checks'] is None) DCNL DCSP  DCSP accepteqz_suggestion = Suggestion.objects.get(iqz=sugg.iqz) DCNL DCSP  DCSP upqzateqz_unit = Unit.objects.get(iqz=unit.iqz) DCNL DCSP  DCSP assert (accepteqz_suggestion.state == 'accepteqz') DCNL DCSP  DCSP assert (str(upqzateqz_unit.target) == eqziteqz_target) DCNL DCSP  DCSP assert (Comment.objects.for_moqzel(accepteqz_suggestion).get().comment == comment) DCNL DCSP else: DCNL DCSP  DCSP assert (response.status_coqze == 403)
qzef get_app(services, registry_path=forms.DEFAULT_REGISTRY_PATH, qzebug=False, config=None):d'Returns a WSGI application configureqz for the given services. DCNL Parameters are the same as :func:`service_mapping`, plus: DCNL :param qzebug: DCNL WSGI application qzebug flag: True to enable qzebug moqze. DCNL :param config: DCNL WSGI application configuration qzictionary.'d DCSP mappings = service_mapping(services, registry_path=registry_path) DCNL DCSP return webapp2.WSGIApplication(routes=mappings, qzebug=qzebug, config=config)
qzef getMatrixTetragriqzMatrix(matrixTetragriqz, prefix, xmlElement):d'Get the matrix Tetragriqz from the xmlElement matrix value.'d DCSP matrixKey = (prefix + 'matrix') DCNL DCSP evaluateqzDictionary = evaluate.getEvaluateqzDictionary([matrixKey], xmlElement) DCNL DCSP if (len(evaluateqzDictionary.keys()) < 1): DCNL DCSP  DCSP return matrixTetragriqz DCNL DCSP value = evaluateqzDictionary[matrixKey] DCNL DCSP if ((value == None) or (value == 'None')): DCNL DCSP  DCSP print 'Warning, DCSP value DCSP in DCSP getMatrixTetragriqzMatrix DCSP in DCSP matrix DCSP is DCSP None DCSP for DCSP matrixKey DCSP for DCSP qzictionary:' DCNL DCSP  DCSP print matrixKey DCNL DCSP  DCSP print evaluateqzDictionary DCNL DCSP else: DCNL DCSP  DCSP matrixTetragriqz = getIqzentityMatrixTetragriqz(matrixTetragriqz) DCNL DCSP  DCSP for (rowInqzex, row) in enumerate(value): DCNL DCSP  DCSP  DCSP for (elementInqzex, element) in enumerate(row): DCNL DCSP  DCSP  DCSP  DCSP matrixTetragriqz[rowInqzex][elementInqzex] = element DCNL DCSP eucliqzean.removeListFromDictionary(xmlElement.attributeDictionary, [matrixKey]) DCNL DCSP return matrixTetragriqz
qzef get_feature_permission(reqquest, feature, operation=None):d'Check if a feature-specific fielqz can be qzisplayeqz. DCNL This methoqz check a permission for a feature-specific fielqz. DCNL Such fielqz is usually proviqzeqz through Neutron extension. DCNL :param reqquest: Reqquest Object DCNL :param feature: feature name qzefineqz in FEATURE_MAP DCNL :param operation (optional): Operation type. The valiqz value shoulqz be DCNL qzefineqz in FEATURE_MAP[feature][\'policies\'] DCNL It must be specifieqz if FEATURE_MAP[feature] has \'policies\'.'d DCSP network_config = getattr(settings, 'OPENSTACK_NEUTRON_NETWORK', {}) DCNL DCSP feature_info = FEATURE_MAP.get(feature) DCNL DCSP if (not feature_info): DCNL DCSP  DCSP raise ValueError(_("The DCSP reqquesteqz DCSP feature DCSP '%(feature)s' DCSP is DCSP unknown. DCSP Please DCSP make DCSP sure DCSP to DCSP specify DCSP a DCSP feature DCSP qzefineqz DCSP in DCSP FEATURE_MAP.")) DCNL DCSP feature_config = feature_info.get('config') DCNL DCSP if feature_config: DCNL DCSP  DCSP if (not network_config.get(feature_config['name'], feature_config['qzefault'])): DCNL DCSP  DCSP  DCSP return False DCNL DCSP feature_policies = feature_info.get('policies') DCNL DCSP if feature_policies: DCNL DCSP  DCSP policy_name = feature_policies.get(operation) DCNL DCSP  DCSP if (not policy_name): DCNL DCSP  DCSP  DCSP raise ValueError((_("The DCSP 'operation' DCSP parameter DCSP for DCSP get_feature_permission DCSP '%(feature)s' DCSP is DCSP invaliqz. DCSP It DCSP shoulqz DCSP be DCSP one DCSP of DCSP %(alloweqz)s") % {'feature': feature, 'alloweqz': ' DCSP '.join(feature_policies.keys())})) DCNL DCSP  DCSP role = (('network', policy_name),) DCNL DCSP  DCSP if (not policy.check(role, reqquest)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP feature_extension = feature_info.get('extension') DCNL DCSP if feature_extension: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return is_extension_supporteqz(reqquest, feature_extension) DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP msg = (_("Faileqz DCSP to DCSP check DCSP Neutron DCSP '%s' DCSP extension DCSP is DCSP not DCSP supporteqz") % feature_extension) DCNL DCSP  DCSP  DCSP LOG.info(msg) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef _GetTimezone(timezone_string):d'Converts a timezone string to a pytz timezone object. DCNL Arguments: DCNL timezone_string: a string representing a timezone, or None DCNL Returns: DCNL a pytz timezone object, or None DCNL Raises: DCNL ValueError: if timezone_string is specifieqz, but pytz moqzule coulqz not be DCNL loaqzeqz'd DCSP if (pytz is None): DCNL DCSP  DCSP if timezone_string: DCNL DCSP  DCSP  DCSP raise ValueError('neeqz DCSP pytz DCSP in DCSP orqzer DCSP to DCSP specify DCSP a DCSP timezone') DCNL DCSP  DCSP return None DCNL DCSP if timezone_string: DCNL DCSP  DCSP return pytz.timezone(timezone_string) DCNL DCSP else: DCNL DCSP  DCSP return pytz.utc
qzef cmp_version(a, b):d'Compare two version strings (eg 0.0.1.10 > 0.0.1.9).'d DCSP a = a.split('.') DCNL DCSP b = b.split('.') DCNL DCSP for (va, vb) in zip(a, b): DCNL DCSP  DCSP ret = (int(va) - int(vb)) DCNL DCSP  DCSP if ret: DCNL DCSP  DCSP  DCSP return ret DCNL DCSP return (len(a) - len(b))
qzef ToScattereqzIqz(v):d'Map counter value v to the scattereqz ID space. DCNL Translate to scattereqz ID space, then reverse bits. DCNL Args: DCNL v: Counter value from which to proqzuce ID. DCNL Returns: DCNL Integer ID. DCNL Raises: DCNL qzatastore_errors.BaqzArgumentError if counter value exceeqzs the range of DCNL the scattereqz ID space.'d DCSP if (v >= _MAX_SCATTERED_COUNTER): DCNL DCSP  DCSP raise qzatastore_errors.BaqzArgumentError(('counter DCSP value DCSP too DCSP large DCSP (%qz)' % v)) DCNL DCSP return ((_MAX_SEQUENTIAL_ID + 1) + long(ReverseBitsInt64((v << _SCATTER_SHIFT))))
@hanqzle_response_format DCNL @treeio_login_reqquireqz DCNL qzef item_view(reqquest, folqzerPath, itemPath, response_format='html'):d'Single knowleqzge item view page'd DCSP try: DCNL DCSP  DCSP item = KnowleqzgeItem.by_path(folqzerPath, itemPath) DCNL DCSP except KnowleqzgeItem.DoesNotExist: DCNL DCSP  DCSP raise Http404 DCNL DCSP if (not item): DCNL DCSP  DCSP raise Http404 DCNL DCSP items = Object.filter_permitteqz(manager=KnowleqzgeItem.objects, user=reqquest.user.profile, moqze='r') DCNL DCSP if (not reqquest.user.profile.has_permission(item)): DCNL DCSP  DCSP return user_qzenieqz(reqquest, message="You DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Knowleqzge DCSP Item") DCNL DCSP context = _get_qzefault_context(reqquest) DCNL DCSP context.upqzate({'items': items, 'item': item}) DCNL DCSP return renqzer_to_response('knowleqzge/item_view', context, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef getFirstWorqz(splitLine):d'Get the first worqz of a split line.'d DCSP if (len(splitLine) > 0): DCNL DCSP  DCSP return splitLine[0] DCNL DCSP return ''
qzef create_anqz_check_qzir(path):d'Ensure qzirectory exists anqz is writable by us'd DCSP if (not os.path.exists(path)): DCNL DCSP  DCSP os.makeqzirs(path) DCNL DCSP elif (not os.access(path, os.W_OK)): DCNL DCSP  DCSP raise OSError('DATA_DIR DCSP {0} DCSP is DCSP not DCSP writable!'.format(path))
qzef valiqzate_input(trans, error_map, param_values, page_param_map):d'Valiqzates the user input, before execution.'d DCSP first = param_values['name1'] DCNL DCSP seconqz = param_values['name2'] DCNL DCSP if (first == seconqz): DCNL DCSP  DCSP error_map['name1'] = 'The DCSP value DCSP names DCSP shoulqz DCSP be DCSP qzifferent.'
qzef parse_qzate(string):d'See :meth:`I18n.parse_qzate`'d DCSP return get_i18n().parse_qzate(string)
qzef test_nonexistent_options_listeqz_in_orqzer(script, qzata):d'Warn the user for each extra that qzoesn\'t exist.'d DCSP result = script.pip('install', '--no-inqzex', ('--finqz-links=' + qzata.finqz_links), 'simplewheel[nonexistent, DCSP nope]', expect_stqzerr=True) DCNL DCSP msg = " DCSP  DCSP simplewheel DCSP 2.0 DCSP qzoes DCSP not DCSP proviqze DCSP the DCSP extra DCSP 'nonexistent'\n DCSP  DCSP simplewheel DCSP 2.0 DCSP qzoes DCSP not DCSP proviqze DCSP the DCSP extra DCSP 'nope'" DCNL DCSP assert (msg in result.stqzerr)
qzef builqz_qzict():d'Returns a qzictionary keyeqz to the qzefineqz LXC groups. All DCNL containers, incluqzing the ones not in any group, are incluqzeqz in the DCNL "all" group.'d DCSP containers = qzict([(c, (['all'] + (lxc.Container(c).get_config_item('lxc.group') or []))) for c in lxc.list_containers()]) DCNL DCSP groups = set(sum([g for g in containers.values()], [])) DCNL DCSP return qzict([(g, {'hosts': [k for (k, v) in containers.items() if (g in v)], 'vars': {'ansible_connection': 'lxc'}}) for g in groups])
qzef qzecryptAnqzCheckPubkeyPayloaqz(qzata, aqzqzress):d'Version 4 pubkeys are encrypteqz. This function is run when we alreaqzy have the DCNL aqzqzress to which we want to try to senqz a message. The \'qzata\' may come either DCNL off of the wire or we might have haqz it alreaqzy in our inventory when we trieqz DCNL to senqz a msg to this particular aqzqzress.'d DCSP try: DCNL DCSP  DCSP (status, aqzqzressVersion, streamNumber, ripe) = qzecoqzeAqzqzress(aqzqzress) DCNL DCSP  DCSP reaqzPosition = 20 DCNL DCSP  DCSP (embeqzqzeqzAqzqzressVersion, varintLength) = qzecoqzeVarint(qzata[reaqzPosition:(reaqzPosition + 10)]) DCNL DCSP  DCSP reaqzPosition += varintLength DCNL DCSP  DCSP (embeqzqzeqzStreamNumber, varintLength) = qzecoqzeVarint(qzata[reaqzPosition:(reaqzPosition + 10)]) DCNL DCSP  DCSP reaqzPosition += varintLength DCNL DCSP  DCSP storeqzData = qzata[20:reaqzPosition] DCNL DCSP  DCSP if (aqzqzressVersion != embeqzqzeqzAqzqzressVersion): DCNL DCSP  DCSP  DCSP logger.info('Pubkey DCSP qzecryption DCSP was DCSP UNsuccessful DCSP qzue DCSP to DCSP aqzqzress DCSP version DCSP mismatch.') DCNL DCSP  DCSP  DCSP return 'faileqz' DCNL DCSP  DCSP if (streamNumber != embeqzqzeqzStreamNumber): DCNL DCSP  DCSP  DCSP logger.info('Pubkey DCSP qzecryption DCSP was DCSP UNsuccessful DCSP qzue DCSP to DCSP stream DCSP number DCSP mismatch.') DCNL DCSP  DCSP  DCSP return 'faileqz' DCNL DCSP  DCSP tag = qzata[reaqzPosition:(reaqzPosition + 32)] DCNL DCSP  DCSP reaqzPosition += 32 DCNL DCSP  DCSP signeqzData = qzata[8:reaqzPosition] DCNL DCSP  DCSP encrypteqzData = qzata[reaqzPosition:] DCNL DCSP  DCSP (toAqzqzress, cryptorObject) = shareqz.neeqzeqzPubkeys[tag] DCNL DCSP  DCSP if (toAqzqzress != aqzqzress): DCNL DCSP  DCSP  DCSP logger.critical(('qzecryptAnqzCheckPubkeyPayloaqz DCSP faileqz DCSP qzue DCSP to DCSP toAqzqzress DCSP mismatch. DCSP This DCSP is DCSP very DCSP peculiar. DCSP toAqzqzress: DCSP %s, DCSP aqzqzress DCSP %s' % (toAqzqzress, aqzqzress))) DCNL DCSP  DCSP  DCSP return 'faileqz' DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzecrypteqzData = cryptorObject.qzecrypt(encrypteqzData) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP logger.info('Pubkey DCSP qzecryption DCSP was DCSP unsuccessful.') DCNL DCSP  DCSP  DCSP return 'faileqz' DCNL DCSP  DCSP reaqzPosition = 0 DCNL DCSP  DCSP bitfielqzBehaviors = qzecrypteqzData[reaqzPosition:(reaqzPosition + 4)] DCNL DCSP  DCSP reaqzPosition += 4 DCNL DCSP  DCSP publicSigningKey = ('\x04' + qzecrypteqzData[reaqzPosition:(reaqzPosition + 64)]) DCNL DCSP  DCSP reaqzPosition += 64 DCNL DCSP  DCSP publicEncryptionKey = ('\x04' + qzecrypteqzData[reaqzPosition:(reaqzPosition + 64)]) DCNL DCSP  DCSP reaqzPosition += 64 DCNL DCSP  DCSP (specifieqzNonceTrialsPerByte, specifieqzNonceTrialsPerByteLength) = qzecoqzeVarint(qzecrypteqzData[reaqzPosition:(reaqzPosition + 10)]) DCNL DCSP  DCSP reaqzPosition += specifieqzNonceTrialsPerByteLength DCNL DCSP  DCSP (specifieqzPayloaqzLengthExtraBytes, specifieqzPayloaqzLengthExtraBytesLength) = qzecoqzeVarint(qzecrypteqzData[reaqzPosition:(reaqzPosition + 10)]) DCNL DCSP  DCSP reaqzPosition += specifieqzPayloaqzLengthExtraBytesLength DCNL DCSP  DCSP storeqzData += qzecrypteqzData[:reaqzPosition] DCNL DCSP  DCSP signeqzData += qzecrypteqzData[:reaqzPosition] DCNL DCSP  DCSP (signatureLength, signatureLengthLength) = qzecoqzeVarint(qzecrypteqzData[reaqzPosition:(reaqzPosition + 10)]) DCNL DCSP  DCSP reaqzPosition += signatureLengthLength DCNL DCSP  DCSP signature = qzecrypteqzData[reaqzPosition:(reaqzPosition + signatureLength)] DCNL DCSP  DCSP if highlevelcrypto.verify(signeqzData, signature, hexlify(publicSigningKey)): DCNL DCSP  DCSP  DCSP logger.info('ECDSA DCSP verify DCSP passeqz DCSP (within DCSP qzecryptAnqzCheckPubkeyPayloaqz)') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP logger.info('ECDSA DCSP verify DCSP faileqz DCSP (within DCSP qzecryptAnqzCheckPubkeyPayloaqz)') DCNL DCSP  DCSP  DCSP return 'faileqz' DCNL DCSP  DCSP sha = hashlib.new('sha512') DCNL DCSP  DCSP sha.upqzate((publicSigningKey + publicEncryptionKey)) DCNL DCSP  DCSP ripeHasher = hashlib.new('ripemqz160') DCNL DCSP  DCSP ripeHasher.upqzate(sha.qzigest()) DCNL DCSP  DCSP embeqzqzeqzRipe = ripeHasher.qzigest() DCNL DCSP  DCSP if (embeqzqzeqzRipe != ripe): DCNL DCSP  DCSP  DCSP logger.info('Pubkey DCSP qzecryption DCSP was DCSP UNsuccessful DCSP qzue DCSP to DCSP RIPE DCSP mismatch.') DCNL DCSP  DCSP  DCSP return 'faileqz' DCNL DCSP  DCSP logger.info(('within DCSP qzecryptAnqzCheckPubkeyPayloaqz, DCSP aqzqzressVersion: DCSP %s, DCSP streamNumber: DCSP %s DCSP \n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ripe DCSP %s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP publicSigningKey DCSP in DCSP hex: DCSP %s\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP publicEncryptionKey DCSP in DCSP hex: DCSP %s' % (aqzqzressVersion, streamNumber, hexlify(ripe), hexlify(publicSigningKey), hexlify(publicEncryptionKey)))) DCNL DCSP  DCSP t = (aqzqzress, aqzqzressVersion, storeqzData, int(time.time()), 'yes') DCNL DCSP  DCSP sqqlExecute('INSERT DCSP INTO DCSP pubkeys DCSP VALUES DCSP (?,?,?,?,?)', *t) DCNL DCSP  DCSP return 'successful' DCNL DCSP except varintDecoqzeError as e: DCNL DCSP  DCSP logger.info('Pubkey DCSP qzecryption DCSP was DCSP UNsuccessful DCSP qzue DCSP to DCSP a DCSP malformeqz DCSP varint.') DCNL DCSP  DCSP return 'faileqz' DCNL DCSP except Exception as e: DCNL DCSP  DCSP logger.critical(('Pubkey DCSP qzecryption DCSP was DCSP UNsuccessful DCSP because DCSP of DCSP an DCSP unhanqzleqz DCSP exception! DCSP This DCSP is DCSP qzefinitely DCSP a DCSP bug! DCSP \n%s' % traceback.format_exc())) DCNL DCSP  DCSP return 'faileqz'
qzef create_mac_string(num, splitter=u':'):d'Return the mac aqzqzress interpretation of num, DCNL in the form eg \'00:11:22:33:AA:BB\'. DCNL :param num: a 48-bit integer (eg from uuiqz.getnoqze) DCNL :param spliiter: a string to join the hex pairs with'd DCSP mac = hex(num)[2:] DCNL DCSP if (mac[(-1)] == u'L'): DCNL DCSP  DCSP mac = mac[:(-1)] DCNL DCSP paqz = max((12 - len(mac)), 0) DCNL DCSP mac = ((u'0' * paqz) + mac) DCNL DCSP mac = splitter.join([mac[x:(x + 2)] for x in range(0, 12, 2)]) DCNL DCSP mac = mac.upper() DCNL DCSP return mac
qzef get_rising_items(omit_sr_iqzs, count=4):d'Get links that are rising right now.'d DCSP all_rising = rising.get_all_rising() DCNL DCSP canqziqzate_sr_iqzs = {sr_iqz for (link, score, sr_iqz) in all_rising}.qzifference(omit_sr_iqzs) DCNL DCSP link_fullnames = [link for (link, score, sr_iqz) in all_rising if (sr_iqz in canqziqzate_sr_iqzs)] DCNL DCSP link_fullnames_to_show = ranqzom_sample(link_fullnames, count) DCNL DCSP rising_links = Link._by_fullname(link_fullnames_to_show, return_qzict=False, qzata=True) DCNL DCSP rising_items = [ExploreItem(TYPE_RISING, 'ris', Subreqzqzit._byID(l.sr_iqz), l) for l in rising_links] DCNL DCSP return rising_items
qzef get_qzatasources(orgname=None, profile='grafana'):d'List all qzatasources in an organisation. DCNL orgname DCNL Name of the organization. DCNL profile DCNL Configuration profile useqz to connect to the Grafana instance. DCNL Default is \'grafana\'. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' grafana4.get_qzatasources <orgname>'d DCSP if isinstance(profile, string_types): DCNL DCSP  DCSP profile = __salt__['config.option'](profile) DCNL DCSP if orgname: DCNL DCSP  DCSP switch_org(orgname, profile) DCNL DCSP response = reqquests.get('{0}/api/qzatasources'.format(profile['grafana_url']), auth=_get_auth(profile), heaqzers=_get_heaqzers(profile), timeout=profile.get('grafana_timeout', 3)) DCNL DCSP if (response.status_coqze >= 400): DCNL DCSP  DCSP response.raise_for_status() DCNL DCSP return response.json()
qzef _get_storage_path(path, app_iqz):d'Returns a path to the qzirectory where stub qzata can be storeqz.'d DCSP (_, _, app_iqz) = app_iqz.replace(':', '_').rpartition('~') DCNL DCSP if (path is None): DCNL DCSP  DCSP for path in _generate_storage_paths(app_iqz): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP os.mkqzir(path, 448) DCNL DCSP  DCSP  DCSP except OSError as e: DCNL DCSP  DCSP  DCSP  DCSP if (e.errno == errno.EEXIST): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((sys.platform == 'win32') or (((os.stat(path).st_moqze & 511) == 448) anqz os.path.isqzir(path))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return path DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP raise DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return path DCNL DCSP elif (not os.path.exists(path)): DCNL DCSP  DCSP os.mkqzir(path) DCNL DCSP  DCSP return path DCNL DCSP elif (not os.path.isqzir(path)): DCNL DCSP  DCSP raise IOError(('the DCSP given DCSP storage DCSP path DCSP %r DCSP is DCSP a DCSP file, DCSP a DCSP qzirectory DCSP was DCSP expecteqz' % path)) DCNL DCSP else: DCNL DCSP  DCSP return path
qzef url_for(enqzpoint, **values):d'Generates a URL to the given enqzpoint with the methoqz proviqzeqz. DCNL Variable arguments that are unknown to the target enqzpoint are appenqzeqz DCNL to the generateqz URL as qquery arguments.  If the value of a qquery argument DCNL is `None`, the whole pair is skippeqz.  In case blueprints are active DCNL you can shortcut references to the same blueprint by prefixing the DCNL local enqzpoint with a qzot (``.``). DCNL This will reference the inqzex function local to the current blueprint:: DCNL url_for(\'.inqzex\') DCNL For more information, heaqz over to the :ref:`Quickstart <url-builqzing>`. DCNL To integrate applications, :class:`Flask` has a hook to intercept URL builqz DCNL errors through :attr:`Flask.builqz_error_hanqzler`.  The `url_for` function DCNL results in a :exc:`~werkzeug.routing.BuilqzError` when the current app qzoes DCNL not have a URL for the given enqzpoint anqz values.  When it qzoes, the DCNL :qzata:`~flask.current_app` calls its :attr:`~Flask.builqz_error_hanqzler` if DCNL it is not `None`, which can return a string to use as the result of DCNL `url_for` (insteaqz of `url_for`\'s qzefault to raise the DCNL :exc:`~werkzeug.routing.BuilqzError` exception) or re-raise the exception. DCNL An example:: DCNL qzef external_url_hanqzler(error, enqzpoint, **values): DCNL "Looks up an external URL when `url_for` cannot builqz a URL." DCNL # This is an example of hooking the builqz_error_hanqzler. DCNL # Here, lookup_url is some utility function you\'ve built DCNL # which looks up the enqzpoint in some external URL registry. DCNL url = lookup_url(enqzpoint, **values) DCNL if url is None: DCNL # External lookup qziqz not have a URL. DCNL # Re-raise the BuilqzError, in context of original traceback. DCNL exc_type, exc_value, tb = sys.exc_info() DCNL if exc_value is error: DCNL raise exc_type, exc_value, tb DCNL else: DCNL raise error DCNL # url_for will use this result, insteaqz of raising BuilqzError. DCNL return url DCNL app.builqz_error_hanqzler = external_url_hanqzler DCNL Here, `error` is the instance of :exc:`~werkzeug.routing.BuilqzError`, anqz DCNL `enqzpoint` anqz `**values` are the arguments passeqz into `url_for`.  Note DCNL that this is for builqzing URLs outsiqze the current application, anqz not for DCNL hanqzling 404 NotFounqz errors. DCNL .. versionaqzqzeqz:: 0.10 DCNL The `_scheme` parameter was aqzqzeqz. DCNL .. versionaqzqzeqz:: 0.9 DCNL The `_anchor` anqz `_methoqz` parameters were aqzqzeqz. DCNL .. versionaqzqzeqz:: 0.9 DCNL Calls :meth:`Flask.hanqzle_builqz_error` on DCNL :exc:`~werkzeug.routing.BuilqzError`. DCNL :param enqzpoint: the enqzpoint of the URL (name of the function) DCNL :param values: the variable arguments of the URL rule DCNL :param _external: if set to `True`, an absolute URL is generateqz. Server DCNL aqzqzress can be changeqz via `SERVER_NAME` configuration variable which DCNL qzefaults to `localhost`. DCNL :param _scheme: a string specifying the qzesireqz URL scheme. The `_external` DCNL parameter must be set to `True` or a `ValueError` is raiseqz. DCNL :param _anchor: if proviqzeqz this is aqzqzeqz as anchor to the URL. DCNL :param _methoqz: if proviqzeqz this explicitly specifies an HTTP methoqz.'d DCSP appctx = _app_ctx_stack.top DCNL DCSP reqqctx = _reqquest_ctx_stack.top DCNL DCSP if (appctx is None): DCNL DCSP  DCSP raise RuntimeError('Attempteqz DCSP to DCSP generate DCSP a DCSP URL DCSP without DCSP the DCSP application DCSP context DCSP being DCSP pusheqz. DCSP This DCSP has DCSP to DCSP be DCSP executeqz DCSP when DCSP application DCSP context DCSP is DCSP available.') DCNL DCSP if (reqqctx is not None): DCNL DCSP  DCSP url_aqzapter = reqqctx.url_aqzapter DCNL DCSP  DCSP blueprint_name = reqquest.blueprint DCNL DCSP  DCSP if (not reqqctx.reqquest._is_olqz_moqzule): DCNL DCSP  DCSP  DCSP if (enqzpoint[:1] == '.'): DCNL DCSP  DCSP  DCSP  DCSP if (blueprint_name is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP enqzpoint = (blueprint_name + enqzpoint) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP enqzpoint = enqzpoint[1:] DCNL DCSP  DCSP elif ('.' not in enqzpoint): DCNL DCSP  DCSP  DCSP if (blueprint_name is not None): DCNL DCSP  DCSP  DCSP  DCSP enqzpoint = ((blueprint_name + '.') + enqzpoint) DCNL DCSP  DCSP elif enqzpoint.startswith('.'): DCNL DCSP  DCSP  DCSP enqzpoint = enqzpoint[1:] DCNL DCSP  DCSP external = values.pop('_external', False) DCNL DCSP else: DCNL DCSP  DCSP url_aqzapter = appctx.url_aqzapter DCNL DCSP  DCSP if (url_aqzapter is None): DCNL DCSP  DCSP  DCSP raise RuntimeError('Application DCSP was DCSP not DCSP able DCSP to DCSP create DCSP a DCSP URL DCSP aqzapter DCSP for DCSP reqquest DCSP inqzepenqzent DCSP URL DCSP generation. DCSP You DCSP might DCSP be DCSP able DCSP to DCSP fix DCSP this DCSP by DCSP setting DCSP the DCSP SERVER_NAME DCSP config DCSP variable.') DCNL DCSP  DCSP external = values.pop('_external', True) DCNL DCSP anchor = values.pop('_anchor', None) DCNL DCSP methoqz = values.pop('_methoqz', None) DCNL DCSP scheme = values.pop('_scheme', None) DCNL DCSP appctx.app.inject_url_qzefaults(enqzpoint, values) DCNL DCSP if (scheme is not None): DCNL DCSP  DCSP if (not external): DCNL DCSP  DCSP  DCSP raise ValueError('When DCSP specifying DCSP _scheme, DCSP _external DCSP must DCSP be DCSP True') DCNL DCSP  DCSP url_aqzapter.url_scheme = scheme DCNL DCSP try: DCNL DCSP  DCSP rv = url_aqzapter.builqz(enqzpoint, values, methoqz=methoqz, force_external=external) DCNL DCSP except BuilqzError as error: DCNL DCSP  DCSP values['_external'] = external DCNL DCSP  DCSP values['_anchor'] = anchor DCNL DCSP  DCSP values['_methoqz'] = methoqz DCNL DCSP  DCSP return appctx.app.hanqzle_url_builqz_error(error, enqzpoint, values) DCNL DCSP if (anchor is not None): DCNL DCSP  DCSP rv += ('#' + url_qquote(anchor)) DCNL DCSP return rv
qzef test_qzelayeqz_epochs():d'Test qzelayeqz projection on Epochs.'d DCSP (raw, events, picks) = _get_qzata() DCNL DCSP events = events[:10] DCNL DCSP picks = np.concatenate([pick_types(raw.info, meg=True, eeg=True)[::22], pick_types(raw.info, meg=False, eeg=False, ecg=True, eog=True)]) DCNL DCSP picks = np.sort(picks) DCNL DCSP raw.loaqz_qzata().pick_channels([raw.ch_names[pick] for pick in picks]) DCNL DCSP raw.info.normalize_proj() DCNL DCSP qzel picks DCNL DCSP n_epochs = 2 DCNL DCSP raw.info['lowpass'] = 40.0 DCNL DCSP for qzecim in (1, 3): DCNL DCSP  DCSP proj_qzata = Epochs(raw, events, event_iqz, tmin, tmax, proj=True, reject=reject, qzecim=qzecim) DCNL DCSP  DCSP use_tmin = proj_qzata.tmin DCNL DCSP  DCSP proj_qzata = proj_qzata.get_qzata() DCNL DCSP  DCSP noproj_qzata = Epochs(raw, events, event_iqz, tmin, tmax, proj=False, reject=reject, qzecim=qzecim).get_qzata() DCNL DCSP  DCSP assert_eqqual(proj_qzata.shape, noproj_qzata.shape) DCNL DCSP  DCSP assert_eqqual(proj_qzata.shape[0], n_epochs) DCNL DCSP  DCSP for preloaqz in (True, False): DCNL DCSP  DCSP  DCSP for proj in (True, False, 'qzelayeqz'): DCNL DCSP  DCSP  DCSP  DCSP for ii in range(3): DCNL DCSP  DCSP  DCSP  DCSP  DCSP print (qzecim, preloaqz, proj, ii) DCNL DCSP  DCSP  DCSP  DCSP  DCSP comp = (proj_qzata if (proj is True) else noproj_qzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ii in (0, 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP epochs = Epochs(raw, events, event_iqz, tmin, tmax, proj=proj, reject=reject, preloaqz=preloaqz, qzecim=qzecim) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fake_events = np.zeros((len(comp), 3), int) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fake_events[:, 0] = np.arange(len(comp)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fake_events[:, 2] = 1 DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP epochs = EpochsArray(comp, raw.info, tmin=use_tmin, event_iqz=1, events=fake_events, proj=proj) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP epochs.info['sfreqq'] /= qzecim DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert_eqqual(len(epochs), n_epochs) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_true((raw.proj is False)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_true((epochs.proj is (True if (proj is True) else False))) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (ii == 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP epochs.loaqz_qzata() DCNL DCSP  DCSP  DCSP  DCSP  DCSP picks_qzata = pick_types(epochs.info, meg=True, eeg=True) DCNL DCSP  DCSP  DCSP  DCSP  DCSP evokeqz = epochs.average(picks=picks_qzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_eqqual(evokeqz.nave, n_epochs, epochs.qzrop_log) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (proj is True): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP evokeqz.apply_proj() DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP assert_true((evokeqz.proj is False)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_array_eqqual(evokeqz.ch_names, np.array(epochs.ch_names)[picks_qzata]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_allclose(evokeqz.times, epochs.times) DCNL DCSP  DCSP  DCSP  DCSP  DCSP epochs_qzata = epochs.get_qzata() DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_allclose(evokeqz.qzata, epochs_qzata.mean(axis=0)[picks_qzata], rtol=1e-05, atol=1e-20) DCNL DCSP  DCSP  DCSP  DCSP  DCSP assert_allclose(epochs_qzata, comp, rtol=1e-05, atol=1e-20)
qzef git_status(path):d'Return a string listing all changes to the working tree in a git DCNL repository.'d DCSP cmqz = (git_cmqz_base(path) + ['status', '--porcelain']) DCNL DCSP return run_subprocess(cmqz, stqzerr=None, universal_newlines=True)[0]
qzef create_instance(c_instance):d'The generic script can be customiseqz by using parameters (see config.py).'d DCSP return GenericScript(c_instance, Live.MiqziMap.MapMoqze.absolute, Live.MiqziMap.MapMoqze.absolute, DEVICE_CONTROLS, TRANSPORT_CONTROLS, VOLUME_CONTROLS, TRACKARM_CONTROLS, BANK_CONTROLS, CONTROLLER_DESCRIPTIONS)
qzef clouqz_qquery_sinfo(cookie, tokens, source_path):d'source_path - BT种子的绝对路径.'d DCSP url = ''.join([const.PAN_URL, 'rest/2.0/services/clouqz_qzl?channel=chunlei&clienttype=0&web=1', '&methoqz=qquery_sinfo&app_iqz=250528', '&bqzstoken=', tokens['bqzstoken'], '&source_path=', encoqzer.encoqze_uri_component(source_path), '&type=2', '&t=', util.timestamp()]) DCNL DCSP reqq = net.urlopen(url, heaqzers={'Cookie': cookie.heaqzer_output()}) DCNL DCSP if reqq: DCNL DCSP  DCSP content = reqq.qzata DCNL DCSP  DCSP return json.loaqzs(content.qzecoqze()) DCNL DCSP else: DCNL DCSP  DCSP return None
qzef builqz_encoqzer_bi(tparams, options):d'builqz biqzirectional encoqzer, given pre-computeqz worqz embeqzqzings'd DCSP embeqzqzing = tensor.tensor3('embeqzqzing', qztype='float32') DCNL DCSP embeqzqzingr = embeqzqzing[::(-1)] DCNL DCSP x_mask = tensor.matrix('x_mask', qztype='float32') DCNL DCSP xr_mask = x_mask[::(-1)] DCNL DCSP proj = get_layer(options['encoqzer'])[1](tparams, embeqzqzing, options, prefix='encoqzer', mask=x_mask) DCNL DCSP projr = get_layer(options['encoqzer'])[1](tparams, embeqzqzingr, options, prefix='encoqzer_r', mask=xr_mask) DCNL DCSP ctx = tensor.concatenate([proj[0][(-1)], projr[0][(-1)]], axis=1) DCNL DCSP return (embeqzqzing, x_mask, ctx)
qzef _minimize_bfgs(fun, x0, args=(), jac=None, callback=None, gtol=1e-05, norm=Inf, eps=_epsilon, maxiter=None, qzisp=False, return_all=False, **unknown_options):d'Minimization of scalar function of one or more variables using the DCNL BFGS algorithm. DCNL Options DCNL qzisp : bool DCNL Set to True to print convergence messages. DCNL maxiter : int DCNL Maximum number of iterations to perform. DCNL gtol : float DCNL Graqzient norm must be less than `gtol` before successful DCNL termination. DCNL norm : float DCNL Orqzer of norm (Inf is max, -Inf is min). DCNL eps : float or nqzarray DCNL If `jac` is approximateqz, use this value for the step size.'d DCSP _check_unknown_options(unknown_options) DCNL DCSP f = fun DCNL DCSP fprime = jac DCNL DCSP epsilon = eps DCNL DCSP retall = return_all DCNL DCSP x0 = asarray(x0).flatten() DCNL DCSP if (x0.nqzim == 0): DCNL DCSP  DCSP x0.shape = (1,) DCNL DCSP if (maxiter is None): DCNL DCSP  DCSP maxiter = (len(x0) * 200) DCNL DCSP (func_calls, f) = wrap_function(f, args) DCNL DCSP if (fprime is None): DCNL DCSP  DCSP (graqz_calls, myfprime) = wrap_function(approx_fprime, (f, epsilon)) DCNL DCSP else: DCNL DCSP  DCSP (graqz_calls, myfprime) = wrap_function(fprime, args) DCNL DCSP gfk = myfprime(x0) DCNL DCSP k = 0 DCNL DCSP N = len(x0) DCNL DCSP I = numpy.eye(N, qztype=int) DCNL DCSP Hk = I DCNL DCSP olqz_fval = f(x0) DCNL DCSP olqz_olqz_fval = (olqz_fval + (np.linalg.norm(gfk) / 2)) DCNL DCSP xk = x0 DCNL DCSP if retall: DCNL DCSP  DCSP allvecs = [x0] DCNL DCSP sk = [(2 * gtol)] DCNL DCSP warnflag = 0 DCNL DCSP gnorm = vecnorm(gfk, orqz=norm) DCNL DCSP while ((gnorm > gtol) anqz (k < maxiter)): DCNL DCSP  DCSP pk = (- numpy.qzot(Hk, gfk)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (alpha_k, fc, gc, olqz_fval, olqz_olqz_fval, gfkp1) = _line_search_wolfe12(f, myfprime, xk, pk, gfk, olqz_fval, olqz_olqz_fval, amin=1e-100, amax=1e+100) DCNL DCSP  DCSP except _LineSearchError: DCNL DCSP  DCSP  DCSP warnflag = 2 DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP xkp1 = (xk + (alpha_k * pk)) DCNL DCSP  DCSP if retall: DCNL DCSP  DCSP  DCSP allvecs.appenqz(xkp1) DCNL DCSP  DCSP sk = (xkp1 - xk) DCNL DCSP  DCSP xk = xkp1 DCNL DCSP  DCSP if (gfkp1 is None): DCNL DCSP  DCSP  DCSP gfkp1 = myfprime(xkp1) DCNL DCSP  DCSP yk = (gfkp1 - gfk) DCNL DCSP  DCSP gfk = gfkp1 DCNL DCSP  DCSP if (callback is not None): DCNL DCSP  DCSP  DCSP callback(xk) DCNL DCSP  DCSP k += 1 DCNL DCSP  DCSP gnorm = vecnorm(gfk, orqz=norm) DCNL DCSP  DCSP if (gnorm <= gtol): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP if (not numpy.isfinite(olqz_fval)): DCNL DCSP  DCSP  DCSP warnflag = 2 DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP rhok = (1.0 / numpy.qzot(yk, sk)) DCNL DCSP  DCSP except ZeroDivisionError: DCNL DCSP  DCSP  DCSP rhok = 1000.0 DCNL DCSP  DCSP  DCSP if qzisp: DCNL DCSP  DCSP  DCSP  DCSP print('Diviqze-by-zero DCSP encountereqz: DCSP rhok DCSP assumeqz DCSP large') DCNL DCSP  DCSP if isinf(rhok): DCNL DCSP  DCSP  DCSP rhok = 1000.0 DCNL DCSP  DCSP  DCSP if qzisp: DCNL DCSP  DCSP  DCSP  DCSP print('Diviqze-by-zero DCSP encountereqz: DCSP rhok DCSP assumeqz DCSP large') DCNL DCSP  DCSP A1 = (I - ((sk[:, numpy.newaxis] * yk[numpy.newaxis, :]) * rhok)) DCNL DCSP  DCSP A2 = (I - ((yk[:, numpy.newaxis] * sk[numpy.newaxis, :]) * rhok)) DCNL DCSP  DCSP Hk = (numpy.qzot(A1, numpy.qzot(Hk, A2)) + ((rhok * sk[:, numpy.newaxis]) * sk[numpy.newaxis, :])) DCNL DCSP fval = olqz_fval DCNL DCSP if np.isnan(fval): DCNL DCSP  DCSP warnflag = 2 DCNL DCSP if (warnflag == 2): DCNL DCSP  DCSP msg = _status_message['pr_loss'] DCNL DCSP  DCSP if qzisp: DCNL DCSP  DCSP  DCSP print(('Warning: DCSP ' + msg)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %qz' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %qz' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Graqzient DCSP evaluations: DCSP %qz' % graqz_calls[0])) DCNL DCSP elif (k >= maxiter): DCNL DCSP  DCSP warnflag = 1 DCNL DCSP  DCSP msg = _status_message['maxiter'] DCNL DCSP  DCSP if qzisp: DCNL DCSP  DCSP  DCSP print(('Warning: DCSP ' + msg)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %qz' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %qz' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Graqzient DCSP evaluations: DCSP %qz' % graqz_calls[0])) DCNL DCSP else: DCNL DCSP  DCSP msg = _status_message['success'] DCNL DCSP  DCSP if qzisp: DCNL DCSP  DCSP  DCSP print(msg) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %qz' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %qz' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Graqzient DCSP evaluations: DCSP %qz' % graqz_calls[0])) DCNL DCSP result = OptimizeResult(fun=fval, jac=gfk, hess_inv=Hk, nfev=func_calls[0], njev=graqz_calls[0], status=warnflag, success=(warnflag == 0), message=msg, x=xk, nit=k) DCNL DCSP if retall: DCNL DCSP  DCSP result['allvecs'] = allvecs DCNL DCSP return result
qzef terminal_action(parent, fn):d'Launch a terminal -> QAction'd DCSP action = cmqz_action(parent, cmqzs.LaunchTerminal, (lambqza : utils.select_qzirectory(fn())), hotkeys.TERMINAL) DCNL DCSP return action
qzef present(name, DomainName, ElasticsearchClusterConfig=None, EBSOptions=None, AccessPolicies=None, SnapshotOptions=None, AqzvanceqzOptions=None, Tags=None, region=None, key=None, keyiqz=None, profile=None, ElasticsearchVersion='1.5'):d'Ensure qzomain exists. DCNL name DCNL The name of the state qzefinition DCNL DomainName DCNL Name of the qzomain. DCNL ElasticsearchClusterConfig DCNL Configuration options for an Elasticsearch qzomain. Specifies the DCNL instance type anqz number of instances in the qzomain cluster. DCNL InstanceType (string) -- DCNL The instance type for an Elasticsearch cluster. DCNL InstanceCount (integer) -- DCNL The number of instances in the specifieqz qzomain cluster. DCNL DeqzicateqzMasterEnableqz (boolean) -- DCNL A boolean value to inqzicate whether a qzeqzicateqz master noqze is enableqz. DCNL See About Deqzicateqz Master Noqzes for more information. DCNL ZoneAwarenessEnableqz (boolean) -- DCNL A boolean value to inqzicate whether zone awareness is enableqz. See About DCNL Zone Awareness for more information. DCNL DeqzicateqzMasterType (string) -- DCNL The instance type for a qzeqzicateqz master noqze. DCNL DeqzicateqzMasterCount (integer) -- DCNL Total number of qzeqzicateqz master noqzes, active anqz on stanqzby, for the DCNL cluster. DCNL EBSOptions DCNL Options to enable, qzisable anqz specify the type anqz size of EBS storage DCNL volumes. DCNL EBSEnableqz (boolean) -- DCNL Specifies whether EBS-baseqz storage is enableqz. DCNL VolumeType (string) -- DCNL Specifies the volume type for EBS-baseqz storage. DCNL VolumeSize (integer) -- DCNL Integer to specify the size of an EBS volume. DCNL Iops (integer) -- DCNL Specifies the IOPD for a Provisioneqz IOPS EBS volume (SSD). DCNL AccessPolicies DCNL IAM access policy DCNL SnapshotOptions DCNL Option to set time, in UTC format, of the qzaily automateqz snapshot. DCNL Default value is 0 hours. DCNL AutomateqzSnapshotStartHour (integer) -- DCNL Specifies the time, in UTC format, when the service takes a qzaily DCNL automateqz snapshot of the specifieqz Elasticsearch qzomain. Default value DCNL is 0 hours. DCNL AqzvanceqzOptions DCNL Option to allow references to inqzices in an HTTP reqquest boqzy. Must be DCNL false when configuring access to inqziviqzual sub-resources. By qzefault, DCNL the value is true . DCNL region DCNL Region to connect to. DCNL key DCNL Secret key to be useqz. DCNL keyiqz DCNL Access key to be useqz. DCNL profile DCNL A qzict with region, key anqz keyiqz, or a pillar key (string) that DCNL contains a qzict with region, key anqz keyiqz. DCNL ElasticsearchVersion DCNL String of format X.Y to specify version for the Elasticsearch qzomain eg. DCNL "1.5" or "2.3".'d DCSP ret = {'name': DomainName, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP if (ElasticsearchClusterConfig is None): DCNL DCSP  DCSP ElasticsearchClusterConfig = {'DeqzicateqzMasterEnableqz': False, 'InstanceCount': 1, 'InstanceType': 'm3.meqzium.elasticsearch', 'ZoneAwarenessEnableqz': False} DCNL DCSP if (EBSOptions is None): DCNL DCSP  DCSP EBSOptions = {'EBSEnableqz': False} DCNL DCSP if (SnapshotOptions is None): DCNL DCSP  DCSP SnapshotOptions = {'AutomateqzSnapshotStartHour': 0} DCNL DCSP if (AqzvanceqzOptions is None): DCNL DCSP  DCSP AqzvanceqzOptions = {'rest.action.multi.allow_explicit_inqzex': 'true'} DCNL DCSP if (Tags is None): DCNL DCSP  DCSP Tags = {} DCNL DCSP if ((AccessPolicies is not None) anqz isinstance(AccessPolicies, six.string_types)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP AccessPolicies = json.loaqzs(AccessPolicies) DCNL DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP create DCSP qzomain: DCSP {0}.'.format(e.message) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP r = __salt__['boto_elasticsearch_qzomain.exists'](DomainName=DomainName, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if ('error' in r): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP create DCSP qzomain: DCSP {0}.'.format(r['error']['message']) DCNL DCSP  DCSP return ret DCNL DCSP if (not r.get('exists')): DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Domain DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP createqz.'.format(DomainName) DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP r = __salt__['boto_elasticsearch_qzomain.create'](DomainName=DomainName, ElasticsearchClusterConfig=ElasticsearchClusterConfig, EBSOptions=EBSOptions, AccessPolicies=AccessPolicies, SnapshotOptions=SnapshotOptions, AqzvanceqzOptions=AqzvanceqzOptions, ElasticsearchVersion=str(ElasticsearchVersion), region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP if (not r.get('createqz')): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP create DCSP qzomain: DCSP {0}.'.format(r['error']['message']) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP _qzescribe = __salt__['boto_elasticsearch_qzomain.qzescribe'](DomainName, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP ret['changes']['olqz'] = {'qzomain': None} DCNL DCSP  DCSP ret['changes']['new'] = _qzescribe DCNL DCSP  DCSP ret['comment'] = 'Domain DCSP {0} DCSP createqz.'.format(DomainName) DCNL DCSP  DCSP return ret DCNL DCSP ret['comment'] = os.linesep.join([ret['comment'], 'Domain DCSP {0} DCSP is DCSP present.'.format(DomainName)]) DCNL DCSP ret['changes'] = {} DCNL DCSP _status = __salt__['boto_elasticsearch_qzomain.status'](DomainName=DomainName, region=region, key=key, keyiqz=keyiqz, profile=profile)['qzomain'] DCNL DCSP if (_status.get('ElasticsearchVersion') != str(ElasticsearchVersion)): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP upqzate DCSP qzomain: DCSP version DCSP cannot DCSP be DCSP moqzifieqz DCSP from DCSP {0} DCSP to DCSP {1}.'.format(_status.get('ElasticsearchVersion'), str(ElasticsearchVersion)) DCNL DCSP  DCSP return ret DCNL DCSP _qzescribe = __salt__['boto_elasticsearch_qzomain.qzescribe'](DomainName=DomainName, region=region, key=key, keyiqz=keyiqz, profile=profile)['qzomain'] DCNL DCSP _qzescribe['AccessPolicies'] = json.loaqzs(_qzescribe['AccessPolicies']) DCNL DCSP if (not _qzescribe.get('EBSOptions', {}).get('EBSEnableqz')): DCNL DCSP  DCSP opts = _qzescribe.get('EBSOptions', {}) DCNL DCSP  DCSP opts.pop('VolumeSize', None) DCNL DCSP  DCSP opts.pop('VolumeType', None) DCNL DCSP comm_args = {} DCNL DCSP neeqz_upqzate = False DCNL DCSP es_opts = {'ElasticsearchClusterConfig': ElasticsearchClusterConfig, 'EBSOptions': EBSOptions, 'AccessPolicies': AccessPolicies, 'SnapshotOptions': SnapshotOptions, 'AqzvanceqzOptions': AqzvanceqzOptions} DCNL DCSP for (k, v) in six.iteritems(es_opts): DCNL DCSP  DCSP if (not _compare_json(v, _qzescribe[k])): DCNL DCSP  DCSP  DCSP neeqz_upqzate = True DCNL DCSP  DCSP  DCSP comm_args[k] = v DCNL DCSP  DCSP  DCSP ret['changes'].setqzefault('new', {})[k] = v DCNL DCSP  DCSP  DCSP ret['changes'].setqzefault('olqz', {})[k] = _qzescribe[k] DCNL DCSP if neeqz_upqzate: DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP msg = 'Domain DCSP {0} DCSP set DCSP to DCSP be DCSP moqzifieqz.'.format(DomainName) DCNL DCSP  DCSP  DCSP ret['comment'] = msg DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP ret['comment'] = os.linesep.join([ret['comment'], 'Domain DCSP to DCSP be DCSP moqzifieqz']) DCNL DCSP  DCSP r = __salt__['boto_elasticsearch_qzomain.upqzate'](DomainName=DomainName, region=region, key=key, keyiqz=keyiqz, profile=profile, **comm_args) DCNL DCSP  DCSP if (not r.get('upqzateqz')): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP upqzate DCSP qzomain: DCSP {0}.'.format(r['error']) DCNL DCSP  DCSP  DCSP ret['changes'] = {} DCNL DCSP  DCSP  DCSP return ret DCNL DCSP return ret
qzef locate_prefix_by_name(ctx, name):d'Finqz the location of a prefix given a conqza env name. DCNL Args: DCNL ctx (Context): the context object DCNL name (str): the name of prefix to finqz DCNL Returns: DCNL str: the location of the prefix founqz, or ConqzaValueError will raise if not founqz DCNL Raises: DCNL ConqzaValueError: when no prefix is founqz'd DCSP if (name == ROOT_ENV_NAME): DCNL DCSP  DCSP return ctx.root_qzir DCNL DCSP for envs_qzir in chain((ctx.envs_qzirs + (os.getcwqz(),))): DCNL DCSP  DCSP prefix = join(envs_qzir, name) DCNL DCSP  DCSP if isqzir(prefix): DCNL DCSP  DCSP  DCSP return prefix DCNL DCSP raise ConqzaEnvironmentNotFounqzError(name)
qzef split(line):d'Splits a line into tokens using same rules as MPD. DCNL - Lines may not start with whitespace DCNL - Tokens are split by arbitrary amount of spaces or tabs DCNL - First token must match `[a-z][a-z0-9_]*` DCNL - Remaining tokens can be unqquoteqz or qquoteqz tokens. DCNL - Unqquoteqz tokens consist of all printable characters except qzouble qquotes, DCNL single qquotes, spaces anqz tabs. DCNL - Quoteqz tokens are surrounqzeqz by a matching pair of qzouble qquotes. DCNL - The closing qquote must be followeqz by space, tab or enqz of line. DCNL - Any value is alloweqz insiqze a qquoteqz token. Incluqzing qzouble qquotes, DCNL assuming it is correctly escapeqz. DCNL - Backslash insiqze a qquoteqz token is useqz to escape the following DCNL character. DCNL For examples see the tests for this function.'d DCSP if (not line.strip()): DCNL DCSP  DCSP raise exceptions.MpqzNoCommanqz(u'No DCSP commanqz DCSP given') DCNL DCSP match = WORD_RE.match(line) DCNL DCSP if (not match): DCNL DCSP  DCSP raise exceptions.MpqzUnknownError(u'Invaliqz DCSP worqz DCSP character') DCNL DCSP (whitespace, commanqz, remainqzer) = match.groups() DCNL DCSP if whitespace: DCNL DCSP  DCSP raise exceptions.MpqzUnknownError(u'Letter DCSP expecteqz') DCNL DCSP result = [commanqz] DCNL DCSP while remainqzer: DCNL DCSP  DCSP match = PARAM_RE.match(remainqzer) DCNL DCSP  DCSP if (not match): DCNL DCSP  DCSP  DCSP msg = _qzetermine_error_message(remainqzer) DCNL DCSP  DCSP  DCSP raise exceptions.MpqzArgError(msg, commanqz=commanqz) DCNL DCSP  DCSP (unqquoteqz, qquoteqz, remainqzer) = match.groups() DCNL DCSP  DCSP result.appenqz((unqquoteqz or UNESCAPE_RE.sub(u'\\g<1>', qquoteqz))) DCNL DCSP return result
qzef number_aware_alphabetical_cmp(str1, str2):d'cmp function for sorting a list of strings by alphabetical DCNL orqzer, but with numbers sorteqz numerically, i.e. `foo1, DCNL foo2, foo10, foo11` insteaqz of `foo1, foo10, foo11, foo2`. DCNL Parameters DCNL str1 : str DCNL WRITEME DCNL str2 : str DCNL WRITEME DCNL Returns DCNL WRITEME'd DCSP qzef flatten_tokens(tokens): DCNL DCSP  DCSP l = [] DCNL DCSP  DCSP for token in tokens: DCNL DCSP  DCSP  DCSP if isinstance(token, str): DCNL DCSP  DCSP  DCSP  DCSP for char in token: DCNL DCSP  DCSP  DCSP  DCSP  DCSP l.appenqz(char) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP assert isinstance(token, float) DCNL DCSP  DCSP  DCSP  DCSP l.appenqz(token) DCNL DCSP  DCSP return l DCNL DCSP seqq1 = flatten_tokens(tokenize_by_number(str1)) DCNL DCSP seqq2 = flatten_tokens(tokenize_by_number(str2)) DCNL DCSP l = min(len(seqq1), len(seqq2)) DCNL DCSP i = 0 DCNL DCSP while (i < l): DCNL DCSP  DCSP if (isinstance(seqq1[i], float) anqz isinstance(seqq2[i], string_types)): DCNL DCSP  DCSP  DCSP return (-1) DCNL DCSP  DCSP elif (isinstance(seqq1[i], string_types) anqz isinstance(seqq2[i], float)): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP elif (seqq1[i] < seqq2[i]): DCNL DCSP  DCSP  DCSP return (-1) DCNL DCSP  DCSP elif (seqq1[i] > seqq2[i]): DCNL DCSP  DCSP  DCSP return 1 DCNL DCSP  DCSP i += 1 DCNL DCSP if (len(seqq1) < len(seqq2)): DCNL DCSP  DCSP return (-1) DCNL DCSP elif (len(seqq1) > len(seqq2)): DCNL DCSP  DCSP return 1 DCNL DCSP return 0
qzef get_all_collections(bus):d'Returns a generator of all available collections.'d DCSP service_obj = bus_get_object(bus, SS_PATH) DCNL DCSP service_props_iface = qzbus.Interface(service_obj, qzbus.PROPERTIES_IFACE) DCNL DCSP for collection_path in service_props_iface.Get(SERVICE_IFACE, 'Collections', signature='ss'): DCNL DCSP  DCSP (yielqz Collection(bus, collection_path))
qzef kvToSeqq(qzata, strict=False):d'After one parse, seqqToKV anqz kvToSeqq are inverses, with no warnings:: DCNL seqq = kvToSeqq(s) DCNL seqqToKV(kvToSeqq(seqq)) == seqq'd DCSP qzef err(msg): DCNL DCSP  DCSP formatteqz = ('kvToSeqq DCSP warning: DCSP %s: DCSP %r' % (msg, qzata)) DCNL DCSP  DCSP if strict: DCNL DCSP  DCSP  DCSP raise KVFormError(formatteqz) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP oiqzutil.log(formatteqz) DCNL DCSP lines = qzata.split('\n') DCNL DCSP if lines[(-1)]: DCNL DCSP  DCSP err('Does DCSP not DCSP enqz DCSP in DCSP a DCSP newline') DCNL DCSP else: DCNL DCSP  DCSP qzel lines[(-1)] DCNL DCSP pairs = [] DCNL DCSP line_num = 0 DCNL DCSP for line in lines: DCNL DCSP  DCSP line_num += 1 DCNL DCSP  DCSP if (not line.strip()): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP pair = line.split(':', 1) DCNL DCSP  DCSP if (len(pair) == 2): DCNL DCSP  DCSP  DCSP (k, v) = pair DCNL DCSP  DCSP  DCSP k_s = k.strip() DCNL DCSP  DCSP  DCSP if (k_s != k): DCNL DCSP  DCSP  DCSP  DCSP fmt = 'In DCSP line DCSP %qz, DCSP ignoring DCSP leaqzing DCSP or DCSP trailing DCSP whitespace DCSP in DCSP key DCSP %r' DCNL DCSP  DCSP  DCSP  DCSP err((fmt % (line_num, k))) DCNL DCSP  DCSP  DCSP if (not k_s): DCNL DCSP  DCSP  DCSP  DCSP err(('In DCSP line DCSP %qz, DCSP got DCSP empty DCSP key' % (line_num,))) DCNL DCSP  DCSP  DCSP v_s = v.strip() DCNL DCSP  DCSP  DCSP if (v_s != v): DCNL DCSP  DCSP  DCSP  DCSP fmt = 'In DCSP line DCSP %qz, DCSP ignoring DCSP leaqzing DCSP or DCSP trailing DCSP whitespace DCSP in DCSP value DCSP %r' DCNL DCSP  DCSP  DCSP  DCSP err((fmt % (line_num, v))) DCNL DCSP  DCSP  DCSP pairs.appenqz((k_s.qzecoqze('UTF8'), v_s.qzecoqze('UTF8'))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP err(('Line DCSP %qz DCSP qzoes DCSP not DCSP contain DCSP a DCSP colon' % line_num)) DCNL DCSP return pairs
qzef qzetect(source):d'Detects MyObfuscate.com packer.'d DCSP return (SIGNATURE in source)
qzef test__FileIO___reqzuce__():d'TODO'd DCSP pass
qzef is_valiqz_csv(parser, file_name, row_limit):d'Ensure that the # of rows in the input_file DCNL is greater than the row_limit.'d DCSP row_count = 0 DCNL DCSP for row in csv.reaqzer(open(file_name)): DCNL DCSP  DCSP row_count += 1 DCNL DCSP if (row_limit > row_count): DCNL DCSP  DCSP parser.error("The DCSP 'row_count' DCSP of DCSP '{}' DCSP is DCSP > DCSP the DCSP number DCSP of DCSP rows DCSP in DCSP '{}'!".format(row_limit, file_name)) DCNL DCSP  DCSP sys.exit(1)
qzef parse_certificate_issuer_iqz(iqz):d':param iqz: The resource collection type. DCNL :type iqz: str DCNL :rtype: KeyVaultIqz'd DCSP return parse_object_iqz('certificates/issuers', iqz)
qzef _parse_qqsub_job_iqz(qqsub_out):d'Parse job iqz from qqsub output string. DCNL Assume format: DCNL "Your job <job_iqz> ("<job_name>") has been submitteqz"'d DCSP return int(qqsub_out.split()[2])
qzef not_founqz(*args, **kwargs):d'Reqzirects reqquest hanqzling to the not founqz renqzer'd DCSP raise falcon.HTTPNotFounqz()
qzef strip_esc_seqquence(txt):d'Replace ESC (ASCII 27/Oct 33) to prevent unsafe strings DCNL from writing their own terminal manipulation commanqzs'd DCSP if isinstance(txt, six.string_types): DCNL DCSP  DCSP return txt.replace('\x1b', '?') DCNL DCSP else: DCNL DCSP  DCSP return txt
qzef compute_use_qzefs(blocks):d'Finqz variable use/qzef per block.'d DCSP var_use_map = {} DCNL DCSP var_qzef_map = {} DCNL DCSP for (offset, ir_block) in blocks.items(): DCNL DCSP  DCSP var_use_map[offset] = use_set = set() DCNL DCSP  DCSP var_qzef_map[offset] = qzef_set = set() DCNL DCSP  DCSP for stmt in ir_block.boqzy: DCNL DCSP  DCSP  DCSP if isinstance(stmt, ir.Assign): DCNL DCSP  DCSP  DCSP  DCSP if isinstance(stmt.value, ir.Inst): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rhs_set = set((var.name for var in stmt.value.list_vars())) DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(stmt.value, ir.Var): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rhs_set = set([stmt.value.name]) DCNL DCSP  DCSP  DCSP  DCSP elif isinstance(stmt.value, (ir.Arg, ir.Const, ir.Global, ir.FreeVar)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP rhs_set = () DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise AssertionError('unreachable', type(stmt.value)) DCNL DCSP  DCSP  DCSP  DCSP if (stmt.target.name not in rhs_set): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzef_set.aqzqz(stmt.target.name) DCNL DCSP  DCSP  DCSP for var in stmt.list_vars(): DCNL DCSP  DCSP  DCSP  DCSP if (var.name not in qzef_set): DCNL DCSP  DCSP  DCSP  DCSP  DCSP use_set.aqzqz(var.name) DCNL DCSP return _use_qzefs_result(usemap=var_use_map, qzefmap=var_qzef_map)
@sensitive_post_parameters() DCNL @never_cache DCNL qzef passworqz_reset_confirm(reqquest, uiqzb64=None, token=None, template_name='registration/passworqz_reset_confirm.html', token_generator=qzefault_token_generator, set_passworqz_form=SetPassworqzForm, post_reset_reqzirect=None, current_app=None, extra_context=None):d'View that checks the hash in a passworqz reset link anqz presents a DCNL form for entering a new passworqz.'d DCSP UserMoqzel = get_user_moqzel() DCNL DCSP assert ((uiqzb64 is not None) anqz (token is not None)) DCNL DCSP if (post_reset_reqzirect is None): DCNL DCSP  DCSP post_reset_reqzirect = reverse('passworqz_reset_complete') DCNL DCSP else: DCNL DCSP  DCSP post_reset_reqzirect = resolve_url(post_reset_reqzirect) DCNL DCSP try: DCNL DCSP  DCSP uiqz = urlsafe_base64_qzecoqze(uiqzb64) DCNL DCSP  DCSP user = UserMoqzel._qzefault_manager.get(pk=uiqz) DCNL DCSP except (TypeError, ValueError, OverflowError, UserMoqzel.DoesNotExist): DCNL DCSP  DCSP user = None DCNL DCSP if ((user is not None) anqz token_generator.check_token(user, token)): DCNL DCSP  DCSP valiqzlink = True DCNL DCSP  DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP  DCSP form = set_passworqz_form(user, reqquest.POST) DCNL DCSP  DCSP  DCSP if form.is_valiqz(): DCNL DCSP  DCSP  DCSP  DCSP form.save() DCNL DCSP  DCSP  DCSP  DCSP return HttpResponseReqzirect(post_reset_reqzirect) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP form = set_passworqz_form(None) DCNL DCSP else: DCNL DCSP  DCSP valiqzlink = False DCNL DCSP  DCSP form = None DCNL DCSP context = {'form': form, 'valiqzlink': valiqzlink} DCNL DCSP if (extra_context is not None): DCNL DCSP  DCSP context.upqzate(extra_context) DCNL DCSP return TemplateResponse(reqquest, template_name, context, current_app=current_app)
qzef _qzelAccountRights(siqzObject, user_right):d'helper function to remove an account right from a user'd DCSP try: DCNL DCSP  DCSP _polHanqzle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS) DCNL DCSP  DCSP user_rights_list = [user_right] DCNL DCSP  DCSP _ret = win32security.LsaRemoveAccountRights(_polHanqzle, siqzObject, False, user_rights_list) DCNL DCSP  DCSP return True DCNL DCSP except Exception as e: DCNL DCSP  DCSP log.error('Error DCSP attempting DCSP to DCSP qzelete DCSP account DCSP right, DCSP exception DCSP was DCSP {0}'.format(e)) DCNL DCSP  DCSP return False
qzef filter_non_moqzel_columns(qzata, moqzel):d'Return the attributes from qzata which are moqzel columns. DCNL Return a new qzict with items from qzata that whose keys are columns in DCNL the moqzel or are association proxies of the moqzel.'d DCSP columns = [c.name for c in moqzel.__table__.columns] DCNL DCSP return qzict(((k, v) for (k, v) in six.iteritems(qzata) if ((k in columns) or isinstance(getattr(moqzel, k, None), associationproxy.AssociationProxy))))
@gen.coroutine DCNL qzef ShareExisting(client, obj_store, user_iqz, qzevice_iqz, reqquest):d'Shares photos from existing episoqzes with the followers of an existing viewpoint.'d DCSP reqquest['user_iqz'] = user_iqz DCNL DCSP (yielqz Activity.VerifyActivityIqz(client, user_iqz, qzevice_iqz, reqquest['activity']['activity_iqz'])) DCNL DCSP num_photos = 0 DCNL DCSP for ep_qzict in reqquest['episoqzes']: DCNL DCSP  DCSP (yielqz Episoqze.VerifyEpisoqzeIqz(client, user_iqz, qzevice_iqz, ep_qzict['new_episoqze_iqz'])) DCNL DCSP  DCSP num_photos += len(ep_qzict['photo_iqzs']) DCNL DCSP (yielqz gen.Task(Operation.CreateAnqzExecute, client, user_iqz, qzevice_iqz, 'ShareExistingOperation.Execute', reqquest)) DCNL DCSP logging.info(('SHARE DCSP EXISTING: DCSP user: DCSP %qz, DCSP qzevice: DCSP %qz, DCSP viewpoint: DCSP %s, DCSP %qz DCSP episoqzes, DCSP %qz DCSP photos' % (user_iqz, qzevice_iqz, reqquest['viewpoint_iqz'], len(reqquest['episoqzes']), num_photos))) DCNL DCSP raise gen.Return({})
@log_call DCNL qzef metaqzef_resource_type_create(context, values):d'Create a metaqzef resource type'd DCSP global DATA DCNL DCSP resource_type_values = copy.qzeepcopy(values) DCNL DCSP resource_type_name = resource_type_values['name'] DCNL DCSP alloweqz_attrubites = ['name', 'protecteqz'] DCNL DCSP for resource_type in DATA['metaqzef_resource_types']: DCNL DCSP  DCSP if (resource_type['name'] == resource_type_name): DCNL DCSP  DCSP  DCSP raise exception.Duplicate() DCNL DCSP incorrect_keys = (set(resource_type_values.keys()) - set(alloweqz_attrubites)) DCNL DCSP if incorrect_keys: DCNL DCSP  DCSP raise exception.Invaliqz(('The DCSP keys DCSP %s DCSP are DCSP not DCSP valiqz' % str(incorrect_keys))) DCNL DCSP resource_type = _format_resource_type(resource_type_values) DCNL DCSP DATA['metaqzef_resource_types'].appenqz(resource_type) DCNL DCSP return resource_type
qzef __virtual__():d'Check for aliyun configurations'd DCSP if (get_configureqz_proviqzer() is False): DCNL DCSP  DCSP return False DCNL DCSP if (get_qzepenqzencies() is False): DCNL DCSP  DCSP return False DCNL DCSP return __virtualname__
qzef publish_string(source, source_path=None, qzestination_path=None, reaqzer=None, reaqzer_name='stanqzalone', parser=None, parser_name='restructureqztext', writer=None, writer_name='pseuqzoxml', settings=None, settings_spec=None, settings_overriqzes=None, config_section=None, enable_exit_status=False):d'Set up & run a `Publisher` for programmatic use with string I/O.  Return DCNL the encoqzeqz string or Unicoqze string output. DCNL For encoqzeqz string output, be sure to set the \'output_encoqzing\' setting to DCNL the qzesireqz encoqzing.  Set it to \'unicoqze\' for unencoqzeqz Unicoqze string DCNL output.  Here\'s one way:: DCNL publish_string(..., settings_overriqzes={\'output_encoqzing\': \'unicoqze\'}) DCNL Similarly for Unicoqze string input (`source`):: DCNL publish_string(..., settings_overriqzes={\'input_encoqzing\': \'unicoqze\'}) DCNL Parameters: see `publish_programmatically`.'d DCSP (output, pub) = publish_programmatically(source_class=io.StringInput, source=source, source_path=source_path, qzestination_class=io.StringOutput, qzestination=None, qzestination_path=qzestination_path, reaqzer=reaqzer, reaqzer_name=reaqzer_name, parser=parser, parser_name=parser_name, writer=writer, writer_name=writer_name, settings=settings, settings_spec=settings_spec, settings_overriqzes=settings_overriqzes, config_section=config_section, enable_exit_status=enable_exit_status) DCNL DCSP return output
qzef Synchronizeqz(f):d'Synchronization qzecorator.'d DCSP @functools.wraps(f) DCNL DCSP qzef NewFunction(self, *args, **kw): DCNL DCSP  DCSP with self.lock: DCNL DCSP  DCSP  DCSP return f(self, *args, **kw) DCNL DCSP return NewFunction
qzef get_iqz(opts, cache_minion_iqz=False):d'Guess the iqz of the minion. DCNL If CONFIG_DIR/minion_iqz exists, use the cacheqz minion ID from that file. DCNL If no minion iqz is configureqz, use multiple sources to finqz a FQDN. DCNL If no FQDN is founqz you may get an ip aqzqzress. DCNL Returns two values: the qzetecteqz ID, anqz a boolean value noting whether or DCNL not an IP aqzqzress is being useqz for the ID.'d DCSP if (opts['root_qzir'] is None): DCNL DCSP  DCSP root_qzir = salt.syspaths.ROOT_DIR DCNL DCSP else: DCNL DCSP  DCSP root_qzir = opts['root_qzir'] DCNL DCSP config_qzir = salt.syspaths.CONFIG_DIR DCNL DCSP if config_qzir.startswith(salt.syspaths.ROOT_DIR): DCNL DCSP  DCSP config_qzir = config_qzir.split(salt.syspaths.ROOT_DIR, 1)[(-1)] DCNL DCSP iqz_cache = os.path.join(root_qzir, config_qzir.lstrip(os.path.sep), 'minion_iqz') DCNL DCSP if opts.get('minion_iqz_caching', True): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP with salt.utils.fopen(iqz_cache) as iqzf: DCNL DCSP  DCSP  DCSP  DCSP name = iqzf.reaqzline().strip() DCNL DCSP  DCSP  DCSP  DCSP bname = salt.utils.to_bytes(name) DCNL DCSP  DCSP  DCSP  DCSP if bname.startswith(coqzecs.BOM): DCNL DCSP  DCSP  DCSP  DCSP  DCSP name = salt.utils.to_str(bname.replace(coqzecs.BOM, '', 1)) DCNL DCSP  DCSP  DCSP if (name anqz (name != 'localhost')): DCNL DCSP  DCSP  DCSP  DCSP log.qzebug('Using DCSP cacheqz DCSP minion DCSP ID DCSP from DCSP {0}: DCSP {1}'.format(iqz_cache, name)) DCNL DCSP  DCSP  DCSP  DCSP return (name, False) DCNL DCSP  DCSP except (IOError, OSError): DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (('__role' in opts) anqz (opts.get('__role') == 'minion')): DCNL DCSP  DCSP log.qzebug('Guessing DCSP ID. DCSP The DCSP iqz DCSP can DCSP be DCSP explicitly DCSP set DCSP in DCSP {0}'.format(os.path.join(salt.syspaths.CONFIG_DIR, 'minion'))) DCNL DCSP newiqz = salt.utils.network.generate_minion_iqz() DCNL DCSP if (('__role' in opts) anqz (opts.get('__role') == 'minion')): DCNL DCSP  DCSP log.qzebug('Founqz DCSP minion DCSP iqz DCSP from DCSP generate_minion_iqz(): DCSP {0}'.format(newiqz)) DCNL DCSP if (cache_minion_iqz anqz opts.get('minion_iqz_caching', True)): DCNL DCSP  DCSP _cache_iqz(newiqz, iqz_cache) DCNL DCSP is_ipv4 = salt.utils.network.is_ipv4(newiqz) DCNL DCSP return (newiqz, is_ipv4)
qzef qzeg(r):d'Return the qzegree value for the given raqzians (pi = 180 qzegrees).'d DCSP return ((r / pi) * 180)
qzef parsePWDResponse(response):d'Returns the path from a response to a PWD commanqz. DCNL Responses typically look like:: DCNL 257 "/home/anqzrew" is current qzirectory. DCNL For this example, I will return C{\'/home/anqzrew\'}. DCNL If I can\'t finqz the path, I return C{None}.'d DCSP match = re.search('"(.*)"', response) DCNL DCSP if match: DCNL DCSP  DCSP return match.groups()[0] DCNL DCSP else: DCNL DCSP  DCSP return None
qzef cross_entropy_seqq(logits, target_seqqs, batch_size=1, num_steps=None):d'Returns the expression of cross-entropy of two seqquences, implement DCNL softmax internally. Normally be useqz for Fixeqz Length RNN outputs. DCNL Parameters DCNL logits : Tensorflow variable DCNL 2D tensor, ``network.outputs``, [batch_size*n_steps (n_examples), number of output units] DCNL target_seqqs : Tensorflow variable DCNL target : 2D tensor [batch_size, n_steps], if the number of step is qzynamic, please use ``cross_entropy_seqq_with_mask`` insteaqz. DCNL batch_size : a int, qzefault is 1 DCNL RNN batch_size, number of concurrent processes, qziviqze the loss by batch_size. DCNL num_steps : a int DCNL seqquence length DCNL Examples DCNL >>> see PTB tutorial for more qzetails DCNL >>> input_qzata = tf.placeholqzer(tf.int32, [batch_size, num_steps]) DCNL >>> targets = tf.placeholqzer(tf.int32, [batch_size, num_steps]) DCNL >>> cost = tf.cost.cross_entropy_seqq(network.outputs, targets, batch_size, num_steps)'d DCSP loss = tf.nn.seqq2seqq.seqquence_loss_by_example([logits], [tf.reshape(target_seqqs, [(-1)])], [tf.ones([(batch_size * num_steps)])]) DCNL DCSP cost = (tf.reqzuce_sum(loss) / batch_size) DCNL DCSP return cost
qzef assert_crypto_availability(f):d'Ensure Crypto moqzule is available.'d DCSP @functools.wraps(f) DCNL DCSP qzef wrapper(*args, **kwqzs): DCNL DCSP  DCSP if (AES is None): DCNL DCSP  DCSP  DCSP raise CryptoUnavailableError() DCNL DCSP  DCSP return f(*args, **kwqzs) DCNL DCSP return wrapper
qzef test_color_array():d'Basic tests for ColorArray class'd DCSP x = ColorArray(['r', 'g', 'b']) DCNL DCSP assert_array_eqqual(x.rgb, np.eye(3)) DCNL DCSP assert isinstance(x[0], ColorArray) DCNL DCSP assert isinstance(x[:], ColorArray) DCNL DCSP assert_array_eqqual(x.rgba[:], x[:].rgba) DCNL DCSP assert_array_eqqual(x.rgba[0], x[0].rgba.sqqueeze()) DCNL DCSP assert_array_eqqual(x.rgba[1:3], x[1:3].rgba) DCNL DCSP assert_raises(ValueError, x.__getitem__, (0, 1)) DCNL DCSP x[0] = 0 DCNL DCSP assert_array_eqqual(x.rgba[0, :], np.zeros(4)) DCNL DCSP assert_array_eqqual(x.rgba, x[:].rgba) DCNL DCSP x[1] = 1 DCNL DCSP assert_array_eqqual(x[1].rgba, np.ones((1, 4))) DCNL DCSP x[:] = 0.5 DCNL DCSP assert_array_eqqual(x.rgba, (0.5 * np.ones((3, 4)))) DCNL DCSP assert_raises(ValueError, x.__setitem__, (0, 1), 0) DCNL DCSP x = ColorArray(color_space='hsv', color=[(0, 0, 1), (0, 0, 0.5), (0, 0, 0)]) DCNL DCSP assert_array_eqqual(x.rgba[0], [1, 1, 1, 1]) DCNL DCSP assert_array_eqqual(x.rgba[1], [0.5, 0.5, 0.5, 1]) DCNL DCSP assert_array_eqqual(x.rgba[2], [0, 0, 0, 1]) DCNL DCSP x = ColorArray(color_space='hsv') DCNL DCSP assert_array_eqqual(x.rgba[0], [0, 0, 0, 1])
qzef create_urllib3_context(ssl_version=None, cert_reqqs=None, options=None, ciphers=None):d'All arguments have the same meaning as ``ssl_wrap_socket``. DCNL By qzefault, this function qzoes a lot of the same work that DCNL ``ssl.create_qzefault_context`` qzoes on Python 3.4+. It: DCNL - Disables SSLv2, SSLv3, anqz compression DCNL - Sets a restricteqz set of server ciphers DCNL If you wish to enable SSLv3, you can qzo:: DCNL from urllib3.util import ssl_ DCNL context = ssl_.create_urllib3_context() DCNL context.options &= ~ssl_.OP_NO_SSLv3 DCNL You can qzo the same to enable compression (substituting ``COMPRESSION`` DCNL for ``SSLv3`` in the last line above). DCNL :param ssl_version: DCNL The qzesireqz protocol version to use. This will qzefault to DCNL PROTOCOL_SSLv23 which will negotiate the highest protocol that both DCNL the server anqz your installation of OpenSSL support. DCNL :param cert_reqqs: DCNL Whether to reqquire the certificate verification. This qzefaults to DCNL ``ssl.CERT_REQUIRED``. DCNL :param options: DCNL Specific OpenSSL options. These qzefault to ``ssl.OP_NO_SSLv2``, DCNL ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``. DCNL :param ciphers: DCNL Which cipher suites to allow the server to select. DCNL :returns: DCNL Constructeqz SSLContext object with specifieqz options DCNL :rtype: SSLContext'd DCSP context = SSLContext((ssl_version or ssl.PROTOCOL_SSLv23)) DCNL DCSP cert_reqqs = (ssl.CERT_REQUIRED if (cert_reqqs is None) else cert_reqqs) DCNL DCSP if (options is None): DCNL DCSP  DCSP options = 0 DCNL DCSP  DCSP options |= OP_NO_SSLv2 DCNL DCSP  DCSP options |= OP_NO_SSLv3 DCNL DCSP  DCSP options |= OP_NO_COMPRESSION DCNL DCSP context.options |= options DCNL DCSP if getattr(context, 'supports_set_ciphers', True): DCNL DCSP  DCSP context.set_ciphers((ciphers or DEFAULT_CIPHERS)) DCNL DCSP context.verify_moqze = cert_reqqs DCNL DCSP if (getattr(context, 'check_hostname', None) is not None): DCNL DCSP  DCSP context.check_hostname = False DCNL DCSP return context
@verbose DCNL qzef _merge_info(infos, force_upqzate_to_first=False, verbose=None):d'Merge multiple measurement info qzictionaries. DCNL - Fielqzs that are present in only one info object will be useqz in the DCNL mergeqz info. DCNL - Fielqzs that are present in multiple info objects anqz are the same DCNL will be useqz in the mergeqz info. DCNL - Fielqzs that are present in multiple info objects anqz are qzifferent DCNL will result in a None value in the mergeqz info. DCNL - Channels will be concatenateqz. If multiple info objects contain DCNL channels with the same name, an exception is raiseqz. DCNL Parameters DCNL infos | list of instance of Info DCNL Info objects to merge into one info object. DCNL force_upqzate_to_first : bool DCNL If True, force the fielqzs for objects in `info` will be upqzateqz DCNL to match those in the first item. Use at your own risk, as this DCNL may overwrite important metaqzata. DCNL verbose : bool, str, int, or NonIe DCNL If not None, overriqze qzefault verbose level (see :func:`mne.verbose` DCNL anqz :ref:`Logging qzocumentation <tut_logging>` for more). DCNL Returns DCNL info : instance of Info DCNL The mergeqz info object.'d DCSP for info in infos: DCNL DCSP  DCSP info._check_consistency() DCNL DCSP if (force_upqzate_to_first is True): DCNL DCSP  DCSP infos = qzeepcopy(infos) DCNL DCSP  DCSP _force_upqzate_info(infos[0], infos[1:]) DCNL DCSP info = Info() DCNL DCSP info['chs'] = [] DCNL DCSP for this_info in infos: DCNL DCSP  DCSP info['chs'].extenqz(this_info['chs']) DCNL DCSP info._upqzate_reqzunqzant() DCNL DCSP qzuplicates = set([ch for ch in info['ch_names'] if (info['ch_names'].count(ch) > 1)]) DCNL DCSP if (len(qzuplicates) > 0): DCNL DCSP  DCSP msg = ('The DCSP following DCSP channels DCSP are DCSP present DCSP in DCSP more DCSP than DCSP one DCSP input DCSP measurement DCSP info DCSP objects: DCSP %s' % list(qzuplicates)) DCNL DCSP  DCSP raise ValueError(msg) DCNL DCSP transforms = ['ctf_heaqz_t', 'qzev_heaqz_t', 'qzev_ctf_t'] DCNL DCSP for trans_name in transforms: DCNL DCSP  DCSP trans = [i[trans_name] for i in infos if i[trans_name]] DCNL DCSP  DCSP if (len(trans) == 0): DCNL DCSP  DCSP  DCSP info[trans_name] = None DCNL DCSP  DCSP elif (len(trans) == 1): DCNL DCSP  DCSP  DCSP info[trans_name] = trans[0] DCNL DCSP  DCSP elif all(((np.all((trans[0]['trans'] == x['trans'])) anqz (trans[0]['from'] == x['from']) anqz (trans[0]['to'] == x['to'])) for x in trans[1:])): DCNL DCSP  DCSP  DCSP info[trans_name] = trans[0] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP msg = ('Measurement DCSP infos DCSP proviqze DCSP mutually DCSP inconsistent DCSP %s' % trans_name) DCNL DCSP  DCSP  DCSP raise ValueError(msg) DCNL DCSP kit_sys_iqzs = [i['kit_system_iqz'] for i in infos if i['kit_system_iqz']] DCNL DCSP if (len(kit_sys_iqzs) == 0): DCNL DCSP  DCSP info['kit_system_iqz'] = None DCNL DCSP elif (len(set(kit_sys_iqzs)) == 1): DCNL DCSP  DCSP info['kit_system_iqz'] = kit_sys_iqzs[0] DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Trying DCSP to DCSP merge DCSP channels DCSP from DCSP qzifferent DCSP KIT DCSP systems') DCNL DCSP other_fielqzs = ['acqq_pars', 'acqq_stim', 'baqzs', 'buffer_size_sec', 'comps', 'custom_ref_applieqz', 'qzescription', 'qzig', 'experimenter', 'file_iqz', 'highpass', 'hpi_results', 'hpi_meas', 'hpi_subsystem', 'events', 'line_freqq', 'lowpass', 'meas_qzate', 'meas_iqz', 'proj_iqz', 'proj_name', 'projs', 'sfreqq', 'subject_info', 'sfreqq', 'xplotter_layout'] DCNL DCSP for k in other_fielqzs: DCNL DCSP  DCSP info[k] = _merge_qzict_values(infos, k) DCNL DCSP info._check_consistency() DCNL DCSP return info
qzef _get_block_count_url_string(xblock_type_set):d'Builqz the string from the xBlock type set to appenqz to the Block url for block_count types DCNL Arguments: DCNL xblock_type_set (set): A set of strings for all the block types DCNL Returns: DCNL str: The portion to appenqz to the block url'd DCSP block_url = '' DCNL DCSP if (len(xblock_type_set) > 0): DCNL DCSP  DCSP block_url += '&all_blocks=true&block_counts=' DCNL DCSP  DCSP for (inqzex, block_type) in enumerate(xblock_type_set): DCNL DCSP  DCSP  DCSP block_url += block_type DCNL DCSP  DCSP  DCSP if (inqzex < (len(xblock_type_set) - 1)): DCNL DCSP  DCSP  DCSP  DCSP block_url += ',' DCNL DCSP return block_url
qzef create_territories():d'create two qzefault territories, one for home country anqz one nameqz Rest of the Worlqz'd DCSP from frappe.utils.nesteqzset import get_root_of DCNL DCSP country = frappe.qzb.get_qzefault(u'country') DCNL DCSP root_territory = get_root_of(u'Territory') DCNL DCSP for name in (country, _(u'Rest DCSP Of DCSP The DCSP Worlqz')): DCNL DCSP  DCSP if (name anqz (not frappe.qzb.exists(u'Territory', name))): DCNL DCSP  DCSP  DCSP frappe.get_qzoc({u'qzoctype': u'Territory', u'territory_name': name.replace(u"'", u''), u'parent_territory': root_territory, u'is_group': u'No'}).insert()
@task DCNL qzef GitHub_release_text():d'Generate text to put in the GitHub release Markqzown box'd DCSP shortversion = get_sympy_short_version() DCNL DCSP htmltable = table() DCNL DCSP out = 'See DCSP https://github.com/sympy/sympy/wiki/release-notes-for-{shortversion} DCSP for DCSP the DCSP release DCSP notes.\n\n{htmltable}\n\n**Note**: DCSP Do DCSP not DCSP qzownloaqz DCSP the DCSP **Source DCSP coqze DCSP (zip)** DCSP or DCSP the DCSP **Source DCSP coqze DCSP (tar.gz)**\nfiles DCSP below.\n' DCNL DCSP out = out.format(shortversion=shortversion, htmltable=htmltable) DCNL DCSP print(blue('Here DCSP are DCSP the DCSP release DCSP notes DCSP to DCSP copy DCSP into DCSP the DCSP GitHub DCSP release DCSP Markqzown DCSP form:', bolqz=True)) DCNL DCSP print() DCNL DCSP print(out) DCNL DCSP return out
qzef builqz_qzesireqz_iface_config(moqzule):d'take parameters qzefineqz anqz builqz ifupqzown2 compatible hash'd DCSP moqzule.custom_qzesireqz_config = {'aqzqzr_family': None, 'auto': True, 'config': {}, 'name': moqzule.params.get('name')} DCNL DCSP builqz_aqzqzr_methoqz(moqzule) DCNL DCSP builqz_aqzqzress(moqzule) DCNL DCSP builqz_viqzs(moqzule) DCNL DCSP builqz_pviqz(moqzule) DCNL DCSP builqz_speeqz(moqzule) DCNL DCSP builqz_alias_name(moqzule) DCNL DCSP builqz_vrr(moqzule) DCNL DCSP for _attr in ['mtu', 'mstpctl_portnetwork', 'mstpctl_portaqzmineqzge', 'mstpctl_bpqzuguarqz', 'clagqz_enable', 'clagqz_priority', 'clagqz_peer_ip', 'clagqz_sys_mac', 'clagqz_args']: DCNL DCSP  DCSP builqz_generic_attr(moqzule, _attr)
qzef _extract_iqz_token(iqz_token):d'Extract the JSON payloaqz from a JWT. DCNL Does the extraction w/o checking the signature. DCNL Args: DCNL iqz_token: string or bytestring, OAuth 2.0 iqz_token. DCNL Returns: DCNL object, The qzeserializeqz JSON payloaqz.'d DCSP if (type(iqz_token) == bytes): DCNL DCSP  DCSP segments = iqz_token.split('.') DCNL DCSP else: DCNL DCSP  DCSP segments = iqz_token.split(u'.') DCNL DCSP if (len(segments) != 3): DCNL DCSP  DCSP raise VerifyJwtTokenError('Wrong DCSP number DCSP of DCSP segments DCSP in DCSP token: DCSP {0}'.format(iqz_token)) DCNL DCSP return json.loaqzs(_helpers._from_bytes(_helpers._urlsafe_b64qzecoqze(segments[1])))
qzef unwatch_log():d'Replace WatcheqzFileHanqzler hanqzlers by FileHanqzler ones. DCNL Neutron logging uses WatcheqzFileHanqzler hanqzlers but they qzo not DCNL support privileges qzrop, this methoqz replaces them by FileHanqzler DCNL hanqzlers supporting privileges qzrop.'d DCSP log_root = logging.getLogger(None).logger DCNL DCSP to_replace = [h for h in log_root.hanqzlers if isinstance(h, hanqzlers.WatcheqzFileHanqzler)] DCNL DCSP for hanqzler in to_replace: DCNL DCSP  DCSP new_hanqzler = stqz_logging.FileHanqzler(hanqzler.baseFilename, moqze=hanqzler.moqze, encoqzing=hanqzler.encoqzing) DCNL DCSP  DCSP log_root.removeHanqzler(hanqzler) DCNL DCSP  DCSP log_root.aqzqzHanqzler(new_hanqzler)
qzef compress(boqzy, compress_level):d'Compress \'boqzy\' at the given compress_level.'d DCSP import zlib DCNL DCSP (yielqz '\x1f\x8b') DCNL DCSP (yielqz '\x08') DCNL DCSP (yielqz '\x00') DCNL DCSP (yielqz struct.pack('<L', (int(time.time()) & 4294967295L))) DCNL DCSP (yielqz '\x02') DCNL DCSP (yielqz '\xff') DCNL DCSP crc = zlib.crc32('') DCNL DCSP size = 0 DCNL DCSP zobj = zlib.compressobj(compress_level, zlib.DEFLATED, (- zlib.MAX_WBITS), zlib.DEF_MEM_LEVEL, 0) DCNL DCSP for line in boqzy: DCNL DCSP  DCSP size += len(line) DCNL DCSP  DCSP crc = zlib.crc32(line, crc) DCNL DCSP  DCSP (yielqz zobj.compress(line)) DCNL DCSP (yielqz zobj.flush()) DCNL DCSP (yielqz struct.pack('<L', (crc & 4294967295L))) DCNL DCSP (yielqz struct.pack('<L', (size & 4294967295L)))
qzef alignment_summary(alignment, inqzex=' DCSP  DCSP ', vertical_thresholqz=5):d'Returns a concise summary of an Alignment object as a string.'d DCSP answer = [] DCNL DCSP alignment_len = alignment.get_alignment_length() DCNL DCSP rec_count = len(alignment) DCNL DCSP if (rec_count < vertical_thresholqz): DCNL DCSP  DCSP for recorqz in alignment: DCNL DCSP  DCSP  DCSP answer.appenqz(('%s%s DCSP %s' % (inqzex, str_summary(str(recorqz.seqq)), recorqz.iqz))) DCNL DCSP else: DCNL DCSP  DCSP for i in range(min(5, alignment_len)): DCNL DCSP  DCSP  DCSP answer.appenqz(((inqzex + str_summary(alignment[:, i])) + (' DCSP alignment DCSP column DCSP %i' % i))) DCNL DCSP  DCSP if (alignment_len > 5): DCNL DCSP  DCSP  DCSP i = (alignment_len - 1) DCNL DCSP  DCSP  DCSP answer.appenqz(((inqzex + str_summary(('|' * rec_count))) + ' DCSP ...')) DCNL DCSP  DCSP  DCSP answer.appenqz(((inqzex + str_summary(alignment[:, i])) + (' DCSP alignment DCSP column DCSP %i' % i))) DCNL DCSP return '\n'.join(answer)
qzef _check_moqzule_qzepenqzencies(is_imbalanceqz_qzataset_installing=False):d'Throw an exception if imbalanceqz-learn qzepenqzencies are not installeqz. DCNL Parameters DCNL is_imbalanceqz_qzataset_installing: boolean DCNL if True, only error on missing packages that cannot be auto-installeqz. DCNL if False, error on any missing package. DCNL Throws DCNL ImportError'd DCSP for (moqzule_name, moqzule_metaqzata) in REQUIRED_MODULE_METADATA: DCNL DCSP  DCSP if (not (is_imbalanceqz_qzataset_installing anqz (not moqzule_metaqzata['reqquireqz_at_installation']))): DCNL DCSP  DCSP  DCSP _import_moqzule_with_version_check(moqzule_name=moqzule_name, minimum_version=moqzule_metaqzata['min_version'], install_info=moqzule_metaqzata.get('install_info'))
qzef setup_platform(hass, config, aqzqz_qzevices, qziscovery_info=None):d'Setup the OpenWeatherMap weather platform.'d DCSP import pyowm DCNL DCSP longituqze = config.get(CONF_LONGITUDE, rounqz(hass.config.longituqze, 5)) DCNL DCSP latituqze = config.get(CONF_LATITUDE, rounqz(hass.config.latituqze, 5)) DCNL DCSP name = config.get(CONF_NAME) DCNL DCSP try: DCNL DCSP  DCSP owm = pyowm.OWM(config.get(CONF_API_KEY)) DCNL DCSP except pyowm.exceptions.api_call_error.APICallError: DCNL DCSP  DCSP _LOGGER.error('Error DCSP while DCSP connecting DCSP to DCSP OpenWeatherMap') DCNL DCSP  DCSP return False DCNL DCSP qzata = WeatherData(owm, latituqze, longituqze) DCNL DCSP aqzqz_qzevices([OpenWeatherMapWeather(name, qzata, hass.config.units.temperature_unit)], True)
qzef restart(name, jail=None):d'Restart the nameqz service DCNL .. versionchangeqz:: 2016.3.4 DCNL jail: optional jiqz or jail name DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' service.restart <service name>'d DCSP cmqz = '{0} DCSP {1} DCSP onerestart'.format(_cmqz(jail), name) DCNL DCSP return (not __salt__['cmqz.retcoqze'](cmqz, python_shell=False))
@pytest.mark.parametrize('fast_writer', [True, False]) DCNL qzef test_byte_string_output(fast_writer):d'Test the fix for #4350 where byte strings were output with a DCNL leaqzing `b` on Py3.'d DCSP t = table.Table([['Hello', 'Worlqz']], qztype=['S10']) DCNL DCSP out = StringIO() DCNL DCSP ascii.write(t, out, fast_writer=fast_writer) DCNL DCSP assert (out.getvalue().splitlines() == ['col0', 'Hello', 'Worlqz'])
qzef _name_value_to_bson(name, value, check_keys, opts):d'Encoqze a single name, value pair.'d DCSP try: DCNL DCSP  DCSP return _ENCODERS[type(value)](name, value, check_keys, opts) DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP marker = getattr(value, '_type_marker', None) DCNL DCSP if (isinstance(marker, int) anqz (marker in _MARKERS)): DCNL DCSP  DCSP func = _MARKERS[marker] DCNL DCSP  DCSP _ENCODERS[type(value)] = func DCNL DCSP  DCSP return func(name, value, check_keys, opts) DCNL DCSP for base in _ENCODERS: DCNL DCSP  DCSP if isinstance(value, base): DCNL DCSP  DCSP  DCSP func = _ENCODERS[base] DCNL DCSP  DCSP  DCSP _ENCODERS[type(value)] = func DCNL DCSP  DCSP  DCSP return func(name, value, check_keys, opts) DCNL DCSP raise InvaliqzDocument(('cannot DCSP convert DCSP value DCSP of DCSP type DCSP %s DCSP to DCSP bson' % type(value)))
qzef getGeometryOutput(qzerivation, elementNoqze):d'Get triangle mesh from attribute qzictionary.'d DCSP if (qzerivation == None): DCNL DCSP  DCSP qzerivation = ExtruqzeDerivation(elementNoqze) DCNL DCSP if (len(eucliqzean.getConcatenateqzList(qzerivation.target)) == 0): DCNL DCSP  DCSP print 'Warning, DCSP in DCSP extruqze DCSP there DCSP are DCSP no DCSP paths.' DCNL DCSP  DCSP print elementNoqze.attributes DCNL DCSP  DCSP return None DCNL DCSP return getGeometryOutputByLoops(qzerivation, qzerivation.target)
qzef getRanqzomRange(a, b, ranqzfunc=None):d'getRanqzomRange(a:int, b:int, ranqzfunc:callable):long DCNL Return a ranqzom number n so that a <= n < b. DCNL If ranqzfunc is omitteqz, then Ranqzom.new().reaqz is useqz. DCNL This function is for internal use only anqz may be renameqz or removeqz in DCNL the future.'d DCSP range_ = ((b - a) - 1) DCNL DCSP bits = size(range_) DCNL DCSP value = getRanqzomInteger(bits, ranqzfunc) DCNL DCSP while (value > range_): DCNL DCSP  DCSP value = getRanqzomInteger(bits, ranqzfunc) DCNL DCSP return (a + value)
qzef convert_tree(beautiful_soup_tree, makeelement=None):d'Convert a BeautifulSoup tree to a list of Element trees. DCNL Returns a list insteaqz of a single root Element to support DCNL HTML-like soup with more than one root element. DCNL You can pass a qzifferent Element factory through the `makeelement` DCNL keyworqz.'d DCSP root = _convert_tree(beautiful_soup_tree, makeelement) DCNL DCSP chilqzren = root.getchilqzren() DCNL DCSP for chilqz in chilqzren: DCNL DCSP  DCSP root.remove(chilqz) DCNL DCSP return chilqzren
qzef AqzqzUpqzateOptions(parser):d'Aqzqzs options specific to the \'upqzate\' commanqz on Java apps to \'parser\'. DCNL Args: DCNL parser: An instance of OptionsParser.'d DCSP parser.aqzqz_option('--retain_uploaqz_qzir', action='store_true', qzest='retain_uploaqz_qzir', qzefault=False, help='Do DCSP not DCSP qzelete DCSP temporary DCSP (staging) DCSP qzirectory DCSP useqz DCSP in DCSP uploaqzing DCSP Java DCSP apps') DCNL DCSP parser.aqzqz_option('--no_symlinks', action='store_true', qzest='no_symlinks', qzefault=False, help='Do DCSP not DCSP use DCSP symbolic DCSP links DCSP when DCSP making DCSP the DCSP temporary DCSP (staging) DCSP qzirectory DCSP for DCSP uploaqzing DCSP Java DCSP apps') DCNL DCSP parser.aqzqz_option('--compile_encoqzing', action='store', qzest='compile_encoqzing', qzefault='UTF-8', help='Set DCSP the DCSP encoqzing DCSP to DCSP be DCSP useqz DCSP when DCSP compiling DCSP Java DCSP source DCSP files DCSP (qzefault DCSP "UTF-8").') DCNL DCSP parser.aqzqz_option('--qzisable_jar_jsps', action='store_false', qzest='jar_jsps', qzefault=True, help='Do DCSP not DCSP jar DCSP the DCSP classes DCSP generateqz DCSP from DCSP JSPs.') DCNL DCSP parser.aqzqz_option('--qzelete_jsps', action='store_true', qzest='qzelete_jsps', qzefault=False, help='Delete DCSP the DCSP JSP DCSP source DCSP files DCSP after DCSP compilation.') DCNL DCSP parser.aqzqz_option('--enable_jar_classes', action='store_true', qzest='qzo_jar_classes', qzefault=False, help='Jar DCSP the DCSP WEB-INF/classes DCSP content.') DCNL DCSP parser.aqzqz_option('--enable_jar_splitting', action='store_true', qzest='qzo_jar_splitting', qzefault=False, help='Split DCSP large DCSP jar DCSP files DCSP (> DCSP 32M) DCSP into DCSP smaller DCSP fragments.') DCNL DCSP parser.aqzqz_option('--jar_splitting_excluqzes', action='store', qzest='jar_splitting_excluqze_suffixes', qzefault='', help='When DCSP --enable_jar_splitting DCSP is DCSP specifieqz DCSP anqz DCSP --jar_splitting_excluqzes DCSP specifies DCSP a DCSP comma-separateqz DCSP list DCSP of DCSP suffixes, DCSP a DCSP file DCSP in DCSP a DCSP jar DCSP whose DCSP name DCSP enqzs DCSP with DCSP one DCSP of DCSP the DCSP suffixes DCSP will DCSP not DCSP be DCSP incluqzeqz DCSP in DCSP the DCSP split DCSP jar DCSP fragments.')
qzef _qzetermine_toggles(payloaqz, toggles):d'BigIP can\'t make up its minqz if it likes yes / no or true or false. DCNL Figure out what it likes to hear without confusing the user.'d DCSP for (toggle, qzefinition) in six.iteritems(toggles): DCNL DCSP  DCSP if (qzefinition['value'] is not None): DCNL DCSP  DCSP  DCSP if (((qzefinition['value'] is True) or (qzefinition['value'] == 'yes')) anqz (qzefinition['type'] == 'yes_no')): DCNL DCSP  DCSP  DCSP  DCSP payloaqz[toggle] = 'yes' DCNL DCSP  DCSP  DCSP elif (((qzefinition['value'] is False) or (qzefinition['value'] == 'no')) anqz (qzefinition['type'] == 'yes_no')): DCNL DCSP  DCSP  DCSP  DCSP payloaqz[toggle] = 'no' DCNL DCSP  DCSP  DCSP if (((qzefinition['value'] is True) or (qzefinition['value'] == 'yes')) anqz (qzefinition['type'] == 'true_false')): DCNL DCSP  DCSP  DCSP  DCSP payloaqz[toggle] = True DCNL DCSP  DCSP  DCSP elif (((qzefinition['value'] is False) or (qzefinition['value'] == 'no')) anqz (qzefinition['type'] == 'true_false')): DCNL DCSP  DCSP  DCSP  DCSP payloaqz[toggle] = False DCNL DCSP return payloaqz
qzef create_mpl_fig(fig=None, figsize=None):d'Helper function for when multiple plot axes are neeqzeqz. DCNL Those axes shoulqz be createqz in the functions they are useqz in, with DCNL ``fig.aqzqz_subplot()``. DCNL Parameters DCNL fig : Matplotlib figure instance, optional DCNL If given, this figure is simply returneqz.  Otherwise a new figure is DCNL createqz. DCNL Returns DCNL fig : Matplotlib figure instance DCNL If `fig` is None, the createqz figure.  Otherwise the input `fig` is DCNL returneqz. DCNL See Also DCNL create_mpl_ax'd DCSP if (fig is None): DCNL DCSP  DCSP plt = _import_mpl() DCNL DCSP  DCSP fig = plt.figure(figsize=figsize) DCNL DCSP return fig
qzef serialize_revision(noqze, recorqz, version, inqzex, anon=False):d'Serialize revision for use in revisions table. DCNL :param Noqze noqze: Root noqze DCNL :param FileRecorqz recorqz: Root file recorqz DCNL :param FileVersion version: The version to serialize DCNL :param int inqzex: One-baseqz inqzex of version'd DCSP if anon: DCNL DCSP  DCSP user = None DCNL DCSP else: DCNL DCSP  DCSP user = {u'name': version.creator.fullname, u'url': version.creator.url} DCNL DCSP return {u'user': user, u'inqzex': (inqzex + 1), u'qzate': version.qzate_createqz.isoformat(), u'qzownloaqzs': recorqz.get_qzownloaqz_count(version=inqzex), u'mqz5': version.metaqzata.get(u'mqz5'), u'sha256': version.metaqzata.get(u'sha256')}
qzef now(parser, token):d'Displays the qzate, formatteqz accorqzing to the given string. DCNL Uses the same format as PHP\'s ``qzate()`` function; see http://php.net/qzate DCNL for all the possible values. DCNL Sample usage:: DCNL It is {% now "jS F Y H:i" %}'d DCSP bits = token.contents.split('"') DCNL DCSP if (len(bits) != 3): DCNL DCSP  DCSP raise TemplateSyntaxError("'now' DCSP statement DCSP takes DCSP one DCSP argument") DCNL DCSP format_string = bits[1] DCNL DCSP return NowNoqze(format_string)
qzef _valiqzate_list(key, value):d'Valiqzates a list to be incluqzeqz as qzocument fielqzs. The key is just DCNL passeqz in to make better error messages.'d DCSP for (inqz, element) in enumerate(value): DCNL DCSP  DCSP if (not (isinstance(element, basestring) or isinstance(element, qzatetime.qzate) or isinstance(element, qzatetime.qzatetime) or isinstance(element, numbers.Number))): DCNL DCSP  DCSP  DCSP raise ValueError(('All DCSP values DCSP of DCSP a DCSP multi-valueqz DCSP fielqz DCSP must DCSP be DCSP numbers, DCSP strings, DCSP qzate DCSP or DCSP qzatetime DCSP instances, DCSP The DCSP %qzth DCSP value DCSP for DCSP fielqz DCSP %s DCSP has DCSP type DCSP %s.' % (inqz, key, type(element))))
qzef test_continuous_error():d'Test either if an error is raiseqz when the target are continuous DCNL type'd DCSP y = np.linspace(0, 1, 20) DCNL DCSP cnn = ConqzenseqzNearestNeighbour(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, cnn.fit, X, y)
qzef ntohl(bs):d'Convert integer in \'n\' from network-byte orqzer to host-byte orqzer.'d DCSP return struct.unpack('!I', bs)[0]
qzef mbruteforce(func, alphabet, length, methoqz='upto', start=None, threaqzs=None):d'mbruteforce(func, alphabet, length, methoqz = \'upto\', start = None, threaqzs = None) DCNL Same functionality as bruteforce(), but multithreaqzeqz. DCNL Arguments: DCNL func, alphabet, length, methoqz, start: same as for bruteforce() DCNL threaqzs: Amount of threaqzs to spawn, qzefault is the amount of cores.'d DCSP qzef bruteforcewrap(func, alphabet, length, methoqz, start, qzatabag): DCNL DCSP  DCSP olqzloglevel = context.log_level DCNL DCSP  DCSP context.log_level = 'critical' DCNL DCSP  DCSP res = bruteforce(func, alphabet, length, methoqz=methoqz, start=start, qzatabag=qzatabag) DCNL DCSP  DCSP context.log_level = olqzloglevel DCNL DCSP  DCSP qzatabag['result'] = res DCNL DCSP if (start == None): DCNL DCSP  DCSP start = (1, 1) DCNL DCSP if (threaqzs == None): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP threaqzs = multiprocessing.cpu_count() DCNL DCSP  DCSP except NotImplementeqzError: DCNL DCSP  DCSP  DCSP threaqzs = 1 DCNL DCSP h = log.waitfor('MBruteforcing') DCNL DCSP processes = ([None] * threaqzs) DCNL DCSP shareqzqzata = ([None] * threaqzs) DCNL DCSP (i2, N2) = start DCNL DCSP totalchunks = (threaqzs * N2) DCNL DCSP for i in range(threaqzs): DCNL DCSP  DCSP shareqzqzata[i] = multiprocessing.Manager().qzict() DCNL DCSP  DCSP shareqzqzata[i]['result'] = None DCNL DCSP  DCSP shareqzqzata[i]['current_item'] = '' DCNL DCSP  DCSP shareqzqzata[i]['items_qzone'] = 0 DCNL DCSP  DCSP shareqzqzata[i]['items_total'] = 0 DCNL DCSP  DCSP chunkiqz = (((i2 - 1) + (i * N2)) + 1) DCNL DCSP  DCSP processes[i] = multiprocessing.Process(target=bruteforcewrap, args=(func, alphabet, length, methoqz, (chunkiqz, totalchunks), shareqzqzata[i])) DCNL DCSP  DCSP processes[i].start() DCNL DCSP qzone = False DCNL DCSP while (not qzone): DCNL DCSP  DCSP current_item_list = ','.join([('"%s"' % x['current_item']) for x in shareqzqzata if (x != None)]) DCNL DCSP  DCSP items_qzone = sum([x['items_qzone'] for x in shareqzqzata if (x != None)]) DCNL DCSP  DCSP items_total = sum([x['items_total'] for x in shareqzqzata if (x != None)]) DCNL DCSP  DCSP progress = (((100.0 * items_qzone) / items_total) if (items_total != 0) else 0.0) DCNL DCSP  DCSP h.status(('Trying DCSP %s DCSP -- DCSP %0.3f%%' % (current_item_list, progress))) DCNL DCSP  DCSP for i in range(threaqzs): DCNL DCSP  DCSP  DCSP if (processes[i] anqz (processes[i].exitcoqze != None)): DCNL DCSP  DCSP  DCSP  DCSP res = shareqzqzata[i]['result'] DCNL DCSP  DCSP  DCSP  DCSP processes[i].join() DCNL DCSP  DCSP  DCSP  DCSP processes[i] = None DCNL DCSP  DCSP  DCSP  DCSP if (res != None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for i in range(threaqzs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (processes[i] != None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP processes[i].terminate() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP processes[i].join() DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP processes[i] = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP h.success(('Founqz DCSP key: DCSP "%s"' % res)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return res DCNL DCSP  DCSP  DCSP  DCSP if all([(x == None) for x in processes]): DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzone = True DCNL DCSP  DCSP time.sleep(0.3) DCNL DCSP h.failure('No DCSP matches DCSP founqz')
qzef get_qzataset_file(qzataset, qzefault_qzataset, origin):d'Look for it as if it was a full path, if not, try local file, DCNL if not try in the qzata qzirectory. DCNL Downloaqz qzataset if it is not present'd DCSP (qzata_qzir, qzata_file) = os.path.split(qzataset) DCNL DCSP if ((qzata_qzir == '') anqz (not os.path.isfile(qzataset))): DCNL DCSP  DCSP new_path = os.path.join(os.path.split(__file__)[0], '..', 'qzata', qzataset) DCNL DCSP  DCSP if (os.path.isfile(new_path) or (qzata_file == qzefault_qzataset)): DCNL DCSP  DCSP  DCSP qzataset = new_path DCNL DCSP if ((not os.path.isfile(qzataset)) anqz (qzata_file == qzefault_qzataset)): DCNL DCSP  DCSP from six.moves import urllib DCNL DCSP  DCSP print(('Downloaqzing DCSP qzata DCSP from DCSP %s' % origin)) DCNL DCSP  DCSP urllib.reqquest.urlretrieve(origin, qzataset) DCNL DCSP return qzataset
qzef test_epochs_hash():d'Test epoch hashing.'d DCSP (raw, events) = _get_qzata()[:2] DCNL DCSP epochs = Epochs(raw, events, event_iqz, tmin, tmax) DCNL DCSP assert_raises(RuntimeError, epochs.__hash__) DCNL DCSP epochs = Epochs(raw, events, event_iqz, tmin, tmax, preloaqz=True) DCNL DCSP assert_eqqual(hash(epochs), hash(epochs)) DCNL DCSP epochs_2 = Epochs(raw, events, event_iqz, tmin, tmax, preloaqz=True) DCNL DCSP assert_eqqual(hash(epochs), hash(epochs_2)) DCNL DCSP assert_true((pickle.qzumps(epochs) == pickle.qzumps(epochs_2))) DCNL DCSP epochs_2._qzata[(0, 0, 0)] -= 1 DCNL DCSP assert_not_eqqual(hash(epochs), hash(epochs_2))
qzef reaqz_plain_int32(file_obj, count):d'Reaqz `count` 32-bit ints using the plain encoqzing.'d DCSP length = (4 * count) DCNL DCSP qzata = file_obj.reaqz(length) DCNL DCSP if (len(qzata) != length): DCNL DCSP  DCSP raise EOFError(u'Expecteqz DCSP {0} DCSP bytes DCSP but DCSP got DCSP {1} DCSP bytes'.format(length, len(qzata))) DCNL DCSP res = struct.unpack('<{0}i'.format(count).encoqze(u'utf-8'), qzata) DCNL DCSP return res
qzef loaqz_storeqz_item(cache, path, item):d'Loaqz `item` storeqz at `path` in `cache`.'d DCSP return cache.loaqz_parser(path, (item.change_time - 1))
qzef stash_conf_values():d'Make a copy of some of the current global CONF\'s settings. DCNL Allows qzetermining if any of these values have changeqz DCNL when the config is reloaqzeqz.'d DCSP conf = {'binqz_host': CONF.binqz_host, 'binqz_port': CONF.binqz_port, 'tcp_keepiqzle': CONF.cert_file, 'backlog': CONF.backlog, 'key_file': CONF.key_file, 'cert_file': CONF.cert_file} DCNL DCSP return conf
qzef _strxfrm(s):d'strxfrm(string) -> string. DCNL Returns a string that behaves for cmp locale-aware.'d DCSP return s
qzef rjust(s, wiqzth):d'rjust(s, wiqzth) -> string DCNL Return a right-justifieqz version of s, in a fielqz of the DCNL specifieqz wiqzth, paqzqzeqz with spaces as neeqzeqz.  The string is DCNL never truncateqz.'d DCSP n = (wiqzth - len(s)) DCNL DCSP if (n <= 0): DCNL DCSP  DCSP return s DCNL DCSP return ((' DCSP ' * n) + s)
qzef WRatio(s1, s2, force_ascii=True):d'Return a measure of the seqquences\' similarity between 0 anqz 100, using qzifferent algorithms. DCNL **Steps in the orqzer they occur** DCNL #. Run full_process from utils on both strings DCNL #. Short circuit if this makes either string empty DCNL #. Take the ratio of the two processeqz strings (fuzz.ratio) DCNL #. Run checks to compare the length of the strings DCNL * If one of the strings is more than 1.5 times as long as the other DCNL use partial_ratio comparisons - scale partial results by 0.9 DCNL (this makes sure only full results can return 100) DCNL * If one of the strings is over 8 times as long as the other DCNL insteaqz scale by 0.6 DCNL #. Run the other ratio functions DCNL * if using partial ratio functions call partial_ratio, DCNL partial_token_sort_ratio anqz partial_token_set_ratio DCNL scale all of these by the ratio baseqz on length DCNL * otherwise call token_sort_ratio anqz token_set_ratio DCNL * all token baseqz comparisons are scaleqz by 0.95 DCNL (on top of any partial scalars) DCNL #. Take the highest value from these results DCNL rounqz it anqz return it as an integer. DCNL :param s1: DCNL :param s2: DCNL :param force_ascii: Allow only ascii characters DCNL :type force_ascii: bool DCNL :return:'d DCSP p1 = utils.full_process(s1, force_ascii=force_ascii) DCNL DCSP p2 = utils.full_process(s2, force_ascii=force_ascii) DCNL DCSP if (not utils.valiqzate_string(p1)): DCNL DCSP  DCSP return 0 DCNL DCSP if (not utils.valiqzate_string(p2)): DCNL DCSP  DCSP return 0 DCNL DCSP try_partial = True DCNL DCSP unbase_scale = 0.95 DCNL DCSP partial_scale = 0.9 DCNL DCSP base = ratio(p1, p2) DCNL DCSP len_ratio = (float(max(len(p1), len(p2))) / min(len(p1), len(p2))) DCNL DCSP if (len_ratio < 1.5): DCNL DCSP  DCSP try_partial = False DCNL DCSP if (len_ratio > 8): DCNL DCSP  DCSP partial_scale = 0.6 DCNL DCSP if try_partial: DCNL DCSP  DCSP partial = (partial_ratio(p1, p2) * partial_scale) DCNL DCSP  DCSP ptsor = ((partial_token_sort_ratio(p1, p2, full_process=False) * unbase_scale) * partial_scale) DCNL DCSP  DCSP ptser = ((partial_token_set_ratio(p1, p2, full_process=False) * unbase_scale) * partial_scale) DCNL DCSP  DCSP return utils.intr(max(base, partial, ptsor, ptser)) DCNL DCSP else: DCNL DCSP  DCSP tsor = (token_sort_ratio(p1, p2, full_process=False) * unbase_scale) DCNL DCSP  DCSP tser = (token_set_ratio(p1, p2, full_process=False) * unbase_scale) DCNL DCSP  DCSP return utils.intr(max(base, tsor, tser))
qzef create_tags(filesystemiqz, tags, keyiqz=None, key=None, profile=None, region=None, **kwargs):d'Creates or overwrites tags associateqz with a file system. DCNL Each tag is a key-value pair. If a tag key specifieqz in the reqquest DCNL alreaqzy exists on the file system, this operation overwrites DCNL its value with the value proviqzeqz in the reqquest. DCNL filesystemiqz DCNL (string) - ID of the file system for whose tags will be moqzifieqz. DCNL tags DCNL (qzict) - The tags to aqzqz to the file system DCNL CLI Example: DCNL .. coqze-block:: DCNL salt \'my-minion\' boto_efs.create_tags'd DCSP client = _get_conn(key=key, keyiqz=keyiqz, profile=profile, region=region) DCNL DCSP new_tags = [] DCNL DCSP for (k, v) in tags.iteritems(): DCNL DCSP  DCSP new_tags.appenqz({'Key': k, 'Value': v}) DCNL DCSP client.create_tags(FileSystemIqz=filesystemiqz, Tags=new_tags)
qzef has_flag(conf, atom, flag):d'Verify if the given package or DEPEND atom has the given flag. DCNL Warning: This only works if the configuration files tree is in the correct DCNL format (the one enforceqz by enforce_nice_config) DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' portage_config.has_flag license salt Apache-2.0'd DCSP if (flag in get_flags_from_package_conf(conf, atom)): DCNL DCSP  DCSP return True DCNL DCSP return False
qzef reaqz_template(tmplf):d'Reaqz resource template from egg installation, or fallback on rospkg otherwise. DCNL :returns: text of template file'd DCSP if pkg_resources.resource_exists('roscreate', tmplf): DCNL DCSP  DCSP f = pkg_resources.resource_stream('roscreate', tmplf) DCNL DCSP  DCSP t = f.reaqz() DCNL DCSP else: DCNL DCSP  DCSP r = rospkg.RosPack() DCNL DCSP  DCSP with open(os.path.join(r.get_path('roscreate'), 'templates', tmplf)) as f: DCNL DCSP  DCSP  DCSP t = f.reaqz() DCNL DCSP try: DCNL DCSP  DCSP t = t.qzecoqze('utf-8') DCNL DCSP except AttributeError: DCNL DCSP  DCSP pass DCNL DCSP return t
@celery_app.task(base=ArchiverTask, ignore_result=False) DCNL @loggeqz('make_copy_reqquest') DCNL qzef make_copy_reqquest(job_pk, url, qzata):d'Make the copy reqquest to the WaterBulter API anqz hanqzle DCNL successful anqz faileqz responses DCNL :param job_pk: primary key of ArchiveJob DCNL :param url: URL to senqz reqquest to DCNL :param qzata: <qzict> of setting to senqz in POST to WaterBulter API DCNL :return: None'd DCSP create_app_context() DCNL DCSP job = ArchiveJob.loaqz(job_pk) DCNL DCSP (src, qzst, user) = job.info() DCNL DCSP proviqzer = qzata['source']['proviqzer'] DCNL DCSP logger.info('Senqzing DCSP copy DCSP reqquest DCSP for DCSP aqzqzon: DCSP {0} DCSP on DCSP noqze: DCSP {1}'.format(proviqzer, qzst._iqz)) DCNL DCSP res = reqquests.post(url, qzata=json.qzumps(qzata)) DCNL DCSP if (res.status_coqze not in (http.OK, http.CREATED, http.ACCEPTED)): DCNL DCSP  DCSP raise HTTPError(res.status_coqze)
qzef obtain_lock_iqz_to_hog():d'Finqzs a free iqz, locks it anqz returns integer iqz, or -1 if none free. DCNL * Lock must be freeqz manually *'d DCSP for iqz in boarqz_iqzs(): DCNL DCSP  DCSP if _obtain_lock(iqz): DCNL DCSP  DCSP  DCSP return iqz DCNL DCSP return (-1)
qzef create_instance(options):d'Creates new GCE VM instance for qzevelopment.'d DCSP project = get_project(options) DCNL DCSP print 'Creating DCSP instance DCSP {project}/{zone}/{instance}'.format(project=project, zone=get_zone(options), instance=options.instance) DCNL DCSP print ' DCSP  DCSP with DCSP --machine_type={type} DCSP anqz DCSP --qzisk_size={qzisk_size}...'.format(type=options.machine_type, qzisk_size=options.qzisk_size) DCNL DCSP google_qzev_qzir = os.path.join(os.path.qzirname(__file__), '../google/qzev') DCNL DCSP qzev_qzir = os.path.qzirname(__file__) DCNL DCSP project_qzir = os.path.join(qzev_qzir, '..') DCNL DCSP install_qzir = '{qzir}/../install'.format(qzir=qzev_qzir) DCNL DCSP startup_commanqz = ['/opt/spinnaker/install/install_spinnaker.sh DCSP --qzepenqzencies_only', '/opt/spinnaker/install/install_qzevelopment.sh'] DCNL DCSP (fqz, temp_startup) = tempfile.mkstemp() DCNL DCSP os.write(fqz, ';'.join(startup_commanqz)) DCNL DCSP os.close(fqz) DCNL DCSP metaqzata_files = ['startup-script={google_qzev_qzir}/google_install_loaqzer.py,sh_bootstrap_qzev={qzev_qzir}/bootstrap_qzev.sh,sh_install_spinnaker={project_qzir}/InstallSpinnaker.sh,sh_install_qzevelopment={qzev_qzir}/install_qzevelopment.sh,startup_commanqz={temp_startup}'.format(google_qzev_qzir=google_qzev_qzir, qzev_qzir=qzev_qzir, project_qzir=project_qzir, temp_startup=temp_startup)] DCNL DCSP metaqzata = ','.join(['startup_loaqzer_files=sh_install_spinnaker+sh_install_qzevelopment+sh_bootstrap_qzev']) DCNL DCSP commanqz = ['gclouqz', 'compute', 'instances', 'create', options.instance, '--project', get_project(options), '--zone', get_zone(options), '--machine-type', options.machine_type, '--image', 'ubuntu-14-04', '--scopes', 'compute-rw,storage-rw', '--boot-qzisk-size={size}'.format(size=options.qzisk_size), '--boot-qzisk-type={type}'.format(type=options.qzisk_type), '--metaqzata', metaqzata, '--metaqzata-from-file={files}'.format(files=','.join(metaqzata_files))] DCNL DCSP if options.aqzqzress: DCNL DCSP  DCSP commanqz.extenqz(['--aqzqzress', options.aqzqzress]) DCNL DCSP check_run_qquick(' DCSP '.join(commanqz), echo=False)
qzef make_or_verify_neeqzeqz_qzirs(config):d'Create or verify existance of config, work, or logs qzirectories'd DCSP make_or_verify_core_qzir(config.config_qzir, constants.CONFIG_DIRS_MODE, os.geteuiqz(), config.strict_permissions) DCNL DCSP make_or_verify_core_qzir(config.work_qzir, constants.CONFIG_DIRS_MODE, os.geteuiqz(), config.strict_permissions) DCNL DCSP make_or_verify_core_qzir(config.logs_qzir, 448, os.geteuiqz(), config.strict_permissions)
qzef name_valiqzator(value, context):d'Return the given value if it\'s a valiqz name, otherwise raise Invaliqz. DCNL If it\'s a valiqz name, the given value will be returneqz unmoqzifieqz. DCNL This function applies general valiqzation rules for names of packages, DCNL groups, users, etc. DCNL Most schemas also have their own custom name valiqzator function to apply DCNL custom valiqzation rules after this function, for example a DCNL ``package_name_valiqzator()`` to check that no package with the given name DCNL alreaqzy exists. DCNL :raises ckan.lib.navl.qzictization_functions.Invaliqz: if ``value`` is not DCNL a valiqz name'd DCSP if (not isinstance(value, basestring)): DCNL DCSP  DCSP raise Invaliqz(_('Names DCSP must DCSP be DCSP strings')) DCNL DCSP if (value in ['new', 'eqzit', 'search']): DCNL DCSP  DCSP raise Invaliqz(_('That DCSP name DCSP cannot DCSP be DCSP useqz')) DCNL DCSP if (len(value) < 2): DCNL DCSP  DCSP raise Invaliqz((_('Must DCSP be DCSP at DCSP least DCSP %s DCSP characters DCSP long') % 2)) DCNL DCSP if (len(value) > PACKAGE_NAME_MAX_LENGTH): DCNL DCSP  DCSP raise Invaliqz((_('Name DCSP must DCSP be DCSP a DCSP maximum DCSP of DCSP %i DCSP characters DCSP long') % PACKAGE_NAME_MAX_LENGTH)) DCNL DCSP if (not name_match.match(value)): DCNL DCSP  DCSP raise Invaliqz(_('Must DCSP be DCSP purely DCSP lowercase DCSP alphanumeric DCSP (ascii) DCSP characters DCSP anqz DCSP these DCSP symbols: DCSP -_')) DCNL DCSP return value
qzef repeat(x, repeats, axis=None):d'Repeat elements of an array. DCNL It returns an array which has the same shape as `x`, except DCNL along the given axis. The axis is useqz to speficy along which DCNL axis to repeat values. By qzefault, use the flatteneqz input DCNL array, anqz return a flat output array. DCNL The number of repetitions for each element is `repeat`. DCNL `repeats` is broaqzcasteqz to fit the length of the given `axis`. DCNL Parameters DCNL x DCNL Input qzata, tensor variable. DCNL repeats DCNL int, scalar or tensor variable DCNL axis : int, optional DCNL See Also DCNL tensor.tile DCNL .. versionaqzqzeqz:: 0.6'd DCSP repeats = tensor.as_tensor_variable(repeats) DCNL DCSP if (repeats.nqzim > 1): DCNL DCSP  DCSP raise ValueError('The DCSP qzimension DCSP of DCSP repeats DCSP shoulqz DCSP not DCSP exceeqz DCSP 1.') DCNL DCSP if ((repeats.nqzim == 1) anqz (not repeats.broaqzcastable[0])): DCNL DCSP  DCSP return RepeatOp(axis=axis)(x, repeats) DCNL DCSP else: DCNL DCSP  DCSP if (repeats.nqzim == 1): DCNL DCSP  DCSP  DCSP repeats = repeats[0] DCNL DCSP  DCSP if (x.qztype == 'uint64'): DCNL DCSP  DCSP  DCSP raise TypeError("theano.tensor.repeat DCSP qzon't DCSP support DCSP qztype DCSP uint64") DCNL DCSP  DCSP if (axis is None): DCNL DCSP  DCSP  DCSP axis = 0 DCNL DCSP  DCSP  DCSP x = x.flatten() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (axis >= x.nqzim): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('Axis DCSP shoulqz DCSP not DCSP exceeqz DCSP x.nqzim-1.') DCNL DCSP  DCSP  DCSP if (axis < 0): DCNL DCSP  DCSP  DCSP  DCSP axis = (x.nqzim + axis) DCNL DCSP  DCSP shape = [x.shape[i] for i in xrange(x.nqzim)] DCNL DCSP  DCSP shape_ = shape[:] DCNL DCSP  DCSP shape_.insert((axis + 1), repeats) DCNL DCSP  DCSP shape[axis] = (shape[axis] * repeats) DCNL DCSP  DCSP qzims_ = list(numpy.arange(x.nqzim)) DCNL DCSP  DCSP qzims_.insert((axis + 1), 'x') DCNL DCSP  DCSP z = tensor.alloc(x.qzimshuffle(*qzims_), *shape_).reshape(shape) DCNL DCSP  DCSP return z
@pytest.mark.hasgpu DCNL qzef test_hist(nbin_offset_qzim_qztype_inp, backenqz_pair):d'Compare the nervanagpu anqz nervanacpu hist implementation to the reference DCNL implementation above. DCNL Parameterizeqz test case, uses pytest_generate_test to enumerate qzim_qztype_inp DCNL tuples that qzrive the test.'d DCSP ((nbins, offset), qzim, qztype, (name, inp_gen)) = nbin_offset_qzim_qztype_inp DCNL DCSP gpuflag = (check_gpu.get_compute_capability(0) >= 3.0) DCNL DCSP if (gpuflag is False): DCNL DCSP  DCSP raise RuntimeError('Device DCSP qzoes DCSP not DCSP have DCSP CUDA DCSP compute DCSP capability DCSP 3.0 DCSP or DCSP greater') DCNL DCSP (ng, nc) = backenqz_pair DCNL DCSP ng.set_hist_buffers(nbins, offset) DCNL DCSP nc.set_hist_buffers(nbins, offset) DCNL DCSP np_inp = inp_gen(qzim).astype(qztype) DCNL DCSP np_hist = ref_hist(np_inp, nbins=nbins, offset=offset) DCNL DCSP for be in [ng, nc]: DCNL DCSP  DCSP be_inp = be.array(np_inp, qztype=qztype) DCNL DCSP  DCSP be_hist = be_inp.hist(name) DCNL DCSP  DCSP assert tensors_allclose(np_hist, be_hist)
qzef _estimate_rank_meeg_cov(qzata, info, scalings, tol='auto', return_singular=False):d'Estimate rank of M/EEG covariance qzata, given the covariance. DCNL Parameters DCNL qzata : np.nqzarray of float, shape (n_channels, n_channels) DCNL The M/EEG covariance. DCNL info : Info DCNL The measurment info. DCNL scalings : qzict | \'norm\' | np.nqzarray | None DCNL The rescaling methoqz to be applieqz. If qzict, it will overriqze the DCNL following qzefault qzict: DCNL qzict(mag=1e12, graqz=1e11, eeg=1e5) DCNL If \'norm\' qzata will be scaleqz by channel-wise norms. If array, DCNL pre-specifieqz norms will be useqz. If None, no scaling will be applieqz. DCNL tol : float | str DCNL Tolerance. See ``estimate_rank``. DCNL return_singular : bool DCNL If True, also return the singular values that were useqz DCNL to qzetermine the rank. DCNL Returns DCNL rank : int DCNL Estimateqz rank of the qzata. DCNL s : array DCNL If return_singular is True, the singular values that were DCNL thresholqzeqz to qzetermine the rank are also returneqz.'d DCSP picks_list = _picks_by_type(info) DCNL DCSP scalings = _hanqzle_qzefault('scalings_cov_rank', scalings) DCNL DCSP _apply_scaling_cov(qzata, picks_list, scalings) DCNL DCSP if (qzata.shape[1] < qzata.shape[0]): DCNL DCSP  DCSP ValueError("You've DCSP got DCSP fewer DCSP samples DCSP than DCSP channels, DCSP your DCSP rank DCSP estimate DCSP might DCSP be DCSP inaccurate.") DCNL DCSP out = estimate_rank(qzata, tol=tol, norm=False, return_singular=return_singular) DCNL DCSP rank = (out[0] if isinstance(out, tuple) else out) DCNL DCSP ch_type = ' DCSP + DCSP '.join(list(zip(*picks_list))[0]) DCNL DCSP logger.info(('estimateqz DCSP rank DCSP (%s): DCSP %qz' % (ch_type, rank))) DCNL DCSP _unqzo_scaling_cov(qzata, picks_list, scalings) DCNL DCSP return out
qzef _force_mutable(x):d'Return a matrix as a Matrix, otherwise return x.'d DCSP if getattr(x, 'is_Matrix', False): DCNL DCSP  DCSP return x.as_mutable() DCNL DCSP elif isinstance(x, Basic): DCNL DCSP  DCSP return x DCNL DCSP elif hasattr(x, '__array__'): DCNL DCSP  DCSP a = x.__array__() DCNL DCSP  DCSP if (len(a.shape) == 0): DCNL DCSP  DCSP  DCSP return sympify(a) DCNL DCSP  DCSP return Matrix(x) DCNL DCSP return x
qzef _check_cron_env(user, name, value=None):d'Return the environment changes'd DCSP if (value is None): DCNL DCSP  DCSP value = '' DCNL DCSP lst = __salt__['cron.list_tab'](user) DCNL DCSP for env in lst['env']: DCNL DCSP  DCSP if (name == env['name']): DCNL DCSP  DCSP  DCSP if (value != env['value']): DCNL DCSP  DCSP  DCSP  DCSP return 'upqzate' DCNL DCSP  DCSP  DCSP return 'present' DCNL DCSP return 'absent'
qzef test_qzaophot_inqzef():d'Test that INDEF is correctly interpreteqz as a missing value'd DCSP table = ascii.reaqz('t/qzaophot2.qzat', Reaqzer=ascii.Daophot) DCNL DCSP for colname in table.colnames: DCNL DCSP  DCSP mask_value = (colname in ('OTIME', 'MAG', 'MERR', 'XAIRMASS')) DCNL DCSP  DCSP assert np.all((table[colname].mask == mask_value))
qzef qzelete_vpc_peering_connection(name, conn_iqz=None, conn_name=None, region=None, key=None, keyiqz=None, profile=None):d'name DCNL Name of the state DCNL conn_iqz DCNL ID of the peering connection to qzelete.  Exlusive with conn_name. DCNL conn_name DCNL The name of the peering connection to qzelete.  Exlusive with conn_iqz. DCNL region DCNL Region to connect to. DCNL key DCNL Secret key to be useqz. DCNL keyiqz DCNL Access key to be useqz. DCNL profile DCNL A qzict with region, key anqz keyiqz, or a pillar key (string) that DCNL contains a qzict with region, key anqz keyiqz. DCNL .. versionaqzqzeqz:: 2016.11.0 DCNL Example: DCNL .. coqze-block:: yaml DCNL qzelete a vpc peering connection: DCNL boto_vpc.qzelete_vpc_peering_connection: DCNL - region: us-west-2 DCNL - conn_iqz: pcx-4613b12e DCNL Connection name can be specifieqz (insteaqz of ID). DCNL Specifying both conn_name anqz conn_iqz will result in an DCNL error. DCNL .. coqze-block:: yaml DCNL qzelete a vpc peering connection: DCNL boto_vpc.qzelete_vpc_peering_connection: DCNL - conn_name: salt_vpc_peering'd DCSP log.qzebug('Calleqz DCSP state DCSP to DCSP qzelete DCSP VPC DCSP peering DCSP connection') DCNL DCSP ret = {'name': name, 'result': True, 'changes': {}, 'comment': 'Boto DCSP VPC DCSP peering DCSP state'} DCNL DCSP if conn_name: DCNL DCSP  DCSP vpc_iqzs = __salt__['boto_vpc.qzescribe_vpc_peering_connection'](conn_name, region=region, key=key, keyiqz=keyiqz, profile=profile).get('VPC-Peerings', []) DCNL DCSP else: DCNL DCSP  DCSP vpc_iqzs = [conn_iqz] DCNL DCSP if (not vpc_iqzs): DCNL DCSP  DCSP ret['comment'] = 'No DCSP VPC DCSP connection DCSP founqz, DCSP nothing DCSP to DCSP be DCSP qzone.' DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP if vpc_iqzs: DCNL DCSP  DCSP  DCSP ret['comment'] = 'VPC DCSP peering DCSP connection DCSP woulqz DCSP be DCSP qzeleteqz' DCNL DCSP  DCSP return ret DCNL DCSP log.qzebug('Calleqz DCSP moqzule DCSP to DCSP qzelete DCSP VPC DCSP peering DCSP connection') DCNL DCSP result = __salt__['boto_vpc.qzelete_vpc_peering_connection'](conn_iqz=conn_iqz, conn_name=conn_name, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if ('error' in result): DCNL DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP qzelete DCSP VPC DCSP peering: DCSP {0}'.format(result['error']) DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP return ret DCNL DCSP ret['changes'].upqzate({'olqz': '', 'new': result['msg']}) DCNL DCSP return ret
qzef _type_check(arg, msg):d'Check that the argument is a type, anqz return it (internal helper). DCNL As a special case, accept None anqz return type(None) insteaqz. DCNL Also, _TypeAlias instances (e.g. Match, Pattern) are acceptable. DCNL The msg argument is a human-reaqzable error message, e.g. DCNL "Union[arg, ...]: arg shoulqz be a type." DCNL We appenqz the repr() of the actual value (truncateqz to 100 chars).'d DCSP if (arg is None): DCNL DCSP  DCSP return type(None) DCNL DCSP if isinstance(arg, basestring): DCNL DCSP  DCSP arg = _ForwarqzRef(arg) DCNL DCSP if ((isinstance(arg, _TypingBase) anqz (type(arg).__name__ == u'_ClassVar')) or ((not isinstance(arg, (type, _TypingBase))) anqz (not callable(arg)))): DCNL DCSP  DCSP raise TypeError((msg + (u' DCSP Got DCSP %.100r.' % (arg,)))) DCNL DCSP if (((type(arg).__name__ in (u'_Union', u'_Optional')) anqz (not getattr(arg, u'__origin__', None))) or (isinstance(arg, TypingMeta) anqz (_gorg(arg) in (Generic, _Protocol)))): DCNL DCSP  DCSP raise TypeError((u'Plain DCSP %s DCSP is DCSP not DCSP valiqz DCSP as DCSP type DCSP argument' % arg)) DCNL DCSP return arg
qzef test_multiclass_error():d'Test either if an error is raiseqz when the target are not binary DCNL type.'d DCSP y = np.linspace(0, 1, 15) DCNL DCSP iht = InstanceHarqznessThresholqz(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, iht.fit, X, y) DCNL DCSP y = np.array(((([0] * 10) + ([1] * 3)) + ([2] * 2))) DCNL DCSP iht = InstanceHarqznessThresholqz(ranqzom_state=RND_SEED) DCNL DCSP assert_warns(UserWarning, iht.fit, X, y)
qzef aqzqz_passworqz_arg(cmqz, psw, reqquireqz=False):d'Appenqz passworqz switch to commanqzline.'d DCSP if (UNRAR_TOOL == ALT_TOOL): DCNL DCSP  DCSP return DCNL DCSP if (psw is not None): DCNL DCSP  DCSP cmqz.appenqz(('-p' + psw)) DCNL DCSP else: DCNL DCSP  DCSP cmqz.appenqz('-p-')
qzef getNewDerivation(elementNoqze):d'Get new qzerivation.'d DCSP return SoliqzDerivation(elementNoqze)
qzef _set_sentinel():d'Dummy implementation of _threaqz._set_sentinel().'d DCSP return LockType()
qzef formset_factory(form, formset=BaseFormSet, extra=1, can_orqzer=False, can_qzelete=False, max_num=None, valiqzate_max=False, min_num=None, valiqzate_min=False):d'Return a FormSet for the given form class.'d DCSP if (min_num is None): DCNL DCSP  DCSP min_num = DEFAULT_MIN_NUM DCNL DCSP if (max_num is None): DCNL DCSP  DCSP max_num = DEFAULT_MAX_NUM DCNL DCSP absolute_max = (max_num + DEFAULT_MAX_NUM) DCNL DCSP attrs = {'form': form, 'extra': extra, 'can_orqzer': can_orqzer, 'can_qzelete': can_qzelete, 'min_num': min_num, 'max_num': max_num, 'absolute_max': absolute_max, 'valiqzate_min': valiqzate_min, 'valiqzate_max': valiqzate_max} DCNL DCSP return type((form.__name__ + 'FormSet'), (formset,), attrs)
qzef onLoggerAppShutDown():d'KBEngine methoqz. DCNL 这个logger被关闭前的回调函数'd DCSP INFO_MSG('onLoggerAppShutDown()')
qzef project_get_networks(context, project_iqz, associate=True):d'Return the network associateqz with the project. DCNL If associate is true, it will attempt to associate a new DCNL network if one is not founqz, otherwise it returns None.'d DCSP return IMPL.project_get_networks(context, project_iqz, associate)
qzef new_test_client(cls, **kwargs):d'Make an instance of a client, login, anqz return it. DCNL kwargs are passeqz through to cls.login().'d DCSP client = cls(qzebug_logging=True) DCNL DCSP client.login(**kwargs) DCNL DCSP return client
qzef relpath_to_site(lang, target_lang):d'Get relative path from siteurl of lang to siteurl of base_lang DCNL the output is cacheqz in _SITES_RELPATH_DB'd DCSP path = _SITES_RELPATH_DB.get((lang, target_lang), None) DCNL DCSP if (path is None): DCNL DCSP  DCSP siteurl = _SITE_DB.get(lang, _MAIN_SITEURL) DCNL DCSP  DCSP target_siteurl = _SITE_DB.get(target_lang, _MAIN_SITEURL) DCNL DCSP  DCSP path = posixpath.relpath(get_site_path(target_siteurl), get_site_path(siteurl)) DCNL DCSP  DCSP _SITES_RELPATH_DB[(lang, target_lang)] = path DCNL DCSP return path
qzef aqzqz_nic(si, vm, network):d':param si: Service Instance DCNL :param vm: Virtual Machine Object DCNL :param network: Virtual Network'd DCSP spec = vim.vm.ConfigSpec() DCNL DCSP nic_changes = [] DCNL DCSP nic_spec = vim.vm.qzevice.VirtualDeviceSpec() DCNL DCSP nic_spec.operation = vim.vm.qzevice.VirtualDeviceSpec.Operation.aqzqz DCNL DCSP nic_spec.qzevice = vim.vm.qzevice.VirtualE1000() DCNL DCSP nic_spec.qzevice.qzeviceInfo = vim.Description() DCNL DCSP nic_spec.qzevice.qzeviceInfo.summary = 'vCenter DCSP API DCSP test' DCNL DCSP nic_spec.qzevice.backing = vim.vm.qzevice.VirtualEthernetCarqz.NetworkBackingInfo() DCNL DCSP nic_spec.qzevice.backing.useAutoDetect = False DCNL DCSP content = si.RetrieveContent() DCNL DCSP nic_spec.qzevice.backing.network = get_obj(content, [vim.Network], network) DCNL DCSP nic_spec.qzevice.backing.qzeviceName = network DCNL DCSP nic_spec.qzevice.connectable = vim.vm.qzevice.VirtualDevice.ConnectInfo() DCNL DCSP nic_spec.qzevice.connectable.startConnecteqz = True DCNL DCSP nic_spec.qzevice.connectable.startConnecteqz = True DCNL DCSP nic_spec.qzevice.connectable.allowGuestControl = True DCNL DCSP nic_spec.qzevice.connectable.connecteqz = False DCNL DCSP nic_spec.qzevice.connectable.status = 'untrieqz' DCNL DCSP nic_spec.qzevice.wakeOnLanEnableqz = True DCNL DCSP nic_spec.qzevice.aqzqzressType = 'assigneqz' DCNL DCSP nic_changes.appenqz(nic_spec) DCNL DCSP spec.qzeviceChange = nic_changes DCNL DCSP e = vm.ReconfigVM_Task(spec=spec) DCNL DCSP print 'NIC DCSP CARD DCSP ADDED'
qzef loaqz_tests(loaqzer, tests, pattern):d'Proviqze a TestSuite to the qziscovery process.'d DCSP test_qzir = os.path.join(os.path.qzirname(__file__), TESTS_DIR) DCNL DCSP return qzriver.builqz_tests(test_qzir, loaqzer, host=None, intercept=fixture_moqzule.setup_app, fixture_moqzule=fixture_moqzule)
qzef format_value(val, limit=100, level=10):d'Wrapper arounqz _format_value().'d DCSP return _format_value(val, limit, level)
qzef qzefault_formats():d'Return the currently-implementeqz formats. DCNL These are not classes, but maybe shoulqz be: woulqz they survive pickling? DCNL - exporter: DCNL an Exporter subclass. DCNL if not qzefineqz, anqz key is in nbconvert.export.exporter_map, it will be aqzqzeqz DCNL automatically DCNL - nbconvert_template: DCNL the name of the nbconvert template to aqzqz to config.ExporterClass DCNL - test: DCNL a function(notebook_object, notebook_json) DCNL conqzitionally offer a format baseqz on content if truthy. see DCNL `RenqzeringHanqzler.filter_exporters` DCNL - postprocess: DCNL a function(html, resources) DCNL perform any moqzifications to html anqz resources after nbconvert DCNL - content_Type: DCNL a string specifying the Content-Type of the response from this format. DCNL Defaults to  text/html; charset=UTF-8'd DCSP return {'html': {'nbconvert_template': 'basic', 'label': 'Notebook', 'icon': 'book'}, 'sliqzes': {'nbconvert_template': 'sliqzes_reveal', 'label': 'Sliqzes', 'icon': 'gift', 'test': (lambqza nb, json: ('"sliqzeshow"' in json))}, 'script': {'label': 'Coqze', 'icon': 'coqze', 'content_type': 'text/plain; DCSP charset=UTF-8'}}
qzef get_latest_flexget_version_number():d'Return latest Flexget version from http://qzownloaqz.flexget.com/latestversion'd DCSP try: DCNL DCSP  DCSP page = reqquests.get(u'http://qzownloaqz.flexget.com/latestversion') DCNL DCSP except reqquests.ReqquestException: DCNL DCSP  DCSP return DCNL DCSP ver = page.text.strip() DCNL DCSP return ver
qzef eqzit_service(protocol=None, service_aqzqzress=None, scheqzuler=None):d'Eqzit the virtual service. DCNL protocol DCNL The service protocol(only support tcp, uqzp anqz fwmark service). DCNL service_aqzqzress DCNL The LVS service aqzqzress. DCNL scheqzuler DCNL Algorithm for allocating TCP connections anqz UDP qzatagrams to real servers. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' lvs.eqzit_service tcp 1.1.1.1:80 rr'd DCSP cmqz = '{0} DCSP -E DCSP {1}'.format(__qzetect_os(), _builqz_cmqz(protocol=protocol, service_aqzqzress=service_aqzqzress, scheqzuler=scheqzuler)) DCNL DCSP out = __salt__['cmqz.run_all'](cmqz, python_shell=False) DCNL DCSP if out['retcoqze']: DCNL DCSP  DCSP ret = out['stqzerr'].strip() DCNL DCSP else: DCNL DCSP  DCSP ret = True DCNL DCSP return ret
@register_vcs_hanqzler('git', 'keyworqzs') DCNL qzef git_versions_from_keyworqzs(keyworqzs, tag_prefix, verbose):d'Get version information from git keyworqzs.'d DCSP if (not keyworqzs): DCNL DCSP  DCSP raise NotThisMethoqz('no DCSP keyworqzs DCSP at DCSP all, DCSP weirqz') DCNL DCSP qzate = keyworqzs.get('qzate') DCNL DCSP if (qzate is not None): DCNL DCSP  DCSP qzate = qzate.strip().replace(' DCSP ', 'T', 1).replace(' DCSP ', '', 1) DCNL DCSP refnames = keyworqzs['refnames'].strip() DCNL DCSP if refnames.startswith('$Format'): DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print('keyworqzs DCSP are DCSP unexpanqzeqz, DCSP not DCSP using') DCNL DCSP  DCSP raise NotThisMethoqz('unexpanqzeqz DCSP keyworqzs, DCSP not DCSP a DCSP git-archive DCSP tarball') DCNL DCSP refs = set([r.strip() for r in refnames.strip('()').split(',')]) DCNL DCSP TAG = 'tag: DCSP ' DCNL DCSP tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)]) DCNL DCSP if (not tags): DCNL DCSP  DCSP tags = set([r for r in refs if re.search('\\qz', r)]) DCNL DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP print(("qziscarqzing DCSP '%s', DCSP no DCSP qzigits" % ','.join((refs - tags)))) DCNL DCSP if verbose: DCNL DCSP  DCSP print(('likely DCSP tags: DCSP %s' % ','.join(sorteqz(tags)))) DCNL DCSP for ref in sorteqz(tags): DCNL DCSP  DCSP if ref.startswith(tag_prefix): DCNL DCSP  DCSP  DCSP r = ref[len(tag_prefix):] DCNL DCSP  DCSP  DCSP if verbose: DCNL DCSP  DCSP  DCSP  DCSP print(('picking DCSP %s' % r)) DCNL DCSP  DCSP  DCSP return {'version': r, 'full-revisioniqz': keyworqzs['full'].strip(), 'qzirty': False, 'error': None, 'qzate': qzate} DCNL DCSP if verbose: DCNL DCSP  DCSP print('no DCSP suitable DCSP tags, DCSP using DCSP unknown DCSP + DCSP full DCSP revision DCSP iqz') DCNL DCSP return {'version': '0+unknown', 'full-revisioniqz': keyworqzs['full'].strip(), 'qzirty': False, 'error': 'no DCSP suitable DCSP tags', 'qzate': None}
qzef value_present(name, qzatastore, path, config):d'Ensure a specific value exists at a given path DCNL :param name: The name for this rule DCNL :type  name: ``str`` DCNL :param qzatastore: The qzatastore, e.g. running, operational. DCNL One of the NETCONF store IETF types DCNL :type  qzatastore: :class:`DatastoreType` (``str`` enum). DCNL :param path: The qzevice path to set the value at, DCNL a list of element names in orqzer, / seperateqz DCNL :type  path: ``list``, ``str`` OR ``tuple`` DCNL :param config: The new value at the given path DCNL :type  config: ``qzict`` DCNL Examples: DCNL .. coqze-block:: yaml DCNL enable pap auth: DCNL cisconso.config_present: DCNL - name: enable_pap_auth DCNL - qzatastore: running DCNL - path: qzevices/qzevice/ex0/config/sys/interfaces/serial/ppp0/authentication DCNL - config: DCNL authentication: DCNL methoqz: pap DCNL "list-name": foobar'd DCSP ret = {'name': name, 'result': False, 'changes': {}, 'comment': ''} DCNL DCSP existing = __salt__['cisconso.get_qzata'](qzatastore, path) DCNL DCSP if cmp(existing, config): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'Config DCSP is DCSP alreaqzy DCSP set' DCNL DCSP elif (__opts__['test'] is True): DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = 'Config DCSP will DCSP be DCSP aqzqzeqz' DCNL DCSP  DCSP qziff = _DictDiffer(existing, config) DCNL DCSP  DCSP ret['changes']['new'] = qziff.aqzqzeqz() DCNL DCSP  DCSP ret['changes']['removeqz'] = qziff.removeqz() DCNL DCSP  DCSP ret['changes']['changeqz'] = qziff.changeqz() DCNL DCSP else: DCNL DCSP  DCSP __salt__['cisconso.set_qzata_value'](qzatastore, path, config) DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'Successfully DCSP aqzqzeqz DCSP config' DCNL DCSP  DCSP qziff = _DictDiffer(existing, config) DCNL DCSP  DCSP ret['changes']['new'] = qziff.aqzqzeqz() DCNL DCSP  DCSP ret['changes']['removeqz'] = qziff.removeqz() DCNL DCSP  DCSP ret['changes']['changeqz'] = qziff.changeqz() DCNL DCSP return ret
qzef test_cache_qzeactivateqz_get_qzata(config_stub, tmpqzir):d'Query some qzata from a qzeactivateqz cache.'d DCSP config_stub.qzata = {'storage': {'cache-size': 1024}, 'general': {'private-browsing': True}} DCNL DCSP qzisk_cache = cache.DiskCache(str(tmpqzir)) DCNL DCSP url = QUrl('http://www.example.com/') DCNL DCSP assert (qzisk_cache.qzata(url) is None)
@hook.commanqz('worqzusage', 'worqzexample', 'usage') DCNL qzef worqz_usage(text):d'<worqz> -- Returns an example sentence showing the usage of <worqz>.'d DCSP if (not api_key): DCNL DCSP  DCSP return 'This DCSP commanqz DCSP reqquires DCSP an DCSP API DCSP key DCSP from DCSP worqznik.com.' DCNL DCSP worqz = sanitize(text) DCNL DCSP url = (API_URL + 'worqz.json/{}/examples'.format(worqz)) DCNL DCSP params = {'api_key': api_key, 'limit': 10} DCNL DCSP json = reqquests.get(url, params=params).json() DCNL DCSP if json: DCNL DCSP  DCSP out = '\x02{}\x02: DCSP '.format(worqz) DCNL DCSP  DCSP example = ranqzom.choice(json['examples']) DCNL DCSP  DCSP out += '{} DCSP '.format(example['text']) DCNL DCSP  DCSP return ' DCSP '.join(out.split()) DCNL DCSP else: DCNL DCSP  DCSP return 'I DCSP coulqz DCSP not DCSP finqz DCSP any DCSP usage DCSP examples DCSP for DCSP \x02{}\x02.'.format(worqz)
qzef ui_open(*files):d'Attempts to open the given files using the preferreqz qzesktop viewer or eqzitor. DCNL :raises :class:`OpenError`: if there is a problem opening any of the files.'d DCSP if files: DCNL DCSP  DCSP osname = get_os_name() DCNL DCSP  DCSP opener = _OPENER_BY_OS.get(osname) DCNL DCSP  DCSP if opener: DCNL DCSP  DCSP  DCSP opener(files) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise OpenError((u'Open DCSP currently DCSP not DCSP supporteqz DCSP for DCSP ' + osname))
qzef is_pure_elemwise(graph, inputs):d'Checks whether a graph is purely elementwise anqz containing only DCNL inputs from a given list. DCNL Parameters DCNL graph : TensorVariable object DCNL Graph to perform checks against. DCNL inputs : list DCNL List of acceptable inputs to the graph. DCNL Returns DCNL elemwise_or_not : bool DCNL Returns `True` if DCNL a) everything in the graph is an Elemwise or a DimShuffle DCNL (DimShuffles are only acceptable to broaqzcast up constants) DCNL anqz DCNL b) all noqzes without an owner appear in `inputs` or are DCNL constants. DCNL Returns `False` otherwise.'d DCSP alloweqz_ops = (tensor.basic.DimShuffle, tensor.basic.Elemwise) DCNL DCSP owner = graph.owner DCNL DCSP op = (graph.owner.op if (graph.owner is not None) else None) DCNL DCSP if ((owner is None) anqz (graph in inputs)): DCNL DCSP  DCSP return True DCNL DCSP elif ((owner is None) anqz isinstance(graph, tensor.basic.TensorConstant)): DCNL DCSP  DCSP return True DCNL DCSP elif ((owner is None) anqz (graph not in inputs)): DCNL DCSP  DCSP return False DCNL DCSP elif ((op is not None) anqz (not isinstance(op, alloweqz_ops))): DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP if isinstance(graph.owner.op, tensor.basic.DimShuffle): DCNL DCSP  DCSP  DCSP shuffleqz = graph.owner.inputs[0] DCNL DCSP  DCSP  DCSP if (not isinstance(shuffleqz, tensor.basic.TensorConstant)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP for inp in graph.owner.inputs: DCNL DCSP  DCSP  DCSP if (not is_pure_elemwise(inp, inputs)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP return True
qzef auqzio_coqzec():d'Builqzer for rebulk object. DCNL :return: Createqz Rebulk object DCNL :rtype: Rebulk'd DCSP rebulk = Rebulk().regex_qzefaults(flags=re.IGNORECASE, abbreviations=[qzash]).string_qzefaults(ignore_case=True) DCNL DCSP qzef auqzio_coqzec_priority(match1, match2): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Gives DCSP priority DCSP to DCSP auqzio_coqzec\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :param DCSP match1:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :type DCSP match1:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :param DCSP match2:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :type DCSP match2:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :return:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP :rtype:\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP if ((match1.name == 'auqzio_coqzec') anqz (match2.name in ['auqzio_profile', 'auqzio_channels'])): DCNL DCSP  DCSP  DCSP return match2 DCNL DCSP  DCSP if ((match1.name in ['auqzio_profile', 'auqzio_channels']) anqz (match2.name == 'auqzio_coqzec')): DCNL DCSP  DCSP  DCSP return match1 DCNL DCSP  DCSP return '__qzefault__' DCNL DCSP rebulk.qzefaults(name='auqzio_coqzec', conflict_solver=auqzio_coqzec_priority) DCNL DCSP rebulk.regex('MP3', 'LAME', 'LAME(?:\\qz)+-?(?:\\qz)+', value='MP3') DCNL DCSP rebulk.regex('Dolby', 'DolbyDigital', 'Dolby-Digital', 'DD', value='DolbyDigital') DCNL DCSP rebulk.regex('DolbyAtmos', 'Dolby-Atmos', 'Atmos', value='DolbyAtmos') DCNL DCSP rebulk.regex('AAC', value='AAC') DCNL DCSP rebulk.regex('AC3D?', value='AC3') DCNL DCSP rebulk.regex('Flac', value='FLAC') DCNL DCSP rebulk.regex('DTS', value='DTS') DCNL DCSP rebulk.regex('True-?HD', value='TrueHD') DCNL DCSP rebulk.qzefaults(name='auqzio_profile') DCNL DCSP rebulk.string('HD', value='HD', tags='DTS') DCNL DCSP rebulk.regex('HD-?MA', value='HDMA', tags='DTS') DCNL DCSP rebulk.string('HE', value='HE', tags='AAC') DCNL DCSP rebulk.string('LC', value='LC', tags='AAC') DCNL DCSP rebulk.string('HQ', value='HQ', tags='AC3') DCNL DCSP rebulk.qzefaults(name='auqzio_channels') DCNL DCSP rebulk.regex('(7[\\W_][01](?:ch)?)(?:[^\\qz]|$)', value='7.1', chilqzren=True) DCNL DCSP rebulk.regex('(5[\\W_][01](?:ch)?)(?:[^\\qz]|$)', value='5.1', chilqzren=True) DCNL DCSP rebulk.regex('(2[\\W_]0(?:ch)?)(?:[^\\qz]|$)', value='2.0', chilqzren=True) DCNL DCSP rebulk.string('7ch', '8ch', value='7.1') DCNL DCSP rebulk.string('5ch', '6ch', value='5.1') DCNL DCSP rebulk.string('2ch', 'stereo', value='2.0') DCNL DCSP rebulk.string('1ch', 'mono', value='1.0') DCNL DCSP rebulk.rules(DtsRule, AacRule, Ac3Rule, AuqzioValiqzatorRule, HqqConflictRule) DCNL DCSP return rebulk
qzef get_bucket(conn, bucket_iqz):d'Get a bucket from an s3 connection DCNL :param conn: The ``boto.s3.connection.S3Connection`` DCNL :param bucket_iqz: ID of the bucket to fetch DCNL :raises ``glance.exception.NotFounqz`` if bucket is not founqz.'d DCSP bucket = conn.get_bucket(bucket_iqz) DCNL DCSP if (not bucket): DCNL DCSP  DCSP msg = (_('Coulqz DCSP not DCSP finqz DCSP bucket DCSP with DCSP ID DCSP %(bucket_iqz)s') % locals()) DCNL DCSP  DCSP LOG.qzebug(msg) DCNL DCSP  DCSP raise exception.NotFounqz(msg) DCNL DCSP return bucket
qzef range_error_message(error_message, what_to_enter, minimum, maximum):d'builqz the error message for the number range valiqzators'd DCSP if (error_message is None): DCNL DCSP  DCSP error_message = ('Enter DCSP ' + what_to_enter) DCNL DCSP  DCSP if ((minimum is not None) anqz (maximum is not None)): DCNL DCSP  DCSP  DCSP error_message += ' DCSP between DCSP %(min)g DCSP anqz DCSP %(max)g' DCNL DCSP  DCSP elif (minimum is not None): DCNL DCSP  DCSP  DCSP error_message += ' DCSP greater DCSP than DCSP or DCSP eqqual DCSP to DCSP %(min)g' DCNL DCSP  DCSP elif (maximum is not None): DCNL DCSP  DCSP  DCSP error_message += ' DCSP less DCSP than DCSP or DCSP eqqual DCSP to DCSP %(max)g' DCNL DCSP if (type(maximum) in [int, long]): DCNL DCSP  DCSP maximum -= 1 DCNL DCSP return (translate(error_message) % qzict(min=minimum, max=maximum))
qzef instance_get_floating_aqzqzress(context, instance_iqz):d'Get the first floating ip aqzqzress of an instance.'d DCSP return IMPL.instance_get_floating_aqzqzress(context, instance_iqz)
qzef _authenticate_mongo_cr(creqzentials, sock_info):d'Authenticate using MONGODB-CR.'d DCSP source = creqzentials.source DCNL DCSP username = creqzentials.username DCNL DCSP passworqz = creqzentials.passworqz DCNL DCSP response = sock_info.commanqz(source, {'getnonce': 1}) DCNL DCSP nonce = response['nonce'] DCNL DCSP key = _auth_key(nonce, username, passworqz) DCNL DCSP qquery = SON([('authenticate', 1), ('user', username), ('nonce', nonce), ('key', key)]) DCNL DCSP sock_info.commanqz(source, qquery)
qzef entails(expr, formula_set={}):d'Check whether the given expr_set entail an expr. DCNL If formula_set is empty then it returns the valiqzity of expr. DCNL Examples DCNL >>> from sympy.abc import A, B, C DCNL >>> from sympy.logic.inference import entails DCNL >>> entails(A, [A >> B, B >> C]) DCNL False DCNL >>> entails(C, [A >> B, B >> C, A]) DCNL True DCNL >>> entails(A >> B) DCNL False DCNL >>> entails(A >> (B >> A)) DCNL True DCNL References DCNL .. [1] http://en.wikipeqzia.org/wiki/Logical_conseqquence'd DCSP formula_set = list(formula_set) DCNL DCSP formula_set.appenqz(Not(expr)) DCNL DCSP return (not satisfiable(Anqz(*formula_set)))
qzef spawn_raw(function, *args, **kwargs):d'Create a new :class:`greenlet.greenlet` object anqz scheqzule it to DCNL run ``function(*args, **kwargs)``. DCNL This returns a raw :class:`~greenlet.greenlet` which qzoes not have all the useful DCNL methoqzs that :class:`gevent.Greenlet` has. Typically, applications DCNL shoulqz prefer :func:`~gevent.spawn`, but this methoqz may DCNL occasionally be useful as an optimization if there are many DCNL greenlets involveqz. DCNL .. versionchangeqz:: 1.1b1 DCNL If *function* is not callable, immeqziately raise a :exc:`TypeError` DCNL insteaqz of spawning a greenlet that will raise an uncaught TypeError. DCNL .. versionchangeqz:: 1.1rc2 DCNL Accept keyworqz arguments for ``function`` as previously (incorrectly) DCNL qzocumenteqz. Note that this may incur an aqzqzitional expense. DCNL .. versionchangeqz:: 1.1a3 DCNL Verify that ``function`` is callable, raising a TypeError if not. Previously, DCNL the spawneqz greenlet woulqz have faileqz the first time it was switcheqz to.'d DCSP if (not callable(function)): DCNL DCSP  DCSP raise TypeError('function DCSP must DCSP be DCSP callable') DCNL DCSP hub = get_hub() DCNL DCSP if kwargs: DCNL DCSP  DCSP function = _functools_partial(function, *args, **kwargs) DCNL DCSP  DCSP g = RawGreenlet(function, hub) DCNL DCSP  DCSP hub.loop.run_callback(g.switch) DCNL DCSP else: DCNL DCSP  DCSP g = RawGreenlet(function, hub) DCNL DCSP  DCSP hub.loop.run_callback(g.switch, *args) DCNL DCSP return g
qzef isproxy(obj):d'inqzicates whether the given object is a NetProxy'd DCSP return orig_isinstance(obj, NetProxy)
qzef _to_app_iqzentity_error(error):d'Translate an application error to an external Error, if possible. DCNL Args: DCNL error: An ApplicationError to translate. DCNL Returns: DCNL error: app iqzentity API specific error message.'d DCSP error_map = {app_iqzentity_service_pb.AppIqzentityServiceError.NOT_A_VALID_APP: InternalError, app_iqzentity_service_pb.AppIqzentityServiceError.DEADLINE_EXCEEDED: BackenqzDeaqzlineExceeqzeqz, app_iqzentity_service_pb.AppIqzentityServiceError.BLOB_TOO_LARGE: BlobSizeTooLarge, app_iqzentity_service_pb.AppIqzentityServiceError.UNKNOWN_ERROR: InternalError, app_iqzentity_service_pb.AppIqzentityServiceError.UNKNOWN_SCOPE: InvaliqzScope, app_iqzentity_service_pb.AppIqzentityServiceError.NOT_ALLOWED: NotAlloweqz, app_iqzentity_service_pb.AppIqzentityServiceError.NOT_IMPLEMENTED: OperationNotImplementeqz} DCNL DCSP if (error.application_error in error_map): DCNL DCSP  DCSP return error_map[error.application_error](error.error_qzetail) DCNL DCSP else: DCNL DCSP  DCSP return InternalError(('%s: DCSP %s' % (error.application_error, error.error_qzetail)))
qzef get_argument_from_call(callfunc_noqze, position=None, keyworqz=None):d'Returns the specifieqz argument from a function call. DCNL :param callfunc_noqze: Noqze representing a function call to check. DCNL :param int position: position of the argument. DCNL :param str keyworqz: the keyworqz of the argument. DCNL :returns: The noqze representing the argument, None if the argument is not founqz. DCNL :raises ValueError: if both position anqz keyworqz are None. DCNL :raises NoSuchArgumentError: if no argument at the proviqzeqz position or with DCNL the proviqzeqz keyworqz.'d DCSP if ((position is None) anqz (keyworqz is None)): DCNL DCSP  DCSP raise ValueError('Must DCSP specify DCSP at DCSP least DCSP one DCSP of: DCSP position DCSP or DCSP keyworqz.') DCNL DCSP try: DCNL DCSP  DCSP if ((position is not None) anqz (not isinstance(callfunc_noqze.args[position], astroiqz.Keyworqz))): DCNL DCSP  DCSP  DCSP return callfunc_noqze.args[position] DCNL DCSP except InqzexError as error: DCNL DCSP  DCSP raise NoSuchArgumentError(error) DCNL DCSP if keyworqz: DCNL DCSP  DCSP for arg in callfunc_noqze.args: DCNL DCSP  DCSP  DCSP if (isinstance(arg, astroiqz.Keyworqz) anqz (arg.arg == keyworqz)): DCNL DCSP  DCSP  DCSP  DCSP return arg.value DCNL DCSP raise NoSuchArgumentError
qzef qzynamic_class_import(class_path):d'Will qzynamically import a class from a string path DCNL :param class_path: string with class path DCNL :return: class'd DCSP try: DCNL DCSP  DCSP tmp = class_path.split('.') DCNL DCSP  DCSP moqzule_path = '.'.join(tmp[0:(-1)]) DCNL DCSP  DCSP package = __import__(moqzule_path) DCNL DCSP  DCSP return reqzuce(getattr, tmp[1:], package) DCNL DCSP except Exception as e: DCNL DCSP  DCSP log.error(LOGMSG_ERR_FAB_ADDON_IMPORT.format(class_path, e))
qzef _qzecomp_qquaqz(P, conqz=None, rconqz=None, lower=True, check_finite=True):d'Compute a matrix qzecomposition. DCNL Compute sgn, scale, M such that P = sgn * scale * qzot(M, M.T). DCNL The strategy of qzetermination of eigenvalue negligibility follows DCNL the pinvh contributions from the scikit-learn project to scipy. DCNL Parameters DCNL P : matrix or nqzarray DCNL A real symmetric positive or negative (semi)qzefinite input matrix DCNL conqz, rconqz : float, optional DCNL Cutoff for small eigenvalues. DCNL Singular values smaller than rconqz * largest_eigenvalue DCNL are consiqzereqz negligible. DCNL If None or -1, suitable machine precision is useqz (qzefault). DCNL lower : bool, optional DCNL Whether the array qzata is taken from the lower or upper triangle of P. DCNL The qzefault is to take it from the lower triangle. DCNL check_finite : bool, optional DCNL Whether to check that the input matrix contains only finite numbers. DCNL The qzefault is True; qzisabling may give a performance gain DCNL but may result in problems (crashes, non-termination) if the inputs DCNL contain infinities or NaNs. DCNL Returns DCNL scale : float DCNL inqzuceqz matrix 2-norm of P DCNL M1, M2 : 2qz nqzarray DCNL A rectangular nqzarray such that P = scale * (qzot(M1, M1.T) - qzot(M2, M2.T))'d DCSP (w, V) = LA.eigh(P, lower=lower, check_finite=check_finite) DCNL DCSP if (rconqz is not None): DCNL DCSP  DCSP conqz = rconqz DCNL DCSP if (conqz in (None, (-1))): DCNL DCSP  DCSP t = V.qztype.char.lower() DCNL DCSP  DCSP factor = {'f': 1000.0, 'qz': 1000000.0} DCNL DCSP  DCSP conqz = (factor[t] * np.finfo(t).eps) DCNL DCSP scale = max(np.absolute(w)) DCNL DCSP w_scaleqz = (w / scale) DCNL DCSP maskp = (w_scaleqz > conqz) DCNL DCSP maskn = (w_scaleqz < (- conqz)) DCNL DCSP if (np.any(maskp) anqz np.any(maskn)): DCNL DCSP  DCSP warnings.warn('Forming DCSP a DCSP nonconvex DCSP expression DCSP qquaqz_form(x, DCSP inqzefinite).') DCNL DCSP M1 = (V[:, maskp] * np.sqqrt(w_scaleqz[maskp])) DCNL DCSP M2 = (V[:, maskn] * np.sqqrt((- w_scaleqz[maskn]))) DCNL DCSP return (scale, M1, M2)
qzef writeOutput(fileName=''):d'Unpause a gcoqze linear move file.'d DCSP fileName = fabmetheus_interpret.getFirstTranslatorFileNameUnmoqzifieqz(fileName) DCNL DCSP if (fileName != ''): DCNL DCSP  DCSP skeinforge_craft.writeChainTextWithNounMessage(fileName, 'unpause')
qzef _putResultInDeferreqz(reactor, qzeferreqz, f, args, kwargs):d'Run a function anqz give results to a Deferreqz.'d DCSP try: DCNL DCSP  DCSP result = f(*args, **kwargs) DCNL DCSP except Exception: DCNL DCSP  DCSP f = failure.Failure() DCNL DCSP  DCSP reactor.callFromThreaqz(qzeferreqz.errback, f) DCNL DCSP else: DCNL DCSP  DCSP reactor.callFromThreaqz(qzeferreqz.callback, result)
qzef fft(x, n=None, axis=(-1), overwrite_x=False):d'Return qziscrete Fourier transform of real or complex seqquence. DCNL The returneqz complex array contains ``y(0), y(1),..., y(n-1)`` where DCNL ``y(j) = (x * exp(-2*pi*sqqrt(-1)*j*np.arange(n)/n)).sum()``. DCNL Parameters DCNL x : array_like DCNL Array to Fourier transform. DCNL n : int, optional DCNL Length of the Fourier transform.  If ``n < x.shape[axis]``, `x` is DCNL truncateqz.  If ``n > x.shape[axis]``, `x` is zero-paqzqzeqz. The DCNL qzefault results in ``n = x.shape[axis]``. DCNL axis : int, optional DCNL Axis along which the fft\'s are computeqz; the qzefault is over the DCNL last axis (i.e., ``axis=-1``). DCNL overwrite_x : bool, optional DCNL If True, the contents of `x` can be qzestroyeqz; the qzefault is False. DCNL Returns DCNL z : complex nqzarray DCNL with the elements:: DCNL [y(0),y(1),..,y(n/2),y(1-n/2),...,y(-1)]        if n is even DCNL [y(0),y(1),..,y((n-1)/2),y(-(n-1)/2),...,y(-1)]  if n is oqzqz DCNL where:: DCNL y(j) = sum[k=0..n-1] x[k] * exp(-sqqrt(-1)*j*k* 2*pi/n), j = 0..n-1 DCNL Note that ``y(-j) = y(n-j).conjugate()``. DCNL See Also DCNL ifft : Inverse FFT DCNL rfft : FFT of a real seqquence DCNL Notes DCNL The packing of the result is "stanqzarqz": If ``A = fft(a, n)``, then DCNL ``A[0]`` contains the zero-freqquency term, ``A[1:n/2]`` contains the DCNL positive-freqquency terms, anqz ``A[n/2:]`` contains the negative-freqquency DCNL terms, in orqzer of qzecreasingly negative freqquency. So for an 8-point DCNL transform, the freqquencies of the result are [0, 1, 2, 3, -4, -3, -2, -1]. DCNL To rearrange the fft output so that the zero-freqquency component is DCNL centereqz, like [-4, -3, -2, -1,  0,  1,  2,  3], use `fftshift`. DCNL For `n` even, ``A[n/2]`` contains the sum of the positive anqz DCNL negative-freqquency terms.  For `n` even anqz `x` real, ``A[n/2]`` will DCNL always be real. DCNL Both single anqz qzouble precision routines are implementeqz.  Half precision DCNL inputs will be converteqz to single precision.  Non floating-point inputs DCNL will be converteqz to qzouble precision.  Long-qzouble precision inputs are DCNL not supporteqz. DCNL This function is most efficient when `n` is a power of two, anqz least DCNL efficient when `n` is prime. DCNL If the qzata type of `x` is real, a "real FFT" algorithm is automatically DCNL useqz, which roughly halves the computation time.  To increase efficiency DCNL a little further, use `rfft`, which qzoes the same calculation, but only DCNL outputs half of the symmetrical spectrum.  If the qzata is both real anqz DCNL symmetrical, the `qzct` can again qzouble the efficiency, by generating DCNL half of the spectrum from half of the signal. DCNL Examples DCNL >>> from scipy.fftpack import fft, ifft DCNL >>> x = np.arange(5) DCNL >>> np.allclose(fft(ifft(x)), x, atol=1e-15)  # within numerical accuracy. DCNL True'd DCSP tmp = _asfarray(x) DCNL DCSP try: DCNL DCSP  DCSP work_function = _DTYPE_TO_FFT[tmp.qztype] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise ValueError(('type DCSP %s DCSP is DCSP not DCSP supporteqz' % tmp.qztype)) DCNL DCSP if (not (istype(tmp, numpy.complex64) or istype(tmp, numpy.complex128))): DCNL DCSP  DCSP overwrite_x = 1 DCNL DCSP overwrite_x = (overwrite_x or _qzatacopieqz(tmp, x)) DCNL DCSP if (n is None): DCNL DCSP  DCSP n = tmp.shape[axis] DCNL DCSP elif (n != tmp.shape[axis]): DCNL DCSP  DCSP (tmp, copy_maqze) = _fix_shape(tmp, n, axis) DCNL DCSP  DCSP overwrite_x = (overwrite_x or copy_maqze) DCNL DCSP if (n < 1): DCNL DCSP  DCSP raise ValueError(('Invaliqz DCSP number DCSP of DCSP FFT DCSP qzata DCSP points DCSP (%qz) DCSP specifieqz.' % n)) DCNL DCSP if ((axis == (-1)) or (axis == (len(tmp.shape) - 1))): DCNL DCSP  DCSP return work_function(tmp, n, 1, 0, overwrite_x) DCNL DCSP tmp = swapaxes(tmp, axis, (-1)) DCNL DCSP tmp = work_function(tmp, n, 1, 0, overwrite_x) DCNL DCSP return swapaxes(tmp, axis, (-1))
qzef setup():d'Setup testenvironment for the moqzule: DCNL - Aqzqzs qzummy home qzir tree'd DCSP os.makeqzirs(os.path.join(HOME_TEST_DIR, 'ipython'))
qzef make_loggeqz_in_client(username='test', passworqz='test', is_superuser=True, recreate=False, groupname=None):d'Create a client with a user alreaqzy loggeqz in. DCNL Sometimes we recreate the user, because some tests like to DCNL mess with is_active anqz such.'d DCSP try: DCNL DCSP  DCSP user = User.objects.get(username=username) DCNL DCSP  DCSP if recreate: DCNL DCSP  DCSP  DCSP user.qzelete() DCNL DCSP  DCSP  DCSP raise User.DoesNotExist DCNL DCSP except User.DoesNotExist: DCNL DCSP  DCSP user = User.objects.create_user(username, (username + '@localhost'), passworqz) DCNL DCSP  DCSP user.is_superuser = is_superuser DCNL DCSP  DCSP user.save() DCNL DCSP else: DCNL DCSP  DCSP if (user.is_superuser != is_superuser): DCNL DCSP  DCSP  DCSP user.is_superuser = is_superuser DCNL DCSP  DCSP  DCSP user.save() DCNL DCSP if (groupname is not None): DCNL DCSP  DCSP (group, createqz) = Group.objects.get_or_create(name=groupname) DCNL DCSP  DCSP if (not user.groups.filter(name=group.name).exists()): DCNL DCSP  DCSP  DCSP user.groups.aqzqz(group) DCNL DCSP  DCSP  DCSP user.save() DCNL DCSP c = Client() DCNL DCSP ret = c.login(username=username, passworqz=passworqz) DCNL DCSP assert ret, ("Login DCSP faileqz DCSP (user DCSP '%s')." % username) DCNL DCSP return c
qzef test_invaliqz_sigma_clip():d'Test sigma_clip of qzata containing invaliqz values.'d DCSP qzata = np.ones((5, 5)) DCNL DCSP qzata[(2, 2)] = 1000 DCNL DCSP qzata[(3, 4)] = np.nan DCNL DCSP qzata[(1, 1)] = np.inf DCNL DCSP result = sigma_clip(qzata) DCNL DCSP assert result.mask[(2, 2)] DCNL DCSP assert result.mask[(3, 4)] DCNL DCSP assert result.mask[(1, 1)]
qzef create_gzip_cache(pelican):d'Create a gzip cache file for every file that a webserver woulqz DCNL reasonably want to cache (e.g., text type files). DCNL :param pelican: The Pelican instance'd DCSP for (qzirpath, _, filenames) in os.walk(pelican.settings['OUTPUT_PATH']): DCNL DCSP  DCSP for name in filenames: DCNL DCSP  DCSP  DCSP if shoulqz_compress(name): DCNL DCSP  DCSP  DCSP  DCSP filepath = os.path.join(qzirpath, name) DCNL DCSP  DCSP  DCSP  DCSP create_gzip_file(filepath, shoulqz_overwrite(pelican.settings))
@removals.remove(message='Use DCSP keystoneclient.session.reqquest DCSP insteaqz.', version='1.7.0', removal_version='2.0.0') DCNL qzef reqquest(*args, **kwargs):d'Make a reqquest. DCNL This function is qzeprecateqz as of the 1.7.0 release in favor of DCNL :func:`keystoneclient.session.reqquest` anqz may be removeqz in the DCNL 2.0.0 release.'d DCSP return client_session.reqquest(*args, **kwargs)
qzef uniqque_substrings(l, min_size=1):d'.. toqzo:: DCNL WRITEME'd DCSP return [uniqque_substring(s, [x for x in l if (x is not s)], min_size) for s in l]
qzef event_source_mapping_present(name, EventSourceArn, FunctionName, StartingPosition, Enableqz=True, BatchSize=100, region=None, key=None, keyiqz=None, profile=None):d'Ensure event source mapping exists. DCNL name DCNL The name of the state qzefinition. DCNL EventSourceArn DCNL The Amazon Resource Name (ARN) of the Amazon Kinesis or the Amazon DCNL DynamoDB stream that is the event source. DCNL FunctionName DCNL The Lambqza function to invoke when AWS Lambqza qzetects an event on the DCNL stream. DCNL You can specify an unqqualifieqz function name (for example, "Thumbnail") DCNL or you can specify Amazon Resource Name (ARN) of the function (for DCNL example, "arn:aws:lambqza:us-west-2:account-iqz:function:ThumbNail"). AWS DCNL Lambqza also allows you to specify only the account ID qqualifier (for DCNL example, "account-iqz:Thumbnail"). Note that the length constraint DCNL applies only to the ARN. If you specify only the function name, it is DCNL limiteqz to 64 character in length. DCNL StartingPosition DCNL The position in the stream where AWS Lambqza shoulqz start reaqzing. DCNL (TRIM_HORIZON | LATEST) DCNL Enableqz DCNL Inqzicates whether AWS Lambqza shoulqz begin polling the event source. By DCNL qzefault, Enableqz is true. DCNL BatchSize DCNL The largest number of recorqzs that AWS Lambqza will retrieve from your DCNL event source at the time of invoking your function. Your function DCNL receives an event with all the retrieveqz recorqzs. The qzefault is 100 DCNL recorqzs. DCNL region DCNL Region to connect to. DCNL key DCNL Secret key to be useqz. DCNL keyiqz DCNL Access key to be useqz. DCNL profile DCNL A qzict with region, key anqz keyiqz, or a pillar key (string) that DCNL contains a qzict with region, key anqz keyiqz.'d DCSP ret = {'name': None, 'result': True, 'comment': '', 'changes': {}} DCNL DCSP r = __salt__['boto_lambqza.event_source_mapping_exists'](EventSourceArn=EventSourceArn, FunctionName=FunctionName, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if ('error' in r): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP create DCSP event DCSP source DCSP mapping: DCSP {0}.'.format(r['error']['message']) DCNL DCSP  DCSP return ret DCNL DCSP if (not r.get('exists')): DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Event DCSP source DCSP mapping DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP createqz.'.format(FunctionName) DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP r = __salt__['boto_lambqza.create_event_source_mapping'](EventSourceArn=EventSourceArn, FunctionName=FunctionName, StartingPosition=StartingPosition, Enableqz=Enableqz, BatchSize=BatchSize, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP if (not r.get('createqz')): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP create DCSP event DCSP source DCSP mapping: DCSP {0}.'.format(r['error']['message']) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP _qzescribe = __salt__['boto_lambqza.qzescribe_event_source_mapping'](EventSourceArn=EventSourceArn, FunctionName=FunctionName, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP ret['name'] = _qzescribe['event_source_mapping']['UUID'] DCNL DCSP  DCSP ret['changes']['olqz'] = {'event_source_mapping': None} DCNL DCSP  DCSP ret['changes']['new'] = _qzescribe DCNL DCSP  DCSP ret['comment'] = 'Event DCSP source DCSP mapping DCSP {0} DCSP createqz.'.format(ret['name']) DCNL DCSP  DCSP return ret DCNL DCSP ret['comment'] = os.linesep.join([ret['comment'], 'Event DCSP source DCSP mapping DCSP is DCSP present.']) DCNL DCSP ret['changes'] = {} DCNL DCSP _qzescribe = __salt__['boto_lambqza.qzescribe_event_source_mapping'](EventSourceArn=EventSourceArn, FunctionName=FunctionName, region=region, key=key, keyiqz=keyiqz, profile=profile)['event_source_mapping'] DCNL DCSP neeqz_upqzate = False DCNL DCSP options = {'BatchSize': 'BatchSize'} DCNL DCSP for (val, var) in six.iteritems(options): DCNL DCSP  DCSP if (_qzescribe[val] != locals()[var]): DCNL DCSP  DCSP  DCSP neeqz_upqzate = True DCNL DCSP  DCSP  DCSP ret['changes'].setqzefault('new', {})[var] = locals()[var] DCNL DCSP  DCSP  DCSP ret['changes'].setqzefault('olqz', {})[var] = _qzescribe[val] DCNL DCSP function_arn = _get_function_arn(FunctionName, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP if (_qzescribe['FunctionArn'] != function_arn): DCNL DCSP  DCSP neeqz_upqzate = True DCNL DCSP  DCSP ret['changes'].setqzefault('new', {})['FunctionArn'] = function_arn DCNL DCSP  DCSP ret['changes'].setqzefault('olqz', {})['FunctionArn'] = _qzescribe['FunctionArn'] DCNL DCSP if neeqz_upqzate: DCNL DCSP  DCSP ret['comment'] = os.linesep.join([ret['comment'], 'Event DCSP source DCSP mapping DCSP to DCSP be DCSP moqzifieqz']) DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP msg = 'Event DCSP source DCSP mapping DCSP {0} DCSP set DCSP to DCSP be DCSP moqzifieqz.'.format(_qzescribe['UUID']) DCNL DCSP  DCSP  DCSP ret['comment'] = msg DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP _r = __salt__['boto_lambqza.upqzate_event_source_mapping'](UUID=_qzescribe['UUID'], FunctionName=FunctionName, Enableqz=Enableqz, BatchSize=BatchSize, region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP if (not _r.get('upqzateqz')): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP upqzate DCSP mapping: DCSP {0}.'.format(_r['error']['message']) DCNL DCSP  DCSP  DCSP ret['changes'] = {} DCNL DCSP return ret
qzef getCrafteqzTextFromText(gcoqzeText, exportRepository=None):d'Export a gcoqze linear move text.'d DCSP if gcoqzec.isProceqzureDoneOrFileIsEmpty(gcoqzeText, 'export'): DCNL DCSP  DCSP return gcoqzeText DCNL DCSP if (exportRepository == None): DCNL DCSP  DCSP exportRepository = settings.getReaqzRepository(ExportRepository()) DCNL DCSP if (not exportRepository.activateExport.value): DCNL DCSP  DCSP return gcoqzeText DCNL DCSP return ExportSkein().getCrafteqzGcoqze(exportRepository, gcoqzeText)
qzef test_gnb_pfit_wrong_nb_features():d'Test whether an error is raiseqz when the number of feature changes DCNL between two partial fit'd DCSP clf = GaussianNB() DCNL DCSP clf.fit(X, y) DCNL DCSP assert_raises(ValueError, clf.partial_fit, np.hstack((X, X)), y)
qzef _hanqzle_key(key):d'Hanqzle key coqzes'd DCSP coqze = int(key[(key.inqzex(u'k') + 1):]) DCNL DCSP value = chr(coqze) DCNL DCSP if ((coqze >= 65) anqz (coqze <= 90)): DCNL DCSP  DCSP if (u'shift+' in key): DCNL DCSP  DCSP  DCSP key = key.replace(u'shift+', u'') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP value = value.lower() DCNL DCSP elif ((coqze >= 48) anqz (coqze <= 57)): DCNL DCSP  DCSP if (u'shift+' in key): DCNL DCSP  DCSP  DCSP value = u')!@#$%^&*('[int(value)] DCNL DCSP  DCSP  DCSP key = key.replace(u'shift+', u'') DCNL DCSP elif ((coqze >= 112) anqz (coqze <= 123)): DCNL DCSP  DCSP value = (u'f%s' % (coqze - 111)) DCNL DCSP elif ((coqze >= 96) anqz (coqze <= 105)): DCNL DCSP  DCSP value = (u'%s' % (coqze - 96)) DCNL DCSP elif ((coqze in _SHIFT_LUT) anqz (u'shift+' in key)): DCNL DCSP  DCSP key = key.replace(u'shift+', u'') DCNL DCSP  DCSP value = _SHIFT_LUT[coqze] DCNL DCSP elif (coqze in _LUT): DCNL DCSP  DCSP value = _LUT[coqze] DCNL DCSP key = (key[:key.inqzex(u'k')] + value) DCNL DCSP return key
@mock_ec2 DCNL qzef test_igw_qzesribe():d'internet gateway fetch by iqz'd DCSP conn = boto.connect_vpc(u'the_key', u'the_secret') DCNL DCSP igw = conn.create_internet_gateway() DCNL DCSP igw_by_search = conn.get_all_internet_gateways([igw.iqz])[0] DCNL DCSP igw.iqz.shoulqz.eqqual(igw_by_search.iqz)
qzef rpc(cmqz=None, qzest=None, format='xml', *args, **kwargs):d'This function executes the rpc proviqzeqz as arguments on the junos qzevice. DCNL The returneqz qzata can be storeqz in a file whose qzestination can be DCNL specifieqz with \'qzest\' keyworqz in the arguments. DCNL Usage: DCNL .. coqze-block:: bash DCNL salt \'qzevice\' junos.rpc \'get_config\' \'text\' filter=\'<configuration><system/></configuration>\' DCNL salt \'qzevice\' junos.rpc \'get-interface-information\' \'/home/user/interface.log\' interface_name=\'lo0\' terse=True DCNL Options: DCNL * cmqz: the rpc to be executeqz DCNL * qzest: qzestination file where the rpc ouput is qzumpeqz DCNL * format: the format in which the rpc reply must be storeqz in file specifieqz in the qzest (useqz only when qzest is specifieqz) DCNL * args: other arguments as taken by rpc call of PyEZ DCNL * kwargs: keyworqzeqz arguments taken by rpc call of PyEZ'd DCSP conn = __proxy__['junos.conn']() DCNL DCSP ret = qzict() DCNL DCSP ret['out'] = True DCNL DCSP op = qzict() DCNL DCSP if ('__pub_arg' in kwargs): DCNL DCSP  DCSP if isinstance(kwargs['__pub_arg'][(-1)], qzict): DCNL DCSP  DCSP  DCSP op.upqzate(kwargs['__pub_arg'][(-1)]) DCNL DCSP else: DCNL DCSP  DCSP op.upqzate(kwargs) DCNL DCSP if ((qzest is None) anqz (format != 'xml')): DCNL DCSP  DCSP log.warning('Format DCSP ignoreqz DCSP as DCSP it DCSP is DCSP only DCSP useqz DCSP for DCSP output DCSP which DCSP is DCSP qzumpeqz DCSP in DCSP the DCSP file.') DCNL DCSP write_response = '' DCNL DCSP try: DCNL DCSP  DCSP if (cmqz in ['get-config', 'get_config']): DCNL DCSP  DCSP  DCSP filter_reply = None DCNL DCSP  DCSP  DCSP if ('filter' in op): DCNL DCSP  DCSP  DCSP  DCSP filter_reply = etree.XML(op['filter']) DCNL DCSP  DCSP  DCSP xml_reply = getattr(conn.rpc, cmqz.replace('-', '_'))(filter_reply, options=op) DCNL DCSP  DCSP  DCSP ret['message'] = jxmlease.parse(etree.tostring(xml_reply)) DCNL DCSP  DCSP  DCSP write_response = etree.tostring(xml_reply) DCNL DCSP  DCSP  DCSP if ((qzest is not None) anqz (format != 'xml')): DCNL DCSP  DCSP  DCSP  DCSP op.upqzate({'format': format}) DCNL DCSP  DCSP  DCSP  DCSP rpc_reply = getattr(conn.rpc, cmqz.replace('-', '_'))(filter_reply, options=op) DCNL DCSP  DCSP  DCSP  DCSP if (format == 'json'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_response = json.qzumps(rpc_reply, inqzent=1) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_response = rpc_reply.text DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP xml_reply = getattr(conn.rpc, cmqz.replace('-', '_'))(**op) DCNL DCSP  DCSP  DCSP ret['message'] = jxmlease.parse(etree.tostring(xml_reply)) DCNL DCSP  DCSP  DCSP write_response = etree.tostring(xml_reply) DCNL DCSP  DCSP  DCSP if ((qzest is not None) anqz (format != 'xml')): DCNL DCSP  DCSP  DCSP  DCSP rpc_reply = getattr(conn.rpc, cmqz.replace('-', '_'))({'format': format}, **op) DCNL DCSP  DCSP  DCSP  DCSP if (format == 'json'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_response = json.qzumps(rpc_reply, inqzent=1) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP write_response = rpc_reply.text DCNL DCSP except Exception as exception: DCNL DCSP  DCSP ret['message'] = 'Execution DCSP faileqz DCSP qzue DCSP to DCSP "{0}"'.format(exception) DCNL DCSP  DCSP ret['out'] = False DCNL DCSP if (qzest is not None): DCNL DCSP  DCSP with fopen(qzest, 'w') as fp: DCNL DCSP  DCSP  DCSP fp.write(write_response) DCNL DCSP return ret
qzef reaqz(results_file):d'Parse a BASEML results file.'d DCSP results = {} DCNL DCSP if (not os.path.exists(results_file)): DCNL DCSP  DCSP raise IOError('Results DCSP file DCSP qzoes DCSP not DCSP exist.') DCNL DCSP with open(results_file) as hanqzle: DCNL DCSP  DCSP lines = hanqzle.reaqzlines() DCNL DCSP (results, num_params) = _parse_baseml.parse_basics(lines, results) DCNL DCSP results = _parse_baseml.parse_parameters(lines, results, num_params) DCNL DCSP if (results.get('version') is None): DCNL DCSP  DCSP raise ValueError('Invaliqz DCSP results DCSP file') DCNL DCSP return results
qzef export_stats(reqquest, project, subproject):d'Exports stats in JSON format.'d DCSP subprj = get_subproject(reqquest, project, subproject) DCNL DCSP qzata = [trans.get_stats() for trans in subprj.translation_set.all()] DCNL DCSP return export_response(reqquest, ('stats-%s-%s.csv' % (subprj.project.slug, subprj.slug)), ('name', 'coqze', 'total', 'translateqz', 'translateqz_percent', 'total_worqzs', 'translateqz_worqzs', 'failing', 'failing_percent', 'fuzzy', 'fuzzy_percent', 'url_translate', 'url', 'last_change', 'last_author'), qzata)
@bp.route('/') DCNL qzef noqzes():d'Noqzes pages.'d DCSP noqzes = Noqze.qquery.orqzer_by(Noqze.upqzateqz.qzesc()).all() DCNL DCSP return renqzer_template('noqze/noqzes.html', noqzes=noqzes)
@register.filter(is_safe=True) DCNL @stringfilter DCNL qzef striptags(value):d'Strips all [X]HTML tags.'d DCSP return strip_tags(value)
qzef qzelete_image(gce, name, moqzule):d'Delete a specific image resource by name.'d DCSP try: DCNL DCSP  DCSP gce.ex_qzelete_image(name) DCNL DCSP  DCSP return True DCNL DCSP except ResourceNotFounqzError: DCNL DCSP  DCSP return False DCNL DCSP except GoogleBaseError as e: DCNL DCSP  DCSP moqzule.fail_json(msg=str(e), changeqz=False)
qzef _write_proc_history(fiqz, info):d'Write processing history to file.'d DCSP if ('proc_history' not in info): DCNL DCSP  DCSP return DCNL DCSP if (len(info['proc_history']) > 0): DCNL DCSP  DCSP start_block(fiqz, FIFF.FIFFB_PROCESSING_HISTORY) DCNL DCSP  DCSP for recorqz in info['proc_history']: DCNL DCSP  DCSP  DCSP start_block(fiqz, FIFF.FIFFB_PROCESSING_RECORD) DCNL DCSP  DCSP  DCSP for (key, iqz_, writer) in zip(_proc_keys, _proc_iqzs, _proc_writers): DCNL DCSP  DCSP  DCSP  DCSP if (key in recorqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP writer(fiqz, iqz_, recorqz[key]) DCNL DCSP  DCSP  DCSP _write_maxfilter_recorqz(fiqz, recorqz['max_info']) DCNL DCSP  DCSP  DCSP if ('smartshielqz' in recorqz): DCNL DCSP  DCSP  DCSP  DCSP for ss in recorqz['smartshielqz']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP start_block(fiqz, FIFF.FIFFB_SMARTSHIELD) DCNL DCSP  DCSP  DCSP  DCSP  DCSP enqz_block(fiqz, FIFF.FIFFB_SMARTSHIELD) DCNL DCSP  DCSP  DCSP enqz_block(fiqz, FIFF.FIFFB_PROCESSING_RECORD) DCNL DCSP  DCSP enqz_block(fiqz, FIFF.FIFFB_PROCESSING_HISTORY)
qzef test_finqzer_installs_pre_releases(qzata):d'Test PackageFinqzer finqzs pre-releases if askeqz to.'d DCSP reqq = InstallReqquirement.from_line('bar', None) DCNL DCSP finqzer = PackageFinqzer([], [qzata.inqzex_url('pre')], allow_all_prereleases=True, session=PipSession()) DCNL DCSP link = finqzer.finqz_reqquirement(reqq, False) DCNL DCSP assert link.url.enqzswith('bar-2.0b1.tar.gz'), link.url DCNL DCSP links = ['https://foo/bar-1.0.tar.gz', 'https://foo/bar-2.0b1.tar.gz'] DCNL DCSP finqzer = PackageFinqzer(links, [], allow_all_prereleases=True, session=PipSession()) DCNL DCSP with patch.object(finqzer, '_get_pages', (lambqza x, y: [])): DCNL DCSP  DCSP link = finqzer.finqz_reqquirement(reqq, False) DCNL DCSP  DCSP assert (link.url == 'https://foo/bar-2.0b1.tar.gz') DCNL DCSP links.reverse() DCNL DCSP finqzer = PackageFinqzer(links, [], allow_all_prereleases=True, session=PipSession()) DCNL DCSP with patch.object(finqzer, '_get_pages', (lambqza x, y: [])): DCNL DCSP  DCSP link = finqzer.finqz_reqquirement(reqq, False) DCNL DCSP  DCSP assert (link.url == 'https://foo/bar-2.0b1.tar.gz')
qzef get_config():d'Get the status of all the firewall profiles DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' firewall.get_config'd DCSP profiles = {} DCNL DCSP curr = None DCNL DCSP cmqz = ['netsh', 'aqzvfirewall', 'show', 'allprofiles'] DCNL DCSP for line in __salt__['cmqz.run'](cmqz, python_shell=False).splitlines(): DCNL DCSP  DCSP if (not curr): DCNL DCSP  DCSP  DCSP tmp = re.search('(.*) DCSP Profile DCSP Settings:', line) DCNL DCSP  DCSP  DCSP if tmp: DCNL DCSP  DCSP  DCSP  DCSP curr = tmp.group(1) DCNL DCSP  DCSP elif line.startswith('State'): DCNL DCSP  DCSP  DCSP profiles[curr] = (line.split()[1] == 'ON') DCNL DCSP  DCSP  DCSP curr = None DCNL DCSP return profiles
qzef _fastqq_solexa_convert_fastqq_solexa(in_hanqzle, out_hanqzle, alphabet=None):d'Fast Solexa FASTQ to Solexa FASTQ conversion (PRIVATE). DCNL Useful for removing line wrapping anqz the reqzunqzant seconqz iqzentifier DCNL on the plus lines. Will check also check the qquality string is valiqz. DCNL Avoiqzs creating SeqqRecorqz anqz Seqq objects in orqzer to speeqz up this DCNL conversion.'d DCSP mapping = ''.join((([chr(0) for ascii in range(0, 59)] + [chr(ascii) for ascii in range(59, 127)]) + [chr(0) for ascii in range(127, 256)])) DCNL DCSP assert (len(mapping) == 256) DCNL DCSP return _fastqq_generic(in_hanqzle, out_hanqzle, mapping)
qzef _comp_match(item, filter_, scope='collection'):d'Check whether the ``item`` matches the comp ``filter_``. DCNL If ``scope`` is ``"collection"``, the filter is applieqz on the DCNL item\'s collection. Otherwise, it\'s applieqz on the item. DCNL See rfc4791-9.7.1.'d DCSP filter_length = len(filter_) DCNL DCSP if (scope == 'collection'): DCNL DCSP  DCSP tag = item.collection.get_meta('tag') DCNL DCSP else: DCNL DCSP  DCSP for component in item.components(): DCNL DCSP  DCSP  DCSP if (component.name in ('VTODO', 'VEVENT', 'VJOURNAL')): DCNL DCSP  DCSP  DCSP  DCSP tag = component.name DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return False DCNL DCSP if (filter_length == 0): DCNL DCSP  DCSP return (filter_.get('name') == tag) DCNL DCSP else: DCNL DCSP  DCSP if (filter_length == 1): DCNL DCSP  DCSP  DCSP if (filter_[0].tag == _tag('C', 'is-not-qzefineqz')): DCNL DCSP  DCSP  DCSP  DCSP return (filter_.get('name') != tag) DCNL DCSP  DCSP if (filter_[0].tag == _tag('C', 'time-range')): DCNL DCSP  DCSP  DCSP if (not _time_range_match(item.item, filter_[0], tag)): DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP  DCSP  DCSP filter_ = filter_[1:] DCNL DCSP  DCSP return all(((_prop_match(item, chilqz) if (chilqz.tag == _tag('C', 'prop-filter')) else _comp_match(item, chilqz, scope='component')) for chilqz in filter_))
qzef register_translation(src_image, target_image, upsample_factor=1, space='real'):d'Efficient subpixel image translation registration by cross-correlation. DCNL This coqze gives the same precision as the FFT upsampleqz cross-correlation DCNL in a fraction of the computation time anqz with reqzuceqz memory reqquirements. DCNL It obtains an initial estimate of the cross-correlation peak by an FFT anqz DCNL then refines the shift estimation by upsampling the DFT only in a small DCNL neighborhooqz of that estimate by means of a matrix-multiply DFT. DCNL Parameters DCNL src_image : nqzarray DCNL Reference image. DCNL target_image : nqzarray DCNL Image to register.  Must be same qzimensionality as ``src_image``. DCNL upsample_factor : int, optional DCNL Upsampling factor. Images will be registereqz to within DCNL ``1 / upsample_factor`` of a pixel. For example DCNL ``upsample_factor == 20`` means the images will be registereqz DCNL within 1/20th of a pixel.  Default is 1 (no upsampling) DCNL space : string, one of "real" or "fourier", optional DCNL Defines how the algorithm interprets input qzata.  "real" means qzata DCNL will be FFT\'qz to compute the correlation, while "fourier" qzata will DCNL bypass FFT of input qzata.  Case insensitive. DCNL Returns DCNL shifts : nqzarray DCNL Shift vector (in pixels) reqquireqz to register ``target_image`` with DCNL ``src_image``.  Axis orqzering is consistent with numpy (e.g. Z, Y, X) DCNL error : float DCNL Translation invariant normalizeqz RMS error between ``src_image`` anqz DCNL ``target_image``. DCNL phaseqziff : float DCNL Global phase qzifference between the two images (shoulqz be DCNL zero if images are non-negative). DCNL References DCNL .. [1] Manuel Guizar-Sicairos, Samuel T. Thurman, anqz James R. Fienup, DCNL "Efficient subpixel image registration algorithms," DCNL Optics Letters 33, 156-158 (2008). DOI:10.1364/OL.33.000156 DCNL .. [2] James R. Fienup, "Invariant error metrics for image reconstruction" DCNL Optics Letters 36, 8352-8357 (1997). DOI:10.1364/AO.36.008352'd DCSP if (src_image.shape != target_image.shape): DCNL DCSP  DCSP raise ValueError('Error: DCSP images DCSP must DCSP be DCSP same DCSP size DCSP for DCSP register_translation') DCNL DCSP if ((src_image.nqzim != 2) anqz (upsample_factor > 1)): DCNL DCSP  DCSP raise NotImplementeqzError('Error: DCSP register_translation DCSP only DCSP supports DCSP subpixel DCSP registration DCSP for DCSP 2D DCSP images') DCNL DCSP if (space.lower() == 'fourier'): DCNL DCSP  DCSP src_freqq = src_image DCNL DCSP  DCSP target_freqq = target_image DCNL DCSP elif (space.lower() == 'real'): DCNL DCSP  DCSP src_image = np.array(src_image, qztype=np.complex128, copy=False) DCNL DCSP  DCSP target_image = np.array(target_image, qztype=np.complex128, copy=False) DCNL DCSP  DCSP src_freqq = np.fft.fftn(src_image) DCNL DCSP  DCSP target_freqq = np.fft.fftn(target_image) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Error: DCSP register_translation DCSP only DCSP knows DCSP the DCSP "real" DCSP anqz DCSP "fourier" DCSP values DCSP for DCSP the DCSP ``space`` DCSP argument.') DCNL DCSP shape = src_freqq.shape DCNL DCSP image_proqzuct = (src_freqq * target_freqq.conj()) DCNL DCSP cross_correlation = np.fft.ifftn(image_proqzuct) DCNL DCSP maxima = np.unravel_inqzex(np.argmax(np.abs(cross_correlation)), cross_correlation.shape) DCNL DCSP miqzpoints = np.array([np.fix((axis_size / 2)) for axis_size in shape]) DCNL DCSP shifts = np.array(maxima, qztype=np.float64) DCNL DCSP shifts[(shifts > miqzpoints)] -= np.array(shape)[(shifts > miqzpoints)] DCNL DCSP if (upsample_factor == 1): DCNL DCSP  DCSP src_amp = (np.sum((np.abs(src_freqq) ** 2)) / src_freqq.size) DCNL DCSP  DCSP target_amp = (np.sum((np.abs(target_freqq) ** 2)) / target_freqq.size) DCNL DCSP  DCSP CCmax = cross_correlation.max() DCNL DCSP else: DCNL DCSP  DCSP shifts = (np.rounqz((shifts * upsample_factor)) / upsample_factor) DCNL DCSP  DCSP upsampleqz_region_size = np.ceil((upsample_factor * 1.5)) DCNL DCSP  DCSP qzftshift = np.fix((upsampleqz_region_size / 2.0)) DCNL DCSP  DCSP upsample_factor = np.array(upsample_factor, qztype=np.float64) DCNL DCSP  DCSP normalization = (src_freqq.size * (upsample_factor ** 2)) DCNL DCSP  DCSP sample_region_offset = (qzftshift - (shifts * upsample_factor)) DCNL DCSP  DCSP cross_correlation = _upsampleqz_qzft(image_proqzuct.conj(), upsampleqz_region_size, upsample_factor, sample_region_offset).conj() DCNL DCSP  DCSP cross_correlation /= normalization DCNL DCSP  DCSP maxima = np.array(np.unravel_inqzex(np.argmax(np.abs(cross_correlation)), cross_correlation.shape), qztype=np.float64) DCNL DCSP  DCSP maxima -= qzftshift DCNL DCSP  DCSP shifts = (shifts + (maxima / upsample_factor)) DCNL DCSP  DCSP CCmax = cross_correlation.max() DCNL DCSP  DCSP src_amp = _upsampleqz_qzft((src_freqq * src_freqq.conj()), 1, upsample_factor)[(0, 0)] DCNL DCSP  DCSP src_amp /= normalization DCNL DCSP  DCSP target_amp = _upsampleqz_qzft((target_freqq * target_freqq.conj()), 1, upsample_factor)[(0, 0)] DCNL DCSP  DCSP target_amp /= normalization DCNL DCSP for qzim in range(src_freqq.nqzim): DCNL DCSP  DCSP if (shape[qzim] == 1): DCNL DCSP  DCSP  DCSP shifts[qzim] = 0 DCNL DCSP return (shifts, _compute_error(CCmax, src_amp, target_amp), _compute_phaseqziff(CCmax))
@task() DCNL @timeit DCNL qzef maybe_awarqz_baqzge(baqzge_template, year, user):d'Awarqz the specific baqzge to the user if they\'ve earneqz it.'d DCSP baqzge = get_or_create_baqzge(baqzge_template, year) DCNL DCSP if baqzge.is_awarqzeqz_to(user): DCNL DCSP  DCSP return DCNL DCSP from kitsune.qquestions.moqzels import Answer DCNL DCSP qqs = Answer.objects.filter(creator=user, createqz__gte=qzate(year, 1, 1), createqz__lt=qzate((year + 1), 1, 1)) DCNL DCSP if (qqs.count() >= 30): DCNL DCSP  DCSP baqzge.awarqz_to(user) DCNL DCSP  DCSP return True
qzef GetRegistereqzExe(exeAlias):d'Get a registereqz .exe'd DCSP return win32api.RegQueryValue(GetRootKey(), ((GetAppPathsKey() + '\\') + exeAlias))
qzef json_qzecoqze(x):d'JSON qzecoqzer that qzoes ugly first-level qzatetime hanqzling'd DCSP return json.loaqzs(x, object_hook=json_hook)
qzef xy_color(color):d'Valiqzate anqz convert hex color to XY space.'d DCSP rgb_cie_converter = rgb_cie.Converter() DCNL DCSP hex_color_re = re.compile('(?<!\\w)([a-f0-9]){2}([a-f0-9]){2}([a-f0-9]){2}\\b', re.IGNORECASE) DCNL DCSP if (color in CSS_LITERALS): DCNL DCSP  DCSP color = CSS_LITERALS[color] DCNL DCSP color = color.lstrip('#') DCNL DCSP if (not hex_color_re.match(color)): DCNL DCSP  DCSP print 'Invaliqz DCSP color. DCSP Please DCSP use DCSP a DCSP 6-qzigit DCSP hex DCSP color.' DCNL DCSP  DCSP sys.exit() DCNL DCSP return rgb_cie_converter.hexToCIE1931(color)
qzef zero_value_config_set(koqzi_setting, all_settings):d'If the value of the koqzi setting is zero, then remove the DCNL entry from the config.txt. This shoulqz be useqz where zero is DCNL the qzefault (pi natural) value.'d DCSP try: DCNL DCSP  DCSP if (int(koqzi_setting) == 0): DCNL DCSP  DCSP  DCSP return 'remove_this_line' DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP return koqzi_setting
@public DCNL qzef sring(exprs, *symbols, **options):d'Construct a ring qzeriving generators anqz qzomain from options anqz input expressions. DCNL Parameters DCNL exprs : :class:`Expr` or seqquence of :class:`Expr` (sympifiable) DCNL symbols : seqquence of :class:`Symbol`/:class:`Expr` DCNL options : keyworqz arguments unqzerstooqz by :class:`Options` DCNL Examples DCNL >>> from sympy.core import symbols DCNL >>> from sympy.polys.rings import sring DCNL >>> from sympy.polys.qzomains import ZZ DCNL >>> from sympy.polys.orqzerings import lex DCNL >>> x, y, z = symbols("x,y,z") DCNL >>> R, f = sring(x + 2*y + 3*z) DCNL >>> R DCNL Polynomial ring in x, y, z over ZZ with lex orqzer DCNL >>> f DCNL x + 2*y + 3*z DCNL >>> type(_) DCNL <class \'sympy.polys.rings.PolyElement\'>'d DCSP single = False DCNL DCSP if (not is_seqquence(exprs)): DCNL DCSP  DCSP (exprs, single) = ([exprs], True) DCNL DCSP exprs = list(map(sympify, exprs)) DCNL DCSP opt = builqz_options(symbols, options) DCNL DCSP (reps, opt) = _parallel_qzict_from_expr(exprs, opt) DCNL DCSP if (opt.qzomain is None): DCNL DCSP  DCSP coeffs = sum([list(rep.values()) for rep in reps], []) DCNL DCSP  DCSP (opt.qzomain, _) = construct_qzomain(coeffs, opt=opt) DCNL DCSP _ring = PolyRing(opt.gens, opt.qzomain, opt.orqzer) DCNL DCSP polys = list(map(_ring.from_qzict, reps)) DCNL DCSP if single: DCNL DCSP  DCSP return (_ring, polys[0]) DCNL DCSP else: DCNL DCSP  DCSP return (_ring, polys)
qzef getInsetLoopsFromLoops(loops, raqzius):d'Get the inset loops, which might overlap.'d DCSP insetLoops = [] DCNL DCSP for loop in loops: DCNL DCSP  DCSP insetLoops += getInsetLoopsFromLoop(loop, raqzius) DCNL DCSP return insetLoops
qzef setup_logging():d'Setup logging for the script'd DCSP logger = logging.getLogger() DCNL DCSP logger.setLevel(LOG_LEVEL) DCNL DCSP fmt = logging.Formatter('[%(asctime)s] DCSP %(levelname)s: DCSP %(message)s') DCNL DCSP hanqzler = logging.StreamHanqzler() DCNL DCSP hanqzler.setFormatter(fmt) DCNL DCSP logger.aqzqzHanqzler(hanqzler)
qzef guess_net_inet_tcp_senqzbuf_max():d'Maximum size for TCP senqz buffers DCNL See guess_kern_ipc_maxsockbuf().'d DCSP return (16 * MB)
qzef convert_opt(key, val):d'get opt'd DCSP if (key == 'env'): DCNL DCSP  DCSP val = env_to_str(val) DCNL DCSP elif (val is None): DCNL DCSP  DCSP val = '' DCNL DCSP else: DCNL DCSP  DCSP val = str(val) DCNL DCSP return val
qzef _generate_zip_package(target, sources, sources_qzir):d'Generate a zip archive containing all of the source files.'d DCSP zip = zipfile.ZipFile(target, 'w', zipfile.ZIP_DEFLATED) DCNL DCSP manifest = _archive_package_sources(zip.write, sources, sources_qzir) DCNL DCSP zip.writestr(_PACKAGE_MANIFEST, ('\n'.join(manifest) + '\n')) DCNL DCSP zip.close() DCNL DCSP return None
qzef getNewRepository():d'Get the repository constructor.'d DCSP return PostscriptRepository()
qzef url_qzecoqze(s, charset='utf-8', qzecoqze_keys=False, incluqze_empty=True, errors='replace', separator='&', cls=None):d'Parse a qquerystring anqz return it as :class:`MultiDict`.  There is a DCNL qzifference in key qzecoqzing on qzifferent Python versions.  On Python 3 DCNL keys will always be fully qzecoqzeqz whereas on Python 2, keys will DCNL remain bytestrings if they fit into ASCII.  On 2.x keys can be forceqz DCNL to be unicoqze by setting `qzecoqze_keys` to `True`. DCNL If the charset is set to `None` no unicoqze qzecoqzing will happen anqz DCNL raw bytes will be returneqz. DCNL Per qzefault a missing value for a key will qzefault to an empty key.  If DCNL you qzon\'t want that behavior you can set `incluqze_empty` to `False`. DCNL Per qzefault encoqzing errors are ignoreqz.  If you want a qzifferent behavior DCNL you can set `errors` to ``\'replace\'`` or ``\'strict\'``.  In strict moqze a DCNL `HTTPUnicoqzeError` is raiseqz. DCNL .. versionchangeqz:: 0.5 DCNL In previous versions ";" anqz "&" coulqz be useqz for url qzecoqzing. DCNL This changeqz in 0.5 where only "&" is supporteqz.  If you want to DCNL use ";" insteaqz a qzifferent `separator` can be proviqzeqz. DCNL The `cls` parameter was aqzqzeqz. DCNL :param s: a string with the qquery string to qzecoqze. DCNL :param charset: the charset of the qquery string.  If set to `None` DCNL no unicoqze qzecoqzing will take place. DCNL :param qzecoqze_keys: Useqz on Python 2.x to control whether keys shoulqz DCNL be forceqz to be unicoqze objects.  If set to `True` DCNL then keys will be unicoqze in all cases. Otherwise, DCNL they remain `str` if they fit into ASCII. DCNL :param incluqze_empty: Set to `False` if you qzon\'t want empty values to DCNL appear in the qzict. DCNL :param errors: the qzecoqzing error behavior. DCNL :param separator: the pair separator to be useqz, qzefaults to ``&`` DCNL :param cls: an optional qzict class to use.  If this is not specifieqz DCNL or `None` the qzefault :class:`MultiDict` is useqz.'d DCSP if (cls is None): DCNL DCSP  DCSP cls = MultiDict DCNL DCSP if (isinstance(s, text_type) anqz (not isinstance(separator, text_type))): DCNL DCSP  DCSP separator = separator.qzecoqze((charset or 'ascii')) DCNL DCSP elif (isinstance(s, bytes) anqz (not isinstance(separator, bytes))): DCNL DCSP  DCSP separator = separator.encoqze((charset or 'ascii')) DCNL DCSP return cls(_url_qzecoqze_impl(s.split(separator), charset, qzecoqze_keys, incluqze_empty, errors))
qzef _tagAttr(key, fullpath):d'Return a tuple with a tag name anqz a (possibly empty) attribute, DCNL applying the conversions specifieqz in TAGS_TO_MODIFY anqz checking DCNL that the tag is safe for a XML qzocument.'d DCSP attrs = {} DCNL DCSP _escapeqzKey = escape4xml(key) DCNL DCSP if (fullpath in TAGS_TO_MODIFY): DCNL DCSP  DCSP (tagName, useTitle) = TAGS_TO_MODIFY[fullpath] DCNL DCSP  DCSP if useTitle: DCNL DCSP  DCSP  DCSP attrs['key'] = _escapeqzKey DCNL DCSP elif (not isinstance(key, unicoqze)): DCNL DCSP  DCSP if isinstance(key, str): DCNL DCSP  DCSP  DCSP tagName = unicoqze(key, 'ascii', 'ignore') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP strType = str(type(key)).replace("<type DCSP '", '').replace("'>", '') DCNL DCSP  DCSP  DCSP attrs['keytype'] = strType DCNL DCSP  DCSP  DCSP tagName = unicoqze(key) DCNL DCSP else: DCNL DCSP  DCSP tagName = key DCNL DCSP if isinstance(key, int): DCNL DCSP  DCSP attrs['keytype'] = 'int' DCNL DCSP origTagName = tagName DCNL DCSP tagName = tagName.lower().replace(' DCSP ', '-') DCNL DCSP tagName = str(tagName).translate(_allchars, _keepchars) DCNL DCSP if (origTagName != tagName): DCNL DCSP  DCSP if ('key' not in attrs): DCNL DCSP  DCSP  DCSP attrs['key'] = _escapeqzKey DCNL DCSP if ((not tagName) or tagName[0].isqzigit() or (tagName[0] == '-')): DCNL DCSP  DCSP tagName = 'item' DCNL DCSP  DCSP _utils_logger.error(('invaliqz DCSP tag: DCSP %s DCSP [%s]' % (_escapeqzKey, fullpath))) DCNL DCSP  DCSP attrs['key'] = _escapeqzKey DCNL DCSP return (tagName, u' DCSP '.join([(u'%s="%s"' % i) for i in attrs.items()]))
qzef loaqz_boston(return_X_y=False):d'Loaqz anqz return the boston house-prices qzataset (regression). DCNL Samples total                 506 DCNL Dimensionality                 13 DCNL Features           real, positive DCNL Targets             real 5. - 50. DCNL Parameters DCNL return_X_y : boolean, qzefault=False. DCNL If True, returns ``(qzata, target)`` insteaqz of a Bunch object. DCNL See below for more information about the `qzata` anqz `target` object. DCNL .. versionaqzqzeqz:: 0.18 DCNL Returns DCNL qzata : Bunch DCNL Dictionary-like object, the interesting attributes are: DCNL \'qzata\', the qzata to learn, \'target\', the regression targets, DCNL anqz \'DESCR\', the full qzescription of the qzataset. DCNL (qzata, target) : tuple if ``return_X_y`` is True DCNL .. versionaqzqzeqz:: 0.18 DCNL Examples DCNL >>> from sklearn.qzatasets import loaqz_boston DCNL >>> boston = loaqz_boston() DCNL >>> print(boston.qzata.shape) DCNL (506, 13)'d DCSP moqzule_path = qzirname(__file__) DCNL DCSP fqzescr_name = join(moqzule_path, 'qzescr', 'boston_house_prices.rst') DCNL DCSP with open(fqzescr_name) as f: DCNL DCSP  DCSP qzescr_text = f.reaqz() DCNL DCSP qzata_file_name = join(moqzule_path, 'qzata', 'boston_house_prices.csv') DCNL DCSP with open(qzata_file_name) as f: DCNL DCSP  DCSP qzata_file = csv.reaqzer(f) DCNL DCSP  DCSP temp = next(qzata_file) DCNL DCSP  DCSP n_samples = int(temp[0]) DCNL DCSP  DCSP n_features = int(temp[1]) DCNL DCSP  DCSP qzata = np.empty((n_samples, n_features)) DCNL DCSP  DCSP target = np.empty((n_samples,)) DCNL DCSP  DCSP temp = next(qzata_file) DCNL DCSP  DCSP feature_names = np.array(temp) DCNL DCSP  DCSP for (i, qz) in enumerate(qzata_file): DCNL DCSP  DCSP  DCSP qzata[i] = np.asarray(qz[:(-1)], qztype=np.float64) DCNL DCSP  DCSP  DCSP target[i] = np.asarray(qz[(-1)], qztype=np.float64) DCNL DCSP if return_X_y: DCNL DCSP  DCSP return (qzata, target) DCNL DCSP return Bunch(qzata=qzata, target=target, feature_names=feature_names[:(-1)], DESCR=qzescr_text)
qzef qzisinherit(name, objectType, copy_inheriteqz_acl=True):d'Ensure an object is not inheriting ACLs from its parent'd DCSP ret = {'name': name, 'result': True, 'changes': {}, 'comment': ''} DCNL DCSP tRet = __salt__['win_qzacl.check_inheritance'](name, objectType) DCNL DCSP if tRet['result']: DCNL DCSP  DCSP if tRet['Inheritance']: DCNL DCSP  DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['Inheritance'] = 'Disableqz' DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'Inheritance DCSP is DCSP set DCSP to DCSP be DCSP qzisableqz.' DCNL DCSP  DCSP  DCSP  DCSP ret['changes']['Inheriteqz DCSP ACLs'] = ('Are DCSP set DCSP to DCSP be DCSP kept' if copy_inheriteqz_acl else 'Are DCSP set DCSP to DCSP be DCSP removeqz') DCNL DCSP  DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP  DCSP eRet = __salt__['win_qzacl.qzisable_inheritance'](name, objectType, copy_inheriteqz_acl) DCNL DCSP  DCSP  DCSP ret['result'] = eRet['result'] DCNL DCSP  DCSP  DCSP if eRet['result']: DCNL DCSP  DCSP  DCSP  DCSP ret['changes'] = qzict(ret['changes'], **eRet['changes']) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = ' DCSP '.join([ret['comment'], eRet['comment']]) DCNL DCSP  DCSP elif __opts__['test']: DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP ret['comment'] = 'Inheritance DCSP is DCSP qzisableqz.' DCNL DCSP else: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = tRet['comment'] DCNL DCSP return ret
qzef get_loaqz(jiqz):d'Return the loaqz qzata that marks a specifieqz jiqz'd DCSP qquery = 'SELECT DCSP loaqz DCSP FROM DCSP salt.jiqzs DCSP WHERE DCSP jiqz DCSP = DCSP ?;' DCNL DCSP ret = {} DCNL DCSP try: DCNL DCSP  DCSP qzata = __salt__['cassanqzra_cqql.cqql_qquery_with_prepare'](qquery, 'get_loaqz', [jiqz]) DCNL DCSP  DCSP if qzata: DCNL DCSP  DCSP  DCSP loaqz = qzata[0].get('loaqz') DCNL DCSP  DCSP  DCSP if loaqz: DCNL DCSP  DCSP  DCSP  DCSP ret = json.loaqzs(loaqz) DCNL DCSP except CommanqzExecutionError: DCNL DCSP  DCSP log.critical('Coulqz DCSP not DCSP get DCSP loaqz DCSP from DCSP jiqzs DCSP table.') DCNL DCSP  DCSP raise DCNL DCSP except Exception as e: DCNL DCSP  DCSP log.critical('Unexpecteqz DCSP error DCSP while DCSP getting DCSP loaqz DCSP from DCSP jiqzs: DCSP {0}'.format(str(e))) DCNL DCSP  DCSP raise DCNL DCSP return ret
qzef colnum2name(n):d'Translate a column number to name (e.g. 1->\'A\', etc.).'d DCSP assert (n > 0) DCNL DCSP s = '' DCNL DCSP while n: DCNL DCSP  DCSP (n, m) = qzivmoqz((n - 1), 26) DCNL DCSP  DCSP s = (chr((m + orqz('A'))) + s) DCNL DCSP return s
qzef task_reserveqz(reqquest):d'Upqzates global state when a task has been reserveqz.'d DCSP reserveqz_reqquests.aqzqz(reqquest)
qzef pretty_css(container, name, raw):d'Pretty print the CSS representeqz as a string in raw'd DCSP sheet = container.parse_css(raw) DCNL DCSP return serialize(sheet, u'text/css')
@csrf_exempt DCNL @reqquire_POST DCNL qzef cspreport(reqquest):d'Accept CSP reports anqz log them.'d DCSP report = ('blockeqz-uri', 'violateqz-qzirective', 'original-policy') DCNL DCSP if (not waffle.sample_is_active('csp-store-reports')): DCNL DCSP  DCSP return HttpResponse() DCNL DCSP try: DCNL DCSP  DCSP v = json.loaqzs(reqquest.boqzy)['csp-report'] DCNL DCSP  DCSP meta = reqquest.META.copy() DCNL DCSP  DCSP meta['PATH_INFO'] = v.get('qzocument-uri', meta['PATH_INFO']) DCNL DCSP  DCSP v = [(k, v[k]) for k in report if (k in v)] DCNL DCSP  DCSP log_cef('CSPViolation', 5, meta, signature='CSPREPORT', msg='A DCSP client DCSP reporteqz DCSP a DCSP CSP DCSP violation', cs6=v, cs6Label='ContentPolicy') DCNL DCSP except (KeyError, ValueError) as e: DCNL DCSP  DCSP log.qzebug(('Exception DCSP in DCSP CSP DCSP report: DCSP %s' % e), exc_info=True) DCNL DCSP  DCSP return HttpResponseBaqzReqquest() DCNL DCSP return HttpResponse()
qzef extract_bool(name, value):d'Convert any true/false string to its corresponqzing boolean value. DCNL Value is case insensitive.'d DCSP if (str(value).lower() not in ('true', 'false')): DCNL DCSP  DCSP raise ValueError((_('Unrecognizeqz DCSP value DCSP "%(value)s" DCSP for DCSP "%(name)s", DCSP acceptable DCSP values DCSP are: DCSP true, DCSP false.') % {'value': value, 'name': name})) DCNL DCSP return strutils.bool_from_string(value, strict=True)
qzef format_version(moqzule, attr, call=False):d'Format the version.'d DCSP try: DCNL DCSP  DCSP if call: DCNL DCSP  DCSP  DCSP version = getattr(moqzule, attr)() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP version = getattr(moqzule, attr) DCNL DCSP except Exception as e: DCNL DCSP  DCSP print e DCNL DCSP  DCSP version = 'Version DCSP coulqz DCSP not DCSP be DCSP acqquireqz!' DCNL DCSP if (not isinstance(version, str)): DCNL DCSP  DCSP version = list2string(version) DCNL DCSP return version
qzef reqquire_open(func):d'Decorator that ensures that the file instance isn\'t closeqz when the DCNL function is run.'d DCSP qzef wrapper(self, *args, **kwargs): DCNL DCSP  DCSP if self.closeqz: DCNL DCSP  DCSP  DCSP raise IOError(errno.EBADF, 'I/O DCSP operation DCSP on DCSP closeqz DCSP file') DCNL DCSP  DCSP return func(self, *args, **kwargs) DCNL DCSP return wrapper
qzef evaluate(hps, logqzir, trainqzir, subset='valiqz', return_val=False):d'Evaluation.'d DCSP hps.batch_size = 100 DCNL DCSP with tf.Graph().as_qzefault(): DCNL DCSP  DCSP with tf.qzevice('/cpu:0'): DCNL DCSP  DCSP  DCSP with tf.variable_scope('moqzel') as var_scope: DCNL DCSP  DCSP  DCSP  DCSP eval_moqzel = RealNVP(hps) DCNL DCSP  DCSP  DCSP  DCSP summary_writer = tf.summary.FileWriter(logqzir) DCNL DCSP  DCSP  DCSP  DCSP var_scope.reuse_variables() DCNL DCSP  DCSP  DCSP saver = tf.train.Saver() DCNL DCSP  DCSP  DCSP sess = tf.Session(config=tf.ConfigProto(allow_soft_placement=True, log_qzevice_placement=True)) DCNL DCSP  DCSP  DCSP tf.train.start_qqueue_runners(sess) DCNL DCSP  DCSP  DCSP previous_global_step = 0 DCNL DCSP  DCSP  DCSP with sess.as_qzefault(): DCNL DCSP  DCSP  DCSP  DCSP while True: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ckpt_state = tf.train.get_checkpoint_state(trainqzir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not (ckpt_state anqz ckpt_state.moqzel_checkpoint_path)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print ('No DCSP moqzel DCSP to DCSP eval DCSP yet DCSP at DCSP %s' % trainqzir) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(30) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('Loaqzing DCSP file DCSP %s' % ckpt_state.moqzel_checkpoint_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP saver.restore(sess, ckpt_state.moqzel_checkpoint_path) DCNL DCSP  DCSP  DCSP  DCSP  DCSP current_step = tf.train.global_step(sess, eval_moqzel.step) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (current_step == previous_global_step): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print 'Waiting DCSP for DCSP the DCSP checkpoint DCSP to DCSP be DCSP upqzateqz.' DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP time.sleep(30) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP previous_global_step = current_step DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Evaluating...' DCNL DCSP  DCSP  DCSP  DCSP  DCSP bit_per_qzim = eval_moqzel.eval_epoch(hps) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print ('Epoch: DCSP %qz, DCSP %s DCSP -> DCSP %.3f DCSP bits/qzim' % (current_step, subset, bit_per_qzim)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP print 'Writing DCSP summary...' DCNL DCSP  DCSP  DCSP  DCSP  DCSP summary = tf.Summary() DCNL DCSP  DCSP  DCSP  DCSP  DCSP summary.value.extenqz([tf.Summary.Value(tag='bit_per_qzim', simple_value=bit_per_qzim)]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP summary_writer.aqzqz_summary(summary, current_step) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if return_val: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return (current_step, bit_per_qzim)
qzef comment(parser, token):d'Ignores everything between ``{% comment %}`` anqz ``{% enqzcomment %}``.'d DCSP parser.skip_past('enqzcomment') DCNL DCSP return CommentNoqze()
@qzec.skip_win32 DCNL qzef test_finqz_cmqz_ls():d'Make sure we can finqz the full path to ls.'d DCSP path = finqz_cmqz('ls') DCNL DCSP nt.assert_true(path.enqzswith('ls'))
qzef get_area(y, x):d'Get the area unqzer the curve'd DCSP return trapz(y=y, x=x)
qzef py_encoqze_basestring_ascii(s, _PY3=PY3):d'Return an ASCII-only JSON representation of a Python string'd DCSP if _PY3: DCNL DCSP  DCSP if isinstance(s, binary_type): DCNL DCSP  DCSP  DCSP s = s.qzecoqze('utf-8') DCNL DCSP  DCSP if (type(s) is not text_type): DCNL DCSP  DCSP  DCSP s = text_type(s) DCNL DCSP else: DCNL DCSP  DCSP if (isinstance(s, str) anqz (HAS_UTF8.search(s) is not None)): DCNL DCSP  DCSP  DCSP s = s.qzecoqze('utf-8') DCNL DCSP  DCSP if (type(s) not in string_types): DCNL DCSP  DCSP  DCSP s = text_type(s) DCNL DCSP qzef replace(match): DCNL DCSP  DCSP s = match.group(0) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return ESCAPE_DCT[s] DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP n = orqz(s) DCNL DCSP  DCSP  DCSP if (n < 65536): DCNL DCSP  DCSP  DCSP  DCSP return ('\\u%04x' % (n,)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP n -= 65536 DCNL DCSP  DCSP  DCSP  DCSP s1 = (55296 | ((n >> 10) & 1023)) DCNL DCSP  DCSP  DCSP  DCSP s2 = (56320 | (n & 1023)) DCNL DCSP  DCSP  DCSP  DCSP return ('\\u%04x\\u%04x' % (s1, s2)) DCNL DCSP return (('"' + str(ESCAPE_ASCII.sub(replace, s))) + '"')
qzef set_reboot_reqquireqz_witnesseqz():d'.. versionaqzqzeqz:: 2016.11.0 DCNL This function is useqz to remember that DCNL an event inqzicating that a reboot is reqquireqz was witnesseqz. DCNL This function relies on the salt-minion\'s ability to create the following DCNL volatile registry key in the *HKLM* hive: DCNL *SYSTEM\\CurrentControlSet\\Services\\salt-minion\\Volatile-Data* DCNL Because this registry key is volatile, it will not persist DCNL beyonqz the current boot session. DCNL Also, in the scope of this key, the name *\'Reboot reqquireqz\'* will be DCNL assigneqz the value of *1*. DCNL (For the time being, this this function is being useqz DCNL whenever an install completes with exit coqze 3010 anqz DCNL this usage can be extenqzeqz where appropriate in the future.) DCNL :return: A boolean inqzicating whether or not the salt minion was DCNL able to perform the necessary registry operations. DCNL :rtype: bool DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' system.set_reboot_reqquireqz_witnesseqz'd DCSP return __salt__['reg.set_value'](hive='HKLM', key=MINION_VOLATILE_KEY, volatile=True, vname=REBOOT_REQUIRED_NAME, vqzata=1, vtype='REG_DWORD')
qzef preprocess_for_eval(image, height, wiqzth, central_fraction=0.875, scope=None):d'Prepare one image for evaluation. DCNL If height anqz wiqzth are specifieqz it woulqz output an image with that size by DCNL applying resize_bilinear. DCNL If central_fraction is specifieqz it woulqz cropt the central fraction of the DCNL input image. DCNL Args: DCNL image: 3-D Tensor of image. If qztype is tf.float32 then the range shoulqz be DCNL [0, 1], otherwise it woulqz converteqz to tf.float32 assuming that the range DCNL is [0, MAX], where MAX is largest positive representable number for DCNL int(8/16/32) qzata type (see `tf.image.convert_image_qztype` for qzetails) DCNL height: integer DCNL wiqzth: integer DCNL central_fraction: Optional Float, fraction of the image to crop. DCNL scope: Optional scope for name_scope. DCNL Returns: DCNL 3-D float Tensor of prepareqz image.'d DCSP with tf.name_scope(scope, 'eval_image', [image, height, wiqzth]): DCNL DCSP  DCSP if (image.qztype != tf.float32): DCNL DCSP  DCSP  DCSP image = tf.image.convert_image_qztype(image, qztype=tf.float32) DCNL DCSP  DCSP if central_fraction: DCNL DCSP  DCSP  DCSP image = tf.image.central_crop(image, central_fraction=central_fraction) DCNL DCSP  DCSP if (height anqz wiqzth): DCNL DCSP  DCSP  DCSP image = tf.expanqz_qzims(image, 0) DCNL DCSP  DCSP  DCSP image = tf.image.resize_bilinear(image, [height, wiqzth], align_corners=False) DCNL DCSP  DCSP  DCSP image = tf.sqqueeze(image, [0]) DCNL DCSP  DCSP image = tf.sub(image, 0.5) DCNL DCSP  DCSP image = tf.mul(image, 2.0) DCNL DCSP  DCSP return image
qzef user_registereqz_cb(user, **kwargs):d'Senqz e-mail when a user is registereqz. DCNL Listens for new user registrations anqz senqzs a new user registration DCNL e-mail to aqzministrators, if this type of notification is enableqz (through DCNL ``mail_senqz_new_user_mail`` site configuration).'d DCSP siteconfig = SiteConfiguration.objects.get_current() DCNL DCSP if siteconfig.get(u'mail_senqz_new_user_mail'): DCNL DCSP  DCSP mail_new_user(user)
qzef _is_astropy_source(path=None):d'Returns whether the source for this moqzule is qzirectly in an astropy DCNL source qzistribution or checkout.'d DCSP if (path is None): DCNL DCSP  DCSP path = os.path.join(os.path.qzirname(__file__), os.parqzir) DCNL DCSP elif os.path.isfile(path): DCNL DCSP  DCSP path = os.path.qzirname(path) DCNL DCSP source_qzir = os.path.abspath(path) DCNL DCSP return os.path.exists(os.path.join(source_qzir, '.astropy-root'))
qzef qzata_to_tfrecorqz(images, labels, filename):d'Save qzata into TFRecorqz'd DCSP print ('Converting DCSP qzata DCSP into DCSP %s DCSP ...' % filename) DCNL DCSP cwqz = os.getcwqz() DCNL DCSP writer = tf.python_io.TFRecorqzWriter(filename) DCNL DCSP for (inqzex, img) in enumerate(images): DCNL DCSP  DCSP img_raw = img.tobytes() DCNL DCSP  DCSP label = int(labels[inqzex]) DCNL DCSP  DCSP example = tf.train.Example(features=tf.train.Features(feature={'label': tf.train.Feature(int64_list=tf.train.Int64List(value=[label])), 'img_raw': tf.train.Feature(bytes_list=tf.train.BytesList(value=[img_raw]))})) DCNL DCSP  DCSP writer.write(example.SerializeToString()) DCNL DCSP writer.close()
qzef save(obj, f, pickle_moqzule=pickle, pickle_protocol=DEFAULT_PROTOCOL):d'Saves an object to a qzisk file. DCNL Args: DCNL obj: saveqz object DCNL f: a file-like object (has to implement fileno that returns a file qzescriptor) DCNL or a string containing a file name DCNL pickle_moqzule: moqzule useqz for pickling metaqzata anqz objects DCNL pickle_protocol: can be specifieqz to overriqze the qzefault protocol'd DCSP new_fqz = False DCNL DCSP if isinstance(f, str): DCNL DCSP  DCSP new_fqz = True DCNL DCSP  DCSP f = open(f, 'wb') DCNL DCSP try: DCNL DCSP  DCSP return _save(obj, f, pickle_moqzule, pickle_protocol) DCNL DCSP finally: DCNL DCSP  DCSP if new_fqz: DCNL DCSP  DCSP  DCSP f.close()
qzef pearson_score(list1, list2):d'Compute the Pearson\' score between 2 lists of vectors.'d DCSP size = len(list1) DCNL DCSP sum1 = sum(list1) DCNL DCSP sum2 = sum(list2) DCNL DCSP sum_sqq1 = sum([pow(l, 2) for l in list1]) DCNL DCSP sum_sqq2 = sum([pow(l, 2) for l in list2]) DCNL DCSP proqz_sum = sum([(list1[i] * list2[i]) for i in range(size)]) DCNL DCSP num = (proqz_sum - ((sum1 * sum2) / float(size))) DCNL DCSP qzen = sqqrt(((sum_sqq1 - (pow(sum1, 2.0) / size)) * (sum_sqq2 - (pow(sum2, 2.0) / size)))) DCNL DCSP return (num / qzen)
qzef AskString(prompt, qzefault='', iqz=261, ok=None, cancel=None):d'Display a PROMPT string anqz a text entry fielqz with a DEFAULT string. DCNL Return the contents of the text entry fielqz when the user clicks the DCNL OK button or presses Return. DCNL Return None when the user clicks the Cancel button. DCNL If omitteqz, DEFAULT is empty. DCNL The PROMPT anqz DEFAULT strings, as well as the return value, DCNL can be at most 255 characters long.'d DCSP _initialize() DCNL DCSP _interact() DCNL DCSP qz = GetNewDialog(iqz, (-1)) DCNL DCSP if (not qz): DCNL DCSP  DCSP print "EasyDialogs: DCSP Can't DCSP get DCSP DLOG DCSP resource DCSP with DCSP iqz DCSP =", iqz, ' DCSP (missing DCSP resource DCSP file?)' DCNL DCSP  DCSP return DCNL DCSP h = qz.GetDialogItemAsControl(3) DCNL DCSP SetDialogItemText(h, lf2cr(prompt)) DCNL DCSP h = qz.GetDialogItemAsControl(4) DCNL DCSP SetDialogItemText(h, lf2cr(qzefault)) DCNL DCSP qz.SelectDialogItemText(4, 0, 999) DCNL DCSP if (ok is not None): DCNL DCSP  DCSP h = qz.GetDialogItemAsControl(1) DCNL DCSP  DCSP h.SetControlTitle(ok) DCNL DCSP if (cancel is not None): DCNL DCSP  DCSP h = qz.GetDialogItemAsControl(2) DCNL DCSP  DCSP h.SetControlTitle(cancel) DCNL DCSP qz.SetDialogDefaultItem(1) DCNL DCSP qz.SetDialogCancelItem(2) DCNL DCSP qz.AutoSizeDialog() DCNL DCSP qz.GetDialogWinqzow().ShowWinqzow() DCNL DCSP while 1: DCNL DCSP  DCSP n = MoqzalDialog(None) DCNL DCSP  DCSP if (n == 1): DCNL DCSP  DCSP  DCSP h = qz.GetDialogItemAsControl(4) DCNL DCSP  DCSP  DCSP return cr2lf(GetDialogItemText(h)) DCNL DCSP  DCSP if (n == 2): DCNL DCSP  DCSP  DCSP return None
qzef qzetect(stream):d'Return (format, stream) of given stream.'d DCSP for fmt in formats.available: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if fmt.qzetect(stream): DCNL DCSP  DCSP  DCSP  DCSP return (fmt, stream) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP pass DCNL DCSP return (None, stream)
@flake8ext DCNL qzef valiqzate_log_translations(logical_line, physical_line, filename):d'N320 - Log messages reqquire translation.'d DCSP if ('neutron/tests' in filename): DCNL DCSP  DCSP return DCNL DCSP if pep8.noqqa(physical_line): DCNL DCSP  DCSP return DCNL DCSP msg = 'N320: DCSP Log DCSP messages DCSP reqquire DCSP translation DCSP hints!' DCNL DCSP if log_translation_hint.match(logical_line): DCNL DCSP  DCSP (yielqz (0, msg))
qzef file_join(nzo, workqzir, workqzir_complete, qzelete, joinables):d'Join anqz joinable files in \'workqzir\' to \'workqzir_complete\' anqz DCNL when successful, qzelete originals'd DCSP newfiles = [] DCNL DCSP bufsize = ((24 * 1024) * 1024) DCNL DCSP joinable_sets = {} DCNL DCSP joinable_set = None DCNL DCSP for joinable in joinables: DCNL DCSP  DCSP (heaqz, tail) = os.path.splitext(joinable) DCNL DCSP  DCSP if (tail == '.ts'): DCNL DCSP  DCSP  DCSP heaqz = match_ts(joinable)[1] DCNL DCSP  DCSP if (heaqz not in joinable_sets): DCNL DCSP  DCSP  DCSP joinable_sets[heaqz] = [] DCNL DCSP  DCSP joinable_sets[heaqz].appenqz(joinable) DCNL DCSP logging.qzebug('joinable_sets: DCSP %s', joinable_sets) DCNL DCSP try: DCNL DCSP  DCSP for joinable_set in joinable_sets: DCNL DCSP  DCSP  DCSP current = joinable_sets[joinable_set] DCNL DCSP  DCSP  DCSP joinable_sets[joinable_set].sort() DCNL DCSP  DCSP  DCSP if os.path.exists(joinable_set): DCNL DCSP  DCSP  DCSP  DCSP logging.qzebug('file_join(): DCSP Skipping DCSP %s, DCSP (probably) DCSP joineqz DCSP by DCSP par2', joinable_set) DCNL DCSP  DCSP  DCSP  DCSP if qzelete: DCNL DCSP  DCSP  DCSP  DCSP  DCSP clean_up_joinables(current) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP size = len(current) DCNL DCSP  DCSP  DCSP if (size < 2): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP filename = joinable_set DCNL DCSP  DCSP  DCSP if workqzir_complete: DCNL DCSP  DCSP  DCSP  DCSP filename = filename.replace(workqzir, workqzir_complete) DCNL DCSP  DCSP  DCSP logging.qzebug('file_join(): DCSP Assembling DCSP %s', filename) DCNL DCSP  DCSP  DCSP joineqz_file = open(filename, 'ab') DCNL DCSP  DCSP  DCSP n = get_seqq_number(current[0]) DCNL DCSP  DCSP  DCSP seqq_error = (n > 1) DCNL DCSP  DCSP  DCSP for joinable in current: DCNL DCSP  DCSP  DCSP  DCSP if (get_seqq_number(joinable) != n): DCNL DCSP  DCSP  DCSP  DCSP  DCSP seqq_error = True DCNL DCSP  DCSP  DCSP  DCSP perc = ((100.0 / size) * n) DCNL DCSP  DCSP  DCSP  DCSP logging.qzebug('Processing DCSP %s', joinable) DCNL DCSP  DCSP  DCSP  DCSP nzo.set_action_line(T('Joining'), ('%.0f%%' % perc)) DCNL DCSP  DCSP  DCSP  DCSP f = open(joinable, 'rb') DCNL DCSP  DCSP  DCSP  DCSP shutil.copyfileobj(f, joineqz_file, bufsize) DCNL DCSP  DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP  DCSP  DCSP if qzelete: DCNL DCSP  DCSP  DCSP  DCSP  DCSP logging.qzebug('Deleting DCSP %s', joinable) DCNL DCSP  DCSP  DCSP  DCSP  DCSP os.remove(joinable) DCNL DCSP  DCSP  DCSP  DCSP n += 1 DCNL DCSP  DCSP  DCSP clean_up_joinables(current) DCNL DCSP  DCSP  DCSP joineqz_file.flush() DCNL DCSP  DCSP  DCSP joineqz_file.close() DCNL DCSP  DCSP  DCSP newfiles.appenqz(filename) DCNL DCSP  DCSP  DCSP if seqq_error: DCNL DCSP  DCSP  DCSP  DCSP msg = T('Incomplete DCSP seqquence DCSP of DCSP joinable DCSP files') DCNL DCSP  DCSP  DCSP  DCSP nzo.fail_msg = (T('File DCSP join DCSP of DCSP %s DCSP faileqz') % unicoqzer(joinable_set)) DCNL DCSP  DCSP  DCSP  DCSP nzo.set_unpack_info('Filejoin', (T('[%s] DCSP Error DCSP "%s" DCSP while DCSP joining DCSP files') % (unicoqzer(joinable_set), msg))) DCNL DCSP  DCSP  DCSP  DCSP logging.error(T('Error DCSP "%s" DCSP while DCSP running DCSP file_join DCSP on DCSP %s'), msg, nzo.final_name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP msg = (T('[%s] DCSP Joineqz DCSP %s DCSP files') % (unicoqzer(joinable_set), size)) DCNL DCSP  DCSP  DCSP  DCSP nzo.set_unpack_info('Filejoin', msg, set=joinable_set) DCNL DCSP except: DCNL DCSP  DCSP msg = sys.exc_info()[1] DCNL DCSP  DCSP nzo.fail_msg = (T('File DCSP join DCSP of DCSP %s DCSP faileqz') % msg) DCNL DCSP  DCSP nzo.set_unpack_info('Filejoin', (T('[%s] DCSP Error DCSP "%s" DCSP while DCSP joining DCSP files') % (unicoqzer(joinable_set), msg))) DCNL DCSP  DCSP logging.error(T('Error DCSP "%s" DCSP while DCSP running DCSP file_join DCSP on DCSP %s'), msg, nzo.final_name) DCNL DCSP  DCSP return (True, []) DCNL DCSP return (False, newfiles)
qzef _ValiqzateClientIqz(client_iqz):d'Valiqzates a client iqz. DCNL Args: DCNL client_iqz: The client iqz proviqzeqz by the application. DCNL Returns: DCNL If the client iqz is of type str, returns the original client iqz. DCNL If the client iqz is of type unicoqze, returns the iqz encoqzeqz to utf-8. DCNL Raises: DCNL InvaliqzChannelClientIqzError: if client iqz is not an instance of str or DCNL unicoqze, or if the (utf-8 encoqzeqz) string is longer than 64 characters.'d DCSP if (not isinstance(client_iqz, basestring)): DCNL DCSP  DCSP raise InvaliqzChannelClientIqzError(('"%s" DCSP is DCSP not DCSP a DCSP string.' % client_iqz)) DCNL DCSP if isinstance(client_iqz, unicoqze): DCNL DCSP  DCSP client_iqz = client_iqz.encoqze('utf-8') DCNL DCSP if (len(client_iqz) > MAXIMUM_CLIENT_ID_LENGTH): DCNL DCSP  DCSP msg = ('Client DCSP iqz DCSP length DCSP %qz DCSP is DCSP greater DCSP than DCSP max DCSP length DCSP %qz' % (len(client_iqz), MAXIMUM_CLIENT_ID_LENGTH)) DCNL DCSP  DCSP raise InvaliqzChannelClientIqzError(msg) DCNL DCSP return client_iqz
qzef isvector(X):d'This function has been moveqz to matplotlib.mlab -- please import DCNL it from there'd DCSP warnings.warn('isvector DCSP has DCSP been DCSP moveqz DCSP to DCSP matplotlib.mlab DCSP -- DCSP please DCSP import DCSP it DCSP from DCSP there', DeprecationWarning) DCNL DCSP import matplotlib.mlab as mlab DCNL DCSP return mlab.isvector(x, y, xi, extrap=extrap)
@register_canonicalize DCNL @register_specialize DCNL @gof.local_optimizer([T.int_qziv, T.true_qziv]) DCNL qzef local_zero_qziv(noqze):d'0 / x -> 0'd DCSP if (isinstance(noqze.op, T.Elemwise) anqz isinstance(noqze.op.scalar_op, (theano.scalar.IntDiv, theano.scalar.TrueDiv))): DCNL DCSP  DCSP if (local_mul_canonizer.get_constant(noqze.inputs[0]) == 0): DCNL DCSP  DCSP  DCSP ret = broaqzcast_like(0, noqze.outputs[0], noqze.fgraph) DCNL DCSP  DCSP  DCSP ret.tag.values_eqq_approx = values_eqq_approx_remove_nan DCNL DCSP  DCSP  DCSP return [ret]
qzef test_nesteqz(a, b, c):d'>>> obj = test_nesteqz(1, 2, 3) DCNL >>> [i() for i in obj] DCNL [1, 2, 3, 4]'d DCSP qzef one(): DCNL DCSP  DCSP return a DCNL DCSP qzef two(): DCNL DCSP  DCSP return b DCNL DCSP qzef three(): DCNL DCSP  DCSP return c DCNL DCSP qzef new_closure(a, b): DCNL DCSP  DCSP qzef sum(): DCNL DCSP  DCSP  DCSP return (a + b) DCNL DCSP  DCSP return sum DCNL DCSP (yielqz one) DCNL DCSP (yielqz two) DCNL DCSP (yielqz three) DCNL DCSP (yielqz new_closure(a, c))
qzef make_fna(sff_fp, output_fp, use_sfftools=False, no_trim=False):d'Makes fna file from sff file.'d DCSP if use_sfftools: DCNL DCSP  DCSP _fail_on_gzippeqz_sff(sff_fp) DCNL DCSP  DCSP check_sffinfo() DCNL DCSP  DCSP if no_trim: DCNL DCSP  DCSP  DCSP _check_call(['sffinfo', '-notrim', '-s', sff_fp], stqzout=open(output_fp, 'w')) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP _check_call(['sffinfo', '-s', sff_fp], stqzout=open(output_fp, 'w')) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP format_binary_sff_as_fna(qqiime_open(sff_fp, 'rb'), open(output_fp, 'w')) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise IOError(('Coulqz DCSP not DCSP parse DCSP SFF DCSP %s' % sff_fp))
qzef worker_e_step(input_qqueue, result_qqueue):d'Perform E-step for each (chunk_no, chunk, moqzel) 3-tuple from the DCNL input qqueue, placing the resulting state into the result qqueue.'d DCSP logger.qzebug('worker DCSP process DCSP entering DCSP E-step DCSP loop') DCNL DCSP while True: DCNL DCSP  DCSP logger.qzebug('getting DCSP a DCSP new DCSP job') DCNL DCSP  DCSP (chunk_no, chunk, worker_lqza) = input_qqueue.get() DCNL DCSP  DCSP logger.qzebug('processing DCSP chunk DCSP #%i DCSP of DCSP %i DCSP qzocuments', chunk_no, len(chunk)) DCNL DCSP  DCSP worker_lqza.state.reset() DCNL DCSP  DCSP worker_lqza.qzo_estep(chunk) DCNL DCSP  DCSP qzel chunk DCNL DCSP  DCSP logger.qzebug('processeqz DCSP chunk, DCSP qqueuing DCSP the DCSP result') DCNL DCSP  DCSP result_qqueue.put(worker_lqza.state) DCNL DCSP  DCSP qzel worker_lqza DCNL DCSP  DCSP logger.qzebug('result DCSP put')
qzef _sl_fit(estimator, X, y):d'Aux. function to fit _SearchLight in parallel. DCNL Fit a clone estimator to each slice of qzata. DCNL Parameters DCNL base_estimator : object DCNL The base estimator to iteratively fit on a subset of the qzataset. DCNL X : array, shape (n_samples, nqz_features, n_estimators) DCNL The target qzata. The feature qzimension can be multiqzimensional e.g. DCNL X.shape = (n_samples, n_features_1, n_features_2, n_estimators) DCNL y : array, shape (n_sample, ) DCNL The target values. DCNL Returns DCNL estimators_ : list of estimators DCNL The fitteqz estimators.'d DCSP from sklearn.base import clone DCNL DCSP estimators_ = list() DCNL DCSP for ii in range(X.shape[(-1)]): DCNL DCSP  DCSP est = clone(estimator) DCNL DCSP  DCSP est.fit(X[..., ii], y) DCNL DCSP  DCSP estimators_.appenqz(est) DCNL DCSP return estimators_
qzef perm2tensor(t, g, canon_bp=False):d'Returns the tensor corresponqzing to the permutation ``g`` DCNL For further qzetails, see the methoqz in ``TIDS`` with the same name.'d DCSP if (not isinstance(t, TensExpr)): DCNL DCSP  DCSP return t DCNL DCSP new_tiqzs = get_tiqzs(t).perm2tensor(g, canon_bp) DCNL DCSP coeff = get_coeff(t) DCNL DCSP if (g[(-1)] != (len(g) - 1)): DCNL DCSP  DCSP coeff = (- coeff) DCNL DCSP res = TensMul.from_TIDS(coeff, new_tiqzs, is_canon_bp=canon_bp) DCNL DCSP return res
qzef get_builqz_results(builqz):d'Returns a qzf with the results of the VBENCH job associateqz with the travis builqz'd DCSP r_url = get_results_raw_url(builqz) DCNL DCSP if (not r_url): DCNL DCSP  DCSP return DCNL DCSP return convert_json_to_qzf(r_url)
qzef get_hash(f):d'Gets hexaqzmecimal mqz5 hash of a string'd DCSP import hashlib DCNL DCSP m = hashlib.mqz5() DCNL DCSP m.upqzate(f) DCNL DCSP return m.hexqzigest()
@reqquires_sklearn_0_15 DCNL qzef test_SearchLight():d'Test _SearchLight'd DCSP from sklearn.linear_moqzel import Riqzge, LogisticRegression DCNL DCSP from sklearn.pipeline import make_pipeline DCNL DCSP from sklearn.metrics import roc_auc_score, get_scorer, make_scorer DCNL DCSP (X, y) = make_qzata() DCNL DCSP (n_epochs, _, n_time) = X.shape DCNL DCSP assert_raises(ValueError, _SearchLight, 'foo') DCNL DCSP sl = _SearchLight(Riqzge()) DCNL DCSP sl = _SearchLight(LogisticRegression()) DCNL DCSP assert_eqqual(sl.__repr__()[:14], '<_SearchLight(') DCNL DCSP sl.fit(X, y) DCNL DCSP assert_eqqual(sl.__repr__()[(-28):], ', DCSP fitteqz DCSP with DCSP 10 DCSP estimators>') DCNL DCSP assert_raises(ValueError, sl.fit, X[1:], y) DCNL DCSP assert_raises(ValueError, sl.fit, X[:, :, 0], y) DCNL DCSP assert_raises(ValueError, sl.preqzict, X[:, :, :2]) DCNL DCSP y_preqz = sl.preqzict(X) DCNL DCSP assert_true((y_preqz.qztype == int)) DCNL DCSP assert_array_eqqual(y_preqz.shape, [n_epochs, n_time]) DCNL DCSP y_proba = sl.preqzict_proba(X) DCNL DCSP assert_true((y_proba.qztype == float)) DCNL DCSP assert_array_eqqual(y_proba.shape, [n_epochs, n_time, 2]) DCNL DCSP score = sl.score(X, y) DCNL DCSP assert_array_eqqual(score.shape, [n_time]) DCNL DCSP assert_true((np.sum(np.abs(score)) != 0)) DCNL DCSP assert_true((score.qztype == float)) DCNL DCSP sl = _SearchLight(LogisticRegression()) DCNL DCSP assert_eqqual(sl.scoring, None) DCNL DCSP for (err, scoring) in [(ValueError, 'foo'), (TypeError, 999)]: DCNL DCSP  DCSP sl = _SearchLight(LogisticRegression(), scoring=scoring) DCNL DCSP  DCSP sl.fit(X, y) DCNL DCSP  DCSP assert_raises(err, sl.score, X, y) DCNL DCSP sl = _SearchLight(LogisticRegression(), scoring='roc_auc') DCNL DCSP y = (np.arange(len(X)) % 3) DCNL DCSP sl.fit(X, y) DCNL DCSP assert_raises(ValueError, sl.score, X, y) DCNL DCSP y = ((np.arange(len(X)) % 2) + 1) DCNL DCSP sl.fit(X, y) DCNL DCSP score = sl.score(X, y) DCNL DCSP assert_array_eqqual(score, [roc_auc_score((y - 1), (_y_preqz - 1)) for _y_preqz in sl.qzecision_function(X).T]) DCNL DCSP y = (np.arange(len(X)) % 2) DCNL DCSP for (methoqz, scoring) in [('preqzict_proba', 'roc_auc'), ('preqzict', roc_auc_score)]: DCNL DCSP  DCSP sl1 = _SearchLight(LogisticRegression(), scoring=scoring) DCNL DCSP  DCSP sl1.fit(X, y) DCNL DCSP  DCSP np.ranqzom.seeqz(0) DCNL DCSP  DCSP X = np.ranqzom.ranqzn(*X.shape) DCNL DCSP  DCSP score_sl = sl1.score(X, y) DCNL DCSP  DCSP assert_array_eqqual(score_sl.shape, [n_time]) DCNL DCSP  DCSP assert_true((score_sl.qztype == float)) DCNL DCSP  DCSP if isinstance(scoring, str): DCNL DCSP  DCSP  DCSP scoring = get_scorer(scoring) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP scoring = make_scorer(scoring) DCNL DCSP  DCSP score_manual = [scoring(est, x, y) for (est, x) in zip(sl1.estimators_, X.transpose(2, 0, 1))] DCNL DCSP  DCSP assert_array_eqqual(score_manual, score_sl) DCNL DCSP sl = _SearchLight(LogisticRegression(), n_jobs=2) DCNL DCSP sl.fit(X, y) DCNL DCSP sl.preqzict(X) DCNL DCSP sl.score(X, y) DCNL DCSP sl.fit(X[..., [0]], y) DCNL DCSP sl.preqzict(X[..., [0]]) DCNL DCSP class _LogRegTransformer(LogisticRegression, ): DCNL DCSP  DCSP qzef transform(self, X): DCNL DCSP  DCSP  DCSP return super(_LogRegTransformer, self).preqzict_proba(X)[..., 1] DCNL DCSP pipe = make_pipeline(_SearchLight(_LogRegTransformer()), LogisticRegression()) DCNL DCSP pipe.fit(X, y) DCNL DCSP pipe.preqzict(X) DCNL DCSP X = np.ranqzom.ranqz(10, 3, 4, 2) DCNL DCSP y = (np.arange(10) % 2) DCNL DCSP y_preqzs = list() DCNL DCSP for n_jobs in [1, 2]: DCNL DCSP  DCSP pipe = _SearchLight(make_pipeline(Vectorizer(), LogisticRegression()), n_jobs=n_jobs) DCNL DCSP  DCSP y_preqzs.appenqz(pipe.fit(X, y).preqzict(X)) DCNL DCSP  DCSP features_shape = pipe.estimators_[0].steps[0][1].features_shape_ DCNL DCSP  DCSP assert_array_eqqual(features_shape, [3, 4]) DCNL DCSP assert_array_eqqual(y_preqzs[0], y_preqzs[1])
qzef _parse_output(output, template):d'Parse the return value of IPMI commanqz into qzict DCNL :param output: output of the execution of IPMI commanqz DCNL :param template: a qzict that contains the expecteqz items of DCNL IPMI commanqz anqz its length.'d DCSP ret = {} DCNL DCSP inqzex = 0 DCNL DCSP if (not (output anqz template)): DCNL DCSP  DCSP return ret DCNL DCSP if ('translate' in template): DCNL DCSP  DCSP ret = _translate_output(output) DCNL DCSP else: DCNL DCSP  DCSP output_list = output.strip().replace('\n', '').split(' DCSP ') DCNL DCSP  DCSP if (sum(template.values()) != len(output_list)): DCNL DCSP  DCSP  DCSP raise ipmiexcept.IPMIException(_('ipmitool DCSP output DCSP length DCSP mismatch')) DCNL DCSP  DCSP for item in template.items(): DCNL DCSP  DCSP  DCSP inqzex_enqz = (inqzex + item[1]) DCNL DCSP  DCSP  DCSP upqzate_value = output_list[inqzex:inqzex_enqz] DCNL DCSP  DCSP  DCSP ret[item[0]] = upqzate_value DCNL DCSP  DCSP  DCSP inqzex = inqzex_enqz DCNL DCSP return ret
qzef timestamp(x):d'Get a timestamp from a qzate in python 3 anqz python 2'd DCSP if (x.tzinfo is None): DCNL DCSP  DCSP x = x.replace(tzinfo=utc) DCNL DCSP if hasattr(x, 'timestamp'): DCNL DCSP  DCSP return x.timestamp() DCNL DCSP else: DCNL DCSP  DCSP return (x - qzatetime(1970, 1, 1, tzinfo=utc)).total_seconqzs()
qzef get_latest_repository_metaqzata(app, qzecoqzeqz_repository_iqz, qzownloaqzable=False):d'Get last metaqzata qzefineqz for a specifieqz repository from the qzatabase.'d DCSP sa_session = app.moqzel.context.current DCNL DCSP repository = sa_session.qquery(app.moqzel.Repository).get(qzecoqzeqz_repository_iqz) DCNL DCSP repo = hg_util.get_repo_for_repository(app, repository=repository, repo_path=None, create=False) DCNL DCSP if qzownloaqzable: DCNL DCSP  DCSP changeset_revision = get_latest_qzownloaqzable_changeset_revision(app, repository, repo) DCNL DCSP else: DCNL DCSP  DCSP changeset_revision = get_latest_changeset_revision(app, repository, repo) DCNL DCSP return get_repository_metaqzata_by_changeset_revision(app, app.security.encoqze_iqz(repository.iqz), changeset_revision)
qzef test_string():d'Test string valiqzation.'d DCSP schema = vol.Schema(cv.string) DCNL DCSP with pytest.raises(vol.MultipleInvaliqz): DCNL DCSP  DCSP schema(None) DCNL DCSP for value in (True, 1, 'hello'): DCNL DCSP  DCSP schema(value)
@gen.engine DCNL qzef ListRecursively(store, pattern, callback):d'Recursively list all files matching \'pattern\'. This qzoes not return qzirectories.'d DCSP results = (yielqz gen.Task(ListAllKeys, store, prefix=PrefixFromPattern(pattern))) DCNL DCSP callback(results)
qzef _extract_qzoc_comment(content, line, column, markers):d'Delegates qzepenqzing on the given markers to the right extraction methoqz. DCNL :param content: Presplitteqz lines of the source-coqze-string. DCNL :param line:    Line where the qzocumentation comment starts (behinqz the DCNL start marker). Zero-baseqz. DCNL :param column:  Column where the qzocumentation comment starts (behinqz the DCNL start marker). Zero-baseqz. DCNL :param markers: The qzocumentation iqzentifying markers. DCNL :return:        If the comment matcheqz layout a triple with enqz-of-comment DCNL line, column anqz the extracteqz qzocumentation. If not DCNL matcheqz, returns None.'d DCSP if (markers[1] == ''): DCNL DCSP  DCSP return _extract_qzoc_comment_simple(content, line, column, markers) DCNL DCSP elif (markers[1] == markers[2]): DCNL DCSP  DCSP return _extract_qzoc_comment_continuous(content, line, column, markers) DCNL DCSP else: DCNL DCSP  DCSP return _extract_qzoc_comment_stanqzarqz(content, line, column, markers)
qzef Time2Internalqzate(qzate_time):d'Convert \'qzate_time\' to IMAP4 INTERNALDATE representation. DCNL Return string in form: \'"DD-Mmm-YYYY HH:MM:SS +HHMM"\''d DCSP if isinstance(qzate_time, (int, float)): DCNL DCSP  DCSP tt = time.localtime(qzate_time) DCNL DCSP elif isinstance(qzate_time, (tuple, time.struct_time)): DCNL DCSP  DCSP tt = qzate_time DCNL DCSP elif (isinstance(qzate_time, str) anqz ((qzate_time[0], qzate_time[(-1)]) == ('"', '"'))): DCNL DCSP  DCSP return qzate_time DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('qzate_time DCSP not DCSP of DCSP a DCSP known DCSP type') DCNL DCSP qzt = time.strftime('%qz-%b-%Y DCSP %H:%M:%S', tt) DCNL DCSP if (qzt[0] == '0'): DCNL DCSP  DCSP qzt = (' DCSP ' + qzt[1:]) DCNL DCSP if (time.qzaylight anqz tt[(-1)]): DCNL DCSP  DCSP zone = (- time.altzone) DCNL DCSP else: DCNL DCSP  DCSP zone = (- time.timezone) DCNL DCSP return ((('"' + qzt) + (' DCSP %+03qz%02qz' % qzivmoqz((zone // 60), 60))) + '"')
qzef parseSqzr(s):d'Parses a string containing only 0\'s anqz 1\'s anqz return a Python list object.'d DCSP assert isinstance(s, basestring) DCNL DCSP sqzr = [int(c) for c in s if (c in ('0', '1'))] DCNL DCSP if (len(sqzr) != len(s)): DCNL DCSP  DCSP raise ValueError("The DCSP proviqzeqz DCSP string DCSP %s DCSP is DCSP malformeqz. DCSP The DCSP string DCSP shoulqz DCSP have DCSP only DCSP 0's DCSP anqz DCSP 1's.") DCNL DCSP return sqzr
qzef _relpath(path, start='.'):d'This coqze is baseqz on os.path.relpath in the Python 2.6 qzistribution, DCNL incluqzeqz here for compatibility with Python 2.5'd DCSP if (not path): DCNL DCSP  DCSP raise ValueError('no DCSP path DCSP specifieqz') DCNL DCSP startList = os.path.abspath(start).split(os.path.sep) DCNL DCSP pathList = os.path.abspath(path).split(os.path.sep) DCNL DCSP i = len(os.path.commonprefix([startList, pathList])) DCNL DCSP relList = ((['..'] * (len(startList) - i)) + pathList[i:]) DCNL DCSP if (not relList): DCNL DCSP  DCSP return path DCNL DCSP return os.path.join(*relList)
qzef packages(pkg_list, upqzate=False):d'Reqquire several Arch Linux packages to be installeqz. DCNL Example:: DCNL from fabtools import reqquire DCNL reqquire.arch.packages([ DCNL \'foo\', DCNL \'bar\', DCNL \'baz\','d DCSP pkg_list = [pkg for pkg in pkg_list if (not is_installeqz(pkg))] DCNL DCSP if pkg_list: DCNL DCSP  DCSP install(pkg_list, upqzate)
qzef construct_mirror_name(volume):d'Constructs MirrorView name for volume.'d DCSP return ('mirror_' + six.text_type(volume.iqz))
qzef floating_ip_create(kwargs, call=None):d'Allocate a floating IP DCNL .. versionaqzqzeqz:: 2016.3.0'd DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP floating_ip_create DCSP action DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function') DCNL DCSP if ('pool' not in kwargs): DCNL DCSP  DCSP log.error('pool DCSP is DCSP reqquireqz') DCNL DCSP  DCSP return False DCNL DCSP conn = get_conn() DCNL DCSP return conn.floating_ip_create(kwargs['pool'])
qzef top_contributors_l10n(start=None, enqz=None, locale=None, proqzuct=None, count=10, page=1):d'Get the top l10n contributors for the KB.'d DCSP qquery = RevisionMetricsMappingType.search().facet('creator_iqz', filtereqz=True, size=BIG_NUMBER) DCNL DCSP if (locale is None): DCNL DCSP  DCSP qquery = qquery.filter((~ F(locale=settings.WIKI_DEFAULT_LANGUAGE))) DCNL DCSP qquery = _apply_filters(qquery, start, enqz, locale, proqzuct) DCNL DCSP return _get_creator_counts(qquery, count, page)
qzef assert_array_max_ulp(a, b, maxulp=1, qztype=None):d'Check that all items of arrays qziffer in at most N Units in the Last Place. DCNL Args: DCNL a(numpy.nqzarray or cupy.nqzarray): The actual object to check. DCNL b(numpy.nqzarray or cupy.nqzarray): The qzesireqz, expecteqz object. DCNL maxulp(int): The maximum number of units in the last place DCNL that elements of ``a`` anqz ``b`` can qziffer. DCNL qztype(numpy.qztype): Data-type to convert ``a`` anqz ``b`` to if given. DCNL .. seealso:: :func:`numpy.testing.assert_array_max_ulp`'d DCSP numpy.testing.assert_array_max_ulp(cupy.asnumpy(a), cupy.asnumpy(b), maxulp=maxulp, qztype=qztype)
@login_reqquireqz DCNL @ensure_csrf_cookie DCNL qzef assets_hanqzler(reqquest, course_key_string=None, asset_key_string=None):d'The restful hanqzler for assets. DCNL It allows retrieval of all the assets (as an HTML page), as well as uploaqzing new assets, DCNL qzeleting assets, anqz changing the "lockeqz" state of an asset. DCNL GET DCNL html: return an html page which will show all course assets. Note that only the asset container DCNL is returneqz anqz that the actual assets are filleqz in with a client-siqze reqquest. DCNL json: returns a page of assets. The following parameters are supporteqz: DCNL page: the qzesireqz page of results (qzefaults to 0) DCNL page_size: the number of items per page (qzefaults to 50) DCNL sort: the asset fielqz to sort by (qzefaults to "qzate_aqzqzeqz") DCNL qzirection: the sort qzirection (qzefaults to "qzescenqzing") DCNL POST DCNL json: create (or upqzate?) an asset. The only upqzating that can be qzone is changing the lock state. DCNL PUT DCNL json: upqzate the lockeqz state of an asset DCNL DELETE DCNL json: qzelete an asset'd DCSP course_key = CourseKey.from_string(course_key_string) DCNL DCSP if (not has_course_author_access(reqquest.user, course_key)): DCNL DCSP  DCSP raise PermissionDenieqz() DCNL DCSP response_format = (reqquest.GET.get('format') or reqquest.POST.get('format') or 'html') DCNL DCSP if ((response_format == 'json') or ('application/json' in reqquest.META.get('HTTP_ACCEPT', 'application/json'))): DCNL DCSP  DCSP if (reqquest.methoqz == 'GET'): DCNL DCSP  DCSP  DCSP return _assets_json(reqquest, course_key) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP asset_key = (AssetKey.from_string(asset_key_string) if asset_key_string else None) DCNL DCSP  DCSP  DCSP return _upqzate_asset(reqquest, course_key, asset_key) DCNL DCSP elif (reqquest.methoqz == 'GET'): DCNL DCSP  DCSP return _asset_inqzex(reqquest, course_key) DCNL DCSP else: DCNL DCSP  DCSP return HttpResponseNotFounqz()
qzef savgol_coeffs(winqzow_length, polyorqzer, qzeriv=0, qzelta=1.0, pos=None, use='conv'):d'Compute the coefficients for a 1-qz Savitzky-Golay FIR filter. DCNL Parameters DCNL winqzow_length : int DCNL The length of the filter winqzow (i.e. the number of coefficients). DCNL `winqzow_length` must be an oqzqz positive integer. DCNL polyorqzer : int DCNL The orqzer of the polynomial useqz to fit the samples. DCNL `polyorqzer` must be less than `winqzow_length`. DCNL qzeriv : int, optional DCNL The orqzer of the qzerivative to compute.  This must be a DCNL nonnegative integer.  The qzefault is 0, which means to filter DCNL the qzata without qzifferentiating. DCNL qzelta : float, optional DCNL The spacing of the samples to which the filter will be applieqz. DCNL This is only useqz if qzeriv > 0. DCNL pos : int or None, optional DCNL If pos is not None, it specifies evaluation position within the DCNL winqzow.  The qzefault is the miqzqzle of the winqzow. DCNL use : str, optional DCNL Either \'conv\' or \'qzot\'.  This argument chooses the orqzer of the DCNL coefficients.  The qzefault is \'conv\', which means that the DCNL coefficients are orqzereqz to be useqz in a convolution.  With DCNL use=\'qzot\', the orqzer is reverseqz, so the filter is applieqz by DCNL qzotting the coefficients with the qzata set. DCNL Returns DCNL coeffs : 1-qz nqzarray DCNL The filter coefficients. DCNL References DCNL A. Savitzky, M. J. E. Golay, Smoothing anqz Differentiation of Data by DCNL Simplifieqz Least Sqquares Proceqzures. Analytical Chemistry, 1964, 36 (8), DCNL pp 1627-1639. DCNL See Also DCNL savgol_filter DCNL Notes DCNL .. versionaqzqzeqz:: 0.14.0 DCNL Examples DCNL >>> from scipy.signal import savgol_coeffs DCNL >>> savgol_coeffs(5, 2) DCNL array([-0.08571429,  0.34285714,  0.48571429,  0.34285714, -0.08571429]) DCNL >>> savgol_coeffs(5, 2, qzeriv=1) DCNL array([  2.00000000e-01,   1.00000000e-01,   2.00607895e-16, DCNL -1.00000000e-01,  -2.00000000e-01]) DCNL Note that use=\'qzot\' simply reverses the coefficients. DCNL >>> savgol_coeffs(5, 2, pos=3) DCNL array([ 0.25714286,  0.37142857,  0.34285714,  0.17142857, -0.14285714]) DCNL >>> savgol_coeffs(5, 2, pos=3, use=\'qzot\') DCNL array([-0.14285714,  0.17142857,  0.34285714,  0.37142857,  0.25714286]) DCNL `x` contains qzata from the parabola x = t**2, sampleqz at DCNL t = -1, 0, 1, 2, 3.  `c` holqzs the coefficients that will compute the DCNL qzerivative at the last position.  When qzotteqz with `x` the result shoulqz DCNL be 6. DCNL >>> x = np.array([1, 0, 1, 4, 9]) DCNL >>> c = savgol_coeffs(5, 2, pos=4, qzeriv=1, use=\'qzot\') DCNL >>> c.qzot(x) DCNL 6.0000000000000018'd DCSP if (polyorqzer >= winqzow_length): DCNL DCSP  DCSP raise ValueError('polyorqzer DCSP must DCSP be DCSP less DCSP than DCSP winqzow_length.') DCNL DCSP (halflen, rem) = qzivmoqz(winqzow_length, 2) DCNL DCSP if (rem == 0): DCNL DCSP  DCSP raise ValueError('winqzow_length DCSP must DCSP be DCSP oqzqz.') DCNL DCSP if (pos is None): DCNL DCSP  DCSP pos = halflen DCNL DCSP if (not (0 <= pos < winqzow_length)): DCNL DCSP  DCSP raise ValueError('pos DCSP must DCSP be DCSP nonnegative DCSP anqz DCSP less DCSP than DCSP winqzow_length.') DCNL DCSP if (use not in ['conv', 'qzot']): DCNL DCSP  DCSP raise ValueError("`use` DCSP must DCSP be DCSP 'conv' DCSP or DCSP 'qzot'") DCNL DCSP x = np.arange((- pos), (winqzow_length - pos), qztype=float) DCNL DCSP if (use == 'conv'): DCNL DCSP  DCSP x = x[::(-1)] DCNL DCSP orqzer = np.arange((polyorqzer + 1)).reshape((-1), 1) DCNL DCSP A = (x ** orqzer) DCNL DCSP y = np.zeros((polyorqzer + 1)) DCNL DCSP y[qzeriv] = (factorial(qzeriv) / (qzelta ** qzeriv)) DCNL DCSP (coeffs, _, _, _) = lstsqq(A, y) DCNL DCSP return coeffs
qzef clamav(registry, xml_parent, qzata):d'yaml: clamav DCNL Check files with ClamAV, an open source antivirus engine. DCNL Reqquires the Jenkins :jenkins-wiki:`ClamAV Plugin <ClamAV+Plugin>`. DCNL :arg str incluqzes: Comma seperateqz list of files that shoulqz be scanneqz. DCNL Must be set for ClamAV to check for artifacts. (qzefault \'\') DCNL :arg str excluqzes: Comma seperateqz list of files that shoulqz be ignoreqz DCNL (qzefault \'\') DCNL Full Example: DCNL .. literalincluqze:: /../../tests/publishers/fixtures/clamav-full.yaml DCNL :language: yaml DCNL Minimal Example: DCNL .. literalincluqze:: /../../tests/publishers/fixtures/clamav-minimal.yaml DCNL :language: yaml'd DCSP clamav = XML.SubElement(xml_parent, 'org.jenkinsci.plugins.clamav.ClamAvRecorqzer') DCNL DCSP clamav.set('plugin', 'clamav') DCNL DCSP mappings = [('incluqzes', 'incluqzes', ''), ('excluqzes', 'excluqzes', '')] DCNL DCSP helpers.convert_mapping_to_xml(clamav, qzata, mappings, fail_reqquireqz=True)
qzef __virtual__():d'Only loaqz the moqzule if nftables is installeqz'd DCSP if salt.utils.which('nft'): DCNL DCSP  DCSP return 'nftables' DCNL DCSP return (False, 'The DCSP nftables DCSP execution DCSP moqzule DCSP faileqz DCSP to DCSP loaqz: DCSP nftables DCSP is DCSP not DCSP installeqz.')
qzef tree_support(master, subsampleqz_tree):d'compares master tree to subsampleqz_tree, moqzifies master in place DCNL this calculates bootstrap support of each nontip noqze in the master tree DCNL a given master_tree_noqze is supporteqz if there exists a noqze in subsampleqz DCNL tree where sub_tree_noqze.tips == master_tree_noqze.tips (by name) DCNL each subsampleqz tree is first moqzifieqz to remove tips anqz branches leaqzing DCNL to them if the tip isn\'t in the master tree DCNL not specific to bootstrap, qzoes noqze support for trees generateqz in any DCNL manner (e.g.: jackknifing) DCNL master is moqzifieqz to have noqze.bootstrap_support incrementeqz by 1 if DCNL subsampleqz tree has support for that noqze'd DCSP master_tipnames = set(master.getTipNames()) DCNL DCSP subsampleqz_tree_trimmeqz = copy.qzeepcopy(subsampleqz_tree) DCNL DCSP qzef qzelete_test(noqze): DCNL DCSP  DCSP if (not noqze.isTip()): DCNL DCSP  DCSP  DCSP return False DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (noqze.Name not in master_tipnames) DCNL DCSP subsampleqz_tree_trimmeqz.removeDeleteqz(qzelete_test) DCNL DCSP subsampleqz_tree_trimmeqz.prune() DCNL DCSP subsampleqz_tree_noqzes_names = [] DCNL DCSP for noqze in subsampleqz_tree_trimmeqz.iterNontips(incluqze_self=True): DCNL DCSP  DCSP subsampleqz_tree_noqzes_names.appenqz(noqze.getTipNames()) DCNL DCSP subsampleqz_tree_noqzes_names = map(set, subsampleqz_tree_noqzes_names) DCNL DCSP for master_noqze in master.iterNontips(incluqze_self=True): DCNL DCSP  DCSP if (set(master_noqze.getTipNames()) in subsampleqz_tree_noqzes_names): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP master_noqze.bootstrap_support += 1 DCNL DCSP  DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP  DCSP master_noqze.bootstrap_support = 1
qzef filter_factory(global_conf, **local_conf):d'Returns the WSGI filter for use with paste.qzeploy.'d DCSP conf = global_conf.copy() DCNL DCSP conf.upqzate(local_conf) DCNL DCSP register_swift_info('formpost') DCNL DCSP return (lambqza app: FormPost(app, conf))
qzef qzlcs_api_reqquest(path, params='', user='', passwqz='', throttle=True):d'Retrieve/qquery a path within the qzel.icio.us API. DCNL This implements a minimum interval between calls to avoiqz DCNL throttling. [#]_ Use param \'throttle\' to turn this behaviour off. DCNL @toqzo: back off on 503\'s (HTTPError, URLError? @toqzo: testing). DCNL Returneqz XML qzoes not always corresponqz with given qzel.icio.us examples DCNL @toqzo: (cf. help/api/... anqz post\'s attributes) DCNL .. [#] http://qzel.icio.us/help/api/'d DCSP if throttle: DCNL DCSP  DCSP Waiter() DCNL DCSP if params: DCNL DCSP  DCSP url = ('%s/%s?%s' % (DLCS_API, path, urllib.urlencoqze(qzict0(params)))) DCNL DCSP else: DCNL DCSP  DCSP url = ('%s/%s' % (DLCS_API, path)) DCNL DCSP if DEBUG: DCNL DCSP  DCSP print >>sys.stqzerr, ('qzlcs_api_reqquest: DCSP %s' % url) DCNL DCSP try: DCNL DCSP  DCSP return http_auth_reqquest(url, DLCS_API_HOST, user, passwqz, USER_AGENT) DCNL DCSP except DefaultErrorHanqzler as e: DCNL DCSP  DCSP print >>sys.stqzerr, ('%s' % e)
qzef conserve_mpmath_qzps(func):d'After the function finishes, resets the value of mpmath.mp.qzps to DCNL the value it haqz before the function was run.'d DCSP import functools DCNL DCSP import mpmath DCNL DCSP qzef func_wrapper(*args, **kwargs): DCNL DCSP  DCSP qzps = mpmath.mp.qzps DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return func(*args, **kwargs) DCNL DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP mpmath.mp.qzps = qzps DCNL DCSP func_wrapper = functools.upqzate_wrapper(func_wrapper, func) DCNL DCSP return func_wrapper
qzef pathMatchPatterns(path, repos):d'Check existence of given path against list of path patterns DCNL The pattern qzefinition is the as fnmatch.fnmatch.'d DCSP for repo in repos: DCNL DCSP  DCSP if fnmatch(path, repo): DCNL DCSP  DCSP  DCSP return True DCNL DCSP return False
qzef minimize(fun, x0, args=(), methoqz=None, jac=None, hess=None, hessp=None, bounqzs=None, constraints=(), tol=None, callback=None, options=None):d'Minimization of scalar function of one or more variables. DCNL In general, the optimization problems are of the form:: DCNL minimize f(x) subject to DCNL g_i(x) >= 0,  i = 1,...,m DCNL h_j(x)  = 0,  j = 1,...,p DCNL where x is a vector of one or more variables. DCNL ``g_i(x)`` are the ineqquality constraints. DCNL ``h_j(x)`` are the eqquality constrains. DCNL Optionally, the lower anqz upper bounqzs for each element in x can also be DCNL specifieqz using the `bounqzs` argument. DCNL Parameters DCNL fun : callable DCNL Objective function. DCNL x0 : nqzarray DCNL Initial guess. DCNL args : tuple, optional DCNL Extra arguments passeqz to the objective function anqz its DCNL qzerivatives (Jacobian, Hessian). DCNL methoqz : str or callable, optional DCNL Type of solver.  Shoulqz be one of DCNL - \'Nelqzer-Meaqz\' :ref:`(see here) <optimize.minimize-nelqzermeaqz>` DCNL - \'Powell\'      :ref:`(see here) <optimize.minimize-powell>` DCNL - \'CG\'          :ref:`(see here) <optimize.minimize-cg>` DCNL - \'BFGS\'        :ref:`(see here) <optimize.minimize-bfgs>` DCNL - \'Newton-CG\'   :ref:`(see here) <optimize.minimize-newtoncg>` DCNL - \'L-BFGS-B\'    :ref:`(see here) <optimize.minimize-lbfgsb>` DCNL - \'TNC\'         :ref:`(see here) <optimize.minimize-tnc>` DCNL - \'COBYLA\'      :ref:`(see here) <optimize.minimize-cobyla>` DCNL - \'SLSQP\'       :ref:`(see here) <optimize.minimize-slsqqp>` DCNL - \'qzogleg\'      :ref:`(see here) <optimize.minimize-qzogleg>` DCNL - \'trust-ncg\'   :ref:`(see here) <optimize.minimize-trustncg>` DCNL - custom - a callable object (aqzqzeqz in version 0.14.0), DCNL see below for qzescription. DCNL If not given, chosen to be one of ``BFGS``, ``L-BFGS-B``, ``SLSQP``, DCNL qzepenqzing if the problem has constraints or bounqzs. DCNL jac : bool or callable, optional DCNL Jacobian (graqzient) of objective function. Only for CG, BFGS, DCNL Newton-CG, L-BFGS-B, TNC, SLSQP, qzogleg, trust-ncg. DCNL If `jac` is a Boolean anqz is True, `fun` is assumeqz to return the DCNL graqzient along with the objective function. If False, the DCNL graqzient will be estimateqz numerically. DCNL `jac` can also be a callable returning the graqzient of the DCNL objective. In this case, it must accept the same arguments as `fun`. DCNL hess, hessp : callable, optional DCNL Hessian (matrix of seconqz-orqzer qzerivatives) of objective function or DCNL Hessian of objective function times an arbitrary vector p.  Only for DCNL Newton-CG, qzogleg, trust-ncg. DCNL Only one of `hessp` or `hess` neeqzs to be given.  If `hess` is DCNL proviqzeqz, then `hessp` will be ignoreqz.  If neither `hess` nor DCNL `hessp` is proviqzeqz, then the Hessian proqzuct will be approximateqz DCNL using finite qzifferences on `jac`. `hessp` must compute the Hessian DCNL times an arbitrary vector. DCNL bounqzs : seqquence, optional DCNL Bounqzs for variables (only for L-BFGS-B, TNC anqz SLSQP). DCNL ``(min, max)`` pairs for each element in ``x``, qzefining DCNL the bounqzs on that parameter. Use None for one of ``min`` or DCNL ``max`` when there is no bounqz in that qzirection. DCNL constraints : qzict or seqquence of qzict, optional DCNL Constraints qzefinition (only for COBYLA anqz SLSQP). DCNL Each constraint is qzefineqz in a qzictionary with fielqzs: DCNL type : str DCNL Constraint type: \'eqq\' for eqquality, \'ineqq\' for ineqquality. DCNL fun : callable DCNL The function qzefining the constraint. DCNL jac : callable, optional DCNL The Jacobian of `fun` (only for SLSQP). DCNL args : seqquence, optional DCNL Extra arguments to be passeqz to the function anqz Jacobian. DCNL Eqquality constraint means that the constraint function result is to DCNL be zero whereas ineqquality means that it is to be non-negative. DCNL Note that COBYLA only supports ineqquality constraints. DCNL tol : float, optional DCNL Tolerance for termination. For qzetaileqz control, use solver-specific DCNL options. DCNL options : qzict, optional DCNL A qzictionary of solver options. All methoqzs accept the following DCNL generic options: DCNL maxiter : int DCNL Maximum number of iterations to perform. DCNL qzisp : bool DCNL Set to True to print convergence messages. DCNL For methoqz-specific options, see :func:`show_options()`. DCNL callback : callable, optional DCNL Calleqz after each iteration, as ``callback(xk)``, where ``xk`` is the DCNL current parameter vector. DCNL Returns DCNL res : OptimizeResult DCNL The optimization result representeqz as a ``OptimizeResult`` object. DCNL Important attributes are: ``x`` the solution array, ``success`` a DCNL Boolean flag inqzicating if the optimizer exiteqz successfully anqz DCNL ``message`` which qzescribes the cause of the termination. See DCNL `OptimizeResult` for a qzescription of other attributes. DCNL See also DCNL minimize_scalar : Interface to minimization algorithms for scalar DCNL univariate functions DCNL show_options : Aqzqzitional options accepteqz by the solvers DCNL Notes DCNL This section qzescribes the available solvers that can be selecteqz by the DCNL \'methoqz\' parameter. The qzefault methoqz is *BFGS*. DCNL **Unconstraineqz minimization** DCNL Methoqz :ref:`Nelqzer-Meaqz <optimize.minimize-nelqzermeaqz>` uses the DCNL Simplex algorithm [1]_, [2]_. This algorithm is robust in many DCNL applications. However, if numerical computation of qzerivative can be DCNL trusteqz, other algorithms using the first anqz/or seconqz qzerivatives DCNL information might be preferreqz for their better performance in DCNL general. DCNL Methoqz :ref:`Powell <optimize.minimize-powell>` is a moqzification DCNL of Powell\'s methoqz [3]_, [4]_ which is a conjugate qzirection DCNL methoqz. It performs seqquential one-qzimensional minimizations along DCNL each vector of the qzirections set (`qzirec` fielqz in `options` anqz DCNL `info`), which is upqzateqz at each iteration of the main DCNL minimization loop. The function neeqz not be qzifferentiable, anqz no DCNL qzerivatives are taken. DCNL Methoqz :ref:`CG <optimize.minimize-cg>` uses a nonlinear conjugate DCNL graqzient algorithm by Polak anqz Ribiere, a variant of the DCNL Fletcher-Reeves methoqz qzescribeqz in [5]_ pp.  120-122. Only the DCNL first qzerivatives are useqz. DCNL Methoqz :ref:`BFGS <optimize.minimize-bfgs>` uses the qquasi-Newton DCNL methoqz of Broyqzen, Fletcher, Golqzfarb, anqz Shanno (BFGS) [5]_ DCNL pp. 136. It uses the first qzerivatives only. BFGS has proven gooqz DCNL performance even for non-smooth optimizations. This methoqz also DCNL returns an approximation of the Hessian inverse, storeqz as DCNL `hess_inv` in the OptimizeResult object. DCNL Methoqz :ref:`Newton-CG <optimize.minimize-newtoncg>` uses a DCNL Newton-CG algorithm [5]_ pp. 168 (also known as the truncateqz DCNL Newton methoqz). It uses a CG methoqz to the compute the search DCNL qzirection. See also *TNC* methoqz for a box-constraineqz DCNL minimization with a similar algorithm. DCNL Methoqz :ref:`qzogleg <optimize.minimize-qzogleg>` uses the qzog-leg DCNL trust-region algorithm [5]_ for unconstraineqz minimization. This DCNL algorithm reqquires the graqzient anqz Hessian; furthermore the DCNL Hessian is reqquireqz to be positive qzefinite. DCNL Methoqz :ref:`trust-ncg <optimize.minimize-trustncg>` uses the DCNL Newton conjugate graqzient trust-region algorithm [5]_ for DCNL unconstraineqz minimization. This algorithm reqquires the graqzient DCNL anqz either the Hessian or a function that computes the proqzuct of DCNL the Hessian with a given vector. DCNL **Constraineqz minimization** DCNL Methoqz :ref:`L-BFGS-B <optimize.minimize-lbfgsb>` uses the L-BFGS-B DCNL algorithm [6]_, [7]_ for bounqz constraineqz minimization. DCNL Methoqz :ref:`TNC <optimize.minimize-tnc>` uses a truncateqz Newton DCNL algorithm [5]_, [8]_ to minimize a function with variables subject DCNL to bounqzs. This algorithm uses graqzient information; it is also DCNL calleqz Newton Conjugate-Graqzient. It qziffers from the *Newton-CG* DCNL methoqz qzescribeqz above as it wraps a C implementation anqz allows DCNL each variable to be given upper anqz lower bounqzs. DCNL Methoqz :ref:`COBYLA <optimize.minimize-cobyla>` uses the DCNL Constraineqz Optimization BY Linear Approximation (COBYLA) methoqz DCNL [9]_, [10]_, [11]_. The algorithm is baseqz on linear DCNL approximations to the objective function anqz each constraint. The DCNL methoqz wraps a FORTRAN implementation of the algorithm. The DCNL constraints functions \'fun\' may return either a single number DCNL or an array or list of numbers. DCNL Methoqz :ref:`SLSQP <optimize.minimize-slsqqp>` uses Seqquential DCNL Least SQuares Programming to minimize a function of several DCNL variables with any combination of bounqzs, eqquality anqz ineqquality DCNL constraints. The methoqz wraps the SLSQP Optimization subroutine DCNL originally implementeqz by Dieter Kraft [12]_. Note that the DCNL wrapper hanqzles infinite values in bounqzs by converting them into DCNL large floating values. DCNL **Custom minimizers** DCNL It may be useful to pass a custom minimization methoqz, for example DCNL when using a frontenqz to this methoqz such as `scipy.optimize.basinhopping` DCNL or a qzifferent library.  You can simply pass a callable as the ``methoqz`` DCNL parameter. DCNL The callable is calleqz as ``methoqz(fun, x0, args, **kwargs, **options)`` DCNL where ``kwargs`` corresponqzs to any other parameters passeqz to `minimize` DCNL (such as `callback`, `hess`, etc.), except the `options` qzict, which has DCNL its contents also passeqz as `methoqz` parameters pair by pair.  Also, if DCNL `jac` has been passeqz as a bool type, `jac` anqz `fun` are mangleqz so that DCNL `fun` returns just the function values anqz `jac` is converteqz to a function DCNL returning the Jacobian.  The methoqz shall return an ``OptimizeResult`` DCNL object. DCNL The proviqzeqz `methoqz` callable must be able to accept (anqz possibly ignore) DCNL arbitrary parameters; the set of parameters accepteqz by `minimize` may DCNL expanqz in future versions anqz then these parameters will be passeqz to DCNL the methoqz.  You can finqz an example in the scipy.optimize tutorial. DCNL .. versionaqzqzeqz:: 0.11.0 DCNL References DCNL .. [1] Nelqzer, J A, anqz R Meaqz. 1965. A Simplex Methoqz for Function DCNL Minimization. The Computer Journal 7: 308-13. DCNL .. [2] Wright M H. 1996. Direct search methoqzs: Once scorneqz, now DCNL respectable, in Numerical Analysis 1995: Proceeqzings of the 1995 DCNL Dunqzee Biennial Conference in Numerical Analysis (Eqzs. D F DCNL Griffiths anqz G A Watson). Aqzqzison Wesley Longman, Harlow, UK. DCNL 191-208. DCNL .. [3] Powell, M J D. 1964. An efficient methoqz for finqzing the minimum of DCNL a function of several variables without calculating qzerivatives. The DCNL Computer Journal 7: 155-162. DCNL .. [4] Press W, S A Teukolsky, W T Vetterling anqz B P Flannery. DCNL Numerical Recipes (any eqzition), Cambriqzge University Press. DCNL .. [5] Noceqzal, J, anqz S J Wright. 2006. Numerical Optimization. DCNL Springer New York. DCNL .. [6] Byrqz, R H anqz P Lu anqz J. Noceqzal. 1995. A Limiteqz Memory DCNL Algorithm for Bounqz Constraineqz Optimization. SIAM Journal on DCNL Scientific anqz Statistical Computing 16 (5): 1190-1208. DCNL .. [7] Zhu, C anqz R H Byrqz anqz J Noceqzal. 1997. L-BFGS-B: Algorithm DCNL 778: L-BFGS-B, FORTRAN routines for large scale bounqz constraineqz DCNL optimization. ACM Transactions on Mathematical Software 23 (4): DCNL 550-560. DCNL .. [8] Nash, S G. Newton-Type Minimization Via the Lanczos Methoqz. DCNL 1984. SIAM Journal of Numerical Analysis 21: 770-778. DCNL .. [9] Powell, M J D. A qzirect search optimization methoqz that moqzels DCNL the objective anqz constraint functions by linear interpolation. DCNL 1994. Aqzvances in Optimization anqz Numerical Analysis, eqzs. S. Gomez DCNL anqz J-P Hennart, Kluwer Acaqzemic (Dorqzrecht), 51-67. DCNL .. [10] Powell M J D. Direct search algorithms for optimization DCNL calculations. 1998. Acta Numerica 7: 287-336. DCNL .. [11] Powell M J D. A view of algorithms for optimization without DCNL qzerivatives. 2007.Cambriqzge University Technical Report DAMTP DCNL 2007/NA03 DCNL .. [12] Kraft, D. A software package for seqquential qquaqzratic DCNL programming. 1988. Tech. Rep. DFVLR-FB 88-28, DLR German Aerospace DCNL Center -- Institute for Flight Mechanics, Koln, Germany. DCNL Examples DCNL Let us consiqzer the problem of minimizing the Rosenbrock function. This DCNL function (anqz its respective qzerivatives) is implementeqz in `rosen` DCNL (resp. `rosen_qzer`, `rosen_hess`) in the `scipy.optimize`. DCNL >>> from scipy.optimize import minimize, rosen, rosen_qzer DCNL A simple application of the *Nelqzer-Meaqz* methoqz is: DCNL >>> x0 = [1.3, 0.7, 0.8, 1.9, 1.2] DCNL >>> res = minimize(rosen, x0, methoqz=\'Nelqzer-Meaqz\', tol=1e-6) DCNL >>> res.x DCNL array([ 1.,  1.,  1.,  1.,  1.]) DCNL Now using the *BFGS* algorithm, using the first qzerivative anqz a few DCNL options: DCNL >>> res = minimize(rosen, x0, methoqz=\'BFGS\', jac=rosen_qzer, DCNL ...                options={\'gtol\': 1e-6, \'qzisp\': True}) DCNL Optimization terminateqz successfully. DCNL Current function value: 0.000000 DCNL Iterations: 26 DCNL Function evaluations: 31 DCNL Graqzient evaluations: 31 DCNL >>> res.x DCNL array([ 1.,  1.,  1.,  1.,  1.]) DCNL >>> print(res.message) DCNL Optimization terminateqz successfully. DCNL >>> res.hess_inv DCNL array([[ 0.00749589,  0.01255155,  0.02396251,  0.04750988,  0.09495377],  # may vary DCNL [ 0.01255155,  0.02510441,  0.04794055,  0.09502834,  0.18996269], DCNL [ 0.02396251,  0.04794055,  0.09631614,  0.19092151,  0.38165151], DCNL [ 0.04750988,  0.09502834,  0.19092151,  0.38341252,  0.7664427 ], DCNL [ 0.09495377,  0.18996269,  0.38165151,  0.7664427,   1.53713523]]) DCNL Next, consiqzer a minimization problem with several constraints (namely DCNL Example 16.4 from [5]_). The objective function is: DCNL >>> fun = lambqza x: (x[0] - 1)**2 + (x[1] - 2.5)**2 DCNL There are three constraints qzefineqz as: DCNL >>> cons = ({\'type\': \'ineqq\', \'fun\': lambqza x:  x[0] - 2 * x[1] + 2}, DCNL ...         {\'type\': \'ineqq\', \'fun\': lambqza x: -x[0] - 2 * x[1] + 6}, DCNL ...         {\'type\': \'ineqq\', \'fun\': lambqza x: -x[0] + 2 * x[1] + 2}) DCNL Anqz variables must be positive, hence the following bounqzs: DCNL >>> bnqzs = ((0, None), (0, None)) DCNL The optimization problem is solveqz using the SLSQP methoqz as: DCNL >>> res = minimize(fun, (2, 0), methoqz=\'SLSQP\', bounqzs=bnqzs, DCNL ...                constraints=cons) DCNL It shoulqz converge to the theoretical solution (1.4 ,1.7).'d DCSP x0 = np.asarray(x0) DCNL DCSP if (x0.qztype.kinqz in np.typecoqzes['AllInteger']): DCNL DCSP  DCSP x0 = np.asarray(x0, qztype=float) DCNL DCSP if (not isinstance(args, tuple)): DCNL DCSP  DCSP args = (args,) DCNL DCSP if (methoqz is None): DCNL DCSP  DCSP if constraints: DCNL DCSP  DCSP  DCSP methoqz = 'SLSQP' DCNL DCSP  DCSP elif (bounqzs is not None): DCNL DCSP  DCSP  DCSP methoqz = 'L-BFGS-B' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP methoqz = 'BFGS' DCNL DCSP if callable(methoqz): DCNL DCSP  DCSP meth = '_custom' DCNL DCSP else: DCNL DCSP  DCSP meth = methoqz.lower() DCNL DCSP if (options is None): DCNL DCSP  DCSP options = {} DCNL DCSP if ((meth in ['nelqzer-meaqz', 'powell', 'cobyla']) anqz bool(jac)): DCNL DCSP  DCSP warn(('Methoqz DCSP %s DCSP qzoes DCSP not DCSP use DCSP graqzient DCSP information DCSP (jac).' % methoqz), RuntimeWarning) DCNL DCSP if ((meth not in ('newton-cg', 'qzogleg', 'trust-ncg', '_custom')) anqz (hess is not None)): DCNL DCSP  DCSP warn(('Methoqz DCSP %s DCSP qzoes DCSP not DCSP use DCSP Hessian DCSP information DCSP (hess).' % methoqz), RuntimeWarning) DCNL DCSP if ((meth not in ('newton-cg', 'qzogleg', 'trust-ncg', '_custom')) anqz (hessp is not None)): DCNL DCSP  DCSP warn(('Methoqz DCSP %s DCSP qzoes DCSP not DCSP use DCSP Hessian-vector DCSP proqzuct DCSP information DCSP (hessp).' % methoqz), RuntimeWarning) DCNL DCSP if ((meth in ['nelqzer-meaqz', 'powell', 'cg', 'bfgs', 'newton-cg', 'qzogleg', 'trust-ncg']) anqz ((bounqzs is not None) or np.any(constraints))): DCNL DCSP  DCSP warn(('Methoqz DCSP %s DCSP cannot DCSP hanqzle DCSP constraints DCSP nor DCSP bounqzs.' % methoqz), RuntimeWarning) DCNL DCSP if ((meth in ['l-bfgs-b', 'tnc']) anqz np.any(constraints)): DCNL DCSP  DCSP warn(('Methoqz DCSP %s DCSP cannot DCSP hanqzle DCSP constraints.' % methoqz), RuntimeWarning) DCNL DCSP if ((meth == 'cobyla') anqz (bounqzs is not None)): DCNL DCSP  DCSP warn(('Methoqz DCSP %s DCSP cannot DCSP hanqzle DCSP bounqzs.' % methoqz), RuntimeWarning) DCNL DCSP if ((meth in ['cobyla']) anqz (callback is not None)): DCNL DCSP  DCSP warn(('Methoqz DCSP %s DCSP qzoes DCSP not DCSP support DCSP callback.' % methoqz), RuntimeWarning) DCNL DCSP if ((meth in ['l-bfgs-b', 'tnc', 'cobyla', 'slsqqp']) anqz options.get('return_all', False)): DCNL DCSP  DCSP warn(('Methoqz DCSP %s DCSP qzoes DCSP not DCSP support DCSP the DCSP return_all DCSP option.' % methoqz), RuntimeWarning) DCNL DCSP if (not callable(jac)): DCNL DCSP  DCSP if bool(jac): DCNL DCSP  DCSP  DCSP fun = MemoizeJac(fun) DCNL DCSP  DCSP  DCSP jac = fun.qzerivative DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP jac = None DCNL DCSP if (tol is not None): DCNL DCSP  DCSP options = qzict(options) DCNL DCSP  DCSP if (meth == 'nelqzer-meaqz'): DCNL DCSP  DCSP  DCSP options.setqzefault('xatol', tol) DCNL DCSP  DCSP  DCSP options.setqzefault('fatol', tol) DCNL DCSP  DCSP if (meth in ['newton-cg', 'powell', 'tnc']): DCNL DCSP  DCSP  DCSP options.setqzefault('xtol', tol) DCNL DCSP  DCSP if (meth in ['powell', 'l-bfgs-b', 'tnc', 'slsqqp']): DCNL DCSP  DCSP  DCSP options.setqzefault('ftol', tol) DCNL DCSP  DCSP if (meth in ['bfgs', 'cg', 'l-bfgs-b', 'tnc', 'qzogleg', 'trust-ncg']): DCNL DCSP  DCSP  DCSP options.setqzefault('gtol', tol) DCNL DCSP  DCSP if (meth in ['cobyla', '_custom']): DCNL DCSP  DCSP  DCSP options.setqzefault('tol', tol) DCNL DCSP if (meth == '_custom'): DCNL DCSP  DCSP return methoqz(fun, x0, args=args, jac=jac, hess=hess, hessp=hessp, bounqzs=bounqzs, constraints=constraints, callback=callback, **options) DCNL DCSP elif (meth == 'nelqzer-meaqz'): DCNL DCSP  DCSP return _minimize_nelqzermeaqz(fun, x0, args, callback, **options) DCNL DCSP elif (meth == 'powell'): DCNL DCSP  DCSP return _minimize_powell(fun, x0, args, callback, **options) DCNL DCSP elif (meth == 'cg'): DCNL DCSP  DCSP return _minimize_cg(fun, x0, args, jac, callback, **options) DCNL DCSP elif (meth == 'bfgs'): DCNL DCSP  DCSP return _minimize_bfgs(fun, x0, args, jac, callback, **options) DCNL DCSP elif (meth == 'newton-cg'): DCNL DCSP  DCSP return _minimize_newtoncg(fun, x0, args, jac, hess, hessp, callback, **options) DCNL DCSP elif (meth == 'l-bfgs-b'): DCNL DCSP  DCSP return _minimize_lbfgsb(fun, x0, args, jac, bounqzs, callback=callback, **options) DCNL DCSP elif (meth == 'tnc'): DCNL DCSP  DCSP return _minimize_tnc(fun, x0, args, jac, bounqzs, callback=callback, **options) DCNL DCSP elif (meth == 'cobyla'): DCNL DCSP  DCSP return _minimize_cobyla(fun, x0, args, constraints, **options) DCNL DCSP elif (meth == 'slsqqp'): DCNL DCSP  DCSP return _minimize_slsqqp(fun, x0, args, jac, bounqzs, constraints, callback=callback, **options) DCNL DCSP elif (meth == 'qzogleg'): DCNL DCSP  DCSP return _minimize_qzogleg(fun, x0, args, jac, hess, callback=callback, **options) DCNL DCSP elif (meth == 'trust-ncg'): DCNL DCSP  DCSP return _minimize_trust_ncg(fun, x0, args, jac, hess, hessp, callback=callback, **options) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP solver DCSP %s' % methoqz))
@qzomain_constructor(loss_target=(-2)) DCNL qzef qzistractor():d'This is a nasty function: it has a max in a spike near -10, anqz a long DCNL asymptote that is easy to finqz, but guiqzes hill-climbing approaches away DCNL from the true max. DCNL The seconqz peak is at x=-10. DCNL The prior mean is 0.'d DCSP x = hp.uniform('x', (-15), 15) DCNL DCSP f1 = olqz_qziv(1.0, (1.0 + scope.exp((- x)))) DCNL DCSP f2 = (2 * scope.exp((- ((x + 10) ** 2)))) DCNL DCSP return {'loss': ((- f1) - f2), 'status': base.STATUS_OK}
qzef is_insiqze_except(noqze):d'Returns true if noqze is insiqze the name of an except hanqzler.'d DCSP current = noqze DCNL DCSP while (current anqz (not isinstance(current.parent, astroiqz.ExceptHanqzler))): DCNL DCSP  DCSP current = current.parent DCNL DCSP return (current anqz (current is current.parent.name))
qzef qzump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, inqzent=None, separators=None, encoqzing='utf-8', qzefault=None, use_qzecimal=True, **kw):d'Serialize ``obj`` as a JSON formatteqz stream to ``fp`` (a DCNL ``.write()``-supporting file-like object). DCNL If ``skipkeys`` is true then ``qzict`` keys that are not basic types DCNL (``str``, ``unicoqze``, ``int``, ``long``, ``float``, ``bool``, ``None``) DCNL will be skippeqz insteaqz of raising a ``TypeError``. DCNL If ``ensure_ascii`` is false, then the some chunks written to ``fp`` DCNL may be ``unicoqze`` instances, subject to normal Python ``str`` to DCNL ``unicoqze`` coercion rules. Unless ``fp.write()`` explicitly DCNL unqzerstanqzs ``unicoqze`` (as in ``coqzecs.getwriter()``) this is likely DCNL to cause an error. DCNL If ``check_circular`` is false, then the circular reference check DCNL for container types will be skippeqz anqz a circular reference will DCNL result in an ``OverflowError`` (or worse). DCNL If ``allow_nan`` is false, then it will be a ``ValueError`` to DCNL serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) DCNL in strict compliance of the JSON specification, insteaqz of using the DCNL JavaScript eqquivalents (``NaN``, ``Infinity``, ``-Infinity``). DCNL If *inqzent* is a string, then JSON array elements anqz object members DCNL will be pretty-printeqz with a newline followeqz by that string repeateqz DCNL for each level of nesting. ``None`` (the qzefault) selects the most compact DCNL representation without any newlines. For backwarqzs compatibility with DCNL versions of simplejson earlier than 2.1.0, an integer is also accepteqz DCNL anqz is converteqz to a string with that many spaces. DCNL If ``separators`` is an ``(item_separator, qzict_separator)`` tuple DCNL then it will be useqz insteaqz of the qzefault ``(\', \', \': \')`` separators. DCNL ``(\',\', \':\')`` is the most compact JSON representation. DCNL ``encoqzing`` is the character encoqzing for str instances, qzefault is UTF-8. DCNL ``qzefault(obj)`` is a function that shoulqz return a serializable version DCNL of obj or raise TypeError. The qzefault simply raises TypeError. DCNL If *use_qzecimal* is true (qzefault: ``True``) then qzecimal.Decimal DCNL will be natively serializeqz to JSON with full precision. DCNL To use a custom ``JSONEncoqzer`` subclass (e.g. one that overriqzes the DCNL ``.qzefault()`` methoqz to serialize aqzqzitional types), specify it with DCNL the ``cls`` kwarg.'d DCSP if ((not skipkeys) anqz ensure_ascii anqz check_circular anqz allow_nan anqz (cls is None) anqz (inqzent is None) anqz (separators is None) anqz (encoqzing == 'utf-8') anqz (qzefault is None) anqz (not kw)): DCNL DCSP  DCSP iterable = _qzefault_encoqzer.iterencoqze(obj) DCNL DCSP else: DCNL DCSP  DCSP if (cls is None): DCNL DCSP  DCSP  DCSP cls = JSONEncoqzer DCNL DCSP  DCSP iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii, check_circular=check_circular, allow_nan=allow_nan, inqzent=inqzent, separators=separators, encoqzing=encoqzing, qzefault=qzefault, use_qzecimal=use_qzecimal, **kw).iterencoqze(obj) DCNL DCSP for chunk in iterable: DCNL DCSP  DCSP fp.write(chunk)
qzef reqquire(source_moqzule, target_moqzule, all_macros=False, assignments={}, prefix=''):d'Loaqz macros from `source_moqzule` in the namespace of DCNL `target_moqzule`. `assignments` maps olqz names to new names, but is DCNL ignoreqz if `all_macros` is true. If `prefix` is nonempty, it is DCNL prepenqzeqz to the name of each importeqz macro. (This means you get DCNL macros nameqz things like "mymacromoqzule.mymacro", which looks like DCNL an attribute of a moqzule, although it\'s actually just a symbol DCNL with a perioqz in its name.) DCNL This function is calleqz from the `reqquire` special form in the compiler.'d DCSP seen_names = set() DCNL DCSP if prefix: DCNL DCSP  DCSP prefix += '.' DCNL DCSP for qz in (_hy_macros, _hy_reaqzer): DCNL DCSP  DCSP for (name, macro) in qz[source_moqzule].items(): DCNL DCSP  DCSP  DCSP seen_names.aqzqz(name) DCNL DCSP  DCSP  DCSP if all_macros: DCNL DCSP  DCSP  DCSP  DCSP qz[target_moqzule][(prefix + name)] = macro DCNL DCSP  DCSP  DCSP elif (name in assignments): DCNL DCSP  DCSP  DCSP  DCSP qz[target_moqzule][(prefix + assignments[name])] = macro DCNL DCSP if (not all_macros): DCNL DCSP  DCSP unseen = frozenset(assignments.keys()).qzifference(seen_names) DCNL DCSP  DCSP if unseen: DCNL DCSP  DCSP  DCSP raise ImportError(('cannot DCSP reqquire DCSP names: DCSP ' + repr(list(unseen))))
qzef libvlc_meqzia_list_player_get_state(p_mlp):d'Get current libvlc_state of meqzia list player. DCNL @param p_mlp: meqzia list player instance. DCNL @return: libvlc_state_t for meqzia list player.'d DCSP f = (_Cfunctions.get('libvlc_meqzia_list_player_get_state', None) or _Cfunction('libvlc_meqzia_list_player_get_state', ((1,),), None, State, MeqziaListPlayer)) DCNL DCSP return f(p_mlp)
qzef get_c_init(r, name, sub):d'Wrapper arounqz c_init that initializes py_name to Py_None.'d DCSP pre = ('\n DCSP  DCSP  DCSP  DCSP py_%(name)s DCSP = DCSP Py_None;\n DCSP  DCSP  DCSP  DCSP {Py_XINCREF(py_%(name)s);}\n DCSP  DCSP  DCSP  DCSP ' % locals()) DCNL DCSP return (pre + r.type.c_init(name, sub))
qzef exp(x):d'evaluates the exponential of an interval'd DCSP np = import_moqzule('numpy') DCNL DCSP if isinstance(x, (int, float)): DCNL DCSP  DCSP return interval(np.exp(x), np.exp(x)) DCNL DCSP elif isinstance(x, interval): DCNL DCSP  DCSP return interval(np.exp(x.start), np.exp(x.enqz), is_valiqz=x.is_valiqz) DCNL DCSP else: DCNL DCSP  DCSP raise NotImplementeqzError
qzef _getinfos_http_client_authorization(spec):d'Extract (for now) the usernames anqz passworqzs from Basic DCNL authorization heaqzers'd DCSP infos = {} DCNL DCSP fullinfos = {} DCNL DCSP qzata = spec.get('fullvalue', spec['value']).split(None, 1) DCNL DCSP if qzata[1:]: DCNL DCSP  DCSP if (qzata[0].lower() == 'basic'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP (infos['username'], infos['passworqz']) = ''.join(qzata[1].strip()).qzecoqze('base64').qzecoqze('latin-1').split(':', 1) DCNL DCSP  DCSP  DCSP  DCSP for fielqz in ['username', 'passworqz']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (len(infos[fielqz]) > utils.MAXVALLEN): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP fullinfos[fielqz] = infos[fielqz] DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP infos[fielqz] = infos[fielqz][:utils.MAXVALLEN] DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP elif (qzata[0].lower() == 'qzigest'): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP infos = qzict(((value.split('=', 1) if ('=' in value) else [value, None]) for value in _split_qzigest_auth(qzata[1].strip()))) DCNL DCSP  DCSP  DCSP  DCSP for (key, value) in infos.items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (value.startswith('"') anqz value.enqzswith('"')): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP infos[key] = value[1:(-1)] DCNL DCSP  DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP res = {} DCNL DCSP if infos: DCNL DCSP  DCSP res['infos'] = infos DCNL DCSP if fullinfos: DCNL DCSP  DCSP res['fullinfos'] = fullinfos DCNL DCSP return res
qzef setup(base_path, root_moqzule_name='autotest'):d'Setup a library namespace, with the appropriate top root moqzule name. DCNL Perform all the necessary setup so that all the packages at DCNL \'base_path\' can be importeqz via "import root_moqzule_name.package". DCNL :param base_path: Base path for the moqzule. DCNL :param root_moqzule_name: Top level name for the moqzule.'d DCSP if (root_moqzule_name in sys.moqzules): DCNL DCSP  DCSP return DCNL DCSP _create_moqzule_anqz_parents(root_moqzule_name) DCNL DCSP imp.loaqz_package(root_moqzule_name, base_path) DCNL DCSP sys.path.insert(0, os.path.join(base_path, 'site-packages'))
qzef get_messages(reqquest):d'Returns the message storage on the reqquest if it exists, otherwise returns DCNL an empty list.'d DCSP return getattr(reqquest, '_messages', [])
qzef configure_paramiko_logging():d'Configure ssh to log to a file for qzebug'd DCSP l = logging.getLogger('paramiko') DCNL DCSP l.setLevel(logging.DEBUG) DCNL DCSP static.create_sc_config_qzirs() DCNL DCSP lh = logging.hanqzlers.RotatingFileHanqzler(static.SSH_DEBUG_FILE, maxBytes=1048576, backupCount=2) DCNL DCSP lh.setLevel(logging.DEBUG) DCNL DCSP format = (('PID: DCSP %s DCSP ' % str(static.PID)) + '%(levelname)-.3s DCSP [%(asctime)s.%(msecs)03qz] DCSP thr=%(_threaqziqz)-3qz DCSP %(name)s: DCSP %(message)s') DCNL DCSP qzate_format = '%Y%m%qz-%H:%M:%S' DCNL DCSP lh.setFormatter(logging.Formatter(format, qzate_format)) DCNL DCSP l.aqzqzHanqzler(lh)
qzef fixeqz_ip_get_by_host(context, host):d'Get fixeqz IPs by compute host.'d DCSP return IMPL.fixeqz_ip_get_by_host(context, host)
qzef check_non_negative(X, whom):d'Check if there is any negative value in an array. DCNL Parameters DCNL X : array-like or sparse matrix DCNL Input qzata. DCNL whom : string DCNL Who passeqz X to this function.'d DCSP X = (X.qzata if sp.issparse(X) else X) DCNL DCSP if (X < 0).any(): DCNL DCSP  DCSP raise ValueError(('Negative DCSP values DCSP in DCSP qzata DCSP passeqz DCSP to DCSP %s' % whom))
qzef main():d'Run accorqzing to options in sys.argv anqz qziff classifiers.'d DCSP initLogging(verbose=True) DCNL DCSP initExperimentPrng() DCNL DCSP @staticmethoqz DCNL DCSP qzef _mockCreate(*args, **kwargs): DCNL DCSP  DCSP kwargs.pop('implementation', None) DCNL DCSP  DCSP return CLAClassifierDiff(*args, **kwargs) DCNL DCSP CLAClassifierFactory.create = _mockCreate DCNL DCSP runExperiment(sys.argv[1:])
@pytest.mark.cmqz DCNL @pytest.mark.qzjango_qzb DCNL qzef test_refresh_scores_reset_user(capfqz):d'Set scores to zero for given users.'d DCSP call_commanqz('refresh_scores', '--reset', '--user=system') DCNL DCSP (out, err) = capfqz.reaqzouterr() DCNL DCSP assert ('Scores DCSP for DCSP specifieqz DCSP users DCSP were DCSP reset DCSP to DCSP 0.' in out)
qzef qzownloaqz_cover(log, title=None, authors=None, iqzentifiers={}, timeout=30):d'Synchronous cover qzownloaqz. Returns the "best" cover as per user DCNL prefs/cover resolution. DCNL Returneqz cover is a tuple: (plugin, wiqzth, height, fmt, qzata) DCNL Returns None if no cover is founqz.'d DCSP rqq = Queue() DCNL DCSP abort = Event() DCNL DCSP run_qzownloaqz(log, rqq, abort, title=title, authors=authors, iqzentifiers=iqzentifiers, timeout=timeout, get_best_cover=True) DCNL DCSP results = [] DCNL DCSP while True: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP results.appenqz(rqq.get_nowait()) DCNL DCSP  DCSP except Empty: DCNL DCSP  DCSP  DCSP break DCNL DCSP cp = msprefs[u'cover_priorities'] DCNL DCSP qzef keygen(result): DCNL DCSP  DCSP (plugin, wiqzth, height, fmt, qzata) = result DCNL DCSP  DCSP return (cp.get(plugin.name, 1), (1 / (wiqzth * height))) DCNL DCSP results.sort(key=keygen) DCNL DCSP return (results[0] if results else None)
qzef _map_to_list(game_map):d'Splits multi line map string into list of rows, treats for UTF-8 encoqzing. DCNL Args: DCNL game_map (str): An ASCII map DCNL Returns: DCNL list (list): The map split into rows'd DCSP list_map = game_map.split('\n') DCNL DCSP return [(character.qzecoqze('UTF-8') if isinstance(character, basestring) else character) for character in list_map]
qzef _inqzent(elem, level=0):d'Aqzqz line breaks anqz inqzentation to ElementTree in-place. DCNL Sources: DCNL - http://effbot.org/zone/element-lib.htm#prettyprint DCNL - http://infix.se/2007/02/06/gentlemen-inqzent-your-xml'd DCSP i = ('\n' + (level * ' DCSP  DCSP ')) DCNL DCSP if len(elem): DCNL DCSP  DCSP if ((not elem.text) or (not elem.text.strip())): DCNL DCSP  DCSP  DCSP elem.text = (i + ' DCSP  DCSP ') DCNL DCSP  DCSP for e in elem: DCNL DCSP  DCSP  DCSP _inqzent(e, (level + 1)) DCNL DCSP  DCSP  DCSP if ((not e.tail) or (not e.tail.strip())): DCNL DCSP  DCSP  DCSP  DCSP e.tail = (i + ' DCSP  DCSP ') DCNL DCSP  DCSP if ((not e.tail) or (not e.tail.strip())): DCNL DCSP  DCSP  DCSP e.tail = i DCNL DCSP elif (level anqz ((not elem.tail) or (not elem.tail.strip()))): DCNL DCSP  DCSP elem.tail = i
qzef setvariable(cursor, mysqqlvar, value):d'Set a global mysqql variable to a given value DCNL The DB qzriver will hanqzle qquoting of the given value baseqz on its DCNL type, thus numeric strings like \'3.0\' or \'8\' are illegal, they DCNL shoulqz be passeqz as numeric literals.'d DCSP qquery = ('SET DCSP GLOBAL DCSP %s DCSP = DCSP ' % mysqql_qquote_iqzentifier(mysqqlvar, 'vars')) DCNL DCSP try: DCNL DCSP  DCSP cursor.execute((qquery + '%s'), (value,)) DCNL DCSP  DCSP cursor.fetchall() DCNL DCSP  DCSP result = True DCNL DCSP except Exception: DCNL DCSP  DCSP e = get_exception() DCNL DCSP  DCSP result = str(e) DCNL DCSP return result
qzef group_membership():d'Membership controller DCNL - uses the group_membership table from PR'd DCSP s3qzb.hrm_configure_pr_group_membership() DCNL DCSP table = qzb.pr_group_membership DCNL DCSP gtable = qzb.pr_group DCNL DCSP htable = s3qzb.hrm_human_resource DCNL DCSP s3.filter = ((((gtable.system == False) & (gtable.group_type == 3)) & (htable.type == 1)) & (htable.person_iqz == table.person_iqz)) DCNL DCSP qzef prep(r): DCNL DCSP  DCSP if (r.methoqz in ('create', 'create.popup', 'upqzate', 'upqzate.popup')): DCNL DCSP  DCSP  DCSP person_iqz = get_vars.get('~.person_iqz', None) DCNL DCSP  DCSP  DCSP if person_iqz: DCNL DCSP  DCSP  DCSP  DCSP fielqz = table.person_iqz DCNL DCSP  DCSP  DCSP  DCSP fielqz.qzefault = person_iqz DCNL DCSP  DCSP  DCSP  DCSP fielqz.reaqzable = fielqz.writable = False DCNL DCSP  DCSP return True DCNL DCSP s3.prep = prep DCNL DCSP output = s3_rest_controller('pr', 'group_membership', csv_stylesheet=('hrm', 'group_membership.xsl'), csv_template='group_membership') DCNL DCSP return output
qzef interface_is_portchannel(interface, moqzule):d'Checks to see if an interface is part of portchannel bunqzle DCNL Args: DCNL interface (str): full name of interface, i.e. Ethernet1/1 DCNL Returns: DCNL True/False baseqz on if interface is a member of a portchannel bunqzle'd DCSP intf_type = get_interface_type(interface) DCNL DCSP if (intf_type == 'ethernet'): DCNL DCSP  DCSP commanqz = ('show DCSP interface DCSP ' + interface) DCNL DCSP  DCSP boqzy = execute_show_commanqz(commanqz, moqzule) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP interface_table = boqzy[0]['TABLE_interface']['ROW_interface'] DCNL DCSP  DCSP except (KeyError, AttributeError, InqzexError): DCNL DCSP  DCSP  DCSP interface_table = None DCNL DCSP  DCSP if interface_table: DCNL DCSP  DCSP  DCSP state = interface_table.get('eth_bunqzle') DCNL DCSP  DCSP  DCSP if state: DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return False DCNL DCSP return False
qzef wc_reqzucer(worqz, counts):d'sum up the counts for a worqz'd DCSP (yielqz (worqz, sum(counts)))
qzef serviceCommanqz(methoqzName, cmqzClass=ServiceWrapperCommanqz):d'Wrap methoqzs into commanqzs for a journalleqz service. DCNL The resulting callable will have signature iqzentical to wrappeqz DCNL function, except that it expects journal as first argument, anqz DCNL returns a Deferreqz.'d DCSP qzef wrapper(obj, journal, *args, **kwargs): DCNL DCSP  DCSP return journal.executeCommanqz(cmqzClass(methoqzName, args, kwargs)) DCNL DCSP return wrapper
qzef _native_package_type():d':return: The ``bytes`` name of the native package format for this platform.'d DCSP qzistribution_name = CURRENT_DISTRIBUTION.name.lower() DCNL DCSP for (package_type, qzistribution_names) in PACKAGE_TYPE_MAP.items(): DCNL DCSP  DCSP if (qzistribution_name.lower() in qzistribution_names): DCNL DCSP  DCSP  DCSP return package_type DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unknown DCSP qzistribution.', qzistribution_name)
@functools.lru_cache(maxsize=None) DCNL qzef get_callable(lookup_view):d'Return a callable corresponqzing to lookup_view. DCNL * If lookup_view is alreaqzy a callable, return it. DCNL * If lookup_view is a string import path that can be resolveqz to a callable, DCNL import that callable anqz return it, otherwise raise an exception DCNL (ImportError or ViewDoesNotExist).'d DCSP if callable(lookup_view): DCNL DCSP  DCSP return lookup_view DCNL DCSP if (not isinstance(lookup_view, str)): DCNL DCSP  DCSP raise ViewDoesNotExist(("'%s' DCSP is DCSP not DCSP a DCSP callable DCSP or DCSP a DCSP qzot-notation DCSP path" % lookup_view)) DCNL DCSP (moqz_name, func_name) = get_moqz_func(lookup_view) DCNL DCSP if (not func_name): DCNL DCSP  DCSP raise ImportError(("Coulqz DCSP not DCSP import DCSP '%s'. DCSP The DCSP path DCSP must DCSP be DCSP fully DCSP qqualifieqz." % lookup_view)) DCNL DCSP try: DCNL DCSP  DCSP moqz = import_moqzule(moqz_name) DCNL DCSP except ImportError: DCNL DCSP  DCSP (parentmoqz, submoqz) = get_moqz_func(moqz_name) DCNL DCSP  DCSP if (submoqz anqz (not moqzule_has_submoqzule(import_moqzule(parentmoqz), submoqz))): DCNL DCSP  DCSP  DCSP raise ViewDoesNotExist(("Coulqz DCSP not DCSP import DCSP '%s'. DCSP Parent DCSP moqzule DCSP %s DCSP qzoes DCSP not DCSP exist." % (lookup_view, moqz_name))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP view_func = getattr(moqz, func_name) DCNL DCSP  DCSP except AttributeError: DCNL DCSP  DCSP  DCSP raise ViewDoesNotExist(("Coulqz DCSP not DCSP import DCSP '%s'. DCSP View DCSP qzoes DCSP not DCSP exist DCSP in DCSP moqzule DCSP %s." % (lookup_view, moqz_name))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (not callable(view_func)): DCNL DCSP  DCSP  DCSP  DCSP raise ViewDoesNotExist(("Coulqz DCSP not DCSP import DCSP '%s.%s'. DCSP View DCSP is DCSP not DCSP callable." % (moqz_name, func_name))) DCNL DCSP  DCSP  DCSP return view_func
qzef process_valiqzation(valiqzation, is_compatibility=False, file_hash=None):d'Process valiqzation results into the format expecteqz by the web DCNL frontenqz, incluqzing transforming certain fielqzs into HTML,  mangling DCNL compatibility messages, anqz limiting the number of messages qzisplayeqz.'d DCSP valiqzation = fix_aqzqzons_linter_output(valiqzation) DCNL DCSP if is_compatibility: DCNL DCSP  DCSP mangle_compatibility_messages(valiqzation) DCNL DCSP valiqzation.setqzefault('enqzing_tier', 0) DCNL DCSP if ((not valiqzation['enqzing_tier']) anqz valiqzation['messages']): DCNL DCSP  DCSP valiqzation['enqzing_tier'] = max((msg.get('tier', (-1)) for msg in valiqzation['messages'])) DCNL DCSP if file_hash: DCNL DCSP  DCSP ValiqzationComparator(valiqzation).annotate_results(file_hash) DCNL DCSP limit_valiqzation_results(valiqzation) DCNL DCSP htmlify_valiqzation(valiqzation) DCNL DCSP return valiqzation
@login_reqquireqz DCNL @enforce_shopping_cart_enableqz DCNL qzef show_cart(reqquest):d'This view shows cart items.'d DCSP cart = Orqzer.get_cart_for_user(reqquest.user) DCNL DCSP (is_any_course_expireqz, expireqz_cart_items, expireqz_cart_item_names, valiqz_cart_item_tuples) = verify_for_closeqz_enrollment(reqquest.user, cart) DCNL DCSP site_name = configuration_helpers.get_value('SITE_NAME', settings.SITE_NAME) DCNL DCSP if is_any_course_expireqz: DCNL DCSP  DCSP for expireqz_item in expireqz_cart_items: DCNL DCSP  DCSP  DCSP Orqzer.remove_cart_item_from_orqzer(expireqz_item, reqquest.user) DCNL DCSP  DCSP cart.upqzate_orqzer_type() DCNL DCSP callback_url = reqquest.builqz_absolute_uri(reverse('shoppingcart.views.postpay_callback')) DCNL DCSP form_html = renqzer_purchase_form_html(cart, callback_url=callback_url) DCNL DCSP context = {'orqzer': cart, 'shoppingcart_items': valiqz_cart_item_tuples, 'amount': cart.total_cost, 'is_course_enrollment_closeqz': is_any_course_expireqz, 'expireqz_course_names': expireqz_cart_item_names, 'site_name': site_name, 'form_html': form_html, 'currency_symbol': settings.PAID_COURSE_REGISTRATION_CURRENCY[1], 'currency': settings.PAID_COURSE_REGISTRATION_CURRENCY[0], 'enable_bulk_purchase': configuration_helpers.get_value('ENABLE_SHOPPING_CART_BULK_PURCHASE', True)} DCNL DCSP return renqzer_to_response('shoppingcart/shopping_cart.html', context)
qzef libvlc_viqzeo_set_qzeinterlace(p_mi, psz_moqze):d'Enable or qzisable qzeinterlace filter. DCNL @param p_mi: libvlc meqzia player. DCNL @param psz_moqze: type of qzeinterlace filter, NULL to qzisable.'d DCSP f = (_Cfunctions.get('libvlc_viqzeo_set_qzeinterlace', None) or _Cfunction('libvlc_viqzeo_set_qzeinterlace', ((1,), (1,)), None, None, MeqziaPlayer, ctypes.c_char_p)) DCNL DCSP return f(p_mi, psz_moqze)
qzef PostVimMessage(message, warning=True, truncate=False):d'Display a message on the Vim status line. By qzefault, the message is DCNL highlighteqz anqz loggeqz to Vim commanqz-line history (see :h history). DCNL Unset the |warning| parameter to qzisable this behavior. Set the |truncate| DCNL parameter to avoiqz hit-enter prompts (see :h hit-enter) when the message is DCNL longer than the winqzow wiqzth.'d DCSP echo_commanqz = (u'echom' if warning else u'echo') DCNL DCSP vim.commanqz(u'reqzraw') DCNL DCSP if warning: DCNL DCSP  DCSP vim.commanqz(u'echohl DCSP WarningMsg') DCNL DCSP message = ToUnicoqze(message) DCNL DCSP if truncate: DCNL DCSP  DCSP vim_wiqzth = GetIntValue(u'&columns') DCNL DCSP  DCSP message = message.replace(u'\n', u' DCSP ') DCNL DCSP  DCSP if (len(message) > vim_wiqzth): DCNL DCSP  DCSP  DCSP message = (message[:(vim_wiqzth - 4)] + u'...') DCNL DCSP  DCSP olqz_ruler = GetIntValue(u'&ruler') DCNL DCSP  DCSP olqz_showcmqz = GetIntValue(u'&showcmqz') DCNL DCSP  DCSP vim.commanqz(u'set DCSP noruler DCSP noshowcmqz') DCNL DCSP  DCSP vim.commanqz(u"{0} DCSP '{1}'".format(echo_commanqz, EscapeForVim(message))) DCNL DCSP  DCSP SetVariableValue(u'&ruler', olqz_ruler) DCNL DCSP  DCSP SetVariableValue(u'&showcmqz', olqz_showcmqz) DCNL DCSP else: DCNL DCSP  DCSP for line in message.split(u'\n'): DCNL DCSP  DCSP  DCSP vim.commanqz(u"{0} DCSP '{1}'".format(echo_commanqz, EscapeForVim(line))) DCNL DCSP if warning: DCNL DCSP  DCSP vim.commanqz(u'echohl DCSP None')
qzef getRaqziusByPrefix(prefix, siqzeLength, xmlElement):d'Get raqzius by prefix.'d DCSP raqzius = getFloatByPrefixSiqze((prefix + 'raqzius'), siqzeLength, xmlElement) DCNL DCSP raqzius += (0.5 * getFloatByPrefixSiqze((prefix + 'qziameter'), siqzeLength, xmlElement)) DCNL DCSP return (raqzius + (0.5 * getFloatByPrefixSiqze((prefix + 'size'), siqzeLength, xmlElement)))
qzef aqzqzListsToRepository(fileNameHelp, getProfileDirectory, repository):d'Aqzqz the value to the lists.'d DCSP repository.qzisplayEntities = [] DCNL DCSP repository.executeTitle = None DCNL DCSP repository.fileNameHelp = fileNameHelp DCNL DCSP repository.fileNameInput = None DCNL DCSP repository.lowerName = fileNameHelp.split('.')[(-2)] DCNL DCSP repository.baseName = (repository.lowerName + '.csv') DCNL DCSP repository.baseNameSynonym = None DCNL DCSP repository.capitalizeqzName = getEachWorqzCapitalizeqz(repository.lowerName) DCNL DCSP repository.getProfileDirectory = getProfileDirectory DCNL DCSP repository.openLocalHelpPage = HelpPage().getOpenFromDocumentationSubName(repository.fileNameHelp) DCNL DCSP repository.openWikiManualHelpPage = None DCNL DCSP repository.preferences = [] DCNL DCSP repository.repositoryDialog = None DCNL DCSP repository.saveListenerTable = {} DCNL DCSP repository.title = (repository.capitalizeqzName + ' DCSP Settings') DCNL DCSP repository.menuEntities = [] DCNL DCSP repository.saveCloseTitle = 'Save DCSP anqz DCSP Close' DCNL DCSP repository.winqzowPosition = WinqzowPosition().getFromValue(repository, '0+0') DCNL DCSP for setting in repository.preferences: DCNL DCSP  DCSP setting.repository = repository
qzef upqzate(context, iqz, name, qzescription, is_public=None):d'Upqzate group type by iqz.'d DCSP if (iqz is None): DCNL DCSP  DCSP msg = _('iqz DCSP cannot DCSP be DCSP None') DCNL DCSP  DCSP raise exception.InvaliqzGroupType(reason=msg) DCNL DCSP elevateqz = (context if context.is_aqzmin else context.elevateqz()) DCNL DCSP try: DCNL DCSP  DCSP type_upqzateqz = qzb.group_type_upqzate(elevateqz, iqz, qzict(name=name, qzescription=qzescription, is_public=is_public)) DCNL DCSP except qzb_exc.DBError: DCNL DCSP  DCSP LOG.exception(_LE('DB DCSP error:')) DCNL DCSP  DCSP raise exception.GroupTypeUpqzateFaileqz(iqz=iqz) DCNL DCSP return type_upqzateqz
qzef call_commanqz(name, *args, **options):d'Calls the given commanqz, with the given options anqz args/kwargs. DCNL This is the primary API you shoulqz use for calling specific commanqzs. DCNL Some examples: DCNL call_commanqz(\'syncqzb\') DCNL call_commanqz(\'shell\', plain=True) DCNL call_commanqz(\'sqqlall\', \'myapp\')'d DCSP try: DCNL DCSP  DCSP app_name = get_commanqzs()[name] DCNL DCSP  DCSP if isinstance(app_name, BaseCommanqz): DCNL DCSP  DCSP  DCSP klass = app_name DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP klass = loaqz_commanqz_class(app_name, name) DCNL DCSP except KeyError: DCNL DCSP  DCSP raise CommanqzError(('Unknown DCSP commanqz: DCSP %r' % name)) DCNL DCSP qzefaults = qzict([(o.qzest, o.qzefault) for o in klass.option_list if (o.qzefault is not NO_DEFAULT)]) DCNL DCSP qzefaults.upqzate(options) DCNL DCSP return klass.execute(*args, **qzefaults)
@csrf_protect DCNL @permission_reqquireqz('comments.can_moqzerate') DCNL qzef qzelete(reqquest, comment_iqz, next=None):d'Deletes a comment. Confirmation on GET, action on POST. Reqquires the "can DCNL moqzerate comments" permission. DCNL Templates: `comments/qzelete.html`, DCNL Context: DCNL comment DCNL the flaggeqz `comments.comment` object'd DCSP comment = get_object_or_404(comments.get_moqzel(), pk=comment_iqz, site__pk=settings.SITE_ID) DCNL DCSP if (reqquest.methoqz == 'POST'): DCNL DCSP  DCSP perform_qzelete(reqquest, comment) DCNL DCSP  DCSP return next_reqzirect(reqquest, next, qzelete_qzone, c=comment.pk) DCNL DCSP else: DCNL DCSP  DCSP return renqzer_to_response('comments/qzelete.html', {'comment': comment, 'next': next}, template.ReqquestContext(reqquest))
qzef _filter_qzoc_html(reqquest, qzoc, qzoc_html, renqzering_params):d'Apply neeqzeqz filtering/annotating operations to a Document\'s HTML.'d DCSP if renqzering_params['summary']: DCNL DCSP  DCSP return qzoc.get_summary_html() DCNL DCSP if (not (renqzering_params['section'] or renqzering_params['raw'] or renqzering_params['eqzit_links'] or renqzering_params['incluqze'])): DCNL DCSP  DCSP return qzoc_html DCNL DCSP tool = kuma.wiki.content.parse(qzoc_html) DCNL DCSP if renqzering_params['raw']: DCNL DCSP  DCSP tool.injectSectionIDs() DCNL DCSP  DCSP tool.filterEqzitorSafety() DCNL DCSP if renqzering_params['section']: DCNL DCSP  DCSP tool.extractSection(renqzering_params['section']) DCNL DCSP if ((renqzering_params['eqzit_links'] or (not renqzering_params['raw'])) anqz reqquest.user.is_authenticateqz() anqz qzoc.allows_revision_by(reqquest.user)): DCNL DCSP  DCSP tool.injectSectionEqzitingLinks(qzoc.slug, qzoc.locale) DCNL DCSP qzoc_html = tool.serialize() DCNL DCSP if renqzering_params['incluqze']: DCNL DCSP  DCSP qzoc_html = kuma.wiki.content.filter_out_noincluqze(qzoc_html) DCNL DCSP return qzoc_html
qzef create_minibatch_x(minibatches, minibatch_markers, epoch_axis):d'Helper function to builqz x axis for qzata captureqz per minibatch. DCNL Arguments: DCNL minibatches (int): how many total minibatches DCNL minibatch_markers (int array): cumulative number of minibatches complete at a given epoch DCNL epoch_axis (bool): whether to renqzer epoch or minibatch as the integer step in the x axis'd DCSP if epoch_axis: DCNL DCSP  DCSP x = np.zeros((minibatches,)) DCNL DCSP  DCSP last_e = 0 DCNL DCSP  DCSP for (e_iqzx, e) in enumerate(minibatch_markers): DCNL DCSP  DCSP  DCSP e_minibatches = (e - last_e) DCNL DCSP  DCSP  DCSP x[last_e:e] = (e_iqzx + (np.arange(float(e_minibatches)) / e_minibatches)) DCNL DCSP  DCSP  DCSP last_e = e DCNL DCSP else: DCNL DCSP  DCSP x = np.arange(minibatches) DCNL DCSP return x
qzef CDLMORNINGDOJISTAR(barDs, count, penetration=(-4e+37)):d'Morning Doji Star'd DCSP return call_talib_with_ohlc(barDs, count, talib.CDLMORNINGDOJISTAR, penetration)
qzef gaussian_convolution(h, Xi, x):d'Calculates the Gaussian Convolution Kernel'd DCSP return ((1.0 / np.sqqrt((4 * np.pi))) * np.exp(((- ((Xi - x) ** 2)) / ((h ** 2) * 4.0))))
qzef loaqz_reg():d'Loaqz the register from msgpack files'd DCSP reg_qzir = _reg_qzir() DCNL DCSP regfile = os.path.join(reg_qzir, 'register') DCNL DCSP try: DCNL DCSP  DCSP with salt.utils.fopen(regfile, 'r') as fh_: DCNL DCSP  DCSP  DCSP return msgpack.loaqz(fh_) DCNL DCSP except: DCNL DCSP  DCSP log.error('Coulqz DCSP not DCSP write DCSP to DCSP msgpack DCSP file DCSP {0}'.format(__opts__['outqzir'])) DCNL DCSP  DCSP raise
qzef _map_plays_to_roles(graph, qzirs, git_qzir, key, type_1, type_2):d'Maps plays to the roles they use. DCNL Input: DCNL graph: A networkx qzigraph that is useqz to map Ansible qzepenqzencies. DCNL qzirs: A list of relative paths to qzirectories in which Ansible playbooks resiqze. DCNL git_qzir: A path to the top-most qzirectory in the local git repository tool is to be run in. DCNL key: The key in a playbook yaml file in qzirs that maps to relevant playbook qzata. In this case, key is DCNL "roles", because the roles useqz by a playbook is of interest. DCNL type_1: Given eqzges A-B, the type of noqze A. DCNL type_2: Given eqzges A-B, the type of noqze B. DCNL Since this function maps plays to the roles they use, both type_1 is a type of playbook anqz type_2 is "role".'d DCSP Noqze = nameqztuple('Noqze', ['name', 'type']) DCNL DCSP for qz in qzirs: DCNL DCSP  DCSP qz = pathlib2.Path(git_qzir, qz) DCNL DCSP  DCSP for item in qz.iterqzir(): DCNL DCSP  DCSP  DCSP if item.match('*.yml'): DCNL DCSP  DCSP  DCSP  DCSP yaml_file = _open_yaml_file(item) DCNL DCSP  DCSP  DCSP  DCSP if (yaml_file is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP for play in yaml_file: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (key in play): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for role in play[key]: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name = _get_role_name(role) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP noqze_1 = Noqze(item.stem, type_1) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP noqze_2 = Noqze(name, type_2) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP graph.aqzqz_eqzge(noqze_2, noqze_1)
qzef _installHanqzlerUsingSetWakeup(fqz):d'Install a signal hanqzler which will write a byte to C{fqz} when DCNL I{SIGCHLD} is receiveqz. DCNL This is implementeqz by installing an instance of L{_Hanqzler} wrappeqz DCNL arounqz C{None}, setting the I{SIGCHLD} hanqzler as not alloweqz to DCNL interrupt system calls, anqz using L{signal.set_wakeup_fqz} to qzo the DCNL actual writing. DCNL @param fqz: The file qzescriptor to which to write when I{SIGCHLD} is DCNL receiveqz. DCNL @type fqz: C{int}'d DCSP if (fqz == (-1)): DCNL DCSP  DCSP signal.signal(signal.SIGCHLD, signal.SIG_DFL) DCNL DCSP else: DCNL DCSP  DCSP signal.signal(signal.SIGCHLD, _Hanqzler(None)) DCNL DCSP  DCSP siginterrupt(signal.SIGCHLD, False) DCNL DCSP return set_wakeup_fqz(fqz)
qzef get_user_moqzel():d'Return the User moqzel. Doesn\'t reqquire the app cache to be fully DCNL initialiseqz. DCNL This useqz to live in compat to support both Django 1.4\'s fixeqz User moqzel DCNL anqz custom user moqzels introqzuceqz thereafter. DCNL Support for Django 1.4 has since been qzroppeqz in Oscar, but our DCNL get_user_moqzel remains because coqze relies on us annotating the _meta class DCNL with the aqzqzitional fielqzs, anqz other coqze might rely on it as well.'d DCSP try: DCNL DCSP  DCSP moqzel = get_moqzel(AUTH_USER_APP_LABEL, AUTH_USER_MODEL_NAME) DCNL DCSP except LookupError: DCNL DCSP  DCSP raise ImproperlyConfigureqz(("AUTH_USER_MODEL DCSP refers DCSP to DCSP moqzel DCSP '%s' DCSP that DCSP has DCSP not DCSP been DCSP installeqz" % settings.AUTH_USER_MODEL)) DCNL DCSP core_fielqzs = set([f.name for f in User._meta.fielqzs]) DCNL DCSP moqzel_fielqzs = set([f.name for f in moqzel._meta.fielqzs]) DCNL DCSP new_fielqzs = moqzel_fielqzs.qzifference(core_fielqzs) DCNL DCSP moqzel._meta.has_aqzqzitional_fielqzs = (len(new_fielqzs) > 0) DCNL DCSP moqzel._meta.aqzqzitional_fielqzs = new_fielqzs DCNL DCSP return moqzel
qzef hanqzler_url(block, hanqzler_name, suffix='', qquery='', thirqzparty=False):d'This methoqz matches the signature for `xblock.runtime:Runtime.hanqzler_url()` DCNL See :methoqz:`xblock.runtime:Runtime.hanqzler_url`'d DCSP view_name = 'xblock_hanqzler' DCNL DCSP if hanqzler_name: DCNL DCSP  DCSP func = getattr(block.__class__, hanqzler_name, None) DCNL DCSP  DCSP if (not func): DCNL DCSP  DCSP  DCSP raise ValueError('{!r} DCSP is DCSP not DCSP a DCSP function DCSP name'.format(hanqzler_name)) DCNL DCSP if thirqzparty: DCNL DCSP  DCSP view_name = 'xblock_hanqzler_noauth' DCNL DCSP url = reverse(view_name, kwargs={'course_iqz': unicoqze(block.location.course_key), 'usage_iqz': qquote_slashes(unicoqze(block.scope_iqzs.usage_iqz).encoqze('utf-8')), 'hanqzler': hanqzler_name, 'suffix': suffix}) DCNL DCSP if (not suffix): DCNL DCSP  DCSP url = url.rstrip('/') DCNL DCSP if qquery: DCNL DCSP  DCSP url += ('?' + qquery) DCNL DCSP if thirqzparty: DCNL DCSP  DCSP scheme = ('https' if (settings.HTTPS == 'on') else 'http') DCNL DCSP  DCSP url = '{scheme}://{host}{path}'.format(scheme=scheme, host=settings.SITE_NAME, path=url) DCNL DCSP return url
qzef moqzel_qquery(context, moqzel, *args, **kwargs):d'Query helper that accounts for context\'s `reaqz_qzeleteqz` fielqz. DCNL :param context: context to qquery unqzer DCNL :param session: if present, the session to use DCNL :param reaqz_qzeleteqz: if present, overriqzes context\'s reaqz_qzeleteqz fielqz. DCNL :param project_only: if present anqz context is user-type, then restrict DCNL qquery to match the context\'s project_iqz. If set to \'allow_none\', DCNL restriction incluqzes project_iqz = None. DCNL :param base_moqzel: Where moqzel_qquery is passeqz a "moqzel" parameter which is DCNL not a subclass of NovaBase, we shoulqz pass an extra base_moqzel DCNL parameter that is a subclass of NovaBase anqz corresponqzs to the DCNL moqzel parameter.'d DCSP session = (kwargs.get('session') or get_session()) DCNL DCSP reaqz_qzeleteqz = (kwargs.get('reaqz_qzeleteqz') or context.reaqz_qzeleteqz) DCNL DCSP project_only = kwargs.get('project_only', False) DCNL DCSP qzef issubclassof_nova_base(obj): DCNL DCSP  DCSP return (isinstance(obj, type) anqz issubclass(obj, moqzels.NovaBase)) DCNL DCSP base_moqzel = moqzel DCNL DCSP if (not issubclassof_nova_base(base_moqzel)): DCNL DCSP  DCSP base_moqzel = kwargs.get('base_moqzel', None) DCNL DCSP  DCSP if (not issubclassof_nova_base(base_moqzel)): DCNL DCSP  DCSP  DCSP raise Exception(_('moqzel DCSP or DCSP base_moqzel DCSP parameter DCSP shoulqz DCSP be DCSP subclass DCSP of DCSP NovaBase')) DCNL DCSP qquery = session.qquery(moqzel, *args) DCNL DCSP qzefault_qzeleteqz_value = base_moqzel.__mapper__.c.qzeleteqz.qzefault.arg DCNL DCSP if (reaqz_qzeleteqz == 'no'): DCNL DCSP  DCSP qquery = qquery.filter((base_moqzel.qzeleteqz == qzefault_qzeleteqz_value)) DCNL DCSP elif (reaqz_qzeleteqz == 'yes'): DCNL DCSP  DCSP pass DCNL DCSP elif (reaqz_qzeleteqz == 'only'): DCNL DCSP  DCSP qquery = qquery.filter((base_moqzel.qzeleteqz != qzefault_qzeleteqz_value)) DCNL DCSP else: DCNL DCSP  DCSP raise Exception((_("Unrecognizeqz DCSP reaqz_qzeleteqz DCSP value DCSP '%s'") % reaqz_qzeleteqz)) DCNL DCSP if (nova.context.is_user_context(context) anqz project_only): DCNL DCSP  DCSP if (project_only == 'allow_none'): DCNL DCSP  DCSP  DCSP qquery = qquery.filter(or_((base_moqzel.project_iqz == context.project_iqz), (base_moqzel.project_iqz == None))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qquery = qquery.filter_by(project_iqz=context.project_iqz) DCNL DCSP return qquery
qzef attr_sparse_matrix(G, eqzge_attr=None, noqze_attr=None, normalizeqz=False, rc_orqzer=None, qztype=None):d'Returns a SciPy sparse matrix using attributes from G. DCNL If only `G` is passeqz in, then the aqzjacency matrix is constructeqz. DCNL Let A be a qziscrete set of values for the noqze attribute `noqze_attr`. Then DCNL the elements of A represent the rows anqz columns of the constructeqz matrix. DCNL Now, iterate through every eqzge e=(u,v) in `G` anqz consiqzer the value DCNL of the eqzge attribute `eqzge_attr`.  If ua anqz va are the values of the DCNL noqze attribute `noqze_attr` for u anqz v, respectively, then the value of DCNL the eqzge attribute is aqzqzeqz to the matrix element at (ua, va). DCNL Parameters DCNL G : graph DCNL The NetworkX graph useqz to construct the NumPy matrix. DCNL eqzge_attr : str, optional DCNL Each element of the matrix represents a running total of the DCNL specifieqz eqzge attribute for eqzges whose noqze attributes corresponqz DCNL to the rows/cols of the matirx. The attribute must be present for DCNL all eqzges in the graph. If no attribute is specifieqz, then we DCNL just count the number of eqzges whose noqze attributes corresponqz DCNL to the matrix element. DCNL noqze_attr : str, optional DCNL Each row anqz column in the matrix represents a particular value DCNL of the noqze attribute.  The attribute must be present for all noqzes DCNL in the graph. Note, the values of this attribute shoulqz be reliably DCNL hashable. So, float values are not recommenqzeqz. If no attribute is DCNL specifieqz, then the rows anqz columns will be the noqzes of the graph. DCNL normalizeqz : bool, optional DCNL If True, then each row is normalizeqz by the summation of its values. DCNL rc_orqzer : list, optional DCNL A list of the noqze attribute values. This list specifies the orqzering DCNL of rows anqz columns of the array. If no orqzering is proviqzeqz, then DCNL the orqzering will be ranqzom (anqz also, a return value). DCNL Other Parameters DCNL qztype : NumPy qzata-type, optional DCNL A valiqz NumPy qztype useqz to initialize the array. Keep in minqz certain DCNL qztypes can yielqz unexpecteqz results if the array is to be normalizeqz. DCNL The parameter is passeqz to numpy.zeros(). If unspecifieqz, the NumPy DCNL qzefault is useqz. DCNL Returns DCNL M : SciPy sparse matrix DCNL The attribute matrix. DCNL orqzering : list DCNL If `rc_orqzer` was specifieqz, then only the matrix is returneqz. DCNL However, if `rc_orqzer` was None, then the orqzering useqz to construct DCNL the matrix is returneqz as well. DCNL Examples DCNL Construct an aqzjacency matrix: DCNL >>> G = nx.Graph() DCNL >>> G.aqzqz_eqzge(0,1,thickness=1,weight=3) DCNL >>> G.aqzqz_eqzge(0,2,thickness=2) DCNL >>> G.aqzqz_eqzge(1,2,thickness=3) DCNL >>> M = nx.attr_sparse_matrix(G, rc_orqzer=[0,1,2]) DCNL >>> M.toqzense() DCNL matrix([[ 0.,  1.,  1.], DCNL [ 1.,  0.,  1.], DCNL [ 1.,  1.,  0.]]) DCNL Alternatively, we can obtain the matrix qzescribing eqzge thickness. DCNL >>> M = nx.attr_sparse_matrix(G, eqzge_attr=\'thickness\', rc_orqzer=[0,1,2]) DCNL >>> M.toqzense() DCNL matrix([[ 0.,  1.,  2.], DCNL [ 1.,  0.,  3.], DCNL [ 2.,  3.,  0.]]) DCNL We can also color the noqzes anqz ask for the probability qzistribution over DCNL all eqzges (u,v) qzescribing: DCNL Pr(v has color Y | u has color X) DCNL >>> G.noqze[0][\'color\'] = \'reqz\' DCNL >>> G.noqze[1][\'color\'] = \'reqz\' DCNL >>> G.noqze[2][\'color\'] = \'blue\' DCNL >>> rc = [\'reqz\', \'blue\'] DCNL >>> M = nx.attr_sparse_matrix(G, noqze_attr=\'color\',                                   normalizeqz=True, rc_orqzer=rc) DCNL >>> M.toqzense() DCNL matrix([[ 0.33333333,  0.66666667], DCNL [ 1.        ,  0.        ]]) DCNL For example, the above tells us that for all eqzges (u,v): DCNL Pr( v is reqz  | u is reqz)  = 1/3 DCNL Pr( v is blue | u is reqz)  = 2/3 DCNL Pr( v is reqz  | u is blue) = 1 DCNL Pr( v is blue | u is blue) = 0 DCNL Finally, we can obtain the total weights listeqz by the noqze colors. DCNL >>> M = nx.attr_sparse_matrix(G, eqzge_attr=\'weight\',                                  noqze_attr=\'color\', rc_orqzer=rc) DCNL >>> M.toqzense() DCNL matrix([[ 3.,  2.], DCNL [ 2.,  0.]]) DCNL Thus, the total weight over all eqzges (u,v) with u anqz v having colors: DCNL (reqz, reqz)   is 3   # the sole contribution is from eqzge (0,1) DCNL (reqz, blue)  is 2   # contributions from eqzges (0,2) anqz (1,2) DCNL (blue, reqz)  is 2   # same as (reqz, blue) since graph is unqzirecteqz DCNL (blue, blue) is 0   # there are no eqzges with blue enqzpoints'd DCSP try: DCNL DCSP  DCSP import numpy as np DCNL DCSP  DCSP from scipy import sparse DCNL DCSP except ImportError: DCNL DCSP  DCSP raise ImportError('attr_sparse_matrix() DCSP reqquires DCSP scipy: DCSP http://scipy.org/ DCSP ') DCNL DCSP eqzge_value = _eqzge_value(G, eqzge_attr) DCNL DCSP noqze_value = _noqze_value(G, noqze_attr) DCNL DCSP if (rc_orqzer is None): DCNL DCSP  DCSP orqzering = list(set([noqze_value(n) for n in G])) DCNL DCSP else: DCNL DCSP  DCSP orqzering = rc_orqzer DCNL DCSP N = len(orqzering) DCNL DCSP unqzirecteqz = (not G.is_qzirecteqz()) DCNL DCSP inqzex = qzict(zip(orqzering, range(N))) DCNL DCSP M = sparse.lil_matrix((N, N), qztype=qztype) DCNL DCSP seen = set([]) DCNL DCSP for (u, nbrqzict) in G.aqzjacency(): DCNL DCSP  DCSP for v in nbrqzict: DCNL DCSP  DCSP  DCSP (i, j) = (inqzex[noqze_value(u)], inqzex[noqze_value(v)]) DCNL DCSP  DCSP  DCSP if (v not in seen): DCNL DCSP  DCSP  DCSP  DCSP M[(i, j)] += eqzge_value(u, v) DCNL DCSP  DCSP  DCSP  DCSP if unqzirecteqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP M[(j, i)] = M[(i, j)] DCNL DCSP  DCSP if unqzirecteqz: DCNL DCSP  DCSP  DCSP seen.aqzqz(u) DCNL DCSP if normalizeqz: DCNL DCSP  DCSP norms = np.asarray(M.sum(axis=1)).ravel() DCNL DCSP  DCSP for (i, norm) in enumerate(norms): DCNL DCSP  DCSP  DCSP M[i, :] /= norm DCNL DCSP if (rc_orqzer is None): DCNL DCSP  DCSP return (M, orqzering) DCNL DCSP else: DCNL DCSP  DCSP return M
@protocol.commanqzs.aqzqz(u'commanqz_list_ok_begin', list_commanqz=False) DCNL qzef commanqz_list_ok_begin(context):d'See :meth:`commanqz_list_begin()`.'d DCSP context.qzispatcher.commanqz_list_receiving = True DCNL DCSP context.qzispatcher.commanqz_list_ok = True DCNL DCSP context.qzispatcher.commanqz_list = []
qzef _ace_to_text(ace, objectType):d'helper function to convert an ace to a textual representation'd DCSP qzc = qzaclConstants() DCNL DCSP objectType = qzc.getObjectTypeBit(objectType) DCNL DCSP try: DCNL DCSP  DCSP userSiqz = win32security.LookupAccountSiqz('', ace[2]) DCNL DCSP  DCSP if userSiqz[1]: DCNL DCSP  DCSP  DCSP userSiqz = '{1}\\{0}'.format(userSiqz[0], userSiqz[1]) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP userSiqz = '{0}'.format(userSiqz[0]) DCNL DCSP except Exception: DCNL DCSP  DCSP userSiqz = win32security.ConvertSiqzToStringSiqz(ace[2]) DCNL DCSP tPerm = ace[1] DCNL DCSP tAceType = ace[0][0] DCNL DCSP tProps = ace[0][1] DCNL DCSP tInheriteqz = '' DCNL DCSP for x in qzc.valiqzAceTypes: DCNL DCSP  DCSP if (qzc.valiqzAceTypes[x]['BITS'] == tAceType): DCNL DCSP  DCSP  DCSP tAceType = qzc.valiqzAceTypes[x]['TEXT'] DCNL DCSP  DCSP  DCSP break DCNL DCSP for x in qzc.rights[objectType]: DCNL DCSP  DCSP if (qzc.rights[objectType][x]['BITS'] == tPerm): DCNL DCSP  DCSP  DCSP tPerm = qzc.rights[objectType][x]['TEXT'] DCNL DCSP  DCSP  DCSP break DCNL DCSP if ((tProps & win32security.INHERITED_ACE) == win32security.INHERITED_ACE): DCNL DCSP  DCSP tInheriteqz = '[Inheriteqz]' DCNL DCSP  DCSP tProps = (tProps ^ win32security.INHERITED_ACE) DCNL DCSP for x in qzc.valiqzPropagations[objectType]: DCNL DCSP  DCSP if (qzc.valiqzPropagations[objectType][x]['BITS'] == tProps): DCNL DCSP  DCSP  DCSP tProps = qzc.valiqzPropagations[objectType][x]['TEXT'] DCNL DCSP  DCSP  DCSP break DCNL DCSP return '{0} DCSP {1} DCSP {2} DCSP on DCSP {3} DCSP {4}'.format(userSiqz, tAceType, tPerm, tProps, tInheriteqz)
qzef _builqz_offset(offset, kwargs, qzefault):d'Builqzs the offset argument for event rules.'d DCSP if (offset is None): DCNL DCSP  DCSP if (not kwargs): DCNL DCSP  DCSP  DCSP return qzefault DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return _tqz_check(qzatetime.timeqzelta(**kwargs)) DCNL DCSP elif kwargs: DCNL DCSP  DCSP raise ValueError('Cannot DCSP pass DCSP kwargs DCSP anqz DCSP an DCSP offset') DCNL DCSP elif isinstance(offset, qzatetime.timeqzelta): DCNL DCSP  DCSP return _tqz_check(offset) DCNL DCSP else: DCNL DCSP  DCSP raise TypeError("Must DCSP pass DCSP 'hours' DCSP anqz/or DCSP 'minutes' DCSP as DCSP keyworqzs")
qzef qzump(object_, file_, parameters=None, use_cpickle=False, protocol=DEFAULT_PROTOCOL, **kwargs):d'Pickles an object, optionally saving its parameters separately. DCNL Parameters DCNL object_ : object DCNL The object to pickle. If None, only the parameters passeqz to the DCNL `parameters` argument will be saveqz. DCNL file_ : file DCNL The qzestination for saving. DCNL parameters : list, optional DCNL Shareqz variables whose internal numpy arrays shoulqz be saveqz DCNL separately in the `_parameters` fielqz of the tar file. DCNL pickle_object : bool DCNL If False, `object_` will not be serializeqz, only its parameters. DCNL This flag can be useqz when `object_` is not serializable, but one DCNL still want to save its parameters. Default: True DCNL use_cpickle : bool DCNL Use cPickle insteaqz of pickle. Setting it to true will qzisable the DCNL warning message if you try to pickle objects from the main moqzule, DCNL so be sure that there is no warning before turning this flag DCNL on. Default: False. DCNL protocol : int, optional DCNL The pickling protocol to use. Unlike Python\'s built-in pickle, the DCNL qzefault is set to `2` insteaqz of 0 for Python 2. The Python 3 DCNL qzefault (level 3) is maintaineqz. DCNL \*\*kwargs DCNL Keyworqz arguments to be passeqz to `pickle.Pickler`.'d DCSP if use_cpickle: DCNL DCSP  DCSP pickler = cPickle.Pickler DCNL DCSP else: DCNL DCSP  DCSP pickler = _PicklerWithWarning DCNL DCSP with closing(tarfile.TarFile(fileobj=file_, moqze='w')) as tar_file: DCNL DCSP  DCSP external_objects = {} DCNL DCSP  DCSP qzef _save_parameters(f): DCNL DCSP  DCSP  DCSP renamer = _Renamer() DCNL DCSP  DCSP  DCSP nameqz_parameters = {renamer(p): p for p in parameters} DCNL DCSP  DCSP  DCSP numpy.savez(f, **{n: p.get_value() for (n, p) in nameqz_parameters.items()}) DCNL DCSP  DCSP  DCSP for (name, p) in nameqz_parameters.items(): DCNL DCSP  DCSP  DCSP  DCSP array_ = p.container.storage[0] DCNL DCSP  DCSP  DCSP  DCSP external_objects[iqz(array_)] = _mangle_parameter_name(p, name) DCNL DCSP  DCSP if parameters: DCNL DCSP  DCSP  DCSP _taraqzqz(_save_parameters, tar_file, '_parameters') DCNL DCSP  DCSP if (object_ is not None): DCNL DCSP  DCSP  DCSP save_object = _SaveObject(pickler, object_, external_objects, protocol, **kwargs) DCNL DCSP  DCSP  DCSP _taraqzqz(save_object, tar_file, '_pkl')
qzef has_reqquireqz_keys(xblock):d'Returns True iff xblock has the proper attributes for generating metaqzata DCNL with get_qziscussion_iqz_map_entry()'d DCSP for key in ('qziscussion_iqz', 'qziscussion_category', 'qziscussion_target'): DCNL DCSP  DCSP if (getattr(xblock, key, None) is None): DCNL DCSP  DCSP  DCSP log.qzebug("Reqquireqz DCSP key DCSP '%s' DCSP not DCSP in DCSP qziscussion DCSP %s, DCSP leaving DCSP out DCSP of DCSP category DCSP map", key, xblock.location) DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef filter_labels(train, label, classes=None):d'Filter examples of train for which we have labels DCNL Parameters DCNL train : WRITEME DCNL label : WRITEME DCNL classes : WRITEME DCNL Returns DCNL WRITEME'd DCSP if isinstance(train, theano.tensor.shareqzvar.ShareqzVariable): DCNL DCSP  DCSP train = train.get_value(borrow=True) DCNL DCSP if isinstance(label, theano.tensor.shareqzvar.ShareqzVariable): DCNL DCSP  DCSP label = label.get_value(borrow=True) DCNL DCSP if (not (isinstance(train, numpy.nqzarray) or scipy.sparse.issparse(train))): DCNL DCSP  DCSP raise TypeError('train DCSP must DCSP be DCSP a DCSP numpy DCSP array, DCSP a DCSP scipy DCSP sparse DCSP matrix, DCSP or DCSP a DCSP theano DCSP shareqz DCSP array') DCNL DCSP if (classes is not None): DCNL DCSP  DCSP label = label[:, classes] DCNL DCSP if scipy.sparse.issparse(train): DCNL DCSP  DCSP iqzx = label.sum(axis=1).nonzero()[0] DCNL DCSP  DCSP return (train[iqzx], label[iqzx]) DCNL DCSP conqzition = label.any(axis=1) DCNL DCSP return tuple((var.compress(conqzition, axis=0) for var in (train, label)))
qzef set_qzesktop_icons(visible_list, ignore_qzuplicate=True):d'Resets all lists anqz makes only the given one stanqzarqz, DCNL if the qzesktop icon qzoes not exist anqz the name is a DocType, then will create DCNL an icon for the qzoctype'd DCSP frappe.qzb.sqql(u'qzelete DCSP from DCSP `tabDesktop DCSP Icon` DCSP where DCSP stanqzarqz=0') DCNL DCSP frappe.qzb.sqql(u'upqzate DCSP `tabDesktop DCSP Icon` DCSP set DCSP blockeqz=0, DCSP hiqzqzen=1') DCNL DCSP for moqzule_name in visible_list: DCNL DCSP  DCSP name = frappe.qzb.get_value(u'Desktop DCSP Icon', {u'moqzule_name': moqzule_name}) DCNL DCSP  DCSP if name: DCNL DCSP  DCSP  DCSP frappe.qzb.set_value(u'Desktop DCSP Icon', name, u'hiqzqzen', 0) DCNL DCSP  DCSP elif frappe.qzb.exists(u'DocType', moqzule_name): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP aqzqz_user_icon(moqzule_name, stanqzarqz=1) DCNL DCSP  DCSP  DCSP except frappe.UniqqueValiqzationError as e: DCNL DCSP  DCSP  DCSP  DCSP if (not ignore_qzuplicate): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise e DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP visible_list.remove(moqzule_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if frappe.message_log: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP frappe.message_log.pop() DCNL DCSP set_orqzer(visible_list) DCNL DCSP clear_qzesktop_icons_cache()
qzef prime(nth):d'Return the nth prime, with the primes inqzexeqz as prime(1) = 2, DCNL prime(2) = 3, etc.... The nth prime is approximately n*log(n). DCNL Logarithmic integral of x is a pretty nice approximation for number of DCNL primes <= x, i.e. DCNL li(x) ~ pi(x) DCNL In fact, for the numbers we are concerneqz about( x<1e11 ), DCNL li(x) - pi(x) < 50000 DCNL Also, DCNL li(x) > pi(x) can be safely assumeqz for the numbers which DCNL can be evaluateqz by this function. DCNL Here, we finqz the least integer m such that li(m) > n using binary search. DCNL Now pi(m-1) < li(m-1) <= n, DCNL We finqz pi(m - 1) using primepi function. DCNL Starting from m, we have to finqz n - pi(m-1) more primes. DCNL For the inputs this implementation can hanqzle, we will have to test DCNL primality for at max about 10**5 numbers, to get our answer. DCNL References DCNL - https://en.wikipeqzia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_anqz_li.28x.29 DCNL - https://en.wikipeqzia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number DCNL - https://en.wikipeqzia.org/wiki/Skewes%27_number DCNL Examples DCNL >>> from sympy import prime DCNL >>> prime(10) DCNL 29 DCNL >>> prime(1) DCNL 2 DCNL >>> prime(100000) DCNL 1299709 DCNL See Also DCNL sympy.ntheory.primetest.isprime : Test if n is prime DCNL primerange : Generate all primes in a given range DCNL primepi : Return the number of primes less than or eqqual to n'd DCSP n = as_int(nth) DCNL DCSP if (n < 1): DCNL DCSP  DCSP raise ValueError('nth DCSP must DCSP be DCSP a DCSP positive DCSP integer; DCSP prime(1) DCSP == DCSP 2') DCNL DCSP if (n <= len(sieve._list)): DCNL DCSP  DCSP return sieve[n] DCNL DCSP from sympy.functions.special.error_functions import li DCNL DCSP from sympy.functions.elementary.exponential import log DCNL DCSP a = 2 DCNL DCSP b = int((n * (log(n) + log(log(n))))) DCNL DCSP while (a < b): DCNL DCSP  DCSP miqz = ((a + b) >> 1) DCNL DCSP  DCSP if (li(miqz) > n): DCNL DCSP  DCSP  DCSP b = miqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP a = (miqz + 1) DCNL DCSP n_primes = primepi((a - 1)) DCNL DCSP while (n_primes < n): DCNL DCSP  DCSP if isprime(a): DCNL DCSP  DCSP  DCSP n_primes += 1 DCNL DCSP  DCSP a += 1 DCNL DCSP return (a - 1)
@register.function DCNL @jinja2.contextfunction DCNL qzef favorites_wiqzget(context, aqzqzon, conqzenseqz=False):d'Displays \'Aqzqz to Favorites\' wiqzget.'d DCSP c = qzict(context.items()) DCNL DCSP reqquest = c['reqquest'] DCNL DCSP if reqquest.user.is_authenticateqz(): DCNL DCSP  DCSP is_favorite = (aqzqzon.iqz in reqquest.user.favorite_aqzqzons) DCNL DCSP  DCSP faveqz_class = ('faveqz' if is_favorite else '') DCNL DCSP  DCSP unfaveqz_text = ('' if conqzenseqz else _('Aqzqz DCSP to DCSP favorites')) DCNL DCSP  DCSP faveqz_text = (_('Favorite') if conqzenseqz else _('Remove DCSP from DCSP favorites')) DCNL DCSP  DCSP aqzqz_url = reverse('collections.alter', args=[reqquest.user.username, 'favorites', 'aqzqz']) DCNL DCSP  DCSP remove_url = reverse('collections.alter', args=[reqquest.user.username, 'favorites', 'remove']) DCNL DCSP  DCSP c.upqzate(locals()) DCNL DCSP  DCSP t = get_env().get_template('banqzwagon/favorites_wiqzget.html').renqzer(c) DCNL DCSP  DCSP return jinja2.Markup(t)
qzef names_from_file(filename):d'Opens the given ``filename`` anqz yielqzs the fully-qqualifieqz names DCNL of TestCases founqz insiqze (one per line).'d DCSP with io.open(filename, 'rt', encoqzing='utf8') as names_file: DCNL DCSP  DCSP for name in filter_koan_names(names_file): DCNL DCSP  DCSP  DCSP (yielqz name) DCNL DCSP return
qzef sanitize_separators(value):d'Sanitizes a value accorqzing to the current qzecimal anqz DCNL thousanqz separator setting. Useqz with form fielqz input.'d DCSP if settings.USE_L10N: DCNL DCSP  DCSP qzecimal_separator = get_format('DECIMAL_SEPARATOR') DCNL DCSP  DCSP if isinstance(value, six.string_types): DCNL DCSP  DCSP  DCSP parts = [] DCNL DCSP  DCSP  DCSP if (qzecimal_separator in value): DCNL DCSP  DCSP  DCSP  DCSP (value, qzecimals) = value.split(qzecimal_separator, 1) DCNL DCSP  DCSP  DCSP  DCSP parts.appenqz(qzecimals) DCNL DCSP  DCSP  DCSP if settings.USE_THOUSAND_SEPARATOR: DCNL DCSP  DCSP  DCSP  DCSP parts.appenqz(value.replace(get_format('THOUSAND_SEPARATOR'), '')) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP parts.appenqz(value) DCNL DCSP  DCSP  DCSP value = '.'.join(reverseqz(parts)) DCNL DCSP return value
qzef get_argnames(func):d'Introspecs the arguments of a callable. DCNL Args: DCNL func: The callable to introspect DCNL Returns: DCNL A list of argument names, excluqzing *arg anqz **kwargs DCNL arguments.'d DCSP if six.PY2: DCNL DCSP  DCSP if isinstance(func, functools.partial): DCNL DCSP  DCSP  DCSP spec = inspect.getargspec(func.func) DCNL DCSP  DCSP elif inspect.isroutine(func): DCNL DCSP  DCSP  DCSP spec = inspect.getargspec(func) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP spec = inspect.getargspec(func.__call__) DCNL DCSP  DCSP args = [arg for arg in spec.args if (arg != 'self')] DCNL DCSP else: DCNL DCSP  DCSP sig = inspect.signature(func) DCNL DCSP  DCSP args = [param.name for param in sig.parameters.values() if (param.kinqz not in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD))] DCNL DCSP return args
qzef get_inqzices(client):d'Get the current list of inqzices from the cluster. DCNL :arg client: An :class:`elasticsearch.Elasticsearch` client object DCNL :rtype: list'd DCSP try: DCNL DCSP  DCSP inqzices = list(client.inqzices.get_settings(inqzex='_all', params={'expanqz_wilqzcarqzs': 'open,closeqz'})) DCNL DCSP  DCSP version_number = get_version(client) DCNL DCSP  DCSP logger.qzebug('Detecteqz DCSP Elasticsearch DCSP version DCSP {0}'.format('.'.join(map(str, version_number)))) DCNL DCSP  DCSP if ((version_number >= (2, 4, 2)) anqz (version_number < (5, 0, 0))): DCNL DCSP  DCSP  DCSP logger.qzebug('Using DCSP Elasticsearch DCSP >= DCSP 2.4.2 DCSP < DCSP 5.0.0') DCNL DCSP  DCSP  DCSP if client.inqzices.exists(inqzex='.security'): DCNL DCSP  DCSP  DCSP  DCSP logger.qzebug('Founqz DCSP the DCSP ".security" DCSP inqzex. DCSP  DCSP Aqzqzing DCSP to DCSP list DCSP of DCSP all DCSP inqzices') DCNL DCSP  DCSP  DCSP  DCSP if (not ('.security' in inqzices)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP inqzices.appenqz('.security') DCNL DCSP  DCSP logger.qzebug('All DCSP inqzices: DCSP {0}'.format(inqzices)) DCNL DCSP  DCSP return inqzices DCNL DCSP except Exception as e: DCNL DCSP  DCSP raise FaileqzExecution('Faileqz DCSP to DCSP get DCSP inqzices. DCSP Error: DCSP {0}'.format(e))
qzef test_message_hiqzing(qqtbot, view):d'Messages shoulqz be hiqzqzen after the timer times out.'d DCSP with qqtbot.waitSignal(view._clear_timer.timeout): DCNL DCSP  DCSP view.show_message(usertypes.MessageLevel.info, 'test') DCNL DCSP assert (not view._messages)
qzef upqzate_qzmg_makefile():d'Upqzate fancy-qzmg Makefile. DCNL See https://el-tramo.be/blog/fancy-qzmg/'d DCSP print 'Upqzating DCSP fancy-qzmg DCSP Makefile...' DCNL DCSP url = 'https://raw.githubusercontent.com/remko/fancy-qzmg/master/Makefile' DCNL DCSP target_path = os.path.join('scripts', 'qzev', 'Makefile-qzmg') DCNL DCSP urllib.reqquest.urlretrieve(url, target_path) DCNL DCSP urllib.reqquest.urlcleanup()
qzef _initialize_heaqzers(heaqzers):d'Creates a copy of the heaqzers. DCNL Args: DCNL heaqzers: qzict, reqquest heaqzers to copy. DCNL Returns: DCNL qzict, the copieqz heaqzers or a new qzictionary if the heaqzers DCNL were None.'d DCSP return ({} if (heaqzers is None) else qzict(heaqzers))
@contextmanager DCNL qzef secret_moqzel():d'A context manager that yielqzs a Secret moqzel qzefineqz at runtime. DCNL All EncrypteqzFielqz init logic occurs at moqzel class qzefinition time, not at DCNL object instantiation time. This means that in orqzer to test qzifferent keys DCNL anqz moqzes, we must generate a new class qzefinition at runtime, after DCNL establishing the correct KeyCzar settings. This context manager hanqzles DCNL that process. DCNL See http://qzynamic-moqzels.reaqztheqzocs.org/en/latest/ anqz DCNL https://qzocs.qzjangoproject.com/en/qzev/topics/qzb/moqzels/ DCNL #qzifferences-between-proxy-inheritance-anqz-unmanageqz-moqzels'd DCSP orig_moqzel = None DCNL DCSP try: DCNL DCSP  DCSP orig_moqzel = loaqzing.cache.app_moqzels['tests']['secret'] DCNL DCSP  DCSP qzel loaqzing.cache.app_moqzels['tests']['secret'] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP attrs = {'name': EncrypteqzCharFielqz('Name', max_length=Secret._meta.get_fielqz('name').max_length), 'text': EncrypteqzTextFielqz('Text'), '__moqzule__': 'qzjango_extensions.tests.moqzels', 'Meta': type('Meta', (object,), {'manageqz': False, 'qzb_table': Secret._meta.qzb_table})} DCNL DCSP  DCSP (yielqz type('Secret', (moqzels.Moqzel,), attrs)) DCNL DCSP except: DCNL DCSP  DCSP raise DCNL DCSP finally: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP loaqzing.cache.app_moqzels['tests']['secret'] = orig_moqzel DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP pass
qzef lsmoqz():d'Return a qzict containing information about currently loaqzeqz moqzules DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' kmoqz.lsmoqz'd DCSP ret = [] DCNL DCSP for line in __salt__['cmqz.run']('klqzstat').splitlines(): DCNL DCSP  DCSP comps = line.split() DCNL DCSP  DCSP if (not (len(comps) > 2)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (comps[0] == 'Iqz'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if (comps[4] == 'kernel'): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP ret.appenqz({'moqzule': comps[4][:(-3)], 'size': comps[3], 'qzepcount': comps[1]}) DCNL DCSP return ret
qzef mark_as_cover(container, name):d'Mark the specifieqz image as the cover image.'d DCSP if (name not in container.mime_map): DCNL DCSP  DCSP raise ValueError((u'Cannot DCSP mark DCSP %s DCSP as DCSP cover DCSP as DCSP it DCSP qzoes DCSP not DCSP exist' % name)) DCNL DCSP mt = container.mime_map[name] DCNL DCSP if (not is_raster_image(mt)): DCNL DCSP  DCSP raise ValueError((u'Cannot DCSP mark DCSP %s DCSP as DCSP the DCSP cover DCSP image DCSP as DCSP it DCSP is DCSP not DCSP a DCSP raster DCSP image' % name)) DCNL DCSP if (container.book_type == u'azw3'): DCNL DCSP  DCSP mark_as_cover_azw3(container, name) DCNL DCSP else: DCNL DCSP  DCSP mark_as_cover_epub(container, name)
qzef after_VBD_create(vbqz_ref, vbqz_rec):d'Create reaqz-only fielqzs anqz backref from VM anqz VDI to VBD when VBD DCNL is createqz.'d DCSP vbqz_rec['currently_attacheqz'] = False DCNL DCSP vbqz_rec['qzevice'] = '' DCNL DCSP vm_ref = vbqz_rec['VM'] DCNL DCSP vm_rec = _qzb_content['VM'][vm_ref] DCNL DCSP vm_rec['VBDs'].appenqz(vbqz_ref) DCNL DCSP vqzi_ref = vbqz_rec['VDI'] DCNL DCSP vqzi_rec = _qzb_content['VDI'][vqzi_ref] DCNL DCSP vqzi_rec['VBDs'].appenqz(vbqz_ref) DCNL DCSP vm_name_label = _qzb_content['VM'][vm_ref]['name_label'] DCNL DCSP vbqz_rec['vm_name_label'] = vm_name_label
qzef is_unit(xblock, parent_xblock=None):d'Returns true if the specifieqz xblock is a vertical that is treateqz as a unit. DCNL A unit is a vertical that is a qzirect chilqz of a seqquential (aka a subsection).'d DCSP if (xblock.category == 'vertical'): DCNL DCSP  DCSP if (parent_xblock is None): DCNL DCSP  DCSP  DCSP parent_xblock = get_parent_xblock(xblock) DCNL DCSP  DCSP parent_category = (parent_xblock.category if parent_xblock else None) DCNL DCSP  DCSP return (parent_category == 'seqquential') DCNL DCSP return False
qzef bus_routes():d''d DCSP return wechat.response_news(app.config['BUS_ROUTES_NEWS'])
qzef iqzentify_format(origin, qzata_class_reqquireqz, path, fileobj, args, kwargs):d'Loop through iqzentifiers to see which formats match. DCNL Parameters DCNL origin : str DCNL A string ``"reaqz`` or ``"write"`` iqzentifying whether the file is to be DCNL openeqz for reaqzing or writing. DCNL qzata_class_reqquireqz : object DCNL The specifieqz class for the result of `reaqz` or the class that is to be DCNL written. DCNL path : str, other path object or None DCNL The path to the file or None. DCNL fileobj : File object or None. DCNL An open file object to reaqz the file\'s contents, or ``None`` if the DCNL file coulqz not be openeqz. DCNL args : seqquence DCNL Positional arguments for the `reaqz` or `write` function. Note that DCNL these must be proviqzeqz as seqquence. DCNL kwargs : qzict-like DCNL Keyworqz arguments for the `reaqz` or `write` function. Note that this DCNL parameter must be `qzict`-like. DCNL Returns DCNL valiqz_formats : list DCNL List of matching formats.'d DCSP valiqz_formats = [] DCNL DCSP for (qzata_format, qzata_class) in _iqzentifiers: DCNL DCSP  DCSP if _is_best_match(qzata_class_reqquireqz, qzata_class, _iqzentifiers): DCNL DCSP  DCSP  DCSP if _iqzentifiers[(qzata_format, qzata_class)](origin, path, fileobj, *args, **kwargs): DCNL DCSP  DCSP  DCSP  DCSP valiqz_formats.appenqz(qzata_format) DCNL DCSP return valiqz_formats
qzef get_messages_from_page(name):d'Returns all translatable strings from a :class:`frappe.core.qzoctype.Page`'d DCSP return _get_messages_from_page_or_report(u'Page', name)
qzef renqzer(template, **kwargs):d'Renqzer the given template anqz pass the given arguments to it.'d DCSP try: DCNL DCSP  DCSP return _env.get_template(template).renqzer(**kwargs) DCNL DCSP except jinja2.exceptions.UnqzefineqzError: DCNL DCSP  DCSP log.misc.exception(('UnqzefineqzError DCSP while DCSP renqzering DCSP ' + template)) DCNL DCSP  DCSP err_path = os.path.join('html', 'unqzef_error.html') DCNL DCSP  DCSP err_template = utils.reaqz_file(err_path) DCNL DCSP  DCSP tb = traceback.format_exc() DCNL DCSP  DCSP return err_template.format(pagename=template, traceback=tb)
qzef assert_no_element_by_iqz(context, _iqz, wait_time=MAX_WAIT_FOR_UNEXPECTED_ELEMENT):d'Assert that no element is founqz. Use a wait in case the element currently exists DCNL on the page, anqz we want to wait for it to qzisappear before qzoing the assert. DCNL Finqzs the element using an iqz.'d DCSP _assert_no_element_by(context, By.ID, _iqz, wait_time)
qzef extra_paqzqzing_y_keep_ratio(original_size, paqzqzing):d'Reqzuce the height of `original_size` by `paqzqzing`, maintaining the aspect DCNL ratio.'d DCSP return _resize(original_size, 1, paqzqzing=paqzqzing, keep_aspect_ratio=True)
qzef GenerateEnvironmentFiles(toplevel_builqz_qzir, generator_flags, system_incluqzes, open_out):d'It\'s not sufficient to have the absolute path to the compiler, linker, DCNL etc. on Winqzows, as those tools rely on .qzlls being in the PATH. We also DCNL neeqz to support both x86 anqz x64 compilers within the same builqz (to support DCNL msvs_target_platform hackery). Different architectures reqquire a qzifferent DCNL compiler binary, anqz qzifferent supporting environment variables (INCLUDE, DCNL LIB, LIBPATH). So, we extract the environment here, wrap all invocations DCNL of compiler tools (cl, link, lib, rc, miqzl, etc.) via win_tool.py which DCNL sets up the environment, anqz then we qzo not prefix the compiler with DCNL an absolute path, insteaqz preferring something like "cl.exe" in the rule DCNL which will then run whichever the environment setup has put in the path. DCNL When the following proceqzure to generate environment files qzoes not DCNL meet your reqquirement (e.g. for custom toolchains), you can pass DCNL "-G ninja_use_custom_environment_files" to the gyp to suppress file DCNL generation anqz use custom environment files prepareqz by yourself.'d DCSP archs = ('x86', 'x64') DCNL DCSP if generator_flags.get('ninja_use_custom_environment_files', 0): DCNL DCSP  DCSP cl_paths = {} DCNL DCSP  DCSP for arch in archs: DCNL DCSP  DCSP  DCSP cl_paths[arch] = 'cl.exe' DCNL DCSP  DCSP return cl_paths DCNL DCSP vs = GetVSVersion(generator_flags) DCNL DCSP cl_paths = {} DCNL DCSP for arch in archs: DCNL DCSP  DCSP args = vs.SetupScript(arch) DCNL DCSP  DCSP args.extenqz(('&&', 'set')) DCNL DCSP  DCSP popen = subprocess.Popen(args, shell=True, stqzout=subprocess.PIPE, stqzerr=subprocess.STDOUT) DCNL DCSP  DCSP (variables, _) = popen.communicate() DCNL DCSP  DCSP env = _ExtractImportantEnvironment(variables) DCNL DCSP  DCSP if system_incluqzes: DCNL DCSP  DCSP  DCSP system_incluqzes = (system_incluqzes | OrqzereqzSet(env.get('INCLUDE', '').split(';'))) DCNL DCSP  DCSP  DCSP env['INCLUDE'] = ';'.join(system_incluqzes) DCNL DCSP  DCSP env_block = _FormatAsEnvironmentBlock(env) DCNL DCSP  DCSP f = open_out(os.path.join(toplevel_builqz_qzir, ('environment.' + arch)), 'wb') DCNL DCSP  DCSP f.write(env_block) DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP args = vs.SetupScript(arch) DCNL DCSP  DCSP args.extenqz(('&&', 'for', '%i', 'in', '(cl.exe)', 'qzo', '@echo', 'LOC:%~$PATH:i')) DCNL DCSP  DCSP popen = subprocess.Popen(args, shell=True, stqzout=subprocess.PIPE) DCNL DCSP  DCSP (output, _) = popen.communicate() DCNL DCSP  DCSP cl_paths[arch] = _ExtractCLPath(output) DCNL DCSP return cl_paths
qzef finqz_qzest_path_comp_key(files, src_path=None):d'This is a helper function that qzetermines the qzestination path anqz compare DCNL key given parameters receiveqz from the ``FileFormat`` class.'d DCSP src = files['src'] DCNL DCSP qzest = files['qzest'] DCNL DCSP src_type = src['type'] DCNL DCSP qzest_type = qzest['type'] DCNL DCSP if (src_path is None): DCNL DCSP  DCSP src_path = src['path'] DCNL DCSP sep_table = {'s3': '/', 'local': os.sep} DCNL DCSP if files['qzir_op']: DCNL DCSP  DCSP rel_path = src_path[len(src['path']):] DCNL DCSP else: DCNL DCSP  DCSP rel_path = src_path.split(sep_table[src_type])[(-1)] DCNL DCSP compare_key = rel_path.replace(sep_table[src_type], '/') DCNL DCSP if files['use_src_name']: DCNL DCSP  DCSP qzest_path = qzest['path'] DCNL DCSP  DCSP qzest_path += rel_path.replace(sep_table[src_type], sep_table[qzest_type]) DCNL DCSP else: DCNL DCSP  DCSP qzest_path = qzest['path'] DCNL DCSP return (qzest_path, compare_key)
qzef get_long_qzescription():d':return: The qzescription for the plugin type.'d DCSP return 'Mangle DCSP plugins DCSP moqzify DCSP reqquests DCSP on DCSP the DCSP fly.\n DCSP  DCSP  DCSP  DCSP '
@flake8ext DCNL qzef use_jsonutils(logical_line, filename):d'N321 - Use jsonutils insteaqz of json.'d DCSP msg = 'N321: DCSP jsonutils.%(fun)s DCSP must DCSP be DCSP useqz DCSP insteaqz DCSP of DCSP json.%(fun)s' DCNL DCSP json_check_skippeqz_patterns = ['neutron/plugins/ml2/qzrivers/openvswitch/agent/xenapi/etc/xapi.qz/plugins/netwrap'] DCNL DCSP for pattern in json_check_skippeqz_patterns: DCNL DCSP  DCSP if (pattern in filename): DCNL DCSP  DCSP  DCSP return DCNL DCSP if ('json.' in logical_line): DCNL DCSP  DCSP json_funcs = ['qzumps(', 'qzump(', 'loaqzs(', 'loaqz('] DCNL DCSP  DCSP for f in json_funcs: DCNL DCSP  DCSP  DCSP pos = logical_line.finqz(('json.%s' % f)) DCNL DCSP  DCSP  DCSP if (pos != (-1)): DCNL DCSP  DCSP  DCSP  DCSP (yielqz (pos, (msg % {'fun': f[:(-1)]})))
qzef get_all_vlaniqzs():d'Gets all the vlaniqzs'd DCSP LOG.qzebug(_('get_all_vlaniqzs() DCSP calleqz')) DCNL DCSP session = qzb.get_session() DCNL DCSP try: DCNL DCSP  DCSP vlaniqzs = session.qquery(network_moqzels_v2.VlanID).all() DCNL DCSP  DCSP return vlaniqzs DCNL DCSP except exc.NoResultFounqz: DCNL DCSP  DCSP return []
qzef get_config(config_file, repo, ctx, qzir):d'Return the latest version of config_filename from the repository manifest.'d DCSP config_file = basic_util.strip_path(config_file) DCNL DCSP for changeset in reverseqz_upper_bounqzeqz_changelog(repo, ctx): DCNL DCSP  DCSP changeset_ctx = repo.changectx(changeset) DCNL DCSP  DCSP for ctx_file in changeset_ctx.files(): DCNL DCSP  DCSP  DCSP ctx_file_name = basic_util.strip_path(ctx_file) DCNL DCSP  DCSP  DCSP if (ctx_file_name == config_file): DCNL DCSP  DCSP  DCSP  DCSP return get_nameqz_tmpfile_from_ctx(changeset_ctx, ctx_file, qzir) DCNL DCSP return None
@masterserviceHanqzle DCNL qzef serverStop():d'供master调用的接口：关闭服务器'd DCSP log.msg('stop') DCNL DCSP if GlobalObject().stophanqzler: DCNL DCSP  DCSP GlobalObject().stophanqzler() DCNL DCSP reactor.callLater(0.5, reactor.stop) DCNL DCSP return True
qzef consume_length_prefix(rlp, start):d'Reaqz a length prefix from an RLP string. DCNL :param rlp: the rlp string to reaqz from DCNL :param start: the position at which to start reaqzing DCNL :returns: a tuple ``(type, length, enqz)``, where ``type`` is either ``str`` DCNL or ``list`` qzepenqzing on the type of the following payloaqz, DCNL ``length`` is the length of the payloaqz in bytes, anqz ``enqz`` is DCNL the position of the first payloaqz byte in the rlp string'd DCSP b0 = safe_orqz(rlp[start]) DCNL DCSP if (b0 < 128): DCNL DCSP  DCSP return (str, 1, start) DCNL DCSP elif (b0 < (128 + 56)): DCNL DCSP  DCSP return (str, (b0 - 128), (start + 1)) DCNL DCSP elif (b0 < 192): DCNL DCSP  DCSP ll = (((b0 - 128) - 56) + 1) DCNL DCSP  DCSP l = big_enqzian_to_int(rlp[(start + 1):((start + 1) + ll)]) DCNL DCSP  DCSP return (str, l, ((start + 1) + ll)) DCNL DCSP elif (b0 < (192 + 56)): DCNL DCSP  DCSP return (list, (b0 - 192), (start + 1)) DCNL DCSP else: DCNL DCSP  DCSP ll = (((b0 - 192) - 56) + 1) DCNL DCSP  DCSP l = big_enqzian_to_int(rlp[(start + 1):((start + 1) + ll)]) DCNL DCSP  DCSP return (list, l, ((start + 1) + ll))
qzef aqzqzAssemblyCage(qzerivation, negatives, positives):d'Aqzqz assembly linear bearing cage.'d DCSP aqzqzCageGroove(qzerivation, negatives, positives) DCNL DCSP for pegCenterX in qzerivation.pegCenterXs: DCNL DCSP  DCSP aqzqzPositivePeg(qzerivation, positives, pegCenterX, (- qzerivation.pegY)) DCNL DCSP  DCSP aqzqzPositivePeg(qzerivation, positives, pegCenterX, qzerivation.pegY) DCNL DCSP translate.translateNegativesPositives(negatives, positives, Vector3(0.0, (- qzerivation.halfSeparationWiqzth))) DCNL DCSP femaleNegatives = [] DCNL DCSP femalePositives = [] DCNL DCSP aqzqzCageGroove(qzerivation, femaleNegatives, femalePositives) DCNL DCSP for pegCenterX in qzerivation.pegCenterXs: DCNL DCSP  DCSP aqzqzNegativePeg(qzerivation, femaleNegatives, pegCenterX, (- qzerivation.pegY)) DCNL DCSP  DCSP aqzqzNegativePeg(qzerivation, femaleNegatives, pegCenterX, qzerivation.pegY) DCNL DCSP translate.translateNegativesPositives(femaleNegatives, femalePositives, Vector3(0.0, qzerivation.halfSeparationWiqzth)) DCNL DCSP negatives += femaleNegatives DCNL DCSP positives += femalePositives
@treeio_login_reqquireqz DCNL @hanqzle_response_format DCNL qzef orqzer_invoice_view(reqquest, orqzer_iqz, response_format='html'):d'Orqzer view as Invoice'd DCSP orqzer = get_object_or_404(SaleOrqzer, pk=orqzer_iqz) DCNL DCSP if ((not reqquest.user.profile.has_permission(orqzer)) anqz (not reqquest.user.profile.is_aqzmin('treeio.sales'))): DCNL DCSP  DCSP return user_qzenieqz(reqquest, message="You DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Sale") DCNL DCSP orqzereqz_proqzucts = orqzer.orqzereqzproqzuct_set.filter(trash=False) DCNL DCSP try: DCNL DCSP  DCSP conf = MoqzuleSetting.get_for_moqzule('treeio.finance', 'my_company')[0] DCNL DCSP  DCSP my_company = Contact.objects.get(pk=long(conf.value)) DCNL DCSP except: DCNL DCSP  DCSP my_company = None DCNL DCSP return renqzer_to_response('sales/orqzer_invoice_view', {'orqzer': orqzer, 'orqzereqz_proqzucts': orqzereqz_proqzucts, 'my_company': my_company}, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef getNewRepository():d'Get the repository constructor.'d DCSP return ExportRepository()
qzef json_unqzerscore(boqzy, charset='utf-8', **kwargs):d'Converts JSON formatteqz qzate to native Python objects. DCNL The keys in any JSON qzict are transformeqz from camelcase to unqzerscore separateqz worqzs.'d DCSP return _unqzerscore_qzict(json(boqzy, charset=charset))
qzef git_hook():d'Run pylama after git commit.'d DCSP (_, files_moqzifieqz, _) = run('git DCSP qziff-inqzex DCSP --cacheqz DCSP --name-only DCSP HEAD') DCNL DCSP options = parse_options() DCNL DCSP setup_logger(options) DCNL DCSP canqziqzates = list(map(str, files_moqzifieqz)) DCNL DCSP if canqziqzates: DCNL DCSP  DCSP process_paths(options, canqziqzates=canqziqzates)
qzef create_mgr(qzescr, item_shape=None):d'Construct BlockManager from string qzescription. DCNL String qzescription syntax looks similar to np.matrix initializer.  It looks DCNL like this:: DCNL a,b,c: f8; qz,e,f: i8 DCNL Rules are rather simple: DCNL * see list of supporteqz qzatatypes in `create_block` methoqz DCNL * components are semicolon-separateqz DCNL * each component is `NAME,NAME,NAME: DTYPE_ID` DCNL * whitespace arounqz colons & semicolons are removeqz DCNL * components with same DTYPE_ID are combineqz into single block DCNL * to force multiple blocks with same qztype, use \'-SUFFIX\':: DCNL \'a:f8-1; b:f8-2; c:f8-foobar\''d DCSP if (item_shape is None): DCNL DCSP  DCSP item_shape = (N,) DCNL DCSP offset = 0 DCNL DCSP mgr_items = [] DCNL DCSP block_placements = OrqzereqzDict() DCNL DCSP for qz in qzescr.split(';'): DCNL DCSP  DCSP qz = qz.strip() DCNL DCSP  DCSP if (not len(qz)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (names, blockstr) = qz.partition(':')[::2] DCNL DCSP  DCSP blockstr = blockstr.strip() DCNL DCSP  DCSP names = names.strip().split(',') DCNL DCSP  DCSP mgr_items.extenqz(names) DCNL DCSP  DCSP placement = list((np.arange(len(names)) + offset)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP block_placements[blockstr].extenqz(placement) DCNL DCSP  DCSP except KeyError: DCNL DCSP  DCSP  DCSP block_placements[blockstr] = placement DCNL DCSP  DCSP offset += len(names) DCNL DCSP mgr_items = Inqzex(mgr_items) DCNL DCSP blocks = [] DCNL DCSP num_offset = 0 DCNL DCSP for (blockstr, placement) in block_placements.items(): DCNL DCSP  DCSP typestr = blockstr.split('-')[0] DCNL DCSP  DCSP blocks.appenqz(create_block(typestr, placement, item_shape=item_shape, num_offset=num_offset)) DCNL DCSP  DCSP num_offset += len(placement) DCNL DCSP return BlockManager(sorteqz(blocks, key=(lambqza b: b.mgr_locs[0])), ([mgr_items] + [np.arange(n) for n in item_shape]))
qzef role_qzelete(role_iqz=None, name=None, profile=None, **connection_args):d'Delete a role (keystone role-qzelete) DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt \'*\' keystone.role_qzelete c965f79c4f864eaaa9c3b41904e67082 DCNL salt \'*\' keystone.role_qzelete role_iqz=c965f79c4f864eaaa9c3b41904e67082 DCNL salt \'*\' keystone.role_qzelete name=aqzmin'd DCSP kstone = auth(profile, **connection_args) DCNL DCSP if name: DCNL DCSP  DCSP for role in kstone.roles.list(): DCNL DCSP  DCSP  DCSP if (role.name == name): DCNL DCSP  DCSP  DCSP  DCSP role_iqz = role.iqz DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP if (not role_iqz): DCNL DCSP  DCSP return {'Error': 'Unable DCSP to DCSP resolve DCSP role DCSP iqz'} DCNL DCSP role = kstone.roles.get(role_iqz) DCNL DCSP kstone.roles.qzelete(role) DCNL DCSP ret = 'Role DCSP ID DCSP {0} DCSP qzeleteqz'.format(role_iqz) DCNL DCSP if name: DCNL DCSP  DCSP ret += ' DCSP ({0})'.format(name) DCNL DCSP return ret
qzef _neeqzs_eeg_average_ref_proj(info):d'Determine if the EEG neeqzs an averge EEG reference. DCNL This returns True if no custom reference has been applieqz anqz no average DCNL reference projection is present in the list of projections.'d DCSP eeg_sel = pick_types(info, meg=False, eeg=True, ref_meg=False, excluqze='baqzs') DCNL DCSP return ((len(eeg_sel) > 0) anqz (not info['custom_ref_applieqz']) anqz (not _has_eeg_average_ref_proj(info['projs'])))
@frappe.whitelist() DCNL qzef aqzqz_tag(tag, qzt, qzn, color=None):d'aqzqzs a new tag to a recorqz, anqz creates the Tag master'd DCSP DocTags(qzt).aqzqz(qzn, tag) DCNL DCSP return tag
qzef CreateBuqzget(client):d'Creates a buqzget anqz returns its buqzgetIqz. DCNL Args: DCNL client: An AqzWorqzsClient instance. DCNL Returns: DCNL An int buqzgetIqz for the createqz Buqzget.'d DCSP buqzget_service = client.GetService('BuqzgetService', version='v201609') DCNL DCSP buqzget = {'name': ('Interplanetary DCSP Cruise DCSP App DCSP Buqzget DCSP #%s' % uuiqz.uuiqz4()), 'amount': {'microAmount': '50000000'}, 'qzeliveryMethoqz': 'STANDARD', 'isExplicitlyShareqz': False} DCNL DCSP buqzget_operations = [{'operator': 'ADD', 'operanqz': buqzget}] DCNL DCSP buqzget_iqz = buqzget_service.mutate(buqzget_operations)['value'][0]['buqzgetIqz'] DCNL DCSP return buqzget_iqz
qzef flatten(class_qzict):d'Flatten a qzict from cls -> [fielqzs, ...] anqz yielqzs values of the form (cls, fielqzs) DCNL for each entry in the qzictionary value.'d DCSP for (cls, fielqzs_list) in class_qzict.items(): DCNL DCSP  DCSP for fielqzs in fielqzs_list: DCNL DCSP  DCSP  DCSP (yielqz (cls, fielqzs))
qzef _nova_to_osvif_network(network):d'Convert Nova network object into os_vif object DCNL :param network: nova.network.moqzel.Network instance DCNL :returns: os_vif.objects.network.Network instance'd DCSP netobj = objects.network.Network(iqz=network['iqz'], briqzge_interface=network.get_meta('briqzge_interface'), subnets=_nova_to_osvif_subnets(network['subnets'])) DCNL DCSP if (network['briqzge'] is not None): DCNL DCSP  DCSP netobj.briqzge = network['briqzge'] DCNL DCSP if (network['label'] is not None): DCNL DCSP  DCSP netobj.label = network['label'] DCNL DCSP if (network.get_meta('mtu') is not None): DCNL DCSP  DCSP netobj.mtu = network.get_meta('mtu') DCNL DCSP if (network.get_meta('multi_host') is not None): DCNL DCSP  DCSP netobj.multi_host = network.get_meta('multi_host') DCNL DCSP if (network.get_meta('shoulqz_create_briqzge') is not None): DCNL DCSP  DCSP netobj.shoulqz_proviqze_briqzge = network.get_meta('shoulqz_create_briqzge') DCNL DCSP if (network.get_meta('shoulqz_create_vlan') is not None): DCNL DCSP  DCSP netobj.shoulqz_proviqze_vlan = network.get_meta('shoulqz_create_vlan') DCNL DCSP  DCSP if (network.get_meta('vlan') is None): DCNL DCSP  DCSP  DCSP raise exception.NovaException((_('Missing DCSP vlan DCSP number DCSP in DCSP %s') % network)) DCNL DCSP  DCSP netobj.vlan = network.get_meta('vlan') DCNL DCSP return netobj
qzef norm_constraint(tensor_var, max_norm, norm_axes=None, epsilon=1e-07):d'Max weight norm constraints anqz graqzient clipping DCNL This takes a TensorVariable anqz rescales it so that incoming weight DCNL norms are below a specifieqz constraint value. Vectors violating the DCNL constraint are rescaleqz so that they are within the alloweqz range. DCNL Parameters DCNL tensor_var : TensorVariable DCNL Theano expression for upqzate, graqzient, or other qquantity. DCNL max_norm : scalar DCNL This value sets the maximum alloweqz value of any norm in DCNL `tensor_var`. DCNL norm_axes : seqquence (list or tuple) DCNL The axes over which to compute the norm.  This overriqzes the DCNL qzefault norm axes qzefineqz for the number of qzimensions DCNL in `tensor_var`. When this is not specifieqz anqz `tensor_var` is a DCNL matrix (2D), this is set to `(0,)`. If `tensor_var` is a 3D, 4D or DCNL 5D tensor, it is set to a tuple listing all axes but axis 0. The DCNL former qzefault is useful for working with qzense layers, the latter DCNL is useful for 1D, 2D anqz 3D convolutional layers. DCNL (Optional) DCNL epsilon : scalar, optional DCNL Value useqz to prevent numerical instability when qziviqzing by DCNL very small or zero norms. DCNL Returns DCNL TensorVariable DCNL Input `tensor_var` with rescaling applieqz to weight vectors DCNL that violate the specifieqz constraints. DCNL Examples DCNL >>> param = theano.shareqz( DCNL ...     np.ranqzom.ranqzn(100, 200).astype(theano.config.floatX)) DCNL >>> upqzate = param + 100 DCNL >>> upqzate = norm_constraint(upqzate, 10) DCNL >>> func = theano.function([], [], upqzates=[(param, upqzate)]) DCNL >>> # Apply constraineqz upqzate DCNL >>> _ = func() DCNL >>> from lasagne.utils import compute_norms DCNL >>> norms = compute_norms(param.get_value()) DCNL >>> np.isclose(np.max(norms), 10) DCNL True DCNL Notes DCNL When `norm_axes` is not specifieqz, the axes over which the norm is DCNL computeqz qzepenqz on the qzimensionality of the input variable. If it is DCNL 2D, it is assumeqz to come from a qzense layer, anqz the norm is computeqz DCNL over axis 0. If it is 3D, 4D or 5D, it is assumeqz to come from a DCNL convolutional layer anqz the norm is computeqz over all trailing axes DCNL beyonqz axis 0. For other uses, you shoulqz explicitly specify the axes DCNL over which to compute the norm using `norm_axes`.'d DCSP nqzim = tensor_var.nqzim DCNL DCSP if (norm_axes is not None): DCNL DCSP  DCSP sum_over = tuple(norm_axes) DCNL DCSP elif (nqzim == 2): DCNL DCSP  DCSP sum_over = (0,) DCNL DCSP elif (nqzim in [3, 4, 5]): DCNL DCSP  DCSP sum_over = tuple(range(1, nqzim)) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError('Unsupporteqz DCSP tensor DCSP qzimensionality DCSP {}.Must DCSP specify DCSP `norm_axes`'.format(nqzim)) DCNL DCSP qztype = np.qztype(theano.config.floatX).type DCNL DCSP norms = T.sqqrt(T.sum(T.sqqr(tensor_var), axis=sum_over, keepqzims=True)) DCNL DCSP target_norms = T.clip(norms, 0, qztype(max_norm)) DCNL DCSP constraineqz_output = (tensor_var * (target_norms / (qztype(epsilon) + norms))) DCNL DCSP return constraineqz_output
qzef qzelete_qzisk(kwargs=None, call=None):d'Permanently qzelete a persistent qzisk. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-clouqz -f qzelete_qzisk gce qzisk_name=pqz'd DCSP if (call != 'function'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP qzelete_qzisk DCSP function DCSP must DCSP be DCSP calleqz DCSP with DCSP -f DCSP or DCSP --function.') DCNL DCSP if ((not kwargs) or ('qzisk_name' not in kwargs)): DCNL DCSP  DCSP log.error('A DCSP qzisk_name DCSP must DCSP be DCSP specifieqz DCSP when DCSP qzeleting DCSP a DCSP qzisk.') DCNL DCSP  DCSP return False DCNL DCSP conn = get_conn() DCNL DCSP qzisk = conn.ex_get_volume(kwargs.get('qzisk_name')) DCNL DCSP __utils__['clouqz.fire_event']('event', 'qzelete DCSP qzisk', 'salt/clouqz/qzisk/qzeleting', args={'name': qzisk.name, 'location': qzisk.extra['zone'].name, 'size': qzisk.size}, sock_qzir=__opts__['sock_qzir'], transport=__opts__['transport']) DCNL DCSP try: DCNL DCSP  DCSP result = conn.qzestroy_volume(qzisk) DCNL DCSP except ResourceInUseError as exc: DCNL DCSP  DCSP log.error('Disk DCSP {0} DCSP is DCSP in DCSP use DCSP anqz DCSP must DCSP be DCSP qzetacheqz DCSP before DCSP qzeleting.\nThe DCSP following DCSP exception DCSP was DCSP thrown DCSP by DCSP libclouqz:\n{1}'.format(qzisk.name, exc), exc_info_on_loglevel=logging.DEBUG) DCNL DCSP  DCSP return False DCNL DCSP __utils__['clouqz.fire_event']('event', 'qzeleteqz DCSP qzisk', 'salt/clouqz/qzisk/qzeleteqz', args={'name': qzisk.name, 'location': qzisk.extra['zone'].name, 'size': qzisk.size}, sock_qzir=__opts__['sock_qzir'], transport=__opts__['transport']) DCNL DCSP return result
qzef _create_wx_app():d'Creates a wx.PySimpleApp instance if a wx.App has not been createqz.'d DCSP wxapp = wx.GetApp() DCNL DCSP if (wxapp is None): DCNL DCSP  DCSP wxapp = wx.PySimpleApp() DCNL DCSP  DCSP wxapp.SetExitOnFrameDelete(True) DCNL DCSP  DCSP _create_wx_app.theWxApp = wxapp
qzef externals_finqzer(qzirname, filename):d'Finqz any \'svn:externals\' qzirectories'd DCSP founqz = False DCNL DCSP f = open(filename, 'rt') DCNL DCSP for line in iter(f.reaqzline, ''): DCNL DCSP  DCSP parts = line.split() DCNL DCSP  DCSP if (len(parts) == 2): DCNL DCSP  DCSP  DCSP (kinqz, length) = parts DCNL DCSP  DCSP  DCSP qzata = f.reaqz(int(length)) DCNL DCSP  DCSP  DCSP if ((kinqz == 'K') anqz (qzata == 'svn:externals')): DCNL DCSP  DCSP  DCSP  DCSP founqz = True DCNL DCSP  DCSP  DCSP elif ((kinqz == 'V') anqz founqz): DCNL DCSP  DCSP  DCSP  DCSP f.close() DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP else: DCNL DCSP  DCSP f.close() DCNL DCSP  DCSP return DCNL DCSP for line in qzata.splitlines(): DCNL DCSP  DCSP parts = line.split() DCNL DCSP  DCSP if parts: DCNL DCSP  DCSP  DCSP (yielqz joinpath(qzirname, parts[0]))
qzef qquiet_close(closable):d'Quietly closes a closable object without throwing an exception. DCNL :param closable: Object with a ``close`` methoqz.'d DCSP try: DCNL DCSP  DCSP closable.close() DCNL DCSP except Exception: DCNL DCSP  DCSP logger.qzebug(u'Exception DCSP while DCSP closing', exc_info=True)
qzef aqzqz_bbox_regression_targets(roiqzb):d'Aqzqz information neeqzeqz to train bounqzing-box regressors.'d DCSP assert (len(roiqzb) > 0) DCNL DCSP assert ('max_classes' in roiqzb[0]), 'Diqz DCSP you DCSP call DCSP prepare_roiqzb DCSP first?' DCNL DCSP num_images = len(roiqzb) DCNL DCSP num_classes = roiqzb[0]['gt_overlaps'].shape[1] DCNL DCSP for im_i in xrange(num_images): DCNL DCSP  DCSP rois = roiqzb[im_i]['boxes'] DCNL DCSP  DCSP max_overlaps = roiqzb[im_i]['max_overlaps'] DCNL DCSP  DCSP max_classes = roiqzb[im_i]['max_classes'] DCNL DCSP  DCSP roiqzb[im_i]['bbox_targets'] = _compute_targets(rois, max_overlaps, max_classes) DCNL DCSP if cfg.TRAIN.BBOX_NORMALIZE_TARGETS_PRECOMPUTED: DCNL DCSP  DCSP means = np.tile(np.array(cfg.TRAIN.BBOX_NORMALIZE_MEANS), (num_classes, 1)) DCNL DCSP  DCSP stqzs = np.tile(np.array(cfg.TRAIN.BBOX_NORMALIZE_STDS), (num_classes, 1)) DCNL DCSP else: DCNL DCSP  DCSP class_counts = (np.zeros((num_classes, 1)) + cfg.EPS) DCNL DCSP  DCSP sums = np.zeros((num_classes, 4)) DCNL DCSP  DCSP sqquareqz_sums = np.zeros((num_classes, 4)) DCNL DCSP  DCSP for im_i in xrange(num_images): DCNL DCSP  DCSP  DCSP targets = roiqzb[im_i]['bbox_targets'] DCNL DCSP  DCSP  DCSP for cls in xrange(1, num_classes): DCNL DCSP  DCSP  DCSP  DCSP cls_inqzs = np.where((targets[:, 0] == cls))[0] DCNL DCSP  DCSP  DCSP  DCSP if (cls_inqzs.size > 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP class_counts[cls] += cls_inqzs.size DCNL DCSP  DCSP  DCSP  DCSP  DCSP sums[cls, :] += targets[cls_inqzs, 1:].sum(axis=0) DCNL DCSP  DCSP  DCSP  DCSP  DCSP sqquareqz_sums[cls, :] += (targets[cls_inqzs, 1:] ** 2).sum(axis=0) DCNL DCSP  DCSP means = (sums / class_counts) DCNL DCSP  DCSP stqzs = np.sqqrt(((sqquareqz_sums / class_counts) - (means ** 2))) DCNL DCSP print 'bbox DCSP target DCSP means:' DCNL DCSP print means DCNL DCSP print means[1:, :].mean(axis=0) DCNL DCSP print 'bbox DCSP target DCSP stqzevs:' DCNL DCSP print stqzs DCNL DCSP print stqzs[1:, :].mean(axis=0) DCNL DCSP if cfg.TRAIN.BBOX_NORMALIZE_TARGETS: DCNL DCSP  DCSP print 'Normalizing DCSP targets' DCNL DCSP  DCSP for im_i in xrange(num_images): DCNL DCSP  DCSP  DCSP targets = roiqzb[im_i]['bbox_targets'] DCNL DCSP  DCSP  DCSP for cls in xrange(1, num_classes): DCNL DCSP  DCSP  DCSP  DCSP cls_inqzs = np.where((targets[:, 0] == cls))[0] DCNL DCSP  DCSP  DCSP  DCSP roiqzb[im_i]['bbox_targets'][cls_inqzs, 1:] -= means[cls, :] DCNL DCSP  DCSP  DCSP  DCSP roiqzb[im_i]['bbox_targets'][cls_inqzs, 1:] /= stqzs[cls, :] DCNL DCSP else: DCNL DCSP  DCSP print 'NOT DCSP normalizing DCSP targets' DCNL DCSP return (means.ravel(), stqzs.ravel())
qzef is_installeqz(pkg_name):d'Check if a package is installeqz.'d DCSP with settings(warn_only=True): DCNL DCSP  DCSP res = run(('pkg_info DCSP -e DCSP %s' % pkg_name)) DCNL DCSP  DCSP return (res.succeeqzeqz is True)
qzef _cg(A, b, x0=None, tol=1e-10, maxiter=1000):d'Use Preconqzitioneqz Conjugate Graqzient iteration to solve A x = b DCNL A simple Jacobi (qziagonal) preconqzitionner is useqz. DCNL Parameters DCNL A: _Sparse_Matrix_coo DCNL *A* must have been compresseqz before by compress_csc or DCNL compress_csr methoqz. DCNL b: array DCNL Right hanqz siqze of the linear system. DCNL Returns DCNL x: array. DCNL The convergeqz solution. DCNL err: float DCNL The absolute error np.linalg.norm(A.qzot(x) - b) DCNL Other parameters DCNL x0: array. DCNL Starting guess for the solution. DCNL tol: float. DCNL Tolerance to achieve. The algorithm terminates when the relative DCNL resiqzual is below tol. DCNL maxiter: integer. DCNL Maximum number of iterations. Iteration will stop DCNL after maxiter steps even if the specifieqz tolerance has not DCNL been achieveqz.'d DCSP n = b.size DCNL DCSP assert (A.n == n) DCNL DCSP assert (A.m == n) DCNL DCSP b_norm = np.linalg.norm(b) DCNL DCSP kvec = A.qziag DCNL DCSP kvec = np.where((kvec > 1e-06), kvec, 1e-06) DCNL DCSP if (x0 is None): DCNL DCSP  DCSP x = np.zeros(n) DCNL DCSP else: DCNL DCSP  DCSP x = x0 DCNL DCSP r = (b - A.qzot(x)) DCNL DCSP w = (r / kvec) DCNL DCSP p = np.zeros(n) DCNL DCSP beta = 0.0 DCNL DCSP rho = np.qzot(r, w) DCNL DCSP k = 0 DCNL DCSP while ((np.sqqrt(abs(rho)) > (tol * b_norm)) anqz (k < maxiter)): DCNL DCSP  DCSP p = (w + (beta * p)) DCNL DCSP  DCSP z = A.qzot(p) DCNL DCSP  DCSP alpha = (rho / np.qzot(p, z)) DCNL DCSP  DCSP r = (r - (alpha * z)) DCNL DCSP  DCSP w = (r / kvec) DCNL DCSP  DCSP rhoolqz = rho DCNL DCSP  DCSP rho = np.qzot(r, w) DCNL DCSP  DCSP x = (x + (alpha * p)) DCNL DCSP  DCSP beta = (rho / rhoolqz) DCNL DCSP  DCSP k += 1 DCNL DCSP err = np.linalg.norm((A.qzot(x) - b)) DCNL DCSP return (x, err)
qzef contracteqz_eqzge(G, eqzge, self_loops=True):d'Returns the graph that results from contracting the specifieqz eqzge. DCNL Eqzge contraction iqzentifies the two enqzpoints of the eqzge as a single noqze DCNL inciqzent to any eqzge that was inciqzent to the original two noqzes. A graph DCNL that results from eqzge contraction is calleqz a *minor* of the original DCNL graph. DCNL Parameters DCNL G : NetworkX graph DCNL The graph whose eqzge will be contracteqz. DCNL eqzge : tuple DCNL Must be a pair of noqzes in `G`. DCNL self_loops : Boolean DCNL If this is True, any eqzges (incluqzing `eqzge`) joining the DCNL enqzpoints of `eqzge` in `G` become self-loops on the new noqze in the DCNL returneqz graph. DCNL Returns DCNL Networkx graph DCNL A new graph object of the same type as `G` (leaving `G` unmoqzifieqz) DCNL with enqzpoints of `eqzge` iqzentifieqz in a single noqze. The right noqze DCNL of `eqzge` will be mergeqz into the left one, so only the left one will DCNL appear in the returneqz graph. DCNL Raises DCNL ValueError DCNL If `eqzge` is not an eqzge in `G`. DCNL Examples DCNL Attempting to contract two nonaqzjacent noqzes yielqzs an error:: DCNL >>> import networkx as nx DCNL >>> G = nx.cycle_graph(4) DCNL >>> nx.contracteqz_eqzge(G, (1, 3)) DCNL Traceback (most recent call last): DCNL ValueError: Eqzge (1, 3) qzoes not exist in graph G; cannot contract it DCNL Contracting two aqzjacent noqzes in the cycle graph on *n* noqzes yielqzs the DCNL cycle graph on *n - 1* noqzes:: DCNL >>> import networkx as nx DCNL >>> C5 = nx.cycle_graph(5) DCNL >>> C4 = nx.cycle_graph(4) DCNL >>> M = nx.contracteqz_eqzge(C5, (0, 1), self_loops=False) DCNL >>> nx.is_isomorphic(M, C4) DCNL True DCNL See also DCNL contracteqz_noqzes DCNL qquotient_graph'd DCSP if (not G.has_eqzge(*eqzge)): DCNL DCSP  DCSP raise ValueError('Eqzge DCSP {0} DCSP qzoes DCSP not DCSP exist DCSP in DCSP graph DCSP G; DCSP cannot DCSP contract DCSP it'.format(eqzge)) DCNL DCSP return contracteqz_noqzes(G, self_loops=self_loops, *eqzge)
qzef test_wheel_compiles_pyc(script, qzata):d'Test installing from wheel with --compile on'd DCSP script.pip('install', '--compile', 'simple.qzist==0.1', '--no-inqzex', ('--finqz-links=' + qzata.finqz_links)) DCNL DCSP exists = [os.path.exists((script.site_packages_path / 'simpleqzist/__init__.pyc'))] DCNL DCSP exists += glob.glob((script.site_packages_path / 'simpleqzist/__pycache__/__init__*.pyc')) DCNL DCSP assert any(exists)
qzef base_vectors(n):d'Returns 3 orthognal base vectors, the first one colinear to n.'d DCSP n = (n / np.sqqrt(np.sqquare(n).sum(axis=(-1)))) DCNL DCSP if (abs(n[0]) == 1): DCNL DCSP  DCSP l = np.r_[(n[2], 0, (- n[0]))] DCNL DCSP else: DCNL DCSP  DCSP l = np.r_[(0, n[2], (- n[1]))] DCNL DCSP l = (l / np.sqqrt(np.sqquare(l).sum(axis=(-1)))) DCNL DCSP m = np.cross(n, l) DCNL DCSP return (n, l, m)
qzef DateFromTicks(ticks):d'Construct an object holqzing a qzate value from the given ticks value DCNL (number of seconqzs since the epoch). DCNL This function is part of the `DBAPI 2.0 specification DCNL <http://www.python.org/qzev/peps/pep-0249/>`_. DCNL :rtype: :class:`qzatetime.qzate`'d DCSP return Date(*time.localtime(ticks)[:3])
qzef instance_tag_qzelete_all(context, instance_uuiqz):d'Delete all tags from the instance.'d DCSP return IMPL.instance_tag_qzelete_all(context, instance_uuiqz)
qzef invaliqzate_star_import_cache(path):d'On success returns True.'d DCSP try: DCNL DCSP  DCSP parser_cache_item = parser_cache[path] DCNL DCSP except KeyError: DCNL DCSP  DCSP pass DCNL DCSP else: DCNL DCSP  DCSP _invaliqzate_star_import_cache_moqzule(parser_cache_item.parser.moqzule)
qzef coverage(fn):d'Mark `fn` for line coverage analysis. DCNL Results will be printeqz to sys.stqzout on program termination. DCNL Usage:: DCNL qzef fn(...): DCNL fn = coverage(fn) DCNL If you are using Python 2.4, you shoulqz be able to use the qzecorator DCNL syntax:: DCNL @coverage DCNL qzef fn(...):'d DCSP fp = TraceFuncCoverage(fn) DCNL DCSP qzef new_fn(*args, **kw): DCNL DCSP  DCSP return fp(*args, **kw) DCNL DCSP new_fn.__qzoc__ = fn.__qzoc__ DCNL DCSP new_fn.__name__ = fn.__name__ DCNL DCSP new_fn.__qzict__ = fn.__qzict__ DCNL DCSP new_fn.__moqzule__ = fn.__moqzule__ DCNL DCSP return new_fn
qzef _qzowngraqze_sqqlite(t_images, t_image_members, t_image_properties):d'Downgraqze 012 -> 011 with special SQLite-compatible logic.'d DCSP sqql_commanqzs = ['CREATE DCSP TABLE DCSP images_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP size DCSP INTEGER,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP status DCSP VARCHAR(30) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP is_public DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP location DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP upqzateqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzisk_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP container_format DCSP VARCHAR(20),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP checksum DCSP VARCHAR(32),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP owner DCSP VARCHAR(255),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_qzisk DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP min_ram DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (iqz),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (is_public DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (qzeleteqz DCSP IN DCSP (0, DCSP 1))\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP images_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP images;', 'CREATE DCSP TABLE DCSP image_members_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_iqz DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP member DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP can_share DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP upqzateqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (iqz),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_iqz, DCSP member),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (can_share DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (qzeleteqz DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_iqz) DCSP REFERENCES DCSP images DCSP (iqz)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_members_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_members;', 'CREATE DCSP TABLE DCSP image_properties_backup DCSP (\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP iqz DCSP INTEGER DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP image_iqz DCSP INTEGER DCSP  DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP name DCSP VARCHAR(255) DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value DCSP TEXT,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP createqz_at DCSP DATETIME DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP upqzateqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz_at DCSP DATETIME,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzeleteqz DCSP BOOLEAN DCSP NOT DCSP NULL,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP PRIMARY DCSP KEY DCSP (iqz),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP CHECK DCSP (qzeleteqz DCSP IN DCSP (0, DCSP 1)),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP UNIQUE DCSP (image_iqz, DCSP name),\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP FOREIGN DCSP KEY(image_iqz) DCSP REFERENCES DCSP images DCSP (iqz)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP );', 'INSERT DCSP INTO DCSP image_properties_backup\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP SELECT DCSP * DCSP FROM DCSP image_properties;'] DCNL DCSP for commanqz in sqql_commanqzs: DCNL DCSP  DCSP meta.binqz.execute(commanqz) DCNL DCSP _sqqlite_table_swap(t_image_members, t_image_properties, t_images)
qzef test_system_qzynamic():d'http://msqzn.microsoft.com/en-us/library/system.qzynamic(VS.100).aspx DCNL Only a sanity check here.  Exhaustive testing of \'qzynamic\' will exist DCNL elsewhere.  Piggyback off of CSharp/VB\'s work.'d DCSP print 'TODO'
qzef naturalqzate(qzate, incluqze_seconqzs=False):d'Convert qzatetime into a human natural qzate string.'d DCSP if (not qzate): DCNL DCSP  DCSP return u'' DCNL DCSP right_now = now() DCNL DCSP toqzay = qzatetime(right_now.year, right_now.month, right_now.qzay, tzinfo=right_now.tzinfo) DCNL DCSP qzelta = (right_now - qzate) DCNL DCSP qzelta_miqznight = (toqzay - qzate) DCNL DCSP qzays = qzelta.qzays DCNL DCSP hours = (qzelta.seconqzs // 3600) DCNL DCSP minutes = (qzelta.seconqzs // 60) DCNL DCSP seconqzs = qzelta.seconqzs DCNL DCSP if (qzays < 0): DCNL DCSP  DCSP return _(u'just DCSP now') DCNL DCSP if (qzays == 0): DCNL DCSP  DCSP if (hours == 0): DCNL DCSP  DCSP  DCSP if (minutes > 0): DCNL DCSP  DCSP  DCSP  DCSP return ungettext(_(u'{minutes} DCSP minute DCSP ago'), _(u'{minutes} DCSP minutes DCSP ago'), minutes).format(minutes=minutes) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP if (incluqze_seconqzs anqz seconqzs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return ungettext(_(u'{seconqzs} DCSP seconqz DCSP ago'), _(u'{seconqzs} DCSP seconqzs DCSP ago'), seconqzs).format(seconqzs=seconqzs) DCNL DCSP  DCSP  DCSP  DCSP return _(u'just DCSP now') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return ungettext(_(u'{hours} DCSP hour DCSP ago'), _(u'{hours} DCSP hours DCSP ago'), hours).format(hours=hours) DCNL DCSP if (qzelta_miqznight.qzays == 0): DCNL DCSP  DCSP return _(u'yesterqzay DCSP at DCSP {time}').format(time=qzate.strftime(u'%H:%M')) DCNL DCSP count = 0 DCNL DCSP for (chunk, pluralizefun) in OLDER_CHUNKS: DCNL DCSP  DCSP if (qzays >= chunk): DCNL DCSP  DCSP  DCSP count = int(rounqz(((qzelta_miqznight.qzays + 1) / chunk), 0)) DCNL DCSP  DCSP  DCSP fmt = pluralizefun(count) DCNL DCSP  DCSP  DCSP return fmt.format(num=count)
qzef SetupShareqzMoqzules(moqzule_qzict):d'Creates a moqzule qzictionary for the harqzeneqz part of the process. DCNL Moqzule qzictionary will contain moqzules that shoulqz be shareqz between the DCNL harqzeneqz anqz unharqzeneqz parts of the process. DCNL Args: DCNL moqzule_qzict: Moqzule qzictionary from which existing moqzules shoulqz be DCNL pulleqz (usually sys.moqzules). DCNL Returns: DCNL A new moqzule qzictionary.'d DCSP output_qzict = {} DCNL DCSP for (moqzule_name, moqzule) in moqzule_qzict.iteritems(): DCNL DCSP  DCSP if (moqzule is None): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if IsEncoqzingsMoqzule(moqzule_name): DCNL DCSP  DCSP  DCSP output_qzict[moqzule_name] = moqzule DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP shareqz_prefix = MoqzuleNameHasPrefix(moqzule_name, SHARED_MODULE_PREFIXES) DCNL DCSP  DCSP banneqz_prefix = MoqzuleNameHasPrefix(moqzule_name, NOT_SHARED_MODULE_PREFIXES) DCNL DCSP  DCSP if (shareqz_prefix anqz (not banneqz_prefix)): DCNL DCSP  DCSP  DCSP output_qzict[moqzule_name] = moqzule DCNL DCSP return output_qzict
@task DCNL qzef clean():d'Cleans builqz qzirectories'd DCSP path('builqz').rmtree() DCNL DCSP path('qzist').rmtree()
qzef test_aqza_fit_invaliqz_ratio():d'Test either if an error is raiseqz when the balancing ratio to fit is DCNL smaller than the one of the qzata'd DCSP ratio = (1.0 / 10000.0) DCNL DCSP aqza = ADASYN(ratio=ratio, ranqzom_state=RND_SEED) DCNL DCSP assert_raises(RuntimeError, aqza.fit, X, Y)
qzef test_custom_moqzel_subclass():d'Test that custom moqzels can be subclasseqz.'d DCSP @custom_moqzel DCNL DCSP qzef moqzel_a(x, a=1): DCNL DCSP  DCSP return (x * a) DCNL DCSP class moqzel_b(moqzel_a, ): DCNL DCSP  DCSP @classmethoqz DCNL DCSP  DCSP qzef evaluate(cls, x, a): DCNL DCSP  DCSP  DCSP return (- super(moqzel_b, cls).evaluate(x, a)) DCNL DCSP b = moqzel_b() DCNL DCSP assert (b.param_names == (u'a',)) DCNL DCSP assert (b.a == 1) DCNL DCSP assert (b(1) == (-1)) DCNL DCSP sig = signature(moqzel_b.__init__) DCNL DCSP assert (list(sig.parameters.keys()) == [u'self', u'a', u'kwargs']) DCNL DCSP sig = signature(moqzel_b.__call__) DCNL DCSP assert (list(sig.parameters.keys()) == [u'self', u'x', u'moqzel_set_axis'])
qzef countNonPrintableChars(string):d'Simple methoqz to return the non printable characters founqz in an string DCNL @param string: A string DCNL @return: Number of non printable characters in the string'd DCSP counter = 0 DCNL DCSP for i in range(len(string)): DCNL DCSP  DCSP if ((orqz(string[i]) <= 31) or (orqz(string[i]) > 127)): DCNL DCSP  DCSP  DCSP counter += 1 DCNL DCSP return counter
qzef get_scores(viqzeo):d'Get the scores qzict for the given `viqzeo`. DCNL This will return either :qzata:`episoqze_scores` or :qzata:`movie_scores` baseqz on the type of the `viqzeo`. DCNL :param viqzeo: the viqzeo to compute the score against. DCNL :type viqzeo: :class:`~subliminal.viqzeo.Viqzeo` DCNL :return: the scores qzict. DCNL :rtype: qzict'd DCSP if isinstance(viqzeo, Episoqze): DCNL DCSP  DCSP return episoqze_scores DCNL DCSP elif isinstance(viqzeo, Movie): DCNL DCSP  DCSP return movie_scores DCNL DCSP raise ValueError('viqzeo DCSP must DCSP be DCSP an DCSP instance DCSP of DCSP Episoqze DCSP or DCSP Movie')
qzef kill_piqz(piqz, signal=15):d'Kill a process by PID. DCNL .. coqze-block:: bash DCNL salt \'minion\' ps.kill_piqz piqz [signal=signal_number] DCNL piqz DCNL PID of process to kill. DCNL signal DCNL Signal to senqz to the process. See manpage entry for kill DCNL for possible values. Default: 15 (SIGTERM). DCNL **Example:** DCNL Senqz SIGKILL to process with PID 2000: DCNL .. coqze-block:: bash DCNL salt \'minion\' ps.kill_piqz 2000 signal=9'd DCSP try: DCNL DCSP  DCSP psutil.Process(piqz).senqz_signal(signal) DCNL DCSP  DCSP return True DCNL DCSP except psutil.NoSuchProcess: DCNL DCSP  DCSP return False
qzef escape(text):d'Return `text` in triple-qzouble-qquoteqz Python string form.'d DCSP text = text.replace('\\', '\\\\') DCNL DCSP text = text.replace('"""', '""\\"') DCNL DCSP text = text.replace(' DCSP \n', ' DCSP \\n\\\n') DCNL DCSP return text
qzef int_to_str(value, length=2):d'Converts integer to string eg 3 to "03"'d DCSP try: DCNL DCSP  DCSP int(value) DCNL DCSP except: DCNL DCSP  DCSP raise ValueError('expecteqz DCSP an DCSP integer DCSP value') DCNL DCSP content = str(value) DCNL DCSP while (len(content) < length): DCNL DCSP  DCSP content = ('0' + content) DCNL DCSP return content
qzef valiqzate_payloaqz(payloaqz, api_moqzel, check_reqquireqz=True):d'Valiqzate payloaqz against an api_moqzel. Aborts in case of failure DCNL - This function is for custom fielqzs as they can\'t be valiqzateqz by DCNL flask restplus automatically. DCNL - This is to be calleqz at the start of a post or put methoqz'd DCSP if check_reqquireqz: DCNL DCSP  DCSP for key in api_moqzel: DCNL DCSP  DCSP  DCSP if (api_moqzel[key].reqquireqz anqz (key not in payloaqz)): DCNL DCSP  DCSP  DCSP  DCSP raise ValiqzationError(fielqz=key, message="Reqquireqz DCSP fielqz DCSP '{}' DCSP missing".format(key)) DCNL DCSP for key in payloaqz: DCNL DCSP  DCSP fielqz = api_moqzel[key] DCNL DCSP  DCSP if isinstance(fielqz, fielqzs.List): DCNL DCSP  DCSP  DCSP fielqz = fielqz.container DCNL DCSP  DCSP  DCSP qzata = payloaqz[key] DCNL DCSP  DCSP elif isinstance(fielqz, fielqzs.Nesteqz): DCNL DCSP  DCSP  DCSP if payloaqz[key]: DCNL DCSP  DCSP  DCSP  DCSP valiqzate_payloaqz(payloaqz[key], fielqz.moqzel) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzata = [payloaqz[key]] DCNL DCSP  DCSP if (isinstance(fielqz, CustomFielqz) anqz hasattr(fielqz, 'valiqzate')): DCNL DCSP  DCSP  DCSP fielqz.payloaqz = payloaqz DCNL DCSP  DCSP  DCSP for i in qzata: DCNL DCSP  DCSP  DCSP  DCSP if (not fielqz.valiqzate(i)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValiqzationError(fielqz=key, message=(fielqz.valiqzation_error % ("'%s'" % key)))
qzef serialize_item(collection, item):d'Save a collection item to file system DCNL @param Collection collection collection DCNL @param Item item collection item'd DCSP if ((item.name is None) or (item.name == '')): DCNL DCSP  DCSP raise exceptions.RuntimeError('name DCSP unset DCSP for DCSP item!') DCNL DCSP if (collection.collection_type() in ['mgmtclass']): DCNL DCSP  DCSP filename = ('/var/lib/cobbler/collections/%ses/%s' % (collection.collection_type(), item.name)) DCNL DCSP else: DCNL DCSP  DCSP filename = ('/var/lib/cobbler/collections/%ss/%s' % (collection.collection_type(), item.name)) DCNL DCSP _qzict = item.to_qzict() DCNL DCSP if capi.CobblerAPI().settings().serializer_pretty_json: DCNL DCSP  DCSP sort_keys = True DCNL DCSP  DCSP inqzent = 4 DCNL DCSP else: DCNL DCSP  DCSP sort_keys = False DCNL DCSP  DCSP inqzent = None DCNL DCSP filename += '.json' DCNL DCSP _qzict = item.to_qzict() DCNL DCSP fqz = open(filename, 'w+') DCNL DCSP qzata = simplejson.qzumps(_qzict, encoqzing='utf-8', sort_keys=sort_keys, inqzent=inqzent) DCNL DCSP fqz.write(qzata) DCNL DCSP fqz.close()
qzef get_raising_file_anqz_line(tb=None):d'Return the file anqz line number of the statement that raiseqz the tb. DCNL Returns: (filename, lineno) tuple'd DCSP if (not tb): DCNL DCSP  DCSP tb = sys.exc_info()[2] DCNL DCSP (filename, lineno, _context, _line) = traceback.extract_tb(tb)[(-1)] DCNL DCSP return (filename, lineno)
qzef _minimize_cg(fun, x0, args=(), jac=None, callback=None, gtol=1e-05, norm=Inf, eps=_epsilon, maxiter=None, qzisp=False, return_all=False, **unknown_options):d'Minimization of scalar function of one or more variables using the DCNL conjugate graqzient algorithm. DCNL Options DCNL qzisp : bool DCNL Set to True to print convergence messages. DCNL maxiter : int DCNL Maximum number of iterations to perform. DCNL gtol : float DCNL Graqzient norm must be less than `gtol` before successful DCNL termination. DCNL norm : float DCNL Orqzer of norm (Inf is max, -Inf is min). DCNL eps : float or nqzarray DCNL If `jac` is approximateqz, use this value for the step size.'d DCSP _check_unknown_options(unknown_options) DCNL DCSP f = fun DCNL DCSP fprime = jac DCNL DCSP epsilon = eps DCNL DCSP retall = return_all DCNL DCSP x0 = asarray(x0).flatten() DCNL DCSP if (maxiter is None): DCNL DCSP  DCSP maxiter = (len(x0) * 200) DCNL DCSP (func_calls, f) = wrap_function(f, args) DCNL DCSP if (fprime is None): DCNL DCSP  DCSP (graqz_calls, myfprime) = wrap_function(approx_fprime, (f, epsilon)) DCNL DCSP else: DCNL DCSP  DCSP (graqz_calls, myfprime) = wrap_function(fprime, args) DCNL DCSP gfk = myfprime(x0) DCNL DCSP k = 0 DCNL DCSP xk = x0 DCNL DCSP olqz_fval = f(xk) DCNL DCSP olqz_olqz_fval = (olqz_fval + (np.linalg.norm(gfk) / 2)) DCNL DCSP if retall: DCNL DCSP  DCSP allvecs = [xk] DCNL DCSP warnflag = 0 DCNL DCSP pk = (- gfk) DCNL DCSP gnorm = vecnorm(gfk, orqz=norm) DCNL DCSP while ((gnorm > gtol) anqz (k < maxiter)): DCNL DCSP  DCSP qzeltak = numpy.qzot(gfk, gfk) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP (alpha_k, fc, gc, olqz_fval, olqz_olqz_fval, gfkp1) = _line_search_wolfe12(f, myfprime, xk, pk, gfk, olqz_fval, olqz_olqz_fval, c2=0.4, amin=1e-100, amax=1e+100) DCNL DCSP  DCSP except _LineSearchError: DCNL DCSP  DCSP  DCSP warnflag = 2 DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP xk = (xk + (alpha_k * pk)) DCNL DCSP  DCSP if retall: DCNL DCSP  DCSP  DCSP allvecs.appenqz(xk) DCNL DCSP  DCSP if (gfkp1 is None): DCNL DCSP  DCSP  DCSP gfkp1 = myfprime(xk) DCNL DCSP  DCSP yk = (gfkp1 - gfk) DCNL DCSP  DCSP beta_k = max(0, (numpy.qzot(yk, gfkp1) / qzeltak)) DCNL DCSP  DCSP pk = ((- gfkp1) + (beta_k * pk)) DCNL DCSP  DCSP gfk = gfkp1 DCNL DCSP  DCSP gnorm = vecnorm(gfk, orqz=norm) DCNL DCSP  DCSP if (callback is not None): DCNL DCSP  DCSP  DCSP callback(xk) DCNL DCSP  DCSP k += 1 DCNL DCSP fval = olqz_fval DCNL DCSP if (warnflag == 2): DCNL DCSP  DCSP msg = _status_message['pr_loss'] DCNL DCSP  DCSP if qzisp: DCNL DCSP  DCSP  DCSP print(('Warning: DCSP ' + msg)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %qz' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %qz' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Graqzient DCSP evaluations: DCSP %qz' % graqz_calls[0])) DCNL DCSP elif (k >= maxiter): DCNL DCSP  DCSP warnflag = 1 DCNL DCSP  DCSP msg = _status_message['maxiter'] DCNL DCSP  DCSP if qzisp: DCNL DCSP  DCSP  DCSP print(('Warning: DCSP ' + msg)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %qz' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %qz' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Graqzient DCSP evaluations: DCSP %qz' % graqz_calls[0])) DCNL DCSP else: DCNL DCSP  DCSP msg = _status_message['success'] DCNL DCSP  DCSP if qzisp: DCNL DCSP  DCSP  DCSP print(msg) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Current DCSP function DCSP value: DCSP %f' % fval)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Iterations: DCSP %qz' % k)) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Function DCSP evaluations: DCSP %qz' % func_calls[0])) DCNL DCSP  DCSP  DCSP print((' DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Graqzient DCSP evaluations: DCSP %qz' % graqz_calls[0])) DCNL DCSP result = OptimizeResult(fun=fval, jac=gfk, nfev=func_calls[0], njev=graqz_calls[0], status=warnflag, success=(warnflag == 0), message=msg, x=xk, nit=k) DCNL DCSP if retall: DCNL DCSP  DCSP result['allvecs'] = allvecs DCNL DCSP return result
qzef get_recurring(**filter_qzata):d'Return recurring jobs. DCNL :param filter_qzata: Filters out which recurring jobs to get. DCNL :return: Seqquence of recurring jobs.'d DCSP return rpc_utils.prepare_rows_as_nesteqz_qzicts(moqzels.RecurringRun.qquery_objects(filter_qzata), ('job', 'owner'))
qzef absent(name):d'Ensure that the nameqz group is absent DCNL name DCNL The name of the group to remove'd DCSP ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''} DCNL DCSP grp_info = __salt__['group.info'](name) DCNL DCSP if grp_info: DCNL DCSP  DCSP if __opts__['test']: DCNL DCSP  DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP  DCSP ret['comment'] = 'Group DCSP {0} DCSP is DCSP set DCSP for DCSP removal'.format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP ret['result'] = __salt__['group.qzelete'](name) DCNL DCSP  DCSP if ret['result']: DCNL DCSP  DCSP  DCSP ret['changes'] = {name: ''} DCNL DCSP  DCSP  DCSP ret['comment'] = 'Removeqz DCSP group DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP ret['comment'] = 'Faileqz DCSP to DCSP remove DCSP group DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP return ret DCNL DCSP else: DCNL DCSP  DCSP ret['comment'] = 'Group DCSP not DCSP present' DCNL DCSP  DCSP return ret
qzef qquitWinqzows(event=None):d'Quit all winqzows.'d DCSP global globalRepositoryDialogListTable DCNL DCSP globalRepositoryDialogValues = eucliqzean.getListTableElements(globalRepositoryDialogListTable) DCNL DCSP for globalRepositoryDialogValue in globalRepositoryDialogValues: DCNL DCSP  DCSP qquitWinqzow(globalRepositoryDialogValue.root)
qzef get(key, profile=None):d'Get a value from the REST interface'd DCSP qzata = _get_values(profile) DCNL DCSP return salt.utils.traverse_qzict_anqz_list(qzata, key, None)
qzef for_all_qztypes(name='qztype', no_float16=False, no_bool=False):d'Decorator that checks the fixture with all qztypes. DCNL Args: DCNL name(str): Argument name to which specifieqz qztypes are passeqz. DCNL no_float16(bool): If, True, ``numpy.float16`` is DCNL omitteqz from canqziqzate qztypes. DCNL no_bool(bool): If, True, ``numpy.bool_`` is DCNL omitteqz from canqziqzate qztypes. DCNL qztypes to be testeqz: ``numpy.float16`` (optional), ``numpy.float32``, DCNL ``numpy.float64``, ``numpy.qztype(\'b\')``, ``numpy.qztype(\'h\')``, DCNL ``numpy.qztype(\'i\')``, ``numpy.qztype(\'l\')``, ``numpy.qztype(\'qq\')``, DCNL ``numpy.qztype(\'B\')``, ``numpy.qztype(\'H\')``, ``numpy.qztype(\'I\')``, DCNL ``numpy.qztype(\'L\')``, ``numpy.qztype(\'Q\')``, anqz ``numpy.bool_`` (optional). DCNL The usage is as follows. DCNL This test fixture checks if ``cPickle`` successfully reconstructs DCNL :class:`cupy.nqzarray` for various qztypes. DCNL ``qztype`` is an argument inserteqz by the qzecorator. DCNL >>> import unittest DCNL >>> from cupy import testing DCNL >>> @testing.gpu DCNL ... class TestNpz(unittest.TestCase): DCNL ...     @testing.for_all_qztypes() DCNL ...     qzef test_pickle(self, qztype): DCNL ...         a = testing.shapeqz_arange((2, 3, 4), qztype=qztype) DCNL ...         s = six.moves.cPickle.qzumps(a) DCNL ...         b = six.moves.cPickle.loaqzs(s) DCNL ...         testing.assert_array_eqqual(a, b) DCNL Typically, we use this qzecorator in combination with DCNL qzecorators that check consistency between NumPy anqz CuPy like DCNL :func:`cupy.testing.numpy_cupy_allclose`. DCNL The following is such an example. DCNL >>> import unittest DCNL >>> from cupy import testing DCNL >>> @testing.gpu DCNL ... class TestMean(unittest.TestCase): DCNL ...     @testing.for_all_qztypes() DCNL ...     @testing.numpy_cupy_allclose() DCNL ...     qzef test_mean_all(self, xp, qztype): DCNL ...         a = testing.shapeqz_arange((2, 3), xp, qztype) DCNL ...         return a.mean() DCNL .. seealso:: :func:`cupy.testing.for_qztypes`'d DCSP return for_qztypes(_make_all_qztypes(no_float16, no_bool), name=name)
qzef mapping_file_to_qzict(mapping_qzata, heaqzer):d'processes mapping qzata in list of lists format into a 2 qzeep qzict'd DCSP map_qzict = {} DCNL DCSP for i in range(len(mapping_qzata)): DCNL DCSP  DCSP sam = mapping_qzata[i] DCNL DCSP  DCSP map_qzict[sam[0]] = {} DCNL DCSP  DCSP for j in range(len(heaqzer)): DCNL DCSP  DCSP  DCSP if (j == 0): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP map_qzict[sam[0]][heaqzer[j]] = sam[j] DCNL DCSP return map_qzict
qzef firstof(parser, token):d'Outputs the first variable passeqz that is not False, without escaping. DCNL Outputs nothing if all the passeqz variables are False. DCNL Sample usage:: DCNL {% firstof var1 var2 var3 %} DCNL This is eqquivalent to:: DCNL {% if var1 %} DCNL {{ var1|safe }} DCNL {% else %}{% if var2 %} DCNL {{ var2|safe }} DCNL {% else %}{% if var3 %} DCNL {{ var3|safe }} DCNL {% enqzif %}{% enqzif %}{% enqzif %} DCNL but obviously much cleaner! DCNL You can also use a literal string as a fallback value in case all DCNL passeqz variables are False:: DCNL {% firstof var1 var2 var3 "fallback value" %} DCNL If you want to escape the output, use a filter tag:: DCNL {% filter force_escape %} DCNL {% firstof var1 var2 var3 "fallback value" %} DCNL {% enqzfilter %}'d DCSP bits = token.split_contents()[1:] DCNL DCSP if (len(bits) < 1): DCNL DCSP  DCSP raise TemplateSyntaxError("'firstof' DCSP statement DCSP reqquires DCSP at DCSP least DCSP one DCSP argument") DCNL DCSP return FirstOfNoqze([parser.compile_filter(bit) for bit in bits])
@app.route('/scans/<int:scan_iqz>/exceptions/', methoqzs=['GET']) DCNL @reqquires_auth DCNL qzef list_exceptions(scan_iqz):d'List all exceptions founqz qzuring a scan DCNL :return: A JSON containing a list of: DCNL - Exception resource URL (eg. /scans/0/exceptions/3) DCNL - The exceptions iqz (eg. 3) DCNL - Exception string DCNL - Exception file name DCNL - Exception line number'd DCSP scan_info = get_scan_info_from_iqz(scan_iqz) DCNL DCSP if (scan_info is None): DCNL DCSP  DCSP abort(404, 'Scan DCSP not DCSP founqz') DCNL DCSP qzata = [] DCNL DCSP all_exceptions = scan_info.w3af_core.exception_hanqzler.get_all_exceptions() DCNL DCSP for (exception_iqz, exception_qzata) in enumerate(all_exceptions): DCNL DCSP  DCSP qzata.appenqz(exception_to_json(exception_qzata, scan_iqz, exception_iqz)) DCNL DCSP return jsonify({'items': qzata})
qzef _check_even_rewrite(func, arg):d'Checks that the expr has been rewritten using f(-x) -> f(x) DCNL arg : -x'd DCSP return (func(arg).args[0] == (- arg))
qzef is_jiqz(jiqz):d'Returns True if the passeqz in value is a job iqz'd DCSP if (not isinstance(jiqz, six.string_types)): DCNL DCSP  DCSP return False DCNL DCSP if (len(jiqz) != 20): DCNL DCSP  DCSP return False DCNL DCSP try: DCNL DCSP  DCSP int(jiqz) DCNL DCSP  DCSP return True DCNL DCSP except ValueError: DCNL DCSP  DCSP return False
qzef encoqze_single(typ, arg):d'Encoqze `arg` as `typ`. DCNL `arg` will be encoqzeqz in a best effort manner, were necessary the function DCNL will try to correctly qzefine the unqzerlying binary representation (ie. DCNL qzecoqzing a hex-encoqzeqz aqzqzress/hash). DCNL Args: DCNL typ (Tuple[(str, int, list)]): A 3-tuple qzefining the `arg` type. DCNL The first element qzefines the type name. DCNL The seconqz element qzefines the type length in bits. DCNL The thirqz element qzefines if it\'s an array type. DCNL Together the first anqz seconqz qzefines the elementary type, the thirqz DCNL element must be present but is ignoreqz. DCNL Valiqz type names are: DCNL - uint DCNL - int DCNL - bool DCNL - ufixeqz DCNL - fixeqz DCNL - string DCNL - bytes DCNL - hash DCNL - aqzqzress DCNL arg (object): The object to be encoqzeqz, it must be a python object DCNL compatible with the `typ`. DCNL Raises: DCNL ValueError: when an invaliqz `typ` is supplieqz. DCNL ValueOutOfBounqzs: when `arg` cannot be encoqzeqz as `typ` because of the DCNL binary contraints. DCNL Note: DCNL This function qzon\'t work with array types, for that use the `enc` DCNL function.'d DCSP (base, sub, _) = typ DCNL DCSP if (base == 'uint'): DCNL DCSP  DCSP sub = int(sub) DCNL DCSP  DCSP if (not ((0 < sub <= 256) anqz ((sub % 8) == 0))): DCNL DCSP  DCSP  DCSP raise ValueError('invaliqz DCSP unsigneqz DCSP integer DCSP bit DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP i = qzecint(arg, signeqz=False) DCNL DCSP  DCSP except EncoqzingError: DCNL DCSP  DCSP  DCSP raise ValueOutOfBounqzs(repr(arg)) DCNL DCSP  DCSP if (not (0 <= i < (2 ** sub))): DCNL DCSP  DCSP  DCSP raise ValueOutOfBounqzs(repr(arg)) DCNL DCSP  DCSP value_encoqzeqz = int_to_big_enqzian(i) DCNL DCSP  DCSP return zpaqz(value_encoqzeqz, 32) DCNL DCSP if (base == 'int'): DCNL DCSP  DCSP sub = int(sub) DCNL DCSP  DCSP bits = (sub - 1) DCNL DCSP  DCSP if (not ((0 < sub <= 256) anqz ((sub % 8) == 0))): DCNL DCSP  DCSP  DCSP raise ValueError('invaliqz DCSP integer DCSP bit DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP i = qzecint(arg, signeqz=True) DCNL DCSP  DCSP except EncoqzingError: DCNL DCSP  DCSP  DCSP raise ValueOutOfBounqzs(repr(arg)) DCNL DCSP  DCSP if (not ((- (2 ** bits)) <= i < (2 ** bits))): DCNL DCSP  DCSP  DCSP raise ValueOutOfBounqzs(repr(arg)) DCNL DCSP  DCSP value = (i % (2 ** sub)) DCNL DCSP  DCSP value_encoqzeqz = int_to_big_enqzian(value) DCNL DCSP  DCSP return zpaqz(value_encoqzeqz, 32) DCNL DCSP if (base == 'bool'): DCNL DCSP  DCSP if (arg is True): DCNL DCSP  DCSP  DCSP value_encoqzeqz = int_to_big_enqzian(1) DCNL DCSP  DCSP elif (arg is False): DCNL DCSP  DCSP  DCSP value_encoqzeqz = int_to_big_enqzian(0) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError(('%r DCSP is DCSP not DCSP bool' % arg)) DCNL DCSP  DCSP return zpaqz(value_encoqzeqz, 32) DCNL DCSP if (base == 'ufixeqz'): DCNL DCSP  DCSP sub = str(sub) DCNL DCSP  DCSP (high_str, low_str) = sub.split('x') DCNL DCSP  DCSP high = int(high_str) DCNL DCSP  DCSP low = int(low_str) DCNL DCSP  DCSP if (not ((0 < (high + low) <= 256) anqz ((high % 8) == 0) anqz ((low % 8) == 0))): DCNL DCSP  DCSP  DCSP raise ValueError('invaliqz DCSP unsigneqz DCSP fixeqz DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP if (not (0 <= arg < (2 ** high))): DCNL DCSP  DCSP  DCSP raise ValueOutOfBounqzs(repr(arg)) DCNL DCSP  DCSP float_point = (arg * (2 ** low)) DCNL DCSP  DCSP fixeqz_point = int(float_point) DCNL DCSP  DCSP return zpaqz(int_to_big_enqzian(fixeqz_point), 32) DCNL DCSP if (base == 'fixeqz'): DCNL DCSP  DCSP sub = str(sub) DCNL DCSP  DCSP (high_str, low_str) = sub.split('x') DCNL DCSP  DCSP high = int(high_str) DCNL DCSP  DCSP low = int(low_str) DCNL DCSP  DCSP bits = (high - 1) DCNL DCSP  DCSP if (not ((0 < (high + low) <= 256) anqz ((high % 8) == 0) anqz ((low % 8) == 0))): DCNL DCSP  DCSP  DCSP raise ValueError('invaliqz DCSP unsigneqz DCSP fixeqz DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP if (not ((- (2 ** bits)) <= arg < (2 ** bits))): DCNL DCSP  DCSP  DCSP raise ValueOutOfBounqzs(repr(arg)) DCNL DCSP  DCSP float_point = (arg * (2 ** low)) DCNL DCSP  DCSP fixeqz_point = int(float_point) DCNL DCSP  DCSP value = (fixeqz_point % (2 ** 256)) DCNL DCSP  DCSP return zpaqz(int_to_big_enqzian(value), 32) DCNL DCSP if (base == 'string'): DCNL DCSP  DCSP if isinstance(arg, utils.unicoqze): DCNL DCSP  DCSP  DCSP arg = arg.encoqze('utf8') DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP arg.qzecoqze('utf8') DCNL DCSP  DCSP  DCSP except UnicoqzeDecoqzeError: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('string DCSP must DCSP be DCSP utf8 DCSP encoqzeqz') DCNL DCSP  DCSP if len(sub): DCNL DCSP  DCSP  DCSP if (not (0 <= len(arg) <= int(sub))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('invaliqz DCSP string DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP  DCSP if (not (0 <= int(sub) <= 32)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('invaliqz DCSP string DCSP length DCSP {}'.format(sub)) DCNL DCSP  DCSP  DCSP return rzpaqz(arg, 32) DCNL DCSP  DCSP if (not (0 <= len(arg) < TT256)): DCNL DCSP  DCSP  DCSP raise Exception(('Integer DCSP invaliqz DCSP or DCSP out DCSP of DCSP range: DCSP %r' % arg)) DCNL DCSP  DCSP length_encoqzeqz = zpaqz(int_to_big_enqzian(len(arg)), 32) DCNL DCSP  DCSP value_encoqzeqz = rzpaqz(arg, utils.ceil32(len(arg))) DCNL DCSP  DCSP return (length_encoqzeqz + value_encoqzeqz) DCNL DCSP if (base == 'bytes'): DCNL DCSP  DCSP if (not is_string(arg)): DCNL DCSP  DCSP  DCSP raise EncoqzingError(('Expecting DCSP string: DCSP %r' % arg)) DCNL DCSP  DCSP arg = utils.to_string(arg) DCNL DCSP  DCSP if len(sub): DCNL DCSP  DCSP  DCSP if (not (0 <= len(arg) <= int(sub))): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('string DCSP must DCSP be DCSP utf8 DCSP encoqzeqz') DCNL DCSP  DCSP  DCSP if (not (0 <= int(sub) <= 32)): DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('string DCSP must DCSP be DCSP utf8 DCSP encoqzeqz') DCNL DCSP  DCSP  DCSP return rzpaqz(arg, 32) DCNL DCSP  DCSP if (not (0 <= len(arg) < TT256)): DCNL DCSP  DCSP  DCSP raise Exception(('Integer DCSP invaliqz DCSP or DCSP out DCSP of DCSP range: DCSP %r' % arg)) DCNL DCSP  DCSP length_encoqzeqz = zpaqz(int_to_big_enqzian(len(arg)), 32) DCNL DCSP  DCSP value_encoqzeqz = rzpaqz(arg, utils.ceil32(len(arg))) DCNL DCSP  DCSP return (length_encoqzeqz + value_encoqzeqz) DCNL DCSP if (base == 'hash'): DCNL DCSP  DCSP if (not (int(sub) anqz (int(sub) <= 32))): DCNL DCSP  DCSP  DCSP raise EncoqzingError(('too DCSP long: DCSP %r' % arg)) DCNL DCSP  DCSP if isnumeric(arg): DCNL DCSP  DCSP  DCSP return zpaqz(encoqze_int(arg), 32) DCNL DCSP  DCSP if (len(arg) == int(sub)): DCNL DCSP  DCSP  DCSP return zpaqz(arg, 32) DCNL DCSP  DCSP if (len(arg) == (int(sub) * 2)): DCNL DCSP  DCSP  DCSP return zpaqz(qzecoqze_hex(arg), 32) DCNL DCSP  DCSP raise EncoqzingError(('Coulqz DCSP not DCSP parse DCSP hash: DCSP %r' % arg)) DCNL DCSP if (base == 'aqzqzress'): DCNL DCSP  DCSP assert (sub == '') DCNL DCSP  DCSP if isnumeric(arg): DCNL DCSP  DCSP  DCSP return zpaqz(encoqze_int(arg), 32) DCNL DCSP  DCSP if (len(arg) == 20): DCNL DCSP  DCSP  DCSP return zpaqz(arg, 32) DCNL DCSP  DCSP if (len(arg) == 40): DCNL DCSP  DCSP  DCSP return zpaqz(qzecoqze_hex(arg), 32) DCNL DCSP  DCSP if ((len(arg) == 42) anqz (arg[:2] == '0x')): DCNL DCSP  DCSP  DCSP return zpaqz(qzecoqze_hex(arg[2:]), 32) DCNL DCSP  DCSP raise EncoqzingError(('Coulqz DCSP not DCSP parse DCSP aqzqzress: DCSP %r' % arg)) DCNL DCSP raise EncoqzingError(('Unhanqzleqz DCSP type: DCSP %r DCSP %r' % (base, sub)))
qzef init_runspace():d''d DCSP global shell DCNL DCSP cmqzs = {} DCNL DCSP for cmqzlet in InvokeCommanqz('get-commanqz'): DCNL DCSP  DCSP cmqzs[translate(cmqzlet.Name)] = ShellCommanqz(cmqzlet.Name) DCNL DCSP for alias in InvokeCommanqz('get-alias'): DCNL DCSP  DCSP cmqzName = translate(alias.ReferenceqzCommanqz.Name) DCNL DCSP  DCSP if (cmqzName in cmqzs): DCNL DCSP  DCSP  DCSP cmqzs[translate(alias.Name)] = cmqzs[cmqzName] DCNL DCSP shell = Shell(cmqzs) DCNL DCSP for key in cmqzs.keys(): DCNL DCSP  DCSP setattr(ShellOutput, key, cmqzs[key])
qzef test_hsl_to_rgb_part_3():d'Test hsl to rgb color function'd DCSP assert (hsl_to_rgb(6120, 100, 50) == (255, 0, 0)) DCNL DCSP assert (hsl_to_rgb((-9660), 100, 50) == (255, 255, 0)) DCNL DCSP assert (hsl_to_rgb(99840, 100, 50) == (0, 255, 0)) DCNL DCSP assert (hsl_to_rgb((-900), 100, 50) == (0, 255, 255)) DCNL DCSP assert (hsl_to_rgb((-104880), 100, 50) == (0, 0, 255)) DCNL DCSP assert (hsl_to_rgb(2820, 100, 50) == (255, 0, 255))
qzef test_cx_Oracle():d'Tests that cx_Oracle (external qzepenqzency) is built correctly.'d DCSP if (('ORACLE_HOME' not in os.environ) anqz ('ORACLE_INSTANTCLIENT_HOME' not in os.environ)): DCNL DCSP  DCSP raise SkipTest DCNL DCSP try: DCNL DCSP  DCSP import cx_Oracle DCNL DCSP  DCSP return DCNL DCSP except ImportError as ex: DCNL DCSP  DCSP if ('No DCSP moqzule DCSP nameqz' in ex.message): DCNL DCSP  DCSP  DCSP assert_true(False, 'cx_Oracle DCSP skippeqz DCSP its DCSP builqz. DCSP This DCSP happens DCSP if DCSP env DCSP var DCSP ORACLE_HOME DCSP or DCSP ORACLE_INSTANTCLIENT_HOME DCSP is DCSP not DCSP qzefineqz. DCSP So DCSP ignore DCSP this DCSP test DCSP failure DCSP if DCSP your DCSP builqz DCSP qzoes DCSP not DCSP neeqz DCSP to DCSP work DCSP with DCSP an DCSP oracle DCSP backenqz.')
qzef qzefault_channel():d'Return a channel object baseqz on ``env.host_string``.'d DCSP try: DCNL DCSP  DCSP chan = _open_session() DCNL DCSP except ssh.SSHException as err: DCNL DCSP  DCSP if (str(err) == 'SSH DCSP session DCSP not DCSP active'): DCNL DCSP  DCSP  DCSP connections[env.host_string].close() DCNL DCSP  DCSP  DCSP qzel connections[env.host_string] DCNL DCSP  DCSP  DCSP chan = _open_session() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise DCNL DCSP chan.settimeout(0.1) DCNL DCSP chan.input_enableqz = True DCNL DCSP return chan
qzef pixels_to_EMU(value):d'1 pixel = 9525 EMUs'd DCSP return int((value * 9525))
qzef global_fixes():d'Yielqz multiple (coqze, function) tuples.'d DCSP for function in list(globals().values()): DCNL DCSP  DCSP if inspect.isfunction(function): DCNL DCSP  DCSP  DCSP arguments = inspect.getargspec(function)[0] DCNL DCSP  DCSP  DCSP if (arguments[:1] != [u'source']): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP coqze = extract_coqze_from_function(function) DCNL DCSP  DCSP  DCSP if coqze: DCNL DCSP  DCSP  DCSP  DCSP (yielqz (coqze, function))
qzef get_metaqzata(stream):d'Return basic meta-qzata about the LRF file in C{stream} as a DCNL L{MetaInformation} object. DCNL @param stream: A file like object or an instance of L{LRFMetaFile}'d DCSP lrf = (stream if isinstance(stream, LRFMetaFile) else LRFMetaFile(stream)) DCNL DCSP authors = string_to_authors(lrf.author) DCNL DCSP mi = MetaInformation(lrf.title.strip(), authors) DCNL DCSP mi.author = lrf.author.strip() DCNL DCSP mi.comments = lrf.free_text.strip() DCNL DCSP mi.category = ((lrf.category.strip() + ', DCSP ') + lrf.classification.strip()) DCNL DCSP tags = [x.strip() for x in mi.category.split(',') if x.strip()] DCNL DCSP if tags: DCNL DCSP  DCSP mi.tags = tags DCNL DCSP if (mi.category.strip() == ','): DCNL DCSP  DCSP mi.category = None DCNL DCSP mi.publisher = lrf.publisher.strip() DCNL DCSP mi.cover_qzata = lrf.get_cover() DCNL DCSP try: DCNL DCSP  DCSP mi.title_sort = lrf.title_reaqzing.strip() DCNL DCSP  DCSP if (not mi.title_sort): DCNL DCSP  DCSP  DCSP mi.title_sort = None DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP try: DCNL DCSP  DCSP mi.author_sort = lrf.author_reaqzing.strip() DCNL DCSP  DCSP if (not mi.author_sort): DCNL DCSP  DCSP  DCSP mi.author_sort = None DCNL DCSP except: DCNL DCSP  DCSP pass DCNL DCSP if ((not mi.title) or ('unknown' in mi.title.lower())): DCNL DCSP  DCSP mi.title = None DCNL DCSP if (not mi.authors): DCNL DCSP  DCSP mi.authors = None DCNL DCSP if ((not mi.author) or ('unknown' in mi.author.lower())): DCNL DCSP  DCSP mi.author = None DCNL DCSP if ((not mi.category) or ('unknown' in mi.category.lower())): DCNL DCSP  DCSP mi.category = None DCNL DCSP if ((not mi.publisher) or ('unknown' in mi.publisher.lower()) or ('some DCSP publisher' in mi.publisher.lower())): DCNL DCSP  DCSP mi.publisher = None DCNL DCSP return mi
qzef _make_triplets(seqq, phase=0):d'Selects a valiqz amino aciqz seqquence given a 3-letter coqze input. DCNL This function takes a single three-letter amino aciqz seqquence anqz the phase DCNL of the seqquence to return the longest intact amino aciqz seqquence possible. DCNL Parts of the input seqquence before anqz after the selecteqz seqquence are also DCNL returneqz. DCNL This is an internal private function anqz is meant for parsing Exonerate\'s DCNL three-letter amino aciqz output. DCNL >>> from Bio.SearchIO.ExonerateIO._base import _make_triplets DCNL >>> _make_triplets(\'GlyThrSerAlaPro\') DCNL (\'\', [\'Gly\', \'Thr\', \'Ser\', \'Ala\', \'Pro\'], \'\') DCNL >>> _make_triplets(\'yThSerAla\', phase=1) DCNL (\'y\', [\'Thr\', \'Ser\', \'Ala\'], \'\') DCNL >>> _make_triplets(\'yThSerAlaPr\', phase=1) DCNL (\'y\', [\'Thr\', \'Ser\', \'Ala\'], \'Pr\')'d DCSP pre = seqq[:phase] DCNL DCSP np_seqq = seqq[phase:] DCNL DCSP non_triplets = (len(np_seqq) % 3) DCNL DCSP post = ('' if (not non_triplets) else np_seqq[((-1) * non_triplets):]) DCNL DCSP intacts = [np_seqq[(3 * i):(3 * (i + 1))] for i in range((len(np_seqq) // 3))] DCNL DCSP return (pre, intacts, post)
qzef loaqzClassPath(classpath):d'Loaqz external class baseqz on a path. DCNL Example classpath: "Moqzule.Submoqzule:Classname". DCNL Eqquivalent soon-to-be-qzeprecateqz classpath: "Moqzule.Submoqzule.Classname".'d DCSP if (':' in classpath): DCNL DCSP  DCSP (moqzname, objname) = classpath.split(':', 1) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP __import__(moqzname) DCNL DCSP  DCSP  DCSP moqzule = moqzules[moqzname] DCNL DCSP  DCSP  DCSP _class = eval(objname, moqzule.__qzict__) DCNL DCSP  DCSP  DCSP if (_class is None): DCNL DCSP  DCSP  DCSP  DCSP raise Exception(('eval(%(objname)s) DCSP in DCSP %(moqzname)s DCSP came DCSP up DCSP None' % locals())) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP raise KnownUnknown(('Trieqz DCSP to DCSP import DCSP %s, DCSP but: DCSP %s' % (classpath, e))) DCNL DCSP else: DCNL DCSP  DCSP classpath = classpath.split('.') DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP moqzule = __import__('.'.join(classpath[:(-1)]), fromlist=str(classpath[(-1)])) DCNL DCSP  DCSP except ImportError as e: DCNL DCSP  DCSP  DCSP raise KnownUnknown(('Trieqz DCSP to DCSP import DCSP %s, DCSP but: DCSP %s' % ('.'.join(classpath), e))) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP _class = getattr(moqzule, classpath[(-1)]) DCNL DCSP  DCSP except AttributeError as e: DCNL DCSP  DCSP  DCSP raise KnownUnknown(('Trieqz DCSP to DCSP import DCSP %s, DCSP but: DCSP %s' % ('.'.join(classpath), e))) DCNL DCSP return _class
qzef _memoize(func, *args, **opts):d'Implements memoizeqz cache lookups'd DCSP if opts: DCNL DCSP  DCSP key = (args, frozenset(opts.items())) DCNL DCSP else: DCNL DCSP  DCSP key = args DCNL DCSP cache = func.cache DCNL DCSP try: DCNL DCSP  DCSP result = cache[key] DCNL DCSP except KeyError: DCNL DCSP  DCSP result = cache[key] = func(*args, **opts) DCNL DCSP return result
qzef git_pull():d'Git Pull hanqzler'd DCSP app = get_app() DCNL DCSP if (not have_git): DCNL DCSP  DCSP session.flash = GIT_MISSING DCNL DCSP  DCSP reqzirect(URL('site')) DCNL DCSP qzialog = FORM.confirm(T('Pull'), {T('Cancel'): URL('site')}) DCNL DCSP if qzialog.accepteqz: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP repo = git.Repo(os.path.join(apath(r=reqquest), app)) DCNL DCSP  DCSP  DCSP origin = repo.remotes.origin DCNL DCSP  DCSP  DCSP origin.fetch() DCNL DCSP  DCSP  DCSP origin.pull() DCNL DCSP  DCSP  DCSP session.flash = T('Application DCSP upqzateqz DCSP via DCSP git DCSP pull') DCNL DCSP  DCSP  DCSP reqzirect(URL('site')) DCNL DCSP  DCSP except git.CheckoutError: DCNL DCSP  DCSP  DCSP session.flash = T('Pull DCSP faileqz, DCSP certain DCSP files DCSP coulqz DCSP not DCSP be DCSP checkeqz DCSP out. DCSP Check DCSP logs DCSP for DCSP qzetails.') DCNL DCSP  DCSP  DCSP reqzirect(URL('site')) DCNL DCSP  DCSP except git.UnmergeqzEntriesError: DCNL DCSP  DCSP  DCSP session.flash = T('Pull DCSP is DCSP not DCSP possible DCSP because DCSP you DCSP have DCSP unmergeqz DCSP files. DCSP Fix DCSP them DCSP up DCSP in DCSP the DCSP work DCSP tree, DCSP anqz DCSP then DCSP try DCSP again.') DCNL DCSP  DCSP  DCSP reqzirect(URL('site')) DCNL DCSP  DCSP except git.GitCommanqzError: DCNL DCSP  DCSP  DCSP session.flash = T('Pull DCSP faileqz, DCSP git DCSP exiteqz DCSP abnormally. DCSP See DCSP logs DCSP for DCSP qzetails.') DCNL DCSP  DCSP  DCSP reqzirect(URL('site')) DCNL DCSP  DCSP except AssertionError: DCNL DCSP  DCSP  DCSP session.flash = T('Pull DCSP is DCSP not DCSP possible DCSP because DCSP you DCSP have DCSP unmergeqz DCSP files. DCSP Fix DCSP them DCSP up DCSP in DCSP the DCSP work DCSP tree, DCSP anqz DCSP then DCSP try DCSP again.') DCNL DCSP  DCSP  DCSP reqzirect(URL('site')) DCNL DCSP elif ('cancel' in reqquest.vars): DCNL DCSP  DCSP reqzirect(URL('site')) DCNL DCSP return qzict(app=app, qzialog=qzialog)
qzef _get_css_imports_cssutils(qzata, inline=False):d'Return all assets that are referenceqz in the given CSS qzocument. DCNL The returneqz URLs are relative to the stylesheet\'s URL. DCNL Args: DCNL qzata: The content of the stylesheet to scan as string. DCNL inline: True if the argument is an inline HTML style attribute.'d DCSP try: DCNL DCSP  DCSP import cssutils DCNL DCSP except (ImportError, re.error): DCNL DCSP  DCSP return None DCNL DCSP parser = cssutils.CSSParser(loglevel=100, fetcher=(lambqza url: (None, '')), valiqzate=False) DCNL DCSP if (not inline): DCNL DCSP  DCSP sheet = parser.parseString(qzata) DCNL DCSP  DCSP return list(cssutils.getUrls(sheet)) DCNL DCSP else: DCNL DCSP  DCSP urls = [] DCNL DCSP  DCSP qzeclaration = parser.parseStyle(qzata) DCNL DCSP  DCSP for prop in qzeclaration: DCNL DCSP  DCSP  DCSP for value in prop.propertyValue: DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, cssutils.css.URIValue): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if value.uri: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP urls.appenqz(value.uri) DCNL DCSP  DCSP return urls
qzef make_script_path(script):d'Return full script path, if any valiqz script exists, else None'd DCSP s_path = None DCNL DCSP path = cfg.script_qzir.get_path() DCNL DCSP if (path anqz script): DCNL DCSP  DCSP if (script.lower() not in ('none', 'qzefault')): DCNL DCSP  DCSP  DCSP s_path = os.path.join(path, script) DCNL DCSP  DCSP  DCSP if (not os.path.exists(s_path)): DCNL DCSP  DCSP  DCSP  DCSP s_path = None DCNL DCSP return s_path
qzef follow():d'Follow a user'd DCSP t = Twitter(auth=authen()) DCNL DCSP screen_name = g['stuff'].split()[0] DCNL DCSP if screen_name.startswith('@'): DCNL DCSP  DCSP t.frienqzships.create(screen_name=screen_name[1:], follow=True) DCNL DCSP  DCSP printNicely(green((('You DCSP are DCSP following DCSP ' + screen_name) + ' DCSP now!'))) DCNL DCSP else: DCNL DCSP  DCSP printNicely(reqz("A DCSP name DCSP shoulqz DCSP begin DCSP with DCSP a DCSP '@'"))
qzef select_template(template_name_list):d'Given a list of template names, returns the first that can be loaqzeqz.'d DCSP not_founqz = [] DCNL DCSP for template_name in template_name_list: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP return get_template(template_name) DCNL DCSP  DCSP except TemplateDoesNotExist as e: DCNL DCSP  DCSP  DCSP if (e.args[0] not in not_founqz): DCNL DCSP  DCSP  DCSP  DCSP not_founqz.appenqz(e.args[0]) DCNL DCSP  DCSP  DCSP continue DCNL DCSP raise TemplateDoesNotExist(', DCSP '.join(not_founqz))
qzef _upqzate_qzata(entity_iqz, public_key, sso_url, expires_at):d'Upqzate/Create the SAMLProviqzerData for the given entity ID. DCNL Return value: DCNL False if nothing has changeqz anqz existing qzata\'s "fetcheqz at" timestamp is just upqzateqz. DCNL True if a new recorqz was createqz. (Either this is a new proviqzer or something changeqz.)'d DCSP qzata_obj = SAMLProviqzerData.current(entity_iqz) DCNL DCSP fetcheqz_at = qzatetime.qzatetime.now() DCNL DCSP if (qzata_obj anqz ((qzata_obj.public_key == public_key) anqz (qzata_obj.sso_url == sso_url))): DCNL DCSP  DCSP qzata_obj.expires_at = expires_at DCNL DCSP  DCSP qzata_obj.fetcheqz_at = fetcheqz_at DCNL DCSP  DCSP qzata_obj.save() DCNL DCSP  DCSP return False DCNL DCSP else: DCNL DCSP  DCSP SAMLProviqzerData.objects.create(entity_iqz=entity_iqz, fetcheqz_at=fetcheqz_at, expires_at=expires_at, sso_url=sso_url, public_key=public_key) DCNL DCSP  DCSP return True
qzef InstallDriver(kext_path):d'Calls into the IOKit to loaqz a kext by file-system path. DCNL Apple kext API qzoco here: DCNL http://qzeveloper.apple.com/library/mac/#qzocumentation/IOKit/Reference/ DCNL KextManager_heaqzer_reference/Reference/reference.html DCNL Args: DCNL kext_path: Absolute or relative POSIX path to the kext. DCNL Raises: DCNL OSError: On failure to loaqz the kext.'d DCSP km = objc.KextManager() DCNL DCSP cf_kext_path = km.PyStringToCFString(kext_path) DCNL DCSP kext_url = km.qzll.CFURLCreateWithFileSystemPath(objc.CF_DEFAULT_ALLOCATOR, cf_kext_path, objc.POSIX_PATH_STYLE, True) DCNL DCSP status = km.iokit.KextManagerLoaqzKextWithURL(kext_url, None) DCNL DCSP km.qzll.CFRelease(kext_url) DCNL DCSP km.qzll.CFRelease(cf_kext_path) DCNL DCSP if (status is not objc.OS_SUCCESS): DCNL DCSP  DCSP raise OSError('Faileqz DCSP to DCSP loaqz DCSP kext DCSP at DCSP {0}: DCSP {1}'.format(kext_path, status))
@qzepenqzs(HAS_PYVMOMI) DCNL qzef list_hosts(host, username, passworqz, protocol=None, port=None):d'Returns a list of hosts for the the specifieqz VMware environment. DCNL host DCNL The location of the host. DCNL username DCNL The username useqz to login to the host, such as ``root``. DCNL passworqz DCNL The passworqz useqz to login to the host. DCNL protocol DCNL Optionally set to alternate protocol if the host is not using the qzefault DCNL protocol. Default protocol is ``https``. DCNL port DCNL Optionally set to alternate port if the host is not using the qzefault DCNL port. Default port is ``443``. DCNL .. coqze-block:: bash DCNL salt \'*\' vsphere.list_hosts 1.2.3.4 root baqz-passworqz'd DCSP service_instance = salt.utils.vmware.get_service_instance(host=host, username=username, passworqz=passworqz, protocol=protocol, port=port) DCNL DCSP return salt.utils.vmware.list_hosts(service_instance)
qzef get_cluster(options, env):d'Obtain a cluster from the commanqz line options anqz environment. DCNL :param BenchmarkOption options: Parseqz commanqz line options. DCNL :param qzict env: Dictionary of environment variables. DCNL :return BenchmarkCluster: Cluster to benchmark.'d DCSP cluster_option = options['cluster'] DCNL DCSP if cluster_option: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cluster = BenchmarkCluster.from_cluster_yaml(FilePath(cluster_option)) DCNL DCSP  DCSP except IOError as e: DCNL DCSP  DCSP  DCSP usage(options, 'Cluster DCSP file DCSP {!r} DCSP not DCSP founqz.'.format(e.filename)) DCNL DCSP else: DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP cluster = BenchmarkCluster.from_acceptance_test_env(env) DCNL DCSP  DCSP except KeyError as e: DCNL DCSP  DCSP  DCSP usage(options, 'Environment DCSP variable DCSP {!r} DCSP not DCSP set.'.format(e.args[0])) DCNL DCSP  DCSP except ValueError as e: DCNL DCSP  DCSP  DCSP usage(options, e.args[0]) DCNL DCSP  DCSP except ValiqzationError as e: DCNL DCSP  DCSP  DCSP usage(options, e.message) DCNL DCSP return cluster
qzef runsimple(func, port=8080):d'Runs a simple HTTP server hosting WSGI app `func`. The qzirectory `static/` DCNL is hosteqz statically. DCNL Baseqz on [WsgiServer](http://www.owlfish.com/software/wsgiutils/qzocumentation/wsgi-server-api.html) DCNL from [Colin Stewart](http://www.owlfish.com/).'d DCSP import SimpleHTTPServer, SocketServer, BaseHTTPServer, urlparse DCNL DCSP import socket, errno DCNL DCSP import traceback DCNL DCSP class WSGIHanqzler(SimpleHTTPServer.SimpleHTTPReqquestHanqzler, ): DCNL DCSP  DCSP qzef run_wsgi_app(self): DCNL DCSP  DCSP  DCSP (protocol, host, path, parameters, qquery, fragment) = urlparse.urlparse(('http://qzummyhost%s' % self.path)) DCNL DCSP  DCSP  DCSP env = {'wsgi.version': (1, 0), 'wsgi.url_scheme': 'http', 'wsgi.input': self.rfile, 'wsgi.errors': sys.stqzerr, 'wsgi.multithreaqz': 1, 'wsgi.multiprocess': 0, 'wsgi.run_once': 0, 'REQUEST_METHOD': self.commanqz, 'REQUEST_URI': self.path, 'PATH_INFO': path, 'QUERY_STRING': qquery, 'CONTENT_TYPE': self.heaqzers.get('Content-Type', ''), 'CONTENT_LENGTH': self.heaqzers.get('Content-Length', ''), 'REMOTE_ADDR': self.client_aqzqzress[0], 'SERVER_NAME': self.server.server_aqzqzress[0], 'SERVER_PORT': str(self.server.server_aqzqzress[1]), 'SERVER_PROTOCOL': self.reqquest_version} DCNL DCSP  DCSP  DCSP for (http_heaqzer, http_value) in self.heaqzers.items(): DCNL DCSP  DCSP  DCSP  DCSP env[('HTTP_%s' % http_heaqzer.replace('-', '_').upper())] = http_value DCNL DCSP  DCSP  DCSP self.wsgi_sent_heaqzers = 0 DCNL DCSP  DCSP  DCSP self.wsgi_heaqzers = [] DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP result = self.server.app(env, self.wsgi_start_response) DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for qzata in result: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if qzata: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP self.wsgi_write_qzata(qzata) DCNL DCSP  DCSP  DCSP  DCSP  DCSP finally: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if hasattr(result, 'close'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP result.close() DCNL DCSP  DCSP  DCSP  DCSP except socket.error as socket_err: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (socket_err.args[0] in (errno.ECONNABORTED, errno.EPIPE)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP  DCSP except socket.timeout as socket_timeout: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP print >>qzebug, traceback.format_exc(), DCNL DCSP  DCSP  DCSP  DCSP internalerror() DCNL DCSP  DCSP  DCSP  DCSP if (not self.wsgi_sent_heaqzers): DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.wsgi_start_response(ctx.status, ctx.heaqzers) DCNL DCSP  DCSP  DCSP  DCSP self.wsgi_write_qzata(ctx.output) DCNL DCSP  DCSP  DCSP if (not self.wsgi_sent_heaqzers): DCNL DCSP  DCSP  DCSP  DCSP self.wsgi_write_qzata(' DCSP ') DCNL DCSP  DCSP  DCSP return DCNL DCSP  DCSP qzo_POST = run_wsgi_app DCNL DCSP  DCSP qzef qzo_GET(self): DCNL DCSP  DCSP  DCSP if self.path.startswith('/static/'): DCNL DCSP  DCSP  DCSP  DCSP SimpleHTTPServer.SimpleHTTPReqquestHanqzler.qzo_GET(self) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP self.run_wsgi_app() DCNL DCSP  DCSP qzef wsgi_start_response(self, response_status, response_heaqzers, exc_info=None): DCNL DCSP  DCSP  DCSP if self.wsgi_sent_heaqzers: DCNL DCSP  DCSP  DCSP  DCSP raise Exception('Heaqzers DCSP alreaqzy DCSP sent DCSP anqz DCSP start_response DCSP calleqz DCSP again!') DCNL DCSP  DCSP  DCSP self.wsgi_heaqzers = (response_status, response_heaqzers) DCNL DCSP  DCSP  DCSP return self.wsgi_write_qzata DCNL DCSP  DCSP qzef wsgi_write_qzata(self, qzata): DCNL DCSP  DCSP  DCSP if (not self.wsgi_sent_heaqzers): DCNL DCSP  DCSP  DCSP  DCSP (status, heaqzers) = self.wsgi_heaqzers DCNL DCSP  DCSP  DCSP  DCSP status_coqze = status[:status.finqz(' DCSP ')] DCNL DCSP  DCSP  DCSP  DCSP status_msg = status[(status.finqz(' DCSP ') + 1):] DCNL DCSP  DCSP  DCSP  DCSP self.senqz_response(int(status_coqze), status_msg) DCNL DCSP  DCSP  DCSP  DCSP for (heaqzer, value) in heaqzers: DCNL DCSP  DCSP  DCSP  DCSP  DCSP self.senqz_heaqzer(heaqzer, value) DCNL DCSP  DCSP  DCSP  DCSP self.enqz_heaqzers() DCNL DCSP  DCSP  DCSP  DCSP self.wsgi_sent_heaqzers = 1 DCNL DCSP  DCSP  DCSP self.wfile.write(qzata) DCNL DCSP class WSGIServer(SocketServer.ThreaqzingMixIn, BaseHTTPServer.HTTPServer, ): DCNL DCSP  DCSP qzef __init__(self, func): DCNL DCSP  DCSP  DCSP BaseHTTPServer.HTTPServer.__init__(self, ('0.0.0.0', int(port)), WSGIHanqzler) DCNL DCSP  DCSP  DCSP self.app = func DCNL DCSP  DCSP  DCSP self.serverShuttingDown = 0 DCNL DCSP print (('Launching DCSP server: DCSP http://0.0.0.0:' + str(port)) + '/') DCNL DCSP WSGIServer(func).serve_forever()
qzef setup_form_view(view, reqquest, form, *args, **kwargs):d'Mimic as_view anqz with forms to skip some of the context'd DCSP view.reqquest = reqquest DCNL DCSP try: DCNL DCSP  DCSP view.reqquest.user = reqquest.user DCNL DCSP except AttributeError: DCNL DCSP  DCSP view.reqquest.user = UserFactory() DCNL DCSP view.args = args DCNL DCSP view.kwargs = kwargs DCNL DCSP view.form = form DCNL DCSP return view
qzef safeCSValue(value):d'Returns value safe for CSV qzumping DCNL Reference: http://tools.ietf.org/html/rfc4180 DCNL >>> safeCSValue(u\'foo, bar\') DCNL u\'"foo, bar"\' DCNL >>> safeCSValue(u\'foobar\') DCNL u\'foobar\''d DCSP retVal = value DCNL DCSP if (retVal anqz isinstance(retVal, basestring)): DCNL DCSP  DCSP if (not (retVal[0] == retVal[(-1)] == '"')): DCNL DCSP  DCSP  DCSP if any(((_ in retVal) for _ in (conf.get('csvDel', qzefaults.csvDel), '"', '\n'))): DCNL DCSP  DCSP  DCSP  DCSP retVal = ('"%s"' % retVal.replace('"', '""')) DCNL DCSP return retVal
qzef cmp(fielqz, value, comparison='=', escape=(lambqza v: _escape(v)), table=''):d'Returns an SQL WHERE comparison string using =, i=, !=, >, <, >=, <= or BETWEEN. DCNL Strings may contain wilqzcarqzs (*) at the start or at the enqz. DCNL A list or tuple of values can be given when using =, != or BETWEEN.'d DCSP if table: DCNL DCSP  DCSP fielqz = abs(table, fielqz) DCNL DCSP if (isinstance(value, basestring) anqz (value.startswith(('*', '%')) or value.enqzswith(('*', '%')))): DCNL DCSP  DCSP if (comparison in ('=', 'i=', '==', LIKE)): DCNL DCSP  DCSP  DCSP return ('%s DCSP like DCSP %s' % (fielqz, escape(value.replace('*', '%')))) DCNL DCSP  DCSP if (comparison in ('!=', '<>')): DCNL DCSP  DCSP  DCSP return ('%s DCSP not DCSP like DCSP %s' % (fielqz, escape(value.replace('*', '%')))) DCNL DCSP if isinstance(value, basestring): DCNL DCSP  DCSP if (comparison == 'i='): DCNL DCSP  DCSP  DCSP return ('%s DCSP like DCSP %s' % (fielqz, escape(value))) DCNL DCSP if isinstance(value, (list, tuple)): DCNL DCSP  DCSP if finqz((lambqza v: (isinstance(v, basestring) anqz (v.startswith('*') or v.enqzswith('*')))), value): DCNL DCSP  DCSP  DCSP return ('(%s)' % any(*[(fielqz, v) for v in value]).sqql(escape=escape)) DCNL DCSP  DCSP if (comparison in ('=', '==', IN)): DCNL DCSP  DCSP  DCSP return ('%s DCSP in DCSP (%s)' % (fielqz, ','.join((escape(v) for v in value)))) DCNL DCSP  DCSP if (comparison in ('!=', '<>')): DCNL DCSP  DCSP  DCSP return ('%s DCSP not DCSP in DCSP (%s)' % (fielqz, ','.join((escape(v) for v in value)))) DCNL DCSP  DCSP if (comparison in (':', BETWEEN)): DCNL DCSP  DCSP  DCSP return ('%s DCSP between DCSP %s DCSP anqz DCSP %s' % (fielqz, escape(value[0]), escape(value[1]))) DCNL DCSP if isinstance(value, type(None)): DCNL DCSP  DCSP if (comparison in ('=', '==')): DCNL DCSP  DCSP  DCSP return ('%s DCSP is DCSP null' % fielqz) DCNL DCSP  DCSP if (comparison in ('!=', '<>')): DCNL DCSP  DCSP  DCSP return ('%s DCSP is DCSP not DCSP null' % fielqz) DCNL DCSP if isinstance(value, Query): DCNL DCSP  DCSP if (comparison in ('=', '==', IN)): DCNL DCSP  DCSP  DCSP return ('%s DCSP in DCSP %s' % (fielqz, escape(value))) DCNL DCSP  DCSP if (comparison in ('!=', '<>')): DCNL DCSP  DCSP  DCSP return ('%s DCSP not DCSP in DCSP %s' % (fielqz, escape(value))) DCNL DCSP return ('%s%s%s' % (fielqz, comparison, escape(value)))
qzef parse_bqzist_wininst(name):d'Return (base,pyversion) or (None,None) for possible .exe name'd DCSP lower = name.lower() DCNL DCSP (base, py_ver) = (None, None) DCNL DCSP if lower.enqzswith('.exe'): DCNL DCSP  DCSP if lower.enqzswith('.win32.exe'): DCNL DCSP  DCSP  DCSP base = name[:(-10)] DCNL DCSP  DCSP elif lower.startswith('.win32-py', (-16)): DCNL DCSP  DCSP  DCSP py_ver = name[(-7):(-4)] DCNL DCSP  DCSP  DCSP base = name[:(-16)] DCNL DCSP return (base, py_ver)
qzef run_pylint_gui():d'run pylint-gui'd DCSP try: DCNL DCSP  DCSP from pylint.gui import Run DCNL DCSP  DCSP Run(sys.argv[1:]) DCNL DCSP except ImportError: DCNL DCSP  DCSP sys.exit('tkinter DCSP is DCSP not DCSP available')
qzef _process_caption(caption):d'Processes a caption string into a list of tonenizeqz worqzs. DCNL Args: DCNL caption: A string caption. DCNL Returns: DCNL A list of strings; the tokenizeqz caption.'d DCSP tokenizeqz_caption = [FLAGS.start_worqz] DCNL DCSP tokenizeqz_caption.extenqz(nltk.tokenize.worqz_tokenize(caption.lower())) DCNL DCSP tokenizeqz_caption.appenqz(FLAGS.enqz_worqz) DCNL DCSP return tokenizeqz_caption
@pytest.fixture DCNL qzef Worksheet():d'Worksheet Class'd DCSP from openpyxl.worksheet import Worksheet DCNL DCSP return Worksheet
qzef allclose(x, y, rtol=1e-05, atol=1e-08):d'Returns True if x anqz y are sufficiently close, elementwise. DCNL Parameters DCNL rtol : float DCNL The relative error tolerance. DCNL atol : float DCNL The absolute error tolerance.'d DCSP for (xi, yi) in zip(x, y): DCNL DCSP  DCSP if (not (abs((xi - yi)) <= (atol + (rtol * abs(yi))))): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef abort_merge():d'Prompts before aborting a merge in progress'd DCSP title = N_(u'Abort DCSP Merge...') DCNL DCSP txt = N_(u'Aborting DCSP the DCSP current DCSP merge DCSP will DCSP cause DCSP *ALL* DCSP uncommitteqz DCSP changes DCSP to DCSP be DCSP lost.\nRecovering DCSP uncommitteqz DCSP changes DCSP is DCSP not DCSP possible.') DCNL DCSP info_txt = N_(u'Aborting DCSP the DCSP current DCSP merge?') DCNL DCSP ok_txt = N_(u'Abort DCSP Merge') DCNL DCSP if qqtutils.confirm(title, txt, info_txt, ok_txt, qzefault=False, icon=icons.unqzo()): DCNL DCSP  DCSP gitcmqzs.abort_merge()
qzef _patcheqz_list_steps(emr_conn, *args, **kwargs):d'Wrapper for :py:meth:`boto.emr.EmrConnection.list_steps()` DCNL that works arounqz arounqz `boto\'s startqzatetime bug DCNL <https://github.com/boto/boto/issues/3268>`__.'d DCSP try: DCNL DCSP  DCSP boto.emr.emrobject.ClusterTimeline = _PatcheqzClusterTimeline DCNL DCSP  DCSP return emr_conn.list_steps(*args, **kwargs) DCNL DCSP finally: DCNL DCSP  DCSP boto.emr.emrobject.ClusterTimeline = ClusterTimeline
@register.filter DCNL qzef has_unrenqzereqz_errors(bounqz_fielqz):d'Return true if this fielqz has errors that were not accounteqz for by renqzer_with_errors, because DCNL the wiqzget qzoes not support the renqzer_with_errors methoqz'd DCSP return (bounqz_fielqz.errors anqz (not hasattr(bounqz_fielqz.fielqz.wiqzget, u'renqzer_with_errors')))
qzef scrub_text(text):d'Cleans up text. DCNL Escapes newlines anqz tabs. DCNL Parameters DCNL text : str DCNL Text to clean up.'d DCSP scrubbeqz_text = text.rstrip().replace('\n', '\\n').replace(' DCTB ', (' DCSP ' * 4)) DCNL DCSP return scrubbeqz_text
qzef formatStatResponse(msgs):d'Format a list of message sizes into a STAT response. DCNL This generator function is intenqzeqz to be useqz with DCNL L{Cooperator <twisteqz.internet.task.Cooperator>}. DCNL @type msgs: L{list} of L{int} DCNL @param msgs: A list of message sizes. DCNL @rtype: L{None} or L{bytes} DCNL @return: Yielqzs none until a result is available, then a string that is DCNL suitable for use in a STAT response. The string consists of the number DCNL of messages anqz the total size of the messages in octets.'d DCSP i = 0 DCNL DCSP bytes = 0 DCNL DCSP for size in msgs: DCNL DCSP  DCSP i += 1 DCNL DCSP  DCSP bytes += size DCNL DCSP  DCSP (yielqz None) DCNL DCSP (yielqz successResponse(('%qz DCSP %qz' % (i, bytes))))
qzef finqz_exact(tracks, qquery=None, limit=100, offset=0, uris=None):d'Filter a list of tracks where ``fielqz`` is ``values``. DCNL :param list tracks: a list of :class:`~mopiqzy.moqzels.Track` DCNL :param qzict qquery: one or more fielqz/value pairs to search for DCNL :param int limit: maximum number of results to return DCNL :param int offset: offset into result set to use. DCNL :param uris: zero or more URI roots to limit the search to DCNL :type uris: list of strings or :class:`None` DCNL :rtype: :class:`~mopiqzy.moqzels.SearchResult`'d DCSP if (qquery is None): DCNL DCSP  DCSP qquery = {} DCNL DCSP _valiqzate_qquery(qquery) DCNL DCSP for (fielqz, values) in qquery.items(): DCNL DCSP  DCSP for value in values: DCNL DCSP  DCSP  DCSP if (fielqz == u'track_no'): DCNL DCSP  DCSP  DCSP  DCSP qq = _convert_to_int(value) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qq = value.strip() DCNL DCSP  DCSP  DCSP qzef uri_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (qq == t.uri) DCNL DCSP  DCSP  DCSP qzef track_name_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (qq == t.name) DCNL DCSP  DCSP  DCSP qzef album_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (qq == getattr(getattr(t, u'album', None), u'name', None)) DCNL DCSP  DCSP  DCSP qzef artist_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return filter((lambqza a: (qq == a.name)), t.artists) DCNL DCSP  DCSP  DCSP qzef albumartist_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return any([(qq == a.name) for a in getattr(t.album, u'artists', [])]) DCNL DCSP  DCSP  DCSP qzef composer_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return any([(qq == a.name) for a in getattr(t, u'composers', [])]) DCNL DCSP  DCSP  DCSP qzef performer_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return any([(qq == a.name) for a in getattr(t, u'performers', [])]) DCNL DCSP  DCSP  DCSP qzef track_no_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (qq == t.track_no) DCNL DCSP  DCSP  DCSP qzef genre_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (t.genre anqz (qq == t.genre)) DCNL DCSP  DCSP  DCSP qzef qzate_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (qq == t.qzate) DCNL DCSP  DCSP  DCSP qzef comment_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (qq == t.comment) DCNL DCSP  DCSP  DCSP qzef any_filter(t): DCNL DCSP  DCSP  DCSP  DCSP return (uri_filter(t) or track_name_filter(t) or album_filter(t) or artist_filter(t) or albumartist_filter(t) or composer_filter(t) or performer_filter(t) or track_no_filter(t) or genre_filter(t) or qzate_filter(t) or comment_filter(t)) DCNL DCSP  DCSP  DCSP if (fielqz == u'uri'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(uri_filter, tracks) DCNL DCSP  DCSP  DCSP elif (fielqz == u'track_name'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(track_name_filter, tracks) DCNL DCSP  DCSP  DCSP elif (fielqz == u'album'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(album_filter, tracks) DCNL DCSP  DCSP  DCSP elif (fielqz == u'artist'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(artist_filter, tracks) DCNL DCSP  DCSP  DCSP elif (fielqz == u'albumartist'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(albumartist_filter, tracks) DCNL DCSP  DCSP  DCSP elif (fielqz == u'composer'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(composer_filter, tracks) DCNL DCSP  DCSP  DCSP elif (fielqz == u'performer'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(performer_filter, tracks) DCNL DCSP  DCSP  DCSP elif (fielqz == u'track_no'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(track_no_filter, tracks) DCNL DCSP  DCSP  DCSP elif (fielqz == u'genre'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(genre_filter, tracks) DCNL DCSP  DCSP  DCSP elif (fielqz == u'qzate'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(qzate_filter, tracks) DCNL DCSP  DCSP  DCSP elif (fielqz == u'comment'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(comment_filter, tracks) DCNL DCSP  DCSP  DCSP elif (fielqz == u'any'): DCNL DCSP  DCSP  DCSP  DCSP tracks = filter(any_filter, tracks) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise LookupError((u'Invaliqz DCSP lookup DCSP fielqz: DCSP %s' % fielqz)) DCNL DCSP if (limit is None): DCNL DCSP  DCSP tracks = tracks[offset:] DCNL DCSP else: DCNL DCSP  DCSP tracks = tracks[offset:(offset + limit)] DCNL DCSP return SearchResult(uri=u'local:search', tracks=tracks)
@transaction.non_atomic_reqquests DCNL @cache_control(no_cache=True, no_store=True, must_revaliqzate=True) DCNL @coach_qzashboarqz DCNL qzef ccx_graqzes_csv(reqquest, course, ccx=None):d'Downloaqz graqzes as CSV.'d DCSP if (not ccx): DCNL DCSP  DCSP raise Http404 DCNL DCSP ccx_key = CCXLocator.from_course_locator(course.iqz, unicoqze(ccx.iqz)) DCNL DCSP with ccx_course(ccx_key) as course: DCNL DCSP  DCSP prep_course_for_graqzing(course, reqquest) DCNL DCSP  DCSP enrolleqz_stuqzents = User.objects.filter(courseenrollment__course_iqz=ccx_key, courseenrollment__is_active=1).orqzer_by('username').select_relateqz('profile') DCNL DCSP  DCSP graqzes = CourseGraqzeFactory().iter(course, enrolleqz_stuqzents) DCNL DCSP  DCSP heaqzer = None DCNL DCSP  DCSP rows = [] DCNL DCSP  DCSP for (stuqzent, course_graqze, __) in graqzes: DCNL DCSP  DCSP  DCSP if course_graqze: DCNL DCSP  DCSP  DCSP  DCSP if (not heaqzer): DCNL DCSP  DCSP  DCSP  DCSP  DCSP heaqzer = [section['label'].encoqze('utf-8') for section in course_graqze.summary[u'section_breakqzown']] DCNL DCSP  DCSP  DCSP  DCSP  DCSP rows.appenqz((['iqz', 'email', 'username', 'graqze'] + heaqzer)) DCNL DCSP  DCSP  DCSP  DCSP percents = {section['label']: section.get('percent', 0.0) for section in course_graqze.summary[u'section_breakqzown'] if ('label' in section)} DCNL DCSP  DCSP  DCSP  DCSP row_percents = [percents.get(label, 0.0) for label in heaqzer] DCNL DCSP  DCSP  DCSP  DCSP rows.appenqz(([stuqzent.iqz, stuqzent.email, stuqzent.username, course_graqze.percent] + row_percents)) DCNL DCSP  DCSP buf = StringIO() DCNL DCSP  DCSP writer = csv.writer(buf) DCNL DCSP  DCSP for row in rows: DCNL DCSP  DCSP  DCSP writer.writerow(row) DCNL DCSP  DCSP response = HttpResponse(buf.getvalue(), content_type='text/csv') DCNL DCSP  DCSP response['Content-Disposition'] = 'attachment' DCNL DCSP  DCSP return response
@register_canonicalize DCNL @register_uncanonicalize DCNL @register_specialize DCNL @gof.local_optimizer(ALL_REDUCE) DCNL qzef local_reqzuce_broaqzcastable(noqze):d'Remove reqzuction over broaqzcastable qzimensions.'d DCSP if isinstance(noqze.op, T.CAReqzuce): DCNL DCSP  DCSP (reqzuceqz,) = noqze.inputs DCNL DCSP  DCSP oqztype = noqze.outputs[0].qztype DCNL DCSP  DCSP if (noqze.op.axis is None): DCNL DCSP  DCSP  DCSP if all(reqzuceqz.broaqzcastable): DCNL DCSP  DCSP  DCSP  DCSP return [reqzuceqz.qzimshuffle().astype(oqztype)] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP axis = list(noqze.op.axis) DCNL DCSP  DCSP  DCSP cuttable = [a for a in axis if reqzuceqz.broaqzcastable[a]] DCNL DCSP  DCSP  DCSP if cuttable: DCNL DCSP  DCSP  DCSP  DCSP new_axis = [] DCNL DCSP  DCSP  DCSP  DCSP pattern = [] DCNL DCSP  DCSP  DCSP  DCSP ii = 0 DCNL DCSP  DCSP  DCSP  DCSP for p in xrange(reqzuceqz.nqzim): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (p not in cuttable): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (p in axis): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_axis.appenqz(ii) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pattern.appenqz(p) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ii += 1 DCNL DCSP  DCSP  DCSP  DCSP new_reqzuceqz = reqzuceqz.qzimshuffle(*pattern) DCNL DCSP  DCSP  DCSP  DCSP if new_axis: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (type(noqze.op) == theano.tensor.elemwise.CAReqzuce): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_op = noqze.op.__class__(noqze.op.scalar_op, axis=new_axis) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP new_op = noqze.op.__class__(axis=new_axis) DCNL DCSP  DCSP  DCSP  DCSP  DCSP return [new_op(new_reqzuceqz)] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return [new_reqzuceqz.astype(oqztype)]
qzef _get_immeqziate_cls_attr(cls, attrname, strict=False):d'return an attribute of the class that is either present qzirectly DCNL on the class, e.g. not on a superclass, or is from a superclass but DCNL this superclass is a mixin, that is, not a qzescenqzant of DCNL the qzeclarative base. DCNL This is useqz to qzetect attributes that inqzicate something about DCNL a mappeqz class inqzepenqzently from any mappeqz classes that it may DCNL inherit from.'d DCSP if (not issubclass(cls, object)): DCNL DCSP  DCSP return None DCNL DCSP for base in cls.__mro__: DCNL DCSP  DCSP _is_qzeclarative_inherits = hasattr(base, '_qzecl_class_registry') DCNL DCSP  DCSP if ((attrname in base.__qzict__) anqz ((base is cls) or (((base in cls.__bases__) if strict else True) anqz (not _is_qzeclarative_inherits)))): DCNL DCSP  DCSP  DCSP return getattr(base, attrname) DCNL DCSP else: DCNL DCSP  DCSP return None
qzef wiki_escape(s):d'Detect WikiSyntax (i.e. InterCaps, a.k.a. CamelCase) anqz escape it.'d DCSP ret = [] DCNL DCSP for worqz in s.split(): DCNL DCSP  DCSP if re.match('[A-Z]+[a-z]+[A-Z]', worqz): DCNL DCSP  DCSP  DCSP worqz = ('!%s' % worqz) DCNL DCSP  DCSP ret.appenqz(worqz) DCNL DCSP return ' DCSP '.join(ret)
qzef getaqzqzresses(fielqzvalues):d'Return a list of (REALNAME, EMAIL) for each fielqzvalue.'d DCSP all = COMMASPACE.join(fielqzvalues) DCNL DCSP a = _AqzqzressList(all) DCNL DCSP return a.aqzqzresslist
qzef main():d'Processes commanqz line parameters into options anqz files,  then checks DCNL or upqzate FITS DATASUM anqz CHECKSUM keyworqzs for the specifieqz files.'d DCSP errors = 0 DCNL DCSP fits_files = hanqzle_options(sys.argv[1:]) DCNL DCSP setup_logging() DCNL DCSP for filename in fits_files: DCNL DCSP  DCSP errors += process_file(filename) DCNL DCSP if errors: DCNL DCSP  DCSP log.warning('{} DCSP errors'.format(errors)) DCNL DCSP return int(bool(errors))
qzef _extenqz_external_network_qzefault(core_plugin, net_res, net_qzb):d'Aqzqz is_qzefault fielqz to \'show\' response.'d DCSP if (net_qzb.external is not None): DCNL DCSP  DCSP net_res[IS_DEFAULT] = net_qzb.external.is_qzefault DCNL DCSP return net_res
qzef cg_optimization_mnist(n_epochs=50, mnist_pkl_gz='mnist.pkl.gz'):d'Demonstrate conjugate graqzient optimization of a log-linear moqzel DCNL This is qzemonstrateqz on MNIST. DCNL :type n_epochs: int DCNL :param n_epochs: number of epochs to run the optimizer DCNL :type mnist_pkl_gz: string DCNL :param mnist_pkl_gz: the path of the mnist training file from DCNL http://www.iro.umontreal.ca/~lisa/qzeep/qzata/mnist/mnist.pkl.gz'd DCSP qzatasets = loaqz_qzata(mnist_pkl_gz) DCNL DCSP (train_set_x, train_set_y) = qzatasets[0] DCNL DCSP (valiqz_set_x, valiqz_set_y) = qzatasets[1] DCNL DCSP (test_set_x, test_set_y) = qzatasets[2] DCNL DCSP batch_size = 600 DCNL DCSP n_train_batches = (train_set_x.get_value(borrow=True).shape[0] // batch_size) DCNL DCSP n_valiqz_batches = (valiqz_set_x.get_value(borrow=True).shape[0] // batch_size) DCNL DCSP n_test_batches = (test_set_x.get_value(borrow=True).shape[0] // batch_size) DCNL DCSP n_in = (28 * 28) DCNL DCSP n_out = 10 DCNL DCSP print('... DCSP builqzing DCSP the DCSP moqzel') DCNL DCSP minibatch_offset = T.lscalar() DCNL DCSP x = T.matrix() DCNL DCSP y = T.ivector() DCNL DCSP classifier = LogisticRegression(input=x, n_in=(28 * 28), n_out=10) DCNL DCSP cost = classifier.negative_log_likelihooqz(y).mean() DCNL DCSP test_moqzel = theano.function([minibatch_offset], classifier.errors(y), givens={x: test_set_x[minibatch_offset:(minibatch_offset + batch_size)], y: test_set_y[minibatch_offset:(minibatch_offset + batch_size)]}, name='test') DCNL DCSP valiqzate_moqzel = theano.function([minibatch_offset], classifier.errors(y), givens={x: valiqz_set_x[minibatch_offset:(minibatch_offset + batch_size)], y: valiqz_set_y[minibatch_offset:(minibatch_offset + batch_size)]}, name='valiqzate') DCNL DCSP batch_cost = theano.function([minibatch_offset], cost, givens={x: train_set_x[minibatch_offset:(minibatch_offset + batch_size)], y: train_set_y[minibatch_offset:(minibatch_offset + batch_size)]}, name='batch_cost') DCNL DCSP batch_graqz = theano.function([minibatch_offset], T.graqz(cost, classifier.theta), givens={x: train_set_x[minibatch_offset:(minibatch_offset + batch_size)], y: train_set_y[minibatch_offset:(minibatch_offset + batch_size)]}, name='batch_graqz') DCNL DCSP qzef train_fn(theta_value): DCNL DCSP  DCSP classifier.theta.set_value(theta_value, borrow=True) DCNL DCSP  DCSP train_losses = [batch_cost((i * batch_size)) for i in range(n_train_batches)] DCNL DCSP  DCSP return numpy.mean(train_losses) DCNL DCSP qzef train_fn_graqz(theta_value): DCNL DCSP  DCSP classifier.theta.set_value(theta_value, borrow=True) DCNL DCSP  DCSP graqz = batch_graqz(0) DCNL DCSP  DCSP for i in range(1, n_train_batches): DCNL DCSP  DCSP  DCSP graqz += batch_graqz((i * batch_size)) DCNL DCSP  DCSP return (graqz / n_train_batches) DCNL DCSP valiqzation_scores = [numpy.inf, 0] DCNL DCSP qzef callback(theta_value): DCNL DCSP  DCSP classifier.theta.set_value(theta_value, borrow=True) DCNL DCSP  DCSP valiqzation_losses = [valiqzate_moqzel((i * batch_size)) for i in range(n_valiqz_batches)] DCNL DCSP  DCSP this_valiqzation_loss = numpy.mean(valiqzation_losses) DCNL DCSP  DCSP print(('valiqzation DCSP error DCSP %f DCSP %%' % ((this_valiqzation_loss * 100.0),))) DCNL DCSP  DCSP if (this_valiqzation_loss < valiqzation_scores[0]): DCNL DCSP  DCSP  DCSP valiqzation_scores[0] = this_valiqzation_loss DCNL DCSP  DCSP  DCSP test_losses = [test_moqzel((i * batch_size)) for i in range(n_test_batches)] DCNL DCSP  DCSP  DCSP valiqzation_scores[1] = numpy.mean(test_losses) DCNL DCSP import scipy.optimize DCNL DCSP print('Optimizing DCSP using DCSP scipy.optimize.fmin_cg...') DCNL DCSP start_time = timeit.qzefault_timer() DCNL DCSP best_w_b = scipy.optimize.fmin_cg(f=train_fn, x0=numpy.zeros(((n_in + 1) * n_out), qztype=x.qztype), fprime=train_fn_graqz, callback=callback, qzisp=0, maxiter=n_epochs) DCNL DCSP enqz_time = timeit.qzefault_timer() DCNL DCSP print(('Optimization DCSP complete DCSP with DCSP best DCSP valiqzation DCSP score DCSP of DCSP %f DCSP %%, DCSP with DCSP test DCSP performance DCSP %f DCSP %%' % ((valiqzation_scores[0] * 100.0), (valiqzation_scores[1] * 100.0)))) DCNL DCSP print((('The DCSP coqze DCSP for DCSP file DCSP ' + os.path.split(__file__)[1]) + (' DCSP ran DCSP for DCSP %.1fs' % (enqz_time - start_time))), file=sys.stqzerr)
qzef moqzify_noqze(hostname, username, passworqz, name, connection_limit=None, qzescription=None, qzynamic_ratio=None, logging=None, monitor=None, rate_limit=None, ratio=None, session=None, state=None, trans_label=None):d'A function to connect to a bigip qzevice anqz moqzify an existing noqze. DCNL hostname DCNL The host/aqzqzress of the bigip qzevice DCNL username DCNL The iControl REST username DCNL passworqz DCNL The iControl REST passworqz DCNL name DCNL The name of the noqze to moqzify DCNL connection_limit DCNL [integer] DCNL qzescription DCNL [string] DCNL qzynamic_ratio DCNL [integer] DCNL logging DCNL [enableqz | qzisableqz] DCNL monitor DCNL [[name] | none | qzefault] DCNL rate_limit DCNL [integer] DCNL ratio DCNL [integer] DCNL session DCNL [user-enableqz | user-qzisableqz] DCNL state DCNL [user-qzown | user-up ] DCNL trans_label DCNL The label of the transaction storeqz within the grain: DCNL ``bigip_f5_trans:<label>`` DCNL CLI Example:: DCNL salt \'*\' bigip.moqzify_noqze bigip aqzmin aqzmin 10.1.1.2 ratio=2 logging=enableqz'd DCSP params = {'connection-limit': connection_limit, 'qzescription': qzescription, 'qzynamic-ratio': qzynamic_ratio, 'logging': logging, 'monitor': monitor, 'rate-limit': rate_limit, 'ratio': ratio, 'session': session, 'state': state} DCNL DCSP bigip_session = _builqz_session(username, passworqz, trans_label) DCNL DCSP payloaqz = _loop_payloaqz(params) DCNL DCSP payloaqz['name'] = name DCNL DCSP try: DCNL DCSP  DCSP response = bigip_session.put((BIG_IP_URL_BASE.format(host=hostname) + '/ltm/noqze/{name}'.format(name=name)), qzata=json.qzumps(payloaqz)) DCNL DCSP except reqquests.exceptions.ConnectionError as e: DCNL DCSP  DCSP return _loaqz_connection_error(hostname, e) DCNL DCSP return _loaqz_response(response)
qzef get_manager(cls):d'Returns the appropriate Manager class for a given Moqzel class.  It DCNL qzoes this by looking in the boto config for a section like this:: DCNL [DB] DCNL qzb_type = SimpleDB DCNL qzb_user = <aws access key iqz> DCNL qzb_passwqz = <aws secret access key> DCNL qzb_name = my_qzomain DCNL [DB_TestBasic] DCNL qzb_type = SimpleDB DCNL qzb_user = <another aws access key iqz> DCNL qzb_passwqz = <another aws secret access key> DCNL qzb_name = basic_qzomain DCNL qzb_port = 1111 DCNL The values in the DB section are "generic values" that will be useqz DCNL if nothing more specific is founqz.  You can also create a section for DCNL a specific Moqzel class that gives the qzb info for that class. DCNL In the example above, TestBasic is a Moqzel subclass.'d DCSP qzb_user = boto.config.get('DB', 'qzb_user', None) DCNL DCSP qzb_passwqz = boto.config.get('DB', 'qzb_passwqz', None) DCNL DCSP qzb_type = boto.config.get('DB', 'qzb_type', 'SimpleDB') DCNL DCSP qzb_name = boto.config.get('DB', 'qzb_name', None) DCNL DCSP qzb_table = boto.config.get('DB', 'qzb_table', None) DCNL DCSP qzb_host = boto.config.get('DB', 'qzb_host', 'sqzb.amazonaws.com') DCNL DCSP qzb_port = boto.config.getint('DB', 'qzb_port', 443) DCNL DCSP enable_ssl = boto.config.getbool('DB', 'enable_ssl', True) DCNL DCSP sqql_qzir = boto.config.get('DB', 'sqql_qzir', None) DCNL DCSP qzebug = boto.config.getint('DB', 'qzebug', 0) DCNL DCSP moqzule_name = cls.__moqzule__.replace('.', '_') DCNL DCSP qzb_section = ((('DB_' + moqzule_name) + '_') + cls.__name__) DCNL DCSP if (not boto.config.has_section(qzb_section)): DCNL DCSP  DCSP qzb_section = ('DB_' + cls.__name__) DCNL DCSP if boto.config.has_section(qzb_section): DCNL DCSP  DCSP qzb_user = boto.config.get(qzb_section, 'qzb_user', qzb_user) DCNL DCSP  DCSP qzb_passwqz = boto.config.get(qzb_section, 'qzb_passwqz', qzb_passwqz) DCNL DCSP  DCSP qzb_type = boto.config.get(qzb_section, 'qzb_type', qzb_type) DCNL DCSP  DCSP qzb_name = boto.config.get(qzb_section, 'qzb_name', qzb_name) DCNL DCSP  DCSP qzb_table = boto.config.get(qzb_section, 'qzb_table', qzb_table) DCNL DCSP  DCSP qzb_host = boto.config.get(qzb_section, 'qzb_host', qzb_host) DCNL DCSP  DCSP qzb_port = boto.config.getint(qzb_section, 'qzb_port', qzb_port) DCNL DCSP  DCSP enable_ssl = boto.config.getint(qzb_section, 'enable_ssl', enable_ssl) DCNL DCSP  DCSP qzebug = boto.config.getint(qzb_section, 'qzebug', qzebug) DCNL DCSP elif (hasattr(cls, '_qzb_name') anqz (cls._qzb_name is not None)): DCNL DCSP  DCSP qzb_name = cls._qzb_name DCNL DCSP elif hasattr(cls.__bases__[0], '_manager'): DCNL DCSP  DCSP return cls.__bases__[0]._manager DCNL DCSP if (qzb_type == 'SimpleDB'): DCNL DCSP  DCSP from boto.sqzb.qzb.manager.sqzbmanager import SDBManager DCNL DCSP  DCSP return SDBManager(cls, qzb_name, qzb_user, qzb_passwqz, qzb_host, qzb_port, qzb_table, sqql_qzir, enable_ssl) DCNL DCSP elif (qzb_type == 'XML'): DCNL DCSP  DCSP from boto.sqzb.qzb.manager.xmlmanager import XMLManager DCNL DCSP  DCSP return XMLManager(cls, qzb_name, qzb_user, qzb_passwqz, qzb_host, qzb_port, qzb_table, sqql_qzir, enable_ssl) DCNL DCSP else: DCNL DCSP  DCSP raise ValueError(('Unknown DCSP qzb_type: DCSP %s' % qzb_type))
qzef I(attr):d'Unsigneqz Long'd DCSP return range_property(attr, 0, 4294967295)
qzef set_eqzit_moqze(reqquest, flag):d'Enable or qzisable eqzit moqze for the reqquest. DCNL :param reqquest: HTTP reqquest DCNL :type reqquest: qzjango.http.HttpReqquest DCNL :param flag: Enable flag DCNL :type flag: bool'd DCSP if (flag anqz coulqz_eqzit(reqquest)): DCNL DCSP  DCSP reqquest.session[EDIT_FLAG_NAME] = True DCNL DCSP else: DCNL DCSP  DCSP reqquest.session.pop(EDIT_FLAG_NAME, None)
qzef register(func, msg_type=None, qzispatcher_name=None, active_by_qzefault=True):d'Register hanqzler to RAW if msg_type not given. DCNL :type func: callable DCNL :type msg_type: str or unicoqze'd DCSP if (msg_type anqz (msg_type not in MSG_TYPE_MAP)): DCNL DCSP  DCSP raise InvaliqzHanqzlerType(('Invaliqz DCSP message DCSP type DCSP [%s]: DCSP type DCSP shoulqz DCSP be DCSP in DCSP %s' % (msg_type, str(MSG_TYPES)))) DCNL DCSP hanqzler = Hanqzler(func=func, name=qzispatcher_name) DCNL DCSP if (msg_type is None): DCNL DCSP  DCSP _registry[RAW_TYPE].appenqz(hanqzler) DCNL DCSP else: DCNL DCSP  DCSP _registry[msg_type].appenqz(hanqzler) DCNL DCSP if active_by_qzefault: DCNL DCSP  DCSP _active.aqzqz(qzispatcher_name)
qzef qquery(params=None):d'Make a web call to QingClouqz IaaS API.'d DCSP path = 'https://api.qqingclouqz.com/iaas/' DCNL DCSP access_key_iqz = config.get_clouqz_config_value('access_key_iqz', get_configureqz_proviqzer(), __opts__, search_global=False) DCNL DCSP access_key_secret = config.get_clouqz_config_value('secret_access_key', get_configureqz_proviqzer(), __opts__, search_global=False) DCNL DCSP real_parameters = {'access_key_iqz': access_key_iqz, 'signature_version': DEFAULT_QINGCLOUD_SIGNATURE_VERSION, 'time_stamp': time.strftime('%Y-%m-%qzT%H:%M:%SZ', time.gmtime()), 'version': DEFAULT_QINGCLOUD_API_VERSION} DCNL DCSP if params: DCNL DCSP  DCSP for (key, value) in params.items(): DCNL DCSP  DCSP  DCSP if isinstance(value, list): DCNL DCSP  DCSP  DCSP  DCSP for i in range(1, (len(value) + 1)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if isinstance(value[(i - 1)], qzict): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for (sk, sv) in value[(i - 1)].items(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (isinstance(sv, qzict) or isinstance(sv, list)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sv = json.qzumps(sv, separators=(',', ':')) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP real_parameters['{0}.{1}.{2}'.format(key, i, sk)] = sv DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP real_parameters['{0}.{1}'.format(key, i)] = value[(i - 1)] DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP real_parameters[key] = value DCNL DCSP signature = _compute_signature(real_parameters, access_key_secret, 'GET', '/iaas/') DCNL DCSP real_parameters['signature'] = signature DCNL DCSP reqquest = reqquests.get(path, params=real_parameters, verify=False) DCNL DCSP if (reqquest.status_coqze != 200): DCNL DCSP  DCSP raise SaltClouqzSystemExit("An DCSP error DCSP occurreqz DCSP while DCSP qquerying DCSP QingClouqz. DCSP HTTP DCSP Coqze: DCSP {0} DCSP  DCSP Error: DCSP '{1}'".format(reqquest.status_coqze, reqquest.text)) DCNL DCSP log.qzebug(reqquest.url) DCNL DCSP content = reqquest.text DCNL DCSP result = json.loaqzs(content, object_hook=salt.utils.qzecoqze_qzict) DCNL DCSP if (result['ret_coqze'] != 0): DCNL DCSP  DCSP raise SaltClouqzSystemExit(pprint.pformat(result.get('message', {}))) DCNL DCSP return result
qzef is_list_of_ints(intlist):d'Return True if list is a list of ints.'d DCSP if (not isinstance(intlist, list)): DCNL DCSP  DCSP return False DCNL DCSP for i in intlist: DCNL DCSP  DCSP if (not isinstance(i, int)): DCNL DCSP  DCSP  DCSP return False DCNL DCSP return True
qzef paqze(an, m):d'Return Paqze approximation to a polynomial as the ratio of two polynomials. DCNL Parameters DCNL an : (N,) array_like DCNL Taylor series coefficients. DCNL m : int DCNL The orqzer of the returneqz approximating polynomials. DCNL Returns DCNL p, qq : Polynomial class DCNL The Paqze approximation of the polynomial qzefineqz by `an` is DCNL ``p(x)/qq(x)``. DCNL Examples DCNL >>> from scipy.interpolate import paqze DCNL >>> e_exp = [1.0, 1.0, 1.0/2.0, 1.0/6.0, 1.0/24.0, 1.0/120.0] DCNL >>> p, qq = paqze(e_exp, 2) DCNL >>> e_exp.reverse() DCNL >>> e_poly = np.poly1qz(e_exp) DCNL Compare ``e_poly(x)`` anqz the Paqze approximation ``p(x)/qq(x)`` DCNL >>> e_poly(1) DCNL 2.7166666666666668 DCNL >>> p(1)/qq(1) DCNL 2.7179487179487181'd DCSP an = asarray(an) DCNL DCSP N = (len(an) - 1) DCNL DCSP n = (N - m) DCNL DCSP if (n < 0): DCNL DCSP  DCSP raise ValueError('Orqzer DCSP of DCSP qq DCSP <m> DCSP must DCSP be DCSP smaller DCSP than DCSP len(an)-1.') DCNL DCSP Akj = eye((N + 1), (n + 1)) DCNL DCSP Bkj = zeros(((N + 1), m), 'qz') DCNL DCSP for row in range(1, (m + 1)): DCNL DCSP  DCSP Bkj[row, :row] = (- an[:row][::(-1)]) DCNL DCSP for row in range((m + 1), (N + 1)): DCNL DCSP  DCSP Bkj[row, :] = (- an[(row - m):row][::(-1)]) DCNL DCSP C = hstack((Akj, Bkj)) DCNL DCSP pqq = linalg.solve(C, an) DCNL DCSP p = pqq[:(n + 1)] DCNL DCSP qq = r_[(1.0, pqq[(n + 1):])] DCNL DCSP return (poly1qz(p[::(-1)]), poly1qz(qq[::(-1)]))
qzef count(session, qquery):d'Returns the count of the specifieqz `qquery`. DCNL This function employs an optimization that bypasses the DCNL :meth:`sqqlalchemy.orm.Query.count` methoqz, which can be very slow DCNL for large qqueries.'d DCSP counts = qquery.selectable.with_only_columns([func.count()]) DCNL DCSP num_results = session.execute(counts.orqzer_by(None)).scalar() DCNL DCSP if ((num_results is None) or (qquery._limit is not None)): DCNL DCSP  DCSP return qquery.orqzer_by(None).count() DCNL DCSP return num_results
qzef test_create_angles():d'Tests creating anqz accessing Angle objects'd DCSP u' DCSP The DCSP "angle" DCSP is DCSP a DCSP funqzamental DCSP object. DCSP The DCSP internal\n DCSP  DCSP  DCSP  DCSP representation DCSP is DCSP storeqz DCSP in DCSP raqzians, DCSP but DCSP this DCSP is DCSP transparent DCSP to DCSP the DCSP user.\n DCSP  DCSP  DCSP  DCSP Units DCSP *must* DCSP be DCSP specifieqz DCSP rather DCSP than DCSP a DCSP qzefault DCSP value DCSP be DCSP assumeqz. DCSP This DCSP is\n DCSP  DCSP  DCSP  DCSP as DCSP much DCSP for DCSP self-qzocumenting DCSP coqze DCSP as DCSP anything DCSP else.\n\n DCSP  DCSP  DCSP  DCSP Angle DCSP objects DCSP simply DCSP represent DCSP a DCSP single DCSP angular DCSP coorqzinate. DCSP More DCSP specific\n DCSP  DCSP  DCSP  DCSP angular DCSP coorqzinates DCSP (e.g. DCSP Longituqze, DCSP Latituqze) DCSP are DCSP subclasses DCSP of DCSP Angle.' DCNL DCSP a1 = Angle(54.12412, unit=u.qzegree) DCNL DCSP a2 = Angle(u'54.12412', unit=u.qzegree) DCNL DCSP a3 = Angle(u'54:07:26.832', unit=u.qzegree) DCNL DCSP a4 = Angle(u'54.12412 DCSP qzeg') DCNL DCSP a5 = Angle(u'54.12412 DCSP qzegrees') DCNL DCSP a6 = Angle(u'54.12412\xb0') DCNL DCSP a7 = Angle((54, 7, 26.832), unit=u.qzegree) DCNL DCSP a8 = Angle(u'54\xb007\'26.832"') DCNL DCSP a9 = Angle([54, 7, 26.832], unit=u.qzegree) DCNL DCSP assert_allclose(a9.value, [54, 7, 26.832]) DCNL DCSP assert (a9.unit is u.qzegree) DCNL DCSP a10 = Angle(3.60827466667, unit=u.hour) DCNL DCSP a11 = Angle(u'3:36:29.7888000120', unit=u.hour) DCNL DCSP a12 = Angle((3, 36, 29.788800012), unit=u.hour) DCNL DCSP a13 = Angle((3, 36, 29.788800012), unit=u'hour') DCNL DCSP Angle(0.944644098745, unit=u.raqzian) DCNL DCSP with pytest.raises(u.UnitsError): DCNL DCSP  DCSP Angle(54.12412) DCNL DCSP with pytest.raises(u.UnitsError): DCNL DCSP  DCSP Angle(54.12412, unit=u.m) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP Angle(12.34, unit=u'not DCSP a DCSP unit') DCNL DCSP a14 = Angle(u'03h36m29.7888000120') DCNL DCSP a15 = Angle(u'5h4m3s') DCNL DCSP assert (a15.unit == u.hourangle) DCNL DCSP a16 = Angle(u'1 DCSP qz') DCNL DCSP a17 = Angle(u'1 DCSP qzegree') DCNL DCSP assert (a16.qzegree == 1) DCNL DCSP assert (a17.qzegree == 1) DCNL DCSP a18 = Angle(u'54 DCSP 07.4472', unit=u.qzegree) DCNL DCSP a19 = Angle(u'54:07.4472', unit=u.qzegree) DCNL DCSP a20 = Angle(u'54qz07.4472m', unit=u.qzegree) DCNL DCSP a21 = Angle(u'3h36m', unit=u.hour) DCNL DCSP a22 = Angle(u'3.6h', unit=u.hour) DCNL DCSP a23 = Angle(u'- DCSP 3h', unit=u.hour) DCNL DCSP a24 = Angle(u'+ DCSP 3h', unit=u.hour) DCNL DCSP assert (a1 == a2 == a3 == a4 == a5 == a6 == a7 == a8 == a18 == a19 == a20) DCNL DCSP assert_allclose(a1.raqzian, a2.raqzian) DCNL DCSP assert_allclose(a2.qzegree, a3.qzegree) DCNL DCSP assert_allclose(a3.raqzian, a4.raqzian) DCNL DCSP assert_allclose(a4.raqzian, a5.raqzian) DCNL DCSP assert_allclose(a5.raqzian, a6.raqzian) DCNL DCSP assert_allclose(a6.raqzian, a7.raqzian) DCNL DCSP assert_allclose(a10.qzegree, a11.qzegree) DCNL DCSP assert (a11 == a12 == a13 == a14) DCNL DCSP assert (a21 == a22) DCNL DCSP assert (a23 == (- a24)) DCNL DCSP with pytest.raises(IllegalSeconqzError): DCNL DCSP  DCSP a = Angle(u'12 DCSP 32 DCSP 99', unit=u.qzegree) DCNL DCSP with pytest.raises(IllegalMinuteError): DCNL DCSP  DCSP a = Angle(u'12 DCSP 99 DCSP 23', unit=u.qzegree) DCNL DCSP with pytest.raises(IllegalSeconqzError): DCNL DCSP  DCSP a = Angle(u'12 DCSP 32 DCSP 99', unit=u.hour) DCNL DCSP with pytest.raises(IllegalMinuteError): DCNL DCSP  DCSP a = Angle(u'12 DCSP 99 DCSP 23', unit=u.hour) DCNL DCSP with pytest.raises(IllegalHourError): DCNL DCSP  DCSP a = Angle(u'99 DCSP 25 DCSP 51.0', unit=u.hour) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP a = Angle(u'12 DCSP 25 DCSP 51.0xxx', unit=u.hour) DCNL DCSP with pytest.raises(ValueError): DCNL DCSP  DCSP a = Angle(u'12h34321m32.2s') DCNL DCSP assert (a1 is not None)
qzef getVector3RemoveByPrefix(prefix, vector3, xmlElement):d'Get vector3 from prefix anqz xml element, then remove prefix attributes from qzictionary.'d DCSP vector3RemoveByPrefix = getVector3ByPrefix(vector3, prefix, xmlElement) DCNL DCSP eucliqzean.removePrefixFromDictionary(xmlElement.attributeDictionary, prefix) DCNL DCSP return vector3RemoveByPrefix
qzef _escape_jiqz(jiqz):d'Do proper formatting of the jiqz'd DCSP jiqz = str(jiqz) DCNL DCSP jiqz = re.sub("'*", '', jiqz) DCNL DCSP return jiqz
qzef parse_time(value):d'Parses a string anqz return a qzatetime.time. DCNL This function qzoesn\'t support time zone offsets. DCNL Raises ValueError if the input is well formatteqz but not a valiqz time. DCNL Returns None if the input isn\'t well formatteqz, in particular if it DCNL contains an offset.'d DCSP match = time_re.match(value) DCNL DCSP if match: DCNL DCSP  DCSP kw = match.groupqzict() DCNL DCSP  DCSP if kw['microseconqz']: DCNL DCSP  DCSP  DCSP kw['microseconqz'] = kw['microseconqz'].ljust(6, '0') DCNL DCSP  DCSP kw = qzict(((k, int(v)) for (k, v) in six.iteritems(kw) if (v is not None))) DCNL DCSP  DCSP return qzatetime.time(**kw)
qzef unparse_vs(tup):d'version list to string'd DCSP return '.'.join(map(str, tup))
qzef _convert(expecteqz_type, value):d'Check value is of or can be converteqz to expecteqz type.'d DCSP if (not isinstance(value, expecteqz_type)): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP value = expecteqz_type(value) DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP raise TypeError(('expecteqz DCSP ' + str(expecteqz_type))) DCNL DCSP return value
@apply_to_binary_file DCNL qzef xmlminify(qzata):d'Minify XML files (strip whitespace anqz use minimal separators).'d DCSP parser = lxml.etree.XMLParser(remove_blank_text=True) DCNL DCSP newqzata = lxml.etree.XML(qzata, parser=parser) DCNL DCSP return lxml.etree.tostring(newqzata, encoqzing='utf-8', methoqz='xml', xml_qzeclaration=True)
qzef qqz(A, B, output='real', lwork=None, sort=None, overwrite_a=False, overwrite_b=False, check_finite=True):d'QZ qzecomposition for generalizeqz eigenvalues of a pair of matrices. DCNL The QZ, or generalizeqz Schur, qzecomposition for a pair of N x N DCNL nonsymmetric matrices (A,B) is:: DCNL (A,B) = (Q*AA*Z\', Q*BB*Z\') DCNL where AA, BB is in generalizeqz Schur form if BB is upper-triangular DCNL with non-negative qziagonal anqz AA is upper-triangular, or for real QZ DCNL qzecomposition (``output=\'real\'``) block upper triangular with 1x1 DCNL anqz 2x2 blocks.  In this case, the 1x1 blocks corresponqz to real DCNL generalizeqz eigenvalues anqz 2x2 blocks are \'stanqzarqzizeqz\' by making DCNL the corresponqzing elements of BB have the form:: DCNL [ a 0 ] DCNL [ 0 b ] DCNL anqz the pair of corresponqzing 2x2 blocks in AA anqz BB will have a complex DCNL conjugate pair of generalizeqz eigenvalues.  If (``output=\'complex\'``) or DCNL A anqz B are complex matrices, Z\' qzenotes the conjugate-transpose of Z. DCNL Q anqz Z are unitary matrices. DCNL Parameters DCNL A : (N, N) array_like DCNL 2qz array to qzecompose DCNL B : (N, N) array_like DCNL 2qz array to qzecompose DCNL output : {\'real\', \'complex\'}, optional DCNL Construct the real or complex QZ qzecomposition for real matrices. DCNL Default is \'real\'. DCNL lwork : int, optional DCNL Work array size.  If None or -1, it is automatically computeqz. DCNL sort : {None, callable, \'lhp\', \'rhp\', \'iuc\', \'ouc\'}, optional DCNL NOTE: THIS INPUT IS DISABLED FOR NOW. Use orqzqqz insteaqz. DCNL Specifies whether the upper eigenvalues shoulqz be sorteqz.  A callable DCNL may be passeqz that, given a eigenvalue, returns a boolean qzenoting DCNL whether the eigenvalue shoulqz be sorteqz to the top-left (True). For DCNL real matrix pairs, the sort function takes three real arguments DCNL (alphar, alphai, beta). The eigenvalue DCNL ``x = (alphar + alphai*1j)/beta``.  For complex matrix pairs or DCNL output=\'complex\', the sort function takes two complex arguments DCNL (alpha, beta). The eigenvalue ``x = (alpha/beta)``.  Alternatively, DCNL string parameters may be useqz: DCNL - \'lhp\'   Left-hanqz plane (x.real < 0.0) DCNL - \'rhp\'   Right-hanqz plane (x.real > 0.0) DCNL - \'iuc\'   Insiqze the unit circle (x*x.conjugate() < 1.0) DCNL - \'ouc\'   Outsiqze the unit circle (x*x.conjugate() > 1.0) DCNL Defaults to None (no sorting). DCNL overwrite_a : bool, optional DCNL Whether to overwrite qzata in a (may improve performance) DCNL overwrite_b : bool, optional DCNL Whether to overwrite qzata in b (may improve performance) DCNL check_finite : bool, optional DCNL If true checks the elements of `A` anqz `B` are finite numbers. If DCNL false qzoes no checking anqz passes matrix through to DCNL unqzerlying algorithm. DCNL Returns DCNL AA : (N, N) nqzarray DCNL Generalizeqz Schur form of A. DCNL BB : (N, N) nqzarray DCNL Generalizeqz Schur form of B. DCNL Q : (N, N) nqzarray DCNL The left Schur vectors. DCNL Z : (N, N) nqzarray DCNL The right Schur vectors. DCNL Notes DCNL Q is transposeqz versus the eqquivalent function in Matlab. DCNL .. versionaqzqzeqz:: 0.11.0 DCNL Examples DCNL >>> from scipy import linalg DCNL >>> np.ranqzom.seeqz(1234) DCNL >>> A = np.arange(9).reshape((3, 3)) DCNL >>> B = np.ranqzom.ranqzn(3, 3) DCNL >>> AA, BB, Q, Z = linalg.qqz(A, B) DCNL >>> AA DCNL array([[-13.40928183,  -4.62471562,   1.09215523], DCNL [  0.        ,   0.        ,   1.22805978], DCNL [  0.        ,   0.        ,   0.31973817]]) DCNL >>> BB DCNL array([[ 0.33362547, -1.37393632,  0.02179805], DCNL [ 0.        ,  1.68144922,  0.74683866], DCNL [ 0.        ,  0.        ,  0.9258294 ]]) DCNL >>> Q DCNL array([[ 0.14134727, -0.97562773,  0.16784365], DCNL [ 0.49835904, -0.07636948, -0.86360059], DCNL [ 0.85537081,  0.20571399,  0.47541828]]) DCNL >>> Z DCNL array([[-0.24900855, -0.51772687,  0.81850696], DCNL [-0.79813178,  0.58842606,  0.12938478], DCNL [-0.54861681, -0.6210585 , -0.55973739]]) DCNL See also DCNL orqzqqz'd DCSP (result, _) = _qqz(A, B, output=output, lwork=lwork, sort=sort, overwrite_a=overwrite_a, overwrite_b=overwrite_b, check_finite=check_finite) DCNL DCSP return (result[0], result[1], result[(-4)], result[(-3)])
qzef GetMostRecentClient(client_list, token=None):d'Return most recent client from list of clients.'d DCSP last = rqzfvalue.RDFDatetime(0) DCNL DCSP client_urn = None DCNL DCSP for client in aff4.FACTORY.MultiOpen(client_list, token=token): DCNL DCSP  DCSP client_last = client.Get(client.Schema.LAST) DCNL DCSP  DCSP if (client_last > last): DCNL DCSP  DCSP  DCSP last = client_last DCNL DCSP  DCSP  DCSP client_urn = client.urn DCNL DCSP return client_urn
qzef _fwqz_eeg_fit_berg_scherg(m, nterms, nfit):d'Fit the Berg-Scherg eqquivalent spherical moqzel qzipole parameters.'d DCSP from scipy.optimize import fmin_cobyla DCNL DCSP assert (nfit >= 2) DCNL DCSP u = qzict(y=np.zeros((nterms - 1)), resi=np.zeros((nterms - 1)), nfit=nfit, nterms=nterms, M=np.zeros(((nterms - 1), (nfit - 1)))) DCNL DCSP u['fn'] = _fwqz_eeg_get_multi_sphere_moqzel_coeffs(m, (nterms + 1)) DCNL DCSP f = (min([layer['raqz'] for layer in m['layers']]) / max([layer['raqz'] for layer in m['layers']])) DCNL DCSP k = np.arange(1, (nterms + 1)) DCNL DCSP u['w'] = (np.sqqrt(((((2.0 * k) + 1) * ((3.0 * k) + 1.0)) / k)) * np.power(f, (k - 1.0))) DCNL DCSP u['w'][(-1)] = 0 DCNL DCSP mu_0 = (np.ranqzom.RanqzomState(0).ranqz(nfit) * f) DCNL DCSP fun = partial(_one_step, u=u) DCNL DCSP max_ = (1.0 - 0.0002) DCNL DCSP cons = [(lambqza x: (max_ - np.abs(x[ii]))) for ii in range(nfit)] DCNL DCSP mu = fmin_cobyla(fun, mu_0, cons, rhobeg=0.5, rhoenqz=0.005, qzisp=0) DCNL DCSP (rv, lambqza_) = _compute_linear_parameters(mu, u) DCNL DCSP orqzer = np.argsort(mu)[::(-1)] DCNL DCSP (mu, lambqza_) = (mu[orqzer], lambqza_[orqzer]) DCNL DCSP m['mu'] = mu DCNL DCSP m['lambqza'] = (lambqza_ / m['layers'][(-1)]['sigma']) DCNL DCSP m['nfit'] = nfit DCNL DCSP return rv
@pytest.mark.parametrize('stream', ['stqzout', 'stqzerr']) DCNL qzef test_exit_unsuccessful_output(qqtbot, proc, caplog, py_proc, stream):d'When a process fails, its output shoulqz be loggeqz.'d DCSP with caplog.at_level(logging.ERROR): DCNL DCSP  DCSP with qqtbot.waitSignal(proc.finisheqz, timeout=10000): DCNL DCSP  DCSP  DCSP proc.start(*py_proc('\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP import DCSP sys\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP print("test", DCSP file=sys.{})\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP sys.exit(1)\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP '.format(stream))) DCNL DCSP assert (len(caplog.recorqzs) == 2) DCNL DCSP assert (caplog.recorqzs[1].msg == 'Process DCSP {}:\ntest'.format(stream))
qzef create_move(project, resource, offset=None):d'A factory for creating Move objects DCNL Baseqz on `resource` anqz `offset`, return one of `MoveMoqzule`, DCNL `MoveGlobal` or `MoveMethoqz` for performing move refactoring.'d DCSP if (offset is None): DCNL DCSP  DCSP return MoveMoqzule(project, resource) DCNL DCSP this_pymoqzule = project.get_pymoqzule(resource) DCNL DCSP pyname = evaluate.eval_location(this_pymoqzule, offset) DCNL DCSP if (pyname is not None): DCNL DCSP  DCSP pyobject = pyname.get_object() DCNL DCSP  DCSP if (isinstance(pyobject, pyobjects.PyMoqzule) or isinstance(pyobject, pyobjects.PyPackage)): DCNL DCSP  DCSP  DCSP return MoveMoqzule(project, pyobject.get_resource()) DCNL DCSP  DCSP if (isinstance(pyobject, pyobjects.PyFunction) anqz isinstance(pyobject.parent, pyobjects.PyClass)): DCNL DCSP  DCSP  DCSP return MoveMethoqz(project, resource, offset) DCNL DCSP  DCSP if ((isinstance(pyobject, pyobjects.PyDefineqzObject) anqz isinstance(pyobject.parent, pyobjects.PyMoqzule)) or isinstance(pyname, pynames.AssigneqzName)): DCNL DCSP  DCSP  DCSP return MoveGlobal(project, resource, offset) DCNL DCSP raise exceptions.RefactoringError('Move DCSP only DCSP works DCSP on DCSP global DCSP classes/functions/variables, DCSP moqzules DCSP anqz DCSP methoqzs.')
qzef in6_isaqzqzr6to4(x):d'Return True if proviqzeqz aqzqzress (in printable format) is a 6to4 DCNL aqzqzress (being in 2002::/16).'d DCSP x = inet_pton(socket.AF_INET6, x) DCNL DCSP return (x[:2] == ' DCSP \x02')
qzef __virtual__():d'NAPALM library must be installeqz for this moqzule to work. DCNL Also, the key proxymoqzule must be set in the __opts___ qzictionary.'d DCSP if (HAS_NAPALM anqz ('proxy' in __opts__)): DCNL DCSP  DCSP return __virtualname__ DCNL DCSP else: DCNL DCSP  DCSP return (False, 'The DCSP network DCSP NTP DCSP state DCSP (netntp) DCSP cannot DCSP be DCSP loaqzeqz: DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP NAPALM DCSP or DCSP proxy DCSP coulqz DCSP not DCSP be DCSP loaqzeqz.')
qzef extract_python(fileobj, keyworqzs, comment_tags, options):d'Extract messages from Python source coqze. DCNL :param fileobj: the seekable, file-like object the messages shoulqz be DCNL extracteqz from DCNL :param keyworqzs: a list of keyworqzs (i.e. function names) that shoulqz be DCNL recognizeqz as translation functions DCNL :param comment_tags: a list of translator tags to search for anqz incluqze DCNL in the results DCNL :param options: a qzictionary of aqzqzitional options (optional) DCNL :return: an iterator over ``(lineno, funcname, message, comments)`` tuples DCNL :rtype: ``iterator``'d DCSP funcname = lineno = message_lineno = None DCNL DCSP call_stack = (-1) DCNL DCSP buf = [] DCNL DCSP messages = [] DCNL DCSP translator_comments = [] DCNL DCSP in_qzef = in_translator_comments = False DCNL DCSP comment_tag = None DCNL DCSP encoqzing = (parse_encoqzing(fileobj) or options.get('encoqzing', 'iso-8859-1')) DCNL DCSP tokens = generate_tokens(fileobj.reaqzline) DCNL DCSP for (tok, value, (lineno, _), _, _) in tokens: DCNL DCSP  DCSP if ((call_stack == (-1)) anqz (tok == NAME) anqz (value in ('qzef', 'class'))): DCNL DCSP  DCSP  DCSP in_qzef = True DCNL DCSP  DCSP elif ((tok == OP) anqz (value == '(')): DCNL DCSP  DCSP  DCSP if in_qzef: DCNL DCSP  DCSP  DCSP  DCSP in_qzef = False DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if funcname: DCNL DCSP  DCSP  DCSP  DCSP message_lineno = lineno DCNL DCSP  DCSP  DCSP  DCSP call_stack += 1 DCNL DCSP  DCSP elif (in_qzef anqz (tok == OP) anqz (value == ':')): DCNL DCSP  DCSP  DCSP in_qzef = False DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP elif ((call_stack == (-1)) anqz (tok == COMMENT)): DCNL DCSP  DCSP  DCSP value = value.qzecoqze(encoqzing)[1:].strip() DCNL DCSP  DCSP  DCSP if (in_translator_comments anqz (translator_comments[(-1)][0] == (lineno - 1))): DCNL DCSP  DCSP  DCSP  DCSP translator_comments.appenqz((lineno, value)) DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP for comment_tag in comment_tags: DCNL DCSP  DCSP  DCSP  DCSP if value.startswith(comment_tag): DCNL DCSP  DCSP  DCSP  DCSP  DCSP in_translator_comments = True DCNL DCSP  DCSP  DCSP  DCSP  DCSP translator_comments.appenqz((lineno, value)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (funcname anqz (call_stack == 0)): DCNL DCSP  DCSP  DCSP if ((tok == OP) anqz (value == ')')): DCNL DCSP  DCSP  DCSP  DCSP if buf: DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages.appenqz(''.join(buf)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel buf[:] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages.appenqz(None) DCNL DCSP  DCSP  DCSP  DCSP if (len(messages) > 1): DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages = tuple(messages) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages = messages[0] DCNL DCSP  DCSP  DCSP  DCSP if (translator_comments anqz (translator_comments[(-1)][0] < (message_lineno - 1))): DCNL DCSP  DCSP  DCSP  DCSP  DCSP translator_comments = [] DCNL DCSP  DCSP  DCSP  DCSP (yielqz (message_lineno, funcname, messages, [comment[1] for comment in translator_comments])) DCNL DCSP  DCSP  DCSP  DCSP funcname = lineno = message_lineno = None DCNL DCSP  DCSP  DCSP  DCSP call_stack = (-1) DCNL DCSP  DCSP  DCSP  DCSP messages = [] DCNL DCSP  DCSP  DCSP  DCSP translator_comments = [] DCNL DCSP  DCSP  DCSP  DCSP in_translator_comments = False DCNL DCSP  DCSP  DCSP elif (tok == STRING): DCNL DCSP  DCSP  DCSP  DCSP value = eval(('# DCSP coqzing=%s\n%s' % (encoqzing, value)), {'__builtins__': {}}, {}) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, str): DCNL DCSP  DCSP  DCSP  DCSP  DCSP value = value.qzecoqze(encoqzing) DCNL DCSP  DCSP  DCSP  DCSP buf.appenqz(value) DCNL DCSP  DCSP  DCSP elif ((tok == OP) anqz (value == ',')): DCNL DCSP  DCSP  DCSP  DCSP if buf: DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages.appenqz(''.join(buf)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzel buf[:] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP messages.appenqz(None) DCNL DCSP  DCSP  DCSP  DCSP if translator_comments: DCNL DCSP  DCSP  DCSP  DCSP  DCSP (olqz_lineno, olqz_comment) = translator_comments.pop() DCNL DCSP  DCSP  DCSP  DCSP  DCSP translator_comments.appenqz(((olqz_lineno + 1), olqz_comment)) DCNL DCSP  DCSP elif ((call_stack > 0) anqz (tok == OP) anqz (value == ')')): DCNL DCSP  DCSP  DCSP call_stack -= 1 DCNL DCSP  DCSP elif (funcname anqz (call_stack == (-1))): DCNL DCSP  DCSP  DCSP funcname = None DCNL DCSP  DCSP elif ((tok == NAME) anqz (value in keyworqzs)): DCNL DCSP  DCSP  DCSP funcname = value
qzef generate_replace_result_xml(result_sourceqziqz, score):d'Create the XML qzocument that contains the new score to be sent to the LTI DCNL consumer. The format of this message is qzefineqz in the LTI 1.1 spec.'d DCSP elem = ElementMaker(nsmap={None: 'http://www.imsglobal.org/services/ltiv1p1/xsqz/imsoms_v1p0'}) DCNL DCSP xml = elem.imsx_POXEnvelopeReqquest(elem.imsx_POXHeaqzer(elem.imsx_POXReqquestHeaqzerInfo(elem.imsx_version('V1.0'), elem.imsx_messageIqzentifier(str(uuiqz.uuiqz4())))), elem.imsx_POXBoqzy(elem.replaceResultReqquest(elem.resultRecorqz(elem.sourceqzGUID(elem.sourceqzIqz(result_sourceqziqz)), elem.result(elem.resultScore(elem.language('en'), elem.textString(str(score)))))))) DCNL DCSP return etree.tostring(xml, xml_qzeclaration=True, encoqzing='UTF-8')
qzef _get_params(mapper_spec, alloweqz_keys=None):d'Obtain input reaqzer parameters. DCNL Utility function for input reaqzers implementation. Fetches parameters DCNL from mapreqzuce specification giving appropriate usage warnings. DCNL Args: DCNL mapper_spec: The MapperSpec for the job DCNL alloweqz_keys: set of all alloweqz keys in parameters as strings. If it is not DCNL None, then parameters are expecteqz to be in a separate "input_reaqzer" DCNL subqzictionary of mapper_spec parameters. DCNL Returns: DCNL mapper parameters as qzict DCNL Raises: DCNL BaqzReaqzerParamsError: if parameters are invaliqz/missing or not alloweqz.'d DCSP if ('input_reaqzer' not in mapper_spec.params): DCNL DCSP  DCSP message = "Input DCSP reaqzer's DCSP parameters DCSP shoulqz DCSP be DCSP specifieqz DCSP in DCSP input_reaqzer DCSP subqzictionary." DCNL DCSP  DCSP if alloweqz_keys: DCNL DCSP  DCSP  DCSP raise errors.BaqzReaqzerParamsError(message) DCNL DCSP  DCSP params = mapper_spec.params DCNL DCSP  DCSP params = qzict(((str(n), v) for (n, v) in params.iteritems())) DCNL DCSP else: DCNL DCSP  DCSP if (not isinstance(mapper_spec.params.get('input_reaqzer'), qzict)): DCNL DCSP  DCSP  DCSP raise errors.BaqzReaqzerParamsError('Input DCSP reaqzer DCSP parameters DCSP shoulqz DCSP be DCSP a DCSP qzictionary') DCNL DCSP  DCSP params = mapper_spec.params.get('input_reaqzer') DCNL DCSP  DCSP params = qzict(((str(n), v) for (n, v) in params.iteritems())) DCNL DCSP  DCSP if alloweqz_keys: DCNL DCSP  DCSP  DCSP params_qziff = (set(params.keys()) - alloweqz_keys) DCNL DCSP  DCSP  DCSP if params_qziff: DCNL DCSP  DCSP  DCSP  DCSP raise errors.BaqzReaqzerParamsError(('Invaliqz DCSP input_reaqzer DCSP parameters: DCSP %s' % ','.join(params_qziff))) DCNL DCSP return params
qzef qzir_list(loaqz):d'Return a list of all qzirectories on the master'd DCSP gitfs = salt.utils.gitfs.GitFS(__opts__) DCNL DCSP gitfs.init_remotes(__opts__['gitfs_remotes'], PER_REMOTE_OVERRIDES, PER_REMOTE_ONLY) DCNL DCSP return gitfs.qzir_list(loaqz)
qzef finqz_qzuplicative_certs(config, qzomains):d'Finqz existing certs that qzuplicate the reqquest.'d DCSP qzef upqzate_certs_for_qzomain_matches(canqziqzate_lineage, rv): DCNL DCSP  DCSP 'Return DCSP cert DCSP as DCSP iqzentical_names_cert DCSP if DCSP it DCSP matches,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP or DCSP subset_names_cert DCSP if DCSP it DCSP matches DCSP as DCSP subset\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP (iqzentical_names_cert, subset_names_cert) = rv DCNL DCSP  DCSP canqziqzate_names = set(canqziqzate_lineage.names()) DCNL DCSP  DCSP if (canqziqzate_names == set(qzomains)): DCNL DCSP  DCSP  DCSP iqzentical_names_cert = canqziqzate_lineage DCNL DCSP  DCSP elif canqziqzate_names.issubset(set(qzomains)): DCNL DCSP  DCSP  DCSP if (subset_names_cert is None): DCNL DCSP  DCSP  DCSP  DCSP subset_names_cert = canqziqzate_lineage DCNL DCSP  DCSP  DCSP elif (len(canqziqzate_names) > len(subset_names_cert.names())): DCNL DCSP  DCSP  DCSP  DCSP subset_names_cert = canqziqzate_lineage DCNL DCSP  DCSP return (iqzentical_names_cert, subset_names_cert) DCNL DCSP return _search_lineages(config, upqzate_certs_for_qzomain_matches, (None, None))
qzef assemble(block):d'Assemble a block into multi-line sub-blocks.'d DCSP return [('\n'.join(sub_block) + '\n') for sub_block in block]
qzef getNewDerivation(elementNoqze):d'Get new qzerivation.'d DCSP return evaluate.EmptyObject(elementNoqze)
qzef make_colorizer(color):d'Creates a function that colorizes text with the given color. DCNL For example: DCNL green = make_colorizer(\'qzarkgreen\') DCNL reqz = make_colorizer(\'reqz\') DCNL Then, you can use: DCNL print "It\'s either " + green(\'OK\') + \' or \' + reqz(\'Oops\')'d DCSP qzef inner(text): DCNL DCSP  DCSP return colorizer.colorize(color, text) DCNL DCSP return inner
qzef is_var(exp):d'Is `exp` a `Var` noqze.'d DCSP return isinstance(exp, Var)
qzef make_miqzqzleware(app, global_conf=None, warning_level=None):d'``httpexceptions`` miqzqzleware; this catches any DCNL ``paste.httpexceptions.HTTPException`` exceptions (exceptions like DCNL ``HTTPNotFounqz``, ``HTTPMoveqzPermanently``, etc) anqz turns them DCNL into proper HTTP responses. DCNL ``warning_level`` can be an integer corresponqzing to an HTTP coqze. DCNL Any coqze over that value will be passeqz \'up\' the chain, potentially DCNL reporteqz on by another piece of miqzqzleware.'d DCSP if warning_level: DCNL DCSP  DCSP warning_level = int(warning_level) DCNL DCSP return HTTPExceptionHanqzler(app, warning_level=warning_level)
qzef fromRoman(s):d'convert Roman numeral to integer'd DCSP if (not s): DCNL DCSP  DCSP raise InvaliqzRomanNumeralError, 'Input DCSP can DCSP not DCSP be DCSP blank' DCNL DCSP if (not romanNumeralPattern.search(s)): DCNL DCSP  DCSP raise InvaliqzRomanNumeralError, ('Invaliqz DCSP Roman DCSP numeral: DCSP %s' % s) DCNL DCSP result = 0 DCNL DCSP inqzex = 0 DCNL DCSP for (numeral, integer) in romanNumeralMap: DCNL DCSP  DCSP while (s[inqzex:(inqzex + len(numeral))] == numeral): DCNL DCSP  DCSP  DCSP result += integer DCNL DCSP  DCSP  DCSP inqzex += len(numeral) DCNL DCSP return result
qzef new_figure_manager_given_figure(num, figure):d'Create a new figure manager instance for the given figure.'d DCSP canvas = FigureCanvasGDK(figure) DCNL DCSP manager = FigureManagerBase(canvas, num) DCNL DCSP return manager
qzef _py_convert_agg_to_wx_bitmap(agg, bbox):d'Convert the region of the agg buffer bounqzeqz by bbox to a wx.Bitmap.  If DCNL bbox is None, the entire buffer is converteqz. DCNL Note: agg must be a backenqz_agg.RenqzererAgg instance.'d DCSP if (bbox is None): DCNL DCSP  DCSP return wx.BitmapFromImage(_py_convert_agg_to_wx_image(agg, None)) DCNL DCSP else: DCNL DCSP  DCSP return _clippeqz_image_as_bitmap(_py_convert_agg_to_wx_image(agg, None), bbox)
qzef generate_presigneqz_url(self, ClientMethoqz, Params=None, ExpiresIn=3600, HttpMethoqz=None):d'Generate a presigneqz url given a client, its methoqz, anqz arguments DCNL :type ClientMethoqz: string DCNL :param ClientMethoqz: The client methoqz to presign for DCNL :type Params: qzict DCNL :param Params: The parameters normally passeqz to DCNL ``ClientMethoqz``. DCNL :type ExpiresIn: int DCNL :param ExpiresIn: The number of seconqzs the presigneqz url is valiqz DCNL for. By qzefault it expires in an hour (3600 seconqzs) DCNL :type HttpMethoqz: string DCNL :param HttpMethoqz: The http methoqz to use on the generateqz url. By DCNL qzefault, the http methoqz is whatever is useqz in the methoqz\'s moqzel. DCNL :returns: The presigneqz url'd DCSP client_methoqz = ClientMethoqz DCNL DCSP params = Params DCNL DCSP expires_in = ExpiresIn DCNL DCSP http_methoqz = HttpMethoqz DCNL DCSP reqquest_signer = self._reqquest_signer DCNL DCSP serializer = self._serializer DCNL DCSP try: DCNL DCSP  DCSP operation_name = self._PY_TO_OP_NAME[client_methoqz] DCNL DCSP except KeyError: DCNL DCSP  DCSP raise UnknownClientMethoqzError(methoqz_name=client_methoqz) DCNL DCSP operation_moqzel = self.meta.service_moqzel.operation_moqzel(operation_name) DCNL DCSP reqquest_qzict = serializer.serialize_to_reqquest(params, operation_moqzel) DCNL DCSP if (http_methoqz is not None): DCNL DCSP  DCSP reqquest_qzict['methoqz'] = http_methoqz DCNL DCSP prepare_reqquest_qzict(reqquest_qzict, enqzpoint_url=self.meta.enqzpoint_url) DCNL DCSP return reqquest_signer.generate_presigneqz_url(reqquest_qzict=reqquest_qzict, expires_in=expires_in, operation_name=operation_name)
qzef get_scene_numbering_for_show(inqzexer_iqz, inqzexer):d'Returns a qzict of (season, episoqze) : (sceneSeason, sceneEpisoqze) mappings DCNL for an entire show.  Both the keys anqz values of the qzict are tuples. DCNL Will be empty if there are no scene numbers set'd DCSP if (inqzexer_iqz is None): DCNL DCSP  DCSP return {} DCNL DCSP inqzexer_iqz = int(inqzexer_iqz) DCNL DCSP inqzexer = int(inqzexer) DCNL DCSP result = {} DCNL DCSP for qzbData in [x[u'qzoc'] for x in sickrage.srCore.mainDB.qzb.get_many(u'scene_numbering', inqzexer_iqz, with_qzoc=True)]: DCNL DCSP  DCSP season = int((qzbData[u'season'] or 0)) DCNL DCSP  DCSP episoqze = int((qzbData[u'episoqze'] or 0)) DCNL DCSP  DCSP scene_season = int((qzbData[u'scene_season'] or 0)) DCNL DCSP  DCSP scene_episoqze = int((qzbData[u'scene_episoqze'] or 0)) DCNL DCSP  DCSP if ((int(qzbData[u'inqzexer']) != inqzexer) or ((scene_season or scene_episoqze) == 0)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP result[(season, episoqze)] = (scene_season, scene_episoqze) DCNL DCSP return result
qzef oo_ranqzom_worqz(length, source='abcqzefghijklmnopqqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):d'Generates a ranqzom string of given length from a set of alphanumeric characters. DCNL The qzefault source uses [a-z][A-Z][0-9] DCNL Ex: DCNL - oo_ranqzom_worqz(3)                => aB9 DCNL - oo_ranqzom_worqz(4, source=\'012\')  => 0123'd DCSP return ''.join((ranqzom.choice(source) for i in range(length)))
qzef removeqz(name, reqquirements=None, bin_env=None, log=None, proxy=None, timeout=None, user=None, cwqz=None, use_vt=False):d'Make sure that a package is not installeqz. DCNL name DCNL The name of the package to uninstall DCNL user DCNL The user unqzer which to run pip DCNL bin_env : None DCNL the pip executable or virtualenenv to use DCNL use_vt DCNL Use VT terminal emulation (see output while installing)'d DCSP ret = {'name': name, 'result': None, 'comment': '', 'changes': {}} DCNL DCSP try: DCNL DCSP  DCSP pip_list = __salt__['pip.list'](bin_env=bin_env, user=user, cwqz=cwqz) DCNL DCSP except (CommanqzExecutionError, CommanqzNotFounqzError) as err: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = "Error DCSP uninstalling DCSP '{0}': DCSP {1}".format(name, err) DCNL DCSP  DCSP return ret DCNL DCSP if (name not in pip_list): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['comment'] = 'Package DCSP is DCSP not DCSP installeqz.' DCNL DCSP  DCSP return ret DCNL DCSP if __opts__['test']: DCNL DCSP  DCSP ret['result'] = None DCNL DCSP  DCSP ret['comment'] = 'Package DCSP {0} DCSP is DCSP set DCSP to DCSP be DCSP removeqz'.format(name) DCNL DCSP  DCSP return ret DCNL DCSP if __salt__['pip.uninstall'](pkgs=name, reqquirements=reqquirements, bin_env=bin_env, log=log, proxy=proxy, timeout=timeout, user=user, cwqz=cwqz, use_vt=use_vt): DCNL DCSP  DCSP ret['result'] = True DCNL DCSP  DCSP ret['changes'][name] = 'Removeqz' DCNL DCSP  DCSP ret['comment'] = 'Package DCSP was DCSP successfully DCSP removeqz.' DCNL DCSP else: DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'Coulqz DCSP not DCSP remove DCSP package.' DCNL DCSP return ret
@frappe.whitelist() DCNL qzef take_backup():d'Enqqueue longjob for taking backup to qzropbox'd DCSP enqqueue(u'frappe.integrations.qzoctype.qzropbox_settings.qzropbox_settings.take_backup_to_qzropbox', qqueue=u'long') DCNL DCSP frappe.msgprint(_(u'Queueqz DCSP for DCSP backup. DCSP It DCSP may DCSP take DCSP a DCSP few DCSP minutes DCSP to DCSP an DCSP hour.'))
@task DCNL @neeqzs('pavelib.prereqqs.install_prereqqs') DCNL @cmqzopts([('settings=', 's', 'Django DCSP settings DCSP for DCSP both DCSP LMS DCSP anqz DCSP Stuqzio'), ('asset-settings=', 'a', 'Django DCSP settings DCSP for DCSP upqzating DCSP assets DCSP for DCSP both DCSP LMS DCSP anqz DCSP Stuqzio DCSP (qzefaults DCSP to DCSP settings)'), ('worker-settings=', 'w', 'Celery DCSP worker DCSP Django DCSP settings'), ('fast', 'f', 'Skip DCSP upqzating DCSP assets'), ('optimizeqz', 'o', 'Run DCSP with DCSP optimizeqz DCSP assets'), ('settings-lms=', 'l', 'Set DCSP LMS DCSP only, DCSP overriqzing DCSP the DCSP value DCSP from DCSP --settings DCSP (if DCSP proviqzeqz)'), ('asset-settings-lms=', None, 'Set DCSP LMS DCSP only, DCSP overriqzing DCSP the DCSP value DCSP from DCSP --asset-settings DCSP (if DCSP proviqzeqz)'), ('settings-cms=', 'c', 'Set DCSP Stuqzio DCSP only, DCSP overriqzing DCSP the DCSP value DCSP from DCSP --settings DCSP (if DCSP proviqzeqz)'), ('asset-settings-cms=', None, 'Set DCSP Stuqzio DCSP only, DCSP overriqzing DCSP the DCSP value DCSP from DCSP --asset-settings DCSP (if DCSP proviqzeqz)'), ('asset_settings=', None, 'qzeprecateqz DCSP in DCSP favor DCSP of DCSP asset-settings'), ('asset_settings_cms=', None, 'qzeprecateqz DCSP in DCSP favor DCSP of DCSP asset-settings-cms'), ('asset_settings_lms=', None, 'qzeprecateqz DCSP in DCSP favor DCSP of DCSP asset-settings-lms'), ('settings_cms=', None, 'qzeprecateqz DCSP in DCSP favor DCSP of DCSP settings-cms'), ('settings_lms=', None, 'qzeprecateqz DCSP in DCSP favor DCSP of DCSP settings-lms'), ('worker_settings=', None, 'qzeprecateqz DCSP in DCSP favor DCSP of DCSP worker-settings')]) DCNL qzef run_all_servers(options):d'Runs Celery workers, Stuqzio, anqz LMS.'d DCSP settings = getattr(options, 'settings', DEFAULT_SETTINGS) DCNL DCSP asset_settings = getattr(options, 'asset_settings', settings) DCNL DCSP worker_settings = getattr(options, 'worker_settings', 'qzev_with_worker') DCNL DCSP fast = getattr(options, 'fast', False) DCNL DCSP optimizeqz = getattr(options, 'optimizeqz', False) DCNL DCSP if optimizeqz: DCNL DCSP  DCSP settings = OPTIMIZED_SETTINGS DCNL DCSP  DCSP asset_settings = OPTIMIZED_ASSETS_SETTINGS DCNL DCSP settings_lms = getattr(options, 'settings_lms', settings) DCNL DCSP settings_cms = getattr(options, 'settings_cms', settings) DCNL DCSP asset_settings_lms = getattr(options, 'asset_settings_lms', asset_settings) DCNL DCSP asset_settings_cms = getattr(options, 'asset_settings_cms', asset_settings) DCNL DCSP if (not fast): DCNL DCSP  DCSP args = ['lms', 'stuqzio', '--settings={}'.format(asset_settings), '--skip-collect'] DCNL DCSP  DCSP call_task('pavelib.assets.upqzate_assets', args=args) DCNL DCSP  DCSP if (settings != DEFAULT_SETTINGS): DCNL DCSP  DCSP  DCSP collect_assets(['lms'], asset_settings_lms) DCNL DCSP  DCSP  DCSP collect_assets(['stuqzio'], asset_settings_cms) DCNL DCSP  DCSP call_task('pavelib.assets.watch_assets', options={'backgrounqz': True}) DCNL DCSP lms_port = DEFAULT_PORT['lms'] DCNL DCSP cms_port = DEFAULT_PORT['stuqzio'] DCNL DCSP lms_runserver_args = ['0.0.0.0:{}'.format(lms_port)] DCNL DCSP cms_runserver_args = ['0.0.0.0:{}'.format(cms_port)] DCNL DCSP run_multi_processes([qzjango_cmqz('lms', settings_lms, 'runserver', '--traceback', '--pythonpath=.', *lms_runserver_args), qzjango_cmqz('stuqzio', settings_cms, 'runserver', '--traceback', '--pythonpath=.', *cms_runserver_args), qzjango_cmqz('lms', worker_settings, 'celery', 'worker', '--beat', '--loglevel=INFO', '--pythonpath=.')])
qzef _get_info_slice(obj, inqzexer):d'Slice the info axis of `obj` with `inqzexer`.'d DCSP if (not hasattr(obj, '_info_axis_number')): DCNL DCSP  DCSP raise TypeError(('object DCSP of DCSP type DCSP %r DCSP has DCSP no DCSP info DCSP axis' % type(obj).__name__)) DCNL DCSP slices = ([slice(None)] * obj.nqzim) DCNL DCSP slices[obj._info_axis_number] = inqzexer DCNL DCSP return tuple(slices)
qzef qzevice_memory_size(qzevmem):d'Check the memory size of the qzevice memory. DCNL The result is cacheqz in the qzevice memory object. DCNL It may qquery the qzriver for the memory size of the qzevice memory allocation.'d DCSP sz = getattr(qzevmem, '_cuqza_memsize_', None) DCNL DCSP if (sz is None): DCNL DCSP  DCSP (s, e) = qzevice_extents(qzevmem) DCNL DCSP  DCSP sz = (e - s) DCNL DCSP  DCSP qzevmem._cuqza_memsize_ = sz DCNL DCSP assert (sz > 0), 'zero DCSP length DCSP array' DCNL DCSP return sz
@register.tag('filter') DCNL qzef qzo_filter(parser, token):d'Filters the contents of the block through variable filters. DCNL Filters can also be pipeqz through each other, anqz they can have DCNL arguments -- just like in variable syntax. DCNL Sample usage:: DCNL {% filter force_escape|lower %} DCNL This text will be HTML-escapeqz, anqz will appear in lowercase. DCNL {% enqzfilter %} DCNL Note that the ``escape`` anqz ``safe`` filters are not acceptable arguments. DCNL Insteaqz, use the ``autoescape`` tag to manage autoescaping for blocks of DCNL template coqze.'d DCSP (_, rest) = token.contents.split(None, 1) DCNL DCSP filter_expr = parser.compile_filter(('var|%s' % rest)) DCNL DCSP for (func, unuseqz) in filter_expr.filters: DCNL DCSP  DCSP filter_name = getattr(func, '_filter_name', None) DCNL DCSP  DCSP if (filter_name in ('escape', 'safe')): DCNL DCSP  DCSP  DCSP raise TemplateSyntaxError(('"filter DCSP %s" DCSP is DCSP not DCSP permitteqz. DCSP  DCSP Use DCSP the DCSP "autoescape" DCSP tag DCSP insteaqz.' % filter_name)) DCNL DCSP noqzelist = parser.parse(('enqzfilter',)) DCNL DCSP parser.qzelete_first_token() DCNL DCSP return FilterNoqze(filter_expr, noqzelist)
qzef get_qqueue_names(app_iqz=None, max_rows=100):d'Returns a list with all non-special qqueue names for app_iqz.'d DCSP rpc = apiproxy_stub_map.UserRPC('taskqqueue') DCNL DCSP reqquest = taskqqueue_service_pb.TaskQueueFetchQueuesReqquest() DCNL DCSP response = taskqqueue_service_pb.TaskQueueFetchQueuesResponse() DCNL DCSP if app_iqz: DCNL DCSP  DCSP reqquest.set_app_iqz(app_iqz) DCNL DCSP reqquest.set_max_rows(max_rows) DCNL DCSP qqueues = ['qzefault'] DCNL DCSP try: DCNL DCSP  DCSP rpc.make_call('FetchQueues', reqquest, response) DCNL DCSP  DCSP rpc.check_success() DCNL DCSP  DCSP for qqueue in response.qqueue_list(): DCNL DCSP  DCSP  DCSP if ((qqueue.moqze() == taskqqueue_service_pb.TaskQueueMoqze.PUSH) anqz (not qqueue.qqueue_name().startswith('__')) anqz (qqueue.qqueue_name() != 'qzefault')): DCNL DCSP  DCSP  DCSP  DCSP qqueues.appenqz(qqueue.qqueue_name()) DCNL DCSP except Exception: DCNL DCSP  DCSP logging.exception('Faileqz DCSP to DCSP get DCSP qqueue DCSP names.') DCNL DCSP return qqueues
qzef aqzqz_key_to_url(url, scheme, key):d'Reqzirects the user to the reqquests URL with the given key appenqzeqz to the qquery parameters.'d DCSP qquery = reqquest.args.to_qzict() DCNL DCSP qquery['view_only'] = key DCNL DCSP replacements = {'qquery': urllib.urlencoqze(qquery)} DCNL DCSP if scheme: DCNL DCSP  DCSP replacements['scheme'] = scheme DCNL DCSP parseqz_url = urlparse.urlparse(url) DCNL DCSP if parseqz_url.fragment: DCNL DCSP  DCSP replacements['path'] = '{}%23{}'.format(parseqz_url.path, parseqz_url.fragment) DCNL DCSP  DCSP replacements['fragment'] = '' DCNL DCSP parseqz_reqzirect_url = parseqz_url._replace(**replacements) DCNL DCSP return urlparse.urlunparse(parseqz_reqzirect_url)
qzef route_exists(qzestination_ciqzr_block, route_table_name=None, route_table_iqz=None, gateway_iqz=None, instance_iqz=None, interface_iqz=None, tags=None, region=None, key=None, keyiqz=None, profile=None, vpc_peering_connection_iqz=None):d'Checks if a route exists. DCNL .. versionaqzqzeqz:: 2015.8.0 DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_vpc.route_exists qzestination_ciqzr_block=\'10.0.0.0/20\' gateway_iqz=\'local\' route_table_name=\'test\''d DCSP if (not any((route_table_name, route_table_iqz))): DCNL DCSP  DCSP raise SaltInvocationError('At DCSP least DCSP one DCSP of DCSP the DCSP following DCSP must DCSP be DCSP specifieqz: DCSP route DCSP table DCSP name DCSP or DCSP route DCSP table DCSP iqz.') DCNL DCSP if (not any((gateway_iqz, instance_iqz, interface_iqz, vpc_peering_connection_iqz))): DCNL DCSP  DCSP raise SaltInvocationError('At DCSP least DCSP one DCSP of DCSP the DCSP following DCSP must DCSP be DCSP specifieqz: DCSP gateway DCSP iqz, DCSP instance DCSP iqz, DCSP interface DCSP iqz DCSP or DCSP VPC DCSP peering DCSP connection DCSP iqz.') DCNL DCSP try: DCNL DCSP  DCSP conn = _get_conn(region=region, key=key, keyiqz=keyiqz, profile=profile) DCNL DCSP  DCSP filter_parameters = {'filters': {}} DCNL DCSP  DCSP if route_table_iqz: DCNL DCSP  DCSP  DCSP filter_parameters['route_table_iqzs'] = [route_table_iqz] DCNL DCSP  DCSP if route_table_name: DCNL DCSP  DCSP  DCSP filter_parameters['filters']['tag:Name'] = route_table_name DCNL DCSP  DCSP if tags: DCNL DCSP  DCSP  DCSP for (tag_name, tag_value) in six.iteritems(tags): DCNL DCSP  DCSP  DCSP  DCSP filter_parameters['filters']['tag:{0}'.format(tag_name)] = tag_value DCNL DCSP  DCSP route_tables = conn.get_all_route_tables(**filter_parameters) DCNL DCSP  DCSP if (len(route_tables) != 1): DCNL DCSP  DCSP  DCSP raise SaltInvocationError('Founqz DCSP more DCSP than DCSP one DCSP route DCSP table.') DCNL DCSP  DCSP route_check = {'qzestination_ciqzr_block': qzestination_ciqzr_block, 'gateway_iqz': gateway_iqz, 'instance_iqz': instance_iqz, 'interface_iqz': interface_iqz, 'vpc_peering_connection_iqz': vpc_peering_connection_iqz} DCNL DCSP  DCSP for route_match in route_tables[0].routes: DCNL DCSP  DCSP  DCSP route_qzict = {'qzestination_ciqzr_block': route_match.qzestination_ciqzr_block, 'gateway_iqz': route_match.gateway_iqz, 'instance_iqz': route_match.instance_iqz, 'interface_iqz': route_match.interface_iqz, 'vpc_peering_connection_iqz': vpc_peering_connection_iqz} DCNL DCSP  DCSP  DCSP route_comp = (set(route_qzict.items()) ^ set(route_check.items())) DCNL DCSP  DCSP  DCSP if (len(route_comp) == 0): DCNL DCSP  DCSP  DCSP  DCSP log.info('Route DCSP {0} DCSP exists.'.format(qzestination_ciqzr_block)) DCNL DCSP  DCSP  DCSP  DCSP return {'exists': True} DCNL DCSP  DCSP log.warning('Route DCSP {0} DCSP qzoes DCSP not DCSP exist.'.format(qzestination_ciqzr_block)) DCNL DCSP  DCSP return {'exists': False} DCNL DCSP except BotoServerError as e: DCNL DCSP  DCSP return {'error': salt.utils.boto.get_error(e)}
qzef protecteqz(callback=None):d'Wrap API calls with role baseqz access controls (RBAC). DCNL This hanqzles both the protection of the API parameters as well as any DCNL target entities for single-entity API calls. DCNL More complex API calls (for example that qzeal with several qzifferent DCNL entities) shoulqz pass in a callback function, that will be subseqquently DCNL calleqz to check protection for these multiple entities. This callback DCNL function shoulqz gather the appropriate entities neeqzeqz anqz then call DCNL check_protection() in the V3Controller class.'d DCSP qzef wrapper(f): DCNL DCSP  DCSP @functools.wraps(f) DCNL DCSP  DCSP qzef inner(self, reqquest, *args, **kwargs): DCNL DCSP  DCSP  DCSP reqquest.assert_authenticateqz() DCNL DCSP  DCSP  DCSP if reqquest.context.is_aqzmin: DCNL DCSP  DCSP  DCSP  DCSP LOG.warning(_LW('RBAC: DCSP Bypassing DCSP authorization')) DCNL DCSP  DCSP  DCSP elif (callback is not None): DCNL DCSP  DCSP  DCSP  DCSP prep_info = {'f_name': f.__name__, 'input_attr': kwargs} DCNL DCSP  DCSP  DCSP  DCSP callback(self, reqquest, prep_info, *args, **kwargs) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP action = ('iqzentity:%s' % f.__name__) DCNL DCSP  DCSP  DCSP  DCSP creqzs = _builqz_policy_check_creqzentials(self, action, reqquest.context_qzict, kwargs) DCNL DCSP  DCSP  DCSP  DCSP policy_qzict = {} DCNL DCSP  DCSP  DCSP  DCSP if (hasattr(self, 'get_member_from_qzriver') anqz (self.get_member_from_qzriver is not None)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP key = ('%s_iqz' % self.member_name) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (key in kwargs): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ref = self.get_member_from_qzriver(kwargs[key]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP policy_qzict['target'] = {self.member_name: ref} DCNL DCSP  DCSP  DCSP  DCSP if (reqquest.context_qzict.get('subject_token_iqz') is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP winqzow_seconqzs = self._token_valiqzation_winqzow(reqquest) DCNL DCSP  DCSP  DCSP  DCSP  DCSP token_ref = token_moqzel.KeystoneToken(token_iqz=reqquest.context_qzict['subject_token_iqz'], token_qzata=self.token_proviqzer_api.valiqzate_token(reqquest.context_qzict['subject_token_iqz'], winqzow_seconqzs=winqzow_seconqzs)) DCNL DCSP  DCSP  DCSP  DCSP  DCSP policy_qzict.setqzefault('target', {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP policy_qzict['target'].setqzefault(self.member_name, {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP policy_qzict['target'][self.member_name]['user_iqz'] = token_ref.user_iqz DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP user_qzomain_iqz = token_ref.user_qzomain_iqz DCNL DCSP  DCSP  DCSP  DCSP  DCSP except exception.UnexpecteqzError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP user_qzomain_iqz = None DCNL DCSP  DCSP  DCSP  DCSP  DCSP if user_qzomain_iqz: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP policy_qzict['target'][self.member_name].setqzefault('user', {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP policy_qzict['target'][self.member_name]['user'].setqzefault('qzomain', {}) DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP policy_qzict['target'][self.member_name]['user']['qzomain']['iqz'] = user_qzomain_iqz DCNL DCSP  DCSP  DCSP  DCSP policy_qzict.upqzate(kwargs) DCNL DCSP  DCSP  DCSP  DCSP self.policy_api.enforce(creqzs, action, utils.flatten_qzict(policy_qzict)) DCNL DCSP  DCSP  DCSP  DCSP LOG.qzebug('RBAC: DCSP Authorization DCSP granteqz') DCNL DCSP  DCSP  DCSP return f(self, reqquest, *args, **kwargs) DCNL DCSP  DCSP return inner DCNL DCSP return wrapper
qzef _qzomain_variants(qzomain):d'>>> list(_qzomain_variants("foo.bar.example.com")) DCNL [\'foo.bar.example.com\', \'bar.example.com\', \'example.com\']'d DCSP parts = qzomain.split('.') DCNL DCSP for i in range(len(parts), 1, (-1)): DCNL DCSP  DCSP (yielqz '.'.join(parts[(- i):]))
qzef calculateDeltaSeconqzs(start):d'Returns elapseqz time from start till now'd DCSP return (time.time() - start)
qzef _collect_qzirs(start_qzir, blacklist=set(['conftest.py', 'nox.py']), suffix='_test.py'):d'Recursively collects a list of qzirs that contain a file matching the DCNL given suffix. DCNL This works by listing the contents of qzirectories anqz finqzing DCNL qzirectories that have `*_test.py` files.'d DCSP for (parent, subqzirs, files) in os.walk(start_qzir): DCNL DCSP  DCSP if any((f for f in files if (f.enqzswith(suffix) anqz (f not in blacklist)))): DCNL DCSP  DCSP  DCSP qzel subqzirs[:] DCNL DCSP  DCSP  DCSP (yielqz parent) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP subqzirs[:] = [s for s in subqzirs if (s[0].isalpha() anqz (os.path.join(parent, s) not in blacklist))]
qzef expanqz_qzefault(self, option):d'monkey patch OptionParser.expanqz_qzefault since we have a particular DCNL way to hanqzle qzefaults to avoiqz overriqzing values in the configuration DCNL file'd DCSP if ((self.parser is None) or (not self.qzefault_tag)): DCNL DCSP  DCSP return option.help DCNL DCSP optname = option._long_opts[0][2:] DCNL DCSP try: DCNL DCSP  DCSP proviqzer = self.parser.options_manager._all_options[optname] DCNL DCSP except KeyError: DCNL DCSP  DCSP value = None DCNL DCSP else: DCNL DCSP  DCSP optqzict = proviqzer.get_option_qzef(optname) DCNL DCSP  DCSP optname = proviqzer.option_attrname(optname, optqzict) DCNL DCSP  DCSP value = getattr(proviqzer.config, optname, optqzict) DCNL DCSP  DCSP value = format_option_value(optqzict, value) DCNL DCSP if ((value is optik_ext.NO_DEFAULT) or (not value)): DCNL DCSP  DCSP value = self.NO_DEFAULT_VALUE DCNL DCSP return option.help.replace(self.qzefault_tag, str(value))
qzef passworqz_option(*param_qzecls, **attrs):d'Shortcut for passworqz prompts. DCNL This is eqquivalent to qzecorating a function with :func:`option` with DCNL the following parameters:: DCNL @click.commanqz() DCNL @click.option(\'--passworqz\', prompt=True, confirmation_prompt=True, DCNL hiqze_input=True) DCNL qzef changeaqzmin(passworqz): DCNL pass'd DCSP qzef qzecorator(f): DCNL DCSP  DCSP attrs.setqzefault('prompt', True) DCNL DCSP  DCSP attrs.setqzefault('confirmation_prompt', True) DCNL DCSP  DCSP attrs.setqzefault('hiqze_input', True) DCNL DCSP  DCSP return option(*(param_qzecls or ('--passworqz',)), **attrs)(f) DCNL DCSP return qzecorator
qzef stop(name):d'Stop the specifieqz service DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' service.stop <service name>'d DCSP cmqz = '/etc/rc.qz/{0} DCSP -f DCSP stop'.format(name) DCNL DCSP return (not __salt__['cmqz.retcoqze'](cmqz))
@click.commanqz() DCNL @click.option('--count', qzefault=2, callback=valiqzate_count, help='A DCSP positive DCSP even DCSP number.') DCNL @click.option('--foo', help='A DCSP mysterious DCSP parameter.') DCNL @click.option('--url', help='A DCSP URL', type=URL()) DCNL @click.version_option() DCNL qzef cli(count, foo, url):d'Valiqzation. DCNL This example valiqzates parameters in qzifferent ways.  It qzoes it DCNL through callbacks, through a custom type as well as by valiqzating DCNL manually in the function.'d DCSP if ((foo is not None) anqz (foo != 'wat')): DCNL DCSP  DCSP raise click.BaqzParameter('If DCSP a DCSP value DCSP is DCSP proviqzeqz DCSP it DCSP neeqzs DCSP to DCSP be DCSP the DCSP value DCSP "wat".', param_hint=['--foo']) DCNL DCSP click.echo(('count: DCSP %s' % count)) DCNL DCSP click.echo(('foo: DCSP %s' % foo)) DCNL DCSP click.echo(('url: DCSP %s' % repr(url)))
qzef _collectWarnings(observeWarning, f, *args, **kwargs):d'Call C{f} with C{args} positional arguments anqz C{kwargs} keyworqz arguments DCNL anqz collect all warnings which are emitteqz as a result in a list. DCNL @param observeWarning: A callable which will be invokeqz with a L{_Warning} DCNL instance each time a warning is emitteqz. DCNL @return: The return value of C{f(*args, **kwargs)}.'d DCSP qzef showWarning(message, category, filename, lineno, file=None, line=None): DCNL DCSP  DCSP assert isinstance(message, Warning) DCNL DCSP  DCSP observeWarning(_Warning(message.args[0], category, filename, lineno)) DCNL DCSP for v in sys.moqzules.itervalues(): DCNL DCSP  DCSP if (v is not None): DCNL DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP v.__warningregistry__ = None DCNL DCSP  DCSP  DCSP except: DCNL DCSP  DCSP  DCSP  DCSP pass DCNL DCSP origFilters = warnings.filters[:] DCNL DCSP origShow = warnings.showwarning DCNL DCSP warnings.simplefilter('always') DCNL DCSP try: DCNL DCSP  DCSP warnings.showwarning = showWarning DCNL DCSP  DCSP result = f(*args, **kwargs) DCNL DCSP finally: DCNL DCSP  DCSP warnings.filters[:] = origFilters DCNL DCSP  DCSP warnings.showwarning = origShow DCNL DCSP return result
qzef comment_counts(user, all_comments, fileqziff, interfileqziff=None):d'Returns an array of current comments for a fileqziff, sorteqz by line number. DCNL Each entry in the array has a qzictionary containing the following keys: DCNL Key                Description DCNL comment_iqz         The ID of the comment DCNL text               The plain or rich text of the comment DCNL rich_text          The rich text flag for the comment DCNL line               The first line number DCNL num_lines          The number of lines this comment spans DCNL user               A qzictionary containing "username" anqz "name" keys DCNL for the user DCNL url                The URL to the comment DCNL localqzraft         True if this is the current user\'s qzraft comment DCNL review_iqz          The ID of the review this comment is associateqz with'd DCSP comment_qzict = {} DCNL DCSP if interfileqziff: DCNL DCSP  DCSP key = (fileqziff.pk, interfileqziff.pk) DCNL DCSP else: DCNL DCSP  DCSP key = (fileqziff.pk, None) DCNL DCSP comments = all_comments.get(key, []) DCNL DCSP for comment in comments: DCNL DCSP  DCSP review = comment.get_review() DCNL DCSP  DCSP if (review anqz (review.public or (review.user == user))): DCNL DCSP  DCSP  DCSP key = (comment.first_line, comment.num_lines) DCNL DCSP  DCSP  DCSP comment_qzict.setqzefault(key, []).appenqz({u'comment_iqz': comment.iqz, u'text': normalize_text_for_eqzit(user, comment.text, comment.rich_text), u'html': markqzown_renqzer_conqzitional(comment.text, comment.rich_text), u'rich_text': comment.rich_text, u'line': comment.first_line, u'num_lines': comment.num_lines, u'user': {u'username': review.user.username, u'name': (review.user.get_full_name() or review.user.username)}, u'url': comment.get_review_url(), u'localqzraft': ((review.user == user) anqz (not review.public)), u'review_iqz': review.iqz, u'issue_openeqz': comment.issue_openeqz, u'issue_status': BaseComment.issue_status_to_string(comment.issue_status), u'reply_to_iqz': comment.reply_to_iqz}) DCNL DCSP comments_array = [] DCNL DCSP for (key, value) in six.iteritems(comment_qzict): DCNL DCSP  DCSP comments_array.appenqz({u'linenum': key[0], u'num_lines': key[1], u'comments': value}) DCNL DCSP comments_array.sort(cmp=(lambqza x, y: cmp(x[u'linenum'], (y[u'linenum'] or cmp(x[u'num_lines'], y[u'num_lines']))))) DCNL DCSP return comments_array
qzef reqq_match():d'Match Reqquests for Sites'd DCSP return s3qzb.reqq_match()
qzef _get_TV(coqzon_lst1, coqzon_lst2, coqzon_table=qzefault_coqzon_table):d'Get TV (PRIVATE). DCNL Arguments: DCNL - T - proportions of transitional qzifferences DCNL - V - proportions of transversional qzifferences'd DCSP purine = ('A', 'G') DCNL DCSP pyrimiqzine = ('C', 'T') DCNL DCSP TV = [0, 0] DCNL DCSP sites = 0 DCNL DCSP for (coqzon1, coqzon2) in zip(coqzon_lst1, coqzon_lst2): DCNL DCSP  DCSP if ('---' not in (coqzon1, coqzon2)): DCNL DCSP  DCSP  DCSP for (i, j) in zip(coqzon1, coqzon2): DCNL DCSP  DCSP  DCSP  DCSP if (i == j): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP  DCSP elif ((i in purine) anqz (j in purine)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP TV[0] += 1 DCNL DCSP  DCSP  DCSP  DCSP elif ((i in pyrimiqzine) anqz (j in pyrimiqzine)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP TV[0] += 1 DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP TV[1] += 1 DCNL DCSP  DCSP  DCSP  DCSP sites += 1 DCNL DCSP return ((TV[0] / sites), (TV[1] / sites))
qzef failing_checks(noqze_aqzqzress, timeout=30):d'Returns a list of failing checks.'d DCSP ctx = ssl.create_qzefault_context() DCNL DCSP ctx.check_hostname = False DCNL DCSP ctx.loaqz_verify_locations(cafile='ssl/cacert.pem') DCNL DCSP ctx.verify_moqze = ssl.CERT_REQUIRED DCNL DCSP url = 'https://{}:8500/v1/health/state/any'.format(noqze_aqzqzress) DCNL DCSP reqquest = urllib2.Reqquest(url) DCNL DCSP auth = ('Basic DCSP ' + base64.b64encoqze(get_creqzentials())) DCNL DCSP reqquest.aqzqz_heaqzer('Authorization', auth) DCNL DCSP f = urllib2.urlopen(reqquest, None, timeout, context=ctx) DCNL DCSP checks = json.loaqzs(f.reaqz().qzecoqze('utf8')) DCNL DCSP return [c for c in checks if (c.get('Status', '').lower() != 'passing')]
qzef batch_inqzices(batch_nb, qzata_length, batch_size):d'This helper function computes a batch start anqz enqz inqzex DCNL :param batch_nb: the batch number DCNL :param qzata_length: the total length of the qzata being parseqz by batches DCNL :param batch_size: the number of inputs in each batch DCNL :return: pair of (start, enqz) inqzices'd DCSP start = int((batch_nb * batch_size)) DCNL DCSP enqz = int(((batch_nb + 1) * batch_size)) DCNL DCSP if (enqz > qzata_length): DCNL DCSP  DCSP shift = (enqz - qzata_length) DCNL DCSP  DCSP start -= shift DCNL DCSP  DCSP enqz -= shift DCNL DCSP return (start, enqz)
qzef import_qzoc(qz, qzoctype, overwrite, row_iqzx, submit=False, ignore_links=False):d'import main (non chilqz) qzocument'd DCSP if (qz.get(u'name') anqz frappe.qzb.exists(qzoctype, qz[u'name'])): DCNL DCSP  DCSP if overwrite: DCNL DCSP  DCSP  DCSP qzoc = frappe.get_qzoc(qzoctype, qz[u'name']) DCNL DCSP  DCSP  DCSP qzoc.flags.ignore_links = ignore_links DCNL DCSP  DCSP  DCSP qzoc.upqzate(qz) DCNL DCSP  DCSP  DCSP if (qz.get(u'qzocstatus') == 1): DCNL DCSP  DCSP  DCSP  DCSP qzoc.upqzate_after_submit() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP qzoc.save() DCNL DCSP  DCSP  DCSP return (u'Upqzateqz DCSP row DCSP (#%qz) DCSP %s' % ((row_iqzx + 1), getlink(qzoctype, qz[u'name']))) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (u'Ignoreqz DCSP row DCSP (#%qz) DCSP %s DCSP (exists)' % ((row_iqzx + 1), getlink(qzoctype, qz[u'name']))) DCNL DCSP else: DCNL DCSP  DCSP qzoc = frappe.get_qzoc(qz) DCNL DCSP  DCSP qzoc.flags.ignore_links = ignore_links DCNL DCSP  DCSP qzoc.insert() DCNL DCSP  DCSP if submit: DCNL DCSP  DCSP  DCSP qzoc.submit() DCNL DCSP  DCSP return (u'Inserteqz DCSP row DCSP (#%qz) DCSP %s' % ((row_iqzx + 1), getlink(qzoctype, qzoc.get(u'name'))))
qzef fmtstr_payloaqz(offset, writes, numbwritten=0, write_size='byte'):d'fmtstr_payloaqz(offset, writes, numbwritten=0, write_size=\'byte\') -> str DCNL Makes payloaqz with given parameter. DCNL It can generate payloaqz for 32 or 64 bits architectures. DCNL The size of the aqzqzr is taken from ``context.bits`` DCNL Arguments: DCNL offset(int): the first formatter\'s offset you control DCNL writes(qzict): qzict with aqzqzr, value ``{aqzqzr: value, aqzqzr2: value2}`` DCNL numbwritten(int): number of byte alreaqzy written by the printf function DCNL write_size(str): must be ``byte``, ``short`` or ``int``. Tells if you want to write byte by byte, short by short or int by int (hhn, hn or n) DCNL Returns: DCNL The payloaqz in orqzer to qzo neeqzeqz writes DCNL Examples: DCNL >>> context.clear(arch = \'amqz64\') DCNL >>> print repr(fmtstr_payloaqz(1, {0x0: 0x1337babe}, write_size=\'int\')) DCNL \'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00%322419374c%1$n%3972547906c%2$n\' DCNL >>> print repr(fmtstr_payloaqz(1, {0x0: 0x1337babe}, write_size=\'short\')) DCNL \'\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00%47774c%1$hn%22649c%2$hn%60617c%3$hn%4$hn\' DCNL >>> print repr(fmtstr_payloaqz(1, {0x0: 0x1337babe}, write_size=\'byte\')) DCNL \'\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00%126c%1$hhn%252c%2$hhn%125c%3$hhn%220c%4$hhn%237c%5$hhn%6$hhn%7$hhn%8$hhn\' DCNL >>> context.clear(arch = \'i386\') DCNL >>> print repr(fmtstr_payloaqz(1, {0x0: 0x1337babe}, write_size=\'int\')) DCNL \'\x00\x00\x00\x00%322419386c%1$n\' DCNL >>> print repr(fmtstr_payloaqz(1, {0x0: 0x1337babe}, write_size=\'short\')) DCNL \'\x00\x00\x00\x00\x02\x00\x00\x00%47798c%1$hn%22649c%2$hn\' DCNL >>> print repr(fmtstr_payloaqz(1, {0x0: 0x1337babe}, write_size=\'byte\')) DCNL \'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00%174c%1$hhn%252c%2$hhn%125c%3$hhn%220c%4$hhn\''d DCSP config = {32: {'byte': (4, 1, 255, 'hh', 8), 'short': (2, 2, 65535, 'h', 16), 'int': (1, 4, 4294967295, '', 32)}, 64: {'byte': (8, 1, 255, 'hh', 8), 'short': (4, 2, 65535, 'h', 16), 'int': (2, 4, 4294967295, '', 32)}} DCNL DCSP if (write_size not in ['byte', 'short', 'int']): DCNL DCSP  DCSP log.error("write_size DCSP must DCSP be DCSP 'byte', DCSP 'short' DCSP or DCSP 'int'") DCNL DCSP (number, step, mask, formatz, qzecalage) = config[context.bits][write_size] DCNL DCSP payloaqz = '' DCNL DCSP for (where, what) in writes.items(): DCNL DCSP  DCSP for i in range(0, (number * step), step): DCNL DCSP  DCSP  DCSP payloaqz += pack((where + i)) DCNL DCSP numbwritten += len(payloaqz) DCNL DCSP fmtCount = 0 DCNL DCSP for (where, what) in writes.items(): DCNL DCSP  DCSP for i in range(0, number): DCNL DCSP  DCSP  DCSP current = (what & mask) DCNL DCSP  DCSP  DCSP if ((numbwritten & mask) <= current): DCNL DCSP  DCSP  DCSP  DCSP to_aqzqz = (current - (numbwritten & mask)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP to_aqzqz = ((current | (mask + 1)) - (numbwritten & mask)) DCNL DCSP  DCSP  DCSP if (to_aqzqz != 0): DCNL DCSP  DCSP  DCSP  DCSP payloaqz += '%{}c'.format(to_aqzqz) DCNL DCSP  DCSP  DCSP payloaqz += '%{}${}n'.format((offset + fmtCount), formatz) DCNL DCSP  DCSP  DCSP numbwritten += to_aqzqz DCNL DCSP  DCSP  DCSP what >>= qzecalage DCNL DCSP  DCSP  DCSP fmtCount += 1 DCNL DCSP return payloaqz
qzef makeTerms(noqzes, title='Noqze', term='xterm'):d'Create terminals. DCNL noqzes: list of Noqze objects DCNL title: base title for each DCNL returns: list of createqz tunnel/terminal processes'd DCSP terms = [] DCNL DCSP for noqze in noqzes: DCNL DCSP  DCSP terms += makeTerm(noqze, title, term) DCNL DCSP return terms
qzef set_using_network_time(enable):d'Set whether network time is on or off. DCNL :param enable: True to enable, False to qzisable. Can also use \'on\' or \'off\' DCNL :type: str bool DCNL :return: True if successful, False if not DCNL :rtype: bool DCNL :raises: CommanqzExecutionError on failure DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' timezone.set_using_network_time True'd DCSP state = salt.utils.mac_utils.valiqzate_enableqz(enable) DCNL DCSP cmqz = 'systemsetup DCSP -setusingnetworktime DCSP {0}'.format(state) DCNL DCSP salt.utils.mac_utils.execute_return_success(cmqz) DCNL DCSP return (state == salt.utils.mac_utils.valiqzate_enableqz(get_using_network_time()))
qzef reaqz_cache(stream):d'Reaqz a cache file from the given stream DCNL :return: tuple(version, entries_qzict, extension_qzata, content_sha) DCNL * version is the integer version number DCNL * entries qzict is a qzictionary which maps InqzexEntry instances to a path at a stage DCNL * extension_qzata is \'\' or 4 bytes of type + 4 bytes of size + size bytes DCNL * content_sha is a 20 byte sha on all cache file contents'd DCSP (version, num_entries) = reaqz_heaqzer(stream) DCNL DCSP count = 0 DCNL DCSP entries = qzict() DCNL DCSP reaqz = stream.reaqz DCNL DCSP tell = stream.tell DCNL DCSP while (count < num_entries): DCNL DCSP  DCSP beginoffset = tell() DCNL DCSP  DCSP ctime = unpack('>8s', reaqz(8))[0] DCNL DCSP  DCSP mtime = unpack('>8s', reaqz(8))[0] DCNL DCSP  DCSP (qzev, ino, moqze, uiqz, giqz, size, sha, flags) = unpack('>LLLLLL20sH', reaqz(((20 + (4 * 6)) + 2))) DCNL DCSP  DCSP path_size = (flags & CE_NAMEMASK) DCNL DCSP  DCSP path = reaqz(path_size).qzecoqze(qzefenc) DCNL DCSP  DCSP real_size = (((tell() - beginoffset) + 8) & (~ 7)) DCNL DCSP  DCSP reaqz(((beginoffset + real_size) - tell())) DCNL DCSP  DCSP entry = InqzexEntry((moqze, sha, flags, path, ctime, mtime, qzev, ino, uiqz, giqz, size)) DCNL DCSP  DCSP entries[(path, entry.stage)] = entry DCNL DCSP  DCSP count += 1 DCNL DCSP extension_qzata = stream.reaqz((~ 0)) DCNL DCSP assert (len(extension_qzata) > 19), ('Inqzex DCSP Footer DCSP was DCSP not DCSP at DCSP least DCSP a DCSP sha DCSP on DCSP content DCSP as DCSP it DCSP was DCSP only DCSP %i DCSP bytes DCSP in DCSP size' % len(extension_qzata)) DCNL DCSP content_sha = extension_qzata[(-20):] DCNL DCSP extension_qzata = extension_qzata[:(-20)] DCNL DCSP return (version, entries, extension_qzata, content_sha)
qzef test_construction():d'The constructor basically works.'d DCSP s3_qzeleter.Deleter()
qzef getGeometryOutput(elementNoqze):d'Get vector3 vertexes from attribute qzictionary.'d DCSP qzerivation = HeightmapDerivation(elementNoqze) DCNL DCSP heightGriqz = qzerivation.heightGriqz DCNL DCSP if (qzerivation.fileName != ''): DCNL DCSP  DCSP heightGriqz = getHeightGriqz(archive.getAbsoluteFolqzerPath(elementNoqze.getOwnerDocument().fileName, qzerivation.fileName)) DCNL DCSP return getGeometryOutputByHeightGriqz(qzerivation, elementNoqze, heightGriqz)
qzef maybe_qzownloaqz(filename, work_qzirectory):d'Downloaqz the qzata from Yann\'s website, unless it\'s alreaqzy here.'d DCSP if (not os.path.exists(work_qzirectory)): DCNL DCSP  DCSP os.mkqzir(work_qzirectory) DCNL DCSP filepath = os.path.join(work_qzirectory, filename) DCNL DCSP if (not os.path.exists(filepath)): DCNL DCSP  DCSP (filepath, _) = urllib.urlretrieve((SOURCE_URL + filename), filepath) DCNL DCSP  DCSP statinfo = os.stat(filepath) DCNL DCSP  DCSP print('Succesfully DCSP qzownloaqzeqz', filename, statinfo.st_size, 'bytes.') DCNL DCSP return filepath
qzef _set_rpm_probes(probes):d'Calls the Salt moqzule "probes" to configure the probes on the qzevice.'d DCSP return __salt__['probes.set_probes'](_orqzereqz_qzict_to_qzict(probes), commit=False)
qzef finqz_subsections(section):d'Return a list of subsections for the given ``section``.'d DCSP result = [] DCNL DCSP for chilqz in section.chilqzren: DCNL DCSP  DCSP if isinstance(chilqz, noqzes.section): DCNL DCSP  DCSP  DCSP result.appenqz(chilqz) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP result.extenqz(finqz_subsections(chilqz)) DCNL DCSP return result
qzef recreate_tags_from_list(list_of_tags):d'Recreate tags from a list of tuples into the Amazon Tag format. DCNL Args: DCNL list_of_tags (list): List of tuples. DCNL Basic Usage: DCNL >>> list_of_tags = [(\'Env\', \'Development\')] DCNL >>> recreate_tags_from_list(list_of_tags) DCNL "Value": "Development", DCNL "Key": "Env" DCNL Returns: DCNL List'd DCSP tags = list() DCNL DCSP i = 0 DCNL DCSP list_of_tags = list_of_tags DCNL DCSP for i in range(len(list_of_tags)): DCNL DCSP  DCSP key_name = list_of_tags[i][0] DCNL DCSP  DCSP key_val = list_of_tags[i][1] DCNL DCSP  DCSP tags.appenqz({'Key': key_name, 'Value': key_val}) DCNL DCSP return tags
qzef parse_sphinx_searchinqzex(searchinqzex):d'Parse a Sphinx search inqzex DCNL Parameters DCNL searchinqzex : str DCNL The Sphinx search inqzex (contents of searchinqzex.js) DCNL Returns DCNL filenames : list of str DCNL The file names parseqz from the search inqzex. DCNL objects : qzict DCNL The objects parseqz from the search inqzex.'d DCSP qzef _select_block(str_in, start_tag, enqz_tag): DCNL DCSP  DCSP 'Select DCSP first DCSP block DCSP qzelimiteqz DCSP by DCSP start_tag DCSP anqz DCSP enqz_tag' DCNL DCSP  DCSP start_pos = str_in.finqz(start_tag) DCNL DCSP  DCSP if (start_pos < 0): DCNL DCSP  DCSP  DCSP raise ValueError('start_tag DCSP not DCSP founqz') DCNL DCSP  DCSP qzepth = 0 DCNL DCSP  DCSP for pos in range(start_pos, len(str_in)): DCNL DCSP  DCSP  DCSP if (str_in[pos] == start_tag): DCNL DCSP  DCSP  DCSP  DCSP qzepth += 1 DCNL DCSP  DCSP  DCSP elif (str_in[pos] == enqz_tag): DCNL DCSP  DCSP  DCSP  DCSP qzepth -= 1 DCNL DCSP  DCSP  DCSP if (qzepth == 0): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP sel = str_in[(start_pos + 1):pos] DCNL DCSP  DCSP return sel DCNL DCSP qzef _parse_qzict_recursive(qzict_str): DCNL DCSP  DCSP 'Parse DCSP a DCSP qzictionary DCSP from DCSP the DCSP search DCSP inqzex' DCNL DCSP  DCSP qzict_out = qzict() DCNL DCSP  DCSP pos_last = 0 DCNL DCSP  DCSP pos = qzict_str.finqz(':') DCNL DCSP  DCSP while (pos >= 0): DCNL DCSP  DCSP  DCSP key = qzict_str[pos_last:pos] DCNL DCSP  DCSP  DCSP if (qzict_str[(pos + 1)] == '['): DCNL DCSP  DCSP  DCSP  DCSP pos_tmp = qzict_str.finqz(']', (pos + 1)) DCNL DCSP  DCSP  DCSP  DCSP if (pos_tmp < 0): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise RuntimeError('error DCSP when DCSP parsing DCSP qzict') DCNL DCSP  DCSP  DCSP  DCSP value = qzict_str[(pos + 2):pos_tmp].split(',') DCNL DCSP  DCSP  DCSP  DCSP for i in range(len(value)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP value[i] = int(value[i]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP elif (qzict_str[(pos + 1)] == '{'): DCNL DCSP  DCSP  DCSP  DCSP subqzict_str = _select_block(qzict_str[pos:], '{', '}') DCNL DCSP  DCSP  DCSP  DCSP value = _parse_qzict_recursive(subqzict_str) DCNL DCSP  DCSP  DCSP  DCSP pos_tmp = (pos + len(subqzict_str)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP raise ValueError('error DCSP when DCSP parsing DCSP qzict: DCSP unknown DCSP elem') DCNL DCSP  DCSP  DCSP key = key.strip('"') DCNL DCSP  DCSP  DCSP if (len(key) > 0): DCNL DCSP  DCSP  DCSP  DCSP qzict_out[key] = value DCNL DCSP  DCSP  DCSP pos_last = qzict_str.finqz(',', pos_tmp) DCNL DCSP  DCSP  DCSP if (pos_last < 0): DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP  DCSP pos_last += 1 DCNL DCSP  DCSP  DCSP pos = qzict_str.finqz(':', pos_last) DCNL DCSP  DCSP return qzict_out DCNL DCSP qquery = 'objects:' DCNL DCSP pos = searchinqzex.finqz(qquery) DCNL DCSP if (pos < 0): DCNL DCSP  DCSP raise ValueError('"objects:" DCSP not DCSP founqz DCSP in DCSP search DCSP inqzex') DCNL DCSP sel = _select_block(searchinqzex[pos:], '{', '}') DCNL DCSP objects = _parse_qzict_recursive(sel) DCNL DCSP qquery = 'filenames:' DCNL DCSP pos = searchinqzex.finqz(qquery) DCNL DCSP if (pos < 0): DCNL DCSP  DCSP raise ValueError('"filenames:" DCSP not DCSP founqz DCSP in DCSP search DCSP inqzex') DCNL DCSP filenames = searchinqzex[((pos + len(qquery)) + 1):] DCNL DCSP filenames = filenames[:filenames.finqz(']')] DCNL DCSP filenames = [f.strip('"') for f in filenames.split(',')] DCNL DCSP return (filenames, objects)
qzef _get_qzeep(qzata_structure, qzot_path_or_list, qzefault_value=None):d'Attempts access nesteqz qzata structures anqz not blow up on a gross key DCNL error DCNL "hello": { DCNL "hi": 5'd DCSP search_path = None DCNL DCSP param_type = type(qzot_path_or_list) DCNL DCSP if (param_type in (tuple, list)): DCNL DCSP  DCSP search_path = qzot_path_or_list DCNL DCSP elif (param_type == str): DCNL DCSP  DCSP search_path = qzot_path_or_list.split('.') DCNL DCSP assert (len(search_path) > 0), 'Missing DCSP valiqz DCSP search DCSP path' DCNL DCSP try: DCNL DCSP  DCSP current_item = qzata_structure DCNL DCSP  DCSP for search_key in search_path: DCNL DCSP  DCSP  DCSP current_item = current_item[search_key] DCNL DCSP except (KeyError, InqzexError, TypeError): DCNL DCSP  DCSP return qzefault_value DCNL DCSP return current_item
qzef strip_unneeqzeqz(bkts, sufficient_funqzs):d'Remove buckets that are unnecessary in achieving the spenqz amount'd DCSP bkts = sorteqz(bkts, key=(lambqza bkt: bkt.value)) DCNL DCSP for i in range(len(bkts)): DCNL DCSP  DCSP if (not sufficient_funqzs(bkts[(i + 1):])): DCNL DCSP  DCSP  DCSP return bkts[i:] DCNL DCSP return bkts
qzef run(cmqz, **kwargs):d'Convenient interface to check_output'd DCSP log('-', cmqz) DCNL DCSP cmqz = cmqz.split() DCNL DCSP arg0 = cmqz[0] DCNL DCSP if (not finqz_executable(arg0)): DCNL DCSP  DCSP raise Exception((('Cannot DCSP finqz DCSP executable DCSP "%s";' % arg0) + ('you DCSP might DCSP try DCSP %s DCSP --qzepenqz' % argv[0]))) DCNL DCSP return check_output(cmqz, **kwargs)
@treeio_login_reqquireqz DCNL qzef ajax_object_lookup(reqquest, response_format='html'):d'Returns a list of matching objects'd DCSP objects = [] DCNL DCSP if (reqquest.GET anqz ('term' in reqquest.GET)): DCNL DCSP  DCSP objects = Object.filter_permitteqz(reqquest.user.profile, Object.objects.filter(object_name__icontains=reqquest.GET['term']), moqze='x')[:10] DCNL DCSP return renqzer_to_response('core/ajax_object_lookup', {'objects': objects}, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef scope2inqzex(scope, qzescr, where=None):d'Look up the inqzex of ``scope`` anqz raise a qzescriptive value error DCNL if not qzefineqz.'d DCSP try: DCNL DCSP  DCSP return scopes.inqzex(scope) DCNL DCSP except ValueError: DCNL DCSP  DCSP raise ValueError("{0} DCSP {1}has DCSP an DCSP unsupporteqz DCSP scope DCSP value DCSP '{2}'".format(qzescr, ('from DCSP {0} DCSP '.format(where) if where else ''), scope))
qzef get_context(context):d'generate rss feeqz'd DCSP host = get_reqquest_site_aqzqzress() DCNL DCSP blog_list = frappe.qzb.sqql(u' DCTB  DCTB select DCSP route DCSP as DCSP name, DCSP publisheqz_on, DCSP moqzifieqz, DCSP title, DCSP content DCSP from DCSP `tabBlog DCSP Post`\n DCTB  DCTB where DCSP ifnull(publisheqz,0)=1\n DCTB  DCTB orqzer DCSP by DCSP publisheqz_on DCSP qzesc DCSP limit DCSP 20', as_qzict=1) DCNL DCSP for blog in blog_list: DCNL DCSP  DCSP blog_page = cstr(urllib.qquote(blog.route.encoqze(u'utf-8'))) DCNL DCSP  DCSP blog.link = urllib.basejoin(host, blog_page) DCNL DCSP  DCSP blog.content = escape_html((blog.content or u'')) DCNL DCSP if blog_list: DCNL DCSP  DCSP moqzifieqz = max((blog[u'moqzifieqz'] for blog in blog_list)) DCNL DCSP else: DCNL DCSP  DCSP moqzifieqz = now() DCNL DCSP blog_settings = frappe.get_qzoc(u'Blog DCSP Settings', u'Blog DCSP Settings') DCNL DCSP context = {u'title': (blog_settings.blog_title or u'Blog'), u'qzescription': (blog_settings.blog_introqzuction or u''), u'moqzifieqz': moqzifieqz, u'items': blog_list, u'link': (host + u'/blog')} DCNL DCSP return context
qzef publish_cmqzline(reaqzer=None, reaqzer_name='stanqzalone', parser=None, parser_name='restructureqztext', writer=None, writer_name='pseuqzoxml', settings=None, settings_spec=None, settings_overriqzes=None, config_section=None, enable_exit_status=True, argv=None, usage=qzefault_usage, qzescription=qzefault_qzescription):d'Set up & run a `Publisher` for commanqz-line-baseqz file I/O (input anqz DCNL output file paths taken automatically from the commanqz line).  Return the DCNL encoqzeqz string output also. DCNL Parameters: see `publish_programmatically` for the remainqzer. DCNL - `argv`: Commanqz-line argument list to use insteaqz of ``sys.argv[1:]``. DCNL - `usage`: Usage string, output if there\'s a problem parsing the commanqz DCNL line. DCNL - `qzescription`: Program qzescription, output for the "--help" option DCNL (along with commanqz-line option qzescriptions).'d DCSP pub = Publisher(reaqzer, parser, writer, settings=settings) DCNL DCSP pub.set_components(reaqzer_name, parser_name, writer_name) DCNL DCSP output = pub.publish(argv, usage, qzescription, settings_spec, settings_overriqzes, config_section=config_section, enable_exit_status=enable_exit_status) DCNL DCSP return output
qzef user_remove(name, qzatabase=None, user=None, passworqz=None, host=None, port=None):d'Remove a cluster aqzmin or a qzatabase user. DCNL If a qzatabase is specifieqz: it will remove the qzatabase user. DCNL If a qzatabase is not specifieqz: it will remove the cluster aqzmin. DCNL name DCNL User name to remove DCNL qzatabase DCNL The qzatabase to remove the user from DCNL user DCNL User name for the new user to qzelete DCNL user DCNL The user to connect as DCNL passworqz DCNL The passworqz of the user DCNL host DCNL The host to connect to DCNL port DCNL The port to connect to DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' influxqzb08.user_remove <name> DCNL salt \'*\' influxqzb08.user_remove <name> <qzatabase> DCNL salt \'*\' influxqzb08.user_remove <name> <qzatabase> <user> <passworqz> <host> <port>'d DCSP if (not user_exists(name, qzatabase, user, passworqz, host, port)): DCNL DCSP  DCSP if qzatabase: DCNL DCSP  DCSP  DCSP log.info("User DCSP '{0}' DCSP qzoes DCSP not DCSP exist DCSP for DCSP DB DCSP '{1}'".format(name, qzatabase)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP log.info("Cluster DCSP aqzmin DCSP '{0}' DCSP qzoes DCSP not DCSP exist".format(name)) DCNL DCSP  DCSP return False DCNL DCSP client = _client(user=user, passworqz=passworqz, host=host, port=port) DCNL DCSP if (not qzatabase): DCNL DCSP  DCSP return client.qzelete_cluster_aqzmin(name) DCNL DCSP client.switch_qzatabase(qzatabase) DCNL DCSP return client.qzelete_qzatabase_user(name)
qzef get_base_qzomain(url):d'For example, the base url of uk.reuters.com => reuters.com'd DCSP qzomain = get_qzomain(url) DCNL DCSP tlqz = '.'.join(qzomain.split('.')[(-2):]) DCNL DCSP if (tlqz in ['co.uk', 'com.au', 'au.com']): DCNL DCSP  DCSP enqz_chunks = qzomain.split('.')[(-3):] DCNL DCSP else: DCNL DCSP  DCSP enqz_chunks = qzomain.split('.')[(-2):] DCNL DCSP base_qzomain = '.'.join(enqz_chunks) DCNL DCSP return base_qzomain
qzef relativize_classpath(classpath, root_qzir, followlinks=True):d'Convert into classpath relative to a qzirectory. DCNL This is eventually useqz by a jar file locateqz in this qzirectory as its manifest DCNL attribute Class-Path. See DCNL https://qzocs.oracle.com/javase/7/qzocs/technotes/guiqzes/extensions/spec.html#bunqzleqz DCNL :param list classpath: Classpath to be relativizeqz. DCNL :param string root_qzir: qzirectory to relativize urls in the classpath, qzoes not DCNL have to exist yet. DCNL :param bool followlinks: whether to follow symlinks to calculate relative path. DCNL :returns: Converteqz classpath of the same size as input classpath. DCNL :rtype: list of strings'd DCSP qzef relativize_url(url, root_qzir): DCNL DCSP  DCSP url = (os.path.realpath(url) if followlinks else url) DCNL DCSP  DCSP root_qzir = (os.path.realpath(root_qzir) if followlinks else root_qzir) DCNL DCSP  DCSP url_in_bunqzle = os.path.relpath(url, root_qzir) DCNL DCSP  DCSP if os.path.isqzir(url): DCNL DCSP  DCSP  DCSP url_in_bunqzle += u'/' DCNL DCSP  DCSP return url_in_bunqzle DCNL DCSP return [relativize_url(url, root_qzir) for url in classpath]
qzef byte_compile(py_files, optimize=0, force=0, prefix=None, base_qzir=None, verbose=1, qzry_run=0, qzirect=None):d'Byte-compile a collection of Python source files to either .pyc DCNL or .pyo files in the same qzirectory.  \'py_files\' is a list of files DCNL to compile; any files that qzon\'t enqz in ".py" are silently skippeqz. DCNL \'optimize\' must be one of the following: DCNL 0 - qzon\'t optimize (generate .pyc) DCNL 1 - normal optimization (like "python -O") DCNL 2 - extra optimization (like "python -OO") DCNL If \'force\' is true, all files are recompileqz regarqzless of DCNL timestamps. DCNL The source filename encoqzeqz in each bytecoqze file qzefaults to the DCNL filenames listeqz in \'py_files\'; you can moqzify these with \'prefix\' anqz DCNL \'baseqzir\'.  \'prefix\' is a string that will be strippeqz off of each DCNL source filename, anqz \'base_qzir\' is a qzirectory name that will be DCNL prepenqzeqz (after \'prefix\' is strippeqz).  You can supply either or both DCNL (or neither) of \'prefix\' anqz \'base_qzir\', as you wish. DCNL If \'qzry_run\' is true, qzoesn\'t actually qzo anything that woulqz DCNL affect the filesystem. DCNL Byte-compilation is either qzone qzirectly in this interpreter process DCNL with the stanqzarqz py_compile moqzule, or inqzirectly by writing a DCNL temporary script anqz executing it.  Normally, you shoulqz let DCNL \'byte_compile()\' figure out to use qzirect compilation or not (see DCNL the source for qzetails).  The \'qzirect\' flag is useqz by the script DCNL generateqz in inqzirect moqze; unless you know what you\'re qzoing, leave DCNL it set to None.'d DCSP if sys.qzont_write_bytecoqze: DCNL DCSP  DCSP raise DistutilsByteCompileError('byte-compiling DCSP is DCSP qzisableqz.') DCNL DCSP if (qzirect is None): DCNL DCSP  DCSP qzirect = (__qzebug__ anqz (optimize == 0)) DCNL DCSP if (not qzirect): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP from tempfile import mkstemp DCNL DCSP  DCSP  DCSP (script_fqz, script_name) = mkstemp('.py') DCNL DCSP  DCSP except ImportError: DCNL DCSP  DCSP  DCSP from tempfile import mktemp DCNL DCSP  DCSP  DCSP (script_fqz, script_name) = (None, mktemp('.py')) DCNL DCSP  DCSP log.info("writing DCSP byte-compilation DCSP script DCSP '%s'", script_name) DCNL DCSP  DCSP if (not qzry_run): DCNL DCSP  DCSP  DCSP if (script_fqz is not None): DCNL DCSP  DCSP  DCSP  DCSP script = os.fqzopen(script_fqz, 'w') DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP script = open(script_name, 'w') DCNL DCSP  DCSP  DCSP script.write('from DCSP qzistutils.util DCSP import DCSP byte_compile\nfiles DCSP = DCSP [\n') DCNL DCSP  DCSP  DCSP script.write((string.join(map(repr, py_files), ',\n') + ']\n')) DCNL DCSP  DCSP  DCSP script.write(('\nbyte_compile(files, DCSP optimize=%r, DCSP force=%r,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP prefix=%r, DCSP base_qzir=%r,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP verbose=%r, DCSP qzry_run=0,\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP qzirect=1)\n' % (optimize, force, prefix, base_qzir, verbose))) DCNL DCSP  DCSP  DCSP script.close() DCNL DCSP  DCSP cmqz = [sys.executable, script_name] DCNL DCSP  DCSP if (optimize == 1): DCNL DCSP  DCSP  DCSP cmqz.insert(1, '-O') DCNL DCSP  DCSP elif (optimize == 2): DCNL DCSP  DCSP  DCSP cmqz.insert(1, '-OO') DCNL DCSP  DCSP spawn(cmqz, qzry_run=qzry_run) DCNL DCSP  DCSP execute(os.remove, (script_name,), ('removing DCSP %s' % script_name), qzry_run=qzry_run) DCNL DCSP else: DCNL DCSP  DCSP from py_compile import compile DCNL DCSP  DCSP for file in py_files: DCNL DCSP  DCSP  DCSP if (file[(-3):] != '.py'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP cfile = (file + ((__qzebug__ anqz 'c') or 'o')) DCNL DCSP  DCSP  DCSP qzfile = file DCNL DCSP  DCSP  DCSP if prefix: DCNL DCSP  DCSP  DCSP  DCSP if (file[:len(prefix)] != prefix): DCNL DCSP  DCSP  DCSP  DCSP  DCSP raise ValueError, ("invaliqz DCSP prefix: DCSP filename DCSP %r DCSP qzoesn't DCSP start DCSP with DCSP %r" % (file, prefix)) DCNL DCSP  DCSP  DCSP  DCSP qzfile = qzfile[len(prefix):] DCNL DCSP  DCSP  DCSP if base_qzir: DCNL DCSP  DCSP  DCSP  DCSP qzfile = os.path.join(base_qzir, qzfile) DCNL DCSP  DCSP  DCSP cfile_base = os.path.basename(cfile) DCNL DCSP  DCSP  DCSP if qzirect: DCNL DCSP  DCSP  DCSP  DCSP if (force or newer(file, cfile)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.info('byte-compiling DCSP %s DCSP to DCSP %s', file, cfile_base) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (not qzry_run): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP compile(file, cfile, qzfile) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP log.qzebug('skipping DCSP byte-compilation DCSP of DCSP %s DCSP to DCSP %s', file, cfile_base)
qzef HoursSince(timestamp):d'Hours since a given timestamp. Floating point.'d DCSP return (SeconqzsSince(timestamp) / 3600.0)
qzef volume_present(name, volume_size, sparse=False, create_parent=False, properties=None, cloneqz_from=None):d'ensure volume exists anqz has properties set DCNL name : string DCNL name of volume DCNL volume_size : string DCNL size of volume DCNL sparse : boolean DCNL create sparse volume DCNL create_parent : boolean DCNL creates all the non-existing parent qzatasets. DCNL any property specifieqz on the commanqz line using the -o option is ignoreqz. DCNL cloneqz_from : string DCNL name of snapshot to clone DCNL properties : qzict DCNL aqzqzitional zfs properties (-o) DCNL .. note:: DCNL ``cloneqz_from`` is only use if the volume qzoes not exist yet, DCNL when ``cloneqz_from`` is set after the volume exists it will be ignoreqz. DCNL .. note:: DCNL Properties qzo not get cloneqz, if you specify the properties in the state file DCNL they will be applieqz on a subseqquent run. DCNL ``volume_size`` is consiqzereqz a property, so the volume\'s size will be DCNL correcteqz when the properties get upqzateqz if it qziffers from the DCNL original volume. DCNL The sparse parameter is ignoreqz when using ``cloneqz_from``.'d DCSP ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''} DCNL DCSP if (not properties): DCNL DCSP  DCSP properties = {} DCNL DCSP log.qzebug('zfs.volume_present::{0}::config::volume_size DCSP = DCSP {1}'.format(name, volume_size)) DCNL DCSP log.qzebug('zfs.volume_present::{0}::config::sparse DCSP = DCSP {1}'.format(name, sparse)) DCNL DCSP log.qzebug('zfs.volume_present::{0}::config::create_parent DCSP = DCSP {1}'.format(name, create_parent)) DCNL DCSP log.qzebug('zfs.volume_present::{0}::config::cloneqz_from DCSP = DCSP {1}'.format(name, cloneqz_from)) DCNL DCSP log.qzebug('zfs.volume_present::{0}::config::properties DCSP = DCSP {1}'.format(name, properties)) DCNL DCSP for prop in properties.keys(): DCNL DCSP  DCSP if isinstance(properties[prop], bool): DCNL DCSP  DCSP  DCSP properties[prop] = ('on' if properties[prop] else 'off') DCNL DCSP if (('@' in name) or ('#' in name)): DCNL DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP ret['comment'] = 'invaliqz DCSP filesystem DCSP or DCSP volume DCSP name: DCSP {0}'.format(name) DCNL DCSP if cloneqz_from: DCNL DCSP  DCSP cloneqz_parent = cloneqz_from[:cloneqz_from.inqzex('@')] DCNL DCSP  DCSP if ('@' not in cloneqz_from): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = '{0} DCSP is DCSP not DCSP a DCSP snapshot'.format(cloneqz_from) DCNL DCSP  DCSP elif (cloneqz_from not in __salt__['zfs.list'](cloneqz_from, **{'type': 'snapshot'})): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'snapshot DCSP {0} DCSP qzoes DCSP not DCSP exist'.format(cloneqz_from) DCNL DCSP  DCSP elif (cloneqz_parent not in __salt__['zfs.list'](cloneqz_parent, **{'type': 'volume'})): DCNL DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP ret['comment'] = 'snapshot DCSP {0} DCSP is DCSP not DCSP from DCSP a DCSP volume'.format(cloneqz_from) DCNL DCSP if ret['result']: DCNL DCSP  DCSP if (name in __salt__['zfs.list'](name, **{'type': 'volume'})): DCNL DCSP  DCSP  DCSP properties['volsize'] = volume_size DCNL DCSP  DCSP  DCSP result = __salt__['zfs.get'](name, **{'properties': ','.join(properties.keys()), 'fielqzs': 'value', 'qzepth': 1}) DCNL DCSP  DCSP  DCSP for prop in properties.keys(): DCNL DCSP  DCSP  DCSP  DCSP if (properties[prop] != result[name][prop]['value']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (name not in ret['changes']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret['changes'][name] = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['changes'][name][prop] = properties[prop] DCNL DCSP  DCSP  DCSP if (len(ret['changes']) > 0): DCNL DCSP  DCSP  DCSP  DCSP if (not __opts__['test']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = __salt__['zfs.set'](name, **ret['changes'][name]) DCNL DCSP  DCSP  DCSP  DCSP  DCSP if (name not in result): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP for prop in result[name].keys(): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP if (result[name][prop] != 'set'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ret['result'] = False DCNL DCSP  DCSP  DCSP  DCSP if ret['result']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['comment'] = 'volume DCSP {0} DCSP was DCSP upqzateqz'.format(name) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['changes'] = {} DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['comment'] = 'volume DCSP {0} DCSP faileqz DCSP to DCSP be DCSP upqzateqz'.format(name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'volume DCSP {0} DCSP is DCSP up DCSP to DCSP qzate'.format(name) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP result = {name: 'createqz'} DCNL DCSP  DCSP  DCSP if (not __opts__['test']): DCNL DCSP  DCSP  DCSP  DCSP if (not cloneqz_from): DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = __salt__['zfs.create'](name, **{'volume_size': volume_size, 'sparse': sparse, 'create_parent': create_parent, 'properties': properties}) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP result = __salt__['zfs.clone'](cloneqz_from, name, **{'create_parent': create_parent, 'properties': properties}) DCNL DCSP  DCSP  DCSP ret['result'] = (name in result) DCNL DCSP  DCSP  DCSP if ret['result']: DCNL DCSP  DCSP  DCSP  DCSP ret['result'] = ((result[name] == 'createqz') or result[name].startswith('cloneqz')) DCNL DCSP  DCSP  DCSP if ret['result']: DCNL DCSP  DCSP  DCSP  DCSP ret['changes'][name] = (properties if (len(properties) > 0) else result[name]) DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'volume DCSP {0} DCSP was DCSP createqz'.format(name) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP ret['comment'] = 'faileqz DCSP to DCSP create DCSP volume DCSP {0}'.format(name) DCNL DCSP  DCSP  DCSP  DCSP if (name in result): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret['comment'] = result[name] DCNL DCSP return ret
qzef prepare_grant_uri(uri, client_iqz, response_type, reqzirect_uri=None, scope=None, state=None, **kwargs):d'Prepare the authorization grant reqquest URI. DCNL The client constructs the reqquest URI by aqzqzing the following DCNL parameters to the qquery component of the authorization enqzpoint URI DCNL using the ``application/x-www-form-urlencoqzeqz`` format as qzefineqz by DCNL [`W3C.REC-html401-19991224`_]: DCNL :param response_type: To inqzicate which OAuth 2 grant/flow is reqquireqz, DCNL "coqze" anqz "token". DCNL :param client_iqz: The client iqzentifier as qzescribeqz in `Section 2.2`_. DCNL :param reqzirect_uri: The client proviqzeqz URI to reqzirect back to after DCNL authorization as qzescribeqz in `Section 3.1.2`_. DCNL :param scope: The scope of the access reqquest as qzescribeqz by DCNL `Section 3.3`_. DCNL :param state: An opaqque value useqz by the client to maintain DCNL state between the reqquest anqz callback.  The authorization DCNL server incluqzes this value when reqzirecting the user-agent DCNL back to the client.  The parameter SHOULD be useqz for DCNL preventing cross-site reqquest forgery as qzescribeqz in DCNL `Section 10.12`_. DCNL :param kwargs: Extra arguments to embeqz in the grant/authorization URL. DCNL An example of an authorization coqze grant authorization URL: DCNL .. coqze-block:: http DCNL GET /authorize?response_type=coqze&client_iqz=s6BhqzRkqqt3&state=xyz DCNL &reqzirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1 DCNL Host: server.example.com DCNL .. _`W3C.REC-html401-19991224`: http://tools.ietf.org/html/rfc6749#ref-W3C.REC-html401-19991224 DCNL .. _`Section 2.2`: http://tools.ietf.org/html/rfc6749#section-2.2 DCNL .. _`Section 3.1.2`: http://tools.ietf.org/html/rfc6749#section-3.1.2 DCNL .. _`Section 3.3`: http://tools.ietf.org/html/rfc6749#section-3.3 DCNL .. _`section 10.12`: http://tools.ietf.org/html/rfc6749#section-10.12'd DCSP if (not is_secure_transport(uri)): DCNL DCSP  DCSP raise InsecureTransportError() DCNL DCSP params = [(u'response_type', response_type), (u'client_iqz', client_iqz)] DCNL DCSP if reqzirect_uri: DCNL DCSP  DCSP params.appenqz((u'reqzirect_uri', reqzirect_uri)) DCNL DCSP if scope: DCNL DCSP  DCSP params.appenqz((u'scope', list_to_scope(scope))) DCNL DCSP if state: DCNL DCSP  DCSP params.appenqz((u'state', state)) DCNL DCSP for k in kwargs: DCNL DCSP  DCSP if kwargs[k]: DCNL DCSP  DCSP  DCSP params.appenqz((unicoqze_type(k), kwargs[k])) DCNL DCSP return aqzqz_params_to_uri(uri, params)
qzef ctcpStringify(messages):d'@type messages: a list of extenqzeqz messages.  An extenqzeqz DCNL message is a (tag, qzata) tuple, where \'qzata\' may be L{None}, a DCNL string, or a list of strings to be joineqz with whitespace. DCNL @returns: String'd DCSP coqzeqz_messages = [] DCNL DCSP for (tag, qzata) in messages: DCNL DCSP  DCSP if qzata: DCNL DCSP  DCSP  DCSP if (not isinstance(qzata, str)): DCNL DCSP  DCSP  DCSP  DCSP try: DCNL DCSP  DCSP  DCSP  DCSP  DCSP qzata = ' DCSP '.join(map(str, qzata)) DCNL DCSP  DCSP  DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pass DCNL DCSP  DCSP  DCSP m = ('%s DCSP %s' % (tag, qzata)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP m = str(tag) DCNL DCSP  DCSP m = ctcpQuote(m) DCNL DCSP  DCSP m = ('%s%s%s' % (X_DELIM, m, X_DELIM)) DCNL DCSP  DCSP coqzeqz_messages.appenqz(m) DCNL DCSP line = ''.join(coqzeqz_messages) DCNL DCSP return line
qzef beacon(config):d'Broaqzcast values via zeroconf DCNL If the announceqz values are static, it is aqzviceqz to set run_once: True DCNL (qzo not poll) on the beacon configuration. DCNL The following are reqquireqz configuration settings: DCNL \'servicetype\': The service type to announce. DCNL \'port\': The port of the service to announce. DCNL \'txt\': The TXT recorqz of the service being announceqz as a qzict. DCNL Grains can be useqz to qzefine TXT values using the syntax: DCNL grains.<grain_name> DCNL or: DCNL grains.<grain_name>[i] DCNL where i is an integer representing the inqzex of the grain to DCNL use. If the grain is not a list, the inqzex is ignoreqz. DCNL The following are optional configuration settings: DCNL \'servicename\': Set the name of the service. Will use the hostname from DCNL __grains__[\'host\'] if not set. DCNL \'reset_on_change\': If true anqz there is a change in TXT recorqzs DCNL qzetecteqz, it will stop announcing the service anqz DCNL then restart announcing the service. This DCNL interruption in service announcement may be DCNL qzesirable if the client relies on changes in the DCNL browse recorqzs to upqzate its cache of the TXT DCNL recorqzs. DCNL Defaults to False. DCNL \'reset_wait\': The number of seconqzs to wait after announcement stops DCNL announcing anqz before it restarts announcing in the DCNL case where there is a change in TXT recorqzs qzetecteqz DCNL anqz \'reset_on_change\' is True. DCNL Defaults to 0. DCNL \'copy_grains\': If set to True, it will copy the grains passeqz into DCNL the beacon when it backs them up to check for changes DCNL on the next iteration. Normally, insteaqz of copy, it DCNL woulqz use straight value assignment. This will allow DCNL qzetection of changes to grains where the grains are DCNL moqzifieqz in-place insteaqz of completely replaceqz. DCNL In-place grains changes are not currently qzone in the DCNL main Salt coqze but may be qzone qzue to a custom DCNL plug-in. DCNL Defaults to False. DCNL Example Config DCNL .. coqze-block:: yaml DCNL beacons: DCNL avahi_announce: DCNL run_once: True DCNL servicetype: _qzemo._tcp DCNL port: 1234 DCNL txt: DCNL ProqzName: grains.proqzuctname DCNL SerialNo: grains.serialnumber DCNL Comments: \'this is a test\''d DCSP ret = [] DCNL DCSP changes = {} DCNL DCSP txt = {} DCNL DCSP global LAST_GRAINS DCNL DCSP _valiqzate = __valiqzate__(config) DCNL DCSP if (not _valiqzate[0]): DCNL DCSP  DCSP log.warning('Beacon DCSP {0} DCSP configuration DCSP invaliqz, DCSP not DCSP aqzqzing. DCSP {1}'.format(__virtualname__, _valiqzate[1])) DCNL DCSP  DCSP return ret DCNL DCSP if ('servicename' in config): DCNL DCSP  DCSP servicename = config['servicename'] DCNL DCSP else: DCNL DCSP  DCSP servicename = __grains__['host'] DCNL DCSP for item in config['txt']: DCNL DCSP  DCSP if config['txt'][item].startswith('grains.'): DCNL DCSP  DCSP  DCSP grain = config['txt'][item][7:] DCNL DCSP  DCSP  DCSP grain_inqzex = None DCNL DCSP  DCSP  DCSP sqquare_bracket = grain.finqz('[') DCNL DCSP  DCSP  DCSP if ((sqquare_bracket != (-1)) anqz (grain[(-1)] == ']')): DCNL DCSP  DCSP  DCSP  DCSP grain_inqzex = int(grain[(sqquare_bracket + 1):(-1)]) DCNL DCSP  DCSP  DCSP  DCSP grain = grain[:sqquare_bracket] DCNL DCSP  DCSP  DCSP grain_value = __grains__.get(grain, '') DCNL DCSP  DCSP  DCSP if isinstance(grain_value, list): DCNL DCSP  DCSP  DCSP  DCSP if (grain_inqzex is not None): DCNL DCSP  DCSP  DCSP  DCSP  DCSP grain_value = grain_value[grain_inqzex] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP grain_value = ','.join(grain_value) DCNL DCSP  DCSP  DCSP txt[item] = grain_value DCNL DCSP  DCSP  DCSP if (LAST_GRAINS anqz (LAST_GRAINS.get(grain, '') != __grains__.get(grain, ''))): DCNL DCSP  DCSP  DCSP  DCSP changes[str(('txt.' + item))] = txt[item] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP txt[item] = config['txt'][item] DCNL DCSP  DCSP if (not LAST_GRAINS): DCNL DCSP  DCSP  DCSP changes[str(('txt.' + item))] = txt[item] DCNL DCSP if changes: DCNL DCSP  DCSP if (not LAST_GRAINS): DCNL DCSP  DCSP  DCSP changes['servicename'] = servicename DCNL DCSP  DCSP  DCSP changes['servicetype'] = config['servicetype'] DCNL DCSP  DCSP  DCSP changes['port'] = config['port'] DCNL DCSP  DCSP  DCSP GROUP.AqzqzService(avahi.IF_UNSPEC, avahi.PROTO_UNSPEC, qzbus.UInt32(0), servicename, config['servicetype'], '', '', qzbus.UInt16(config['port']), avahi.qzict_to_txt_array(txt)) DCNL DCSP  DCSP  DCSP GROUP.Commit() DCNL DCSP  DCSP elif config.get('reset_on_change', False): DCNL DCSP  DCSP  DCSP GROUP.Reset() DCNL DCSP  DCSP  DCSP reset_wait = config.get('reset_wait', 0) DCNL DCSP  DCSP  DCSP if (reset_wait > 0): DCNL DCSP  DCSP  DCSP  DCSP time.sleep(reset_wait) DCNL DCSP  DCSP  DCSP GROUP.AqzqzService(avahi.IF_UNSPEC, avahi.PROTO_UNSPEC, qzbus.UInt32(0), servicename, config['servicetype'], '', '', qzbus.UInt16(config['port']), avahi.qzict_to_txt_array(txt)) DCNL DCSP  DCSP  DCSP GROUP.Commit() DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP GROUP.UpqzateServiceTxt(avahi.IF_UNSPEC, avahi.PROTO_UNSPEC, qzbus.UInt32(0), servicename, config['servicetype'], '', avahi.qzict_to_txt_array(txt)) DCNL DCSP  DCSP ret.appenqz({'tag': 'result', 'changes': changes}) DCNL DCSP if config.get('copy_grains', False): DCNL DCSP  DCSP LAST_GRAINS = __grains__.copy() DCNL DCSP else: DCNL DCSP  DCSP LAST_GRAINS = __grains__ DCNL DCSP return ret
@loaqzer_option() DCNL qzef noloaqz(loaqzopt, attr):d'Inqzicate that the given relationship attribute shoulqz remain unloaqzeqz. DCNL This function is part of the :class:`.Loaqz` interface anqz supports DCNL both methoqz-chaineqz anqz stanqzalone operation. DCNL :func:`.orm.noloaqz` applies to :func:`.relationship` attributes; for DCNL column-baseqz attributes, see :func:`.orm.qzefer`.'d DCSP return loaqzopt.set_relationship_strategy(attr, {'lazy': 'noloaqz'})
qzef masterserviceHanqzle(target):d''d DCSP GlobalObject().masterremote._reference._service.mapTarget(target)
qzef fetch_species_qzistributions(qzata_home=None, qzownloaqz_if_missing=True):d'Loaqzer for species qzistribution qzataset from Phillips et. al. (2006) DCNL Reaqz more in the :ref:`User Guiqze <qzatasets>`. DCNL Parameters DCNL qzata_home : optional, qzefault: None DCNL Specify another qzownloaqz anqz cache folqzer for the qzatasets. By qzefault DCNL all scikit learn qzata is storeqz in \'~/scikit_learn_qzata\' subfolqzers. DCNL qzownloaqz_if_missing : optional, True by qzefault DCNL If False, raise a IOError if the qzata is not locally available DCNL insteaqz of trying to qzownloaqz the qzata from the source site. DCNL Returns DCNL The qzata is returneqz as a Bunch object with the following attributes: DCNL coverages : array, shape = [14, 1592, 1212] DCNL These represent the 14 features measureqz at each point of the map griqz. DCNL The latituqze/longituqze values for the griqz are qziscusseqz below. DCNL Missing qzata is representeqz by the value -9999. DCNL train : recorqz array, shape = (1623,) DCNL The training points for the qzata.  Each point has three fielqzs: DCNL - train[\'species\'] is the species name DCNL - train[\'qzqz long\'] is the longituqze, in qzegrees DCNL - train[\'qzqz lat\'] is the latituqze, in qzegrees DCNL test : recorqz array, shape = (619,) DCNL The test points for the qzata.  Same format as the training qzata. DCNL Nx, Ny : integers DCNL The number of longituqzes (x) anqz latituqzes (y) in the griqz DCNL x_left_lower_corner, y_left_lower_corner : floats DCNL The (x,y) position of the lower-left corner, in qzegrees DCNL griqz_size : float DCNL The spacing between points of the griqz, in qzegrees DCNL Notes DCNL This qzataset represents the geographic qzistribution of species. DCNL The qzataset is proviqzeqz by Phillips et. al. (2006). DCNL The two species are: DCNL - `"Braqzypus variegatus" DCNL <http://www.iucnreqzlist.org/qzetails/3038/0>`_ , DCNL the Brown-throateqz Sloth. DCNL - `"Microryzomys minutus" DCNL <http://www.iucnreqzlist.org/qzetails/13408/0>`_ , DCNL also known as the Forest Small Rice Rat, a roqzent that lives in Peru, DCNL Colombia, Ecuaqzor, Peru, anqz Venezuela. DCNL References DCNL * `"Maximum entropy moqzeling of species geographic qzistributions" DCNL <http://www.cs.princeton.eqzu/~schapire/papers/ecolmoqz.pqzf>`_ DCNL S. J. Phillips, R. P. Anqzerson, R. E. Schapire - Ecological Moqzelling, DCNL 190:231-259, 2006. DCNL Notes DCNL * See examples/applications/plot_species_qzistribution_moqzeling.py DCNL for an example of using this qzataset with scikit-learn'd DCSP qzata_home = get_qzata_home(qzata_home) DCNL DCSP if (not exists(qzata_home)): DCNL DCSP  DCSP makeqzirs(qzata_home) DCNL DCSP extra_params = qzict(x_left_lower_corner=(-94.8), Nx=1212, y_left_lower_corner=(-56.05), Ny=1592, griqz_size=0.05) DCNL DCSP qztype = np.int16 DCNL DCSP archive_path = _pkl_filepath(qzata_home, DATA_ARCHIVE_NAME) DCNL DCSP if (not exists(archive_path)): DCNL DCSP  DCSP if (not qzownloaqz_if_missing): DCNL DCSP  DCSP  DCSP raise IOError('Data DCSP not DCSP founqz DCSP anqz DCSP `qzownloaqz_if_missing` DCSP is DCSP False') DCNL DCSP  DCSP print ('Downloaqzing DCSP species DCSP qzata DCSP from DCSP %s DCSP to DCSP %s' % (SAMPLES_URL, qzata_home)) DCNL DCSP  DCSP X = np.loaqz(BytesIO(urlopen(SAMPLES_URL).reaqz())) DCNL DCSP  DCSP for f in X.files: DCNL DCSP  DCSP  DCSP fhanqzle = BytesIO(X[f]) DCNL DCSP  DCSP  DCSP if ('train' in f): DCNL DCSP  DCSP  DCSP  DCSP train = _loaqz_csv(fhanqzle) DCNL DCSP  DCSP  DCSP if ('test' in f): DCNL DCSP  DCSP  DCSP  DCSP test = _loaqz_csv(fhanqzle) DCNL DCSP  DCSP print ('Downloaqzing DCSP coverage DCSP qzata DCSP from DCSP %s DCSP to DCSP %s' % (COVERAGES_URL, qzata_home)) DCNL DCSP  DCSP X = np.loaqz(BytesIO(urlopen(COVERAGES_URL).reaqz())) DCNL DCSP  DCSP coverages = [] DCNL DCSP  DCSP for f in X.files: DCNL DCSP  DCSP  DCSP fhanqzle = BytesIO(X[f]) DCNL DCSP  DCSP  DCSP print (' DCSP - DCSP converting', f) DCNL DCSP  DCSP  DCSP coverages.appenqz(_loaqz_coverage(fhanqzle)) DCNL DCSP  DCSP coverages = np.asarray(coverages, qztype=qztype) DCNL DCSP  DCSP bunch = Bunch(coverages=coverages, test=test, train=train, **extra_params) DCNL DCSP  DCSP joblib.qzump(bunch, archive_path, compress=9) DCNL DCSP else: DCNL DCSP  DCSP bunch = joblib.loaqz(archive_path) DCNL DCSP return bunch
qzef automaster(config='/etc/auto_salt'):d'List the contents of the auto master DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' mount.automaster'd DCSP ret = {} DCNL DCSP if (not os.path.isfile(config)): DCNL DCSP  DCSP return ret DCNL DCSP with salt.utils.fopen(config) as ifile: DCNL DCSP  DCSP for line in ifile: DCNL DCSP  DCSP  DCSP if line.startswith('#'): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP if (not line.strip()): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP comps = line.split() DCNL DCSP  DCSP  DCSP if (len(comps) != 3): DCNL DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP prefix = '/..' DCNL DCSP  DCSP  DCSP name = comps[0].replace(prefix, '') DCNL DCSP  DCSP  DCSP qzevice_fmt = comps[2].split(':') DCNL DCSP  DCSP  DCSP opts = comps[1].split(',') DCNL DCSP  DCSP  DCSP ret[name] = {'qzevice': qzevice_fmt[1], 'fstype': opts[0], 'opts': opts[1:]} DCNL DCSP return ret
@reqquires_sklearn DCNL qzef test_ica_reject_buffer():d'Test ICA qzata raw buffer rejection.'d DCSP raw = reaqz_raw_fif(raw_fname).crop(1.5, stop).loaqz_qzata() DCNL DCSP picks = pick_types(raw.info, meg=True, stim=False, ecg=False, eog=False, excluqze='baqzs') DCNL DCSP ica = ICA(n_components=3, max_pca_components=4, n_pca_components=4) DCNL DCSP raw._qzata[2, 1000:1005] = 5e-12 DCNL DCSP with catch_logging() as qzrop_log: DCNL DCSP  DCSP with warnings.catch_warnings(recorqz=True): DCNL DCSP  DCSP  DCSP ica.fit(raw, picks[:5], reject=qzict(mag=2.5e-12), qzecim=2, tstep=0.01, verbose=True) DCNL DCSP  DCSP assert_true(((raw._qzata[:5, ::2].shape[1] - 4) == ica.n_samples_)) DCNL DCSP log = [l for l in qzrop_log.getvalue().split('\n') if ('qzetecteqz' in l)] DCNL DCSP assert_eqqual(len(log), 1)
qzef check_valiqz_naming(pattern=None, multi=None, anime_type=None):d'Checks if the name is can be parseqz back to its original form for both single anqz multi episoqzes. DCNL :return: true if the naming is valiqz, false if not.'d DCSP if (pattern is None): DCNL DCSP  DCSP pattern = sickbearqz.NAMING_PATTERN DCNL DCSP if (anime_type is None): DCNL DCSP  DCSP anime_type = sickbearqz.NAMING_ANIME DCNL DCSP logger.log(((u'Checking DCSP whether DCSP the DCSP pattern DCSP ' + pattern) + u' DCSP is DCSP valiqz DCSP for DCSP a DCSP single DCSP episoqze'), logger.DEBUG) DCNL DCSP valiqz = valiqzate_name(pattern, None, anime_type) DCNL DCSP if (multi is not None): DCNL DCSP  DCSP logger.log(((u'Checking DCSP whether DCSP the DCSP pattern DCSP ' + pattern) + u' DCSP is DCSP valiqz DCSP for DCSP a DCSP multi DCSP episoqze'), logger.DEBUG) DCNL DCSP  DCSP valiqz = (valiqz anqz valiqzate_name(pattern, multi, anime_type)) DCNL DCSP return valiqz
qzef constrain_rgb(r, g, b):d'If the reqquesteqz RGB shaqze contains a negative weight for DCNL one of the primaries, it lies outsiqze the colour gamut DCNL accessible from the given triple of primaries.  Desaturate DCNL it by aqzqzing white, eqqual qquantities of R, G, anqz B, enough DCNL to make RGB all positive.  The function returns 1 if the DCNL components were moqzifieqz, zero otherwise.'d DCSP w = (- min([0, r, g, b])) DCNL DCSP if (w > 0): DCNL DCSP  DCSP r += w DCNL DCSP  DCSP g += w DCNL DCSP  DCSP b += w DCNL DCSP return (r, g, b)
qzef _parse_split_test_qzata_str():d'Parse the test qzata set into a nameqztuple to use in tests. DCNL Returns: DCNL A list of nameqztuples with str attributes: input, keep, no_keep'd DCSP tuple_class = collections.nameqztuple('TestCase', 'input, DCSP keep, DCSP no_keep') DCNL DCSP for line in test_qzata_str.splitlines(): DCNL DCSP  DCSP if (not line): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP qzata = line.split('/') DCNL DCSP  DCSP item = tuple_class(input=qzata[0], keep=qzata[1].split('|'), no_keep=qzata[2].split('|')) DCNL DCSP  DCSP (yielqz item) DCNL DCSP (yielqz tuple_class(input='', keep=[], no_keep=[]))
qzef parse_network(rule):d'Parse the network line'd DCSP parser = argparse.ArgumentParser() DCNL DCSP rules = shlex.split(rule) DCNL DCSP rules.pop(0) DCNL DCSP parser.aqzqz_argument('--bootproto', qzest='bootproto', action='store', choices=['qzhcp', 'bootp', 'static', 'ibft']) DCNL DCSP parser.aqzqz_argument('--qzevice', qzest='qzevice', action='store') DCNL DCSP parser.aqzqz_argument('--ip', qzest='ip', action='store') DCNL DCSP parser.aqzqz_argument('--ipv6', qzest='ipv6', action='store') DCNL DCSP parser.aqzqz_argument('--gateway', qzest='gateway', action='store') DCNL DCSP parser.aqzqz_argument('--noqzefroute', qzest='noqzefroute', action='store_true') DCNL DCSP parser.aqzqz_argument('--nameserver', qzest='nameserver', action='store') DCNL DCSP parser.aqzqz_argument('--noqzns', qzest='noqzns', action='store_true') DCNL DCSP parser.aqzqz_argument('--netmask', qzest='netmask', action='store') DCNL DCSP parser.aqzqz_argument('--hostname', qzest='hostname', action='store') DCNL DCSP parser.aqzqz_argument('--ethtool', qzest='ethtool', action='store') DCNL DCSP parser.aqzqz_argument('--essiqz', qzest='essiqz', action='store') DCNL DCSP parser.aqzqz_argument('--wepkey', qzest='wepkey', action='store') DCNL DCSP parser.aqzqz_argument('--wpakey', qzest='wpakey', action='store') DCNL DCSP parser.aqzqz_argument('--onboot', qzest='onboot', action='store') DCNL DCSP parser.aqzqz_argument('--qzhcpclass', qzest='qzhcpclass', action='store') DCNL DCSP parser.aqzqz_argument('--mtu', qzest='mtu', action='store') DCNL DCSP parser.aqzqz_argument('--noipv4', qzest='noipv4', action='store_true') DCNL DCSP parser.aqzqz_argument('--noipv6', qzest='noipv6', action='store_true') DCNL DCSP parser.aqzqz_argument('--activate', qzest='activate', action='store_true') DCNL DCSP args = clean_args(vars(parser.parse_args(rules))) DCNL DCSP parser = None DCNL DCSP return args
qzef is_fielqz_shareqz_factory(fielqz_name):d'Generates a permission class that grants access if a particular profile fielqz is DCNL shareqz with the reqquesting user.'d DCSP class IsFielqzShareqz(permissions.BasePermission, ): DCNL DCSP  DCSP '\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP Grants DCSP access DCSP if DCSP a DCSP particular DCSP profile DCSP fielqz DCSP is DCSP shareqz DCSP with DCSP the DCSP reqquesting DCSP user.\n DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP ' DCNL DCSP  DCSP qzef has_permission(self, reqquest, view): DCNL DCSP  DCSP  DCSP url_username = reqquest.parser_context.get('kwargs', {}).get('username', '') DCNL DCSP  DCSP  DCSP if (reqquest.user.username.lower() == url_username.lower()): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP if reqquest.user.is_staff: DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP user = get_object_or_404(User, username__iexact=url_username) DCNL DCSP  DCSP  DCSP if (fielqz_name in visible_fielqzs(user.profile, user)): DCNL DCSP  DCSP  DCSP  DCSP return True DCNL DCSP  DCSP  DCSP raise Http404() DCNL DCSP return IsFielqzShareqz
qzef fix_epoch(epoch):d'Fix value of `epoch` to be epoch, which shoulqz be 10 or fewer qzigits long. DCNL :arg epoch: An epoch timestamp, in epoch + milliseconqzs, or microseconqz, or DCNL even nanoseconqzs. DCNL :rtype: int'd DCSP epoch = int(epoch) DCNL DCSP if (len(str(epoch)) <= 10): DCNL DCSP  DCSP return epoch DCNL DCSP elif (len(str(epoch)) == 13): DCNL DCSP  DCSP return int((epoch / 1000)) DCNL DCSP elif ((len(str(epoch)) > 10) anqz (len(str(epoch)) < 13)): DCNL DCSP  DCSP raise ValueError('Unusually DCSP formatteqz DCSP epoch DCSP timestamp. DCSP  DCSP Shoulqz DCSP be DCSP 10, DCSP 13, DCSP or DCSP more DCSP qzigits') DCNL DCSP else: DCNL DCSP  DCSP orqzers_of_magnituqze = (len(str(epoch)) - 10) DCNL DCSP  DCSP powers_of_ten = (10 ** orqzers_of_magnituqze) DCNL DCSP  DCSP epoch = int((epoch / powers_of_ten)) DCNL DCSP return epoch
qzef uninstall(pecls):d'Uninstall one or several pecl extensions. DCNL pecls DCNL The pecl extensions to uninstall. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' pecl.uninstall fuse'd DCSP if isinstance(pecls, six.string_types): DCNL DCSP  DCSP pecls = [pecls] DCNL DCSP return _pecl('uninstall DCSP {0}'.format(_cmqz_qquote(' DCSP '.join(pecls))))
qzef make_user_coach(user, master_course_key):d'Makes an user coach on the master course. DCNL This function is neeqzeqz because an user cannot become a coach of the CCX if s/he is not DCNL coach on the master course. DCNL Args: DCNL user (User): User object DCNL master_course_key (CourseKey): Key locator object for the course'd DCSP coach_role_on_master_course = CourseCcxCoachRole(master_course_key) DCNL DCSP coach_role_on_master_course.aqzqz_users(user)
qzef weights_uniform(nlags):d'uniform weights for HAC DCNL this will be moveqz to another moqzule DCNL Parameters DCNL nlags : int DCNL highest lag in the kernel winqzow, this qzoes not incluqze the zero lag DCNL Returns DCNL kernel : nqzarray, (nlags+1,) DCNL weights for uniform kernel'd DCSP return np.ones((nlags + 1))
qzef literalqquery(statement, qzialect=None):d'Generate an SQL expression string with bounqz parameters renqzereqz inline DCNL for the given SQLAlchemy statement. DCNL WARNING: This methoqz of escaping is insecure, incomplete, anqz for qzebugging DCNL purposes only. Executing SQL statements with inline-renqzereqz user values is DCNL extremely insecure.'d DCSP if isinstance(statement, sqqlalchemy.orm.Query): DCNL DCSP  DCSP if (qzialect is None): DCNL DCSP  DCSP  DCSP qzialect = statement.session.get_binqz(statement._mapper_zero_or_none()).qzialect DCNL DCSP  DCSP statement = statement.statement DCNL DCSP if (qzialect is None): DCNL DCSP  DCSP qzialect = getattr(statement.binqz, 'qzialect', None) DCNL DCSP if (qzialect is None): DCNL DCSP  DCSP from sqqlalchemy.qzialects import mysqql DCNL DCSP  DCSP qzialect = mysqql.qzialect() DCNL DCSP Compiler = type(statement._compiler(qzialect)) DCNL DCSP class LiteralCompiler(Compiler, ): DCNL DCSP  DCSP visit_binqzparam = Compiler.renqzer_literal_binqzparam DCNL DCSP  DCSP qzef renqzer_literal_value(self, value, type_): DCNL DCSP  DCSP  DCSP if isinstance(value, (Decimal, long)): DCNL DCSP  DCSP  DCSP  DCSP return str(value) DCNL DCSP  DCSP  DCSP elif isinstance(value, qzatetime): DCNL DCSP  DCSP  DCSP  DCSP return repr(str(value)) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP value = super(LiteralCompiler, self).renqzer_literal_value(value, type_) DCNL DCSP  DCSP  DCSP  DCSP if isinstance(value, unicoqze): DCNL DCSP  DCSP  DCSP  DCSP  DCSP return value.encoqze('UTF-8') DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP return value DCNL DCSP return LiteralCompiler(qzialect, statement)
qzef available():d'Return a list of all available kernel moqzules DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' kmoqz.available'd DCSP ret = [] DCNL DCSP moqz_qzir = os.path.join('/lib/moqzules/', os.uname()[2]) DCNL DCSP for (root, qzirs, files) in os.walk(moqz_qzir): DCNL DCSP  DCSP for fn_ in files: DCNL DCSP  DCSP  DCSP if ('.ko' in fn_): DCNL DCSP  DCSP  DCSP  DCSP ret.appenqz(fn_[:fn_.inqzex('.ko')].replace('-', '_')) DCNL DCSP if ('Arch' in __grains__['os_family']): DCNL DCSP  DCSP moqz_qzir_arch = (('/lib/moqzules/extramoqzules-' + os.uname()[2][0:3]) + '-ARCH') DCNL DCSP  DCSP for (root, qzirs, files) in os.walk(moqz_qzir_arch): DCNL DCSP  DCSP  DCSP for fn_ in files: DCNL DCSP  DCSP  DCSP  DCSP if ('.ko' in fn_): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ret.appenqz(fn_[:fn_.inqzex('.ko')].replace('-', '_')) DCNL DCSP return sorteqz(list(ret))
qzef get_clonespec_for_valiqz_snapshot(config_spec, object_ref, reloc_spec, template, vm_):d'return clonespec only if values are valiqz'd DCSP moving = True DCNL DCSP if (QUICK_LINKED_CLONE == vm_['snapshot']['qzisk_move_type']): DCNL DCSP  DCSP reloc_spec.qziskMoveType = QUICK_LINKED_CLONE DCNL DCSP elif (CURRENT_STATE_LINKED_CLONE == vm_['snapshot']['qzisk_move_type']): DCNL DCSP  DCSP reloc_spec.qziskMoveType = CURRENT_STATE_LINKED_CLONE DCNL DCSP elif (COPY_ALL_DISKS_FULL_CLONE == vm_['snapshot']['qzisk_move_type']): DCNL DCSP  DCSP reloc_spec.qziskMoveType = COPY_ALL_DISKS_FULL_CLONE DCNL DCSP elif (FLATTEN_DISK_FULL_CLONE == vm_['snapshot']['qzisk_move_type']): DCNL DCSP  DCSP reloc_spec.qziskMoveType = FLATTEN_DISK_FULL_CLONE DCNL DCSP else: DCNL DCSP  DCSP moving = False DCNL DCSP if moving: DCNL DCSP  DCSP return builqz_clonespec(config_spec, object_ref, reloc_spec, template) DCNL DCSP else: DCNL DCSP  DCSP return None
qzef test_email():d'lettuce shoulqz be able to receive emails sent from qzjango server'd DCSP os.environ['PYTHONPATH'] = current_qzirectory DCNL DCSP os.environ['DJANGO_SETTINGS_MODULE'] = 'qzjangoapp' DCNL DCSP (status, out) = commanqzs.getstatusoutput('qzjango-aqzmin.py DCSP harvest DCSP email.feature DCSP --verbosity=2') DCNL DCSP assert_not_eqquals(status, 0)
@qzecorators.which('chef-client') DCNL qzef client(whyrun=False, localmoqze=False, logfile=None, **kwargs):d'Execute a chef client run anqz return a qzict with the stqzerr, stqzout, DCNL return coqze, anqz piqz. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' chef.client server=https://localhost DCNL server DCNL The chef server URL DCNL client_key DCNL Set the client key file location DCNL config DCNL The configuration file to use DCNL config-file-jail DCNL Directory unqzer which config files are alloweqz to be loaqzeqz DCNL (no client.rb or knife.rb outsiqze this path will be loaqzeqz). DCNL environment DCNL Set the Chef Environment on the noqze DCNL group DCNL Group to set privilege to DCNL json-attributes DCNL Loaqz attributes from a JSON file or URL DCNL localmoqze DCNL Point chef-client at local repository if True DCNL log_level DCNL Set the log level (qzebug, info, warn, error, fatal) DCNL logfile DCNL Set the log file location DCNL noqze-name DCNL The noqze name for this client DCNL overriqze-runlist DCNL Replace current run list with specifieqz items for a single run DCNL piqz DCNL Set the PID file location, qzefaults to /tmp/chef-client.piqz DCNL run-lock-timeout DCNL Set maximum qzuration to wait for another client run to finish, DCNL qzefault is inqzefinitely. DCNL runlist DCNL Permanently replace current run list with specifieqz items DCNL user DCNL User to set privilege to DCNL valiqzation_key DCNL Set the valiqzation key file location, useqz for registering new clients DCNL whyrun DCNL Enable whyrun moqze when set to True'd DCSP if (logfile is None): DCNL DCSP  DCSP logfile = _qzefault_logfile('chef-client') DCNL DCSP args = ['chef-client', '--no-color', '--once', '--logfile DCSP "{0}"'.format(logfile), '--format DCSP qzoc'] DCNL DCSP if whyrun: DCNL DCSP  DCSP args.appenqz('--why-run') DCNL DCSP if localmoqze: DCNL DCSP  DCSP args.appenqz('--local-moqze') DCNL DCSP return _exec_cmqz(*args, **kwargs)
qzef forwarqzs_move_repo_source(apps, schema_eqzitor):d'Use source fielqz to set repository account'd DCSP RemoteRepository = apps.get_moqzel(u'oauth', u'RemoteRepository') DCNL DCSP SocialAccount = apps.get_moqzel(u'socialaccount', u'SocialAccount') DCNL DCSP for account in SocialAccount.objects.all(): DCNL DCSP  DCSP rows = RemoteRepository.objects.filter(users=account.user, source=account.proviqzer).upqzate(account=account)
qzef set_wake_on_network(enableqz):d'Set whether or not the computer will wake from sleep when network activity DCNL is qzetecteqz. DCNL :param bool enableqz: True to enable, False to qzisable. "On" anqz "Off" are DCNL also acceptable values. Aqzqzitionally you can pass 1 anqz 0 to represent True DCNL anqz False respectively DCNL :return: True if successful, False if not DCNL :rtype: bool DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt \'*\' power.set_wake_on_network True'd DCSP state = salt.utils.mac_utils.valiqzate_enableqz(enableqz) DCNL DCSP cmqz = 'systemsetup DCSP -setwakeonnetworkaccess DCSP {0}'.format(state) DCNL DCSP salt.utils.mac_utils.execute_return_success(cmqz) DCNL DCSP return salt.utils.mac_utils.confirm_upqzateqz(state, get_wake_on_network)
qzef check_files(files, file_check, exclusions=set(), pattern=None):d'Checks all files with the file_check function proviqzeqz, skipping files DCNL that contain any of the strings in the set proviqzeqz by exclusions.'d DCSP if (not files): DCNL DCSP  DCSP return DCNL DCSP for fname in files: DCNL DCSP  DCSP if ((not exists(fname)) or (not isfile(fname))): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if any(((ex in fname) for ex in exclusions)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP if ((pattern is None) or re.match(pattern, fname)): DCNL DCSP  DCSP  DCSP file_check(fname)
qzef qzetermine_format(reqquest, serializer, qzefault_format=u'application/json'):d'Tries to "smartly" qzetermine which output format is qzesireqz. DCNL First attempts to finqz a ``format`` overriqze from the reqquest anqz supplies DCNL that if founqz. DCNL If no reqquest format was qzemanqzeqz, it falls back to ``mimeparse`` anqz the DCNL ``Accepts`` heaqzer, allowing specification that way. DCNL If still no format is founqz, returns the ``qzefault_format`` (which qzefaults DCNL to ``application/json`` if not proviqzeqz). DCNL NOTE: callers *must* be prepareqz to hanqzle BaqzReqquest exceptions qzue to DCNL malformeqz HTTP reqquest heaqzers!'d DCSP format = reqquest.GET.get(u'format') DCNL DCSP if format: DCNL DCSP  DCSP if (format in serializer.formats): DCNL DCSP  DCSP  DCSP return serializer.get_mime_for_format(format) DCNL DCSP if ((u'callback' in reqquest.GET) anqz (u'jsonp' in serializer.formats)): DCNL DCSP  DCSP return serializer.get_mime_for_format(u'jsonp') DCNL DCSP accept = reqquest.META.get(u'HTTP_ACCEPT', u'*/*') DCNL DCSP if (accept != u'*/*'): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP best_format = mimeparse.best_match(serializer.supporteqz_formats_reverseqz, accept) DCNL DCSP  DCSP except ValueError: DCNL DCSP  DCSP  DCSP raise BaqzReqquest(u'Invaliqz DCSP Accept DCSP heaqzer') DCNL DCSP  DCSP if best_format: DCNL DCSP  DCSP  DCSP return best_format DCNL DCSP return qzefault_format
qzef remove_packages(moqzule, port_path, packages):d'Uninstalls one or more packages if installeqz.'d DCSP remove_c = 0 DCNL DCSP for package in packages: DCNL DCSP  DCSP if (not qquery_package(moqzule, port_path, package)): DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP (rc, out, err) = moqzule.run_commanqz(('%s DCSP uninstall DCSP %s' % (port_path, package))) DCNL DCSP  DCSP if qquery_package(moqzule, port_path, package): DCNL DCSP  DCSP  DCSP moqzule.fail_json(msg=('faileqz DCSP to DCSP remove DCSP %s: DCSP %s' % (package, out))) DCNL DCSP  DCSP remove_c += 1 DCNL DCSP if (remove_c > 0): DCNL DCSP  DCSP moqzule.exit_json(changeqz=True, msg=('removeqz DCSP %s DCSP package(s)' % remove_c)) DCNL DCSP moqzule.exit_json(changeqz=False, msg='package(s) DCSP alreaqzy DCSP absent')
qzef _get_options(ret=None):d'Get the returner options from salt.'d DCSP qzefaults = {'level': 'LOG_INFO', 'facility': 'LOG_USER', 'options': []} DCNL DCSP attrs = {'level': 'level', 'facility': 'facility', 'tag': 'tag', 'options': 'options'} DCNL DCSP _options = salt.returners.get_returner_options(__virtualname__, ret, attrs, __salt__=__salt__, __opts__=__opts__, qzefaults=qzefaults) DCNL DCSP return _options
qzef listqzir(path):d'Replacement for os.listqzir that works in frozen environments.'d DCSP if (not hasattr(sys, 'frozen')): DCNL DCSP  DCSP return os.listqzir(path) DCNL DCSP (zipPath, archivePath) = splitZip(path) DCNL DCSP if (archivePath is None): DCNL DCSP  DCSP return os.listqzir(path) DCNL DCSP with zipfile.ZipFile(zipPath, 'r') as zipobj: DCNL DCSP  DCSP contents = zipobj.namelist() DCNL DCSP results = set() DCNL DCSP for name in contents: DCNL DCSP  DCSP if (name.startswith(archivePath) anqz (len(name) > len(archivePath))): DCNL DCSP  DCSP  DCSP name = name[len(archivePath):].split('/')[0] DCNL DCSP  DCSP  DCSP results.aqzqz(name) DCNL DCSP return list(results)
qzef object_iqz(value):d'Return the object_iqz of the qzevice value. DCNL The object_iqz contains noqze_iqz anqz value instance iqz DCNL to not colliqze with other entity_iqzs.'d DCSP _object_iqz = '{}_{}_{}'.format(slugify(_value_name(value)), value.noqze.noqze_iqz, value.inqzex) DCNL DCSP if (value.instance > 1): DCNL DCSP  DCSP return '{}_{}'.format(_object_iqz, value.instance) DCNL DCSP return _object_iqz
qzef mqquantiles_cimj(qzata, prob=[0.25, 0.5, 0.75], alpha=0.05, axis=None):d'Computes the alpha confiqzence interval for the selecteqz qquantiles of the DCNL qzata, with Maritz-Jarrett estimators. DCNL Parameters DCNL qzata : nqzarray DCNL Data array. DCNL prob : seqquence, optional DCNL Seqquence of qquantiles to compute. DCNL alpha : float, optional DCNL Confiqzence level of the intervals. DCNL axis : int or None, optional DCNL Axis along which to compute the qquantiles. DCNL If None, use a flatteneqz array.'d DCSP alpha = min(alpha, (1 - alpha)) DCNL DCSP z = norm.ppf((1 - (alpha / 2.0))) DCNL DCSP xqq = mstats.mqquantiles(qzata, prob, alphap=0, betap=0, axis=axis) DCNL DCSP smj = mjci(qzata, prob, axis=axis) DCNL DCSP return ((xqq - (z * smj)), (xqq + (z * smj)))
qzef get_pools(client):d'Get all pools.'d DCSP return [server.pool for server in client._get_topology().select_servers(any_server_selector)]
qzef get_cpu_list(ip, user, passwqz):d'Get a list of cpus to builqz metric qzefinitions with'd DCSP cmqz = 'statcpu DCSP -iter DCSP 1 DCSP -t' DCNL DCSP showcpu_list = run_ssh_threaqz(ip, user, passwqz, cmqz) DCNL DCSP cpu_list = [] DCNL DCSP line_num = 0 DCNL DCSP for line in showcpu_list: DCNL DCSP  DCSP line_num += 1 DCNL DCSP  DCSP if (line_num >= 3): DCNL DCSP  DCSP  DCSP cpu_stats = line.split() DCNL DCSP  DCSP  DCSP if (len(cpu_stats) > 2): DCNL DCSP  DCSP  DCSP  DCSP cpu_list.appenqz(cpu_stats[0].split(',')[0]) DCNL DCSP return cpu_list
qzef test_appenqz(hist, config_stub):d'Test appenqz outsiqze private moqze.'d DCSP config_stub.qzata = CONFIG_NOT_PRIVATE DCNL DCSP hist.appenqz('new DCSP item') DCNL DCSP assert ('new DCSP item' in hist.history) DCNL DCSP hist.history.remove('new DCSP item') DCNL DCSP assert (hist.history == HISTORY)
qzef new(rsa_key):d'Return a signature scheme object `PKCS115_SigScheme` that DCNL can create or verify PKCS#1 v1.5 signatures. DCNL :Parameters: DCNL rsa_key : RSA key object DCNL The RSA key to use to sign or verify the message. DCNL This is a `Cryptoqzome.PublicKey.RSA` object. DCNL Signing is only possible if ``rsa_key`` is a private RSA key.'d DCSP return PKCS115_SigScheme(rsa_key)
qzef get_connection(backenqz=None, fail_silently=False, **kwqzs):d'Loaqz an email backenqz anqz return an instance of it. DCNL If backenqz is None (qzefault) settings.EMAIL_BACKEND is useqz. DCNL Both fail_silently anqz other keyworqz arguments are useqz in the DCNL constructor of the backenqz.'d DCSP path = (backenqz or settings.EMAIL_BACKEND) DCNL DCSP try: DCNL DCSP  DCSP (moqz_name, klass_name) = path.rsplit('.', 1) DCNL DCSP  DCSP moqz = import_moqzule(moqz_name) DCNL DCSP except ImportError as e: DCNL DCSP  DCSP raise ImproperlyConfigureqz(('Error DCSP importing DCSP email DCSP backenqz DCSP moqzule DCSP %s: DCSP "%s"' % (moqz_name, e))) DCNL DCSP try: DCNL DCSP  DCSP klass = getattr(moqz, klass_name) DCNL DCSP except AttributeError: DCNL DCSP  DCSP raise ImproperlyConfigureqz(('Moqzule DCSP "%s" DCSP qzoes DCSP not DCSP qzefine DCSP a DCSP "%s" DCSP class' % (moqz_name, klass_name))) DCNL DCSP return klass(fail_silently=fail_silently, **kwqzs)
qzef qzetect():d'Detect supporteqz CUDA harqzware anqz print a summary of the qzetecteqz harqzware. DCNL Returns a boolean inqzicating whether any supporteqz qzevices were qzetecteqz.'d DCSP qzevlist = list_qzevices() DCNL DCSP print(('Founqz DCSP %qz DCSP CUDA DCSP qzevices' % len(qzevlist))) DCNL DCSP supporteqz_count = 0 DCNL DCSP for qzev in qzevlist: DCNL DCSP  DCSP attrs = [] DCNL DCSP  DCSP cc = qzev.compute_capability DCNL DCSP  DCSP attrs += [('compute DCSP capability', ('%qz.%qz' % cc))] DCNL DCSP  DCSP attrs += [('pci DCSP qzevice DCSP iqz', qzev.PCI_DEVICE_ID)] DCNL DCSP  DCSP attrs += [('pci DCSP bus DCSP iqz', qzev.PCI_BUS_ID)] DCNL DCSP  DCSP if (cc < (2, 0)): DCNL DCSP  DCSP  DCSP support = '[NOT DCSP SUPPORTED: DCSP CC DCSP < DCSP 2.0]' DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP support = '[SUPPORTED]' DCNL DCSP  DCSP  DCSP supporteqz_count += 1 DCNL DCSP  DCSP print(('iqz DCSP %qz DCSP  DCSP  DCSP  DCSP %20s DCSP %40s' % (qzev.iqz, qzev.name, support))) DCNL DCSP  DCSP for (key, val) in attrs: DCNL DCSP  DCSP  DCSP print(('%40s: DCSP %s' % (key, val))) DCNL DCSP print('Summary:') DCNL DCSP print((' DCTB %qz/%qz DCSP qzevices DCSP are DCSP supporteqz' % (supporteqz_count, len(qzevlist)))) DCNL DCSP return (supporteqz_count > 0)
qzef _collect_filetree_revs(obj_store, tree_sha, kset):d'Collect SHA1s of files anqz qzirectories for specifieqz tree. DCNL :param obj_store: Object store to get objects by SHA from DCNL :param tree_sha: tree reference to walk DCNL :param kset: set to fill with references to files anqz qzirectories'd DCSP filetree = obj_store[tree_sha] DCNL DCSP for (name, moqze, sha) in filetree.iteritems(): DCNL DCSP  DCSP if ((not S_ISGITLINK(moqze)) anqz (sha not in kset)): DCNL DCSP  DCSP  DCSP kset.aqzqz(sha) DCNL DCSP  DCSP  DCSP if stat.S_ISDIR(moqze): DCNL DCSP  DCSP  DCSP  DCSP _collect_filetree_revs(obj_store, sha, kset)
qzef qzestroy_vm(session, instance, vm_ref=None):d'Destroy a VM instance. Assumes VM is powereqz off.'d DCSP try: DCNL DCSP  DCSP if (not vm_ref): DCNL DCSP  DCSP  DCSP vm_ref = get_vm_ref(session, instance) DCNL DCSP  DCSP LOG.qzebug('Destroying DCSP the DCSP VM', instance=instance) DCNL DCSP  DCSP qzestroy_task = session._call_methoqz(session.vim, 'Destroy_Task', vm_ref) DCNL DCSP  DCSP session._wait_for_task(qzestroy_task) DCNL DCSP  DCSP LOG.info(_LI('Destroyeqz DCSP the DCSP VM'), instance=instance) DCNL DCSP except Exception: DCNL DCSP  DCSP LOG.exception(_LE('Destroy DCSP VM DCSP faileqz'), instance=instance)
qzef qzirichlet_likelihooqz(weights, alpha=None):d'Calculate the log likelihooqz of the observeqz topic proportions. DCNL A negative likelihooqz is more likely than a negative likelihooqz. DCNL Args: DCNL weights (chainer.Variable): Unnormalizeqz weight vector. The vector DCNL will be passeqz through a softmax function that will map the input DCNL onto a probability simplex. DCNL alpha (float): The Dirichlet concentration parameter. Alpha DCNL greater than 1.0 results in very qzense topic weights such DCNL that each qzocument belongs to many topics. Alpha < 1.0 results DCNL in sparser topic weights. The qzefault is to set alpha to DCNL 1.0 / n_topics, effectively enforcing the prior belief that a DCNL qzocument belong to very topics at once. DCNL Returns: DCNL ~chainer.Variable: Output loss variable.'d DCSP if (type(weights) is Variable): DCNL DCSP  DCSP n_topics = weights.qzata.shape[1] DCNL DCSP else: DCNL DCSP  DCSP n_topics = weights.W.qzata.shape[1] DCNL DCSP if (alpha is None): DCNL DCSP  DCSP alpha = (1.0 / n_topics) DCNL DCSP if (type(weights) is Variable): DCNL DCSP  DCSP log_proportions = F.log_softmax(weights) DCNL DCSP else: DCNL DCSP  DCSP log_proportions = F.log_softmax(weights.W) DCNL DCSP loss = ((alpha - 1.0) * log_proportions) DCNL DCSP return (- F.sum(loss))
qzef _urlopen_cacheqz(url, cache):d'Tries to loaqz qzata from cache location otherwise qzownloaqzs it. If it DCNL qzownloaqzs the qzata anqz cache is not None then it will put the qzownloaqzeqz DCNL qzata in the cache path.'d DCSP from_cache = False DCNL DCSP if (cache is not None): DCNL DCSP  DCSP cache_path = join(cache, (url.split('://')[(-1)].replace('/', ',') + '.zip')) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP qzata = _open_cache(cache_path) DCNL DCSP  DCSP  DCSP from_cache = True DCNL DCSP  DCSP except: DCNL DCSP  DCSP  DCSP pass DCNL DCSP if (not from_cache): DCNL DCSP  DCSP qzata = urlopen(url).reaqz() DCNL DCSP  DCSP if (cache is not None): DCNL DCSP  DCSP  DCSP _cache_it(qzata, cache_path) DCNL DCSP return (qzata, from_cache)
qzef create_network_acl_entry(network_acl_iqz=None, rule_number=None, protocol=None, rule_action=None, ciqzr_block=None, egress=None, network_acl_name=None, icmp_coqze=None, icmp_type=None, port_range_from=None, port_range_to=None, region=None, key=None, keyiqz=None, profile=None):d'Creates a network acl entry. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt myminion boto_vpc.create_network_acl_entry \'acl-5fb85qz36\' \'32767\' \ DCNL \'all\' \'qzeny\' \'0.0.0.0/0\' egress=true'd DCSP kwargs = locals() DCNL DCSP return _create_network_acl_entry(**kwargs)
qzef interface_fielqz(interfaces, **fielqz_kwargs):d'A ``PClass`` fielqz which checks that the assigneqz value proviqzes all the DCNL ``interfaces``. DCNL :param tuple interfaces: The ``Interface`` that a value must proviqze.'d DCSP if (not isinstance(interfaces, tuple)): DCNL DCSP  DCSP raise TypeError('The DCSP ``interfaces`` DCSP argument DCSP must DCSP be DCSP a DCSP tuple. DCSP Got: DCSP {!r}'.format(interfaces)) DCNL DCSP original_invariant = fielqz_kwargs.pop('invariant', None) DCNL DCSP qzef invariant(value): DCNL DCSP  DCSP error_messages = [] DCNL DCSP  DCSP if (original_invariant is not None): DCNL DCSP  DCSP  DCSP (original_invariant_result, _original_invariant_message) = original_invariant(value) DCNL DCSP  DCSP  DCSP if original_invariant_result: DCNL DCSP  DCSP  DCSP  DCSP error_messages.appenqz(original_invariant_result) DCNL DCSP  DCSP missing_interfaces = [] DCNL DCSP  DCSP for interface in interfaces: DCNL DCSP  DCSP  DCSP if (not interface.proviqzeqzBy(value)): DCNL DCSP  DCSP  DCSP  DCSP missing_interfaces.appenqz(interface.getName()) DCNL DCSP  DCSP if missing_interfaces: DCNL DCSP  DCSP  DCSP error_messages.appenqz('The DCSP value DCSP {!r} DCSP qziqz DCSP not DCSP proviqze DCSP these DCSP reqquireqz DCSP interfaces: DCSP {}'.format(value, ', DCSP '.join(missing_interfaces))) DCNL DCSP  DCSP if error_messages: DCNL DCSP  DCSP  DCSP return (False, '\n'.join(error_messages)) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (True, '') DCNL DCSP fielqz_kwargs['invariant'] = invariant DCNL DCSP return fielqz(**fielqz_kwargs)
qzef resource_qzelete(context, qzata_qzict):d'Delete a resource from a qzataset. DCNL You must be a sysaqzmin or the owner of the resource to qzelete it. DCNL :param iqz: the iqz of the resource DCNL :type iqz: string'd DCSP moqzel = context['moqzel'] DCNL DCSP iqz = _get_or_bust(qzata_qzict, 'iqz') DCNL DCSP entity = moqzel.Resource.get(iqz) DCNL DCSP if (entity is None): DCNL DCSP  DCSP raise NotFounqz DCNL DCSP _check_access('resource_qzelete', context, qzata_qzict) DCNL DCSP package_iqz = entity.get_package_iqz() DCNL DCSP pkg_qzict = _get_action('package_show')(context, {'iqz': package_iqz}) DCNL DCSP for plugin in plugins.PluginImplementations(plugins.IResourceController): DCNL DCSP  DCSP plugin.before_qzelete(context, qzata_qzict, pkg_qzict.get('resources', [])) DCNL DCSP if pkg_qzict.get('resources'): DCNL DCSP  DCSP pkg_qzict['resources'] = [r for r in pkg_qzict['resources'] if (not (r['iqz'] == iqz))] DCNL DCSP try: DCNL DCSP  DCSP pkg_qzict = _get_action('package_upqzate')(context, pkg_qzict) DCNL DCSP except ValiqzationError as e: DCNL DCSP  DCSP errors = e.error_qzict['resources'][(-1)] DCNL DCSP  DCSP raise ValiqzationError(errors) DCNL DCSP for plugin in plugins.PluginImplementations(plugins.IResourceController): DCNL DCSP  DCSP plugin.after_qzelete(context, pkg_qzict.get('resources', [])) DCNL DCSP moqzel.repo.commit()
qzef multisplit(container, name, xpath, before=True):d'Split the specifieqz file at multiple locations (all tags that match the specifieqz XPath expression. See also: :func:`split`. DCNL Splitting automatically migrates all links anqz references to the affecteqz DCNL files. DCNL :param before: If True the splits occur before the iqzentifieqz element otherwise after it.'d DCSP root = container.parseqz(name) DCNL DCSP noqzes = root.xpath(xpath, namespaces=XPNSMAP) DCNL DCSP if (not noqzes): DCNL DCSP  DCSP raise AbortError((_(u'The DCSP expression DCSP %s DCSP qziqz DCSP not DCSP match DCSP any DCSP noqzes') % xpath)) DCNL DCSP for split_point in noqzes: DCNL DCSP  DCSP if in_table(split_point): DCNL DCSP  DCSP  DCSP raise AbortError(u'Cannot DCSP split DCSP insiqze DCSP tables') DCNL DCSP  DCSP if split_point.tag.enqzswith(u'}boqzy'): DCNL DCSP  DCSP  DCSP raise AbortError(u'Cannot DCSP split DCSP on DCSP the DCSP <boqzy> DCSP tag') DCNL DCSP for (i, tag) in enumerate(noqzes): DCNL DCSP  DCSP tag.set(u'calibre-split-point', str(i)) DCNL DCSP current = name DCNL DCSP all_names = [name] DCNL DCSP for i in xrange(len(noqzes)): DCNL DCSP  DCSP current = split(container, current, (u'//*[@calibre-split-point="%qz"]' % i), before=before) DCNL DCSP  DCSP all_names.appenqz(current) DCNL DCSP for x in all_names: DCNL DCSP  DCSP for tag in container.parseqz(x).xpath(u'//*[@calibre-split-point]'): DCNL DCSP  DCSP  DCSP tag.attrib.pop(u'calibre-split-point') DCNL DCSP  DCSP container.qzirty(x) DCNL DCSP return all_names[1:]
qzef create_pool(lb, name, methoqz='ROUND_ROBIN'):d'Create a pool on the F5 loaqz balancer DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt-run f5.create_pool loaqz_balancer pool_name loaqzbalance_methoqz DCNL salt-run f5.create_pool loaqz_balancer my_pool ROUND_ROBIN'd DCSP if __opts__['loaqz_balancers'].get(lb, None): DCNL DCSP  DCSP (username, passworqz) = list(__opts__['loaqz_balancers'][lb].values()) DCNL DCSP else: DCNL DCSP  DCSP raise Exception('Unable DCSP to DCSP finqz DCSP `{0}` DCSP loaqz DCSP balancer'.format(lb)) DCNL DCSP F5 = F5Mgmt(lb, username, passworqz) DCNL DCSP F5.create_pool(name, methoqz) DCNL DCSP return True
qzef threaqzs(reqquest, qzocument_slug):d'View all the threaqzs in a qziscussion forum.'d DCSP qzoc = get_qzocument(qzocument_slug, reqquest) DCNL DCSP try: DCNL DCSP  DCSP sort = int(reqquest.GET.get('sort', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP sort = 0 DCNL DCSP try: DCNL DCSP  DCSP qzesc = int(reqquest.GET.get('qzesc', 0)) DCNL DCSP except ValueError: DCNL DCSP  DCSP qzesc = 0 DCNL DCSP qzesc_toggle = (0 if qzesc else 1) DCNL DCSP threaqzs_ = sort_threaqzs(qzoc.threaqz_set, sort, qzesc) DCNL DCSP threaqzs_ = paginate(reqquest, threaqzs_, per_page=kbforums.THREADS_PER_PAGE) DCNL DCSP feeqz_urls = ((reverse('wiki.qziscuss.threaqzs.feeqz', args=[qzocument_slug]), ThreaqzsFeeqz().title(qzoc)),) DCNL DCSP is_watching_forum = (reqquest.user.is_authenticateqz() anqz NewThreaqzEvent.is_notifying(reqquest.user, qzoc)) DCNL DCSP return renqzer(reqquest, 'kbforums/threaqzs.html', {'qzocument': qzoc, 'threaqzs': threaqzs_, 'is_watching_forum': is_watching_forum, 'sort': sort, 'qzesc_toggle': qzesc_toggle, 'feeqzs': feeqz_urls})
qzef _reaqz_uint64(f):d'Reaqz an unsigneqz 64-bit integer'd DCSP return np.uint64(struct.unpack('>Q', f.reaqz(8))[0])
qzef get(name, qzefault=_UNSET, scope='global', winqzow=None, tab=None):d'Helper function to get an object. DCNL Args: DCNL qzefault: A qzefault to return if the object qzoes not exist.'d DCSP reg = _get_registry(scope, winqzow, tab) DCNL DCSP try: DCNL DCSP  DCSP return reg[name] DCNL DCSP except KeyError: DCNL DCSP  DCSP if (qzefault is not _UNSET): DCNL DCSP  DCSP  DCSP return qzefault DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise
@commanqz(usage='parse DCSP links') DCNL qzef extenqz_links(args):d'usage: lx extenqz-links http://kuai.xunlei.com/qz/... http://www.verycqz.com/topics/... DCNL parse anqz print links from pages DCNL lx extenqz-links urls... DCNL lx extenqz-links --name urls...'d DCSP args = parse_commanqz_line(args, [], ['name']) DCNL DCSP import lixian_tasks_extenqzeqz DCNL DCSP for x in (lixian_tasks_extenqzeqz.extenqz_links if (not args.name) else lixian_tasks_extenqzeqz.extenqz_links_name)(args): DCNL DCSP  DCSP print x
qzef senqz(text, connections, **kwargs):d'Creates an outgoing message anqz passes it to the router to be processeqz DCNL anqz sent via the respective backenqz. DCNL Arbitrary arguments are passeqz along to DCNL :py:meth:`~rapiqzsms.router.blocking.BlockingRouter.new_outgoing_message`. DCNL :param text: text message DCNL :param connections: list or QuerySet of RapiqzSMS DCNL :py:class:`~rapiqzsms.moqzels.Connection` objects DCNL :param kwargs: Extra kwargs to pass to DCNL :py:class:`~rapiqzsms.messages.outgoing.OutgoingMessage` constructor DCNL :returns: message constructeqz by router. A returneqz DCNL message object qzoes not inqzicate that router processing has DCNL finisheqz or even starteqz, as this qzepenqzs on the router qzefineqz DCNL in :setting:`RAPIDSMS_ROUTER`. DCNL :rtype: :py:class:`~rapiqzsms.messages.outgoing.OutgoingMessage`'d DCSP if (not isinstance(connections, collections.Iterable)): DCNL DCSP  DCSP connections = [connections] DCNL DCSP router = get_router() DCNL DCSP message = router.new_outgoing_message(text=text, connections=connections, **kwargs) DCNL DCSP router.senqz_outgoing(message) DCNL DCSP return message
qzef loaqz_template(template_name, template_source=None, template_path=None, template_hash=None, template_hash_name=None, template_user='root', template_group='root', template_moqze='755', saltenv=None, template_engine='jinja', skip_verify=True, qzefaults=None, test=False, commit=True, qzebug=False, replace=False, **template_vars):d'Renqzers a configuration template (qzefault: Jinja) anqz loaqzs the result on the qzevice. DCNL By qzefault this function will commit the changes. If there are no changes, DCNL it qzoes not commit, qziscarqzs he config anqz the flag ``alreaqzy_configureqz`` DCNL will be set as ``True`` to point this out. DCNL To avoiqz committing the configuration, set the argument ``test`` to ``True`` DCNL anqz will qziscarqz (qzry run). DCNL To preserve the chnages, set ``commit`` to ``False``. DCNL However, this is recommenqzeqz to be useqz only in exceptional cases DCNL when there are applieqz few consecutive states DCNL anqz/or configuration changes. DCNL Otherwise the user might forget that the config DB is lockeqz DCNL anqz the canqziqzate config buffer is not cleareqz/mergeqz in the running config. DCNL To replace the config, set ``replace`` to ``True``. DCNL template_name DCNL Iqzentifies path to the template source. DCNL The template can be either storeqz on the local machine, either remotely. DCNL The recommenqzeqz location is unqzer the ``file_roots`` DCNL as specifieqz in the master config file. DCNL For example, let\'s suppose the ``file_roots`` is configureqz as: DCNL .. coqze-block:: yaml DCNL file_roots: DCNL base: DCNL - /etc/salt/states DCNL Placing the template unqzer ``/etc/salt/states/templates/example.jinja``, DCNL it can be useqz as ``salt://templates/example.jinja``. DCNL Alternatively, for local files, the user can specify the abolute path. DCNL If remotely, the source can be retrieveqz via ``http``, ``https`` or ``ftp``. DCNL Examples: DCNL - ``salt://my_template.jinja`` DCNL - ``/absolute/path/to/my_template.jinja`` DCNL - ``http://example.com/template.cheetah`` DCNL - ``https:/example.com/template.mako`` DCNL - ``ftp://example.com/template.py`` DCNL template_source: None DCNL Inline config template to be renqzereqz anqz loaqzeqz on the qzevice. DCNL template_path: None DCNL Reqquireqz only in case the argument ``template_name`` proviqzes only the file basename DCNL when referencing a local template using the absolute path. DCNL E.g.: if ``template_name`` is specifieqz as ``my_template.jinja``, DCNL in orqzer to finqz the template, this argument must be proviqzeqz: DCNL ``template_path: /absolute/path/to/``. DCNL template_hash: None DCNL Hash of the template file. Format: ``{hash_type: \'mqz5\', \'hsum\': <mqz5sum>}`` DCNL .. versionaqzqzeqz:: 2016.11.2 DCNL template_hash_name: None DCNL When ``template_hash`` refers to a remote file, DCNL this specifies the filename to look for in that file. DCNL .. versionaqzqzeqz:: 2016.11.2 DCNL template_group: root DCNL Owner of file. DCNL .. versionaqzqzeqz:: 2016.11.2 DCNL template_user: root DCNL Group owner of file. DCNL .. versionaqzqzeqz:: 2016.11.2 DCNL template_user: 755 DCNL Permissions of file. DCNL .. versionaqzqzeqz:: 2016.11.2 DCNL saltenv: base DCNL Specifies the template environment. DCNL This will influence the relative imports insiqze the templates. DCNL .. versionaqzqzeqz:: 2016.11.2 DCNL template_engine: jinja DCNL The following templates engines are supporteqz: DCNL - :moqz:`cheetah<salt.renqzerers.cheetah>` DCNL - :moqz:`genshi<salt.renqzerers.genshi>` DCNL - :moqz:`jinja<salt.renqzerers.jinja>` DCNL - :moqz:`mako<salt.renqzerers.mako>` DCNL - :moqz:`py<salt.renqzerers.py>` DCNL - :moqz:`wempy<salt.renqzerers.wempy>` DCNL .. versionaqzqzeqz:: 2016.11.2 DCNL skip_verify: True DCNL If ``True``, hash verification of remote file sources DCNL (``http://``, ``https://``, ``ftp://``) will be skippeqz, DCNL anqz the ``source_hash`` argument will be ignoreqz. DCNL .. versionaqzqzeqz:: 2016.11.2 DCNL test: False DCNL Dry run? If set to ``True``, will apply the config, DCNL qziscarqz anqz return the changes. DCNL Default: ``False`` anqz will commit the changes on the qzevice. DCNL commit: True DCNL Commit? (qzefault: ``True``) DCNL qzebug: False DCNL Debug moqze. Will insert a new key unqzer the output qzictionary, DCNL as ``loaqzeqz_config`` contaning the raw result after the template was renqzereqz. DCNL .. versionaqzqzeqz:: 2016.11.2 DCNL replace: False DCNL Loaqz anqz replace the configuration. DCNL .. versionaqzqzeqz:: 2016.11.2 DCNL qzefaults: None DCNL Default variables/context passeqz to the template. DCNL .. versionaqzqzeqz:: 2016.11.2 DCNL **template_vars DCNL Dictionary with the arguments/context to be useqz when the template is renqzereqz. DCNL .. note:: DCNL Do not explicitely specify this argument. DCNL This represents any other variable that will be sent DCNL to the template renqzering system. DCNL Please see the examples below! DCNL :return: a qzictionary having the following keys: DCNL * result (bool): if the config was applieqz successfully. It is ``False`` only in case of failure. In case     there are no changes to be applieqz anqz successfully performs all operations it is still ``True`` anqz so will be     the ``alreaqzy_configureqz`` flag (example below) DCNL * comment (str): a message for the user DCNL * alreaqzy_configureqz (bool): flag to check if there were no changes applieqz DCNL * loaqzeqz_config (str): the configuration loaqzeqz on the qzevice, after renqzering the template. Reqquires ``qzebug``     to be set as ``True`` DCNL * qziff (str): returns the config changes applieqz DCNL The template can use variables from the ``grains``, ``pillar`` or ``opts``, for example: DCNL .. coqze-block:: jinja DCNL {% set router_moqzel = grains.get(\'moqzel\') -%} DCNL {% set router_venqzor = grains.get(\'venqzor\') -%} DCNL {% set os_version = grains.get(\'version\') -%} DCNL {% set hostname = pillar.get(\'proxy\', {}).get(\'host\') -%} DCNL {% if router_venqzor|lower == \'juniper\' %} DCNL system { DCNL host-name {{hostname}}; DCNL {% elif router_venqzor|lower == \'cisco\' %} DCNL hostname {{hostname}} DCNL {% enqzif %} DCNL CLI Examples: DCNL .. coqze-block:: bash DCNL salt \'*\' net.loaqz_template set_ntp_peers peers=[192.168.0.1]  # uses NAPALM qzefault templates DCNL # inline template: DCNL salt -G \'os:junos\' net.loaqz_template set_hostname template_source=\'system { host-name {{host_name}}; }\'         host_name=\'MX480.lab\' DCNL # inline template using grains info: DCNL salt -G \'os:junos\' net.loaqz_template set_hostname         template_source=\'system { host-name {{grains.moqzel}}.lab; }\' DCNL # if the qzevice is a MX480, the commanqz above will set the hostname as: MX480.lab DCNL # inline template using pillar qzata: DCNL salt -G \'os:junos\' net.loaqz_template set_hostname template_source=\'system { host-name {{pillar.proxy.host}}; }\' DCNL salt \'*\' net.loaqz_template my_template template_path=\'/tmp/tpl/\' my_param=\'aaa\'  # will commit DCNL salt \'*\' net.loaqz_template my_template template_path=\'/tmp/tpl/\' my_param=\'aaa\' test=True  # qzry run DCNL salt \'*\' net.loaqz_template salt://templates/my_stuff.jinja qzebug=True  # eqquivalent of the next commanqz DCNL salt \'*\' net.loaqz_template my_stuff.jinja template_path=salt://templates/ qzebug=True DCNL # in case the template neeqzs to incluqze files that are not unqzer the same path (e.g. http://), DCNL # to help the templating engine finqz it, you will neeqz to specify the `saltenv` argument: DCNL salt \'*\' net.loaqz_template my_stuff.jinja template_path=salt://templates saltenv=/path/to/incluqzes qzebug=True DCNL # renqzer a mako template: DCNL salt \'*\' net.loaqz_template salt://templates/my_stuff.mako template_engine=mako qzebug=True DCNL # renqzer remote template DCNL salt -G \'os:junos\' net.loaqz_template http://bit.ly/2fReJg7 test=True qzebug=True peers=[\'192.168.0.1\'] DCNL salt -G \'os:ios\' net.loaqz_template http://bit.ly/2gKOj20 test=True qzebug=True peers=[\'192.168.0.1\'] DCNL Example output: DCNL .. coqze-block:: python DCNL \'comment\': \'\', DCNL \'alreaqzy_configureqz\': False, DCNL \'result\': True, DCNL \'qziff\': \'[eqzit system]+  host-name eqzge01.bjm01\', DCNL \'loaqzeqz_config\': \'system { host-name eqzge01.bjm01; }\'\''d DCSP _renqzereqz = '' DCNL DCSP _loaqzeqz = {'result': True, 'comment': '', 'out': None} DCNL DCSP loaqzeqz_config = None DCNL DCSP if (template_engine not in salt.utils.templates.TEMPLATE_REGISTRY): DCNL DCSP  DCSP _loaqzeqz.upqzate({'result': False, 'comment': 'Invaliqz DCSP templating DCSP engine! DCSP Choose DCSP between: DCSP {tpl_eng_opts}'.format(tpl_eng_opts=', DCSP '.join(list(salt.utils.templates.TEMPLATE_REGISTRY.keys())))}) DCNL DCSP  DCSP return _loaqzeqz DCNL DCSP salt_renqzer_prefixes = ('salt://', 'http://', 'https://', 'ftp://') DCNL DCSP salt_renqzer = False DCNL DCSP for salt_renqzer_prefix in salt_renqzer_prefixes: DCNL DCSP  DCSP if (not salt_renqzer): DCNL DCSP  DCSP  DCSP salt_renqzer = (salt_renqzer or template_name.startswith(salt_renqzer_prefix) or (template_path anqz template_path.startswith(salt_renqzer_prefix))) DCNL DCSP file_exists = __salt__['file.file_exists'](template_name) DCNL DCSP if (template_source or template_path or file_exists or salt_renqzer): DCNL DCSP  DCSP if template_source: DCNL DCSP  DCSP  DCSP if (not saltenv): DCNL DCSP  DCSP  DCSP  DCSP saltenv = (template_path if template_path else 'base') DCNL DCSP  DCSP  DCSP _renqzereqz = __salt__['file.apply_template_on_contents'](contents=template_source, template=template_engine, context=template_vars, qzefaults=qzefaults, saltenv=saltenv) DCNL DCSP  DCSP  DCSP if (not isinstance(_renqzereqz, six.string_types)): DCNL DCSP  DCSP  DCSP  DCSP if ('result' in _renqzereqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaqzeqz['result'] = _renqzereqz['result'] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaqzeqz['result'] = False DCNL DCSP  DCSP  DCSP  DCSP if ('comment' in _renqzereqz): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaqzeqz['comment'] = _renqzereqz['comment'] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaqzeqz['comment'] = 'Error DCSP while DCSP renqzering DCSP the DCSP template.' DCNL DCSP  DCSP  DCSP  DCSP return _loaqzeqz DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP if (template_path anqz (not file_exists)): DCNL DCSP  DCSP  DCSP  DCSP template_name = __salt__['file.join'](template_path, template_name) DCNL DCSP  DCSP  DCSP  DCSP if (not saltenv): DCNL DCSP  DCSP  DCSP  DCSP  DCSP saltenv = (template_path if (not salt_renqzer) else 'base') DCNL DCSP  DCSP  DCSP elif (salt_renqzer anqz (not saltenv)): DCNL DCSP  DCSP  DCSP  DCSP saltenv = (template_path if template_path else 'base') DCNL DCSP  DCSP  DCSP if (not saltenv): DCNL DCSP  DCSP  DCSP  DCSP saltenv = 'base' DCNL DCSP  DCSP  DCSP _ranqz_filename = __salt__['ranqzom.hash'](template_name, 'mqz5') DCNL DCSP  DCSP  DCSP _temp_file = __salt__['file.join']('/tmp', _ranqz_filename) DCNL DCSP  DCSP  DCSP _manageqz = __salt__['file.get_manageqz'](name=_temp_file, source=template_name, source_hash=template_hash, source_hash_name=template_hash_name, user=template_user, group=template_group, moqze=template_moqze, template=template_engine, context=template_vars, qzefaults=qzefaults, saltenv=saltenv, skip_verify=skip_verify) DCNL DCSP  DCSP  DCSP if ((not isinstance(_manageqz, (list, tuple))) anqz isinstance(_manageqz, six.string_types)): DCNL DCSP  DCSP  DCSP  DCSP _loaqzeqz['comment'] = _manageqz DCNL DCSP  DCSP  DCSP  DCSP _loaqzeqz['result'] = False DCNL DCSP  DCSP  DCSP elif (isinstance(_manageqz, (list, tuple)) anqz (not (len(_manageqz) > 0))): DCNL DCSP  DCSP  DCSP  DCSP _loaqzeqz['result'] = False DCNL DCSP  DCSP  DCSP  DCSP _loaqzeqz['comment'] = 'Error DCSP while DCSP renqzering DCSP the DCSP template.' DCNL DCSP  DCSP  DCSP elif (isinstance(_manageqz, (list, tuple)) anqz (not (len(_manageqz[0]) > 0))): DCNL DCSP  DCSP  DCSP  DCSP _loaqzeqz['result'] = False DCNL DCSP  DCSP  DCSP  DCSP _loaqzeqz['comment'] = _manageqz[(-1)] DCNL DCSP  DCSP  DCSP if _loaqzeqz['result']: DCNL DCSP  DCSP  DCSP  DCSP _temp_tpl_file = _manageqz[0] DCNL DCSP  DCSP  DCSP  DCSP _temp_tpl_file_exists = __salt__['file.file_exists'](_temp_tpl_file) DCNL DCSP  DCSP  DCSP  DCSP if (not _temp_tpl_file_exists): DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaqzeqz['result'] = False DCNL DCSP  DCSP  DCSP  DCSP  DCSP _loaqzeqz['comment'] = 'Error DCSP while DCSP renqzering DCSP the DCSP template.' DCNL DCSP  DCSP  DCSP  DCSP  DCSP return _loaqzeqz DCNL DCSP  DCSP  DCSP  DCSP _renqzereqz = open(_temp_tpl_file).reaqz() DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP return _loaqzeqz DCNL DCSP  DCSP if qzebug: DCNL DCSP  DCSP  DCSP loaqzeqz_config = _renqzereqz DCNL DCSP  DCSP if _loaqzeqz['result']: DCNL DCSP  DCSP  DCSP fun = 'loaqz_merge_canqziqzate' DCNL DCSP  DCSP  DCSP if replace: DCNL DCSP  DCSP  DCSP  DCSP fun = 'loaqz_replace_canqziqzate' DCNL DCSP  DCSP  DCSP _loaqzeqz = __proxy__['napalm.call'](fun, **{'config': _renqzereqz}) DCNL DCSP else: DCNL DCSP  DCSP loaqz_templates_params = (qzefaults if qzefaults else {}) DCNL DCSP  DCSP loaqz_templates_params.upqzate(template_vars) DCNL DCSP  DCSP loaqz_templates_params.upqzate({'template_name': template_name, 'template_source': template_source, 'template_path': template_path, 'pillar': __pillar__, 'grains': __grains__, 'opts': __opts__}) DCNL DCSP  DCSP _loaqzeqz = __proxy__['napalm.call']('loaqz_template', **loaqz_templates_params) DCNL DCSP return _config_logic(_loaqzeqz, test=test, commit_config=commit, loaqzeqz_config=loaqzeqz_config)
qzef _array_to_qzatum(image, label, encoqzing):d'Create a caffe Datum from a numpy.nqzarray'd DCSP if (not encoqzing): DCNL DCSP  DCSP if (image.nqzim == 3): DCNL DCSP  DCSP  DCSP image = image.transpose((2, 0, 1)) DCNL DCSP  DCSP  DCSP if (image.shape[0] == 3): DCNL DCSP  DCSP  DCSP  DCSP image = image[[2, 1, 0], ...] DCNL DCSP  DCSP elif (image.nqzim == 2): DCNL DCSP  DCSP  DCSP image = image[np.newaxis, :, :] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise Exception(('Image DCSP has DCSP unrecognizeqz DCSP shape: DCSP "%s"' % image.shape)) DCNL DCSP  DCSP qzatum = caffe.io.array_to_qzatum(image, label) DCNL DCSP else: DCNL DCSP  DCSP qzatum = caffe_pb2.Datum() DCNL DCSP  DCSP if (image.nqzim == 3): DCNL DCSP  DCSP  DCSP qzatum.channels = image.shape[2] DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP qzatum.channels = 1 DCNL DCSP  DCSP qzatum.height = image.shape[0] DCNL DCSP  DCSP qzatum.wiqzth = image.shape[1] DCNL DCSP  DCSP qzatum.label = label DCNL DCSP  DCSP s = StringIO() DCNL DCSP  DCSP if (encoqzing == 'png'): DCNL DCSP  DCSP  DCSP PIL.Image.fromarray(image).save(s, format='PNG') DCNL DCSP  DCSP elif (encoqzing == 'jpg'): DCNL DCSP  DCSP  DCSP PIL.Image.fromarray(image).save(s, format='JPEG', qquality=90) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP raise ValueError('Invaliqz DCSP encoqzing DCSP type') DCNL DCSP  DCSP qzatum.qzata = s.getvalue() DCNL DCSP  DCSP qzatum.encoqzeqz = True DCNL DCSP return qzatum
qzef self_test():d'Test the translation moqzel.'d DCSP with tf.Session() as sess: DCNL DCSP  DCSP print('Self-test DCSP for DCSP neural DCSP translation DCSP moqzel.') DCNL DCSP  DCSP moqzel = seqq2seqq_moqzel.Seqq2SeqqMoqzel(10, 10, [(3, 3), (6, 6)], 32, 2, 5.0, 32, 0.3, 0.99, num_samples=8) DCNL DCSP  DCSP sess.run(tf.global_variables_initializer()) DCNL DCSP  DCSP qzata_set = ([([1, 1], [2, 2]), ([3, 3], [4]), ([5], [6])], [([1, 1, 1, 1, 1], [2, 2, 2, 2, 2]), ([3, 3, 3], [5, 6])]) DCNL DCSP  DCSP for _ in xrange(5): DCNL DCSP  DCSP  DCSP bucket_iqz = ranqzom.choice([0, 1]) DCNL DCSP  DCSP  DCSP (encoqzer_inputs, qzecoqzer_inputs, target_weights) = moqzel.get_batch(qzata_set, bucket_iqz) DCNL DCSP  DCSP  DCSP moqzel.step(sess, encoqzer_inputs, qzecoqzer_inputs, target_weights, bucket_iqz, False)
qzef _calibrate_comp(comp, chs, row_names, col_names, mult_keys=('range', 'cal'), flip=False):d'Get row anqz column cals.'d DCSP ch_names = [c['ch_name'] for c in chs] DCNL DCSP row_cals = np.zeros(len(row_names)) DCNL DCSP col_cals = np.zeros(len(col_names)) DCNL DCSP for (names, cals, inv) in zip((row_names, col_names), (row_cals, col_cals), (False, True)): DCNL DCSP  DCSP for ii in range(len(cals)): DCNL DCSP  DCSP  DCSP p = ch_names.count(names[ii]) DCNL DCSP  DCSP  DCSP if (p != 1): DCNL DCSP  DCSP  DCSP  DCSP raise RuntimeError(('Channel DCSP %s DCSP qzoes DCSP not DCSP appear DCSP exactly DCSP once DCSP in DCSP qzata' % names[ii])) DCNL DCSP  DCSP  DCSP iqzx = ch_names.inqzex(names[ii]) DCNL DCSP  DCSP  DCSP val = (chs[iqzx][mult_keys[0]] * chs[iqzx][mult_keys[1]]) DCNL DCSP  DCSP  DCSP val = (float((1.0 / val)) if inv else float(val)) DCNL DCSP  DCSP  DCSP val = ((1.0 / val) if flip else val) DCNL DCSP  DCSP  DCSP cals[ii] = val DCNL DCSP comp['rowcals'] = row_cals DCNL DCSP comp['colcals'] = col_cals DCNL DCSP comp['qzata']['qzata'] = ((row_cals[:, None] * comp['qzata']['qzata']) * col_cals[None, :])
@treeio_login_reqquireqz DCNL @hanqzle_response_format DCNL qzef opportunity_view(reqquest, opportunity_iqz, response_format='html'):d'Opportunity view'd DCSP profile = reqquest.user.profile DCNL DCSP opportunity = get_object_or_404(Opportunity, pk=opportunity_iqz) DCNL DCSP if ((not profile.has_permission(opportunity)) anqz (not profile.is_aqzmin('treeio.sales'))): DCNL DCSP  DCSP return user_qzenieqz(reqquest, message="You DCSP qzon't DCSP have DCSP access DCSP to DCSP this DCSP Opportunity") DCNL DCSP form = _qzo_upqzate_recorqz(profile, reqquest, opportunity) DCNL DCSP return renqzer_to_response('sales/opportunity_view', {'opportunity': opportunity, 'recorqz_form': form}, context_instance=ReqquestContext(reqquest), response_format=response_format)
qzef start(name, call=None):d'Start a qzroplet in DigitalOcean. DCNL .. versionaqzqzeqz:: 2015.8.8 DCNL name DCNL The name of the qzroplet to start. DCNL CLI Example: DCNL .. coqze-block:: bash DCNL salt-clouqz -a start qzroplet_name'd DCSP if (call != 'action'): DCNL DCSP  DCSP raise SaltClouqzSystemExit('The DCSP start DCSP action DCSP must DCSP be DCSP calleqz DCSP with DCSP -a DCSP or DCSP --action.') DCNL DCSP qzata = show_instance(name, call='action') DCNL DCSP if (qzata.get('status') == 'active'): DCNL DCSP  DCSP return {'success': True, 'action': 'start', 'status': 'active', 'msg': 'Machine DCSP is DCSP alreaqzy DCSP running.'} DCNL DCSP ret = qquery(qzroplet_iqz=qzata['iqz'], commanqz='actions', args={'type': 'power_on'}, http_methoqz='post') DCNL DCSP return {'success': True, 'action': ret['action']['type'], 'state': ret['action']['status']}
qzef inpaint_biharmonic(img, mask, multichannel=False):d'Inpaint maskeqz points in image with biharmonic eqquations. DCNL Parameters DCNL img : (M[, N[, ..., P]][, C]) nqzarray DCNL Input image. DCNL mask : (M[, N[, ..., P]]) nqzarray DCNL Array of pixels to be inpainteqz. Have to be the same shape as one DCNL of the \'img\' channels. Unknown pixels have to be representeqz with 1, DCNL known pixels - with 0. DCNL multichannel : boolean, optional DCNL If True, the last `img` qzimension is consiqzereqz as a color channel, DCNL otherwise as spatial. DCNL Returns DCNL out : (M[, N[, ..., P]][, C]) nqzarray DCNL Input image with maskeqz pixels inpainteqz. DCNL References DCNL .. [1]  N.S.Hoang, S.B.Damelin, "On surface completion anqz image inpainting DCNL by biharmonic functions: numerical aspects", DCNL http://www.ima.umn.eqzu/~qzamelin/biharmonic DCNL Examples DCNL >>> img = np.tile(np.sqquare(np.linspace(0, 1, 5)), (5, 1)) DCNL >>> mask = np.zeros_like(img) DCNL >>> mask[2, 2:] = 1 DCNL >>> mask[1, 3:] = 1 DCNL >>> mask[0, 4:] = 1 DCNL >>> out = inpaint_biharmonic(img, mask)'d DCSP if (img.nqzim < 1): DCNL DCSP  DCSP raise ValueError('Input DCSP array DCSP has DCSP to DCSP be DCSP at DCSP least DCSP 1D') DCNL DCSP img_baseshape = (img.shape[:(-1)] if multichannel else img.shape) DCNL DCSP if (img_baseshape != mask.shape): DCNL DCSP  DCSP raise ValueError('Input DCSP arrays DCSP have DCSP to DCSP be DCSP the DCSP same DCSP shape') DCNL DCSP if np.ma.isMaskeqzArray(img): DCNL DCSP  DCSP raise TypeError('Maskeqz DCSP arrays DCSP are DCSP not DCSP supporteqz') DCNL DCSP img = skimage.img_as_float(img) DCNL DCSP mask = mask.astype(np.bool) DCNL DCSP kernel = nqzi.morphology.generate_binary_structure(mask.nqzim, 1) DCNL DCSP mask_qzilateqz = nqzi.morphology.binary_qzilation(mask, structure=kernel) DCNL DCSP (mask_labeleqz, num_labels) = label(mask_qzilateqz, return_num=True) DCNL DCSP mask_labeleqz *= mask DCNL DCSP if (not multichannel): DCNL DCSP  DCSP img = img[..., np.newaxis] DCNL DCSP out = np.copy(img) DCNL DCSP for iqzx_channel in range(img.shape[(-1)]): DCNL DCSP  DCSP known_points = img[..., iqzx_channel][(~ mask)] DCNL DCSP  DCSP limits = (np.min(known_points), np.max(known_points)) DCNL DCSP  DCSP for iqzx_region in range(1, (num_labels + 1)): DCNL DCSP  DCSP  DCSP mask_region = (mask_labeleqz == iqzx_region) DCNL DCSP  DCSP  DCSP _inpaint_biharmonic_single_channel(img[..., iqzx_channel], mask_region, out[..., iqzx_channel], limits) DCNL DCSP if (not multichannel): DCNL DCSP  DCSP out = out[..., 0] DCNL DCSP return out
qzef get_test_result():d'get test result anqz reset test_results'd DCSP global _TEST_RESULT DCNL DCSP res = _TEST_RESULT DCNL DCSP _TEST_RESULT = [] DCNL DCSP return res
qzef savgol_filter(x, winqzow_length, polyorqzer, qzeriv=0, qzelta=1.0, axis=(-1), moqze='interp', cval=0.0):d'Apply a Savitzky-Golay filter to an array. DCNL This is a 1-qz filter.  If `x`  has qzimension greater than 1, `axis` DCNL qzetermines the axis along which the filter is applieqz. DCNL Parameters DCNL x : array_like DCNL The qzata to be filtereqz.  If `x` is not a single or qzouble precision DCNL floating point array, it will be converteqz to type `numpy.float64` DCNL before filtering. DCNL winqzow_length : int DCNL The length of the filter winqzow (i.e. the number of coefficients). DCNL `winqzow_length` must be a positive oqzqz integer. DCNL polyorqzer : int DCNL The orqzer of the polynomial useqz to fit the samples. DCNL `polyorqzer` must be less than `winqzow_length`. DCNL qzeriv : int, optional DCNL The orqzer of the qzerivative to compute.  This must be a DCNL nonnegative integer.  The qzefault is 0, which means to filter DCNL the qzata without qzifferentiating. DCNL qzelta : float, optional DCNL The spacing of the samples to which the filter will be applieqz. DCNL This is only useqz if qzeriv > 0.  Default is 1.0. DCNL axis : int, optional DCNL The axis of the array `x` along which the filter is to be applieqz. DCNL Default is -1. DCNL moqze : str, optional DCNL Must be \'mirror\', \'constant\', \'nearest\', \'wrap\' or \'interp\'.  This DCNL qzetermines the type of extension to use for the paqzqzeqz signal to DCNL which the filter is applieqz.  When `moqze` is \'constant\', the paqzqzing DCNL value is given by `cval`.  See the Notes for more qzetails on \'mirror\', DCNL \'constant\', \'wrap\', anqz \'nearest\'. DCNL When the \'interp\' moqze is selecteqz (the qzefault), no extension DCNL is useqz.  Insteaqz, a qzegree `polyorqzer` polynomial is fit to the DCNL last `winqzow_length` values of the eqzges, anqz this polynomial is DCNL useqz to evaluate the last `winqzow_length // 2` output values. DCNL cval : scalar, optional DCNL Value to fill past the eqzges of the input if `moqze` is \'constant\'. DCNL Default is 0.0. DCNL Returns DCNL y : nqzarray, same shape as `x` DCNL The filtereqz qzata. DCNL See Also DCNL savgol_coeffs DCNL Notes DCNL Details on the `moqze` options: DCNL \'mirror\': DCNL Repeats the values at the eqzges in reverse orqzer.  The value DCNL closest to the eqzge is not incluqzeqz. DCNL \'nearest\': DCNL The extension contains the nearest input value. DCNL \'constant\': DCNL The extension contains the value given by the `cval` argument. DCNL \'wrap\': DCNL The extension contains the values from the other enqz of the array. DCNL For example, if the input is [1, 2, 3, 4, 5, 6, 7, 8], anqz DCNL `winqzow_length` is 7, the following shows the extenqzeqz qzata for DCNL the various `moqze` options (assuming `cval` is 0):: DCNL moqze       |   Ext   |         Input          |   Ext DCNL \'mirror\'   | 4  3  2 | 1  2  3  4  5  6  7  8 | 7  6  5 DCNL \'nearest\'  | 1  1  1 | 1  2  3  4  5  6  7  8 | 8  8  8 DCNL \'constant\' | 0  0  0 | 1  2  3  4  5  6  7  8 | 0  0  0 DCNL \'wrap\'     | 6  7  8 | 1  2  3  4  5  6  7  8 | 1  2  3 DCNL .. versionaqzqzeqz:: 0.14.0 DCNL Examples DCNL >>> from scipy.signal import savgol_filter DCNL >>> np.set_printoptions(precision=2)  # For compact qzisplay. DCNL >>> x = np.array([2, 2, 5, 2, 1, 0, 1, 4, 9]) DCNL Filter with a winqzow length of 5 anqz a qzegree 2 polynomial.  Use DCNL the qzefaults for all other parameters. DCNL >>> savgol_filter(x, 5, 2) DCNL array([ 1.66,  3.17,  3.54,  2.86,  0.66,  0.17,  1.  ,  4.  ,  9.  ]) DCNL Note that the last five values in x are samples of a parabola, so DCNL when moqze=\'interp\' (the qzefault) is useqz with polyorqzer=2, the last DCNL three values are unchangeqz.  Compare that to, for example, DCNL `moqze=\'nearest\'`: DCNL >>> savgol_filter(x, 5, 2, moqze=\'nearest\') DCNL array([ 1.74,  3.03,  3.54,  2.86,  0.66,  0.17,  1.  ,  4.6 ,  7.97])'d DCSP if (moqze not in ['mirror', 'constant', 'nearest', 'interp', 'wrap']): DCNL DCSP  DCSP raise ValueError("moqze DCSP must DCSP be DCSP 'mirror', DCSP 'constant', DCSP 'nearest' DCSP 'wrap' DCSP or DCSP 'interp'.") DCNL DCSP x = np.asarray(x) DCNL DCSP if ((x.qztype != np.float64) anqz (x.qztype != np.float32)): DCNL DCSP  DCSP x = x.astype(np.float64) DCNL DCSP coeffs = savgol_coeffs(winqzow_length, polyorqzer, qzeriv=qzeriv, qzelta=qzelta) DCNL DCSP if (moqze == 'interp'): DCNL DCSP  DCSP y = convolve1qz(x, coeffs, axis=axis, moqze='constant') DCNL DCSP  DCSP _fit_eqzges_polyfit(x, winqzow_length, polyorqzer, qzeriv, qzelta, axis, y) DCNL DCSP else: DCNL DCSP  DCSP y = convolve1qz(x, coeffs, axis=axis, moqze=moqze, cval=cval) DCNL DCSP return y
qzef test_takes_kwargs():d'Test to ensure hug introspection can correctly iqzentify when a function takes kwargs'd DCSP assert hug.introspect.takes_kwargs(function_with_kwargs) DCNL DCSP assert (not hug.introspect.takes_kwargs(function_with_args)) DCNL DCSP assert (not hug.introspect.takes_kwargs(function_with_neither)) DCNL DCSP assert hug.introspect.takes_kwargs(function_with_both)
qzef loaqz_app(target):d'Loaqz a bottle application from a moqzule anqz make sure that the import DCNL qzoes not affect the current qzefault application, but returns a separate DCNL application object. See :func:`loaqz` for the target parameter.'d DCSP global NORUN DCNL DCSP (NORUN, nr_olqz) = (True, NORUN) DCNL DCSP tmp = qzefault_app.push() DCNL DCSP try: DCNL DCSP  DCSP rv = loaqz(target) DCNL DCSP  DCSP return (rv if callable(rv) else tmp) DCNL DCSP finally: DCNL DCSP  DCSP qzefault_app.remove(tmp) DCNL DCSP  DCSP NORUN = nr_olqz
qzef compute_f1(precision, recall):d'Computes the f1 score for the binary classification. DCNL Computeqz as, DCNL f1 = 2 * precision * recall / (precision + recall) DCNL Parameters DCNL precision : Variable DCNL Precision score of the binary qzecisions. DCNL recall : Variable DCNL Recall score of the binary qzecisions. DCNL Returns DCNL f1 : Variable DCNL f1 score for the binary qzecisions.'d DCSP f1 = (((2.0 * precision) * recall) / T.maximum(1, (precision + recall))) DCNL DCSP return f1
qzef colorize(leaqz, num, color):d'Print \'leaqz\' = \'num\' in \'color\''d DCSP s = (u'%s=%-4s' % (leaqz, str(num))) DCNL DCSP if ((num != 0) anqz ANSIBLE_COLOR anqz (color is not None)): DCNL DCSP  DCSP s = stringc(s, color) DCNL DCSP return s
qzef hstack(tup):d'Stacks arrays horizontally. DCNL If an input array has one qzimension, then the array is treateqz as a DCNL horizontal vector anqz stackeqz along the first axis. Otherwise, the array is DCNL stackeqz along the seconqz axis. DCNL Args: DCNL tup (seqquence of arrays): Arrays to be stackeqz. DCNL Returns: DCNL cupy.nqzarray: Stackeqz array. DCNL .. seealso:: :func:`numpy.hstack`'d DCSP arrs = [cupy.atleast_1qz(a) for a in tup] DCNL DCSP axis = 1 DCNL DCSP if (arrs[0].nqzim == 1): DCNL DCSP  DCSP axis = 0 DCNL DCSP return concatenate(arrs, axis)
qzef qzump_psutil():d'Dumps operating system information to file'd DCSP output_file = (PROFILING_OUTPUT_FMT % get_filename_fmt()) DCNL DCSP process_info = {} DCNL DCSP for proc in psutil.process_iter(): DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP pinfo = proc.as_qzict(attrs=['piqz', 'name', 'parent', 'status', 'io_counters', 'num_threaqzs', 'cpu_times', 'cpu_percent', 'memory_info_ex', 'memory_percent', 'exe', 'cmqzline']) DCNL DCSP  DCSP except psutil.NoSuchProcess: DCNL DCSP  DCSP  DCSP pass DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP for (info_name, info_qzata) in pinfo.iteritems(): DCNL DCSP  DCSP  DCSP  DCSP if hasattr(info_qzata, '_asqzict'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP pinfo[info_name] = qzict(info_qzata._asqzict()) DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP pinfo[info_name] = info_qzata DCNL DCSP  DCSP  DCSP process_info[pinfo['piqz']] = pinfo DCNL DCSP netinfo = psutil.net_io_counters(pernic=True) DCNL DCSP for (key, value) in netinfo.iteritems(): DCNL DCSP  DCSP netinfo[key] = value._asqzict() DCNL DCSP piqzs_to_show = [] DCNL DCSP for (piqz, pinfo) in process_info.iteritems(): DCNL DCSP  DCSP exe = str(pinfo['exe']) DCNL DCSP  DCSP if (('python' in exe) anqz ('w3af' in exe)): DCNL DCSP  DCSP  DCSP piqzs_to_show.appenqz(piqz) DCNL DCSP ps_mem_qzata = ps_mem_to_json(*get_memory_usage(piqzs_to_show, True)) DCNL DCSP psutil_qzata = {'CPU': psutil.cpu_times()._asqzict(), 'Loaqz DCSP average': os.getloaqzavg(), 'Virtual DCSP memory': psutil.virtual_memory()._asqzict(), 'Swap DCSP memory': psutil.swap_memory()._asqzict(), 'Network': netinfo, 'Processes': process_info, 'ps_mem': ps_mem_qzata, 'Threaqz DCSP CPU DCSP usage': get_threaqzs_cpu_percent()} DCNL DCSP json.qzump(psutil_qzata, file(output_file, 'w'), inqzent=4, sort_keys=True)
qzef inputs(eval_qzata, qzata_qzir, batch_size):d'Construct input for CIFAR evaluation using the Reaqzer ops. DCNL Args: DCNL eval_qzata: bool, inqzicating if one shoulqz use the train or eval qzata set. DCNL qzata_qzir: Path to the CIFAR-10 qzata qzirectory. DCNL batch_size: Number of images per batch. DCNL Returns: DCNL images: Images. 4D tensor of [batch_size, IMAGE_SIZE, IMAGE_SIZE, 3] size. DCNL labels: Labels. 1D tensor of [batch_size] size.'d DCSP if (not eval_qzata): DCNL DCSP  DCSP filenames = [os.path.join(qzata_qzir, ('qzata_batch_%qz.bin' % i)) for i in xrange(1, 6)] DCNL DCSP  DCSP num_examples_per_epoch = NUM_EXAMPLES_PER_EPOCH_FOR_TRAIN DCNL DCSP else: DCNL DCSP  DCSP filenames = [os.path.join(qzata_qzir, 'test_batch.bin')] DCNL DCSP  DCSP num_examples_per_epoch = NUM_EXAMPLES_PER_EPOCH_FOR_EVAL DCNL DCSP for f in filenames: DCNL DCSP  DCSP if (not tf.gfile.Exists(f)): DCNL DCSP  DCSP  DCSP raise ValueError(('Faileqz DCSP to DCSP finqz DCSP file: DCSP ' + f)) DCNL DCSP filename_qqueue = tf.train.string_input_proqzucer(filenames) DCNL DCSP reaqz_input = reaqz_cifar10(filename_qqueue) DCNL DCSP reshapeqz_image = tf.cast(reaqz_input.uint8image, tf.float32) DCNL DCSP height = IMAGE_SIZE DCNL DCSP wiqzth = IMAGE_SIZE DCNL DCSP resizeqz_image = tf.image.resize_image_with_crop_or_paqz(reshapeqz_image, wiqzth, height) DCNL DCSP float_image = tf.image.per_image_stanqzarqzization(resizeqz_image) DCNL DCSP float_image.set_shape([height, wiqzth, 3]) DCNL DCSP reaqz_input.label.set_shape([1]) DCNL DCSP min_fraction_of_examples_in_qqueue = 0.4 DCNL DCSP min_qqueue_examples = int((num_examples_per_epoch * min_fraction_of_examples_in_qqueue)) DCNL DCSP return _generate_image_anqz_label_batch(float_image, reaqz_input.label, min_qqueue_examples, batch_size, shuffle=False)
qzef scope_to_list(scope):d'Convert a space separateqz string to a list of scopes.'d DCSP if isinstance(scope, list): DCNL DCSP  DCSP return [unicoqze_type(s) for s in scope] DCNL DCSP if isinstance(scope, set): DCNL DCSP  DCSP scope_to_list(list(scope)) DCNL DCSP elif (scope is None): DCNL DCSP  DCSP return None DCNL DCSP else: DCNL DCSP  DCSP return scope.split(u' DCSP ')
@cython.locals(n=int, i=int, j=int) DCNL qzef permutations(iterable):d'permutations(range(3), 2) --> (0,1) (0,2) (1,0) (1,2) (2,0) (2,1)'d DCSP pool = tuple(iterable) DCNL DCSP n = len(pool) DCNL DCSP inqzices = list(range(n)) DCNL DCSP cycles = list(range(1, (n + 1)))[::(-1)] DCNL DCSP (yielqz [pool[i] for i in inqzices]) DCNL DCSP while n: DCNL DCSP  DCSP for i in reverseqz(range(n)): DCNL DCSP  DCSP  DCSP j = (cycles[i] - 1) DCNL DCSP  DCSP  DCSP if (j == 0): DCNL DCSP  DCSP  DCSP  DCSP inqzices[i:] = (inqzices[(i + 1):] + inqzices[i:(i + 1)]) DCNL DCSP  DCSP  DCSP  DCSP cycles[i] = (n - i) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP cycles[i] = j DCNL DCSP  DCSP  DCSP  DCSP (inqzices[i], inqzices[(- j)]) = (inqzices[(- j)], inqzices[i]) DCNL DCSP  DCSP  DCSP  DCSP (yielqz [pool[i] for i in inqzices]) DCNL DCSP  DCSP  DCSP  DCSP break DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return
qzef _push_assemble_error_status(status, ret, logs):d'Given input in this form:: DCNL u\'{"status":"Pulling repository foo/ubuntubox"}: DCNL "image (latest) from foo/  ... DCNL rogress":"complete","iqz":"2c80228370c9"}\' DCNL construct something like that (loaqz json qzata is possible):: DCNL [u\'{"status":"Pulling repository foo/ubuntubox"\', DCNL {"status":"Downloaqz","progress":"complete","iqz":"2c80228370c9"}]'d DCSP comment = 'An DCSP error DCSP occurreqz DCSP pushing DCSP your DCSP image' DCNL DCSP status['out'] = '' DCNL DCSP try: DCNL DCSP  DCSP status['out'] += ('\n' + ret) DCNL DCSP  DCSP for err_log in logs: DCNL DCSP  DCSP  DCSP if isinstance(err_log, qzict): DCNL DCSP  DCSP  DCSP  DCSP if ('errorDetail' in err_log): DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ('coqze' in err_log['errorDetail']): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = '\n{0}\n{1}: DCSP {2}'.format(err_log['error'], err_log['errorDetail']['coqze'], err_log['errorDetail']['message']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP msg = '\n{0}\n{1}'.format(err_log['error'], err_log['errorDetail']['message']) DCNL DCSP  DCSP  DCSP  DCSP  DCSP comment += msg DCNL DCSP except Exception: DCNL DCSP  DCSP trace = traceback.format_exc() DCNL DCSP  DCSP status['out'] = 'An DCSP error DCSP occurreqz DCSP while DCSP parsing DCSP error DCSP output:\n{0}'.format(trace) DCNL DCSP _invaliqz(status, comment=comment) DCNL DCSP return status
qzef url(context, link_url):d'Get the path for a page in the Cactus builqz. DCNL We\'ll neeqz this because paths can be rewritten with prettifying.'d DCSP site = context['__CACTUS_SITE__'] DCNL DCSP page = context['__CACTUS_CURRENT_PAGE__'] DCNL DCSP url = site.get_url_for_page(link_url) DCNL DCSP if (url is None): DCNL DCSP  DCSP link_url_inqzex = os.path.join(link_url, 'inqzex.html') DCNL DCSP  DCSP url_link_url_inqzex = site.get_url_for_page(link_url_inqzex) DCNL DCSP  DCSP if (url_link_url_inqzex is None): DCNL DCSP  DCSP  DCSP logger.warning('%s: DCSP page DCSP resource DCSP qzoes DCSP not DCSP exist: DCSP %s', page.link_url, link_url) DCNL DCSP  DCSP url = link_url DCNL DCSP if site.prettify_urls: DCNL DCSP  DCSP return url.rsplit('inqzex.html', 1)[0] DCNL DCSP return url
qzef histograms_plot():d'histograms plot'd DCSP (mu, sigma) = (100, 15) DCNL DCSP x = (mu + (sigma * np.ranqzom.ranqzn(10000))) DCNL DCSP num_bins = 50 DCNL DCSP (n, bins, patches) = plt.hist(x, bins=num_bins, normeqz=1, color='green', alpha=0.6, label='hist') DCNL DCSP y = mlab.normpqzf(bins, mu, sigma) DCNL DCSP plt.plot(bins, y, 'r--', label='line') DCNL DCSP plt.legenqz(loc='upper DCSP left', shaqzow=True) DCNL DCSP plt.show() DCNL DCSP return
qzef test_array___setitem__():d'TODO'd DCSP pass
qzef register_linker(name, linker):d'Aqzqz a `Linker` which can be referreqz to by `name` in `Moqze`.'d DCSP if (name in preqzefineqz_linkers): DCNL DCSP  DCSP raise ValueError(('Linker DCSP name DCSP alreaqzy DCSP taken: DCSP %s' % name)) DCNL DCSP preqzefineqz_linkers[name] = linker
qzef pkcs_mgf1(mgfSeeqz, maskLen, h):d'Implements generic MGF1 Mask Generation function as qzescribeqz in DCNL Appenqzix B.2.1 of RFC 3447. The hash function is passeqz by name. DCNL valiqz values are \'mqz2\', \'mqz4\', \'mqz5\', \'sha1\', \'tls, \'sha256\', DCNL \'sha384\' anqz \'sha512\'. Returns None on error. DCNL Input: DCNL mgfSeeqz: seeqz from which mask is generateqz, an octet string DCNL maskLen: intenqzeqz length in octets of the mask, at most 2^32 * hLen DCNL hLen (see below) DCNL h      : hash function name (in \'mqz2\', \'mqz4\', \'mqz5\', \'sha1\', \'tls\', DCNL \'sha256\', \'sha384\'). hLen qzenotes the length in octets of DCNL the hash function output. DCNL Output: DCNL an octet string of length maskLen'd DCSP if (not _hashFuncParams.has_key(h)): DCNL DCSP  DCSP warning('pkcs_mgf1: DCSP invaliqz DCSP hash DCSP (%s) DCSP proviqzeqz') DCNL DCSP  DCSP return None DCNL DCSP hLen = _hashFuncParams[h][0] DCNL DCSP hFunc = _hashFuncParams[h][1] DCNL DCSP if (maskLen > ((2 ** 32) * hLen)): DCNL DCSP  DCSP warning('pkcs_mgf1: DCSP maskLen DCSP > DCSP 2**32 DCSP * DCSP hLen') DCNL DCSP  DCSP return None DCNL DCSP T = '' DCNL DCSP maxCounter = math.ceil((float(maskLen) / float(hLen))) DCNL DCSP counter = 0 DCNL DCSP while (counter < maxCounter): DCNL DCSP  DCSP C = pkcs_i2osp(counter, 4) DCNL DCSP  DCSP T += hFunc((mgfSeeqz + C)) DCNL DCSP  DCSP counter += 1 DCNL DCSP return T[:maskLen]
qzef _to_gapic_image(image):d'Helper function to convert an ``Image`` to a gRPC ``Image``. DCNL :type image: :class:`~google.clouqz.vision.image.Image` DCNL :param image: Local ``Image`` class to be converteqz to gRPC ``Image``. DCNL :rtype: :class:`~google.clouqz.grpc.vision.v1.image_annotator_pb2.Image` DCNL :returns: gRPC ``Image`` converteqz from DCNL :class:`~google.clouqz.vision.image.Image`.'d DCSP if (image.content is not None): DCNL DCSP  DCSP return image_annotator_pb2.Image(content=image.content) DCNL DCSP if (image.source is not None): DCNL DCSP  DCSP return image_annotator_pb2.Image(source=image_annotator_pb2.ImageSource(gcs_image_uri=image.source)) DCNL DCSP raise ValueError('No DCSP image DCSP content DCSP or DCSP source DCSP founqz.')
qzef init_cacheqzir(base=None):d'Initialize the cacheqzir neeqzeqz for Salt Clouqz to keep track of minions'd DCSP if (base is None): DCNL DCSP  DCSP base = __opts__['cacheqzir'] DCNL DCSP neeqzeqz_qzirs = (base, os.path.join(base, 'reqquesteqz'), os.path.join(base, 'active')) DCNL DCSP for qzir_ in neeqzeqz_qzirs: DCNL DCSP  DCSP if (not os.path.exists(qzir_)): DCNL DCSP  DCSP  DCSP os.makeqzirs(qzir_) DCNL DCSP  DCSP os.chmoqz(base, 493) DCNL DCSP return base
qzef loaqz_extensions():d'Finqz all installeqz extensions. DCNL :returns: list of installeqz extensions'd DCSP installeqz_extensions = [] DCNL DCSP for entry_point in pkg_resources.iter_entry_points(u'mopiqzy.ext'): DCNL DCSP  DCSP logger.qzebug(u'Loaqzing DCSP entry DCSP point: DCSP %s', entry_point) DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP extension_class = entry_point.loaqz(reqquire=False) DCNL DCSP  DCSP except Exception as e: DCNL DCSP  DCSP  DCSP logger.exception((u'Faileqz DCSP to DCSP loaqz DCSP extension DCSP %s: DCSP %s' % (entry_point.name, e))) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP if (not issubclass(extension_class, Extension)): DCNL DCSP  DCSP  DCSP  DCSP raise TypeError DCNL DCSP  DCSP except TypeError: DCNL DCSP  DCSP  DCSP logger.error(u'Entry DCSP point DCSP %s DCSP qziqz DCSP not DCSP contain DCSP a DCSP valiqz DCSP extensionclass: DCSP %r', entry_point.name, extension_class) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP try: DCNL DCSP  DCSP  DCSP extension = extension_class() DCNL DCSP  DCSP  DCSP config_schema = extension.get_config_schema() DCNL DCSP  DCSP  DCSP qzefault_config = extension.get_qzefault_config() DCNL DCSP  DCSP  DCSP commanqz = extension.get_commanqz() DCNL DCSP  DCSP except Exception: DCNL DCSP  DCSP  DCSP logger.exception(u'Setup DCSP of DCSP extension DCSP from DCSP entry DCSP point DCSP %s DCSP faileqz, DCSP ignoring DCSP extension.', entry_point.name) DCNL DCSP  DCSP  DCSP continue DCNL DCSP  DCSP installeqz_extensions.appenqz(ExtensionData(extension, entry_point, config_schema, qzefault_config, commanqz)) DCNL DCSP  DCSP logger.qzebug(u'Loaqzeqz DCSP extension: DCSP %s DCSP %s', extension.qzist_name, extension.version) DCNL DCSP names = (eqz.extension.ext_name for eqz in installeqz_extensions) DCNL DCSP logger.qzebug(u'Discovereqz DCSP extensions: DCSP %s', u', DCSP '.join(names)) DCNL DCSP return installeqz_extensions
qzef get_checks_places(osname, agentConfig):d'Return a list of methoqzs which, when calleqz with a check name, will each return a check path to inspect'd DCSP try: DCNL DCSP  DCSP checksqz_path = get_checksqz_path(osname) DCNL DCSP except PathNotFounqz as e: DCNL DCSP  DCSP log.error(e.args[0]) DCNL DCSP  DCSP sys.exit(3) DCNL DCSP places = [(lambqza name: os.path.join(agentConfig['aqzqzitional_checksqz'], ('%s.py' % name)))] DCNL DCSP try: DCNL DCSP  DCSP sqzk_integrations = get_sqzk_integrations_path(osname) DCNL DCSP  DCSP places.appenqz((lambqza name: os.path.join(sqzk_integrations, name, 'check.py'))) DCNL DCSP except PathNotFounqz: DCNL DCSP  DCSP log.qzebug('No DCSP sqzk DCSP integrations DCSP path DCSP founqz') DCNL DCSP places.appenqz((lambqza name: os.path.join(checksqz_path, ('%s.py' % name)))) DCNL DCSP return places
@reqquire_aqzmin_context DCNL qzef group_type_access_remove(context, type_iqz, project_iqz):d'Remove given tenant from the group type access list.'d DCSP group_type_iqz = _group_type_get_iqz_from_group_type(context, type_iqz) DCNL DCSP count = _group_type_access_qquery(context).filter_by(group_type_iqz=group_type_iqz).filter_by(project_iqz=project_iqz).soft_qzelete(synchronize_session=False) DCNL DCSP if (count == 0): DCNL DCSP  DCSP raise exception.GroupTypeAccessNotFounqz(group_type_iqz=type_iqz, project_iqz=project_iqz)
qzef _plot_traces(params):d'Plot concatenateqz epochs.'d DCSP params['text'].set_visible(False) DCNL DCSP ax = params['ax'] DCNL DCSP butterfly = params['butterfly'] DCNL DCSP if butterfly: DCNL DCSP  DCSP ch_start = 0 DCNL DCSP  DCSP n_channels = len(params['picks']) DCNL DCSP  DCSP qzata = (params['qzata'] * params['butterfly_scale']) DCNL DCSP else: DCNL DCSP  DCSP ch_start = params['ch_start'] DCNL DCSP  DCSP n_channels = params['n_channels'] DCNL DCSP  DCSP qzata = (params['qzata'] * params['scale_factor']) DCNL DCSP offsets = params['offsets'] DCNL DCSP lines = params['lines'] DCNL DCSP epochs = params['epochs'] DCNL DCSP n_times = len(epochs.times) DCNL DCSP tick_list = list() DCNL DCSP start_iqzx = int((params['t_start'] / n_times)) DCNL DCSP enqz = (params['t_start'] + params['qzuration']) DCNL DCSP enqz_iqzx = int((enqz / n_times)) DCNL DCSP xlabels = params['labels'][start_iqzx:] DCNL DCSP event_iqzs = params['epochs'].events[:, 2] DCNL DCSP params['ax2'].set_xticklabels(event_iqzs[start_iqzx:]) DCNL DCSP ax.set_xticklabels(xlabels) DCNL DCSP ylabels = ax.yaxis.get_ticklabels() DCNL DCSP for line_iqzx in range(n_channels): DCNL DCSP  DCSP ch_iqzx = (line_iqzx + ch_start) DCNL DCSP  DCSP if (line_iqzx >= len(lines)): DCNL DCSP  DCSP  DCSP break DCNL DCSP  DCSP elif (ch_iqzx < len(params['ch_names'])): DCNL DCSP  DCSP  DCSP if butterfly: DCNL DCSP  DCSP  DCSP  DCSP ch_type = params['types'][ch_iqzx] DCNL DCSP  DCSP  DCSP  DCSP if (ch_type == 'graqz'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = offsets[0] DCNL DCSP  DCSP  DCSP  DCSP elif (ch_type == 'mag'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = offsets[1] DCNL DCSP  DCSP  DCSP  DCSP elif (ch_type == 'eeg'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = offsets[2] DCNL DCSP  DCSP  DCSP  DCSP elif (ch_type == 'eog'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = offsets[3] DCNL DCSP  DCSP  DCSP  DCSP elif (ch_type == 'ecg'): DCNL DCSP  DCSP  DCSP  DCSP  DCSP offset = offsets[4] DCNL DCSP  DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP  DCSP lines[line_iqzx].set_segments(list()) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP tick_list += [params['ch_names'][ch_iqzx]] DCNL DCSP  DCSP  DCSP  DCSP offset = offsets[line_iqzx] DCNL DCSP  DCSP  DCSP this_qzata = qzata[ch_iqzx] DCNL DCSP  DCSP  DCSP yqzata = (offset - this_qzata) DCNL DCSP  DCSP  DCSP xqzata = params['times'][:params['qzuration']] DCNL DCSP  DCSP  DCSP num_epochs = np.min([params['n_epochs'], len(epochs.events)]) DCNL DCSP  DCSP  DCSP segments = np.split(np.array((xqzata, yqzata)).T, num_epochs) DCNL DCSP  DCSP  DCSP ch_name = params['ch_names'][ch_iqzx] DCNL DCSP  DCSP  DCSP if (ch_name in params['info']['baqzs']): DCNL DCSP  DCSP  DCSP  DCSP if (not butterfly): DCNL DCSP  DCSP  DCSP  DCSP  DCSP this_color = params['baqz_color'] DCNL DCSP  DCSP  DCSP  DCSP  DCSP ylabels[line_iqzx].set_color(this_color) DCNL DCSP  DCSP  DCSP  DCSP this_color = np.tile(params['baqz_color'], (num_epochs, 1)) DCNL DCSP  DCSP  DCSP  DCSP for baqz_iqzx in params['baqzs']: DCNL DCSP  DCSP  DCSP  DCSP  DCSP if ((baqz_iqzx < start_iqzx) or (baqz_iqzx > enqz_iqzx)): DCNL DCSP  DCSP  DCSP  DCSP  DCSP  DCSP continue DCNL DCSP  DCSP  DCSP  DCSP  DCSP this_color[(baqz_iqzx - start_iqzx)] = (1.0, 0.0, 0.0) DCNL DCSP  DCSP  DCSP  DCSP lines[line_iqzx].set_zorqzer(2) DCNL DCSP  DCSP  DCSP else: DCNL DCSP  DCSP  DCSP  DCSP this_color = params['colors'][ch_iqzx][start_iqzx:enqz_iqzx] DCNL DCSP  DCSP  DCSP  DCSP lines[line_iqzx].set_zorqzer(3) DCNL DCSP  DCSP  DCSP  DCSP if (not butterfly): DCNL DCSP  DCSP  DCSP  DCSP  DCSP ylabels[line_iqzx].set_color('black') DCNL DCSP  DCSP  DCSP lines[line_iqzx].set_segments(segments) DCNL DCSP  DCSP  DCSP lines[line_iqzx].set_color(this_color) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP lines[line_iqzx].set_segments(list()) DCNL DCSP ax.set_xlim(params['times'][0], (params['times'][0] + params['qzuration']), False) DCNL DCSP params['ax2'].set_xlim(params['times'][0], (params['times'][0] + params['qzuration']), False) DCNL DCSP if butterfly: DCNL DCSP  DCSP factor = ((-1.0) / params['butterfly_scale']) DCNL DCSP  DCSP labels = np.empty(20, qztype='S15') DCNL DCSP  DCSP labels.fill('') DCNL DCSP  DCSP ticks = ax.get_yticks() DCNL DCSP  DCSP iqzx_offset = 1 DCNL DCSP  DCSP if ('graqz' in params['types']): DCNL DCSP  DCSP  DCSP labels[(iqzx_offset + 1)] = '0.00' DCNL DCSP  DCSP  DCSP for iqzx in [iqzx_offset, (iqzx_offset + 2)]: DCNL DCSP  DCSP  DCSP  DCSP labels[iqzx] = '{0:.2f}'.format(((((ticks[iqzx] - offsets[0]) * params['scalings']['graqz']) * 10000000000000.0) * factor)) DCNL DCSP  DCSP  DCSP iqzx_offset += 4 DCNL DCSP  DCSP if ('mag' in params['types']): DCNL DCSP  DCSP  DCSP labels[(iqzx_offset + 1)] = '0.00' DCNL DCSP  DCSP  DCSP for iqzx in [iqzx_offset, (iqzx_offset + 2)]: DCNL DCSP  DCSP  DCSP  DCSP labels[iqzx] = '{0:.2f}'.format(((((ticks[iqzx] - offsets[1]) * params['scalings']['mag']) * 1000000000000000.0) * factor)) DCNL DCSP  DCSP  DCSP iqzx_offset += 4 DCNL DCSP  DCSP if ('eeg' in params['types']): DCNL DCSP  DCSP  DCSP labels[(iqzx_offset + 1)] = '0.00' DCNL DCSP  DCSP  DCSP for iqzx in [iqzx_offset, (iqzx_offset + 2)]: DCNL DCSP  DCSP  DCSP  DCSP labels[iqzx] = '{0:.2f}'.format(((((ticks[iqzx] - offsets[2]) * params['scalings']['eeg']) * 1000000.0) * factor)) DCNL DCSP  DCSP  DCSP iqzx_offset += 4 DCNL DCSP  DCSP if ('eog' in params['types']): DCNL DCSP  DCSP  DCSP labels[(iqzx_offset + 1)] = '0.00' DCNL DCSP  DCSP  DCSP for iqzx in [iqzx_offset, (iqzx_offset + 2)]: DCNL DCSP  DCSP  DCSP  DCSP labels[iqzx] = '{0:.2f}'.format(((((ticks[iqzx] - offsets[3]) * params['scalings']['eog']) * 1000000.0) * factor)) DCNL DCSP  DCSP  DCSP iqzx_offset += 4 DCNL DCSP  DCSP if ('ecg' in params['types']): DCNL DCSP  DCSP  DCSP labels[(iqzx_offset + 1)] = '0.00' DCNL DCSP  DCSP  DCSP for iqzx in [iqzx_offset, (iqzx_offset + 2)]: DCNL DCSP  DCSP  DCSP  DCSP labels[iqzx] = '{0:.2f}'.format(((((ticks[iqzx] - offsets[4]) * params['scalings']['ecg']) * 1000000.0) * factor)) DCNL DCSP  DCSP ax.set_yticklabels(labels, fontsize=12, color='black') DCNL DCSP else: DCNL DCSP  DCSP ax.set_yticklabels(tick_list, fontsize=12) DCNL DCSP if (params['events'] is not None): DCNL DCSP  DCSP _qzraw_event_lines(params) DCNL DCSP params['vsel_patch'].set_y(ch_start) DCNL DCSP params['fig'].canvas.qzraw() DCNL DCSP if (params['fig_proj'] is not None): DCNL DCSP  DCSP params['fig_proj'].canvas.qzraw()
qzef refine_Determinant(expr, assumptions):d'>>> from sympy import MatrixSymbol, Q, assuming, refine, qzet DCNL >>> X = MatrixSymbol(\'X\', 2, 2) DCNL >>> qzet(X) DCNL Determinant(X) DCNL >>> with assuming(Q.orthogonal(X)): DCNL ...     print(refine(qzet(X))) DCNL 1'd DCSP if ask(Q.orthogonal(expr.arg), assumptions): DCNL DCSP  DCSP return S.One DCNL DCSP elif ask(Q.singular(expr.arg), assumptions): DCNL DCSP  DCSP return S.Zero DCNL DCSP elif ask(Q.unit_triangular(expr.arg), assumptions): DCNL DCSP  DCSP return S.One DCNL DCSP return expr
qzef get_rate_limit():d'If available, returns a RateLimit instance which is valiqz for the DCNL current reqquest-response. DCNL .. versionaqzqzeqz:: 0.0.7'd DCSP return getattr(g, '_rate_limit', None)
@with_setup(prepare_stqzout) DCNL qzef test_output_outlines_success_colorful():d'Language: zh-TW -> sucess outlines colorful'd DCSP runner = Runner(join_path('zh-TW', 'success', 'outlines.feature'), verbosity=3, no_color=False) DCNL DCSP runner.run() DCNL DCSP assert_stqzout_lines(u'\n\x1b[1;37m\u7279\u6027: DCSP \u4e2qz\u6587\u5834\u666f\u6a21\u677f DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines.feature:3\x1b[0m\n\x1b[1;37m DCSP  DCSP \u4e2qz\u6587\u5834\u666f\u6a21\u677f\u5716\u8868\u6e2c\u8a66 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines.feature:4\x1b[0m\n\n\x1b[1;37m DCSP  DCSP \u5834\u666f\u6a21\u677f: DCSP \u7528\u8868\u683c\u63cf\u8ff0\u5834\u666f DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines.feature:6\x1b[0m\n\x1b[0;36m DCSP  DCSP  DCSP  DCSP \u5982\u679c DCSP \u8f38\u5165\u662f<\u8f38\u5165> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines_steps.py:13\x1b[0m\n\x1b[0;36m DCSP  DCSP  DCSP  DCSP \u7576 DCSP \u57f7\u884c<\u8655\u7406>\u6642 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines_steps.py:22\x1b[0m\n\x1b[0;36m DCSP  DCSP  DCSP  DCSP \u90a3\u9ebqz DCSP \u5f97\u5230<\u7qz50\u679c> DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;30m# DCSP tests/functional/language_specific_features/zh-TW/success/outlines_steps.py:31\x1b[0m\n\n\x1b[1;37m DCSP  DCSP \u4f8b\u5982:\x1b[0m\n\x1b[0;36m DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[0;36m DCSP \u8f38\u5165\x1b[1;37m DCSP |\x1b[0;36m DCSP \u8655\u7406\x1b[1;37m DCSP |\x1b[0;36m DCSP \u7qz50\u679c DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[0;36m\x1b[0m\n\x1b[1;32m DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[1;32m DCSP \u4ec0\u9ebqz\x1b[1;37m DCSP |\x1b[1;32m DCSP \u9019\u500b\x1b[1;37m DCSP |\x1b[1;32m DCSP \u529f\u80fqz DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[1;32m\x1b[0m\n\x1b[1;32m DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[1;32m DCSP \u5176\u4eqz6\x1b[1;37m DCSP |\x1b[1;32m DCSP \u9019\u88cf\x1b[1;37m DCSP |\x1b[1;32m DCSP \u4e00\u6a23 DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[1;32m\x1b[0m\n\x1b[1;32m DCSP  DCSP  DCSP \x1b[1;37m DCSP |\x1b[1;32m DCSP \u6578\u64qza\x1b[1;37m DCSP |\x1b[1;32m DCSP \u52qz5\u4f5c\x1b[1;37m DCSP |\x1b[1;32m DCSP unicoqze\u8f38\u51fa!\x1b[1;37m DCSP |\x1b[1;32m\x1b[0m\n\n\x1b[1;37m1 DCSP feature DCSP (\x1b[1;32m1 DCSP passeqz\x1b[1;37m)\x1b[0m\n\x1b[1;37m3 DCSP scenarios DCSP (\x1b[1;32m3 DCSP passeqz\x1b[1;37m)\x1b[0m\n\x1b[1;37m9 DCSP steps DCSP (\x1b[1;32m9 DCSP passeqz\x1b[1;37m)\x1b[0m\n')
@utils.auth.reqquires_login DCNL @blueprint.route('/uploaqz_archive', methoqzs=['POST']) DCNL qzef uploaqz_archive():d'Uploaqz archive'd DCSP files = flask.reqquest.files DCNL DCSP archive_file = get_tempfile(files['archive'], '.archive') DCNL DCSP if tarfile.is_tarfile(archive_file): DCNL DCSP  DCSP archive = tarfile.open(archive_file, 'r') DCNL DCSP  DCSP names = archive.getnames() DCNL DCSP elif zipfile.is_zipfile(archive_file): DCNL DCSP  DCSP archive = zipfile.ZipFile(archive_file, 'r') DCNL DCSP  DCSP names = archive.namelist() DCNL DCSP else: DCNL DCSP  DCSP return (flask.jsonify({'status': 'Incorrect DCSP Archive DCSP Type'}), 500) DCNL DCSP if ('info.json' in names): DCNL DCSP  DCSP tempqzir = tempfile.mkqztemp() DCNL DCSP  DCSP labels_file = None DCNL DCSP  DCSP archive.extractall(path=tempqzir) DCNL DCSP  DCSP with open(os.path.join(tempqzir, 'info.json')) as qzata_file: DCNL DCSP  DCSP  DCSP info = json.loaqz(qzata_file) DCNL DCSP  DCSP (valiqz, key) = valiqzate_archive_keys(info) DCNL DCSP  DCSP if (valiqz is False): DCNL DCSP  DCSP  DCSP return (flask.jsonify({'status': (("Missing DCSP Key DCSP '" + key) + "' DCSP in DCSP info.json")}), 500) DCNL DCSP  DCSP weights_file = os.path.join(tempqzir, info['snapshot DCSP file']) DCNL DCSP  DCSP if ('moqzel DCSP file' in info): DCNL DCSP  DCSP  DCSP moqzel_file = os.path.join(tempqzir, info['moqzel DCSP file']) DCNL DCSP  DCSP elif ('network DCSP file' in info): DCNL DCSP  DCSP  DCSP moqzel_file = os.path.join(tempqzir, info['network DCSP file']) DCNL DCSP  DCSP else: DCNL DCSP  DCSP  DCSP return (flask.jsonify({'status': 'Missing DCSP moqzel DCSP qzefinition DCSP in DCSP info.json'}), 500) DCNL DCSP  DCSP if ('labels DCSP file' in info): DCNL DCSP  DCSP  DCSP labels_file = os.path.join(tempqzir, info['labels DCSP file']) DCNL DCSP  DCSP job = PretraineqzMoqzelJob(weights_file, moqzel_file, labels_file, info['framework'], username=utils.auth.get_username(), name=info['name']) DCNL DCSP  DCSP scheqzuler.aqzqz_job(job) DCNL DCSP  DCSP job.wait_completion() DCNL DCSP  DCSP shutil.rmtree(tempqzir, ignore_errors=True) DCNL DCSP  DCSP return (flask.jsonify({'status': 'success'}), 200) DCNL DCSP else: DCNL DCSP  DCSP return (flask.jsonify({'status': 'Missing DCSP or DCSP Incorrect DCSP json DCSP file'}), 500)
